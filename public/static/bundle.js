(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var iframe = require('windorfer')

var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];
var stringify = JSON.stringify;

module.exports = function (fn, name, params) {
    var keys = [];
    var wkey;
    var cacheKeys = Object.keys(cache);
    
    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        if (cache[key].exports === fn) {
            wkey = key;
            break;
        }
    }
    
    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function(['require','module','exports'], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
    
    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'],'require(' + stringify(wkey) + ')(self)'),
        scache
    ];
    
    var src = '(' + bundleFn + ')({'
        + Object.keys(sources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
     ;
    
    src = window.URL.createObjectURL(new Blob([src], {type:'text/javascript'}))
    src = '<script type=text/javascript src='+src+'></script>'
    var frame = iframe({body: src, name: name, params: params})
    return frame.ref
};

},{"windorfer":2}],2:[function(require,module,exports){
module.exports = function(opts) {
  return new IFrame(opts)
}

function IFrame(opts) {
  if (!opts) opts = {}
  this.opts = opts
  this.container = opts.container || document.body
  this.ref = this.setHTML(opts)
}

IFrame.prototype.parseHTMLOptions = function(opts) {
  if (typeof opts === 'string') opts = {html: opts}
  if (!opts) opts = {}
  if (true) {
    if (!opts.body) opts.body = ""
    if (!opts.head) opts.head = ""
    opts.html = '<!DOCTYPE html><html><head>' + opts.head + '</head><body>' + opts.body + '</body></html>'
  }
  if (!opts.sandboxAttributes) opts.sandboxAttributes = ['allow-scripts']
  return opts
}

IFrame.prototype.remove = function() {
//  if (this.iframe) this.container.removeChild(this.iframe)
}

IFrame.prototype.setHTML = function(opts) {
  opts = this.parseHTMLOptions(opts)
  if (!opts.html) return
//  this.remove()
  // create a blob for opts.html and set as iframe `src` attribute
  var blob = new Blob([opts.html], { encoding: 'UTF-8', type: 'text/html' })
  var U = typeof URL !== 'undefined' ? URL : webkitURL
  var targetUrl = U.createObjectURL(blob)
  // create temporary iframe for generating HTML string
  // element is inserted into the DOM as a string so that the security policies do not interfere
  // see: https://gist.github.com/kumavis/8202447
  var frame = document.createElement('iframe')
  frame.src = targetUrl

  //var w = window.open(targetUrl, opts.name || 'johnny', opts.params || '')
  return frame
}

},{}],3:[function(require,module,exports){
// handles audio files and raw, mono, audio buffers

module.exports = function(context, buff, cb){
  
  var name = buff.constructor.name
  //if(Math.random() < .05) console.log(buff)
  if(name == 'ArrayBuffer'){
    context.decodeAudioData(buff).then(function(data){
      var source = context.createBufferSource()
      source.buffer = data
/*      var gain = context.createGain()
      gain.channelCount = 1
      gain.channelCountMode = 'explicit'
      gain.channelInterpretation = 'speakers'
      source.connect(gain)
      source._connect = source.connect
      source.connect = gain.connect
 */     cb(null, source) 
    }).catch(function(err){cb(err, null)})
	
  }else if(name == 'Array'){
  
    var source = context.createBufferSource();
      
    var buffer = context.createBuffer(2, buff[0].length, context.sampleRate)

    try{ // new
      buffer.copyToChannel(buff[0], 0, 0)
      buffer.copyToChannel(buff[1], 1, 0)

    }catch(err){ // old
      //buffer.getChannelData(0).set(buff)
    }
    
    source.buffer = buffer;
    
    /*
    var gain = context.createGain()
    gain.channelCount = 2
    gain.channelCountMode = 'explicit'
    gain.channelInterpretation = 'speakers'
    source.gain = gain
    source.connect(gain)
    source._connect = source.connect
    source.connect = gain.connect
    if(cb) cb(null, source)
    */
    return source
  }
}

},{}],4:[function(require,module,exports){
module.exports = function(master, stream){
    var node = master.createMediaStreamSource(stream)
    var gain = master.createGain()
    gain.channelCount = 1
    gain.channelCountMode = 'explicit'
    gain. channelInterpretation = 'speakers'
    node.connect(gain)
    return gain
}

},{}],5:[function(require,module,exports){
(function (Buffer){(function (){
module.exports = function(self){
  self.addEventListener('load', etc => {
    const WebAudioContext = window.AudioContext || window.webkitAudioContext
    var master 
    var Emitter = require('events')//.EventEmitter //require('./sharedEmitter')
    var bus = new Emitter()
    bus.once('iframeLoaded', e => {
      console.log(e)
      bus.emit('pong', {goat: 1})
      bus.on('clock', e => console.log(e))
    })
    //var iframe = require('../iframarfi')
    //var peering = iframe(require('./peering.js'))
    //ui.peering.appendChild(peering)
    
    const short = require('short-uuid');
    const toa = require('to-arraybuffer')
    const btob = require('blob-to-buffer')
    const thru = require('through2')
    var store = require('store')
    var h = require('hyperscript')
    var shajs = require('sha.js')
    const Time = require('../since-when')
    var jmic = require('../jsynth-mic/stream')
    var sampler = require('../jsynth-file-sample')
    var media 
    var interval = 20
    var mime = 'audio/ogg;codecs=opus'
    var runp =require('run-waterfall')
    var {OggOpusDecoder} = require('ogg-opus-decoder')
    var OpusMediaRecorder = require('opus-media-recorder') 
    window.MediaRecorder = OpusMediaRecorder;

    broadcasting = !self.parent.location.hash.length
    var bps = 48000
    try{
    getApp(broadcasting, (err, audio) =>{
      console.log(err, audio)
      self.parent.postMessage({type: 'debug', data: err})
      self.addEventListener('message', msg =>{
      //console.log(msg)
        switch (msg.data.type){
          case 'param':
            console.log(msg)
            audio[msg.data.id].gain.value = Math.max(0, msg.data.data)
          break;
          case 'start':
            
          break;
          case 'resume':
            audio.master.resume()
          break;
          case 'captureMic':
            audio.master.resume()
            audio.captureMic((err, mic)=>{
      self.parent.postMessage({type: 'debug', data: err})
      self.parent.postMessage({type: 'debug', data: !!mic})
          //    let {encoder, node}  = audio.createEncoder(msg.data.id)
          //    encoder.start(interval)
            })
            //setTimeout(e => {audio.broadcastencoder.stop()}, 3000)
          break;
          case 'startBroadcast':
            audio.master.resume()
            audio.captureMic((err, mic)=>{
      self.parent.postMessage({type: 'debug', data: err})
      self.parent.postMessage({type: 'debug', data: !!mic})
              let {encoder, node}  = audio.createEncoder(audio.splitter, 'record')
              encoder.start(interval)
            })
            //setTimeout(e => {audio.broadcastencoder.stop()}, 3000)
          break;
          case 'addPeer':
            let source = msg.data.data == 'broadcast' ? audio.splitter : audio.callmixer
            let {encoder, node} = audio.createEncoder(source, msg.data.id)
            encoder.start(msg.data.interval || interval)
          break;
          case 'stopBroadcast':
            audio.encoders['record'].stop()
          break;
          case 'callBuffer':
            //console.log(new shajs('sha256').update(msg.data.data).digest('hex'),msg.data.data.length)
          //app._log(new shajs('sha256').update(ab).digest('hex'))
          console.log(msg)
          audio.calldecoder.decode(msg.data.data) 

          //cb(null, audio) 
          break;
          case 'sourceBuffer':
            //console.log(new shajs('sha256').update(msg.data.data).digest('hex'),msg.data.data.length)
          //app._log(new shajs('sha256').update(ab).digest('hex'))
          audio.sourcedecoder.decode(msg.data.data) 

          //cb(null, audio) 
          break;
          case 'addAudioTrack':
            audio.addAudioTrack(msg.data.id,  msg.data.data)
          break;
          case 'audioTrackControl':
            let track = audio.tracks[msg.data.id] //= msg.data.data
            let cmd = data.msg.data
            audio[cmd](track)
          break;
          
        }
      })
    })} catch(err){
      self.parent.postMessage({type: 'debug', data: err.toString()})
    
    }

      function getApp(broadcasting, cb){

    class App extends require('events').EventEmitter {
    
      constructor(master, broadcasting=true){
        super()
        this.broadcasting = broadcasting
        this.decoders = {}
        this.encoders = {}
        this.tracks = {}
        this.master = master
        this.mixer = master.createChannelMerger(12)
        this.callmixer = master.createChannelMerger(2)
        this.monitormix = master.createChannelMerger(12)
        this.monitor = master.createGain()
        this.splitter = master.createChannelSplitter(12)
        this.mic = master.createGain()
        this.call = master.createGain()
        this.track = master.createGain()
        this.source = master.createGain()

        this.mixer.connect(this.splitter)

        this.monitormix.connect(this.monitor)
        this.monitor.connect(master.destination)

        this.mic.connect(this.callmixer)
        this.track.connect(this.callmixer)
        
        this.createDecoder(this.call, ({decoder}) => {
          this.calldecoder = decoder
         })
        this.createDecoder(this.source, ({decoder}) => {
          this.sourcedecoder = decoder
         })
        
        if(broadcasting){
          this.mic.connect(this.mixer)
          this.call.connect(this.mixer)
          this.track.connect(this.mixer)
          this.mic.connect(this.monitormix)
          this.call.connect(this.monitormix)
          this.track.connect(this.monitormix)
        }

        else{
          this.source.connect(this.monitormix)
          this.call.connect(this.monitormix)
        }

      }

      addAudioTrack(id, buf){
        var a = h('audio.invert', {controls: true, id: id, src : URL.createObjectURL(buf)})
        document.body.appendChild(a)
        var c = this.master.createMediaElementSource(a)
        console.log(a)
        //a.loop = true
        c.connect(this.track)

      }

      play(id){
        
      }

      captureMic (cb, connect) {
      // TODO source is either the mediastream or a peer connection
        const self = this
        addMedia((err, stream) =>{

          if(err) console.log(err)

          const mic = self.master.createMediaStreamSource(stream) 
          mic.connect(self.mic)

          self.mediastream = stream
          self.micnode = mic
      
          cb(err, stream)
          
        
        })
      }


      createDecoder(connect, cb){
      
        async function wsm(self, connect, cb){

          const decoder = new OggOpusDecoder({onDecode, onDecodeAll})

          function onDecode () {
          }

          function onDecodeAll ({channelData, samplesDecoded, sampleRate}) {
            //console.log(channelData)
            //console.log({samplesDecoded, sampleRate})
            let sam = sampler(self.master, channelData)
            sam.connect(connect)
            sam.start(0)
          }

          await decoder.ready

          let pid = short().generate()

          self.decoders[pid] = {
            decoder: decoder
          }

          if(cb) cb({decoder, pid})
          
        }

        wsm(this, connect, cb)

      }

      createEncoder(source, id, cb){
        const workerOptions = {
          encoderWorkerFactory: function () {
            return new Worker(tob(Buffer("CihmdW5jdGlvbiBPcHVzTWVkaWFXb3JrZXJVTUQocm9vdCwgZmFjdG9yeSkgewogIGlmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmCiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHsKICAgIHZhciBpbml0V29ya2VyID0gZmFjdG9yeSgpOwogICAgaW5pdFdvcmtlcigpOwogIH0KCWVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKQoJCW1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOwoJZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpCgkJZGVmaW5lKFtdLCBmYWN0b3J5KTsKCWVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKQoJCWV4cG9ydHNbImVuY29kZXJXb3JrZXIiXSA9IGZhY3RvcnkoKTsKCWVsc2UKCQlyb290WyJlbmNvZGVyV29ya2VyIl0gPSBmYWN0b3J5KCk7Cn0pKHR5cGVvZiBPcHVzTWVkaWFSZWNvcmRlciAhPT0gJ3VuZGVmaW5lZCcgPyBPcHVzTWVkaWFSZWNvcmRlciA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHsKcmV0dXJuIGZ1bmN0aW9uKCkgeyFmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiBuKHIpe2lmKHRbcl0pcmV0dXJuIHRbcl0uZXhwb3J0czt2YXIgbz10W3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtyXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxuKSxvLmw9ITAsby5leHBvcnRzfW4ubT1lLG4uYz10LG4uZD1mdW5jdGlvbihlLHQscil7bi5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0OnJ9KX0sbi5yPWZ1bmN0aW9uKGUpeyJ1bmRlZmluZWQiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6Ik1vZHVsZSJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSl9LG4udD1mdW5jdGlvbihlLHQpe2lmKDEmdCYmKGU9bihlKSksOCZ0KXJldHVybiBlO2lmKDQmdCYmIm9iamVjdCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHI9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihuLnIociksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJiJzdHJpbmciIT10eXBlb2YgZSlmb3IodmFyIG8gaW4gZSluLmQocixvLGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfS5iaW5kKG51bGwsbykpO3JldHVybiByfSxuLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIG4uZCh0LCJhIix0KSx0fSxuLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LG4ucD0iIixuKG4ucz01KX0oW2Z1bmN0aW9uKGUsdCxuKXsoZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihlLHQpe2Zvcih2YXIgbj0wLHI9ZS5sZW5ndGgtMTtyPj0wO3ItLSl7dmFyIG89ZVtyXTsiLiI9PT1vP2Uuc3BsaWNlKHIsMSk6Ii4uIj09PW8/KGUuc3BsaWNlKHIsMSksbisrKTpuJiYoZS5zcGxpY2UociwxKSxuLS0pfWlmKHQpZm9yKDtuLS07billLnVuc2hpZnQoIi4uIik7cmV0dXJuIGV9ZnVuY3Rpb24gcihlLHQpe2lmKGUuZmlsdGVyKXJldHVybiBlLmZpbHRlcih0KTtmb3IodmFyIG49W10scj0wO3I8ZS5sZW5ndGg7cisrKXQoZVtyXSxyLGUpJiZuLnB1c2goZVtyXSk7cmV0dXJuIG59dC5yZXNvbHZlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PSIiLG89ITEsaT1hcmd1bWVudHMubGVuZ3RoLTE7aT49LTEmJiFvO2ktLSl7dmFyIHU9aT49MD9hcmd1bWVudHNbaV06ZS5jd2QoKTtpZigic3RyaW5nIiE9dHlwZW9mIHUpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MiKTt1JiYodD11KyIvIit0LG89Ii8iPT09dS5jaGFyQXQoMCkpfXJldHVybihvPyIvIjoiIikrKHQ9bihyKHQuc3BsaXQoIi8iKSwoZnVuY3Rpb24oZSl7cmV0dXJuISFlfSkpLCFvKS5qb2luKCIvIikpfHwiLiJ9LHQubm9ybWFsaXplPWZ1bmN0aW9uKGUpe3ZhciBpPXQuaXNBYnNvbHV0ZShlKSx1PSIvIj09PW8oZSwtMSk7cmV0dXJuKGU9bihyKGUuc3BsaXQoIi8iKSwoZnVuY3Rpb24oZSl7cmV0dXJuISFlfSkpLCFpKS5qb2luKCIvIikpfHxpfHwoZT0iLiIpLGUmJnUmJihlKz0iLyIpLChpPyIvIjoiIikrZX0sdC5pc0Fic29sdXRlPWZ1bmN0aW9uKGUpe3JldHVybiIvIj09PWUuY2hhckF0KDApfSx0LmpvaW49ZnVuY3Rpb24oKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cmV0dXJuIHQubm9ybWFsaXplKHIoZSwoZnVuY3Rpb24oZSx0KXtpZigic3RyaW5nIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MiKTtyZXR1cm4gZX0pKS5qb2luKCIvIikpfSx0LnJlbGF0aXZlPWZ1bmN0aW9uKGUsbil7ZnVuY3Rpb24gcihlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoJiYiIj09PWVbdF07dCsrKTtmb3IodmFyIG49ZS5sZW5ndGgtMTtuPj0wJiYiIj09PWVbbl07bi0tKTtyZXR1cm4gdD5uP1tdOmUuc2xpY2UodCxuLXQrMSl9ZT10LnJlc29sdmUoZSkuc3Vic3RyKDEpLG49dC5yZXNvbHZlKG4pLnN1YnN0cigxKTtmb3IodmFyIG89cihlLnNwbGl0KCIvIikpLGk9cihuLnNwbGl0KCIvIikpLHU9TWF0aC5taW4oby5sZW5ndGgsaS5sZW5ndGgpLGE9dSxzPTA7czx1O3MrKylpZihvW3NdIT09aVtzXSl7YT1zO2JyZWFrfXZhciBjPVtdO2ZvcihzPWE7czxvLmxlbmd0aDtzKyspYy5wdXNoKCIuLiIpO3JldHVybihjPWMuY29uY2F0KGkuc2xpY2UoYSkpKS5qb2luKCIvIil9LHQuc2VwPSIvIix0LmRlbGltaXRlcj0iOiIsdC5kaXJuYW1lPWZ1bmN0aW9uKGUpe2lmKCJzdHJpbmciIT10eXBlb2YgZSYmKGUrPSIiKSwwPT09ZS5sZW5ndGgpcmV0dXJuIi4iO2Zvcih2YXIgdD1lLmNoYXJDb2RlQXQoMCksbj00Nz09PXQscj0tMSxvPSEwLGk9ZS5sZW5ndGgtMTtpPj0xOy0taSlpZig0Nz09PSh0PWUuY2hhckNvZGVBdChpKSkpe2lmKCFvKXtyPWk7YnJlYWt9fWVsc2Ugbz0hMTtyZXR1cm4tMT09PXI/bj8iLyI6Ii4iOm4mJjE9PT1yPyIvIjplLnNsaWNlKDAscil9LHQuYmFzZW5hbWU9ZnVuY3Rpb24oZSx0KXt2YXIgbj1mdW5jdGlvbihlKXsic3RyaW5nIiE9dHlwZW9mIGUmJihlKz0iIik7dmFyIHQsbj0wLHI9LTEsbz0hMDtmb3IodD1lLmxlbmd0aC0xO3Q+PTA7LS10KWlmKDQ3PT09ZS5jaGFyQ29kZUF0KHQpKXtpZighbyl7bj10KzE7YnJlYWt9fWVsc2UtMT09PXImJihvPSExLHI9dCsxKTtyZXR1cm4tMT09PXI/IiI6ZS5zbGljZShuLHIpfShlKTtyZXR1cm4gdCYmbi5zdWJzdHIoLTEqdC5sZW5ndGgpPT09dCYmKG49bi5zdWJzdHIoMCxuLmxlbmd0aC10Lmxlbmd0aCkpLG59LHQuZXh0bmFtZT1mdW5jdGlvbihlKXsic3RyaW5nIiE9dHlwZW9mIGUmJihlKz0iIik7Zm9yKHZhciB0PS0xLG49MCxyPS0xLG89ITAsaT0wLHU9ZS5sZW5ndGgtMTt1Pj0wOy0tdSl7dmFyIGE9ZS5jaGFyQ29kZUF0KHUpO2lmKDQ3IT09YSktMT09PXImJihvPSExLHI9dSsxKSw0Nj09PWE/LTE9PT10P3Q9dToxIT09aSYmKGk9MSk6LTEhPT10JiYoaT0tMSk7ZWxzZSBpZighbyl7bj11KzE7YnJlYWt9fXJldHVybi0xPT09dHx8LTE9PT1yfHwwPT09aXx8MT09PWkmJnQ9PT1yLTEmJnQ9PT1uKzE/IiI6ZS5zbGljZSh0LHIpfTt2YXIgbz0iYiI9PT0iYWIiLnN1YnN0cigtMSk/ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlLnN1YnN0cih0LG4pfTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHQ8MCYmKHQ9ZS5sZW5ndGgrdCksZS5zdWJzdHIodCxuKX19KS5jYWxsKHRoaXMsbigyKSl9LGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbihlKXtyZXR1cm4obj0iZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYic3ltYm9sIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiYiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT8ic3ltYm9sIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIHIoZSx0KXtpZigiZnVuY3Rpb24iIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmbyhlLHQpfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4obz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX0pKGUsdCl9ZnVuY3Rpb24gaShlKXt2YXIgdD1mdW5jdGlvbigpe2lmKCJ1bmRlZmluZWQiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoImZ1bmN0aW9uIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBuLHI9YShlKTtpZih0KXt2YXIgbz1hKHRoaXMpLmNvbnN0cnVjdG9yO249UmVmbGVjdC5jb25zdHJ1Y3Qocixhcmd1bWVudHMsbyl9ZWxzZSBuPXIuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB1KHRoaXMsbil9fWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm4hdHx8Im9iamVjdCIhPT1uKHQpJiYiZnVuY3Rpb24iIT10eXBlb2YgdD9mdW5jdGlvbihlKXtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7cmV0dXJuIGV9KGUpOnR9ZnVuY3Rpb24gYShlKXtyZXR1cm4oYT1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfSkoZSl9ZnVuY3Rpb24gcyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfWZ1bmN0aW9uIGMoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBmKGUsdCxuKXtyZXR1cm4gdCYmYyhlLnByb3RvdHlwZSx0KSxuJiZjKGUsbiksZX12YXIgbD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIsbyl7c3dpdGNoKHModGhpcyxlKSx0aGlzLl9zaXplPW4sdGhpcy5fbW9kdWxlPXQsdGhpcy5fc2l6ZSl7Y2FzZSAxOnRoaXMuX2hlYXBBcnJheT1yP3RoaXMuX21vZHVsZS5IRUFQODp0aGlzLl9tb2R1bGUuSEVBUFU4O2JyZWFrO2Nhc2UgMjp0aGlzLl9oZWFwQXJyYXk9cj90aGlzLl9tb2R1bGUuSEVBUDE2OnRoaXMuX21vZHVsZS5IRUFQVTE2O2JyZWFrO2Nhc2UgNDp0aGlzLl9oZWFwQXJyYXk9cj90aGlzLl9tb2R1bGUuSEVBUDMyOnRoaXMuX21vZHVsZS5IRUFQVTMyO2JyZWFrO2RlZmF1bHQ6dGhpcy5faGVhcEFycmF5PXRoaXMuX21vZHVsZS5IRUFQVTh9byYmKHRoaXMuX3NpemU9NCx0aGlzLl9oZWFwQXJyYXk9dGhpcy5fbW9kdWxlLkhFQVBGMzIpLHRoaXMuX3BvaW50ZXI9dGhpcy5fbW9kdWxlLl9tYWxsb2Mobil9cmV0dXJuIGYoZSxbe2tleToiZnJlZSIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9tb2R1bGUuX2ZyZWUodGhpcy5wb2ludGVyKX19LHtrZXk6InBvaW50ZXIiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wb2ludGVyfX0se2tleToidmFsdWUiLGdldDpmdW5jdGlvbigpe3ZhciBlPTA7c3dpdGNoKHRoaXMuX3NpemUpe2Nhc2UgMjplPTE7YnJlYWs7Y2FzZSA0OmU9MjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiUG9pbnRlciBjYW4gYmUgb25seSBkZWZlcmVuY2VkIGFzIGludGVnZXItc2l6ZWQiKX1yZXR1cm4gdGhpcy5faGVhcEFycmF5W3RoaXMucG9pbnRlcj4+ZV19LHNldDpmdW5jdGlvbihlKXt2YXIgdD0wO3N3aXRjaCh0aGlzLl9zaXplKXtjYXNlIDI6dD0xO2JyZWFrO2Nhc2UgNDp0PTI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIlBvaW50ZXIgY2FuIGJlIG9ubHkgZGVmZXJlbmNlZCBhcyBpbnRlZ2VyLXNpemVkIil9dGhpcy5faGVhcEFycmF5W3RoaXMucG9pbnRlcj4+dF09ZX19XSksZX0oKSxwPWZ1bmN0aW9uKGUpe3IobixlKTt2YXIgdD1pKG4pO2Z1bmN0aW9uIG4oZSxyKXt2YXIgbztyZXR1cm4gcyh0aGlzLG4pLG89dC5jYWxsKHRoaXMsZSw0LCEwLCExKSx2b2lkIDAhPT1yJiYoby52YWx1ZT1yKSxvfXJldHVybiBufShsKSxfPWZ1bmN0aW9uKGUpe3IobixlKTt2YXIgdD1pKG4pO2Z1bmN0aW9uIG4oZSxyKXt2YXIgbztyZXR1cm4gcyh0aGlzLG4pLG89dC5jYWxsKHRoaXMsZSw0LCExLCExKSx2b2lkIDAhPT1yJiYoby52YWx1ZT1yKSxvfXJldHVybiBufShsKSxkPWZ1bmN0aW9uKGUpe3IobixlKTt2YXIgdD1pKG4pO2Z1bmN0aW9uIG4oZSxyLG8saSx1KXt2YXIgYTtzKHRoaXMsbiksYT10LmNhbGwodGhpcyxlLHIqbyxpLHUpO3ZhciBjPTA7c3dpdGNoKG8pe2Nhc2UgMTphLl9oZWFwQXJyYXk9aT9hLl9tb2R1bGUuSEVBUDg6YS5fbW9kdWxlLkhFQVBVOCxjPTA7YnJlYWs7Y2FzZSAyOmEuX2hlYXBBcnJheT1pP2EuX21vZHVsZS5IRUFQMTY6YS5fbW9kdWxlLkhFQVBVMTYsYz0xO2JyZWFrO2Nhc2UgNDphLl9oZWFwQXJyYXk9aT9hLl9tb2R1bGUuSEVBUDMyOmEuX21vZHVsZS5IRUFQVTMyLGM9MjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5pdCBzaXplIG11c3QgYmUgYW4gaW50ZWdlci1zaXplIil9dSYmKGEuX2hlYXBBcnJheT1hLl9tb2R1bGUuSEVBUEYzMixjPTIpO3ZhciBmPWEuX3BvaW50ZXI+PmM7cmV0dXJuIGEuX2J1ZmZlcj1hLl9oZWFwQXJyYXkuc3ViYXJyYXkoZixmK3IpLGEuX2xlbmd0aD1yLGF9cmV0dXJuIGYobixbe2tleToic2V0Iix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuX2J1ZmZlci5zZXQoZSx0KX19LHtrZXk6InN1YmFycmF5Iix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9idWZmZXIuc3ViYXJyYXkoZSx0KX19LHtrZXk6Imxlbmd0aCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xlbmd0aH19XSksbn0obCksaD1mdW5jdGlvbihlKXtyKG4sZSk7dmFyIHQ9aShuKTtmdW5jdGlvbiBuKGUscil7cmV0dXJuIHModGhpcyxuKSx0LmNhbGwodGhpcyxlLHIsNCwhMCwhMCl9cmV0dXJuIG59KGQpLG09ZnVuY3Rpb24oZSl7cihuLGUpO3ZhciB0PWkobik7ZnVuY3Rpb24gbihlLHIpe3JldHVybiBzKHRoaXMsbiksdC5jYWxsKHRoaXMsZSxyLDEsITEsITEpfXJldHVybiBufShkKSx5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtzKHRoaXMsZSksdGhpcy5fbW9kdWxlPXR9cmV0dXJuIGYoZSxbe2tleToibWFsbG9jSW50MzIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgcCh0aGlzLl9tb2R1bGUsZSl9fSx7a2V5OiJtYWxsb2NVaW50MzIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgXyh0aGlzLl9tb2R1bGUsZSl9fSx7a2V5OiJtYWxsb2NVaW50OEJ1ZmZlciIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBtKHRoaXMuX21vZHVsZSxlKX19LHtrZXk6Im1hbGxvY0Zsb2F0MzJCdWZmZXIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgaCh0aGlzLl9tb2R1bGUsZSl9fV0pLGV9KCk7ZS5leHBvcnRzPXt3cml0ZVN0cmluZzpmdW5jdGlvbihlLHQsbil7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspZS5zZXRVaW50OCh0K3Isbi5jaGFyQ29kZUF0KHIpKX0sRW1zY3JpcHRlbk1lbW9yeUFsbG9jYXRvcjp5fX0sZnVuY3Rpb24oZSx0KXt2YXIgbixyLG89ZS5leHBvcnRzPXt9O2Z1bmN0aW9uIGkoKXt0aHJvdyBuZXcgRXJyb3IoInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX1mdW5jdGlvbiB1KCl7dGhyb3cgbmV3IEVycm9yKCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX1mdW5jdGlvbiBhKGUpe2lmKG49PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KGUsMCk7aWYoKG49PT1pfHwhbikmJnNldFRpbWVvdXQpcmV0dXJuIG49c2V0VGltZW91dCxzZXRUaW1lb3V0KGUsMCk7dHJ5e3JldHVybiBuKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlLDApfX19IWZ1bmN0aW9uKCl7dHJ5e249ImZ1bmN0aW9uIj09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDppfWNhdGNoKGUpe249aX10cnl7cj0iZnVuY3Rpb24iPT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDp1fWNhdGNoKGUpe3I9dX19KCk7dmFyIHMsYz1bXSxmPSExLGw9LTE7ZnVuY3Rpb24gcCgpe2YmJnMmJihmPSExLHMubGVuZ3RoP2M9cy5jb25jYXQoYyk6bD0tMSxjLmxlbmd0aCYmXygpKX1mdW5jdGlvbiBfKCl7aWYoIWYpe3ZhciBlPWEocCk7Zj0hMDtmb3IodmFyIHQ9Yy5sZW5ndGg7dDspe2ZvcihzPWMsYz1bXTsrK2w8dDspcyYmc1tsXS5ydW4oKTtsPS0xLHQ9Yy5sZW5ndGh9cz1udWxsLGY9ITEsZnVuY3Rpb24oZSl7aWYocj09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KGUpO2lmKChyPT09dXx8IXIpJiZjbGVhclRpbWVvdXQpcmV0dXJuIHI9Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dChlKTt0cnl7cihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlKX19fShlKX19ZnVuY3Rpb24gZChlLHQpe3RoaXMuZnVuPWUsdGhpcy5hcnJheT10fWZ1bmN0aW9uIGgoKXt9by5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciBuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0W24tMV09YXJndW1lbnRzW25dO2MucHVzaChuZXcgZChlLHQpKSwxIT09Yy5sZW5ndGh8fGZ8fGEoXyl9LGQucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LG8udGl0bGU9ImJyb3dzZXIiLG8uYnJvd3Nlcj0hMCxvLmVudj17fSxvLmFyZ3Y9W10sby52ZXJzaW9uPSIiLG8udmVyc2lvbnM9e30sby5vbj1oLG8uYWRkTGlzdGVuZXI9aCxvLm9uY2U9aCxvLm9mZj1oLG8ucmVtb3ZlTGlzdGVuZXI9aCxvLnJlbW92ZUFsbExpc3RlbmVycz1oLG8uZW1pdD1oLG8ucHJlcGVuZExpc3RlbmVyPWgsby5wcmVwZW5kT25jZUxpc3RlbmVyPWgsby5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119LG8uYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkIil9LG8uY3dkPWZ1bmN0aW9uKCl7cmV0dXJuIi8ifSxvLmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcigicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkIil9LG8udW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBlLndlYnBhY2tQb2x5ZmlsbHx8KGUuZGVwcmVjYXRlPWZ1bmN0aW9uKCl7fSxlLnBhdGhzPVtdLGUuY2hpbGRyZW58fChlLmNoaWxkcmVuPVtdKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwibG9hZGVkIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZS5sfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJpZCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGUuaX19KSxlLndlYnBhY2tQb2x5ZmlsbD0xKSxlfX0sZnVuY3Rpb24oZSx0KXt9LGZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUpe3ZhciB0LHI9big2KSxvPW4oNyksaT1uKDgpO2Uub25tZXNzYWdlPWZ1bmN0aW9uKGUpe3ZhciBuPWUuZGF0YS5jb21tYW5kO3N3aXRjaChuKXtjYXNlImxvYWRFbmNvZGVyIjp2YXIgdSxhPWUuZGF0YSxzPWEubWltZVR5cGUsYz1hLndhc21QYXRoO3N3aXRjaChzKXtjYXNlImF1ZGlvL3dhdiI6Y2FzZSJhdWRpby93YXZlIjp1PXI7YnJlYWs7Y2FzZSJhdWRpby93ZWJtIjp1PW87YnJlYWs7Y2FzZSJhdWRpby9vZ2ciOnU9aX12YXIgZj17fTtjJiYoZi5sb2NhdGVGaWxlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubWF0Y2goLy53YXNtLyk/Yzp0K2V9KSx1KGYpLnRoZW4oKGZ1bmN0aW9uKGUpe3Q9ZSxzZWxmLnBvc3RNZXNzYWdlKHtjb21tYW5kOiJyZWFkeVRvSW5pdCJ9KX0pKTticmVhaztjYXNlImluaXQiOnZhciBsPWUuZGF0YSxwPWwuc2FtcGxlUmF0ZSxfPWwuY2hhbm5lbENvdW50LGQ9bC5iaXRzUGVyU2Vjb25kO3QuaW5pdChwLF8sZCk7YnJlYWs7Y2FzZSJwdXNoSW5wdXREYXRhIjpmb3IodmFyIGg9ZS5kYXRhLG09aC5jaGFubmVsQnVmZmVycyx5PShoLmxlbmd0aCxoLmR1cmF0aW9uLDApO3k8bS5sZW5ndGg7eSsrKW1beV09bmV3IEZsb2F0MzJBcnJheShtW3ldLmJ1ZmZlcik7dC5lbmNvZGUobSk7YnJlYWs7Y2FzZSJnZXRFbmNvZGVkRGF0YSI6Y2FzZSJkb25lIjoiZG9uZSI9PT1uJiZ0LmNsb3NlKCk7dmFyIHY9dC5mbHVzaCgpO3NlbGYucG9zdE1lc3NhZ2Uoe2NvbW1hbmQ6ImRvbmUiPT09bj8ibGFzdEVuY29kZWREYXRhIjoiZW5jb2RlZERhdGEiLGJ1ZmZlcnM6dn0sdiksImRvbmUiPT09biYmc2VsZi5jbG9zZSgpfX19InVuZGVmaW5lZCIhPXR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSYmc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlJiZyKHNlbGYpLGUuZXhwb3J0cz1yfSxmdW5jdGlvbihlLHQsbil7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gbyhlKX0oZSl8fGZ1bmN0aW9uKGUpe2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpKXJldHVybiBBcnJheS5mcm9tKGUpfShlKXx8ZnVuY3Rpb24oZSx0KXtpZighZSlyZXR1cm47aWYoInN0cmluZyI9PXR5cGVvZiBlKXJldHVybiBvKGUsdCk7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpOyJPYmplY3QiPT09biYmZS5jb25zdHJ1Y3RvciYmKG49ZS5jb25zdHJ1Y3Rvci5uYW1lKTtpZigiTWFwIj09PW58fCJTZXQiPT09bilyZXR1cm4gQXJyYXkuZnJvbShlKTtpZigiQXJndW1lbnRzIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKXJldHVybiBvKGUsdCl9KGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLiIpfSgpfWZ1bmN0aW9uIG8oZSx0KXsobnVsbD09dHx8dD5lLmxlbmd0aCkmJih0PWUubGVuZ3RoKTtmb3IodmFyIG49MCxyPW5ldyBBcnJheSh0KTtuPHQ7bisrKXJbbl09ZVtuXTtyZXR1cm4gcn1mdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsInZhbHVlImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19dmFyIHU9bigxKS53cml0ZVN0cmluZyxhPUludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQscz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfSh0aGlzLGUpLHRoaXMuY29uZmlnPXtpbnB1dFNhbXBsZVJhdGU6dCxjaGFubmVsQ291bnQ6bn0sdGhpcy5lbmNvZGVkQnVmZmVycz1bXX12YXIgdCxuLHI7cmV0dXJuIHQ9ZSwobj1be2tleToiZW5jb2RlIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9ZVswXS5sZW5ndGgsbj1uZXcgQXJyYXlCdWZmZXIodCphKnRoaXMuY29uZmlnLmNoYW5uZWxDb3VudCkscj1uZXcgRGF0YVZpZXcobiksbz0wO288dGhpcy5jb25maWcuY2hhbm5lbENvdW50O28rKylmb3IodmFyIGk9ZVtvXSx1PTA7dTx0O3UrKyl7dmFyIHM9MzI3NjcqaVt1XXwwO3M+MzI3Njc/cz0zMjc2NzpzPC0zMjc2OCYmKHM9LTMyNzY4KTt2YXIgYz0odSp0aGlzLmNvbmZpZy5jaGFubmVsQ291bnQrbykqYTtyLnNldEludDE2KGMsMHxzLCEwKX10aGlzLmVuY29kZWRCdWZmZXJzLnB1c2gobil9fSx7a2V5OiJnZXRIZWFkZXIiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5lbmNvZGVkQnVmZmVycy5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdC5ieXRlTGVuZ3RofSksMCksdD1uZXcgQXJyYXlCdWZmZXIoNDQpLG49bmV3IERhdGFWaWV3KHQpO3JldHVybiB1KG4sMCwiUklGRiIpLG4uc2V0VWludDMyKDQsMzYrZSwhMCksdShuLDgsIldBVkUiKSx1KG4sMTIsImZtdCAiKSxuLnNldFVpbnQzMigxNiwxNiwhMCksbi5zZXRVaW50MTYoMjAsMSwhMCksbi5zZXRVaW50MTYoMjIsdGhpcy5jb25maWcuY2hhbm5lbENvdW50LCEwKSxuLnNldFVpbnQzMigyNCx0aGlzLmNvbmZpZy5pbnB1dFNhbXBsZVJhdGUsITApLG4uc2V0VWludDMyKDI4LHRoaXMuY29uZmlnLmlucHV0U2FtcGxlUmF0ZSphKnRoaXMuY29uZmlnLmNoYW5uZWxDb3VudCwhMCksbi5zZXRVaW50MTYoMzIsYSp0aGlzLmNvbmZpZy5jaGFubmVsQ291bnQsITApLG4uc2V0VWludDE2KDM0LDgqYSwhMCksdShuLDM2LCJkYXRhIiksbi5zZXRVaW50MzIoNDAsZSwhMCksdH19XSkmJmkodC5wcm90b3R5cGUsbiksciYmaSh0LHIpLGV9KCk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxuKXsoZT12b2lkIDAhPT1lJiZlfHx7fSkuaW5pdD1mdW5jdGlvbih0LG4scil7ZS5lbmNvZGVyPW5ldyBzKHQsbixyKX0sZS5lbmNvZGU9ZnVuY3Rpb24odCl7ZS5lbmNvZGVyLmVuY29kZSh0KX0sZS5mbHVzaD1mdW5jdGlvbigpe3ZhciB0PWUuZW5jb2Rlci5nZXRIZWFkZXIoKSxuPWUuZW5jb2Rlci5lbmNvZGVkQnVmZmVycy5zcGxpY2UoMCxlLmVuY29kZXIuZW5jb2RlZEJ1ZmZlcnMubGVuZ3RoKTtyZXR1cm5bdF0uY29uY2F0KHIobikpfSxlLmNsb3NlPWZ1bmN0aW9uKCl7fSx0KGUpfSkpfX0sZnVuY3Rpb24oZSx0LG4peyhmdW5jdGlvbihlLHIsbyxpKXt2YXIgdTtmdW5jdGlvbiBhKGUpe3JldHVybihhPSJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJiJzeW1ib2wiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJiJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlPyJzeW1ib2wiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gcyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfWZ1bmN0aW9uIGMoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBmKGUsdCxuKXtyZXR1cm4gdCYmYyhlLnByb3RvdHlwZSx0KSxuJiZjKGUsbiksZX12YXIgbCxwPShsPShsPSJ1bmRlZmluZWQiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8ZSxmdW5jdGlvbihlKXtlPXZvaWQgMCE9PShlPWV8fHt9KT9lOnt9O3ZhciB0PW4oMSksaT10LkVtc2NyaXB0ZW5NZW1vcnlBbGxvY2F0b3IsdT0yMDQ5LGM9NDhlMyxwPTRlMyxfPTIwLGQ9NixoPTQwOTYsbT0wLHk9NDAwMix2PTAsYj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobixyKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dm9pZCAwO3ModGhpcyx0KSx0aGlzLmNvbmZpZz17aW5wdXRTYW1wbGVSYXRlOm4sY2hhbm5lbENvdW50OnJ9LHRoaXMubWVtb3J5PW5ldyBpKGUpLHRoaXMuX29wdXNfZW5jb2Rlcl9jcmVhdGU9ZS5fb3B1c19lbmNvZGVyX2NyZWF0ZSx0aGlzLl9vcHVzX2VuY29kZXJfY3RsPWUuX29wdXNfZW5jb2Rlcl9jdGwsdGhpcy5fb3B1c19lbmNvZGVfZmxvYXQ9ZS5fb3B1c19lbmNvZGVfZmxvYXQsdGhpcy5fb3B1c19lbmNvZGVyX2Rlc3Ryb3k9ZS5fb3B1c19lbmNvZGVyX2Rlc3Ryb3ksdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQsdGhpcy5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQ9ZS5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQsdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3k9ZS5fc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3ksdGhpcy5fY29udGFpbmVyPW5ldyBlLkNvbnRhaW5lcix0aGlzLl9jb250YWluZXIuaW5pdChjLHIsTWF0aC5mbG9vcig0Mjk0OTY3Mjk1Kk1hdGgucmFuZG9tKCkpKSx0aGlzLk9wdXNJbml0Q29kZWMoYyxyLG8pLHRoaXMuU3BlZXhJbml0UmVzYW1wbGVyKG4sYyxyKSx0aGlzLmlucHV0U2FtcGxlc1BlckNoYW5uZWw9bipfLzFlMyx0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWw9YypfLzFlMyx0aGlzLmlucHV0QnVmZmVySW5kZXg9MCx0aGlzLm1JbnB1dEJ1ZmZlcj10aGlzLm1lbW9yeS5tYWxsb2NGbG9hdDMyQnVmZmVyKHRoaXMuaW5wdXRTYW1wbGVzUGVyQ2hhbm5lbCpyKSx0aGlzLm1SZXNhbXBsZWRCdWZmZXI9dGhpcy5tZW1vcnkubWFsbG9jRmxvYXQzMkJ1ZmZlcih0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWwqciksdGhpcy5tT3V0cHV0QnVmZmVyPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQ4QnVmZmVyKHApLHRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzPTEhPT1yP25ldyBGbG9hdDMyQXJyYXkoaCpyKTp2b2lkIDB9cmV0dXJuIGYodCxbe2tleToiZW5jb2RlIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcy5pbnRlcmxlYXZlKGUpLG49MDtuPHQubGVuZ3RoOyl7dmFyIHI9TWF0aC5taW4odGhpcy5tSW5wdXRCdWZmZXIubGVuZ3RoLXRoaXMuaW5wdXRCdWZmZXJJbmRleCx0Lmxlbmd0aC1uKTtpZih0aGlzLm1JbnB1dEJ1ZmZlci5zZXQodC5zdWJhcnJheShuLG4rciksdGhpcy5pbnB1dEJ1ZmZlckluZGV4KSx0aGlzLmlucHV0QnVmZmVySW5kZXgrPXIsdGhpcy5pbnB1dEJ1ZmZlckluZGV4Pj10aGlzLm1JbnB1dEJ1ZmZlci5sZW5ndGgpe3ZhciBvPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih0aGlzLmlucHV0U2FtcGxlc1BlckNoYW5uZWwpLGk9dGhpcy5tZW1vcnkubWFsbG9jVWludDMyKHRoaXMub3V0cHV0U2FtcGxlUGVyQ2hhbm5lbCksdT10aGlzLl9zcGVleF9yZXNhbXBsZXJfcHJvY2Vzc19pbnRlcmxlYXZlZF9mbG9hdCh0aGlzLnJlc2FtcGxlcix0aGlzLm1JbnB1dEJ1ZmZlci5wb2ludGVyLG8ucG9pbnRlcix0aGlzLm1SZXNhbXBsZWRCdWZmZXIucG9pbnRlcixpLnBvaW50ZXIpO2lmKG8uZnJlZSgpLGkuZnJlZSgpLHUhPT12KXRocm93IG5ldyBFcnJvcigiUmVzYW1wbGluZyBlcnJvci4iKTt2YXIgYT10aGlzLl9vcHVzX2VuY29kZV9mbG9hdCh0aGlzLmVuY29kZXIsdGhpcy5tUmVzYW1wbGVkQnVmZmVyLnBvaW50ZXIsdGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsLHRoaXMubU91dHB1dEJ1ZmZlci5wb2ludGVyLHRoaXMubU91dHB1dEJ1ZmZlci5sZW5ndGgpO2lmKGE8MCl0aHJvdyBuZXcgRXJyb3IoIk9wdXMgZW5jb2RpbmcgZXJyb3IuIik7dGhpcy5fY29udGFpbmVyLndyaXRlRnJhbWUodGhpcy5tT3V0cHV0QnVmZmVyLnBvaW50ZXIsYSx0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWwpLHRoaXMuaW5wdXRCdWZmZXJJbmRleD0wfW4rPXJ9fX0se2tleToiY2xvc2UiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuY29uZmlnLmNoYW5uZWxDb3VudCxuPVtdLHI9MDtyPHQ7KytyKW4ucHVzaChuZXcgRmxvYXQzMkFycmF5KGgtdGhpcy5pbnB1dEJ1ZmZlckluZGV4L3QpKTt0aGlzLmVuY29kZShuKSxlLmRlc3Ryb3kodGhpcy5fY29udGFpbmVyKSx0aGlzLm1JbnB1dEJ1ZmZlci5mcmVlKCksdGhpcy5tUmVzYW1wbGVkQnVmZmVyLmZyZWUoKSx0aGlzLm1PdXRwdXRCdWZmZXIuZnJlZSgpLHRoaXMuX29wdXNfZW5jb2Rlcl9kZXN0cm95KHRoaXMuZW5jb2RlciksdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3kodGhpcy5yZXNhbXBsZXIpfX0se2tleToiaW50ZXJsZWF2ZSIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGg7aWYoMT09PXQpcmV0dXJuIGVbMF07Zm9yKHZhciBuPTA7bjx0O24rKylmb3IodmFyIHI9ZVtuXSxvPTA7bzxyLmxlbmd0aDtvKyspdGhpcy5pbnRlcmxlYXZlZEJ1ZmZlcnNbbyp0K25dPXJbb107cmV0dXJuIHRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzfX0se2tleToiT3B1c0luaXRDb2RlYyIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dm9pZCAwLHI9dGhpcy5tZW1vcnkubWFsbG9jVWludDMyKHZvaWQgMCk7dGhpcy5lbmNvZGVyPXRoaXMuX29wdXNfZW5jb2Rlcl9jcmVhdGUoZSx0LHUsci5wb2ludGVyKTt2YXIgbz1yLnZhbHVlO2lmKHIuZnJlZSgpLG8hPT1tKXRocm93IG5ldyBFcnJvcigiT3B1cyBlbmNvZG9yIGluaXRpYWxpemF0aW9uIGZhaWxlZC4iKTtuJiZ0aGlzLk9wdXNTZXRPcHVzQ29udHJvbCh5LG4pfX0se2tleToiT3B1c1NldE9wdXNDb250cm9sIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMubWVtb3J5Lm1hbGxvY0ludDMyKHQpO3RoaXMuX29wdXNfZW5jb2Rlcl9jdGwodGhpcy5lbmNvZGVyLGUsbi5wb2ludGVyKSxuLmZyZWUoKX19LHtrZXk6IlNwZWV4SW5pdFJlc2FtcGxlciIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih2b2lkIDApO3RoaXMucmVzYW1wbGVyPXRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9pbml0KG4sZSx0LGQsci5wb2ludGVyKTt2YXIgbz1yLnZhbHVlO2lmKHIuZnJlZSgpLG8hPT12KXRocm93IG5ldyBFcnJvcigiSW5pdGlhbGl6aW5nIHJlc2FtcGxlciBmYWlsZWQuIil9fV0pLHR9KCk7ZS5pbml0PWZ1bmN0aW9uKHQsbixyKXtlLmVuY29kZWRCdWZmZXJzPVtdLGUuZW5jb2Rlcj1uZXcgYih0LG4scil9LGUuZW5jb2RlPWZ1bmN0aW9uKHQpe2UuZW5jb2Rlci5lbmNvZGUodCl9LGUuZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4gZS5lbmNvZGVkQnVmZmVycy5zcGxpY2UoMCxlLmVuY29kZWRCdWZmZXJzLmxlbmd0aCl9LGUuY2xvc2U9ZnVuY3Rpb24oKXtlLmVuY29kZXIuY2xvc2UoKX07dmFyIGcsdz17fTtmb3IoZyBpbiBlKWUuaGFzT3duUHJvcGVydHkoZykmJih3W2ddPWVbZ10pO3ZhciBBPVtdLEM9ITEsUz0hMSx4PSExLFA9ITE7Qz0ib2JqZWN0Ij09PSgidW5kZWZpbmVkIj09dHlwZW9mIHdpbmRvdz8idW5kZWZpbmVkIjphKHdpbmRvdykpLFM9ImZ1bmN0aW9uIj09dHlwZW9mIGltcG9ydFNjcmlwdHMseD0ib2JqZWN0Ij09PSh2b2lkIDA9PT1yPyJ1bmRlZmluZWQiOmEocikpJiYib2JqZWN0Ij09PWEoci52ZXJzaW9ucykmJiJzdHJpbmciPT10eXBlb2Ygci52ZXJzaW9ucy5ub2RlLFA9IUMmJiF4JiYhUzt2YXIgRSxCLEksUixPPSIiO2Z1bmN0aW9uIGoodCl7cmV0dXJuIGUubG9jYXRlRmlsZT9lLmxvY2F0ZUZpbGUodCxPKTpPK3R9eD8oTz1TP24oMCkuZGlybmFtZShPKSsiLyI6bysiLyIsRT1mdW5jdGlvbihlLHQpe3JldHVybiBJfHwoST1uKDQpKSxSfHwoUj1uKDApKSxlPVIubm9ybWFsaXplKGUpLEkucmVhZEZpbGVTeW5jKGUsdD9udWxsOiJ1dGY4Iil9LEI9ZnVuY3Rpb24oZSl7dmFyIHQ9RShlLCEwKTtyZXR1cm4gdC5idWZmZXJ8fCh0PW5ldyBVaW50OEFycmF5KHQpKSxXKHQuYnVmZmVyKSx0fSxyLmFyZ3YubGVuZ3RoPjEmJnIuYXJndlsxXS5yZXBsYWNlKC9cXC9nLCIvIiksQT1yLmFyZ3Yuc2xpY2UoMiksci5vbigidW5jYXVnaHRFeGNlcHRpb24iLChmdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiBxZSkpdGhyb3cgZX0pKSxyLm9uKCJ1bmhhbmRsZWRSZWplY3Rpb24iLF9lKSxlLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4iW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF0ifSk6UD8oInVuZGVmaW5lZCIhPXR5cGVvZiByZWFkJiYoRT1mdW5jdGlvbihlKXtyZXR1cm4gcmVhZChlKX0pLEI9ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHJlYWRidWZmZXI/bmV3IFVpbnQ4QXJyYXkocmVhZGJ1ZmZlcihlKSk6KFcoIm9iamVjdCI9PT1hKHQ9cmVhZChlLCJiaW5hcnkiKSkpLHQpfSwidW5kZWZpbmVkIiE9dHlwZW9mIHNjcmlwdEFyZ3M/QT1zY3JpcHRBcmdzOnZvaWQgMCE9PWFyZ3VtZW50cyYmKEE9YXJndW1lbnRzKSwidW5kZWZpbmVkIiE9dHlwZW9mIHByaW50JiYoInVuZGVmaW5lZCI9PXR5cGVvZiBjb25zb2xlJiYoY29uc29sZT17fSksY29uc29sZS5sb2c9cHJpbnQsY29uc29sZS53YXJuPWNvbnNvbGUuZXJyb3I9InVuZGVmaW5lZCIhPXR5cGVvZiBwcmludEVycj9wcmludEVycjpwcmludCkpOihDfHxTKSYmKFM/Tz1zZWxmLmxvY2F0aW9uLmhyZWY6ZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKE89ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLGwmJihPPWwpLE89MCE9PU8uaW5kZXhPZigiYmxvYjoiKT9PLnN1YnN0cigwLE8ubGFzdEluZGV4T2YoIi8iKSsxKToiIixFPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKCJHRVQiLGUsITEpLHQuc2VuZChudWxsKSx0LnJlc3BvbnNlVGV4dH0sUyYmKEI9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oIkdFVCIsZSwhMSksdC5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIix0LnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkodC5yZXNwb25zZSl9KSk7dmFyIGssVSxUPWUucHJpbnR8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksRj1lLnByaW50RXJyfHxjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtmb3IoZyBpbiB3KXcuaGFzT3duUHJvcGVydHkoZykmJihlW2ddPXdbZ10pO3c9bnVsbCxlLmFyZ3VtZW50cyYmKEE9ZS5hcmd1bWVudHMpLGUudGhpc1Byb2dyYW0mJmUudGhpc1Byb2dyYW0sZS5xdWl0JiZlLnF1aXQsZS53YXNtQmluYXJ5JiYoaz1lLndhc21CaW5hcnkpLGUubm9FeGl0UnVudGltZSYmZS5ub0V4aXRSdW50aW1lLCJvYmplY3QiIT09KCJ1bmRlZmluZWQiPT10eXBlb2YgV2ViQXNzZW1ibHk/InVuZGVmaW5lZCI6YShXZWJBc3NlbWJseSkpJiZGKCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkIik7dmFyIEg9bmV3IFdlYkFzc2VtYmx5LlRhYmxlKHtpbml0aWFsOjYwLG1heGltdW06NjAsZWxlbWVudDoiYW55ZnVuYyJ9KSxNPSExO2Z1bmN0aW9uIFcoZSx0KXtlfHxfZSgiQXNzZXJ0aW9uIGZhaWxlZDogIit0KX12YXIgRD0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcigidXRmOCIpOnZvaWQgMDtmdW5jdGlvbiB6KGUsdCxuKXtmb3IodmFyIHI9dCtuLG89dDtlW29dJiYhKG8+PXIpOykrK287aWYoby10PjE2JiZlLnN1YmFycmF5JiZEKXJldHVybiBELmRlY29kZShlLnN1YmFycmF5KHQsbykpO2Zvcih2YXIgaT0iIjt0PG87KXt2YXIgdT1lW3QrK107aWYoMTI4JnUpe3ZhciBhPTYzJmVbdCsrXTtpZigxOTIhPSgyMjQmdSkpe3ZhciBzPTYzJmVbdCsrXTtpZigodT0yMjQ9PSgyNDAmdSk/KDE1JnUpPDwxMnxhPDw2fHM6KDcmdSk8PDE4fGE8PDEyfHM8PDZ8NjMmZVt0KytdKTw2NTUzNilpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUpO2Vsc2V7dmFyIGM9dS02NTUzNjtpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGM+PjEwLDU2MzIwfDEwMjMmYyl9fWVsc2UgaSs9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmdSk8PDZ8YSl9ZWxzZSBpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUpfXJldHVybiBpfWZ1bmN0aW9uIEwoZSx0KXtyZXR1cm4gZT96KHEsZSx0KToiIn0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHREZWNvZGVyJiZuZXcgVGV4dERlY29kZXIoInV0Zi0xNmxlIik7dmFyIFYscSxOLEc9NjU1MzY7ZnVuY3Rpb24gWCh0KXtWPXQsZS5IRUFQOD1uZXcgSW50OEFycmF5KHQpLGUuSEVBUDE2PW5ldyBJbnQxNkFycmF5KHQpLGUuSEVBUDMyPU49bmV3IEludDMyQXJyYXkodCksZS5IRUFQVTg9cT1uZXcgVWludDhBcnJheSh0KSxlLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KHQpLGUuSEVBUFUzMj1uZXcgVWludDMyQXJyYXkodCksZS5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkodCksZS5IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkodCl9dmFyIFk9NTI4OTAyNCwkPTQ1OTg0LEo9ZS5JTklUSUFMX01FTU9SWXx8MTY3NzcyMTY7ZnVuY3Rpb24gSyh0KXtmb3IoO3QubGVuZ3RoPjA7KXt2YXIgbj10LnNoaWZ0KCk7aWYoImZ1bmN0aW9uIiE9dHlwZW9mIG4pe3ZhciByPW4uZnVuYzsibnVtYmVyIj09dHlwZW9mIHI/dm9pZCAwPT09bi5hcmc/ZS5keW5DYWxsX3Yocik6ZS5keW5DYWxsX3ZpKHIsbi5hcmcpOnIodm9pZCAwPT09bi5hcmc/bnVsbDpuLmFyZyl9ZWxzZSBuKCl9fShVPWUud2FzbU1lbW9yeT9lLndhc21NZW1vcnk6bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpKL0csbWF4aW11bTpKL0d9KSkmJihWPVUuYnVmZmVyKSxKPVYuYnl0ZUxlbmd0aCxYKFYpLE5bJD4+Ml09WTt2YXIgUT1bXSxaPVtdLGVlPVtdLHRlPVtdO2Z1bmN0aW9uIG5lKCl7aWYoZS5wcmVSdW4pZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBlLnByZVJ1biYmKGUucHJlUnVuPVtlLnByZVJ1bl0pO2UucHJlUnVuLmxlbmd0aDspdWUoZS5wcmVSdW4uc2hpZnQoKSk7SyhRKX1mdW5jdGlvbiByZSgpe0soWil9ZnVuY3Rpb24gb2UoKXtLKGVlKX1mdW5jdGlvbiBpZSgpe2lmKGUucG9zdFJ1bilmb3IoImZ1bmN0aW9uIj09dHlwZW9mIGUucG9zdFJ1biYmKGUucG9zdFJ1bj1bZS5wb3N0UnVuXSk7ZS5wb3N0UnVuLmxlbmd0aDspYWUoZS5wb3N0UnVuLnNoaWZ0KCkpO0sodGUpfWZ1bmN0aW9uIHVlKGUpe1EudW5zaGlmdChlKX1mdW5jdGlvbiBhZShlKXt0ZS51bnNoaWZ0KGUpfXZhciBzZT0wLGNlPW51bGwsZmU9bnVsbDtmdW5jdGlvbiBsZSh0KXtzZSsrLGUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKHNlKX1mdW5jdGlvbiBwZSh0KXtpZihzZS0tLGUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKHNlKSwwPT1zZSYmKG51bGwhPT1jZSYmKGNsZWFySW50ZXJ2YWwoY2UpLGNlPW51bGwpLGZlKSl7dmFyIG49ZmU7ZmU9bnVsbCxuKCl9fWZ1bmN0aW9uIF9lKHQpe3Rocm93IGUub25BYm9ydCYmZS5vbkFib3J0KHQpLFQodCs9IiIpLEYodCksTT0hMCx0PSJhYm9ydCgiK3QrIikuIEJ1aWxkIHdpdGggLXMgQVNTRVJUSU9OUz0xIGZvciBtb3JlIGluZm8uIixuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHQpfWUucHJlbG9hZGVkSW1hZ2VzPXt9LGUucHJlbG9hZGVkQXVkaW9zPXt9O3ZhciBkZT0iZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCI7ZnVuY3Rpb24gaGUoZSl7cmV0dXJuIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aD9lLnN0YXJ0c1dpdGgoZGUpOjA9PT1lLmluZGV4T2YoZGUpfXZhciBtZT0iV2ViTU9wdXNFbmNvZGVyLndhc20iO2Z1bmN0aW9uIHllKCl7dHJ5e2lmKGspcmV0dXJuIG5ldyBVaW50OEFycmF5KGspO2lmKEIpcmV0dXJuIEIobWUpO3Rocm93ImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkIn1jYXRjaChlKXtfZShlKX19ZnVuY3Rpb24gdmUoKXtyZXR1cm4ga3x8IUMmJiFTfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2g/bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7ZSh5ZSgpKX0pKTpmZXRjaChtZSx7Y3JlZGVudGlhbHM6InNhbWUtb3JpZ2luIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKCFlLm9rKXRocm93ImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJyIrbWUrIiciO3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIHllKCl9KSl9ZnVuY3Rpb24gYmUoKXt2YXIgdD17YTpUZX07ZnVuY3Rpb24gbih0LG4pe3ZhciByPXQuZXhwb3J0cztlLmFzbT1yLHBlKCl9ZnVuY3Rpb24gcihlKXtuKGUuaW5zdGFuY2UpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIHZlKCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsdCl9KSkudGhlbihlLChmdW5jdGlvbihlKXtGKCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAiK2UpLF9lKGUpfSkpfWlmKGxlKCksZS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBlLmluc3RhbnRpYXRlV2FzbSh0LG4pfWNhdGNoKGUpe3JldHVybiBGKCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAiK2UpLCExfXJldHVybiBmdW5jdGlvbigpe2lmKGt8fCJmdW5jdGlvbiIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8aGUobWUpfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2gpcmV0dXJuIG8ocik7ZmV0Y2gobWUse2NyZWRlbnRpYWxzOiJzYW1lLW9yaWdpbiJ9KS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZSx0KS50aGVuKHIsKGZ1bmN0aW9uKGUpe0YoIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAiK2UpLEYoImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uIiksbyhyKX0pKX0pKX0oKSx7fX1mdW5jdGlvbiBnZSh0LG4pe3ZhciByPW5ldyBVaW50OEFycmF5KGUuSEVBUFU4LmJ1ZmZlcix0LG4pO2UuZW5jb2RlZEJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShyKS5idWZmZXIpfWZ1bmN0aW9uIHdlKGUsdCxuLHIpe19lKCJBc3NlcnRpb24gZmFpbGVkOiAiK0woZSkrIiwgYXQ6ICIrW3Q/TCh0KToidW5rbm93biBmaWxlbmFtZSIsbixyP0wocik6InVua25vd24gZnVuY3Rpb24iXSl9aGUobWUpfHwobWU9aihtZSkpLFoucHVzaCh7ZnVuYzpmdW5jdGlvbigpe01lKCl9fSk7dmFyIEFlPXttYXBwaW5nczp7fSxidWZmZXJzOltudWxsLFtdLFtdXSxwcmludENoYXI6ZnVuY3Rpb24oZSx0KXt2YXIgbj1BZS5idWZmZXJzW2VdOzA9PT10fHwxMD09PXQ/KCgxPT09ZT9UOkYpKHoobiwwKSksbi5sZW5ndGg9MCk6bi5wdXNoKHQpfSx2YXJhcmdzOnZvaWQgMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQWUudmFyYXJncys9NCxOW0FlLnZhcmFyZ3MtND4+Ml19LGdldFN0cjpmdW5jdGlvbihlKXtyZXR1cm4gTChlKX0sZ2V0NjQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZX19O2Z1bmN0aW9uIENlKGUsdCxuKXtyZXR1cm4gQWUudmFyYXJncz1uLDB9ZnVuY3Rpb24gU2UoZSx0LG4pe0FlLnZhcmFyZ3M9bn1mdW5jdGlvbiB4ZShlLHQsbil7cmV0dXJuIEFlLnZhcmFyZ3M9biwwfWZ1bmN0aW9uIFBlKCl7X2UoKX1mdW5jdGlvbiBFZShlLHQsbil7cS5jb3B5V2l0aGluKGUsdCx0K24pfWZ1bmN0aW9uIEJlKGUpe19lKCJPT00iKX1mdW5jdGlvbiBJZShlKXtCZSgpfWZ1bmN0aW9uIFJlKGUpe3JldHVybiAwfWZ1bmN0aW9uIE9lKGUsdCxuLHIpe3ZhciBvPUFlLmdldFN0cmVhbUZyb21GRChlKSxpPUFlLmRvUmVhZHYobyx0LG4pO3JldHVybiBOW3I+PjJdPWksMH1mdW5jdGlvbiBqZShlLHQsbixyLG8pe31mdW5jdGlvbiBrZShlLHQsbixyKXtmb3IodmFyIG89MCxpPTA7aTxuO2krKyl7Zm9yKHZhciB1PU5bdCs4Kmk+PjJdLGE9Tlt0Kyg4KmkrNCk+PjJdLHM9MDtzPGE7cysrKUFlLnByaW50Q2hhcihlLHFbdStzXSk7bys9YX1yZXR1cm4gTltyPj4yXT1vLDB9ZnVuY3Rpb24gVWUoZSl7dmFyIHQ9RGF0ZS5ub3coKS8xZTN8MDtyZXR1cm4gZSYmKE5bZT4+Ml09dCksdH12YXIgVGU9e2E6d2UsZTpDZSxoOlNlLGc6eGUsYjpQZSxtOmdlLGs6RWUsbDpJZSxjOlJlLGY6T2UsajpqZSxkOmtlLG1lbW9yeTpVLHRhYmxlOkgsaTpVZX0sRmU9YmUoKTtlLmFzbT1GZTt2YXIgSGUsTWU9ZS5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4oTWU9ZS5fX193YXNtX2NhbGxfY3RvcnM9ZS5hc20ubikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxXZT0oZS5fX19lbV9qc19fZW1zY3JpcHRlblB1c2hCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fX19lbV9qc19fZW1zY3JpcHRlblB1c2hCdWZmZXI9ZS5hc20ubykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9lbXNjcmlwdGVuX2JpbmRfVm9pZFB0cl9fX2Rlc3Ryb3lfX18wPWZ1bmN0aW9uKCl7cmV0dXJuKFdlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Wb2lkUHRyX19fZGVzdHJveV9fXzA9ZS5hc20ucCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSksRGU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9Db250YWluZXJfMD1mdW5jdGlvbigpe3JldHVybihEZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX0NvbnRhaW5lcl8wPWUuYXNtLnEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0semU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9pbml0XzM9ZnVuY3Rpb24oKXtyZXR1cm4oemU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9pbml0XzM9ZS5hc20ucikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxMZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX3dyaXRlRnJhbWVfMz1mdW5jdGlvbigpe3JldHVybihMZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX3dyaXRlRnJhbWVfMz1lLmFzbS5zKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFZlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfX19kZXN0cm95X19fMD1mdW5jdGlvbigpe3JldHVybihWZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX19fZGVzdHJveV9fXzA9ZS5hc20udCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBxZShlKXt0aGlzLm5hbWU9IkV4aXRTdGF0dXMiLHRoaXMubWVzc2FnZT0iUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgiK2UrIikiLHRoaXMuc3RhdHVzPWV9ZnVuY3Rpb24gTmUodCl7ZnVuY3Rpb24gbigpe0hlfHwoSGU9ITAsZS5jYWxsZWRSdW49ITAsTXx8KHJlKCksb2UoKSxlLm9uUnVudGltZUluaXRpYWxpemVkJiZlLm9uUnVudGltZUluaXRpYWxpemVkKCksaWUoKSkpfXQ9dHx8QSxzZT4wfHwobmUoKSxzZT4wfHwoZS5zZXRTdGF0dXM/KGUuc2V0U3RhdHVzKCJSdW5uaW5nLi4uIiksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe2Uuc2V0U3RhdHVzKCIiKX0pLDEpLG4oKX0pLDEpKTpuKCkpKX1pZihlLl9vcHVzX2VuY29kZXJfY3JlYXRlPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX29wdXNfZW5jb2Rlcl9jcmVhdGU9ZS5hc20udSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9vcHVzX2VuY29kZV9mbG9hdD1mdW5jdGlvbigpe3JldHVybihlLl9vcHVzX2VuY29kZV9mbG9hdD1lLmFzbS52KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX29wdXNfZW5jb2Rlcl9jdGw9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fb3B1c19lbmNvZGVyX2N0bD1lLmFzbS53KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX29wdXNfZW5jb2Rlcl9kZXN0cm95PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX29wdXNfZW5jb2Rlcl9kZXN0cm95PWUuYXNtLngpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZS5hc20ueSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1mdW5jdGlvbigpe3JldHVybihlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1lLmFzbS56KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWUuYXNtLkEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fZnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9mcmVlPWUuYXNtLkIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fbWFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX21hbGxvYz1lLmFzbS5DKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuZHluQ2FsbF92aT1mdW5jdGlvbigpe3JldHVybihlLmR5bkNhbGxfdmk9ZS5hc20uRCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLmR5bkNhbGxfdj1mdW5jdGlvbigpe3JldHVybihlLmR5bkNhbGxfdj1lLmFzbS5FKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuYXNtPUZlLGUudGhlbj1mdW5jdGlvbih0KXtpZihIZSl0KGUpO2Vsc2V7dmFyIG49ZS5vblJ1bnRpbWVJbml0aWFsaXplZDtlLm9uUnVudGltZUluaXRpYWxpemVkPWZ1bmN0aW9uKCl7biYmbigpLHQoZSl9fXJldHVybiBlfSxmZT1mdW5jdGlvbiBlKCl7SGV8fE5lKCksSGV8fChmZT1lKX0sZS5ydW49TmUsZS5wcmVJbml0KWZvcigiZnVuY3Rpb24iPT10eXBlb2YgZS5wcmVJbml0JiYoZS5wcmVJbml0PVtlLnByZUluaXRdKTtlLnByZUluaXQubGVuZ3RoPjA7KWUucHJlSW5pdC5wb3AoKSgpO2Z1bmN0aW9uIEdlKCl7fWZ1bmN0aW9uIFhlKGUpe3JldHVybihlfHxHZSkuX19jYWNoZV9ffWZ1bmN0aW9uIFllKGUsdCl7dmFyIG49WGUodCkscj1uW2VdO3JldHVybiByfHwoKHI9T2JqZWN0LmNyZWF0ZSgodHx8R2UpLnByb3RvdHlwZSkpLnB0cj1lLG5bZV09cil9ZnVuY3Rpb24gJGUoZSx0KXtyZXR1cm4gWWUoZS5wdHIsdCl9ZnVuY3Rpb24gSmUoZSl7aWYoIWUuX19kZXN0cm95X18pdGhyb3ciRXJyb3I6IENhbm5vdCBkZXN0cm95IG9iamVjdC4gKERpZCB5b3UgY3JlYXRlIGl0IHlvdXJzZWxmPykiO2UuX19kZXN0cm95X18oKSxkZWxldGUgWGUoZS5fX2NsYXNzX18pW2UucHRyXX1mdW5jdGlvbiBLZShlLHQpe3JldHVybiBlLnB0cj09PXQucHRyfWZ1bmN0aW9uIFFlKGUpe3JldHVybiBlLnB0cn1mdW5jdGlvbiBaZShlKXtyZXR1cm4gZS5fX2NsYXNzX199ZnVuY3Rpb24gZXQoKXt0aHJvdyJjYW5ub3QgY29uc3RydWN0IGEgVm9pZFB0ciwgbm8gY29uc3RydWN0b3IgaW4gSURMIn1mdW5jdGlvbiB0dCgpe3RoaXMucHRyPURlKCksWGUodHQpW3RoaXMucHRyXT10aGlzfXJldHVybiBOZSgpLEdlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEdlLnByb3RvdHlwZSksR2UucHJvdG90eXBlLmNvbnN0cnVjdG9yPUdlLEdlLnByb3RvdHlwZS5fX2NsYXNzX189R2UsR2UuX19jYWNoZV9fPXt9LGUuV3JhcHBlck9iamVjdD1HZSxlLmdldENhY2hlPVhlLGUud3JhcFBvaW50ZXI9WWUsZS5jYXN0T2JqZWN0PSRlLGUuTlVMTD1ZZSgwKSxlLmRlc3Ryb3k9SmUsZS5jb21wYXJlPUtlLGUuZ2V0UG9pbnRlcj1RZSxlLmdldENsYXNzPVplLGV0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEdlLnByb3RvdHlwZSksZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yPWV0LGV0LnByb3RvdHlwZS5fX2NsYXNzX189ZXQsZXQuX19jYWNoZV9fPXt9LGUuVm9pZFB0cj1ldCxldC5wcm90b3R5cGUuX19kZXN0cm95X189ZXQucHJvdG90eXBlLl9fZGVzdHJveV9fPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wdHI7V2UoZSl9LHR0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEdlLnByb3RvdHlwZSksdHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXR0LHR0LnByb3RvdHlwZS5fX2NsYXNzX189dHQsdHQuX19jYWNoZV9fPXt9LGUuQ29udGFpbmVyPXR0LHR0LnByb3RvdHlwZS5pbml0PXR0LnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLnB0cjtlJiYib2JqZWN0Ij09PWEoZSkmJihlPWUucHRyKSx0JiYib2JqZWN0Ij09PWEodCkmJih0PXQucHRyKSxuJiYib2JqZWN0Ij09PWEobikmJihuPW4ucHRyKSx6ZShyLGUsdCxuKX0sdHQucHJvdG90eXBlLndyaXRlRnJhbWU9dHQucHJvdG90eXBlLndyaXRlRnJhbWU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMucHRyO2UmJiJvYmplY3QiPT09YShlKSYmKGU9ZS5wdHIpLHQmJiJvYmplY3QiPT09YSh0KSYmKHQ9dC5wdHIpLG4mJiJvYmplY3QiPT09YShuKSYmKG49bi5wdHIpLExlKHIsZSx0LG4pfSx0dC5wcm90b3R5cGUuX19kZXN0cm95X189dHQucHJvdG90eXBlLl9fZGVzdHJveV9fPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wdHI7VmUoZSl9LGV9KTsib2JqZWN0Ij09PWEodCkmJiJvYmplY3QiPT09YShpKT9pLmV4cG9ydHM9cDp2b2lkIDA9PT0odT1mdW5jdGlvbigpe3JldHVybiBwfS5hcHBseSh0LFtdKSl8fChpLmV4cG9ydHM9dSl9KS5jYWxsKHRoaXMsIi9pbmRleC5qcyIsbigyKSwiLyIsbigzKShlKSl9LGZ1bmN0aW9uKGUsdCxuKXsoZnVuY3Rpb24oZSxyLG8saSl7dmFyIHU7ZnVuY3Rpb24gYShlKXtyZXR1cm4oYT0iZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYic3ltYm9sIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiYiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT8ic3ltYm9sIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIHMoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKX1mdW5jdGlvbiBjKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsInZhbHVlImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19ZnVuY3Rpb24gZihlLHQsbil7cmV0dXJuIHQmJmMoZS5wcm90b3R5cGUsdCksbiYmYyhlLG4pLGV9dmFyIGwscD0obD0obD0idW5kZWZpbmVkIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCl8fGUsZnVuY3Rpb24oZSl7ZT12b2lkIDAhPT0oZT1lfHx7fSk/ZTp7fTt2YXIgdD1uKDEpLGk9dC5FbXNjcmlwdGVuTWVtb3J5QWxsb2NhdG9yLHU9MjA0OSxjPTQ4ZTMscD00ZTMsXz0yMCxkPTYsaD00MDk2LG09MCx5PTQwMDIsdj0wLGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG4scil7dmFyIG89YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnZvaWQgMDtzKHRoaXMsdCksdGhpcy5jb25maWc9e2lucHV0U2FtcGxlUmF0ZTpuLGNoYW5uZWxDb3VudDpyfSx0aGlzLm1lbW9yeT1uZXcgaShlKSx0aGlzLl9vcHVzX2VuY29kZXJfY3JlYXRlPWUuX29wdXNfZW5jb2Rlcl9jcmVhdGUsdGhpcy5fb3B1c19lbmNvZGVyX2N0bD1lLl9vcHVzX2VuY29kZXJfY3RsLHRoaXMuX29wdXNfZW5jb2RlX2Zsb2F0PWUuX29wdXNfZW5jb2RlX2Zsb2F0LHRoaXMuX29wdXNfZW5jb2Rlcl9kZXN0cm95PWUuX29wdXNfZW5jb2Rlcl9kZXN0cm95LHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9pbml0PWUuX3NwZWV4X3Jlc2FtcGxlcl9pbml0LHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0LHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95PWUuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95LHRoaXMuX2NvbnRhaW5lcj1uZXcgZS5Db250YWluZXIsdGhpcy5fY29udGFpbmVyLmluaXQoYyxyLE1hdGguZmxvb3IoNDI5NDk2NzI5NSpNYXRoLnJhbmRvbSgpKSksdGhpcy5PcHVzSW5pdENvZGVjKGMscixvKSx0aGlzLlNwZWV4SW5pdFJlc2FtcGxlcihuLGMsciksdGhpcy5pbnB1dFNhbXBsZXNQZXJDaGFubmVsPW4qXy8xZTMsdGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsPWMqXy8xZTMsdGhpcy5pbnB1dEJ1ZmZlckluZGV4PTAsdGhpcy5tSW5wdXRCdWZmZXI9dGhpcy5tZW1vcnkubWFsbG9jRmxvYXQzMkJ1ZmZlcih0aGlzLmlucHV0U2FtcGxlc1BlckNoYW5uZWwqciksdGhpcy5tUmVzYW1wbGVkQnVmZmVyPXRoaXMubWVtb3J5Lm1hbGxvY0Zsb2F0MzJCdWZmZXIodGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsKnIpLHRoaXMubU91dHB1dEJ1ZmZlcj10aGlzLm1lbW9yeS5tYWxsb2NVaW50OEJ1ZmZlcihwKSx0aGlzLmludGVybGVhdmVkQnVmZmVycz0xIT09cj9uZXcgRmxvYXQzMkFycmF5KGgqcik6dm9pZCAwfXJldHVybiBmKHQsW3trZXk6ImVuY29kZSIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMuaW50ZXJsZWF2ZShlKSxuPTA7bjx0Lmxlbmd0aDspe3ZhciByPU1hdGgubWluKHRoaXMubUlucHV0QnVmZmVyLmxlbmd0aC10aGlzLmlucHV0QnVmZmVySW5kZXgsdC5sZW5ndGgtbik7aWYodGhpcy5tSW5wdXRCdWZmZXIuc2V0KHQuc3ViYXJyYXkobixuK3IpLHRoaXMuaW5wdXRCdWZmZXJJbmRleCksdGhpcy5pbnB1dEJ1ZmZlckluZGV4Kz1yLHRoaXMuaW5wdXRCdWZmZXJJbmRleD49dGhpcy5tSW5wdXRCdWZmZXIubGVuZ3RoKXt2YXIgbz10aGlzLm1lbW9yeS5tYWxsb2NVaW50MzIodGhpcy5pbnB1dFNhbXBsZXNQZXJDaGFubmVsKSxpPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWwpLHU9dGhpcy5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQodGhpcy5yZXNhbXBsZXIsdGhpcy5tSW5wdXRCdWZmZXIucG9pbnRlcixvLnBvaW50ZXIsdGhpcy5tUmVzYW1wbGVkQnVmZmVyLnBvaW50ZXIsaS5wb2ludGVyKTtpZihvLmZyZWUoKSxpLmZyZWUoKSx1IT09dil0aHJvdyBuZXcgRXJyb3IoIlJlc2FtcGxpbmcgZXJyb3IuIik7dmFyIGE9dGhpcy5fb3B1c19lbmNvZGVfZmxvYXQodGhpcy5lbmNvZGVyLHRoaXMubVJlc2FtcGxlZEJ1ZmZlci5wb2ludGVyLHRoaXMub3V0cHV0U2FtcGxlUGVyQ2hhbm5lbCx0aGlzLm1PdXRwdXRCdWZmZXIucG9pbnRlcix0aGlzLm1PdXRwdXRCdWZmZXIubGVuZ3RoKTtpZihhPDApdGhyb3cgbmV3IEVycm9yKCJPcHVzIGVuY29kaW5nIGVycm9yLiIpO3RoaXMuX2NvbnRhaW5lci53cml0ZUZyYW1lKHRoaXMubU91dHB1dEJ1ZmZlci5wb2ludGVyLGEsdGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsKSx0aGlzLmlucHV0QnVmZmVySW5kZXg9MH1uKz1yfX19LHtrZXk6ImNsb3NlIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmNvbmZpZy5jaGFubmVsQ291bnQsbj1bXSxyPTA7cjx0OysrciluLnB1c2gobmV3IEZsb2F0MzJBcnJheShoLXRoaXMuaW5wdXRCdWZmZXJJbmRleC90KSk7dGhpcy5lbmNvZGUobiksZS5kZXN0cm95KHRoaXMuX2NvbnRhaW5lciksdGhpcy5tSW5wdXRCdWZmZXIuZnJlZSgpLHRoaXMubVJlc2FtcGxlZEJ1ZmZlci5mcmVlKCksdGhpcy5tT3V0cHV0QnVmZmVyLmZyZWUoKSx0aGlzLl9vcHVzX2VuY29kZXJfZGVzdHJveSh0aGlzLmVuY29kZXIpLHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95KHRoaXMucmVzYW1wbGVyKX19LHtrZXk6ImludGVybGVhdmUiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoO2lmKDE9PT10KXJldHVybiBlWzBdO2Zvcih2YXIgbj0wO248dDtuKyspZm9yKHZhciByPWVbbl0sbz0wO288ci5sZW5ndGg7bysrKXRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzW28qdCtuXT1yW29dO3JldHVybiB0aGlzLmludGVybGVhdmVkQnVmZmVyc319LHtrZXk6Ik9wdXNJbml0Q29kZWMiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnZvaWQgMCxyPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih2b2lkIDApO3RoaXMuZW5jb2Rlcj10aGlzLl9vcHVzX2VuY29kZXJfY3JlYXRlKGUsdCx1LHIucG9pbnRlcik7dmFyIG89ci52YWx1ZTtpZihyLmZyZWUoKSxvIT09bSl0aHJvdyBuZXcgRXJyb3IoIk9wdXMgZW5jb2RvciBpbml0aWFsaXphdGlvbiBmYWlsZWQuIik7biYmdGhpcy5PcHVzU2V0T3B1c0NvbnRyb2woeSxuKX19LHtrZXk6Ik9wdXNTZXRPcHVzQ29udHJvbCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLm1lbW9yeS5tYWxsb2NJbnQzMih0KTt0aGlzLl9vcHVzX2VuY29kZXJfY3RsKHRoaXMuZW5jb2RlcixlLG4ucG9pbnRlciksbi5mcmVlKCl9fSx7a2V5OiJTcGVleEluaXRSZXNhbXBsZXIiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLm1lbW9yeS5tYWxsb2NVaW50MzIodm9pZCAwKTt0aGlzLnJlc2FtcGxlcj10aGlzLl9zcGVleF9yZXNhbXBsZXJfaW5pdChuLGUsdCxkLHIucG9pbnRlcik7dmFyIG89ci52YWx1ZTtpZihyLmZyZWUoKSxvIT09dil0aHJvdyBuZXcgRXJyb3IoIkluaXRpYWxpemluZyByZXNhbXBsZXIgZmFpbGVkLiIpfX1dKSx0fSgpO2UuaW5pdD1mdW5jdGlvbih0LG4scil7ZS5lbmNvZGVkQnVmZmVycz1bXSxlLmVuY29kZXI9bmV3IGIodCxuLHIpfSxlLmVuY29kZT1mdW5jdGlvbih0KXtlLmVuY29kZXIuZW5jb2RlKHQpfSxlLmZsdXNoPWZ1bmN0aW9uKCl7cmV0dXJuIGUuZW5jb2RlZEJ1ZmZlcnMuc3BsaWNlKDAsZS5lbmNvZGVkQnVmZmVycy5sZW5ndGgpfSxlLmNsb3NlPWZ1bmN0aW9uKCl7ZS5lbmNvZGVyLmNsb3NlKCl9O3ZhciBnLHc9e307Zm9yKGcgaW4gZSllLmhhc093blByb3BlcnR5KGcpJiYod1tnXT1lW2ddKTt2YXIgQT1bXSxDPSExLFM9ITEseD0hMSxQPSExO0M9Im9iamVjdCI9PT0oInVuZGVmaW5lZCI9PXR5cGVvZiB3aW5kb3c/InVuZGVmaW5lZCI6YSh3aW5kb3cpKSxTPSJmdW5jdGlvbiI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLHg9Im9iamVjdCI9PT0odm9pZCAwPT09cj8idW5kZWZpbmVkIjphKHIpKSYmIm9iamVjdCI9PT1hKHIudmVyc2lvbnMpJiYic3RyaW5nIj09dHlwZW9mIHIudmVyc2lvbnMubm9kZSxQPSFDJiYheCYmIVM7dmFyIEUsQixJLFIsTz0iIjtmdW5jdGlvbiBqKHQpe3JldHVybiBlLmxvY2F0ZUZpbGU/ZS5sb2NhdGVGaWxlKHQsTyk6Tyt0fXg/KE89Uz9uKDApLmRpcm5hbWUoTykrIi8iOm8rIi8iLEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gSXx8KEk9big0KSksUnx8KFI9bigwKSksZT1SLm5vcm1hbGl6ZShlKSxJLnJlYWRGaWxlU3luYyhlLHQ/bnVsbDoidXRmOCIpfSxCPWZ1bmN0aW9uKGUpe3ZhciB0PUUoZSwhMCk7cmV0dXJuIHQuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksVyh0LmJ1ZmZlciksdH0sci5hcmd2Lmxlbmd0aD4xJiZyLmFyZ3ZbMV0ucmVwbGFjZSgvXFwvZywiLyIpLEE9ci5hcmd2LnNsaWNlKDIpLHIub24oInVuY2F1Z2h0RXhjZXB0aW9uIiwoZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgV2UpKXRocm93IGV9KSksci5vbigidW5oYW5kbGVkUmVqZWN0aW9uIixfZSksZS5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdIn0pOlA/KCJ1bmRlZmluZWQiIT10eXBlb2YgcmVhZCYmKEU9ZnVuY3Rpb24oZSl7cmV0dXJuIHJlYWQoZSl9KSxCPWZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiByZWFkYnVmZmVyP25ldyBVaW50OEFycmF5KHJlYWRidWZmZXIoZSkpOihXKCJvYmplY3QiPT09YSh0PXJlYWQoZSwiYmluYXJ5IikpKSx0KX0sInVuZGVmaW5lZCIhPXR5cGVvZiBzY3JpcHRBcmdzP0E9c2NyaXB0QXJnczp2b2lkIDAhPT1hcmd1bWVudHMmJihBPWFyZ3VtZW50cyksInVuZGVmaW5lZCIhPXR5cGVvZiBwcmludCYmKCJ1bmRlZmluZWQiPT10eXBlb2YgY29uc29sZSYmKGNvbnNvbGU9e30pLGNvbnNvbGUubG9nPXByaW50LGNvbnNvbGUud2Fybj1jb25zb2xlLmVycm9yPSJ1bmRlZmluZWQiIT10eXBlb2YgcHJpbnRFcnI/cHJpbnRFcnI6cHJpbnQpKTooQ3x8UykmJihTP089c2VsZi5sb2NhdGlvbi5ocmVmOmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihPPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxsJiYoTz1sKSxPPTAhPT1PLmluZGV4T2YoImJsb2I6Iik/Ty5zdWJzdHIoMCxPLmxhc3RJbmRleE9mKCIvIikrMSk6IiIsRT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbigiR0VUIixlLCExKSx0LnNlbmQobnVsbCksdC5yZXNwb25zZVRleHR9LFMmJihCPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKCJHRVQiLGUsITEpLHQucmVzcG9uc2VUeXBlPSJhcnJheWJ1ZmZlciIsdC5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KHQucmVzcG9uc2UpfSkpO3ZhciBrLFUsVD1lLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLEY9ZS5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7Zm9yKGcgaW4gdyl3Lmhhc093blByb3BlcnR5KGcpJiYoZVtnXT13W2ddKTt3PW51bGwsZS5hcmd1bWVudHMmJihBPWUuYXJndW1lbnRzKSxlLnRoaXNQcm9ncmFtJiZlLnRoaXNQcm9ncmFtLGUucXVpdCYmZS5xdWl0LGUud2FzbUJpbmFyeSYmKGs9ZS53YXNtQmluYXJ5KSxlLm5vRXhpdFJ1bnRpbWUmJmUubm9FeGl0UnVudGltZSwib2JqZWN0IiE9PSgidW5kZWZpbmVkIj09dHlwZW9mIFdlYkFzc2VtYmx5PyJ1bmRlZmluZWQiOmEoV2ViQXNzZW1ibHkpKSYmRigibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCIpO3ZhciBIPW5ldyBXZWJBc3NlbWJseS5UYWJsZSh7aW5pdGlhbDozNixtYXhpbXVtOjM2LGVsZW1lbnQ6ImFueWZ1bmMifSksTT0hMTtmdW5jdGlvbiBXKGUsdCl7ZXx8X2UoIkFzc2VydGlvbiBmYWlsZWQ6ICIrdCl9dmFyIEQ9InVuZGVmaW5lZCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoInV0ZjgiKTp2b2lkIDA7ZnVuY3Rpb24geihlLHQsbil7Zm9yKHZhciByPXQrbixvPXQ7ZVtvXSYmIShvPj1yKTspKytvO2lmKG8tdD4xNiYmZS5zdWJhcnJheSYmRClyZXR1cm4gRC5kZWNvZGUoZS5zdWJhcnJheSh0LG8pKTtmb3IodmFyIGk9IiI7dDxvOyl7dmFyIHU9ZVt0KytdO2lmKDEyOCZ1KXt2YXIgYT02MyZlW3QrK107aWYoMTkyIT0oMjI0JnUpKXt2YXIgcz02MyZlW3QrK107aWYoKHU9MjI0PT0oMjQwJnUpPygxNSZ1KTw8MTJ8YTw8NnxzOig3JnUpPDwxOHxhPDwxMnxzPDw2fDYzJmVbdCsrXSk8NjU1MzYpaSs9U3RyaW5nLmZyb21DaGFyQ29kZSh1KTtlbHNle3ZhciBjPXUtNjU1MzY7aSs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjPj4xMCw1NjMyMHwxMDIzJmMpfX1lbHNlIGkrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJnUpPDw2fGEpfWVsc2UgaSs9U3RyaW5nLmZyb21DaGFyQ29kZSh1KX1yZXR1cm4gaX1mdW5jdGlvbiBMKGUsdCl7cmV0dXJuIGU/eihxLGUsdCk6IiJ9InVuZGVmaW5lZCIhPXR5cGVvZiBUZXh0RGVjb2RlciYmbmV3IFRleHREZWNvZGVyKCJ1dGYtMTZsZSIpO3ZhciBWLHEsTixHPTY1NTM2O2Z1bmN0aW9uIFgodCl7Vj10LGUuSEVBUDg9bmV3IEludDhBcnJheSh0KSxlLkhFQVAxNj1uZXcgSW50MTZBcnJheSh0KSxlLkhFQVAzMj1OPW5ldyBJbnQzMkFycmF5KHQpLGUuSEVBUFU4PXE9bmV3IFVpbnQ4QXJyYXkodCksZS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheSh0KSxlLkhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KHQpLGUuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KHQpLGUuSEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KHQpfXZhciBZPTUyODk3MjgsJD00NjY4OCxKPWUuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2Z1bmN0aW9uIEsodCl7Zm9yKDt0Lmxlbmd0aD4wOyl7dmFyIG49dC5zaGlmdCgpO2lmKCJmdW5jdGlvbiIhPXR5cGVvZiBuKXt2YXIgcj1uLmZ1bmM7Im51bWJlciI9PXR5cGVvZiByP3ZvaWQgMD09PW4uYXJnP2UuZHluQ2FsbF92KHIpOmUuZHluQ2FsbF92aShyLG4uYXJnKTpyKHZvaWQgMD09PW4uYXJnP251bGw6bi5hcmcpfWVsc2UgbigpfX0oVT1lLndhc21NZW1vcnk/ZS53YXNtTWVtb3J5Om5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6Si9HLG1heGltdW06Si9HfSkpJiYoVj1VLmJ1ZmZlciksSj1WLmJ5dGVMZW5ndGgsWChWKSxOWyQ+PjJdPVk7dmFyIFE9W10sWj1bXSxlZT1bXSx0ZT1bXTtmdW5jdGlvbiBuZSgpe2lmKGUucHJlUnVuKWZvcigiZnVuY3Rpb24iPT10eXBlb2YgZS5wcmVSdW4mJihlLnByZVJ1bj1bZS5wcmVSdW5dKTtlLnByZVJ1bi5sZW5ndGg7KXVlKGUucHJlUnVuLnNoaWZ0KCkpO0soUSl9ZnVuY3Rpb24gcmUoKXtLKFopfWZ1bmN0aW9uIG9lKCl7SyhlZSl9ZnVuY3Rpb24gaWUoKXtpZihlLnBvc3RSdW4pZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBlLnBvc3RSdW4mJihlLnBvc3RSdW49W2UucG9zdFJ1bl0pO2UucG9zdFJ1bi5sZW5ndGg7KWFlKGUucG9zdFJ1bi5zaGlmdCgpKTtLKHRlKX1mdW5jdGlvbiB1ZShlKXtRLnVuc2hpZnQoZSl9ZnVuY3Rpb24gYWUoZSl7dGUudW5zaGlmdChlKX12YXIgc2U9MCxjZT1udWxsLGZlPW51bGw7ZnVuY3Rpb24gbGUodCl7c2UrKyxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhzZSl9ZnVuY3Rpb24gcGUodCl7aWYoc2UtLSxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhzZSksMD09c2UmJihudWxsIT09Y2UmJihjbGVhckludGVydmFsKGNlKSxjZT1udWxsKSxmZSkpe3ZhciBuPWZlO2ZlPW51bGwsbigpfX1mdW5jdGlvbiBfZSh0KXt0aHJvdyBlLm9uQWJvcnQmJmUub25BYm9ydCh0KSxUKHQrPSIiKSxGKHQpLE09ITAsdD0iYWJvcnQoIit0KyIpLiBCdWlsZCB3aXRoIC1zIEFTU0VSVElPTlM9MSBmb3IgbW9yZSBpbmZvLiIsbmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih0KX1lLnByZWxvYWRlZEltYWdlcz17fSxlLnByZWxvYWRlZEF1ZGlvcz17fTt2YXIgZGU9ImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCwiO2Z1bmN0aW9uIGhlKGUpe3JldHVybiBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGg/ZS5zdGFydHNXaXRoKGRlKTowPT09ZS5pbmRleE9mKGRlKX12YXIgbWU9Ik9nZ09wdXNFbmNvZGVyLndhc20iO2Z1bmN0aW9uIHllKCl7dHJ5e2lmKGspcmV0dXJuIG5ldyBVaW50OEFycmF5KGspO2lmKEIpcmV0dXJuIEIobWUpO3Rocm93ImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkIn1jYXRjaChlKXtfZShlKX19ZnVuY3Rpb24gdmUoKXtyZXR1cm4ga3x8IUMmJiFTfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2g/bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7ZSh5ZSgpKX0pKTpmZXRjaChtZSx7Y3JlZGVudGlhbHM6InNhbWUtb3JpZ2luIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKCFlLm9rKXRocm93ImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJyIrbWUrIiciO3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIHllKCl9KSl9ZnVuY3Rpb24gYmUoKXt2YXIgdD17YTpSZX07ZnVuY3Rpb24gbih0LG4pe3ZhciByPXQuZXhwb3J0cztlLmFzbT1yLHBlKCl9ZnVuY3Rpb24gcihlKXtuKGUuaW5zdGFuY2UpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIHZlKCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsdCl9KSkudGhlbihlLChmdW5jdGlvbihlKXtGKCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAiK2UpLF9lKGUpfSkpfWlmKGxlKCksZS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBlLmluc3RhbnRpYXRlV2FzbSh0LG4pfWNhdGNoKGUpe3JldHVybiBGKCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAiK2UpLCExfXJldHVybiBmdW5jdGlvbigpe2lmKGt8fCJmdW5jdGlvbiIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8aGUobWUpfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2gpcmV0dXJuIG8ocik7ZmV0Y2gobWUse2NyZWRlbnRpYWxzOiJzYW1lLW9yaWdpbiJ9KS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZSx0KS50aGVuKHIsKGZ1bmN0aW9uKGUpe0YoIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAiK2UpLEYoImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uIiksbyhyKX0pKX0pKX0oKSx7fX1mdW5jdGlvbiBnZSh0LG4pe3ZhciByPW5ldyBVaW50OEFycmF5KGUuSEVBUFU4LmJ1ZmZlcix0LG4pO2UuZW5jb2RlZEJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShyKS5idWZmZXIpfWZ1bmN0aW9uIHdlKGUsdCxuLHIpe19lKCJBc3NlcnRpb24gZmFpbGVkOiAiK0woZSkrIiwgYXQ6ICIrW3Q/TCh0KToidW5rbm93biBmaWxlbmFtZSIsbixyP0wocik6InVua25vd24gZnVuY3Rpb24iXSl9ZnVuY3Rpb24gQWUoKXtfZSgpfWZ1bmN0aW9uIENlKGUsdCxuKXtxLmNvcHlXaXRoaW4oZSx0LHQrbil9ZnVuY3Rpb24gU2UoZSl7X2UoIk9PTSIpfWZ1bmN0aW9uIHhlKGUpe1NlKCl9aGUobWUpfHwobWU9aihtZSkpLFoucHVzaCh7ZnVuYzpmdW5jdGlvbigpe2tlKCl9fSk7dmFyIFBlPXttYXBwaW5nczp7fSxidWZmZXJzOltudWxsLFtdLFtdXSxwcmludENoYXI6ZnVuY3Rpb24oZSx0KXt2YXIgbj1QZS5idWZmZXJzW2VdOzA9PT10fHwxMD09PXQ/KCgxPT09ZT9UOkYpKHoobiwwKSksbi5sZW5ndGg9MCk6bi5wdXNoKHQpfSx2YXJhcmdzOnZvaWQgMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUGUudmFyYXJncys9NCxOW1BlLnZhcmFyZ3MtND4+Ml19LGdldFN0cjpmdW5jdGlvbihlKXtyZXR1cm4gTChlKX0sZ2V0NjQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZX19O2Z1bmN0aW9uIEVlKGUpe3JldHVybiAwfWZ1bmN0aW9uIEJlKGUsdCxuLHIsbyl7fWZ1bmN0aW9uIEllKGUsdCxuLHIpe2Zvcih2YXIgbz0wLGk9MDtpPG47aSsrKXtmb3IodmFyIHU9Tlt0KzgqaT4+Ml0sYT1OW3QrKDgqaSs0KT4+Ml0scz0wO3M8YTtzKyspUGUucHJpbnRDaGFyKGUscVt1K3NdKTtvKz1hfXJldHVybiBOW3I+PjJdPW8sMH12YXIgUmU9e2E6d2UsYzpBZSxkOmdlLGY6Q2UsZzp4ZSxoOkVlLGU6QmUsYjpJZSxtZW1vcnk6VSx0YWJsZTpIfSxPZT1iZSgpO2UuYXNtPU9lO3ZhciBqZSxrZT1lLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihrZT1lLl9fX3dhc21fY2FsbF9jdG9ycz1lLmFzbS5pKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFVlPShlLl9fX2VtX2pzX19lbXNjcmlwdGVuUHVzaEJ1ZmZlcj1mdW5jdGlvbigpe3JldHVybihlLl9fX2VtX2pzX19lbXNjcmlwdGVuUHVzaEJ1ZmZlcj1lLmFzbS5qKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX2Vtc2NyaXB0ZW5fYmluZF9Wb2lkUHRyX19fZGVzdHJveV9fXzA9ZnVuY3Rpb24oKXtyZXR1cm4oVWU9ZS5fZW1zY3JpcHRlbl9iaW5kX1ZvaWRQdHJfX19kZXN0cm95X19fMD1lLmFzbS5rKS5hcHBseShudWxsLGFyZ3VtZW50cyl9KSxUZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX0NvbnRhaW5lcl8wPWZ1bmN0aW9uKCl7cmV0dXJuKFRlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfQ29udGFpbmVyXzA9ZS5hc20ubCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxGZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX2luaXRfMz1mdW5jdGlvbigpe3JldHVybihGZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX2luaXRfMz1lLmFzbS5tKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfd3JpdGVGcmFtZV8zPWZ1bmN0aW9uKCl7cmV0dXJuKEhlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfd3JpdGVGcmFtZV8zPWUuYXNtLm4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTWU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9fX2Rlc3Ryb3lfX18wPWZ1bmN0aW9uKCl7cmV0dXJuKE1lPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfX19kZXN0cm95X19fMD1lLmFzbS5vKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIFdlKGUpe3RoaXMubmFtZT0iRXhpdFN0YXR1cyIsdGhpcy5tZXNzYWdlPSJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCIrZSsiKSIsdGhpcy5zdGF0dXM9ZX1mdW5jdGlvbiBEZSh0KXtmdW5jdGlvbiBuKCl7amV8fChqZT0hMCxlLmNhbGxlZFJ1bj0hMCxNfHwocmUoKSxvZSgpLGUub25SdW50aW1lSW5pdGlhbGl6ZWQmJmUub25SdW50aW1lSW5pdGlhbGl6ZWQoKSxpZSgpKSl9dD10fHxBLHNlPjB8fChuZSgpLHNlPjB8fChlLnNldFN0YXR1cz8oZS5zZXRTdGF0dXMoIlJ1bm5pbmcuLi4iKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS5zZXRTdGF0dXMoIiIpfSksMSksbigpfSksMSkpOm4oKSkpfWlmKGUuX29wdXNfZW5jb2Rlcl9jcmVhdGU9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fb3B1c19lbmNvZGVyX2NyZWF0ZT1lLmFzbS5wKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX29wdXNfZW5jb2RlX2Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX29wdXNfZW5jb2RlX2Zsb2F0PWUuYXNtLnEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fb3B1c19lbmNvZGVyX2N0bD1mdW5jdGlvbigpe3JldHVybihlLl9vcHVzX2VuY29kZXJfY3RsPWUuYXNtLnIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fb3B1c19lbmNvZGVyX2Rlc3Ryb3k9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fb3B1c19lbmNvZGVyX2Rlc3Ryb3k9ZS5hc20ucykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fbWFsbG9jPWUuYXNtLnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fZnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9mcmVlPWUuYXNtLnUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZS5hc20udikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1mdW5jdGlvbigpe3JldHVybihlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1lLmFzbS53KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWUuYXNtLngpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5keW5DYWxsX3ZpPWZ1bmN0aW9uKCl7cmV0dXJuKGUuZHluQ2FsbF92aT1lLmFzbS55KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuZHluQ2FsbF92PWZ1bmN0aW9uKCl7cmV0dXJuKGUuZHluQ2FsbF92PWUuYXNtLnopLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5hc209T2UsZS50aGVuPWZ1bmN0aW9uKHQpe2lmKGplKXQoZSk7ZWxzZXt2YXIgbj1lLm9uUnVudGltZUluaXRpYWxpemVkO2Uub25SdW50aW1lSW5pdGlhbGl6ZWQ9ZnVuY3Rpb24oKXtuJiZuKCksdChlKX19cmV0dXJuIGV9LGZlPWZ1bmN0aW9uIGUoKXtqZXx8RGUoKSxqZXx8KGZlPWUpfSxlLnJ1bj1EZSxlLnByZUluaXQpZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBlLnByZUluaXQmJihlLnByZUluaXQ9W2UucHJlSW5pdF0pO2UucHJlSW5pdC5sZW5ndGg+MDspZS5wcmVJbml0LnBvcCgpKCk7ZnVuY3Rpb24gemUoKXt9ZnVuY3Rpb24gTGUoZSl7cmV0dXJuKGV8fHplKS5fX2NhY2hlX199ZnVuY3Rpb24gVmUoZSx0KXt2YXIgbj1MZSh0KSxyPW5bZV07cmV0dXJuIHJ8fCgocj1PYmplY3QuY3JlYXRlKCh0fHx6ZSkucHJvdG90eXBlKSkucHRyPWUsbltlXT1yKX1mdW5jdGlvbiBxZShlLHQpe3JldHVybiBWZShlLnB0cix0KX1mdW5jdGlvbiBOZShlKXtpZighZS5fX2Rlc3Ryb3lfXyl0aHJvdyJFcnJvcjogQ2Fubm90IGRlc3Ryb3kgb2JqZWN0LiAoRGlkIHlvdSBjcmVhdGUgaXQgeW91cnNlbGY/KSI7ZS5fX2Rlc3Ryb3lfXygpLGRlbGV0ZSBMZShlLl9fY2xhc3NfXylbZS5wdHJdfWZ1bmN0aW9uIEdlKGUsdCl7cmV0dXJuIGUucHRyPT09dC5wdHJ9ZnVuY3Rpb24gWGUoZSl7cmV0dXJuIGUucHRyfWZ1bmN0aW9uIFllKGUpe3JldHVybiBlLl9fY2xhc3NfX31mdW5jdGlvbiAkZSgpe3Rocm93ImNhbm5vdCBjb25zdHJ1Y3QgYSBWb2lkUHRyLCBubyBjb25zdHJ1Y3RvciBpbiBJREwifWZ1bmN0aW9uIEplKCl7dGhpcy5wdHI9VGUoKSxMZShKZSlbdGhpcy5wdHJdPXRoaXN9cmV0dXJuIERlKCksemUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoemUucHJvdG90eXBlKSx6ZS5wcm90b3R5cGUuY29uc3RydWN0b3I9emUsemUucHJvdG90eXBlLl9fY2xhc3NfXz16ZSx6ZS5fX2NhY2hlX189e30sZS5XcmFwcGVyT2JqZWN0PXplLGUuZ2V0Q2FjaGU9TGUsZS53cmFwUG9pbnRlcj1WZSxlLmNhc3RPYmplY3Q9cWUsZS5OVUxMPVZlKDApLGUuZGVzdHJveT1OZSxlLmNvbXBhcmU9R2UsZS5nZXRQb2ludGVyPVhlLGUuZ2V0Q2xhc3M9WWUsJGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoemUucHJvdG90eXBlKSwkZS5wcm90b3R5cGUuY29uc3RydWN0b3I9JGUsJGUucHJvdG90eXBlLl9fY2xhc3NfXz0kZSwkZS5fX2NhY2hlX189e30sZS5Wb2lkUHRyPSRlLCRlLnByb3RvdHlwZS5fX2Rlc3Ryb3lfXz0kZS5wcm90b3R5cGUuX19kZXN0cm95X189ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnB0cjtVZShlKX0sSmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoemUucHJvdG90eXBlKSxKZS5wcm90b3R5cGUuY29uc3RydWN0b3I9SmUsSmUucHJvdG90eXBlLl9fY2xhc3NfXz1KZSxKZS5fX2NhY2hlX189e30sZS5Db250YWluZXI9SmUsSmUucHJvdG90eXBlLmluaXQ9SmUucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMucHRyO2UmJiJvYmplY3QiPT09YShlKSYmKGU9ZS5wdHIpLHQmJiJvYmplY3QiPT09YSh0KSYmKHQ9dC5wdHIpLG4mJiJvYmplY3QiPT09YShuKSYmKG49bi5wdHIpLEZlKHIsZSx0LG4pfSxKZS5wcm90b3R5cGUud3JpdGVGcmFtZT1KZS5wcm90b3R5cGUud3JpdGVGcmFtZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcy5wdHI7ZSYmIm9iamVjdCI9PT1hKGUpJiYoZT1lLnB0ciksdCYmIm9iamVjdCI9PT1hKHQpJiYodD10LnB0ciksbiYmIm9iamVjdCI9PT1hKG4pJiYobj1uLnB0ciksSGUocixlLHQsbil9LEplLnByb3RvdHlwZS5fX2Rlc3Ryb3lfXz1KZS5wcm90b3R5cGUuX19kZXN0cm95X189ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnB0cjtNZShlKX0sZX0pOyJvYmplY3QiPT09YSh0KSYmIm9iamVjdCI9PT1hKGkpP2kuZXhwb3J0cz1wOnZvaWQgMD09PSh1PWZ1bmN0aW9uKCl7cmV0dXJuIHB9LmFwcGx5KHQsW10pKXx8KGkuZXhwb3J0cz11KX0pLmNhbGwodGhpcywiL2luZGV4LmpzIixuKDIpLCIvIixuKDMpKGUpKX1dKTt9fSk7","base64")))
          },
          OggOpusEncoderWasmPath: tob(Buffer("AGFzbQEAAAABtwVDYAF/AX9gBH9/f38AYAN/f38AYAF/AGACf38Bf2AFf39/f38AYAJ/fwBgA39/fwF/YAZ/f39/f38AYAZ/f39/f38Bf2AFf39/f38Bf2AEf39/fwF/YAAAYAd/f39/f39/AGABfAF8YAh/f39/f39/fwBgC39/f39/f39/f39/AGAHf39/f39/fwF/YAR/f39/AX1gCX9/f39/f39/fwBgCn9/f39/f39/f38AYA9/f39/f39/f39/f39/f38AYAR/f31/AGAEf35+fwBgAAF/YAp/f39/f39/f39/AX9gC39/f39/f39/f39/AX9gBn98f39/fwF/YAJ+fwF/YAJ8fwF8YAJ8fAF8YAx/f39/f39/f39/f38AYBF/f39/f39/f39/f39/f39/fwBgFn9/f39/f39/f39/f39/f39/f39/f38AYBp/f39/f39/f39/f39/f39/f39/f39/f39/fwBgDH9/f39/fX1/f39/fwBgBH9/f30AYAN/f30AYAV/f31/fwBgCX9/fX1/f39/fwBgA399fwBgCX9/f39/f39/fwF/YAx/f39/f39/f39/f38Bf2ASf39/f39/f39/f39/f39/f39/AX9gD39/f39/f39/f39/f399fwF/YAp/f39/f39/f31/AX9gC39/f39/f39/fX9/AX9gCX9/f39/f399fwF/YAd/f39/f399AX9gCX9/f39/f31/fwF/YAt/f39/f399fX9/fwF/YAR/f39+AX9gA35/fwF/YAF9AX9gAn1/AX9gAnx/AX9gA39+fwF+YAN/f38BfWAJf39/f39/f39/AX1gE39/f39/f39/f39/f39/f39/f38BfWAGf39/f31/AX1gBn9/fX9/fwF9YAR9fX9/AX1gAn9/AXxgA39/fwF8YAJ+fgF8YAN8fH8BfAJMCgFhAWEAAQFhAWIACwFhAWMADAFhAWQABgFhAWUACgFhAWYABwFhAWcAAAFhAWgAAAFhBm1lbW9yeQIBgAKAAgFhBXRhYmxlAXAAJAPRAs8CBwEHBwMANQI/BQIHBwACLgAHAAsdHAADAAAJL0IeDgAAQAYGAgQFAwADBAUABh4MDgUFJQEAAQQACAIBAgAKAAATBhoNCAgHAAUBAg4OBQUBCwUHAAEEBAQDAgAdBAcIPgAnKgcKBwQ6AQAQAQIA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ACACRQ0AGiAEQQh1IgEgBEEBcUUNABogAigCACABaigCAAsgAmogA0ECIARBAnEbIAAoAgAoAhwRAQALHAAgABDFAiABBEAgACABEMICIAAgARC+AgsgAAsLACAAIAE2AgAgAAsjACAAQQA2AgwgACABNgIEIAAgATYCACAAIAFBAWo2AgggAAspAQF/IwBBEGsiASQAIAFBADYCDEGIGigCACIBIAAQugEgARCuARACAAujAgACQAJAIAFBFEsNACABQXdqIgFBCUsNAAJAAkACQAJAAkACQAJAAkAgAUEBaw4JAQIJAwQFBgkHAAsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgACACQQoRBgALDwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC0IBA38gACgCACwAABAhBEADQCAAKAIAIgIsAAAhAyAAIAJBAWo2AgAgAyABQQpsakFQaiEBIAIsAAEQIQ0ACwsgAQt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARBkIQAgASgCAEFAags2AgAgAA8LIAEgAkGCeGo2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLEgAgAEUEQEEADwsgACABEL4BC+4FAgp/AX4CQCAARQ0AIAAoAhwiB0H/ASAHQf8BSBsiA0UNACAAKAIAIghFDQACQAJAAkAgACgCzAIiCQRAIAdBAU4NAUJ/IQ1BACEDDAILIANBACADQQBKGyEDA0AgAyAFRg0CIAVBAnQhBiAFQQFqIgQhBSAGIAAoAhBqLQAAQf8BRg0ACyAEIQMMAQsgA0EBIANBAUobIQRCfyENQQAhAwJAA0AgBUGAIEwgBkEDTHJFBEBBASECDAILQQAhBiAAKAIQIANBAnRqLQAAIgpB/wFHBEAg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BUGBAiAFQYECSBshBkEBIARB6QdHDQEaIA1BwANqIAZBfmpBgAIQLEEBDAELIABBADYCwG5BACEGQQALIQUCfyASKAIAIgdB6AdGBEAgDSgC3AMhBCANKALUAyEIIA1BwANqEJYBIAggBGdqQWdqQQN1IgwMAQsgDUHAA2ogGCAGayIMECtBAAshCAJAAkAgBUUEQCASKAIAQegHRg0BCyANIA1BqARqNgLwASAOQabOACANQfABahALGiASKAIAQekHRw0AIA0gACgCZDYCuAMgDSAAKAJoNgK8AyANIA1BuANqNgLQASAOQazOACANQdABahALGgwBCyANQQA2AuABIA5BrM4AIA1B4AFqEAsaCyAUQQBHIAVxIgRBAUYEQCANQQA2AsABIA5Bms4AIA1BwAFqEAsaIA1BADYCsAEgDkGmHyANQbABahALGiANQX82AqABIA5Boh8gDUGgAWoQCxpBfSAOIBEgACgCkAFByAFtIAwgF2ogBkEAECJBAEgNARogDSANQegEajYCkAEgDkG/HyANQZABahALGiAOQbwfQQAQCxoLIA1BAEERIAdB6gdGGzYCgAEgDkGazgAgDUGAAWoQCxoCQCASKAIAIgdB6AdGDQAgByAAKAKsbiILRiALQQFIckUEQCAOQbwfQQAQCxogDiAJIAAoApABQZADbSANQbgDakECQQAQIhogDUEANgJwIA5Bks4AIA1B8ABqEAsaCyANKALUAyANKALcA2dqQWBqIAxBA3RKDQACQCAERQ0AIBIoAgBB6QdHDQAgACgClAFFDQAgDSAAKAKgASAAKAIkazYCYCAOQaIfIA1B4ABqEAsaCyANIAAoApQBNgJQIA5Bph8gDUHQAGoQCxpBfSAOIBEgAkEAIAwgDUHAA2oQIiIIQQBIDQEaIARFDQAgEigCAEHpB0cNACAAKAKUAUUNACAIIBdqIAwgF2ogBhATGiAGIAxqIQwLAkAgFCAFRXJFBEAgACgCkAEhBCAOQbwfQQAQCxogDUEANgJAIA5Bms4AIA1BQGsQCxogDUEANgIwIA5Bks4AIA1BMGoQCxogDUEANgIgIA5Bph8gDUEgahALGiANQX82AhAgDkGiHyANQRBqEAsaIARBkANtIQcgBEHIAW0hBCAAKAKobkHpB0YEQCANQcADaiAIECsgCCEMCyAOIBEgACgCcCACIARrIgkgB2tsQQJ0aiAHIA1BuANqQQJBABAiGiAOIBEgACgCcCAJbEECdGogBCAMIBdqIAZBABAiQQBIDQEgDSANQegEajYCACAOQb8fIA0QCxoLIAAoAohuIQcgACgCqG4hCUEAIQwgACgCkAEgAm0iBEGPA0wEQANAIAxBAWohDCAEQQF0IgRBkANIDQALIAxBA3QhDAsgAwJ/AkAgCUGYeGoiBEECSw0AAkACQCAEQQFrDgICAQALIAxBcGogCkEFdEHgAGpB4AFxcgwCCyAKQc4IIApBzghKG0EFdEFAa0HgAHEgDHJBgAFyDAELIAxB8AFqIApBBHRyQeAAcgsgB0ECRkECdHI6AAAgACANKALcAyIHIA0oAugEczYC8IwBIAAgIAR/QeoHBSASKAIACzYCrG4gAEEANgLEbiAAIAI2ArRuIAAgACgCiG4iCTYCsG4CQCAAKAK4AUUNACANKAKoBCAlckUNAAJAICQEQCANKgLIBEPNzMw9XUEBcw0BIAAqAuiMASEnQwAAAAAhKCAAKAJwIAJsIgRBAU4EQEEAIQwDQCAoIAEgDEECdGoqAgAiKCAolJIhKCAMQQFqIgwgBEcNAAsLICggBLKVQ3EdnkOUICdfQQFzDQELIAAgACgC5IwBIgFBAWo2AuSMASABQQpIDQEgAUEeTgRAIABBCjYC5IwBDAILQQAhDCAAQQA2AvCMASAAKAKobiEBIAAoApABIAJtIgBBjwNMBEADQCAMQQFqIQwgAEEBdCIAQZADSA0ACyAMQQN0IQwLIAMCfwJAIAFBmHhqIgBBAksNAAJAAkAgAEEBaw4CAgEACyAMQXBqIApBBXRB4ABqQeABcXIMAgsgCkHOCCAKQc4IShtBBXRBQGtB4ABxIAxyQYABcgwBCyAMQfABaiAKQQR0ckHgAHILIAlBAkZBAnRyOgAAQQEMAwsgAEEANgLkjAELAkAgDSgC1AMgB2dqQWBqIBhBA3RKBEBBfiATQQJIDQMaIBdBADoAACAAQQA2AvCMAUEBIQgMAQsgCEEDSA0AIAUgEigCAEHoB0dyDQADQCADIAhqLQAADQEgCEEDSiEBIAhBf2ohCCABDQALQQIhCAsgBiAIakEBaiEBAkAgACgClAEEQCABIRMMAQtBfSADIAEgExBsDQIaCyATDAELQX0LIQwLIA1B8ARqJAAgDAt0AQJ/IwBBsAJrIgMkAEF/IQQCQCABQQFIDQBBACEEIAEgAkYNAEF/IQQgASACSg0AIANBADYCBCADIAAgAmogAWsgACABEBMgARBuIgQNACADIAMoAgQgACACQQEQbSIAQR91IABxIQQLIANBsAJqJAAgBAu3BgEHf0F/IQUCQCABQQBMDQAgACgCBCABSA0AIABByAFqIQgCQAJAAkAgASIHQX9qIgVBAU0EQCAFQQFrBEBBfiEFIAguAQBBAWoiBiADSg0FIAIgAC0AAEH8AXE6AAAgAkEBaiEFDAILIAgvAQAiBUEQdEEQdSEGIAUgCC8BAiIJRgRAQX4hBSAGQQF0QQFyIgYgA0oNBSACIAAtAABB/AFxQQFyOgAAIAJBAWohBQwCC0F+IQUgCUEQdEEQdSAGaiAGQfsBSmpBAmoiBiADSg0EIAIgAC0AAEH8AXFBAnI6AAAgCC4BACACQQFqIgUQbyAFaiEFDAELIAIhBSAHQQJKDQELIARFIAYgA05yDQELQQEhBSAILgEAIQYCfwJAIAdBAUwNACAGQf//A3EhCQNAIAkgCCAFQQF0ai8BAEYEQCAHIAVBAWoiBUcNAQwCCwtBASEFIAZBAmpBAkEBIAZB+wFKG2ohBiABQX9qIglBAk4EQANAIAYgCCAFQQF0ai4BACIKakECQQEgCkH7AUobaiEGIAVBAWoiBSAJRw0ACwtBfiEFIAYgCCAHQX9qQQF0ai4BAGoiBiADSg0DIAAtAAAhBSACIAdBgH9yIgk6AAEgAiAFQQNyOgAAQQAMAQtBfiEFIAYgB2xBAmoiBiADSg0CIAAtAAAhBSACIAc6AAEgAiAFQQNyOgAAIAchCUEBCyELIAJBAmohBQJAIARFDQAgAyAGayIKRQ0AIAIgCUHAAHI6AAEgCkF/akH/AW0hBiAKQYACTgRAIAVB/wEgBkEBIAZBAUobIgUQChogAiAFakECaiEFCyAFIAZBgX5sIApqQX9qOgAAIAVBAWohBSADIQYLIAsgB0ECSHINACABQX9qIgFBASABQQFKGyEJQQAhAQNAIAggAUEBdGouAQAgBRBvIAVqIQUgAUEBaiIBIAlHDQALCyAHQQFOBEAgAEEIaiEBQQAhAANAIAUgASAAQQJ0aigCACAIIABBAXRqIgUuAQAQEyAFLgEAaiEFIABBAWoiACAHRw0ACwsgBEUgBSACIANqT3JFBEAgBUEAIAIgAyAFa2oQChoLIAYhBQsgBQu3AQEEfyMAQRBrIgQkAEF8IQMCQCACQQFIDQACQCAAKAIERQRAIAAgAS0AADoAACAAIAEQ4wE2AqgCDAELIAEtAAAgAC0AAHNBA0sNAQsgASACEOEBIgVBAUgNACAAKAKoAiAAKAIEIgYgBWpsQcAHSg0AIAEgAiAEQQ9qIAAgBkECdGpBCGogACAGQQF0akHIAWoQ4gEiA0EBSA0AIAAgACgCBCAFajYCBEEAIQMLIARBEGokACADCzYBAX8gAEH7AUwEQCABIAA6AABBAQ8LIAEgAEF8ciICOgAAIAEgACACQf8BcWtBAnY6AAFBAgvFBQIDfwh9IwAiCSEKIARFBEAgCiQAQwAAAAAPCwJAIAhBgPcCRgRAIAVBAXQhBSAEQQF0IQQMAQsgCEGA/QBHDQAgBUEBdEEDbSEFIARBAXRBA20hBAsgCSAEQQJ0QQ9qQXBxayIJIgskACABIAkgBCAFQQAgBiAHIAARDQBDAAAAOCAHspVDAACAN0MAAAA4IAZBf0obIAZBfkYbIQ0gBEEBTgRAQQAhBgNAIAkgBkECdGoiACANIAAqAgCUOAIAIAZBAWoiBiAERw0ACwsCQCAIQYD3AkYEQCAEQQJtIQBDAAAAACENIARBAkgNAUEAIQYDQCADIAkgBkEDdCIBaioCACIMIAwgAyoCACIOk0P/gBs/lCIPkjgCACADIAkgAUEEcmoqAgAiDCAMIAMqAgQiEJNDwD4aPpQiEZI4AgQgAyAMjCADKgIIIhKTQ8A+Gj6UIhMgDJM4AgggAiAGQQJ0aiAQIA4gD5IiDJIgEZJDAAAAP5Q4AgAgDSAMIBKSIBOSIg0gDZSSIQ0gBkEBaiIGIABHDQALDAELQwAAAAAhDSAIQYD9AEcEQCAIQcC7AUcNASACIAkgBEECdBAIGgwBCyALIARBA2wiAUECdEEPakFwcWsiACQAIARBAU4EQEEAIQYDQCAAIAZBDGxqIgUgCSAGQQJ0aigCACIHNgIIIAUgBzYCBCAFIAc2AgAgBkEBaiIGIARHDQALCyABQQJtIQQgAUECTgRAQQAhBgNAIAMgACAGQQN0IgFqKgIAIgwgDCADKgIAIg6TQ/+AGz+UIg+SOAIAIAMgACABQQRyaioCACIMIAwgAyoCBCIQk0PAPho+lCIRkjgCBCADIAyMIAMqAgiTQ8A+Gj6UIAyTOAIIIAIgBkECdGogECAOIA+SkiARkkMAAAA/lDgCACAGQQFqIgYgBEcNAAsLCyAKJAAgDQtKAAJAIAFBgPcCRgRAIAJBf2pB/wFxQQJPDQEgACACOgAIIABBgPcCNgIEDwtB+AtBjQxBFEGvDBAAAAtBtAxBjQxBFkGvDBAAAAsiACAAQaD1ACgCAEECdEGk9QAoAgBBBHRqQYAgamxB7AFqC8sSAgp/A30gACgCJCESIAAoAhwhDSAAKAIQIRAgACgCACEMQQEhCwJ/IAUoAgAiDiAAKAIIIhMoAjggACgCDCIPQQF0ai4BACAIQQN0aiIIa0FgaiIRIAhBAXVBEEEEIARBAkYgCUEAR3EiCBtrIARBAXRBfkF/IAgbaiIIbCAOaiAIbSIIIBEgCEgbIghBwAAgCEHAAEgbIghBBE4EQCAIQQdxQQF0QdCtAmouAQBBDiAIQQN2a3VBAWpBfnEhCwsgCwtBASALIAkbIA8gEEgbIQsCfwJAAkACQAJAAkACQAJAAkACQCAMBEAgAiADIAkgBCAAKAIsEPoBIQggDRAVIRAgC0EBRwRAAkACfwJAIAkEQCAAKAIwIgANASAIIAtsQYBAa0EOdQwCCwJAIAggC2wiDEGAQGsiDkEOdSIIIAtOBEAgCCEADAELIAxBgMAASARAIAghAAwBCyAAKAI4RQRAIAghAAwBCyAOQYCAf3EgCyIAbkEQdCIOQQ11IA5BEHVsQYCAAmpBEHUiDEGOe2xBgIABakEPdUHVwABqIAxsQQF0QYCAAmpBgIB8cUGAgPSQfmpBEHUgDGxBgIABakEPdiAMa0EQdEGAgICAeGpBEHUiEWciFEGAgICABCAOayIMQQ11IAxBEHVsQYCAAmpBEHUiDEGOe2xBgIABakEPdUHVwABqIAxsQQF0QYCAAmpBgIB8cUGAgPSQfmpBEHUgDGxBgIABakEPdiAMa0EQdEGAgICAeGpBEHUiDGciDmtBC3QgESAUQW9qdEEQdEEQdSIRQdtrbEGAgAFqQQ91Qfw9aiARbEGAgAFqQQ92ayAMIA5Bb2p0QRB0QRB1IgxB22tsQYCAAWpBD3VB/D1qIAxsQYCAAWpBD3ZqQRB0QRB1IARBF3RBgICAfGpBEHVsQYCAAWpBD3UiDCAFKAIAIg5KDQBBACAIIAxBACAOa0gbIQALIAdBAUwNAgwHCyAAQX9zQR92QQAgCCALbEH//wFBgYB+IAhBgMAAShsgC21qIgBBDnUgAEEASBsiACALQX9qIAsgAEobagshACAEQQJMDQUgDSAAQQNsIgkgC0ECbSIHQQNsQQNqIgggB0F/c2ogAGogACAHTCIMGyAJQQNqIAggB2sgAGogDBsgByAIahA+IABBDnQiACALbiEIDAYLIABBAWoiByALIABrIghBAWoiCSAAIAtBAXUiAkwbIQ8gAkEBaiIDIANsIQMgDSAAIAJMBH8gACAHbEEBdQUgAyAJIAhBAmpsQQF1awsiCSAJIA9qIAMQPiAAQQ50IAtuIQgMBwsgCUUNBkEAIQlBACEHAkAgCEGBwABIDQAgACgCNCIIDQBBASEHIARBAUgNACAIRSEHQQAhCwNAIAMgC0ECdGoiCCAIKgIAjDgCACALQQFqIgsgBEcNAAsLIARBAUgNASASIBMoAgggD2pBAnRqKgIAIhUgEiAPQQJ0aioCACIWIBaUQ30dkCaSIBUgFZSSkUN9HZAmkiIVlSEXIBYgFZUhFQNAIAIgCUECdCIIaiILIBUgCyoCAJQgFyADIAhqKgIAlJI4AgAgCUEBaiIJIARHDQALDAELIA0QFSEQIAtBAUcNAUEAIQcgCUUNBAtBAAJ/QQAgBSgCAEERSA0AGkEAIAAoAiBBEUgNABogDARAIA0gB0ECEBIgBwwBCyANEL0CCyAAKAI0GyEHDAMLAkAgCUUgBEEDSHJFBEAgDQJ/IA0gC0ECbSIAQQFqIgdBA2wiAiAAaiIIEJMBIgMgAkgEQCADQQNtDAELIAMgB0EBdGsLIglBA2wiAyACIABBf3NqIAlqIAkgAEwiBxsgA0EDaiACIABrIAlqIAcbIAgQkgEMAQtBACAHQQFMIAkbRQRAIA0gC0EBahCRASEJDAELIA0CfyANIAtBAXUiB0EBaiIAIABsIgMQkwEiAiAAIAdsQQF1SARAIAJBA3RBAXIQdkF/akEBdiIJQQFqIgAgCWxBAXYMAQsgAyALQQFqIgAgAEEBdCACQX9zIANqQQN0QQFyEHZrQQF2IglrIgAgCyAJa0ECamxBAXVrCyICIAAgAmogAxCSAQsgCUEOdCALbiEIDAMLIA0gACALQQFqECwgAEEOdCIAIAtuIQggCUUNAgsgCyAASwRAQQAhByAEQQFIDQEgEiATKAIIIA9qQQJ0aioCACIVIBIgD0ECdGoqAgAiFiAWlEN9HZAmkiAVIBWUkpFDfR2QJpIiFZUhFyAWIBWVIRVBACEJA0AgAiAJQQJ0IgBqIgggFSAIKgIAlCAXIAAgA2oqAgCUkjgCACAJQQFqIgkgBEcNAAsMAQsgBEEBSA0BQQAhCQNAIAIgCUECdCIAaiIHIAcqAgBD8wQ1P5QiFSAAIANqIgAqAgBD8wQ1P5QiFpI4AgAgACAWIBWTOAIAIAlBAWoiCSAERw0ACwwBCyANEBUhACAFIAUoAgAgACAQayIAazYCAAwBCyANEBUhACAFIAUoAgAgACAQayIAazYCAEGAgAEhCSAIQYCAAUYNASAIDQIgCCEHCyAKIAooAgBBfyAGdEF/c3E2AgBB//8BIQNBACEJQQAhAkGAgH8MAgsgCiAKKAIAQX8gBnRBf3MgBnRxNgIAQf//ASECQQAhB0EAIQNBgIABDAELQQAhByAIIQkgCEEQdCIFQQ11IAVBEHVsQYCAAmpBEHUiAkGOe2xBgIABakEPdUHVwABqIAJsQQF0QYCAAmpBgIB8cUGAgPSQfmpBEHUgAmxBgIABakEPdiACa0EQdEGAgICAeGpBEHUiA2ciBkGAgICABCAFayICQQ11IAJBEHVsQYCAAmpBEHUiAkGOe2xBgIABakEPdUHVwABqIAJsQQF0QYCAAmpBgIB8cUGAgPSQfmpBEHUgAmxBgIABakEPdiACa0EQdEGAgICAeGpBEHUiAmciBWtBC3QgAyAGQW9qdEEQdEEQdSIGQdtrbEGAgAFqQQ91Qfw9aiAGbEGAgAFqQQ92ayACIAVBb2p0QRB0QRB1IgVB22tsQYCAAWpBD3VB/D1qIAVsQYCAAWpBD3ZqQRB0QRB1IARBF3RBgICAfGpBEHVsQYCAAWpBD3ULIQQgASAANgIUIAEgCTYCECABIAQ2AgwgASACNgIIIAEgAzYCBCABIAc2AgALkQIBB38jACIEIQggBCABIAJsIglBAnRBD2pBcHFrIgUkAAJAIANFBEAgAkEBSA0BQQAhBCABQQFIIQYDQCAGRQRAIAEgBGwhB0EAIQMDQCAFIAMgB2pBAnRqIAAgAiADbCAEakECdGooAgA2AgAgA0EBaiIDIAFHDQALCyAEQQFqIgQgAkcNAAsMAQsgAkEBSA0AIAJBAnRByKwCaiEGQQAhBCABQQFIIQcDQCAHRQRAIAYgBEECdGooAgAgAWwhCkEAIQMDQCAFIAMgCmpBAnRqIAAgAiADbCAEakECdGooAgA2AgAgA0EBaiIDIAFHDQALCyAEQQFqIgQgAkcNAAsLIAAgBSAJQQJ0EAgaIAgkAAulAQIFfwJ9IAJBAU4EQCABQQF1IgNBASADQQFKGyEFIAJBAXQhBkEAIQMgAUECSCEHA0BBACEBIAdFBEADQCAAIAEgBmwgA2pBAnRqIgQgBCoCAEPzBDU/lCIIIAAgAUEBdEEBciACbCADakECdGoiBCoCAEPzBDU/lCIJkjgCACAEIAggCZM4AgAgAUEBaiIBIAVHDQALCyADQQFqIgMgAkcNAAsLC1oBBH9BAUEfIABna0EBdSICdCEDA0AgAEEAIARBAXQgA2ogAnQiASAAIAFJIgEbayEAQQAgAyABGyAEaiEEIAJBAEohASADQQF2IQMgAkF/aiECIAENAAsgBAvKAQECfyMAQRBrIgEkAAJ8IAC9QiCIp0H/////B3EiAkH7w6T/A00EQEQAAAAAAADwPyACQZ7BmvIDSQ0BGiAARAAAAAAAAAAAECUMAQsgACAAoSACQYCAwP8HTw0AGiAAIAEQeEEDcSICQQJNBEACQAJAAkAgAkEBaw4CAQIACyABKwMAIAErAwgQJQwDCyABKwMAIAErAwhBARAkmgwCCyABKwMAIAErAwgQJZoMAQsgASsDACABKwMIQQEQJAshACABQRBqJAAgAAvACQMEfwF+BHwjAEEwayIEJAACQAJAAkAgAL0iBkIgiKciAkH/////B3EiA0H61L2ABE0EQCACQf//P3FB+8MkRg0BIANB/LKLgARNBEAgBkIAWQRAIAEgAEQAAEBU+yH5v6AiAEQxY2IaYbTQvaAiBzkDACABIAAgB6FEMWNiGmG00L2gOQMIQQEhAgwFCyABIABEAABAVPsh+T+gIgBEMWNiGmG00D2gIgc5AwAgASAAIAehRDFjYhphtNA9oDkDCEF/IQIMBAsgBkIAWQRAIAEgAEQAAEBU+yEJwKAiAEQxY2IaYbTgvaAiBzkDACABIAAgB6FEMWNiGmG04L2gOQMIQQIhAgwECyABIABEAABAVPshCUCgIgBEMWNiGmG04D2gIgc5AwAgASAAIAehRDFjYhphtOA9oDkDCEF+IQIMAwsgA0G7jPGABE0EQCADQbz714AETQRAIANB/LLLgARGDQIgBkIAWQRAIAEgAEQAADB/fNkSwKAiAETKlJOnkQ7pvaAiBzkDACABIAAgB6FEypSTp5EO6b2gOQMIQQMhAgwFCyABIABEAAAwf3zZEkCgIgBEypSTp5EO6T2gIgc5AwAgASAAIAehRMqUk6eRDuk9oDkDCEF9IQIMBAsgA0H7w+SABEYNASAGQgBZBEAgASAARAAAQFT7IRnAoCIARDFjYhphtPC9oCIHOQMAIAEgACAHoUQxY2IaYbTwvaA5AwhBBCECDAQLIAEgAEQAAEBU+yEZQKAiAEQxY2IaYbTwPaAiBzkDACABIAAgB6FEMWNiGmG08D2gOQMIQXwhAgwDCyADQfrD5IkESw0BCyABIAAgAESDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIIRAAAQFT7Ifm/oqAiByAIRDFjYhphtNA9oiIKoSIAOQMAIANBFHYiBSAAvUI0iKdB/w9xa0ERSCEDAn8gCJlEAAAAAAAA4EFjBEAgCKoMAQtBgICAgHgLIQICQCADDQAgASAHIAhEAABgGmG00D2iIgChIgkgCERzcAMuihmjO6IgByAJoSAAoaEiCqEiADkDACAFIAC9QjSIp0H/D3FrQTJIBEAgCSEHDAELIAEgCSAIRAAAAC6KGaM7oiIAoSIHIAhEwUkgJZqDezmiIAkgB6EgAKGhIgqhIgA5AwALIAEgByAAoSAKoTkDCAwBCyADQYCAwP8HTwRAIAEgACAAoSIAOQMAIAEgADkDCEEAIQIMAQsgBkL/////////B4NCgICAgICAgLDBAIS/IQBBACECA0AgBEEQaiACIgVBA3RqAn8gAJlEAAAAAAAA4EFjBEAgAKoMAQtBgICAgHgLtyIHOQMAIAAgB6FEAAAAAAAAcEGiIQBBASECIAVFDQALIAQgADkDIAJAIABEAAAAAAAAAABiBEBBAiECDAELQQEhBQNAIAUiAkF/aiEFIARBEGogAkEDdGorAwBEAAAAAAAAAABhDQALCyAEQRBqIAQgA0EUdkHqd2ogAkEBahCCAiECIAQrAwAhACAGQn9XBEAgASAAmjkDACABIAQrAwiaOQMIQQAgAmshAgwBCyABIAA5AwAgASAEKQMINwMICyAEQTBqJAAgAgvwBQILfwh9IwBBEGsiDyQAIA9CADcDCCAGQQNqIAVMBEAgCSAMQQMQEgsCfSAMBEBDAJgZPgwBCyALQQJ0IgZBsO0BaioCACEcIAZBwO0BaioCAAshHUEAIQYgASACSARAIApBASAKQQFKGyESIApBA2whEyAFQSBqIRQgACgCCCEFIAEhCwNAIA5BAEcgC0EBSnEhFSATIAIgC2tsIRYgByALQRQgC0EUSBtBAXQiCmohFyAHIApBAXJqIRhBACEKA0AgAyAFIApsIAtqQQJ0IgVqKgIAIhogBCAFaioCACIbQwAA4MGXIA2TIh5dQQFzIQUgBQJ/IBogHCAbQwAAEMGXlCIfkyAPQQhqIApBAnRqIhkqAgAiG5MiIEMAAAA/ko4iIYtDAAAAT10EQCAhqAwBC0GAgICAeAsiDEF/SnJFBEACfyAeIBqTIhqLQwAAAE9dBEAgGqgMAQtBgICAgHgLIAxqIgVBH3UgBXEhDAsgDyAMNgIEIBQgCSgCFGsgCSgCHGdrIRAgDCEFAkAgASALRg0AIBAgFmsiEUEXSg0AIA8gDEEBIAxBAUgbIgU2AgQgEUEPSg0AIA8gBUF/IAVBf0obIgU2AgQLIBUEQCAPIAVBH3UgBXEiBTYCBAsCQCAQQQ9OBEAgCSAPQQRqIBctAABBB3QgGC0AAEEGdBCGAgwBCyAQQQJOBEAgDyAFQQEgBUEBSBsiBUF/IAVBf0obIgU2AgQgCSAFQQF0IAVBH3VzQdDtAUECEAkMAQsgEEEBRgRAIA8gBUEfdSAFcSIFNgIEIAlBACAFa0EBEBIMAQsgD0F/NgIECyAIIAAoAggiBSAKbCALakECdCIQaiAgIA8oAgQiEbIiGpM4AgAgBCAQaiAbIB+SIBqSOAIAIBkgGyAakiAdIBqUkzgCACAGIAwgEWsiBiAGQR91IgZqIAZzaiEGIApBAWoiCiASRw0ACyALQQFqIgsgAkcNAAsLIA9BEGokAEEAIAYgDhsLywUCBX8KfQJAIAVDAAAAAFwgBkMAAAAAXHJFBEAgACABRg0BIAAgASAEQQJ0EBMaDwtBACELQX4gA0EPIANBD0obIgxrIQ0gDEF/cyEOQQEgDGshD0EAIAxrIRAgCEEMbCIDQYjpAWoqAgAgBpQhFCADQYTpAWoqAgAgBpQhFSADQYDpAWoqAgAgBpQhFkEAIAogByAIRhsgCiAFIAZbGyAKIAJBDyACQQ9KGyIIIAxGGyICQQFOBEAgB0EMbCIDQYjpAWoqAgAgBZQhFyADQYTpAWoqAgAgBZQhGCADQYDpAWoqAgAgBZQhGUECIAxrIQMgASAPQQJ0aioCACERIAEgEEECdGoqAgAhEiABIA5BAnRqKgIAIRMgASANQQJ0aioCACEFQQAhCgNAIAAgCkECdCIHaiAFIAEgAyAKakECdGoqAgAiGpIgFCAHIAlqKgIAIgUgBZQiBZSUIBEgE5IgFSAFlJQgEiAWIAWUlCABIAdqKgIAIAEgCiAIa0ECdGoiByoCACAZQwAAgD8gBZMiBZSUkiAYIAWUIAcqAgQgB0F8aioCAJKUkiAXIAWUIAcqAgggB0F4aioCAJKUkpKSkjgCACATIQUgEiETIBEhEiAaIREgCkEBaiIKIAJHDQALIAIhCwsgBkMAAAAAWwRAIAAgAUYNASAAIAJBAnQiA2ogASADaiAEIAJrQQJ0EBMaDwsgBCALayIHQQFIDQAgACALQQJ0IgRqIQNBAiAMayECIAEgBGoiASANQQJ0aioCACETIAEgDkECdGoqAgAhBSABIBBBAnRqKgIAIREgASAPQQJ0aioCACESQQAhCgNAIAMgCkECdCIAaiAUIBMgASACIApqQQJ0aioCACIGkpQgFSAFIBKSlCAWIBGUIAAgAWoqAgCSkpI4AgAgBSETIBEhBSASIREgBiESIApBAWoiCiAHRw0ACwsL8BsBJX8jAEEQayIXIRMgFyQAIAEoAkQEQCAAQQE2AoBzIABBATYCtCQLIABBADYC8CwgAEEANgK8ewJAIAEQxAIiCA0AIABBzM4AaiEfIAFBADYCWAJAIAEoAgQgACgC3J0BTA0AIB8gACgC4CcQPyEOIABCATcCqJ0BIABCADcCoJ0BIABBADYCmJ0BIABCgYCAgICAEDcCsJ0BIAAoAtidAUECRw0AIABB2PsAaiAAQYwtakGsAhAIGiAAIAApAgA3AsxOCwJ/IAEoAhgiGCAAKAKAJEcEQCABKAIEIQlBAQwBCyABKAIEIgkgACgC3J0BRwshECABKAIAIQggACAJNgLcnQEgACAINgLYnQEgA0HkAGwiCiABKAIIIgttIQwCQAJAAkAgBgRAQZt/IQggDEEBRw0EIAlBAEwNAgNAIAAgB0HMzgBsaiIIIAgoAuAnED8hDiAHQQFqIgghByAIIAEoAgQiCUgNAAsgASgCGCEYIAFBCjYCGCABKAIkIRpBACEHIAFBADYCJCAJQQFIDQMDQCAAIAdBzM4AbGoiCEEBNgLEJCAIQQA2ArgkIAdBAWoiByAJRw0ACwwBC0GbfyEIIAsgDGwgCkcgA0EASHINAyALIBhsIQpBACEYIANB6AdsIApKDQMLIAlBAUgNASAQQX9zIQoDQEEAIQcgACANQczOAGxqIgsgASAAKALonQEgDSANQQFGBH8gACgC3CMFQQALEMECIggNAwJAIAogCygCtCRFcQ0AIAAoAuwsQQFIDQADQCALIAdBAnRqQfAkakEANgIAIAdBAWoiByAAKALsLEgNAAsLIAsgCygCuC82ArwvIA1BAWoiDSABKAIESA0AC0EAIQ4MAQsgAUEKNgIYIAEoAiQhGiABQQA2AiQLIAxBAXVBASAMQQFKGyIbQQF0ISMgG0F/aiEkIABB3M8AaiElIABByIYBaiEgIABBuPMAaiEhIABBtPYAaiEmIABB6CdqIScgAEGYnQFqISggAEHMnQFqIRUgAEG88wBqISkgAEG6nQFqIRwgAEGw9gBqIR0gAEHY+wBqIR4gAEHkJ2ohFiAAQYwtaiEZIBcgACgC3CMiCCAMQQpsIipsIiIgACgCyCNsIAhB6AdsbUEBdEEPakFwcWsiEiQAAn8DQCAAKALkIyAAKALoLCIKayIIICIgCCAiSBsiDCAAKALII2wgACgC3CNB6AdsbSEPAkACQCABKAIAQQJHDQAgASgCBEF/aiIIQQFLDQAgCEEBa0UEQCAAKALwLCEIQQAhByAPQQFIIhBFBEADQCASIAdBAXRqIAIgB0ECdGovAQA7AQAgB0EBaiIHIA9HDQALCwJAIAgNACAAKALgnQFBAUcNACAeIBlBrAIQCBoLIBkgCkEBdCAWakEEaiASIA8QGyEJIAAgACgC6CwgDGo2AugsIAAoArByIAAoArR7IgtrIgogACgCqHIgKmwiCCAKIAhIGyEKQQAhByAQRQRAA0AgEiAHQQF0aiACIAdBAnRBAnJqLwEAOwEAIAdBAWoiByAPRw0ACwsgHiALQQF0IB1qQQRqIBIgDxAbIQggACAAKAK0eyAKajYCtHsgCCAJIA5qaiEOIAAoAugsIQcMAgtBACEHIA9BAU4EQANAIBIgB0EBdGogAiAHQQJ0IghBAnJqLgEAIAIgCGouAQBqIghBAXYgCEEBcWo7AQAgB0EBaiIHIA9HDQALCyAZIApBAXQgFmpBBGogEiAPEBsgDmohDgJAIAAoAuCdAUECRw0AIAAoAvAsDQAgHiAAKAK0e0EBdCAdakEEaiASIA8QGyAOaiEOIAAoAuQjIhBBAUgNACAAKAK0eyEJIAAoAugsIQtBACEHA0AgFiAHQQJqIgogC2pBAXRqIgggHSAJIApqQQF0ai4BACAILgEAakEBdjsBACAHQQFqIgcgEEcNAAsLIAAgACgC6CwgDGoiBzYC6CwMAQsgGSAKQQF0IBZqQQRqIBIgAiAPQQF0EAggDxAbIQggACAAKALoLCAMaiIHNgLoLCAIIA5qIQ4LIAEoAgAhK0EAIRcgAEEANgLonQFBACAHIAAoAuQjSA0BGiAAKALwLCAGckUEQEEAIREgE0EAOwEGIBNBAEGAAiABKAIEIAAoAuwsQQFqbHZrOgAGIARBACATQQZqQQgQCSABKAIEIghBAEoEQANAQQAhB0EAIQkgACARQczOAGxqIgooAuwsIgtBAU4EQANAIAogB0ECdGpB8CRqKAIAIAd0IAlyIQkgB0EBaiIHIAtHDQALCyAKIAlBAEo6AO8kIAlFIAtBAkhyRQRAIAQgCUF/aiALQQJ0QaA9aigCAEEIEAkgASgCBCEICyARQQFqIhEgCEgNAAsLQQAhDSAAKALsLEEASgRAA0AgCEEBTgRAIA1Bf2ohESANIBVqIQwgKSANQQJ0IhBqIQsgHCANQQZsaiEKQQAhCQNAIAAgCUHMzgBsaiIHIBBqQfAkaigCAARAAkAgCSAIQQJHcg0AIAQgChCVASALKAIADQAgBCAMLAAAEJQBCyAHIAQgDUEBAn8gDQRAQQIgByARQQJ0akHwJGooAgANARoLQQALEFcgBCAHIA1BJGxqIghB7S9qLAAAIAhB7i9qLAAAIAcgDUHAAmxqQbwwaiAHKALkIxBWIAEoAgQhCAsgCUEBaiIJIAhIDQALCyANQQFqIg0gACgC7CxIDQALC0EAIQcgCEEASgRAA0AgACAHQczOAGxqIghCADcC8CQgCEH4JGpBADYCACAHQQFqIgcgASgCBEgNAAsLIAAgBCgCFCAEKAIcZ2pBYGo2AtCdAQsgABC5AiABKAIYIgogASgCHCIIbEHoB20hCSAGBH8gCQUgCSAAKALQnQFrCyAAKALsLG0iC0EQdEEQdUHkAEEyIApBCkYbbCAAKALUnQFBAXRrIQkCQCAGDQAgACgC8CwiCkEBSA0AIAkgBCgCHGcgBCgCFCAKIAtsa2ogACgC0J0Ba0EBdGtBQGshCQsCQCAIQYknTgRAIAkgCCIKSg0BIAlBiCcgCUGIJ0obIQoMAQtBiCchCiAJQYgnSg0AIAggCSAJIAhIGyEKCwJAIAEoAgRBAkYEQCAoICcgJiAcIAAoAvAsIghBBmxqIAggFWogE0EIaiAKIAAoArAjIAEoAjwgACgC3CMgACgC5CMQtwICQCAVIAAoAvAsIghqLQAARQRAIAAoAuydAUEBRgRAICBCADcCACAgQQA2AgggAEIANwLcTiAlQQBBoCIQChogAEEKOgDIhgEgAEHkADYCxHEgAEHkADYCiHIgAEEAOgCFciAAQQE2AoBzIABBgIAENgLUcQsgHxB8DAELIAggIWpBADoAAAsgBg0BIAQgHCAAKALwLEEGbGoQlQEgISAAKALwLCIIai0AAA0BIAQgCCAVaiwAABCUAQwBCyAAIAAoApydATYC5CcgACAWIAAoAuQjQQF0aigBADYCnJ0BCyAAEHwgASgCBCIMQQFOBEAgFEUgG0ECRnEhEEEAIQcDQCABKAI4IQsCfyAQBEAgC0EDbEEFbQwBCyALIBtBA0cNABogFEUEQCALQQF0QQVtDAELIAsgFEEBRw0AGiALQQNsQQRtCyEIIBQgJEYgASgCNEEAR3EhEQJAIAxBAUYEQCAKIQkMAQsgE0EIaiAHQQJ0aigCACEJIAcNACATKAIMQQFIDQAgCCALICNtayEIQQAhEQsgCUEBTgRAIAAgB0HMzgBsaiILIAkQiQIgCyAFIAQCf0EAIAAoAvAsIAdMDQAaIAcEQEEBIAAoAuydAQ0BGgtBAgsgCCAREIoCIQ4gASgCBCEMCyAAIAdBzM4AbGoiCEEANgLoLCAIQQA2ArgkIAggCCgC8CxBAWo2AvAsIAdBAWoiByAMSA0ACwsgDyArbEEBdCELIAMgD2shAyAAIAAoAvAsIhAgFWpBf2osAAA2AuydAQJAIAUoAgBBAUgNACAQIAAoAuwsRw0AQQAhEUEAIQcCQCAMQQFIBEAMAQsDQCAHQQF0IQlBACEHIAAgEUHMzgBsaiIKKALsLCIIQQFOBEADQCAJIAcgCmpB7CRqLAAAckEBdCEJIAdBAWoiByAIRw0ACwsgCSAKLADvJHIhByARQQFqIhEgDEcNAAsLIAZFBEAgBCAHIBBBAWogDGwQvwILAkAgACgCvC9FDQAgASgCBEEBRwRAIAAoAoh+RQ0BCyAFQQA2AgALIAAgACgC1J0BIAUoAgBBA3RqIAEoAhgiCiABKAIcbEHoB21rIghBACAIQQBKGyIIQZDOACAIQZDOAEgbNgLUnQEgACgCsCMgACgC5J0BIghBEHRBEHVB9BhsQRB1QQ1qSARAIABCgICAgBA3AuSdAQwBCyAAQQA2AuidASAAIAggCmo2AuSdAQsgAiALaiECIBRBAWohFCADDQALIAAoAuidAQshByAOIQggACABKAIEIgM2AuCdASABIAc2AkwgASAAKALcIyICQRBGBH8gACgCHEUFQQALNgJQIAEgAkEQdEEQdUHoB2w2AkhBACEHIAEgASgCPAR/QQAFIAAuAbSdAQs2AlQCQCAGRQ0AIAEgGjYCJCABIBg2AhggA0EBSA0AA0AgACAHQczOAGxqIgJBADYCxCQgAkEANgK4JCAHQQFqIgcgA0cNAAsLIAEgACwAmSUiAjYCXCABIAJBAXRBfHEgACwAmiVBAXRqQcA9ai4BADYCYAsgE0EQaiQAIAgLhAEBAn8gACAAQeYnahDGAgJAIAAoArAjQQxMBEAgAEGZJWpBADoAACAAIAAoAsAvIgJBAWo2AsAvIAJBCU4EQCACQR5IDQIgAEEKNgLALwsgAEEANgK8LwwBCyAAQgA3ArwvQQEhASAAQZklakEBOgAACyAAIAAoAvAsakHsJGogAToAAAstAQJ/IAFBAU4EQANAIAAgA2osAAAgAkEIdGohAiADQQFqIgMgAUcNAAsLIAILzQMBB38gBEEBTgRAA0AgASAIQQJ0aiIKKAIAEA0aIAAgCGoiBiAKKAIAEA1BEHRBgIDYvn9qQRB1QcsRbCIHQRB2IgU6AAAgB0EIdEEYdSACLAAASARAIAYgBUEBaiIFOgAACyAGIAVBACAFQRh0QRh1QQBKGyIFQT8gBUEYdEEYdUE/SBsiBzoAACACLAAAIQUCQCADIAhyRQRAIAYgBUF8aiIGQT8gBiAHQf8BcSIHSBsgBiAHIAYgB0obIAVBwwBKGyIFOgAAIAIgBToAAAwBCyAGIAcgBWsiBToAACACLAAAIglBCGoiByAFQRh0QRh1IgtIBEAgBiALIAlrQfkDakEBdiAHaiIFOgAACyAGIAVBfCAFQRh0QRh1QXxKGyIFQSQgBUEYdEEYdUEkSBsiBToAACACAn8gByAFQRh0QRh1IglIBEAgAiACLQAAIAlBAXQgB2tqIgU6AAAgBUE/IAVBGHRBGHVBP0gbDAELIAItAAAgBWoLOgAAIAYgBi0AAEEEajoAACACLQAAIQULIAogBUEYdEEYdSIFQfE4bEEQdSAFQR1saiIFQdUOIAVB1Q5IG0GqEGoQKDYCACAIQQFqIgggBEcNAAsLC80LAwt/A30JfCMAQeAHayIHJAAgASADIARsEBAhGCAHQaAGakEAQcABEAoaIARBAU4EQANAQQEhBiAFQQFOBEAgASADIAhsQQJ0aiEJA0AgBkEDdCAHaiIKQZgGaiAJIAkgBkECdGogAyAGaxApIAorA5gGoDkDACAFIAZHIQogBkEBaiEGIAoNAAsLIAhBAWoiCCAERw0ACwsgB0HgBGogB0GgBmpBwAEQCBogByAYIBhEAAAAgLX45D6iIhygRAAAAOALLhE+oCIVOQPAASAHIBU5A5ADAnwCQCAFQQFIBEBEAAAAAAAA8D8hFAwBCyACuyEZQQAhCEECIRBBASEPRAAAAAAAAPA/IRcDQCAEQQFOBEAgAyAIayINQX9qIQ5BACEKA0AgASADIApsQQJ0aiIJIA5BAnRqKgIAIgK7IRQgCSAIQQJ0aioCACIRuyEVQQAhBiAIBEADQCAGQQN0IgsgB0GgBmpqIgwgDCsDACARIAkgCCAGQX9zakECdGoqAgAiEpS7oTkDACAHQeAEaiALaiIMIAwrAwAgAiAJIAYgDWpBAnRqKgIAIhOUu6E5AwAgFSAHIAtqKwMAIhYgEruioCEVIBQgFiATu6KgIRQgBkEBaiIGIAhHDQALC0EAIQYDQCAGQQN0IgsgB0GQA2pqIgwgDCsDACAVIAkgCCAGa0ECdGoqAgC7oqE5AwAgB0HAAWogC2oiCyALKwMAIBQgCSAGIA5qQQJ0aioCALuioTkDACAGQQFqIgYgD0cNAAsgCkEBaiIKIARHDQALCyAIQQN0Ig4gB0HgBGpqKwMAIRUgB0GgBmogDmorAwAhFEEAIQYgCARAA0AgFSAHIAZBA3RqKwMAIhYgCCAGQX9zakEDdCIJIAdBoAZqaisDAKKgIRUgFCAWIAdB4ARqIAlqKwMAoqAhFCAGQQFqIgYgCEcNAAsLIAhBAWoiCUEDdCIGIAdBkANqaiAUOQMAIAdBwAFqIAZqIgsgFTkDAEEAIQYgBysDwAEhFCAHKwOQAyIaIRYgCARAA0AgFiAHIAZBA3RqKwMAIhsgBkEBaiIKQQN0Ig0gB0GQA2pqKwMAoqAhFiAUIBsgB0HAAWogDWorAwCioCEUIBUgGyAHQcABaiAIIAZrQQN0aisDAKKgIRUgCiIGIAhHDQALC0EAIQZBACEKIBdEAAAAAAAA8D8gFUQAAAAAAAAAwKIgFiAUoKMiFCAUoqGiIhYgGWVBAXNFBEBEAAAAAAAA8D8gGSAXo6GfIhaaIBYgFUQAAAAAAAAAAGQbIRRBASEKIBkhFgsgCUH+////B3EEQCAPQQF2IQ0DQCAHIAZBA3RqIgwgDCsDACIXIBQgByAIIAZBf3NqQQN0aiIMKwMAIhWioDkDACAMIBUgFCAXoqA5AwAgBkEBaiIGIA1HDQALCyAHIA5qIBQ5AwACQCAKRQRAIAcgGiAUIAsrAwAiF6KgOQOQAyALIBcgFCAaoqA5AwBBASEGA0AgB0HAAWogCSAGa0EDdGoiCCAIKwMAIhcgFCAHQZADaiAGQQN0aiIIKwMAIhWioDkDACAIIBUgFCAXoqA5AwAgBkEBaiIGIBBHDQALDAELIAkgBUgEQCAHIAlBA3RqQQAgBSAJa0EDdBAKGgtBACEGA0AgACAGQQJ0aiAHIAZBA3RqKwMAtow4AgAgBkEBaiIGIAVHDQALQQAhBiAEQQBKBEADQCAYIAEgAyAGbEECdGogBRAQoSEYIAZBAWoiBiAERw0ACwsgFiAYogwDCyAQQQFqIRAgD0EBaiEPIBYhFyAJIgggBUcNAAtBACEGRAAAAAAAAPA/IRQgBysDkAMhFQNAIAdBkANqIAZBAWoiAUEDdGorAwAhGSAAIAZBAnRqIAcgBkEDdGorAwAiFraMOAIAIBUgFiAZoqAhFSAUIBYgFqKgIRQgASIGIAVHDQALCyAVIBwgFKKhCyEUIAdB4AdqJAAgFLYLnAYBCH8jAEHwB2siByQAAkAgACgC4CMiCkEBTgRAIAAoApgkIglBAUghCwNAIAtFBEAgCEEYbCEMQQAhBgNAIAdBMGogBiAMaiINQQF0aiABIA1BAnRqKgL0AUMAAABGlBAOOwEAIAZBAWoiBiAJRw0ACwsgCEEBaiIIIApHDQALQQAhCANAIAEgCEECdCIGaiIJKgKEBUMAAIBGlBAOIQsgB0EgaiAGaiAJKgL0BEMAAIBGlBAOQf//A3EgC0EQdHI2AgAgB0EQaiAGaiAJKgKUBUMAAIBGlBAONgIAIAYgB2ogCSoCpAVDAACARpQQDjYCACAIQQFqIgggCkcNAAsgCkEFbCIGQQEgBkEBShshCEEAIQYgASoCtAVDAACARJQQDiEJA0AgB0HwAWogBkEBdGogASAGQQJ0aioCkAFDAACARpQQDjsBACAGQQFqIgYgCEcNAAsMAQsgASoCtAVDAACARJQQDiEJC0EAIQYgACgCnCQiCEEASgRAA0AgB0GgAmogBkEBdGogASAGQQJ0aioCEEMAAIBFlBAOOwEAIAZBAWoiBiAIRw0AC0EAIQYDQCAGQQF0IAdqIAEgBkECdGoqAlBDAACARZQQDjsBwAIgBkEBaiIGIAhHDQALC0EAIQYgCkEASgRAA0AgBkECdCIIIAdB4AJqaiABIAhqKgIAQwAAgEeUEA42AgAgBkEBaiIGIApHDQALC0EAIQZBACEIIAItAB1BAkYEQCACLAAhQQF0Qcg9ai4BACEICyAAKALkIyIKQQFOBEADQCAHQfACaiAGQQF0aiAFIAZBAnRqKgIAEA47AQAgBkEBaiIGIApHDQALCwJAAkAgACgCkCRBAUwEQCAAKAK8JEEBSA0BCyAAIAMgAiAHQfACaiAEIAdBoAJqIAdB8AFqIAdBMGogByAHQRBqIAdBIGogB0HgAmogAUHkAWogCSAIEJkCDAELIAAgAyACIAdB8AJqIAQgB0GgAmogB0HwAWogB0EwaiAHIAdBEGogB0EgaiAHQeACaiABQeQBaiAJIAgQlwILIAdB8AdqJAALUQEDfyMAQUBqIgMkACACQQFOBEADQCADIARBAnQiBWogASAFaioCAEMAAIBHlBAONgIAIARBAWoiBCACRw0ACwsgACADIAIQogIgA0FAayQAC8oEARJ/IwBBEGsiCSQAIAhBAUghE0H/////ByEQA0AgAygCACEOAkAgEwRAQQAhDUEAIQsgDiEMDAELIA9B/MYAaiwAACEUIA9BAnQiDEHwxgBqKAIAIRUgDEGgxgBqKAIAIRYgDEHwwwBqKAIAIRdBACERQQAhC0EAIQ0gBiESIAUhCgNAIAlBDGogEWogCUEIaiAJQQRqIAkgCiASIBYgFSAXIAdB1TAgDmsQKEFNaiAUEJYCIAkoAgQgC2oiC0H/////B0khGCAJKAIIIA1qIg1B/////wdJIRlBACEMIAtB/////wcgGBshCyANQf////8HIBkbIQ0gEkEUaiESIApB5ABqIQogCSgCAEEzahANIA5qQYAHTgRAIAkoAgBBM2oQDSAOakGAeWohDAsgDCEOIBFBAWoiESAIRw0ACwsgCyAQTARAIAIgDzoAACABIAlBDGogCBAIGiAMIRogCyEQCyAPQQFqIg9BA0cNAAsgCEEBTgRAIAIsAABBAnRBoMYAaigCACECQQAhCgNAIAAgCkEKbGoiBSACIAEgCmoiBiwAAEEFbGosAABBB3Q7AQAgBSAGLAAAQQVsIAJqLAABQQd0OwECIAUgBiwAAEEFbCACaiwAAkEHdDsBBCAFIAYsAABBBWwgAmosAANBB3Q7AQYgBSAGLAAAQQVsIAJqLAAEQQd0OwEIIApBAWoiCiAIRw0ACwsgAyAaNgIAIAQgDUEBQQIgCEECRht2EA1BEHRBgICARGpBEHVBfWw2AgAgCUEQaiQAC6ACAQZ/IAQgA0gEQCAEQQdIIQogBCEFA0AgAi4BAiAFQQF0IgsgAWoiBkF8ai4BAGwgAi4BACAGQX5qIgkuAQBsaiACLgEEIAZBemouAQBsaiACLgEGIAZBeGouAQBsaiACLgEIIAZBdmouAQBsaiACLgEKIAZBdGouAQBsaiEHQQYhCCAKRQRAA0AgByACIAhBAXQiB2ouAQAgCSAHay4BAGxqIAIgB0ECcmouAQAgCSAIQX9zQQF0ai4BAGxqIQcgCEECaiIIIARIDQALCyAAIAtqIAYuAQBBDHQgB2tBC3VBAWpBAXUiBkGAgH4gBkGAgH5KGyIGQf//ASAGQf//AUgbOwEAIAVBAWoiBSADRw0ACwsgAEEAIARBAXQQChoL/gUBDn8gASACQQF0aiENIAAgAkF/aiILQQF0aiEJIAJBAkghDwJAA0AgAC4BACIDIAEuAQAiBmshBUEBIQRBACEHIA9FBEADQCADQRB0IQggACAEQQF0IgpqLgEAIgMgCEEQdWsgASAKai4BAGsiCCAFIAggBUgiCBshBSAEIAcgCBshByAEQQFqIgQgAkcNAAsLQYCAAiANLgEAIgggCS4BAGprIgMgBSADIAVIIgMbQX9KDQECQCACIAcgAxsiA0UEQCAAIAY7AQAMAQsCQAJAIAIgA0cEQCADQQFODQFBACEGDAILIAlBgIB+IAhrOwEADAILQQEhBCADQQFGDQADQCAGIAEgBEEBdGouAQBqIQYgBEEBaiIEIANHDQALCyAGIAEgA0EBdCIMaiIQLgEAQQF1IgpqIQVBgIACIQcCQCADIAJODQBBgIACIAhrIQcgCyIEIANMDQADQCAHIAEgBEEBdGouAQBrIQcgBEF/aiIEIANKDQALCyAAIAxqIgguAQAgCEF+aiIMLgEAaiIDQQF1IANBAXFqIQYCQCAFIAcgCmsiBEoEQCAGIAUiA0oNASAEIAYgBiAESBshAwwBCyAGIAQiA0oNACAFIAYgBiAFSBshAwsgDCADIAprIgM7AQAgCCADIBAvAQBqOwEACyAOQQFqIg5BFEcNAAsgACACEJ8CIAAgAC4BACIDIAEuAQAiBCADIARKGyIFOwEAIAJBAkgiA0UEQEEBIQQDQCAAIARBAXQiC2oiByAHLgEAIgcgASALai4BACAFQRB0QRB1aiIFQf//ASAFQf//AUgbIgVBgIB+IAVBgIB+ShsiBSAHIAVKGyIFOwEAIARBAWoiBCACRw0ACwsgCSAJLgEAIgRBgIACIA0uAQBrIgUgBSAEShsiBTsBACADDQAgAkF+aiEEA0AgACAEQQF0IgJqIgMgAy4BACIDIAVBEHRBEHUgASACai4BAmsiAiACIANKGyIFOwEAIARBAEohAiAEQX9qIQQgAg0ACwsLgQMBCH8CQCADQQBMDQADQCABIARBAnRqIAQ2AgAgBEEBaiIEIANHDQALQQEhBSADQQFMDQADQCAAIAVBAnRqKAIAIQcgBSEEAkADQCAHIAAgBEF/aiIJQQJ0IgZqKAIAIgpODQEgACAEQQJ0IghqIAo2AgAgASAIaiABIAZqKAIANgIAIARBAUohBiAJIQQgBg0AC0EAIQQLIAAgBEECdCIEaiAHNgIAIAEgBGogBTYCAEEBIQcgBUEBaiIFIANHDQALCyADIAJIBEAgA0F+aiEJIANBAnQgAGpBfGohCgNAIAAgA0ECdGooAgAiBiAKKAIASARAIAkiBCEFAkAgB0UNAANAIAYgACAEQQJ0IgVqKAIAIghOBEAgBCEFDAILIAAgBUEEaiILaiAINgIAIAEgC2ogASAFaigCADYCAEF/IQUgBEEASiEIIARBf2ohBCAIDQALCyAAIAVBAnRBBGoiBGogBjYCACABIARqIAM2AgALIANBAWoiAyACRw0ACwsLowIBBX9BASEFIABBgIAIIAEuAQIgAS4BACIDayIEQQEgBEEBShtuIgRBgIAIIANBASADQQFKG25qIgNB//8BIANB//8BSRs7AQAgAkF/aiEDIAJBA04EQANAIAAgBUEBdCICaiAEQYCACCABIAJBAmoiBGoiBi4BACABIAJqLgEAayICQQEgAkEBShtuIgJqIgdB//8BIAdB//8BSRs7AQAgACAEaiACQYCACCABIAVBAmoiBUEBdGouAQAgBi4BAGsiAkEBIAJBAUobbiIEaiICQf//ASACQf//AUkbOwEAIAUgA0gNAAsLIAAgA0EBdCICakGAgAhBgIACIAEgAmouAQBrIgBBASAAQQFKG24gBGoiAEH//wEgAEH//wFJGzsBAAuVBwIMfwR+IwBB4ABrIQcCQCABQQFOBEADQCAHIARBAnRqIAAgBEEBdGouAQAiCUEMdDYCACACIAlqIQIgBEEBaiIEIAFHDQALIAJB/x9KDQELIAcgAUF/aiICQQJ0aigCACIAQZ7f/wdqQby+/w9LIQRCgICAgAQhDiABQQJOBEADQCAEQQFxBEBBAA8LIA5BgICAgARBACAAQQd0a6wiECAQfkIgiKciBmsiCKx+Qh6Ip0F8cSINQe7GBkgNAiACIQlB/////wEgCCAGQYCAgIB8aiILIAggBkGAgICABEsbZyIFQX9qdCIEQRB1IgJtIgBBD3VBAWpBAXVBACAAQRB0IgBBEHUiAyAEQf//A3FsQRB1IAIgA2xqQQN0ayICbCAAaiACQRB1IANsaiACQfj/A3EgA2xBEHVqIQMCfyAIIAsgBkGAgICABEkbZyIIIAVrIgBBAEwEQAJAQYCAgIB4QQAgAGsiBXUiBEH/////ByAFdiICSgRAIAMgBCIASg0BIAIgAyADIAJIGyAFdAwDCyADIAIiAEoNACAEIAMgAyAESBshAAsgACAFdAwBCyADIAB1QQAgAEEgSBsLIQIgAUEBdiIAQQEgAEEBSxshC0EfIAhrrSERIAKsIQ9BACECA0BBgICAgHhB/////wcgByACQQJ0aiIFKAIAIgwgByAJIAJBf3NqQQJ0aiIEKAIAIgasIBB+Qh6IQgF8QgGIpyIDayIAQX9KIgEbIAAgAyAMIAEbQYCAgIB4cyAMIAMgARtxQQBIG6wgD34hDgJ+IA5CAYMgDkIBh3wgCEEfRyIBRQ0AGiAOIBGHQgF8QgGHCyIOQoCAgIAIfEL/////D1YNAyAFIA4+AgBBgICAgHhB/////wcgBiAMrCAQfkIeiEIBfEIBiKciA2siAEF/SiIFGyAAIAMgBiAFG0GAgICAeHMgBiADIAUbcUEASBusIA9+IQ4gAQR+IA4gEYdCAXxCAYcFIA5CAYMgDkIBh3wLIg5CgICAgAh8Qv////8PVg0DIAQgDj4CACACQQFqIgIgC0cNAAsgByAJQX9qIgJBAnRqKAIAIgBBnt//B2pBvL7/D0shBCANrCEOIAkiAUEBSg0ACwsgBA0AQQBCgICAgICAgIDAAEEAIAcoAgBBB3RrrCIPIA9+QoCAgIDw/////wCDfUIghyAOfkIeiKdBfHEiACAAQe7GBkgbIQoLIAoLvwMBBH8gASADQQJ0IgRqQYCABDYCACACIARqQYCABDYCAAJAIANBAUgNAEEAIQQDQCABIARBAnQiBWpBACAAIAMgBGpBAnRqIgYoAgAgACAEQX9zIANqQQJ0aiIHKAIAams2AgAgAiAFaiAGKAIAIAcoAgBrNgIAIARBAWoiBCADRw0ACyADIQQDQCABIARBf2oiAEECdCIFaiIGIAYoAgAgASAEQQJ0IgZqKAIAazYCACACIAVqIgUgBSgCACACIAZqKAIAajYCACAEQQFKIQUgACEEIAUNAAtBAiEAIANBAkgNAANAIAAgAyIESARAA0AgASAEQQJ0aiIFQXhqIgYgBigCACAFKAIAazYCACAEQX9qIgQgAEoNAAsLQQIhBSABIABBAnRqIgRBeGoiBiAGKAIAIAQoAgBBAXRrNgIAIAAgA0chBCAAQQFqIQAgBA0ACwNAIAUgAyIESARAA0AgAiAEQQJ0aiIAQXhqIgEgASgCACAAKAIAazYCACAEQX9qIgQgBUoNAAsLIAIgBUECdGoiAEF4aiIBIAEoAgAgACgCAEEBdGs2AgAgAyAFRyEAIAVBAWohBSAADQALCwuhAQEEfyACQfz/A3EiAwRAA0AgACAEQQJ0IgVqIgYgBioCACABlDgCACAAIAVBBHJqIgYgBioCACABlDgCACAAIAVBCHJqIgYgBioCACABlDgCACAAIAVBDHJqIgUgBSoCACABlDgCACAEQQRqIgQgA0kNAAsLIAMgAkgEQANAIAAgA0ECdGoiBCAEKgIAIAGUOAIAIANBAWoiAyACRw0ACwsLAwABC/IBAQd/IANBAk4EQCADQQF1IgNBASADQQFKGyEIIAAoAgQhBCAAKAIAIQVBACEDA0AgASADQQF0akH//wEgAiADQQJ0IgZqLgEAQQp0IgcgBWsiBUH//wNxQYG3fmxBEHUgBUEQdUGBt35saiAHaiIHIARqIAIgBkECcmouAQBBCnQiBiAEayIEQf//A3FBkM0AbEEQdiAEQRB1QZDNAGxqIgRqIglBCnVBAWpBAXUiCkGAgH4gCkGAgH5KGyAJQf/3/x9KGzsBACAEIAZqIQQgBSAHaiEFIANBAWoiAyAIRw0ACyAAIAQ2AgQgACAFNgIACwukAQIHfwN9QQEhBSACQQFOBEADQCABIANBAnQiB2oqAgAhCiADQQFqIghB/v///wdxBEAgBUEBdiEJQQAhBANAIAAgBEECdGoiBiAGKgIAIgsgCiAAIAMgBEF/c2pBAnRqIgYqAgAiDJSSOAIAIAYgDCAKIAuUkjgCACAEQQFqIgQgCUcNAAsLIAAgB2ogCow4AgAgBUEBaiEFIAgiAyACRw0ACwsLvgICBH8DfCMAQZADayIEJAAgAkEBakEBIAJBAEobIQYDQCAEIANBBHRqIgUgASADQQJ0aioCALsiBzkDACAFIAc5AwggA0EBaiIDIAZHDQALIAJBAU4EQEEAIQEgAiEGA0AgACABIgNBAnRqIAQgA0EBaiIBQQR0aiIFKwMAmiAEKwMIIghEAAAA4AsuET4gCEQAAADgCy4RPmQboyIHtjgCAAJAIAMgAk4NACAFIAUrAwAiCSAHIAiioDkDACAEIAggByAJoqA5AwhBASEDIAZBAUYNAANAIAQgASADakEEdGoiBSAFKwMAIgggByAEIANBBHRqIgUrAwgiCaKgOQMAIAUgCSAHIAiioDkDCCADQQFqIgMgBkcNAAsLIAZBf2ohBiABIAJHDQALCyAEKwMIIQcgBEGQA2okACAHtgtFAQJ/IAIgAyADIAJKGyIEQQFOBEBBACEDA0AgACADQQJ0IgVqIAEgASAFaiACIANrECm2OAIAIANBAWoiAyAERw0ACwsLvQoBCn8jAEEQayIIJAAgCEEEaiAIQQxqIAEgBBCQASAIIAhBCGogAiAEEJABIAggCCgCACAIKAIMIgcgCCgCCCIGIAcgBkobIgtBAXEgC2oiCiAGa3U2AgAgCCAIKAIEIAogB2t1IgdBASAHQQFKGzYCBCABIAIgCiAEELgCIgsgCyALQR91IgFqIAFzZyIHQX9qdCICQf////8BIAgoAgQiBCAEIARBH3UiAWogAXNnIglBf2p0IgZBEHVtQRB0QRB1IgEgAkH//wNxbEEQdSACQRB1IAFsaiICrCAGrH5CHYinQXhxayIGQRB1IAFsIAJqIAZB//8DcSABbEEQdWohBiAFAn8gByAJa0EQaiIBQX9MBEACQEGAgICAeEEAIAFrIgl1IgJB/////wcgCXYiB0oEQCAGIAIiAUoNASAHIAYgBiAHSBsgCXQMAwsgBiAHIgFKDQAgAiAGIAYgAkgbIQELIAEgCXQMAQsgBiABdUEAIAFBIEgbCyICQYCAfyACQYCAf0obIgFBgIABIAFBgIABSBsiB0H//wNxIAdsQRB1IAdBEHUgB2xqIg0gDUEfdSIBaiABcyIBIAEgBUgbIQEgCkEBdSEGQQAhBSADKAIAIQogAwJ/IARBAEwEQCABQRB0QRB1IgJBACAKa0EQdWwMAQsgBGciBUFoaiEOQYCAAkGG6QIgBUEBcRsgBUEBdnYiDCAMAn8gBEEYIAVrIglFDQAaIAQgDnQgBEE4IAVrdnIgBEH/AE0NABogBCAFQQhqdCAEIAl2cgtB/wBxQYCA1AZsQRB2bEEQdmogBnQgCmtBEHUhDyABQRB0QRB1IQIgDAJ/IAQgCUUNABogBCAOdCAEQTggBWt2ciAEQf8ATQ0AGiAEIAVBCGp0IAQgCXZyC0H/AHFBgIDUBmxBEHYgDGxBEHZqIQUgAiAPbAsgCmogBSAGdCAKa0H//wNxIAJsQRB1aiIMNgIAIAggCCgCACAHIAtBEHVsIAcgC0H//wNxbEEQdWpBBHRrIA1BEHRBEHUiASAEQf//A3FsQRB1IAEgBEEQdWxqQQZ0aiIENgIAIAMgAygCBCILAn8gBEEBSARAQQAhBEEADAELIARnIgVBaGohDUGAgAJBhukCIAVBAXEbIAVBAXZ2IgkgCQJ/IARBGCAFayIKRQ0AGiAEIA10IARBOCAFa3ZyIARB/wBNDQAaIAQgBUEIanQgBCAKdnILQf8AcUGAgNQGbEEQdmxBEHZqIQECQCAKRQ0AIARB/wBNBEAgBCANdCAEQTggBWt2ciEEDAELIAQgBUEIanQgBCAKdnIhBAsgCSAEQf8AcUGAgNQGbEEQdiAJbEEQdmohBCABIAZ0CyALa0EQdSACbGogBCAGdCALa0H//wNxIAJsQRB1aiIBNgIEIAEgASABQR91IgJqIAJzZyIEQX9qdCICQf////8BIAxBASAMQQFKGyIBIAFnIgVBf2p0IgNBEHVtQRB0QRB1IgEgAkH//wNxbEEQdSACQRB1IAFsaiICrCADrH5CHYinQXhxayIDQRB1IAFsIAJqIANB//8DcSABbEEQdWohAyAAAn8gBCAFa0EPaiIBQX9MBEACQEGAgICAeEEAIAFrIgR1IgFB/////wcgBHYiAkoEQCADIAEiBUoNASACIAMgAyACSBsgBHQMAwsgAyACIgVKDQAgASADIAMgAUgbIQULIAUgBHQMAQsgAyABdUEAIAFBIEgbCyIEQQAgBEEAShsiAEH//wEgAEH//wFIGzYCACAIQRBqJAAgBwugAgEGfyADQX9qIQhBHyADZyIHayEFAkAgA0ECSARAIAMhBAwBCyADIQQDQCAEIAIgBkEBdCIEQQJyai4BACIJIAlsIAIgBGouAQAiBCAEbGogBXZqIQQgBkECaiIGIAhIDQALIANBfnEhBgsgBiADSARAIAQgAiAGQQF0ai4BACIEIARsIAV2aiEEC0EAIQVBIiAHIARnamsiBEEAIARBAEobIQQgA0ECSAR/QQAFQQAhBgNAIAUgAiAGQQF0IgVBAnJqLgEAIgcgB2wgAiAFai4BACIFIAVsaiAEdmohBSAGQQJqIgYgCEgNAAsgA0F+cQsiBiADSARAIAIgBkEBdGouAQAiAiACbCAEdiAFaiEFCyABIAQ2AgAgACAFNgIAC/YFAQt/AkAgAUF/aiIKQYACTwRAIAAgACgCHCIDIApBGCAKZ2siBnYiAkEBaiIEbiIBNgIkIAAgACgCICIFIAJBACAFIAFuIgVBAWoiCCAEayIEIAQgCEsbIAIgBWtqIgtrIAFsIgJrIgc2AiAgACABIAMgAmsgCxsiAjYCHCACQYCAgARNBEAgACgCGCEDIAAoAighBCAAKAIUIQUgACgCBCEMA0AgACACQQh0Igg2AhwgACAFQQhqIgU2AhRBACEBIAMgDEkEQCAAIANBAWoiCTYCGCAAKAIAIANqLQAAIQEgCSEDCyAAIAE2AiggACABIARBCHRyQQF2Qf8BcSAHQQh0QYD+//8HcXJB/wFzIgc2AiAgAkGBgAJJIQkgASEEIAghAiAJDQALCyALIAZ0IQggACgCDCEHAkAgACgCECIBIAZPBEAgASEFDAELIAAoAgghAiAAKAIEIQQDQEEAIQMgAiAESQR/IAAgAkEBaiICNgIIIAAoAgAgBCACa2otAAAFQQALIAF0IAdyIQcgAUERSCEDIAFBCGoiBSEBIAMNAAsLIAAgBSAGazYCECAAIAcgBnY2AgwgACAAKAIUIAZqNgIUIAdBfyAGdEF/c3EgCHIiBiAKTQ0BIABBATYCLCAKDwsgACAAKAIcIgMgAW4iAjYCJCAAIAAoAiAiBCABIAQgAm4iBEF/cyABakEAIARBAWoiBCABayIBIAEgBEsbaiIGQX9zaiACbCIBayIHNgIgIAAgAiADIAFrIAYbIgI2AhwgAkGAgIAESw0AIAAoAhghAyAAKAIoIQQgACgCFCEFIAAoAgQhCgNAIAAgAkEIdCIINgIcIAAgBUEIaiIFNgIUQQAhASADIApJBEAgACADQQFqIgk2AhggACgCACADai0AACEBIAkhAwsgACABNgIoIAAgASAEQQh0ckEBdkH/AXEgB0EIdEGA/v//B3FyQf8BcyIHNgIgIAJBgYACSSEJIAEhBCAIIQIgCQ0ACwsgBgvrAQEGfyAAIAAoAiAgACgCJCIEIAMgAmtsIgNrIgY2AiAgACABBH8gBCACIAFrbAUgACgCHCADawsiAjYCHCACQYCAgARNBEAgACgCGCEDIAAoAighBCAAKAIUIQcgACgCBCEIA0AgACACQQh0Igk2AhwgACAHQQhqIgc2AhRBACEBIAMgCEkEQCAAIANBAWoiBTYCGCAAKAIAIANqLQAAIQEgBSEDCyAAIAE2AiggACAGQQh0QYD+//8HcSABIARBCHRyQQF2Qf8BcXJB/wFzIgY2AiAgAkGBgAJJIQUgASEEIAkhAiAFDQALCws4AQF/IAAgACgCHCABbiICNgIkIAAoAiAgAm4iAEF/cyABakEAIABBAWoiACABayIBIAEgAEsbagsNACAAIAFBmT1BCBAJC1EAIAAgASwABSABLAACQQVsakGAPUEIEAkgACABLAAAQc49QQgQCSAAIAEsAAFB1T1BCBAJIAAgASwAA0HOPUEIEAkgACABLAAEQdU9QQgQCQvjBgEHfwJAAkBB/////wcgACgCHCIDZyIFdiIBIAAoAiAiBGpBgICAgHggBXVxIgIgAXIgAyAEak8EQCABQQF2IgEgBGogAUF/c3EhAiAFQQFqIQUMAQsgBUUNAQsgBSEEA0ACQCACQRd2IgZB/wFHBEAgAkEfdiEFIAAoAigiB0EATgRAQX8hASAAIAAoAhgiAyAAKAIIaiAAKAIESQR/IAAgA0EBajYCGCAAKAIAIANqIAUgB2o6AABBAAVBfwsgACgCLHI2AiwLIAAoAiQiAQRAIAVBf2ohBwNAQX8hAyAAIAAoAhgiBSAAKAIIaiAAKAIESQR/IAAgBUEBajYCGCAAKAIAIAVqIAc6AABBACEDIAAoAiQFIAELQX9qIgE2AiQgACAAKAIsIANyNgIsIAENAAsLIAAgBkH/AXE2AigMAQsgACAAKAIkQQFqNgIkCyACQQh0QYD+//8HcSECIARBCEohASAEQXhqIgUhBCABDQALC0F/IQECQAJAAkAgACgCKCIEQX9MBEAgACgCJCIBDQEMAwsgACAAKAIYIgIgACgCCGogACgCBEkEfyAAIAJBAWo2AhggACgCACACaiAEOgAAQQAFQX8LIAAoAixyNgIsIAAoAiQiAUUNAQsDQEF/IQMgACAAKAIYIgIgACgCCGogACgCBEkEfyAAIAJBAWo2AhggACgCACACakH/AToAAEEAIQMgACgCJAUgAQtBf2oiATYCJCAAIAAoAiwgA3I2AiwgAQ0ACwsgAEEANgIoCyAAKAIMIQMCQCAAKAIQIgJBB0wEQCAAKAIsIQQMAQsgAiEBA0BBfyECIAAgACgCCCIEIAAoAhhqIAAoAgQiBkkEfyAAIARBAWoiAjYCCCAAKAIAIAYgAmtqIAM6AABBAAVBfwsgACgCLHIiBDYCLCADQQh2IQMgAUEPSiEGIAFBeGoiAiEBIAYNAAsLAkAgBA0AIAAoAhgiASAAKAIAakEAIAAoAgQgAWsgACgCCGsQChogAkEBSA0AIAAoAggiASAAKAIEIgRPBEAgAEF/NgIsDwsCQCACQQAgBWsiAkwNACAAKAIYIAFqIARJDQAgAEF/NgIsIANBfyACdEF/c3EhAwsgACgCACAEIAFBf3NqaiIAIAAtAAAgA3I6AAALC0UAIABCgICAgICAgICAfzcCGCAAQoCAgICQBDcCECAAQgA3AgggACABNgIAIABCADcCICAAQv////8PNwIoIAAgAjYCBAuoAwEJfyMAQbACayICIQkgAiQAAn8gASAAKALcIyIDRgRAQQAgACgCzCMgACgCyCNGDQEaCyADRQRAIABBjC1qIAAoAsgjIAFB6AdsQQEQWQwBCyACIAAoAuAjQQpsQQVqIgcgA2wiAyABIAdsIgQgAyAEShtBAXRBD2pBcHFrIggiCiQAIANBAU4EQCADIQIDQCAIIAJBf2oiBUEBdGogACAFQQJ0akGIOGoqAgAQDiIGQYCAfiAGQYCAfkobIgZB//8BIAZB//8BSBs7AQAgAkEBSiEGIAUhAiAGDQALCyAJIAAuAdwjQegHbCAAKALII0EAEFkhBSAKIAAoAsgjQegHbSAHbCIHQQF0QQ9qQXBxayICJAAgCSACIAggAxAbIAVqIABBjC1qIgMgACgCyCMgAUEQdEEQdUHoB2xBARBZaiEFIAMgCCACIAcQGyECIARBAU4EQANAIAAgBEF/aiIBQQJ0akGIOGogCCABQQF0ai4BALI4AgAgBEEBSiEDIAEhBCADDQALCyACIAVqCyEEIAAgACgCyCM2AswjIAlBsAJqJAAgBAuvEgERfyMAIgchEiAHIAAoApQCIgggACgCjAIiBGpBAnRBD2pBcHFrIgckACAHIABBGGoiEyAIQQJ0EAghDCAAKAKoAiIHQQRqIRAgACgCkAIhDyAHIQUDQCAAIAwgCEECdGogAiAFIAMgBCADIARIGyIOEJoBAkAgACgClAIiEUFuaiIFQRJLDQAgDkEQdCENAkACQAJAIAVBAWsOEgMDAwMDAQMDAwMDAwMDAwMDAgALIA1BAUgNAiAAKAKYAiIGQRB0QRB1IRRBACEFA0AgAUH//wEgECAFQf//A3EgFGxBEHUiCkESbGoiBC4BACIJIAwgBUEQdUECdGoiCCgCACILQf//A3FsQRB1IAtBEHUgCWxqIAQuAQIiCSAIKAIEIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuAQQiCSAIKAIIIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuAQYiCSAIKAIMIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuAQgiCSAIKAIQIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuAQoiCSAIKAIUIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuAQwiCSAIKAIYIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuAQ4iCSAIKAIcIgtBEHVsaiALQf//A3EgCWxBEHVqIAQuARAiBCAIKAIgIglBEHVsaiAJQf//A3EgBGxBEHVqIBAgBiAKQX9zakESbGoiBC4BACIKIAgoAkQiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BAiIKIAgoAkAiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BBCIKIAgoAjwiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BBiIKIAgoAjgiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BCCIKIAgoAjQiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BCiIKIAgoAjAiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BDCIKIAgoAiwiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BDiIKIAgoAigiCUEQdWxqIAlB//8DcSAKbEEQdWogBC4BECIEIAgoAiQiCEEQdWxqIAhB//8DcSAEbEEQdWoiCEEFdUEBakEBdSIEQYCAfiAEQYCAfkobIAhB3///AEobOwEAIAFBAmohASAFIA9qIgUgDUgNAAsMAgtBACEIIA1BAEwNAQNAIAFB//8BIAcuAQQiBCAMIAhBEHVBAnRqIgUoAlwgBSgCAGoiBkH//wNxbEEQdSAGQRB1IARsaiAHLgEGIgQgBSgCWCAFKAIEaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEIIgQgBSgCVCAFKAIIaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEKIgQgBSgCUCAFKAIMaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEMIgQgBSgCTCAFKAIQaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEOIgQgBSgCSCAFKAIUaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEQIgQgBSgCRCAFKAIYaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgESIgQgBSgCQCAFKAIcaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEUIgQgBSgCPCAFKAIgaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEWIgQgBSgCOCAFKAIkaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEYIgQgBSgCNCAFKAIoaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEaIgQgBSgCMCAFKAIsaiIFQRB1bGogBUH//wNxIARsQRB1aiIFQQV1QQFqQQF1IgRBgIB+IARBgIB+ShsgBUHf//8AShs7AQAgAUECaiEBIAggD2oiCCANSA0ACwwBC0EAIQggDUEATA0AA0AgAUH//wEgBy4BBCIEIAwgCEEQdUECdGoiBSgCjAEgBSgCAGoiBkH//wNxbEEQdSAGQRB1IARsaiAHLgEGIgQgBSgCiAEgBSgCBGoiBkEQdWxqIAZB//8DcSAEbEEQdWogBy4BCCIEIAUoAoQBIAUoAghqIgZBEHVsaiAGQf//A3EgBGxBEHVqIAcuAQoiBCAFKAKAASAFKAIMaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEMIgQgBSgCfCAFKAIQaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEOIgQgBSgCeCAFKAIUaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEQIgQgBSgCdCAFKAIYaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgESIgQgBSgCcCAFKAIcaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEUIgQgBSgCbCAFKAIgaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEWIgQgBSgCaCAFKAIkaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEYIgQgBSgCZCAFKAIoaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEaIgQgBSgCYCAFKAIsaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEcIgQgBSgCXCAFKAIwaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEeIgQgBSgCWCAFKAI0aiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEgIgQgBSgCVCAFKAI4aiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEiIgQgBSgCUCAFKAI8aiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEkIgQgBSgCTCAFKAJAaiIGQRB1bGogBkH//wNxIARsQRB1aiAHLgEmIgQgBSgCSCAFKAJEaiIFQRB1bGogBUH//wNxIARsQRB1aiIFQQV1QQFqQQF1IgRBgIB+IARBgIB+ShsgBUHf//8AShs7AQAgAUECaiEBIAggD2oiCCANSA0ACwsgAyAOayIDQQJOBEAgDCAMIA5BAnRqIBFBAnQQCBogAiAOQQF0aiECIAAoAqgCIQUgACgClAIhCCAAKAKMAiEEDAELCyATIAwgDkECdGogEUECdBAIGiASJAALlQEBBX8gBEEBTgRAIAAoAgAhBSADLgECIQYgAy4BACEHQQAhAwNAIAEgA0ECdGogAiADQQF0ai4BAEEIdCAFaiIFNgIAIAAoAgQhCCAAIAVBAnQiBUH8/wNxIgkgBmxBEHUgBUEQdSIFIAZsajYCBCAAIAggBSAHbGogByAJbEEQdWoiBTYCACADQQFqIgMgBEcNAAsLC7kDAQp/IwAiBSEJIAUgACgCjAIiBEECdEEfakFwcWsiBSQAIAUgACkCIDcCCCAFIAApAhg3AgAgBUEQaiEKIAAoApACIQsDQCAAIAogAiADIAQgAyAESBsiBxCdAUEAIQggB0ERdCIMQQFOBEADQCABQf//ASAIQf//A3FBDGxBEHYiDUEDdCIGQZLBAGouAQAgBSAIQRB1QQF0aiIELgECbCAGQZDBAGouAQAgBC4BAGxqIAZBlMEAai4BACAELgEEbGogBkGWwQBqLgEAIAQuAQZsakELIA1rQQN0IgZBlsEAai4BACAELgEIbGogBkGUwQBqLgEAIAQuAQpsaiAGQZLBAGouAQAgBC4BDGxqIAZBkMEAai4BACAELgEObGoiBEEOdUEBakEBdSIGQYCAfiAGQYCAfkobIARB///+/wNKGzsBACABQQJqIQEgCCALaiIIIAxIDQALCyADIAdrIgNBAU4EQCAFIAUgB0ECdGoiBCkCADcCACAFIAQpAgg3AgggAiAHQQF0aiECIAAoAowCIQQMAQsLIAAgBSAHQQJ0aiIBKQIANwIYIAAgASkCCDcCICAJJAALDQAgACABIAIgAxCdAQvbAwEOfyADQQFOBEAgACgCFCEIIAAoAhAhBiAAKAIMIQQgACgCCCEJIAAoAgQhByAAKAIAIQUDQCABIApBAnQiC2pB//8BIAcgBSACIApBAXRqLgEAQQp0IgwgBWsiBUH//wNxQdINbEEQdiAFQRB1QdINbGoiDWoiDiAHayIHQf//A3FBivUAbEEQdiAHQRB1QYr1AGxqIg9qIgUgCWsiB0H//wNxQauxfmxBEHUgB0EQdUGrsX5saiAFaiIFQQl1QQFqQQF1IglBgIB+IAlBgIB+ShsgBUH/+/8PShs7AQAgASALQQJyakH//wEgBiAEIAwgBGsiBEH//wNxQcY1bEEQdiAEQRB1QcY1bGoiC2oiECAGayIGQf//A3FBqckBbEEQdiAGQRB1QanJAWxqIhFqIgQgCGsiBkH//wNxQfaxf2xBEHUgBkEQdUH2sX9saiAEaiIEQQl1QQFqQQF1IghBgIB+IAhBgIB+ShsgBEH/+/8PShs7AQAgBCAGaiEIIAUgB2ohCSAQIBFqIQYgDiAPaiEHIAsgDGohBCAMIA1qIQUgCkEBaiIKIANHDQALIAAgCDYCFCAAIAY2AhAgACAENgIMIAAgCTYCCCAAIAc2AgQgACAFNgIACwt/AQN/IwBBEGsiASQAIAFBCjoADwJAIAAoAhAiAkUEQCAAEJ8BDQEgACgCECECCwJAIAAoAhQiAyACTw0AIAAsAEtBCkYNACAAIANBAWo2AhQgA0EKOgAADAELIAAgAUEPakEBIAAoAiQRBwBBAUcNACABLQAPGgsgAUEQaiQAC1kBAX8gACAALQBKIgFBf2ogAXI6AEogACgCACIBQQhxBEAgACABQSByNgIAQX8PCyAAQgA3AgQgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCEEEACzABAX8gABC8AiAAKAIABEAgACAAKAIAEIsCIAAQGhogACgCACEBIAAQJxogARAMCwuvAwEGfyAAEMsCIgFBAU4Ef0EQIQMgACABaiIEQXBqIgJBEDYCDCACQRA2AgACQAJAAkBBwOwCKAIAIgBFDQAgASAAKAIIRw0AIAEgAUF8aigCACIDQR91IANzayIGQXxqKAIAIQUgACAENgIIQXAhAyAGIAUgBUEfdXNrIgAgACgCAGpBfGooAgBBf0oNASAAKAIEIgEgACgCCDYCCCAAKAIIIAE2AgQgACACIABrIgE2AgAMAgsgAUEQNgIMIAFBEDYCACABIAQ2AgggASAANgIEQcDsAiABNgIACyABIANqIgAgAiAAayIBNgIACyABQXxxIABqQXxqIAFBf3M2AgAgAAJ/IAAoAgBBeGoiAUH/AE0EQCABQQN2QX9qDAELIAFnIQIgAUEdIAJrdkEEcyACQQJ0a0HuAGogAUH/H00NABogAUEeIAJrdkECcyACQQF0a0HHAGoiAUE/IAFBP0kbCyIBQQR0IgJBwOQCajYCBCAAIAJByOQCaiICKAIANgIIIAIgADYCACAAKAIIIAA2AgRByOwCQcjsAikDAEIBIAGthoQ3AwBBAQVBAAsLoAQBBH8gACABKAIIIAQQFARAIAEgAiADEEIPCwJAIAAgASgCACAEEBQEQAJAIAIgASgCEEcEQCABKAIUIAJHDQELIANBAUcNAiABQQE2AiAPCyABIAM2AiAgASgCLEEERwRAIABBEGoiBSAAKAIMQQN0aiEIIAECfwJAA0ACQCAFIAhPDQAgAUEAOwE0IAUgASACIAJBASAEEEEgAS0ANg0AAkAgAS0ANUUNACABLQA0BEBBASEDIAEoAhhBAUYNBEEBIQdBASEGIAAtAAhBAnENAQwEC0EBIQcgBiEDIAAtAAhBAXFFDQMLIAVBCGohBQwBCwsgBiEDQQQgB0UNARoLQQMLNgIsIANBAXENAgsgASACNgIUIAEgASgCKEEBajYCKCABKAIkQQFHDQEgASgCGEECRw0BIAFBAToANg8LIAAoAgwhBiAAQRBqIgUgASACIAMgBBAuIAZBAkgNACAFIAZBA3RqIQYgAEEYaiEFAkAgACgCCCIAQQJxRQRAIAEoAiRBAUcNAQsDQCABLQA2DQIgBSABIAIgAyAEEC4gBUEIaiIFIAZJDQALDAELIABBAXFFBEADQCABLQA2DQIgASgCJEEBRg0CIAUgASACIAMgBBAuIAVBCGoiBSAGSQ0ADAIACwALA0AgAS0ANg0BIAEoAiRBAUYEQCABKAIYQQFGDQILIAUgASACIAMgBBAuIAVBCGoiBSAGSQ0ACwsLbAECfyAAIAEoAghBABAUBEAgASACIAMQRA8LIAAoAgwhBCAAQRBqIgUgASACIAMQXQJAIARBAkgNACAFIARBA3RqIQQgAEEYaiEAA0AgACABIAIgAxBdIAEtADYNASAAQQhqIgAgBEkNAAsLCzEAIAAgASgCCEEAEBQEQCABIAIgAxBEDwsgACgCCCIAIAEgAiADIAAoAgAoAhwRAQALGAAgACABKAIIQQAQFARAIAEgAiADEEQLC6gCAQR/IwBBQGoiASQAIAAoAgAiAkF8aigCACEDIAJBeGooAgAhBCABQQA2AhQgAUH0GzYCECABIAA2AgwgAUGkHDYCCEEAIQIgAUEYakEAQScQChogACAEaiEAAkAgA0GkHEEAEBQEQCABQQE2AjggAyABQQhqIAAgAEEBQQAgAygCACgCFBEIACAAQQAgASgCIEEBRhshAgwBCyADIAFBCGogAEEBQQAgAygCACgCGBEFACABKAIsIgBBAUsNACAAQQFrBEAgASgCHEEAIAEoAihBAUYbQQAgASgCJEEBRhtBACABKAIwQQFGGyECDAELIAEoAiBBAUcEQCABKAIwDQEgASgCJEEBRw0BIAEoAihBAUcNAQsgASgCGCECCyABQUBrJAAgAgueAQEBfyMAQUBqIgMkAAJ/QQEgACABQQAQFA0AGkEAIAFFDQAaQQAgARCmASIBRQ0AGiADQX82AhQgAyAANgIQIANBADYCDCADIAE2AgggA0EYakEAQScQChogA0EBNgI4IAEgA0EIaiACKAIAQQEgASgCACgCHBEBAEEAIAMoAiBBAUcNABogAiADKAIYNgIAQQELIQAgA0FAayQAIAALSgECfwJAIAAtAAAiAkUgAiABLQAAIgNHcg0AA0AgAS0AASEDIAAtAAEiAkUNASABQQFqIQEgAEEBaiEAIAIgA0YNAAsLIAIgA2sLCABBmhsQYQALMgEBfyMAQRBrIgEkACABQQhqIAAoAgQQXygCAEEBOgAAIAAoAghBAToAACABQRBqJAALMwECfwJAIAAoAggiAC0AACICQQFHBH8gAkECcQ0BIABBAjoAAEEBBUEACw8LQeQaEGEACzUBAn8jAEEQayIBJAAgAUEIaiAAKAIEEF8oAgAtAABBAUcEQCAAEKsBIQILIAFBEGokACACC1ABA38jAEEQayIBJAAgAUE2EF4iAigCACIDEMoB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CyAAQSAgAiALIBEgCUEQamsgD2sgB2ogAyARaiAPa0ECaiADRSAHIAlrQW5qIANOchsiA2oiDCAEEBEgACANIAsQDyAAQTAgAiAMIARBgIAEcxARIAAgCUEQaiAHIAlBEGprIgUQDyAAQTAgAyAFIBEgD2siA2prQQBBABARIAAgDyADEA8LIABBICACIAwgBEGAwABzEBEgCUGwBGokACACIAwgDCACSBsLNAAgAFBFBEADQCABQX9qIgEgAKdBD3FB0BlqLQAAIAJyOgAAIABCBIgiAEIAUg0ACwsgAQstACAAUEUEQANAIAFBf2oiASAAp0EHcUEwcjoAACAAQgOIIgBCAFINAAsLIAELWQAgACABIAIgAxBxIABBEGogAxDGAQRAQagJQbQJQR5B0AkQAAALIABCADcDiAMgAEIANwKUAyAAQQE2ApADIABCADcCnAMgAEEANgKkAyAAELMBIAAQrQELyAIBBH8jAEHQAWsiAiQAIAJBADYCzAEgAkGgAWpBAEEoEAoaIAIgAigCzAE2AsgBAkBBACABIAJByAFqIAJB0ABqIAJBoAFqEEZBAEgNACAAKAJMQQBOBEBBASEECyAAKAIAIQMgACwASkEATARAIAAgA0FfcTYCAAsgA0EgcSEFAn8gACgCMARAIAAgASACQcgBaiACQdAAaiACQaABahBGDAELIABB0AA2AjAgACACQdAAajYCECAAIAI2AhwgACACNgIUIAAoAiwhAyAAIAI2AiwgACABIAJByAFqIAJB0ABqIAJBoAFqEEYgA0UNABogAEEAQQAgACgCJBEHABogAEEANgIwIAAgAzYCLCAAQQA2AhwgAEEANgIQIAAoAhQaIABBADYCFEEACxogACAAKAIAIAVyNgIAIARFDQALIAJB0AFqJAAL2QMCAn8CfiMAQSBrIgIkAAJAIAFC////////////AIMiBUKAgICAgIDA/0N8IAVCgICAgICAwIC8f3xUBEAgAUIEhiAAQjyIhCEEIABC//////////8PgyIAQoGAgICAgICACFoEQCAEQoGAgICAgICAwAB8IQQMAgsgBEKAgICAgICAgEB9IQQgAEKAgICAgICAgAiFQgBSDQEgBEIBgyAEfCEEDAELIABQIAVCgICAgICAwP//AFQgBUKAgICAgIDA//8AURtFBEAgAUIEhiAAQjyIhEL/////////A4NCgICAgICAgPz/AIQhBAwBC0KAgICAgICA+P8AIQQgBUL///////+//8MAVg0AQgAhBCAFQjCIpyIDQZH3AEkNACACQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiBCADQf+If2oQvQEgAiAAIARBgfgAIANrELwBIAIpAwhCBIYgAikDACIAQjyIhCEEIAIpAxAgAikDGIRCAFKtIABC//////////8Pg4QiAEKBgICAgICAgAhaBEAgBEIBfCEEDAELIABCgICAgICAgIAIhUIAUg0AIARCAYMgBHwhBAsgAkEgaiQAIAQgAUKAgICAgICAgIB/g4S/C1ABAX4CQCADQcAAcQRAIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC1ABAX4CQCADQcAAcQRAIAEgA0FAaq2GIQJCACEBDAELIANFDQAgAiADrSIEhiABQcAAIANrrYiEIQIgASAEhiEBCyAAIAE3AwAgACACNwMIC4sCAAJAIAAEfyABQf8ATQ0BAkBB4OECKAIAKAIARQRAIAFBgH9xQYC/A0YNAwwBCyABQf8PTQRAIAAgAUE/cUGAAXI6AAEgACABQQZ2QcABcjoAAEECDwsgAUGAsANPQQAgAUGAQHFBgMADRxtFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAw8LIAFBgIB8akH//z9NBEAgACABQT9xQYABcjoAAyAAIAFBEnZB8AFyOgAAIAAgAUEGdkE/cUGAAXI6AAIgACABQQx2QT9xQYABcjoAAUEEDwsLQfDjAkEZNgIAQX8FQQELDwsgACABOgAAQQELvAEBAX8gAUEARyECAkACQAJAAkAgAUUgAEEDcUVyDQADQCAALQAARQ0CIABBAWohACABQX9qIgFBAEchAiABRQ0BIABBA3ENAAsLIAJFDQELIAAtAABFDQECQCABQQRPBEADQCAAKAIAIgJBf3MgAkH//ft3anFBgIGChHhxDQIgAEEEaiEAIAFBfGoiAUEDSw0ACwsgAUUNAQsDQCAALQAARQ0CIABBAWohACABQX9qIgENAAsLQQAPCyAAC00BAn8CQCAARQ0AIAAo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BygCSBAMIAcoAkwQDCAHKAI8EAwgBygCRBAMIAcoAkAQDCAHEAxBACEHCyAGRQ0AIAYgADYCAAsgBwsTACAAIAEgAiABIAIgAyAEENYBC84BAQJ/IwBBEGsiASQAAkAgAL1CIIinQf////8HcSICQfvDpP8DTQRAIAJBgIDA8gNJDQEgAEQAAAAAAAAAAEEAECQhAAwBCyACQYCAwP8HTwRAIAAgAKEhAAwBCyAAIAEQeEEDcSICQQJNBEACQAJAAkAgAkEBaw4CAQIACyABKwMAIAErAwhBARAkIQAMAwsgASsDACABKwMIECUhAAwCCyABKwMAIAErAwhBARAkmiEADAELIAErAwAgASsDCBAlmiEACyABQRBqJAAgAAu6FwEDfyMAQeABayIDJAAgAyACNgLcASAAIAAoAgBqIQRBeyECAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQeBgaiIFQS9LBEAgAUHhsX9qIgVBC00NASABQYaqf2oiAUERSw0mAkACQAJAIAFBAWsOESkpKSkpKSkpKSkpKSkpKQABAgsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFqQeUASw0oIAAgATYCjAFBACECDCgLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwoCyABIAAoAowBNgIAQQAhAgwnCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUGYeGpBA08EQEF/IQIgAUGYeEcNJwsgACABNgKIAUEAIQIMJgsgBUEBaw4vIyIhHh0SERwbGBcWFRQTGhklJRAPIB8ODSUMAQslCiUlJSUJCCUlBwYFBCUlAwIkCwJAAkACQCAFQQFrDgsnJycnJycnJwInAQALIAMgAygC3AEiAEEEajYC3AEgACgCACIARQRAQX8hAgwnCyADIAA2AnAgBEGfzgAgA0HwAGoQCyECDCYLIAMgAygC3AEiAUEEajYC3AEgACABKAIAIgA2AshuIAMgADYCYCAEQarOACADQeAAahALIQIMJQsgAyADKALcASIBQQRqNgLcASAAIAEoAgAiADYCsAEgAyAANgJQIARBqM4AIANB0ABqEAshAgwkCyAAKAIEIQEg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BCACIApqIAxqQQF0ai4BAEEDdSIOIA5saiEDIAJBAWoiAiAFRw0ACyABIANqIgFB/////wcgAUH/////B0kbIQEgCEEDbCEIIAYoAgAhBkEAIQJBACEDA0AgAyAEIAIgCGogBmpBAXRqLgEAQQN1IgogCmxqIQMgAkEBaiICIAVHDQALCyALIAEgA0EBdmoiAUH/////ByABQf////8HSRs2AgAgDSADNgI4IAlBAWoiCUEERw0AC0EAIQUgACgCjAEiCUHnB0wEQEH//wEgCUEEdUEBam0hBQtB/////wcgBygCICIIIAAoAnxqIgFB/////wcgAUH/////B0kbIgRuIQNBgAEhASAAAn9BgAEgBCAAKAJcIgJBA3RKDQAaQYAIIAQgAkgNABogAkEQdEEQdSIEIANBEHZsIAMgAkEPdUEBakEBdWxqIANB//8DcSAEbEEQdWoiAkEQdUELdCACQQV2Qf8PcXILIgIgBSACIAVKG0EQdEEQdSICIAMgACgCbCIDayIEQRB1bCADaiACIARB//8DcWxBEHVqIgM2AmwgAEH/////ByADbSIDQf///wcgA0H///8HSBsiAzYCXEH/////ByAHKAIkIgogACgCgAFqIgJB/////wcgAkH/////B0kbIgZuIQICQCAGIAAoAmAiBEEDdEoNAEGACCEBIAYgBEgNACAEQRB0QRB1IgEgAkEQdmwgAiAEQQ91QQFqQQF1bGogAkH//wNxIAFsQRB1aiIBQRB1QQt0IAFBBXZB/w9xciEBCyAAIAEgBSABIAVKG0EQdEEQdSIBIAIgACgCcCICayIEQRB1bCACaiABIARB//8DcWxBEHVqIgE2AnAgAEH/////ByABbSIBQf///wcgAUH///8HSBs2AmBB/////wcgBygCKCIMIAAoAoQBaiIBQf////8HIAFB/////wdJGyIGbiECQYABIQEgAAJ/QYABIAYgACgCZCIEQQN0Sg0AGkGACCAGIARIDQAaIARBEHRBEHUiBiACQRB2bCACIARBD3VBAWpBAXVsaiACQf//A3EgBmxBEHVqIgRBEHVBC3QgBEEFdkH/D3FyCyIEIAUgBCAFShtBEHRBEHUiBCACIAAoAnQiAmsiBkEQdWwgAmogBCAGQf//A3FsQRB1aiICNgJ0IABB/////wcgAm0iAkH///8HIAJB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TW9kdWxlLkhFQVBVOC5idWZmZXIsIGJ1ZiwgbGVuKTsgTW9kdWxlLmVuY29kZWRCdWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYXJyYXkpLmJ1ZmZlcik7IH0AAAAAAIwFAAABAAAAAgAAAHJlc3VsdCA9PSAwAC9idWlsZC9zcmMvT2dnQ29udGFpbmVyLmNwcABpbml0AHJlc3VsdCAhPSAwAHByb2R1Y2VJRFBhZ2UAcHJvZHVjZUNvbW1lbnRQYWdlACFvZ2dfc3RyZWFtX2NoZWNrKCZzdHJlYW1fc3RhdGVfKQBwcm9kdWNlUGFja2V0UGFnZQAhKGRhdGEgPT0gbnVsbHB0ciAmJiBzaXplID4gMCkAd3JpdGVQYWNrZXQAIW9nZ19zdHJlYW1fZW9zKCZzdHJlYW1fc3RhdGVfKQA5Q29udGFpbmVyALwOAACBBQAAAAAAAAEAAADYBgAAAAAAAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAAAAAANgGAAAHAAAACAAAAHNhbXBsZV9yYXRlID09IDQ4MDAwAC9idWlsZC9zcmMvQ29udGFpbmVySW50ZXJmYWNlLmNwcABpbml0AGNoYW5uZWxfY291bnQgPiAwICYmIGNoYW5uZWxfY291bnQgPD0gMgBoZWFkZXIAd3JpdGVPcHVzSWRIZWFkZXIAT3B1c0hlYWQAd3JpdGVPcHVzQ29tbWVudEhlYWRlcgBPcHVzVGFncwBvcHVzLW1lZGlhLXJlY29yZGVyAFRJVExFPXJlY29yZGluZwAxOENvbnRhaW5lckludGVyZmFjZQAAOA4AAMIGAAAAAAAAtx3BBG47ggnZJkMN3HYEE2trxReyTYYaBVBHHrjtCCYP8Mki1taKL2HLSytkmww104bNMQqgjjy9vU84cNsRTMfG0Ege4JNFqf1SQaytFV8bsNRbwpaXVnWLVlLINhlqfyvYbqYNm2MREFpnFEAdeaNd3H16e59wzWZedOC2I5hXq+Kcjo2hkTmQYJU8wCeLi93mj1L7pYLl5mSGWFsrvu9G6ro2YKm3gX1os4QtL60zMO6p6hatpF0LbKCQbTLUJ3Dz0P5WsN1JS3HZTBs2x/sG98MiILTOlT11yiiAOvKfnfv2Rru4+/Gmef/09j7hQ+v/5ZrNvOgt0H3sd3CGNMBtRzAZSwQ9rlbFOasGgiccG0MjxT0ALnIgwSrPnY4SeIBPFqGmDBsWu80fE+uKAaT2SwV90AgIys3JDAerl3iwtlZ8aZAVcd6N1HXb3ZNrbMBSb7XmEWIC+9Bmv0afXghbXlrRfR1XZmDcU2Mwm03ULVpJDQsZRLoW2ECXxqWsINtkqPn9J6VO4OahS7Chv/ytYLsliyO2kpbisi8rrYqYNmyOQRAvg/YN7ofzXamZREBonZ1mK5Aqe+qU5x204FAAdeSJJjbpPjv37TtrsPOMdnH3VVAy+uJN8/5f8LzG6O19wjHLPs+G1v/Lg4a41TSbedHtvTrcWqD72O7gDGlZ/c1tgNuOYDfGT2Qylgh6hYvJflytinPrsEt3Vg0ET+EQxUs4NoZGjytHQop7AFw9ZsFY5ECCVVNdQ1GeOx0lKSbcIfAAnyxHHV4oQk0ZNvVQ2DIsdps/m2taOybWFQORy9QHSO2XCv/wVg76oBEQTb3QFJSbkxkjhlIdDlYv8blL7vVgba3413Bs/NIgK+JlPermvBup6wsGaO+2uyfXAabm09iApd5vnWTaas0jxN3Q4sAE9qHNs+tgyX6NPr3JkP+5ELa8tKerfbCi+zquFeb7qszAuKd73XmjxmA2m3F995+oW7SSH0Z1lhoWMoitC/OMdC2wgcMwcYWZkIpdLo1LWferCFRAtslQReaOTvL7T0or3QxHnMDNQyF9gnuWYEN/T0YAcvhbwXb9C4ZoShZHbJMwBGEkLcVl6UubEV5WWhWHcBkYMG3YHDU9nwKCIF4GWwYdC+wb3A9RppM35rtSMz+dET6IgNA6jdCXJDrNViDj6xUtVPbUKXkmqcXOO2jBFx0rzKAA6silUK3WEk1s0strL998du7bwcuh43bWYOev8CPqGO3i7h29pfCqoGT0c4Yn+cSb5v0J/biJvuB5jWfGOoDQ2/uE1Yu8mmKWfZ67sD6TDK3/l7EQsK8GDXGr3ysypmg286JtZrS82nt1uANdNrW0QPexLSsgICAwWDB4AChudWxsKQBBgBYLQREACgAREREAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAEQAPChEREQMKBwABEwkLCwAACQYLAAALAAYRAAAAERERAEHRFgshCwAAAAAAAAAAEQAKChEREQAKAAACAAkLAAAACQALAAALAEGLFwsBDABBlxcLFQwAAAAADAAAAAAJDAAAAAAADAAADABBxRcLAQ4AQdEXCxUNAAAABA0AAAAACQ4AAAAAAA4AAA4AQf8XCwEQAEGLGAseDwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhISAEHCGAsOEgAAABISEgAAAAAAAAkAQfMYCwELAEH/GAsVCgAAAAAKAAAAAAkLAAAAAAALAAALAEGtGQsBDABBuRkL7AQMAAAAAAwAAAAACQwAAAAAAAwAAAwAADAxMjM0NTY3ODlBQkNERUYtMFgrMFggMFgtMHgrMHggMHgAaW5mAElORgBuYW4ATkFOAC4AAAAAGLEAAGJhc2ljX3N0cmluZwBhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAHZlY3RvcgBfX2N4YV9ndWFyZF9hY3F1aXJlIGRldGVjdGVkIHJlY3Vyc2l2ZSBpbml0aWFsaXphdGlvbgBQdXJlIHZpcnR1YWwgZnVuY3Rpb24gY2FsbGVkIQBTdDl0eXBlX2luZm8AAAAAOA4AALgNAABOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAABgDgAA0A0AAMgNAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAABgDgAAAA4AAPQNAAAAAAAAJA4AAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAAAAAAKgOAAAOAAAAFgAAABAAAAARAAAAEgAAABcAAAAYAAAAGQAAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAABgDgAAgA4AACQOAAAAAAAABA8AAA4AAAAaAAAAEAAAABEAAAASAAAAGwAAABwAAAAdAAAATjEwX19jeHhhYml2MTIxX192bWlfY2xhc3NfdHlwZV9pbmZvRQAAAGAOAADcDgAAJA4AAABAAABsIgAAQg8AABIGAABNAgAA2wBBsB4LFe0AAACZAAAASQAAAB4AAAAMAAAABwBB0R4LFUAAAJNdAAC9cAAA7XkAALJ9AAAkfwBB8B4LRDB1AABwFwAAINH//yDR///9+vTp1LaWg3huYlVIPDEoIBkTDw0LCQgHBgUEAwIBANLQzsvHwbeojmhKNCUbFA4KBgQCAEHAHwvSCN/Jt6eYinxvYlhPRj44MiwnIx8bGBUSEA4MCggGBAMCAQC8sJuKd2FDKxoKAKV3UD0vIxsUDgkEAHE/AAAAAAAMIzxTbISdtM7kDyA3TWV9l6/J4RMqQllyiaK40eYMGTJIYXiTrMjfGixFWnKHn7TN4Q0WNVBqgpy0zeQPGSxAWnOOqMTeExg+UmR4kai+1hYfMk9neJeqy+MVHS1BanyWq8TgHjFLYXmOpbrR5RMZNEZddI+mwNsaIj5LYXaRp8LZGSE4Rltxj6XE3xUiM0hhdZGrxN4UHTJDWnWQqMXdFh8wQl91kqjE3hghM010hp60yOAVHEZXanyVqsLZGiE1QFN1mK3M4RsiQV9sgZuu0uEUGkhjcYOasMjbIis9Tl1ym7HN5RcdNmF8iqOz0eUeJjhZdoGessjnFR0xP1VvjqPB3hswTWeFnrPE1+gdL0pjfJewxtztISo9TF15m67P4R01V3CImqq80OMYHjRUg5amusvlJTBAVGh2nLHJ5lELCgkKCQoJ7wjvCAoJ/AgXCe8ISAsUCloJPwkKCeII4gjiCOIIkgi3CSQJJAkKCQoJCgkkCSQJPwkyCZAMzgokCSQJCgniCK0InwjVCJIInAmqCT8JWglaCVoJWgk/CWcJCgmXDfALTwifCOII4gjiCO8ICgnVCNIMRQwUCloJxwitCJ8IkgiSCEIIABAFD60IPAo8CmcJCglaCT8JGghqDKwMPwmtCPkJggkkCQoJdwitCAoNoA2mCpII1QicCTIJPwmfCDUIMgl0CRcJPwlaCXQJdAl0CZwJPwnDDi0OggnfCT8J4gjiCPwInwgACLYMmQyZCh4LjwkXCfwI/AjiCE8IvwzkDMEK9gqPCdUI1QjHCE8INQg5C6ULSQo/CWcJMgmSCMcIxwhCCJkMfQxJChQK4giFCMcIrQitCF0IagzuDLQKZwniCOII4gjvCJIIQghFDMgMnAkNCO8IxAk/CbcJggmFCLMN0gwKCYwKVwqqCT8JWgkkCU8IXw3PDd4L8Av8CJ4HrQjiCOII4ghMDSYNJwh/CjkLMgl0CeIIqgnsCbAOoA2eB2QKUQvfCVoJPwmcCdUI1AvIDLQKSAu0CmoITwjvCLoIxwhvDkkO6QexB2QKjAoUCsQJFwk/CYcMVQ0yCRoISAtICyQJtwnHCHcICg0mDR4L3AoXCWoI4gjvCEIIDQgXCfwIhQh3CIUIPwlJCowKjAr5CWcJggmtCNUIrQitCCQJdAkvCowK3gusDPYKSAuqCRoI/AgKCTIJTAmtCGoITwjvCMQJ6QrpCjwKFAo/CVwOgQ66CC4HhQjBCqYKcQrRCZ8I6QpYDKYK+QkeC9EJhQhaCa0IhQjUspSBbGBVUk9NPTs5ODMxMC0qKSgmJCIfHhUMCgMBAP/19Ozp4dnLvrCvoZWIfXJmW1FHPDQrIxwUExIMCwUAs4qMlJeVmZejdENSO1xIZFlcAEGgKAvnARAAAAAAY0IkJCIkIiIiIlNFJDQidGZGRESwZkREIkFVRFQkdI2Yi6qEu7jYiYT5qLmLaGZkRESy2rm5qvTYu7uq9Lu724pnm7i5iXS3m5iIhNm4uKqk2aubi/SpuLmqpNjf2orWj7zaqPSNiJuqqIrc24uk28rYiai69rmLdLnbuYpkZIZkZiJERGREqMvd2qinmohoRqT2q4mLiZva24v//v3uDgMCAQD//vzaIwMCAQD//vrQOwQCAQD//vbCRwoCAQD//Oy3UggCAQD//Ou0WhECAQD/+OCrYR4EAQD//uytXyUHAQBBkCoL7g3///+DBpH//////+xdD2D//////8JTGUfd/////6JJIkKi////0n5JKzmt////yX1HMDqC////pm5JOT5o0v//+3tBN0Rkq/8AAAAAAAAAAPoAAwAGAAMAAwADAAQAAwADAAMAzQEAACAACgAULmQBABAAAEARAADAEwAAABQAACAUAADAFAAAEBUAAGAVAAAHFyY2RVVkdIOTorLB0N/vDRkpN0VTYnB/jp2ru8vc7A8VIjM9TlxqfoiYp7nN4fAKFSQyP09fbn6Nna29zd3tERQlMztOWWt7hpakuM3g8AoPIDNDUWBwgY6erb3M3OwIFSUzQU9icX6Km6izwNHaDA8iNz9OV2x2g5Snucvb7BATICQ4T1tsdoiaq7rM3O0LHCs6SllpeIeWpbTE0+LxBhAhLjxLXGt7iZypucfW4QsTHiw5SllpeYeYqbrK2uoMEx0uOUdYZHiElKW2x9jpERcjLjhNXGp7hpinucze7Q4RLTU/S1lrc4SXq7zO3fAJEB0oOEdYZ3eJmqu9zd7tEBMkMDlMV2l2hJanucra7AwRHTZHUV5ofoiVpLbJ3e0PHC8+T2FzgY6bqLTC0N/uCA4eLT5OXm9/j5+vwM/f7xEeMT5PXGt3hJGgrr7M3OsOEyQtPUxbbHmKmqy9zd7uDBIfLTxMW2t7ipqru8zd7A0RHys1RlNncoOVp7nL3O0RFiMqOk5dbn2Lm6q8zuDwCA8iMkNTY3ODkqKywdHg7w0QKUJJVl9vgImWo7fO4fERGSU0P0tcZneEkKCvv9TnEx8xQVNkdYWToa67yNXj8hIfNERYZ3V+ipWjscDP3+8QHS89TFpqd4WTobDB0eDwDxUjMj1JVmFud4GNr8ba7UkObQttC20LbQttC20LbQttC20LbQttC5MLkwttCx4LkAwNDJwL8AvwC8ILwgvCC5MLkwvCC5wLSAseCx4LpgpQD64PpQuHDIcMdgvwCx4LMgysDG0LHgs8CvkJ3AptC7wNfQzCCx8MywtIC20LbQttC20LSAtIC0gLSAtIC8EKvhO+E3YL9Q05DfALDQzpClgMWAycCx4L0QnsCcEKSAtMETUQjArBCpwLwgttCx4LpQvLC20LbQttC20LSAumCiQOywucC/AL8As5C/YK8AuQDOcLpQvbDNsMpQvuDK8LaxSWE+wJCg3GDTkNfQwWDDANpQuMClcKfwrpCh4LcQrZEzYUBxJMEZwJUQvnC4cMYQx/CrQKSAseC+kKHguMCjIMSAuTC20LbQttC20LkwuTC5MLkwttC20LkwuTC5MLahCHDKULHwzCC0gLSAttC5wLOQtkC8sLnAvCC30MOQuwDrAOrAwfDKULSAttC0gLnAt2C+kK6QoeC0gLSAtkCg4Prg+HDDIMrAx2C+cLkwuTCw0MHgvpCukK6QrpChQKBQ/wDx0NvA0WDLQKwgt2CzIMDQweCx4LVwpXCh4L9gobFB4TmQwFD3ENYQxRC1UNew2MChQKcQq0Ch4L9grBCg0QzQ7bDFgMbQtIC0gLbQvpCrQK6Qq0CukKHgtIC/YK2RO+E+cL2Q2sDPALDQyACx8MUQu0CrQKtAoeC+kKPArVENUQLAvfCYcMMA0wDQMMAwwwDfALHgtXChQKpgrBCvALZAv2CkgLtAp/ClELHwxODE4MkAxhDPALwguTCx4LFxEqD20LSAseC0gLHgseC0gLSAtICx4LSAttC0gLHgulC2QLZAulC6UL8AsyDJAMTgzwC8ILnAucC5wLbQu0CoUQNRDuDBMNbQuTC0gLpQulCx4L6Qq0Ch4LHgseC+kK8A+uDx8MwgttC20LbQtIC20LbQseCx4LHgvpCkgL3AoHEt8RYQxxDYcMpQtRC94LMgy0Cn8Kfwp/CrQK6QqMCjUQrRDNDkkOpgrcCkgLSAvCC5wLbQseC38KfwrpCkgLdxDiDcEKHgseC0gLSAtIC20LbQtIC20LbQttC5MLSAs2FDkT1QhoDc0Olw0TDR4L7gyXDU4MUQucCbcJwQptC3sNZQ4yDH0MHQ3nC4cMhwylC5AMDQxtC20LfwrsCYIJpQvCC+kK6Qq0CukKHgucC/ALHwxODE4MTgwfDMILwguACzkLfwqmCtwKwgtoDdkNHQ2sDPALwguTC20LSAseC8sLgAtRC8ILwgucC8sLHwzwC/ALwgtICx4LbQttC0gLUA9/D8ILfQwdDZAM2wzbDJcNeA5xDaYKhQicCRQKLwrhzMm4t6+empmHd3Nxbm1jYl9PRDQyMC0rIB8bEgoDAP/76+bUycS2p6ajl4p8bmhaTkxGRTktIhgVCwYFBAMAr5SgsLKtrqSxrsS2xsC2RD5CPEh1VVp2iJeOoI6bAEGHOAvAAgFkZmZERCQiYKRrnrm0uYtmQEIkIiIAASDQi42/mLmbaGCraKZmZmaEAQAAAAAQEABQbU5ruYtnZdDUjYutmXtnJAAAAAAAAAEwAAAAAAAAIESHe3d3Z0ViRGd4dnZmR2KGiJ24tpmLhtCo+Eu9j3lrIDEiIiIAEQLS64t7uYlphmKHaLZkt6uGZEZERkJCIoNApmZEJAIBAIamZkQiIkKE1Paei2trV2Zk2316iXZnhHKHiWmrajIipNaNj7mXeWfAIgAAAAAAAdBtSruG+Z+JZm6adldld2UAAgAkJEJEI2CkZmQkAAIhp4quZmRUAgJka3h3JMUYAP/+/fQMAwIBAP/+/OAmAwIBAP/++9E5BAIBAP/+9MNFBAIBAP/76LhUBwIBAP/+8LpWDgIBAP/+77JbHgUBAP/447FkEwIBAEHQOguaAf///5wEmv//////42YPXP//////1VMYSOz/////lkwhP9b///++eU0rN7n////1iUcrO4v/////g0IyQmvC//+mdEw3NX3//wAAAAAAAAAAZAADACgAAwADAAMABQAOAA4ACgALAAMACAAJAAcAAwBbAQAAIAAQAGYmqwGgFQAAoBcAAKAbAADgGwAAABwAAAAdAABQHQAAoB0AQfQ7C5AFQB8AALgkAADsLAAAvDQAAFxEAACoYQAAgDgBAAAAAAAoIwAA4C4AAKQ4AABESAAAtF8AAKyKAACAOAEAAAAAAAQpAACwNgAAaEIAAPxTAABUbwAAEKQAAIA4AQASAB0AJgAoAC4ANAA+AFQAXMq+2LbfmuKc5njsevTM/DQDhguIE2QZZh1KIEInpDX59/b19OrSysnIxa5SOzg3Ni4WDAsKCQcAQADLlgDXw6Z9blIAAAAAmx4AAJ4eAAB4AIBAAOieCgDmAPPdwLUAZADwACAAZADNPAAwACCrVQDAgEAAzZpmMwDVq4BVKwDgwKCAYEAgAGQoEAcDAQAACmfyDlbN5B0KZ/IOdVKCDFmaBBl1UoIMRhExCu0DYhRGETEK2gLXB/nGrQ/aAtcHIrZSBdr6pAoitlIFAAAAAEbzLh4r40sOH2aAGBwsHQraYUgS7Zz0BuwwEwvjkKUE7aQdAgrfawMAAAAAAAAAACqv1cnP/0AAEQBj/2EBEP6jACcrvVbZ/wYAWwBW/7oAFwCA/MAY2E3t/9z/ZgCn/+j/SAFJ/AgKJT4AAAAAAACHxz3JQACAAIb/JAA2AQD9SAIzJEVFDACAABIAcv8gAYv/n/wbEHs4AAAAAAAAAABoAg3I9v8nADoA0v+s/3gAuADF/uP9BAUEFUAjAAAAAOY+xsTz/wAAFAAaAAUA4f/V//z/QQBaAAcAY/8I/9T/UQIvBjQKxwwAAAAAAAAAAORXBcUDAPL/7P/x/wIAGQAlABkA8P+5/5X/sf8yACQBbwLWAwgFuAUAAAAAAAAAAJRrZ8QRAAwACAABAPb/6v/i/+D/6v8DACwAZACoAPMAPQF9Aa0BxwET9ZXmWRLzKR8GVCAAQZDBAAuXAb0AqP1pAmd3dQBh/9L7CHQ0AN0AqPZ0bvz/EQLq8uVm0P/2AozwpV2w/4kDde8GU53/zAOC72ZHlf/HA4vwJzuZ/4ADYfKuLqX/BQPP9F4iuf9jAqH3mBbS/6kBofq0CwYAAwAHAwABCgACBhIKDAQAAgAAAAkEBwQAAwwHBwAA4HAsDwMCAQD+7cCERhcEAP/84ps9CwIAQbDCAAsz+vXqy0cyKiYjIR8dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQCzYwBHOCseFQwGAEHwwgALRMelkHxtYFRHPTMqIBcPCADx4dPHu6+kmY6Ee3JpYFhQSEA5MiwmIR0YFBAMCQUCAFwhAABwIQAAgCEAAA+Dioqbm62tAEHAwwAL9AJFXXN2g4qNipaWm5aboKagg4CGjY2NkZGRlpubm5ugoKCgpqatrbbAtsDAwM3AzeCsIQAAwCEAANAhAAAAAAAABAYYBwUAAAIAAAwcKQ389w8qGQ4B/j4p9/YlQfwD+gRCB/gQDib9IQAAAAAAAAAADRYnFwz/JEAb+vkKNysRAQEIAQEG9Uo19/Q3TPQI/QNdG/waJzsD+AIATQsJ+BYs+gcoCRoDCfkUZfkEA/gqGgDxIUQCF/43Lv4PA/8VECn6Gz0nBfUqWAQB/jxBBvz/+0k4AfcTXh33AAxjBgQI7WYu8wMCDQMCCetUSO71LmjqCBImMBcA8EZT6wsF9XUW+PoXdfQDA/hfHAT2D0088f8EfAL8AyZUGOcCDSoNHxX8OC7//yNP8xP5QVj38hQEUTHjFABLA+8F9yxc+AH9FkUf+l8p9AUnQxD8AQD6eDfc8yx6BOhRBQsDBwIACQpYACIAADAiAACAIgAALgJaV11bUmIAQcDGAAtDbXh2DHFzdXdjO1dvP29wUH58fXyBeX4XhH9/f35/eoWChmV2d5F+Vnx4e3eqrWttLCMAAEAjAABQIwAACBAgCAoMEABBkMcAC7MBfTMaEg8MCwoJCAcGBQQDAgEAxmktFg8MCwoJCAcGBQQDAgEA1aJ0UzsrIBgSDwwJBwYFAwIA77t0OxwQCwoJCAcGBQQDAgEA+uW8h1YzHhMNCggGBQQDAgEA+evVuZyAZ1NCNSohGhURDQoA/vnrzqR2TS4bEAoHBQQDAgEA//3579y/nHdVOSUXDwoGBAIA//379u3fy7OYfGJLNygdFQ8A//7999yiakMqHBIMCQYEAwIAQdDIAAuiAR85a6DNzf///////////////0UvQ2+mzf///////////////1JKT19tgJGgrc3NzeD//+D/4H1KO0Vhjbb//////////////61zVUlMXHORrc3g4P///////6aGcWZlZmt2fYqRm6a2wMDNluC2hmVTT1VheJGtzeD////////gwJZ4ZVxZXWZ2hqC2wODg4P/g4LabhnZtaGZqb3aDkaCtgwBBgMoACxHxvrKEV0opDgDfwZ2MajknEgBBoMoACxKDSo1PUIpfaIZfY1t9XUx7c3sAQcDKAAuXAYAA1ioA64AVAPS4SAsA+NaAKgcA+OGqUBkFAPvsxn42EgMA+u7Tn1IjDwUA+ufLqIBYNRkGAPzu2LmUbEcoEgQA/fPhx6aAWjkfDQMA/vbp1LeTbUksFwoCAP/68N/GpoBaOiEQBgEA//v059K1km5LLhkMBQEA//347t3EpIBcPCMSCAMBAP/9+fLl0LSSbkwwGw4HAwEAQeDLAAuXAYEAzzIA7IEUAPW5SAoA+dWBKgYA+uKpVxsEAPvpwoI+FAQA+uzPoGMvEQMA//DZtoNRKQsBAP/+6cmfaz0UAgEA//npzqqAVjIXBwEA//ru2bqUbEYnEgYBAP/88+LIpoBaOB4NBAEA//z159G0km5MLxkLBAEA//347dvCo4BdPiUTCAMBAP/++vHizbGRb08zHg8GAgEAQYDNAAuXAYEAyzYA6oEXAPW4SQoA+teBKQUA/OitVhgDAP3wyIE4DwIA/fTZpF4mCgEA/fXivYRHGwcBAP3258ufaTgXBgEA//jr1bOFVS8TBQEA//7z3cKfdUYlDAIBAP/++OrQq4BVMBYIAgEA//768Ny9lWtDJBAGAgEA//778+PJpoBaNx0NBQIBAP/+/Pbq1beTbUkrFgoEAgEAQaDOAAuXAYIAyDoA54IaAPS4TAwA+daCKwYA/OitVxgDAP3xy4M4DgIA/vbdp14jCAEA/vnowYJBFwUBAP/779OiYy0PBAEA//vz37qDSiELAwEA//z15sqeaTkYCAIBAP/99+vWs4RULBMHAgEA//768N/En3BFJA8GAgEA//799efRsIhdNxsLAwIBAP/+/fzv3cKedUwqEgQDAgEAQcLPAAsPAgUJDhQbIyw2QU1aaHeHAEHgzwALKv4xQ01SXWPGCxIYHyQt/y5CTldeaNAOFSAqM0L/XmhtcHN2+DVFUFhfZgBBmNAACz4DAAAAAgAAAAMAAAACAAAABQAAAAIAAAADAAAAAgAAAAMAAAACAAAABQAAAAIAAAADAAAAAgAAAAABAAAAAQBB4tAAC/kBAf8B/wL+Av4D/QABAAH/Av8C/gP+A/0H/gcAAAAAAAL///8AAAEBAAEAAQAAAAAAAQAAAAAAAQAAAAEAAAAAAP8CAQABAQAA//8AAAAAAAAB/wAB/wD/Af4C/v4C/QID/fwD/AQE+wX6+wb5BgUI9wAAAQAAAAAAAAD/AQAAAf8AAf//Af8CAf8C/v4C/gICA/0AAQAAAAAAAAEAAQAAAf8BAAACAf8C//8C/wIC/wP+/v4DAAEAAAEAAf8C/wL/AgP+A/7+BAT9Bf38BvwGBfsI+vv5CQAAAAAAAAAA+wj/Bv8G/Ar6Cv4G/wb7CvcM/Qf+B/kNEBgiAEHm0gALjCLgPwAAAAAAAOC/XT1/Zp6g5j8AAAAAAIg5PUQXdfpSsOY/AAAAAAAA2Dz+2Qt1EsDmPwAAAAAAeCi9v3bU3dzP5j8AAAAAAMAePSkaZTyy3+Y/AAAAAAAA2LzjOlmYku/mPwAAAAAAALy8hpNR+X3/5j8AAAAAANgvvaMt9GZ0D+c/AAAAAACILL3DX+zodR/nPwAAAAAAwBM9Bc/qhoIv5z8AAAAAADA4vVKBpUiaP+c/AAAAAADAAL38zNc1vU/nPwAAAAAAiC898WdCVutf5z8AAAAAAOADPUhtq7EkcOc/AAAAAADQJ704Xd5PaYDnPwAAAAAAAN28AB2sOLmQ5z8AAAAAAADjPHgB63MUoec/AAAAAAAA7bxg0HYJe7HnPwAAAAAAQCA9M8EwAe3B5z8AAAAAAACgPDaG/2Jq0uc/AAAAAACQJr07Ts828+LnPwAAAAAA4AK96MORhIfz5z8AAAAAAFgkvU4bPlQnBOg/AAAAAAAAMz0aB9Gt0hToPwAAAAAAAA89fs1MmYkl6D8AAAAAAMAhvdBCuR5MNug/AAAAAADQKT21yiNGGkfoPwAAAAAAEEc9vFufF/RX6D8AAAAAAGAiPa+RRJvZaOg/AAAAAADEMr2VozHZynnoPwAAAAAAACO9uGWK2ceK6D8AAAAAAIAqvQBYeKTQm+g/AAAAAAAA7bwjoipC5azoPwAAAAAAKDM9+hnWugW+6D8AAAAAALRCPYNDtRYyz+g/AAAAAADQLr1MZgheauDoPwAAAAAAUCC9B3gVma7x6D8AAAAAACgoPQ4sKND+Auk/AAAAAACwHL2W/5ELWxTpPwAAAAAA4AW9+S+qU8Ml6T8AAAAAAED1PErGzbA3N+k/AAAAAAAgFz2umF8ruEjpPwAAAAAAAAm9y1LIy0Ra6T8AAAAAAGglPSFvdprda+k/AAAAAADQNr0qTt6fgn3pPwAAAAAAAAG9oyN65DOP6T8AAAAAAAAtPQQGynDxoOk/AAAAAACkOL2J/1NNu7LpPwAAAAAAXDU9W/GjgpHE6T8AAAAAALgmPcW4Sxl01uk/AAAAAAAA7LyOI+MZY+jpPwAAAAAA0Bc9AvMHjV766T8AAAAAAEAWPU3lXXtmDOo/AAAAAAAA9bz2uI7teh7qPwAAAAAA4Ak9Jy5K7Jsw6j8AAAAAANgqPV0KRoDJQuo/AAAAAADwGr2bJT6yA1XqPwAAAAAAYAs9E2L0ikpn6j8AAAAAAIg4PaezMBOeeeo/AAAAAAAgET2NLsFT/ovqPwAAAAAAwAY90vx5VWue6j8AAAAAALgpvbhvNSHlsOo/AAAAAABwKz2B89O/a8PqPwAAAAAAANk8gCc8Ov/V6j8AAAAAAADkPKPSWpmf6Oo/AAAAAACQLL1n8yLmTPvqPwAAAAAAUBY9kLeNKQcO6z8AAAAAANQvPamJmmzOIOs/AAAAAABwEj1LGk+4ojPrPwAAAAAAR00950e3FYRG6z8AAAAAADg4vTpZ5Y1yWes/AAAAAAAAmDxqxfEpbmzrPwAAAAAA0Ao9UF778nZ/6z8AAAAAAIDePLJJJ/KMkus/AAAAAADABL0DBqEwsKXrPwAAAAAAcA29Zm+at+C46z8AAAAAAJANPf/BS5AezOs/AAAAAACgAj1vofPDad/rPwAAAAAAeB+9uB3XW8Ly6z8AAAAAAKAQvemyQWEoBuw/AAAAAABAEb3gUoXdmxnsPwAAAAAA4As97mT62Rwt7D8AAAAAAEAJvS/Q/1+rQOw/AAAAAADQDr0V/fp4R1TsPwAAAAAAZjk9y9BXLvFn7D8AAAAAABAavbbBiImoe+w/AAAAAIBFWL0z5waUbY/sPwAAAAAASBq938RRV0Cj7D8AAAAAAADLPJSQ79wgt+w/AAAAAABAAT2JFm0uD8vsPwAAAAAAIPA8EsRdVQvf7D8AAAAAAGDzPDurW1sV8+w/AAAAAACQBr28iQdKLQftPwAAAAAAoAk9+sgIK1Mb7T8AAAAAAOAVvYWKDQiHL+0/AAAAAAAoHT0DosrqyEPtPwAAAAAAoAE9kaT73BhY7T8AAAAAAADfPKHmYuh2bO0/AAAAAACgA71Og8kW44DtPwAAAAAA2Ay9kGD/cV2V7T8AAAAAAMD0PK4y2wPmqe0/AAAAAACQ/zwlgzrWfL7tPwAAAAAAgOk8RbQB8yHT7T8AAAAAACD1vL8FHGTV5+0/AAAAAABwHb3smnszl/ztPwAAAAAAFBa9Xn0Za2cR7j8AAAAAAEgLPeej9RRGJu4/AAAAAADOQD1c7hY7MzvuPwAAAAAAaAw9tD+L5y5Q7j8AAAAAADAJvWhtZyQ5Ze4/AAAAAAAA5bxETMf7UXruPwAAAAAA+Ae9JrfNd3mP7j8AAAAAAHDzvOiQpKKvpO4/AAAAAADQ5TzkynyG9LnuPwAAAAAAGhY9DWiOLUjP7j8AAAAAAFD1PBSFGKKq5O4/AAAAAABAxjwTWmHuG/ruPwAAAAAAgO68BkG2HJwP7z8AAAAAAIj6vGO5azcrJe8/AAAAAACQLL11ct1IyTrvPwAAAAAAAKo8JEVuW3ZQ7z8AAAAAAPD0vP1EiHkyZu8/AAAAAACAyjw4vpyt/XvvPwAAAAAAvPo8gjwkAtiR7z8AAAAAAGDUvI6QnoHBp+8/AAAAAAAMC70R1ZI2ur3vPwAAAAAA4MC8lHGPK8LT7z8AAAAAgN4Qve4jKmvZ6e8/AAAAAABD7jwAAAAAAADwPwAAAAAAAAAAvrxa+hoL8D8AAAAAAECzvAMz+6k9FvA/AAAAAAAXEr2CAjsUaCHwPwAAAAAAQLo8bIB3Ppos8D8AAAAAAJjvPMq7ES7UN/A/AAAAAABAx7yJf27oFUPwPwAAAAAAMNg8Z1T2cl9O8D8AAAAAAD8avVqFFdOwWfA/AAAAAACEAr2VHzwOCmXwPwAAAAAAYPE8GvfdKWtw8D8AAAAAACQVPS2ocivUe/A/AAAAAACg6bzQm3UYRYfwPwAAAAAAQOY8yAdm9r2S8D8AAAAAAHgAvYPzxso+nvA/AAAAAAAAmLwwOR+bx6nwPwAAAAAAoP88/Ij5bFi18D8AAAAAAMj6vIps5EXxwPA/AAAAAADA2TwWSHIrkszwPwAAAAAAIAU92F05IzvY8D8AAAAAAND6vPPR0zLs4/A/AAAAAACsGz2mqd9fpe/wPwAAAAAA6AS98NL+r2b78D8AAAAAADANvUsj1ygwB/E/AAAAAABQ8TxbWxLQARPxPwAAAAAAAOw8+Speq9se8T8AAAAAALwWPdUxbMC9KvE/AAAAAABA6Dx9BPIUqDbxPwAAAAAA0A696S2prppC8T8AAAAAAODoPDgxT5OVTvE/AAAAAABA6zxxjqXImFrxPwAAAAAAMAU938NxVKRm8T8AAAAAADgDPRFSfTy4cvE/AAAAAADUKD2fu5WG1H7xPwAAAAAA0AW9k42MOPmK8T8AAAAAAIgcvWZdN1gml/E/AAAAAADwET2ny2/rW6PxPwAAAAAASBA944cT+Jmv8T8AAAAAADlHvVRdBITgu/E/AAAAAADkJD1DHCiVL8jxPwAAAAAAIAq9srloMYfU8T8AAAAAAIDjPDFAtF7n4PE/AAAAAADA6jw42fwiUO3xPwAAAAAAkAE99804hMH58T8AAAAAAHgbvY+NYog7BvI/AAAAAACULT0eqHg1vhLyPwAAAAAAANg8Qd19kUkf8j8AAAAAADQrPSMTeaLdK/I/AAAAAAD4GT3nYXVuejjyPwAAAAAAyBm9JxSC+x9F8j8AAAAAADACPQKmsk/OUfI/AAAAAABIE72wzh5xhV7yPwAAAAAAcBI9Fn3iZUVr8j8AAAAAANARPQ/gHTQOePI/AAAAAADuMT0+Y/Xh34TyPwAAAAAAwBS9MLuRdbqR8j8AAAAAANgTvQnfH/WdnvI/AAAAAACwCD2bDtFmiqvyPwAAAAAAfCK9Otra0H+48j8AAAAAADQqPfkadzl+xfI/AAAAAACAEL3ZAuSmhdLyPwAAAAAA0A69eRVkH5bf8j8AAAAAACD0vM8uPqmv7PI/AAAAAACYJL0iiL1K0vnyPwAAAAAAMBa9JbYxCv4G8z8AAAAAADYyvQul7u0yFPM/AAAAAIDfcL2410z8cCHzPwAAAAAASCK9oumoO7gu8z8AAAAAAJglvWYXZLIIPPM/AAAAAADQHj0n+uNmYknzPwAAAAAAANy8D5+SX8VW8z8AAAAAANgwvbmI3qIxZPM/AAAAAADIIj05qjo3p3HzPwAAAAAAYCA9/nQeIyZ/8z8AAAAAAGAWvTjYBW2ujPM/AAAAAADgCr3DPnEbQJrzPwAAAAAAckS9IKDlNNun8z8AAAAAACAIPZVu7L9/tfM/AAAAAACAPj3yqBPDLcPzPwAAAAAAgO88IuHtROXQ8z8AAAAAAKAXvbs0Ekym3vM/AAAAAAAwJj3MThzfcOzzPwAAAAAApki9jH6sBEX68z8AAAAAANw8vbugZ8MiCPQ/AAAAAAC4JT2VLvchChb0PwAAAAAAwB49RkYJJ/sj9D8AAAAAAGATvSCpUNn1MfQ/AAAAAACYIz3ruYQ/+j/0PwAAAAAAAPo8GYlhYAhO9D8AAAAAAMD2vAHSp0IgXPQ/AAAAAADAC70WAB3tQWr0PwAAAAAAgBK9JjOLZm149D8AAAAAAOAwPQA8wbWihvQ/AAAAAABALb0Er5Lh4ZT0PwAAAAAAIAw9ctPX8Cqj9D8AAAAAAFAevQG4bep9sfQ/AAAAAACABz3hKTbV2r/0PwAAAAAAgBO9MsEXuEHO9D8AAAAAAIAAPdvd/Zmy3PQ/AAAAAABwLD2Wq9iBLev0PwAAAAAA4By9Ai2ddrL59D8AAAAAACAZPcExRX9BCPU/AAAAAADACL0qZs+i2hb1PwAAAAAAAPq86lE/6H0l9T8AAAAAAAhKPdpOnVYrNPU/AAAAAADYJr0arPb04kL1PwAAAAAARDK925RdyqRR9T8AAAAAADxIPWsR6d1wYPU/AAAAAACwJD3eKbU2R2/1PwAAAAAAWkE9DsTi2yd+9T8AAAAAAOApvW/Hl9QSjfU/AAAAAAAII71MC/8nCJz1PwAAAAAA7E09J1RI3Qer9T8AAAAAAADEvPR6qPsRuvU/AAAAAAAIMD0LRlmKJsn1PwAAAAAAyCa9P46ZkEXY9T8AAAAAAJpGPeEgrRVv5/U/AAAAAABAG73K69wgo/b1PwAAAAAAcBc9uNx2ueEF9j8AAAAAAPgmPRX3zeYqFfY/AAAAAAAAAT0xVTqwfiT2PwAAAAAA0BW9tSkZHd0z9j8AAAAAANASvRPDzDRGQ/Y/AAAAAACA6rz6jrz+uVL2PwAAAAAAYCi9lzNVgjhi9j8AAAAAAP5xPY4yCMfBcfY/AAAAAAAgN71+qUzUVYH2PwAAAAAAgOY8cZSesfSQ9j8AAAAAAHgpvQAg/h/2H+of2B/CH6gfiB9iHzofCh/YHqAeYh4iHtwdkB1CHe4clhw6HNgbchsKG5waKhq0GToZvBg8GLYXLhegFhAWfhXoFE4UsBMQE24SyBEeEXQQxg8WD2QOrg34DEAMhAvICgoKSgmKCMYHAgc+BngFsgTqAyIDWgKSAcoAAAA2/27+pv3e/Bb8TvuI+sL5/vg6+Hb3tvb29Tj1fPTA8wjzUvKc8erwOvCM7+LuOO6S7fDsUOyy6xjrgurw6WDp0uhK6MTnROfG5kzm1uVk5fbkjuQo5MbjauMS477icOIk4t7hnuFg4Sjh9uDG4J7geOBY4D7gKOAW4ArgAuAA4ABBgfUAC4UBDwgHBAsMAwINCgUGCQ4BAAkGAwQFCAECBwAAgLsAAHgAAAAVAAAAFQAAAACaWT8AAAAAAACAPwAAgD8QOwAAAwAAAAgAAAB4AAAACwAAAEA7AAAwPAAAYDwAAIAHAAADAAAAQD4AAGByAACQcwAASHQAAIA+AACIAQAAoFoAAIBbAAAQXQBBkvYACykBAAIAAwAEAAUABgAHAAgACgAMAA4AEAAUABgAHAAiACgAMAA8AE4AZABB1fYAC9IBWlBLRT84MSgiHRQSCgAAAAAAAAAAbmRaVE5HQTozLScgGhQMAAAAAAAAdm5nXVZQS0ZBOzUvKB8XDwQAAAAAfndwaF9ZU05IQjw2LycgGREMAQAAhn94cmdhW1VOSEI8Ni8pIx0XEAoBkImCfHFrZV9YUkxGQDkzLSchGg8BmJGKhHt1b2liXFZQSkM9NzErJBQBopuUjoV/eXNsZmBaVE1HQTs1Lh4BrKWemI+Jg312cGpkXldRS0U/OC0UyMjIyMjIyMjGwby3sq2oo56ZlIFoAEHA+AALnwQIAAgACAAIABAAEAAQABUAFQAYAB0AIgAkAAAAAAAAAGocjThSux46CGncOoLtVzuJY7I7AyoFPDDcOTy0Pnc8HKOePNHyxTz+hvE8m6sQPQWtKj2EwkY9U+ZkPRGJgj2Hn5M9y7KlPdG+uD06v8w9VK/hPRSK9z0OJQc+2fQSPl8xHz5o1ys+iuM4PjBSRj6UH1Q+v0diPo7GcD6wl38+UluHPmAPjz6Y5ZY+eduePnDupj7YG68++2C3PhG7vz5GJ8g+t6LQPngq2T6Uu+E+DFPqPt7t8j4Gifs+vhACPx9aBj8knwo/UN4OPysWEz9BRRc/JWobP3ODHz/OjyM/5o0nP3R8Kz8/Wi8/GSYzP+feNj+Zgzo/MxM+P8WMQT9370Q/fzpIPydtSz/Ohk4/5YZRP/FsVD+OOFc/aelZP0V/XD/6+V4/c1lhP6+dYz/BxmU/z9RnPxHIaT/SoGs/bl9tP1AEbz/0j3A/5gJyP71dcz8foXQ/v811P1fkdj+w5Xc/l9J4P+OreT9zcno/Jyd7P+fKez+dXnw/NeN8P5xZfT+9wn0/hh9+P95wfj+rt34/z/R+PyYpfz+GVX8/vnp/P5aZfz/Msn8/FMd/PxzXfz+C438/3ex/P7bzfz+K+H8/yPt/P9b9fz8H/38/pf9/P+j/fz/9/38/AACAP+ABAACHiAg7/////wUAYAADACAABAAIAAIABAAEAAEAQez8AAsGwF0AAIBhAEGA/QALyTj//38/jv9/P2r+fz+T/H8/B/p/P8j2fz/W8n8/MO5/P9bofz/I4n8/B9x/P5PUfz9rzH8/j8N/PwC6fz+9r38/x6R/Px2Zfz/AjH8/sH9/P+xxfz92Y38/S1R/P25Efz/eM38/miJ/P6MQfz/6/X4/nep+P43Wfj/LwX4/Vqx+Py6Wfj9Tf34/xmd+P4ZPfj+UNn4/7xx+P5gCfj+P530/08t9P2avfT9Gkn0/dHR9P/FVfT+8Nn0/1RZ9Pzz2fD/y1Hw/9rJ8P0mQfD/rbHw/20h8PxskfD+p/ns/h9h7P7Sxez8wins//GF7Pxc5ez+CD3s/PeV6P0i6ej+ijno/TWJ6P0g1ej+UB3o/MNl5Px2qeT9aenk/6Ul5P8gYeT/55ng/e7R4P06BeD9zTXg/6hh4P7Ljdz/NrXc/Ond3P/k/dz8KCHc/bs92PyWWdj8vXHY/jCF2PzzmdT9AqnU/l211P0IwdT9B8nQ/lLN0Pzt0dD83NHQ/h/NzPyyycz8mcHM/di1zPxrqcj8UpnI/ZGFyPwoccj8F1nE/V49xPwBIcT///3A/VbdwPwJucD8GJHA/YtlvPxWObz8gQm8/hPVuPz+obj9TWm4/wAtuP4a8bT+lbG0/HRxtP+/KbD8beWw/oSZsP4DTaz+7f2s/UCtrP0DWaj+MgGo/MipqPzXTaT+Te2k/TSNpP2TKaD/YcGg/qBZoP9W7Zz9gYGc/SARnP4+nZj8zSmY/NuxlP5eNZT9XLmU/d85kP/VtZD/UDGQ/EqtjP7FIYz+w5WI/EIJiP9EdYj/zuGE/d1NhP1ztYD+khmA/Th9gP1u3Xz/LTl8/nuVeP9V7Xj9wEV4/bqZdP9I6XT+azlw/xmFcP1n0Wz9Rhls/rhdbP3KoWj+dOFo/LshZPydXWT+H5Vg/T3NYP38AWD8XjVc/GBlXP4KkVj9WL1Y/k7lVPzpDVT9LzFQ/x1RUP67cUz8BZFM/v+pSP+lwUj9/9lE/gntRP/L/UD/Pg1A/GgdQP9KJTz/6C08/kI1OP5QOTj8Jj00/7Q5NP0GOTD8FDUw/O4tLP+EISz/5hUo/gwJKP39+ST/u+Ug/z3RIPyTvRz/taEc/KeJGP9paRj8A00U/m0pFP6zBRD8yOEQ/L65DP6IjQz+NmEI/7wxCP8iAQT8a9EA/5WZAPyjZPz/lSj8/G7w+P8wsPj/3nD0/nQw9P757PD9c6js/dVg7PwrGOj8dMzo/rZ85P7sLOT9Hdzg/UeI3P9pMNz/jtjY/ayA2P3SJNT/98TQ/B1o0P5PBMz+gKDM/MI8yP0L1MT/YWjE/8b8wP44kMD+viC8/VewuP4FPLj8ysi0/aRQtPyd2LD9r1ys/NzgrP4uYKj9n+Ck/zFcpP7q2KD8yFSg/M3MnP7/QJj/WLSY/eYolP6fmJD9hQiQ/qZ0jP334Ij/fUiI/z6whP00GIT9bXyA/+LcfPyUQHz/iZx4/ML8dPxAWHT+BbBw/hMIbPxoYGz9DbRo/AMIZP1EWGT82ahg/sb0XP8EQFz9nYxY/o7UVP3YHFT/hWBQ/5KkTP3/6Ej+zShI/gJoRP+fpED/oOBA/hIcPP7vVDj+OIw4//nANPwq+DD+zCgw/+lYLP9+iCj9j7gk/hjkJP0mECD+szgc/rxgHP1RiBj+bqwU/g/QEPw89BD89hQM/D80CP4YUAj+hWwE/YaIAP4/R/z6nXf4+Dun8PsJz+z7G/fk+G4f4PsEP9z66l/U+Bh/0Pqil8j6eK/E+7LDvPpE17j6Quew+6DzrPpq/6T6pQeg+FcPmPt9D5T4IxOM+kUPiPnzC4D7IQN8+eL7dPow73D4GuNo+5jPZPi6v1z7fKdY++aPUPn0d0z5ultE+zA7QPpeGzj7S/cw+fXTLPpnqyT4nYMg+KNXGPp9JxT6KvcM+7DDCPsajwD4ZFr8+5oe9Pi35uz7xabo+Mtq4PvFJtz4vubU+7ie0Pi+Wsj7yA7E+OXGvPgTerT5WSqw+L7aqPpAhqT56jKc+7/alPu9gpD58yqI+lzOhPkCcnz56BJ4+RGycPqHTmj6ROpk+FqGXPjAHlj7hbJQ+KdKSPgs3kT6Hm48+nv+NPlFjjD6ixoo+kSmJPiCMhz5Q7oU+IlCEPpexgj6wEoE+3uZ+Pqmnez7DZ3g+Lyd1Pu7lcT4EpG4+c2FrPjweaD5i2mQ+6JVhPs9QXj4aC1s+zMRXPuZ9VD5rNlE+Xe5NPr+lSj6SXEc+2hJEPpfIQD7OfT0+gDI6Pq7mNj5dmjM+jU0wPkIALT59sik+QmQmPpEVIz5uxh8+23YcPtomGT5t1hU+mIUSPls0Dz664gs+t5AIPlQ+BT6U6wE+8DD9PQaK9j1x4u89MzrpPU+R4j3P59s9tT3VPQOTzj3A58c98jvBPZyPuj3D4rM9bDWtPZuHpj1V2Z89nyqZPX57kj32y4s9CxyFPYfXfD1Gdm89XRRiPdaxVD25Tkc9EOs5PeWGLD1AIh89LL0RPbJXBD214+08YBfTPHZKuDwLfZ08Mq+CPPrBTzz+JBo8Kg/JO5mnOzsufda50kZxu6ve47umjCe8gSldvOFiibygMKS87P2+vLPK2bzglvS8MbEHvZMWFb2MeyK9E+AvvR5EPb2lp0q9nQpYvf5sZb2+znK96heAvRvIhr3td429XCeUvWPWmr39hKG9JjOovdngrr0RjrW9yjq8vf7mwr2qksm9yD3QvVTo1r1Kkt29pDvkvV3k6r1yjPG93TP4vZra/r1SwAK+/BIGvkdlCb4ytwy+uggQvt1ZE76Yqha+6voZvtBKHb5HmiC+TukjvuE3J74Ahiq+ptMtvtMgMb6DbTS+tbk3vmUFO76TUD6+OptBvlrlRL7wLki++XdLvnTATr5dCFK+s09VvnOWWL6c3Fu+KiJfvhtnYr5tq2W+H+9oviwybL6UdG++VLZyvmr3db7TN3m+jXd8vpa2f751eoG+RRmDvrm3hL7QVYa+iPOHvuGQib7aLYu+cMqMvqRmjr50ApC+352RvuQ4k76B05S+tm2WvoEHmL7ioJm+1zmbvl/SnL55ap6+IwKgvl6Zob4mMKO+fcakvmBcpr7O8ae+xoapvkcbq75Qr6y+4EKuvvXVr76PaLG+rfqyvk2MtL5uHba+EK63vjA+ub7Pzbq+6ly8voLrvb6Ueb++HwfBviOUwr6fIMS+kazFvvg3x77Twsi+Ik3KvuLWy74TYM2+tejOvsVw0L5C+NG+LX/TvoMF1b5Di9a+bRDYvv+U2b75GNu+WZzcvh0f3r5God++0yLhvsGj4r4QJOS+vqPlvswi5744oei+AB/qviSc676iGO2+epTuvqsP8L4zivG+EgTzvkZ99L7P9fW+qm33vtnk+L5YW/q+KNH7vkdG/b61uv6+OBcAv7vQAL/kiQG/skICvyX7Ar87swO/9moEv1MiBb9T2QW/9Y8GvzhGB78d/Ae/orEIv8dmCb+MGwq/8M8Kv/ODC7+TNwy/0eoMv6ydDb8kUA6/OAIPv+izD78yZRC/GBYRv5fGEb+wdhK/YyYTv67VE7+RhBS/DTMVvx/hFb/Ijha/CDwXv93oF79IlRi/SEEZv9zsGb8EmBq/wEIbvw/tG7/wlhy/Y0Adv2jpHb/+kR6/JTofv9zhH78jiSC/+i8hv1/WIb9SfCK/1CEjv+PGI79/ayS/pw8lv1yzJb+dVia/aPkmv7+bJ7+gPSi/C98ov/9/Kb99ICq/g8AqvxFgK78n/yu/xJ0sv+g7Lb+S2S2/w3Yuv3kTL7+0ry+/c0swv7fmML9/gTG/yxsyv5m1Mr/qTjO/veczvxKANL/oFzW/P681vxZGNr9u3Da/RXI3v5wHOL9xnDi/xTA5v5bEOb/mVzq/suo6v/x8O7/CDjy/A6A8v8EwPb/6wD2/rVA+v9vfPr+Dbj+/pfw/v0CKQL9TF0G/4KNBv+QvQr9gu0K/U0ZDv77QQ7+eWkS/9uNEv8JsRb8F9UW/vHxGv+gDR7+Jike/nRBIvyWWSL8gG0m/jp9Jv28jSr/Bpkq/hilLv7yrS79jLUy/eq5MvwIvTb/6rk2/Yi5OvzmtTr9+K0+/M6lPv1UmUL/molC/5B5Rv1CaUb8oFVK/bY9Svx4JU787glO/w/pTv7dyVL8W6lS/32BVvxLXVb+wTFa/t8FWvyc2V78Aqle/Qh1Yv+yPWL/+AVm/eHNZv1nkWb+iVFq/UcRav2YzW7/ioVu/ww9cvwp9XL+36Vy/yFVdvz7BXb8YLF6/V5Zev/n/Xr//aF+/aNFfvzM5YL9ioGC/8wZhv+VsYb860mG/8DZivwibYr+A/mK/WWFjv5LDY78sJWS/JYZkv37mZL83RmW/TqVlv8UDZr+aYWa/zb5mv14bZ79Nd2e/mtJnv0QtaL9Lh2i/ruBov285ab+LkWm/BOlpv9k/ar8Jlmq/lOtqv3tAa7+8lGu/Wehrv087bL+gjWy/S99sv08wbb+tgG2/ZdBtv3Ufbr/fbW6/obtuv7sIb78uVW+/+KBvvxvsb7+VNnC/Z4Bwv5DJcL8PEnG/5llxvxOhcb+X53G/cS1yv6Bycr8mt3K/AftyvzI+c7+4gHO/lMJzv8QDdL9JRHS/IoR0v1DDdL/SAXW/qD91v9J8db9QuXW/IfV1v0Uwdr+9ana/iKR2v6bddr8WFne/2U13v++Ed79Xu3e/EfF3vx0meL96Wni/Ko54vyvBeL9983i/ISV5vxZWeb9chnm/8rV5v9rkeb8SE3q/mkB6v3Nter+dmXq/FsV6v9/ver/4GXu/YUN7vxpse78ilHu/ert7vyDie78XCHy/XC18v/BRfL/TdXy/BZl8v4a7fL9V3Xy/c/58v98efb+aPn2/o119v/p7fb+fmX2/krZ9v9PSfb9i7n2/Pwl+v2kjfr/hPH6/p1V+v7ptfr8bhX6/yZt+v8Sxfr8Nx36/ott+v4Xvfr+1An+/MhV/v/wmf78TOH+/dkh/vydYf78kZ3+/bnV/vwWDf7/oj3+/GZx/v5Wnf79fsn+/dLx/v9fFf7+Fzn+/gdZ/v8jdf79d5H+/Pep/v2rvf7/j83+/qfd/v7v6f78Z/X+/xP5/v7v/f7/6/38/Of5/P6n5fz9L8n8/Huh/PyPbfz9Zy38/wbh/P1ujfz8oi38/J3B/P1pSfz+/MX8/WA5/PyXofj8mv34/XJN+P8hkfj9pM34/Qf99P0/IfT+Wjn0/FFJ9P8sSfT+80Hw/54t8P01EfD/v+Xs/zax7P+lcez9DCns/3bR6P7Zcej/RAXo/LqR5P85DeT+y4Hg/3Hp4P0wSeD8Ep3c/BDl3P0/Idj/kVHY/xt51P/ZldT916nQ/RGx0P2Xrcz/aZ3M/o+FyP8JYcj85zXE/CT9xPzSucD+7GnA/oIRvP+Trbj+KUG4/k7JtPwESbT/Vbmw/EclrP7cgaz/JdWo/SchpPzkYaT+bZWg/b7BnP7r4Zj98PmY/uIFlP2/CZD+kAGQ/WjxjP5F1Yj9MrGE/juBgP1kSYD+uQV8/kW5ePwOZXT8IwVw/oOZbP88JWz+YKlo/+0hZP/1kWD+fflc/5ZVWP9CqVT9jvVQ/oc1TP4zbUj8n51E/dfBQP3n3Tz80/E4/q/5NP9/+TD/U/Es/jPhKPwryST9S6Ug/Zd5HP0fRRj/7wUU/hLBEP+WcQz8gh0I/Om9BPzRVQD8TOT8/2Bo+P4j6PD8m2Ds/tLM6PzaNOT+vZDg/Ijo3P5MNNj8F3zQ/fK4zP/l7Mj+CRzE/GREwP8LYLj9/ni0/VmIsP0gkKz9a5Ck/kKIoP+teJz9xGSY/JdIkPwmJIz8jPiI/dfEgPwSjHz/SUh4/5AAdPz2tGz/hVxo/0wAZPxmoFz+0TRY/qvEUP/2TEz+yNBI/zNMQP1BxDz9CDQ4/pKcMP3xACz/N1wk/mm0IP+kBBz+9lAU/GSYEPwO2Aj9+RAE/HKP/Pm66/D76zvk+yuD2PuTv8z5R/PA+GgbuPkcN6z7gEeg+7RPlPncT4j6HEN8+JAvcPlgD2T4q+dU+pOzSPs3dzz6vzMw+UrnJPr+jxj7+i8M+GHLAPhZWvT4AOLo+4Be3Pr31sz6h0bA+lautPqKDqj7PWac+Jy6kPrIAoT550Z0+haCaPt9tlz6POZQ+oAORPhrMjT4Fk4o+a1iHPlYchD7N3oA+tj97PhC/dD67O24+ybVnPk0tYT5Zolo+/xRUPlGFTT5j80Y+Rl9APg3JOT7KMDM+kJYsPnL6JT6CXB8+0rwYPnYbEj5/eAs+AdQEPh1c/D1yDe89KbzhPWZo1D1OEsc9CLq5PbhfrD2EA589kqWRPQdGhD0Sym09egVTPZE+OD2kdR09/KoCPcq9zzxWI5o8YQ5JPMWnuzs9ela6CUbxuxLdY7xQiqe8QSTdvONdCb0jKCS9lvA+vfK2Wb3qenS9Gp6HvUL9lL3IWqK9hravvVcQvb0WaMq9m73XvcMQ5b1pYfK9Za//vUp9Br5oIQ2++sMTvu1kGr4uBCG+rKEnvlM9Lr4Q1zS+0m47voYEQr4ZmEi+eSlPvpS4Vb5WRVy+rs9ivolXab7W3G++gF92vnjffL5UroG+geuEvjgniL5yYYu+JJqOvkXRkb7NBpW+szqYvu5sm750nZ6+PcyhvkD5pL5zJKi+z02rvkl1rr7amrG+eL60vhvgt766/7q+Sx2+vsc4wb4lUsS+W2nHvmF+yr4wkc2+vKHQvgCw077xu9a+h8XZvrrM3L6B0d++09PivqnT5b760Oi+vcvrvurD7r54ufG+YKz0vpqc974civq+33T9vm0uAL8DoQG/LRIDv+aBBL8s8AW/+lwHv0zICL8eMgq/bJoLvzIBDb9sZg6/F8oPvy0sEb+sjBK/kOsTv9VIFb92pBa/cf4Xv8BWGb9irRq/UQIcv4pVHb8Jpx6/y/Yfv8xEIb8JkSK/fNsjvyQkJb/9aia/ArAnvzDzKL+ENCq/+nMrv4+xLL8/7S2/Bycvv+NeML/QlDG/ysgyv876M7/aKjW/6Fg2v/eEN78Crzi/B9c5vwP9Or/xIDy/z0I9v5piPr9PgD+/6ZtAv2i1Qb/GzEK/AeJDvxf1RL8DBka/xBRHv1YhSL+2K0m/4TNKv9Q5S7+NPUy/CT9Nv0Q+Tr89O0+/8DVQv1ouUb95JFK/ShhTv8oJVL/3+FS/zuVVv03QVr9wuFe/N55Yv5yBWb+gYlq/PkFbv3UdXL9B91y/os5dv5SjXr8Udl+/IkZgv7oTYb/Z3mG/f6div6ltY79UMWS/fvJkvyaxZb9JbWa/5SZnv/jdZ7+Akmi/e0Rpv+jzab/DoGq/DEtrv8Dya7/el2y/ZDptv1Dabb+gd26/UxJvv2aqb7/ZP3C/qdJwv9Vicb9b8HG/Ontyv3EDc7/9iHO/3gt0vxGMdL+WCXW/a4R1v4/8db8Acna/veR2v8ZUd78Ywne/six4v5OUeL+7+Xi/KFx5v9m7eb/NGHq/AnN6v3nKer8vH3u/JHF7v1jAe7/JDHy/dlZ8v1+dfL+C4Xy/4CJ9v3dhfb9HnX2/T9Z9v44Mfr8EQH6/sHB+v5Kefr+pyX6/9fF+v3UXf78pOn+/EFp/vyt3f794kX+/+Kh/v6q9f7+Pz3+/pd5/v+3qf79m9H+/Eft/v+3+f7/q/38/5fh/P6bmfz8tyX8/fKB/P5Vsfz95LX8/LON+P7GNfj8LLX4/P8F9P1JKfT9IyHw/KDt8P/eiez+9/3o/gFF6P0iYeT8e1Hg/CQV4PxMrdz9GRnY/rFZ1P05cdD84V3M/dkdyPxMtcT8cCHA/nthuP6WebT9AWmw/fgtrP2uyaT8ZT2g/luFmP/JpZT8+6GM/i1xiP+rGYD9tJ18/Jn5dPyjLWz+FDlo/U0hYP6N4Vj+Ln1Q/IL1SP3bRUD+j3E4/vd5MP9vXSj8TyEg/fK9GPy6ORD9BZEI/zjFAP+z2PT+0szs/Qmg5P60UNz8QuTQ/hlUyPynqLz8Vdy0/ZfwqPzV6KD+h8CU/xl8jP8DHID+sKB4/qYIbP9TVGD9KIhY/KmgTP5OnED+k4A0/exMLPzlACD/9ZgU/54cCPy1G/z5bcfk+l5HzPiSn7T5Fsuc+PLPhPkyq2z66l9U+yXvPPr5WyT7fKMM+cPK8Preztj77bLA+gR6qPpLIoz5za50+bAeXPsWckD7HK4o+ubSDPsdvej4ha20+EVxgPilDUz79IEY+IPY4PibDKz6kiB4+LUcRPlf/Az5uY+09wr3SPdoOuD3eV509+5mCPbysTz1lHBo9mQrJPCqnOzzBeNa6LURxvFfX47xMgSe9lA9dvRVKib1aBqS9bbu+vSJo2b1OC/S941EHvi+YFL731yG+pRAvvqZBPL5kakm+TYpWvs2gY75QrXC+Ra99vg1Thb6eyIu+DTiSvhKhmL5mA5++v16lvtiyq75p/7G+K0S4vtiAvr4qtcS+2+DKvqUD0b5FHde+dS3dvvEz4752MOm+wCLvvo0K9b6b5/q+01wAvzhAA7/bHQa/m/UIv1rHC7/3kg6/VFgRv1AXFL/Nzxa/rIEZv9AsHL8a0R6/bW4hv6sEJL+3kya/dBspv8ebK7+TFC6/u4UwvybvMr+3UDW/Vao3v+P7Ob9KRTy/boY+vze/QL+L70K/UxdFv3U2R7/aTEm/a1pLvxBfTb+zWk+/Pk1Rv5o2U7+zFlW/cu1Wv8W6WL+Vflq/0Dhcv2LpXb84kF+/QC1hv2fAYr+cSWS/zshlv+s9Z7/jqGi/pwlqvydga79UrGy/H+5tv3olb79YUnC/q3Rxv2eMcr9/mXO/55t0v5WTdb9+gHa/lmJ3v9Q5eL8vBnm/nsd5vxd+er+UKXu/Dcp7v3pffL/V6Xy/GGl9vz7dfb9ARn6/HKR+v8z2fr9NPn+/nHp/v7arf7+Z0X+/Q+x/v7T7f7+m/38/lON/P5yafz/MJH8/OIJ+P/2yfT8/t3w/Ko97P/M6ej/Uung/EQ93P/Y3dT/VNXM/CAlxP/Gxbj/5MGw/kIZpPy+zZj9Tt2M/hJNgP05IXT9F1lk/Az5WPyuAUj9lnU4/XpZKP8xrRj9qHkI/+a49P0AeOT8NbTQ/MpwvP4esKj/rniU/P3QgP20tGz9hyxU/DU8QP2i5Cj9rCwU/Loz+Pt3U8j7x8uY+f+jaPqa3zj6IYsI+Tuu1PipUqT5Rn5w+/c6PPm3lgj7OyWs+Yp9RPjBQNz7T4Bw+8VUCPmJozz18AJo9JPtIPRukuzzzd1a7ZD3xvLvAY71nXae9FL3cvQP7CL5zfyO+NOc9vqQtWL4mTnK+EiKGvokFk740z5++1XysvjMMub4ae8W+W8fRvs3u3b5Q7+m+x8b1vpC5AL8meQa/JCEMv42wEb9mJhe/uoEcv5jBIb8V5Sa/Susrv1bTML9bnDW/g0U6v/3NPr/8NEO/vHlHv32bS7+EmU+/H3NTv6EnV79jtlq/xh5evzBgYb8PemS/2Gtnvwc1ar8f1Wy/qUtvvzeYcb9iunO/ybF1vxZ+d7/2Hnm/IZR6v1Xde79Z+ny/+up9vw6vfr90Rn+/D7F/v87uf7//////////////////////AAAAAAAAAAApACkAKQBSAFIAewCkAMgA3gBB2rUBC5gBKQApACkAKQB7AHsAewCkAKQA8AAKARsBJwEpACkAKQApACkAKQApACkAewB7AHsAewDwAPAA8AAKAQoBMQE+AUgBUAF7AHsAewB7AHsAewB7AHsA8ADwAPAA8AAxATEBMQE+AT4BVwFfAWYBbAHwAPAA8ADwAPAA8ADwAPAAMQExATEBMQFXAVcBVwFfAV8BcgF4AX4BgwEAQYC3AQu4BCgHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHKA8XHB8iJCYnKSorLC0uLy8xMjM0NTY3Nzk6Ozw9Pj8/QUJDREVGR0coFCEpMDU5PUBCRUdJS0xOUFJVV1lbXF5gYmVnaWtsbnBydXd5e3x+gCgXJzM8Q0lPU1dbXmFkZmlrb3N2eXx+gYOHi46RlJaZm5+jpqmsrrGzIxwxQU5ZY2tyeH6EiI2RlZmfpauwtLm9wMfN09jc4eXo7/X7FSE6T2FwfYmUnaautr3Dyc/Z4+vz+xEjP1Zqe4uYpbG7xc7W3ubt+hkfN0tbaXWAipKaoaiutLm+yNDX3uXr8PX/ECRBWW6AkJ+tucTP2eLq8voLKUpngJesv9Hh8f8JK09uiqO6z+P2DCdHY3uQpLbG1uTx/QksUXGOqMDW6/8HMVp/oL/c9wYzX4aqy+oHL1d7m7jU7QY0YYmu0PAFOWqXwOcFO2+eyvMFN2eTu+AFPHGhzvgEQXqv4ARDf7bqAAAAAAAAAADg4ODg4ODg4KCgoKC5ubmysqiGPSXg4ODg4ODg4PDw8PDPz8/GxreQQiigoKCgoKCgoLm5ubnBwcG3t6yKQCbw8PDw8PDw8M/Pz8/MzMzBwbSPQii5ubm5ubm5ucHBwcHBwcG3t6yKQSfPz8/Pz8/Pz8zMzMzJycm8vLCNQijBwcHBwcHBwcHBwcHCwsK4uK2LQSfMzMzMzMzMzMnJycnGxsa7u6+MQigAQcK7AQu5KWAAwAAgAYABIACAAOAAQAGgAUAAoAAAAWABwAEIAGgAyAAoAYgBKACIAOgASAGoAUgAqAAIAWgByAEQAHAA0AAwAZABMACQAPAAUAGwAVAAsAAQAXAB0AEYAHgA2AA4AZgBOACYAPgAWAG4AVgAuAAYAXgB2AEEAGQAxAAkAYQBJACEAOQARAGkAUQApAAEAWQBxAEMAGwAzAAsAYwBLACMAOwATAGsAUwArAAMAWwBzAEUAHQA1AA0AZQBNACUAPQAVAG0AVQAtAAUAXQB1AEcAHwA3AA8AZwBPACcAPwAXAG8AVwAvAAcAXwB3AEBAGEAwQAhAYEBIQCBAOEAQQGhAUEAoQABAWEBwQEJAGkAyQApAYkBKQCJAOkASQGpAUkAqQAJAWkByQERAHEA0QAxAZEBMQCRAPEAUQGxAVEAsQARAXEB0QEZAHkA2QA5AZkBOQCZAPkAWQG5AVkAuQAZAXkB2QEFAGUAxQAlAYUBJQCFAOUARQGlAUUApQAFAWUBxQENAG0AzQAtAY0BLQCNAO0ATQGtAU0ArQANAW0BzQEVAHUA1QA1AZUBNQCVAPUAVQG1AVUAtQAVAXUB1QEdAH0A3QA9AZ0BPQCdAP0AXQG9AV0AvQAdAX0B3QECAGIAwgAiAYIBIgCCAOIAQgGiAUIAogACAWIBwgEKAGoAygAqAYoBKgCKAOoASgGqAUoAqgAKAWoBygESAHIA0gAyAZIBMgCSAPIAUgGyAVIAsgASAXIB0gEaAHoA2gA6AZoBOgCaAPoAWgG6AVoAugAaAXoB2gEGAGYAxgAmAYYBJgCGAOYARgGmAUYApgAGAWYBxgEOAG4AzgAuAY4BLgCOAO4ATgGuAU4ArgAOAW4BzgEWAHYA1gA2AZYBNgCWAPYAVgG2AVYAtgAWAXYB1gEeAH4A3gA+AZ4BPgCeAP4AXgG+AV4AvgAeAX4B3gEDAGMAwwAjAYMBIwCDAOMAQwGjAUMAowADAWMBwwELAGsAywArAYsBKwCLAOsASwGrAUsAqwALAWsBywETAHMA0wAzAZMBMwCTAPMAUwGzAVMAswATAXMB0wEbAHsA2wA7AZsBOwCbAPsAWwG7AVsAuwAbAXsB2wEHAGcA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aAAQACgAQABYAHAABAAcADQATABkAAwAJAA8AFQAbAAUACwARABcAHQAAQAZADEASQBhAAkAIQA5AFEAaQARACkAQQBZAHEABQAdADUATQBlAA0AJQA9AFUAbQAVAC0ARQBdAHUAAgAaADIASgBiAAoAIgA6AFIAagASACoAQgBaAHIABgAeADYATgBmAA4AJgA+AFYAbgAWAC4ARgBeAHYAAwAbADMASwBjAAsAIwA7AFMAawATACsAQwBbAHMABwAfADcATwBnAA8AJwA/AFcAbwAXAC8ARwBfAHcAeAAAAIiICDwCAAAABQAYAAMACAACAAQABAABAEG85wELBqByAACAYQBB0ucBC40BDAAYACQAMAAEABAAHAAoADQACAAUACAALAA4AAEADQAZACUAMQAFABEAHQApADUACQAVACEALQA5AAIADgAaACYAMgAGABIAHgAqADYACgAWACIALgA6AAMADwAbACcAMwAHABMAHwArADcACwAXACMALwA7ADwAAACJiIg8AwAAAAUADAADAAQABAABAEH06AELLNBzAACAYQAAAAAAAAAAnT4AQF4+AMAEPgCA7T4AQIk+AAAAAADATD8AAM09AEGx6QELowH/AP8A/wD/AP8A/gEAAf8A/gD9AgAB/wD+AP0DAAH/lYsAADeYAAD/pQAABLUAAGfFAABF1wAAweoAAP//AAAAAM5AAADIQAAAuEAAAKpAAACiQAAAmkAAAJBAAACMQAAAnEAAAJZAAACSQAAAjkAAAJxAAACUQAAAikAAAJBAAACMQAAAlEAAAJhAAACOQAAAcEAAAHBAAABwQAAAcEAAAHBAAEHg6gEL8gJIf0GBQoBBgECAPoBAgECAXE5cT1xOWk90KXMociiEGoQakRGhDLAKsQsYszCKNoc2hDWGOIU3hDeEPXJGYEpYS1hXSllCW0NkO2wyeCh6JWErTjJTTlRRWEtWSldHWkldSl1KbShyJHUidSKPEZESkhOiDKUKsge9Br4IsQkXsjZzP2ZCYkVjSllHW0lbTllWUFxCXUBmO2c8aDx1NHssiiOFH2EmTS09Wl08aSprKW4tdCZxJnAmfBqEG4gTjBSbDp8QnhKqDbEKuwjABq8JnwoVsjtuR1ZLVVRTW0JYSVdIXEtiSGk6azZzNHI3cDiBM4QoliGMHWIjTSoqeWBCbCtv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","base64")),
          WebMOpusEncoderWasmPath: tob(Buffer("AGFzbQEAAAABngZTYAF/AX5gA39/fwF/YAF/AX9gBH9/f38AYAF/AGACf38Bf2ADf39/AGAFf39/f38AYAJ/fwBgAn9+AX9gBn9/f39/fwBgA39+fgBgBn9/f39/fwF/YAR/f39/AX9gBX9/f39/AX9gAABgB39/f39/f38AYAF8AXxgAn9/AX5gAAF/YAh/f39/f39/fwBgC39/f39/f39/f39/AGAHf39/f39/fwF/YAN/fn4Bf2AEf39/fwF9YAl/f39/f39/f38AYAp/f39/f39/f39/AGAPf39/f39/f39/f39/f39/AGAEf399fwBgBH9+fn8AYAp/f39/f39/f39/AX9gC39/f39/f39/f39/AX9gBn98f39/fwF/YAJ+fwF/YAN/f38BfmADf35/AX5gAn5+AX5gAnx/AXxgAnx8AXxgDH9/f39/f39/f39/fwBgEX9/f39/f39/f39/f39/f39/AGAWf39/f39/f39/f39/f39/f39/f39/fwBgGn9/f39/f39/f39/f39/f39/f39/f39/f39/AGAMf39/f399fX9/f39/AGAEf39/fQBgBX9/fn5+AGADf399AGAFf399f38AYAl/f319f39/f38AYAJ/fgBgA399fwBgCX9/f39/f39/fwF/YAx/f39/f39/f39/f38Bf2ASf39/f39/f39/f39/f39/f39/AX9gD39/f39/f39/f39/f399fwF/YAp/f39/f39/f31/AX9gC39/f39/f39/fX9/AX9gCX9/f39/f399fwF/YAd/f39/f399AX9gCX9/f39/f31/fwF/YAt/f39/f399fX9/fwF/YAN/fn8Bf2AEf35/fgF/YAR/fn5/AX9gA39+fQF/YAN+f38Bf2ABfQF/YAJ9fwF/YAJ8fwF/YAJ/fgF+YAJ+fwF+YAN+f34BfmACfn0BfmADf39/AX1gCX9/f39/f39/fwF9YBN/f39/f39/f39/f39/f39/f39/AX1gBn9/f399fwF9YAZ/f31/f38BfWAEfX1/fwF9YAJ/fwF8YAN/f38BfGACfn4BfGADfHx/AXwCag8BYQFhAAMBYQFiAA8BYQFjAAIBYQFkAA0BYQFlAAEBYQFmAA0BYQFnAAEBYQFoAAEBYQFpAAIBYQFqAA4BYQFrAAEBYQFsAAIBYQFtAAgBYQZtZW1vcnkC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NgI8DAULIAMgAygCDCIBQQRqNgIMIAEoAgAiAUH0A0wEQEF/IQIgAUF/Rw0GCyAAIAEgACgCBEGg7w9sIgAgASAASBs2AigMBAsgAyADKAIMIgFBBGo2AgwgACABKAIANgIsDAMLIAMgAygCDCIBQQRqNgIMIAAgASgCADYCNAwCCyADIAMoAgwiAUEEajYCDEF/IQIgASgCACIBQeQASw0CIAAgATYCOAwBCyADIAMoAgwiAUEEajYCDEF/IQIgASgCACIBQQpLDQEgACABNgIYC0EAIQILIANBEGokACACC4YEAgR/An4jAEEQayIFJAACQCAARQ0AIAAgASAAIAAoAgAoAgQRAAAgACgCACgCEBELAEEBIQMCQCABQoACVA0AQQIhAyABQoCABFQNAEEDIQMgAUKAgIAIVA0AQQQhAyABQoCAgIAQVA0AQQUhAyABQoCAgICAIFQNAEEGIQMgAUKAgICAgIDAAFQNAEEHQQggAUKAgICAgICAgAFUGyIDQX9qQQdLDQELIANBAWqtIQhCASEHAkADQAJAIAUgASADIAena0EDdK2HPAANIAAgBUENakEBIAAoAgAoAgARAQAiBCAGIARBAEgbIQYgBEF/TA0AIAggB0IBfCIHUg0BDAILC0EAIQQgBg0BCyAFAn9BASACQoACVA0AGkECIAJCgIAEVA0AGkEDIAJCgICACFQNABpBBCACQoCAgIAQVA0AGkEFIAJCgICAgIAgVA0AGkEGIAJCgICAgICAwABUDQAaQQdBCCACQoCAgICAgICAAVQbCyIDQYABcjoADkEAIQQgACAFQQ5qQQEgACgCACgCABEBAEEASA0AIANBAWqtIQFCASEHAkADQCAFIAIgAyAHp2tBA3SthzwADyAAIAVBD2pBASAAKAIAKAIAEQEAIgQgBiAEQQBIGyEGIARBf0wNASAHQgF8IgcgAVINAAtBACEGCyAGRSEECyAFQRBqJAAgBAvfAQEBfkIBIQICfkIBIABCgAJUDQAaQgIgAEKAgARUDQAaQgMgAEKAgIAIVA0AGkIEIABCgICAgBBUDQAaQgUgAEKAgICAgCBUDQAaQgYgAEKAgICAgIDAAFQNABpCB0IIIABCgICAgICAgIABVBsLIQACQCABQv8AVA0AQgIhAiABQv//AFQNAEIDIQIgAUL///8AVA0AQgQhAiABQv////8AVA0AQgUhAiABQv//////AFQNAEIGIQIgAUL///////8AVA0AQgdCCCABQv////////8AVBshAgsgACACfAv6AwIEfwJ+IwBBEGsiBiQAAkAgAEUNACAAIAEgACAAKAIAKAIEEQAAIAAoAgAoAhARCwBBASEDAkAgAUKAAlQNAEECIQMgAUKAgARUDQBBAyEDIAFCgICACFQNAEEEIQMgAUKAgICAEFQNAEEFIQMgAUKAgICAgCBUDQBBBiEDIAFCgICAgICAwABUDQBBB0EIIAFCgICAgICAgIABVBsiA0F/akEHSw0BCyADQQFqrSEIQgEhBwJAA0ACQCAGIAEgAyAHp2tBA3SthzwADiAAIAZBDmpBASAAKAIAKAIAEQEAIgQgBSAEQQBIGyEFIARBf0wNACAIIAdCAXwiB1INAQwCCwtBACEEIAUNAQtBfyEFAkBCAQJ/QQEgAkL/AFQNABpBAiACQv//AFQNABpBAyACQv///wBUDQAaQQQgAkL/////AFQNABpBBSACQv//////AFQNABpBBiACQv///////wBUDQAaQQdBCCACQv////////8AVBsLIgNBB2ythiIBQn58IAJUDQAgASAChCEBIANBAWqtIQJCASEHA0AgBiABIAMgB6drQQN0rYc8AA8gACAGQQ9qQQEgACgCACgCABEBACIEIAUgBEEASBshBSAEQX9MDQEgB0IBfCIHIAJSDQALQQAhBQsgBUUhBAsgBkEQaiQAIAQLZQECfwJAQRggAGciAWsiAkUNACAAQf8ATQRAIAAgAUFoanQgAEE4IAFrdnIhAAwBCyAAIAFBCGp0IAAgAnZyIQALIABB/wBxIgAgAUEHdGsgAEGAASAAa2xBswFsQRB2akGAH2oLMAECfyAAQQEgABshAANAAkAgABApIgENAEH83gIoAgAiAkUNACACEQ8ADAELCyABCxsAIACQIgCLQwAAAE9dBEAgAKgPC0GAgICAeAt4ACABRQRAQgAPCwJ+QgIgAEKAAlQNABpCAyAAQoCABFQNABpCBCAAQoCAgAhUDQAaQgUgAEKAgICAEFQNABpCBiAAQoCAgICAIFQNABpCByAAQoCAgICAgMAAVA0AGkIIQgkgAEKAgICAgICAgAFUGwsgARAirXwLFwAgAC0AAEEgcUUEQCABIAIgABDq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CxgBAX8gABApIgEEQCABQQAgABARGgsgAQtJAQJ/IAAoAgQiBUEIdSEGIAAoAgAiACABIAVBAXEEfyACKAIAIAZqKAIABSAGCyACaiADQQIgBUECcRsgBCAAKAIAKAIYEQcACxYAIABFBEBBAA8LQfDeAiAANgIAQX8LmwQCBH8CfiMAQRBrIgYkAAJAIANQIABFIAJFcnINACAAIAEgACAAKAIAKAIEEQAAIAAoAgAoAhARCwBBASEFAkAgAUKAAlQNAEECIQUgAUKAgARUDQBBAyEFIAFCgICACFQNAEEEIQUgAUKAgICAEFQNAEEFIQUgAUKAgICAgCBUDQBBBiEFIAFCgICAgICAwABUDQBBB0EIIAFCgICAgICAgIABVBsiBUF/akEHSw0BCyAFQQFqrSEJQgEhCAJAA0ACQCAGIAEgBSAIp2tBA3SthzwADiAAIAZBDmpBASAAKAIAKAIAEQEAIgQgByAEQQBIGyEHIARBf0wNACAJIAhCAXwiCFINAQwCCwtBACEEIAcNAQtBACEEQgECf0EBIANC/wBUDQAaQQIgA0L//wBUDQAaQQMgA0L///8AVA0AGkEEIANC/////wBUDQAaQQUgA0L//////wBUDQAaQQYgA0L///////8AVA0AGkEHQQggA0L/////////AFQbCyIFQQdsrYYiAUJ+fCADVA0AIAEgA4QhASAFQQFqrSEJQgEhCAJAA0ACQCAGIAEgBSAIp2tBA3SthzwADyAAIAZBD2pBASAAKAIAKAIAEQEAIgQgByAEQQBIGyEHIARBf0wNACAJIAhCAXwiCFINAQwCCwtBACEEIAcNAQsgACACIAOnIAAoAgAoAgARAQBFIQQLIAZBEGokACAEC/QDAgV/An4jAEEQayIEJAACQCAARQ0AIAAgASAAIAAoAgAoAgQRAAAgACgCACgCEBELAEEBIQUCQCABQoACVA0AQQIhBSABQoCABFQNAEEDIQUgAUKAgIAIVA0AQQQhBSABQoCAgIAQVA0AQQUhBSABQoCAgICAIFQNAEEGIQUgAUKAgICAgIDAAFQNAEEHQQggAUKAgICAgICAgAFUGyIFQX9qQQdLDQELIAVBAWqtIQlCASEIAkADQAJAIAQgASAFIAina0EDdK2HPAANIAAgBEENakEBIAAoAgAoAgARAQAiAyAGIANBAEgb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CyAAQSAgDCAGIAlrIgogCCAIIApIGyIOaiIGIAsgCyAGSBsiASAGIAcQHSAAIA8gDBAaIABBMCABIAYgB0GAgARzEB0gAEEwIA4gCkEAEB0gACAJIAoQGiAAQSAgASAGIAdBgMAAcxAdDAELC0EAIQwMAQtBfyEMCyAFQdAAaiQAIAwLaQECfwJAIAAoAhQgACgCHE0NACAAQQBBACAAKAIkEQEAGiAAKAIUDQBBfw8LIAAoAgQiASAAKAIIIgJJBEAgACABIAJrrEEBIAAoAigRIwAaCyAAQQA2AhwgAEIANwMQIABCADcCBEEAC54FAgR/Bn4jAEEQayIDJAACQCAARQ0AAn5CASABQn98IgZC/wBUDQAaQgIgBkL//wBUDQAaQgMgBkL///8AVA0AGkIEIAZC/////wBUDQAaQgUgBkL//////wBUDQAaQgYgBkL///////8AVA0AGkIHQgggBkL/////////AFQbCyEHAn5CAiAGIAd9IgZC/wBUDQAaQgMgBkL//wBUDQAaQgQgBkL///8AVA0AGkIFIAZC/////wBUDQAaQgYgBkL//////wBUDQAaQgcgBkL///////8AVA0AGkIIQgkgBkL/////////AFQbCyAGfCABUg0AIAAgACgCACgCBBEAACIJQgBTDQAgAELsASAAIAAoAgAoAgQRAAAgACgCACgCEBELACADQewBOgAOQQEhAiAAIANBDmpBASAAKAIAKAIAEQEAQQBIDQACQCAGQv8AVA0AQQIhAiAGQv//AFQNAEEDIQIgBkL///8AVA0AQQQhAiAGQv////8AVA0AQQUhAiAGQv//////AFQNAEEGIQIgBkL///////8AVA0AQQdBCCAGQv////////8AVBshAgtCASACQQdsrYYiB0J+fCAGVA0AIAYgB4QhCiACQQFqrSELQgEhBwJAA0ACQCADIAogAiAHp2tBA3SthzwADyAAIANBD2pBASAAKAIAKAIAEQEAIgQgBSAEQQBIGyEFIARBf0wNACALIAdCAXwiB1INAQwCCwsgBQ0BC0EAIQIgA0EAOgANAkAgBqciBEEATA0AA0AgACADQQ1qQQEgACgCACgCABEBAEUEQCACQQFqIgIgBEgNAQwCCwsMAQsgAUIAIAEgACAAKAIAKAIEEQAAIgEgCX1RG0IAIAFCf1UbIQgL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AkACQAJAAkACQAJAAkAgAUEBaw4JAQIJAwQFBgkHAAsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgACACQSARCAALDwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC0IBA38gACgCACwAABA6BEADQCAAKAIAIgIsAAAhAyAAIAJBAWo2AgAgAyABQQpsakFQaiEBIAIsAAEQOg0ACwsgAQsDAAELdgEBfyAABEAgACgCTEF/TARAIAAQag8LIAAQag8LQaDeAigCAARAQaDeAigCABDBASEBC0Gs3gIoAgAiAARAA0AgACgCTEEATgR/QQEFQQALGiAAKAIUIAAoAhxLBEAgABBqIAFyIQELIAAoAjgiAA0ACwsgAQsmAQF/IwBBEGsiBCQAIAQgAzYCDCAAIAEgAiADEJcDIARBEGokAAsoAQF/AkAgAUUNACAAKAIEDQAgACABEI8DIgA2AgQgAEEARyECCyACC2UAIAAQKkEEdEGA/gNxIAAQKkEEdkH/AXFyQRB0IAAQKkEEdEGA/gNxciAAECpBBHZB/wFxcq1CEIYgABAqQQR0QYD+A3GthCAAECpBBHZB/wFxrYRCCIYgABAqQQR2Qf8Bca2EC9wTAgR/C34jAEEQayIDJAACQCAARSABRXINACACRSABEK4CIgRFcg0AIAIpAygiB1ANAEJ/IAEpAzggB4AgAikDIH0iByAHQv//AVYbIhBC//8BVg0AAn8CQCABKAIIDQAgASkDQEIAUg0AIAEpAxhQIQULIAULBEAgAEKjASAAIAAoAgAoAgQRAAAgACgCACgCEBELACADQaMBOgALQQEhAiAAIANBC2pBASAAKAIAKAIAEQEAQQBIDQECQCABKQMoQiCGQoCAgIBAfUIghyIIQv8AVA0AQQIhAiAIQv//AFQNAEEDIQIgCEL///8AVA0AQQQhAiAIQv////8AVA0AQQVBCCAIQv//////AFQbIQILQgEgAkEHbK2GIgdCfnwgCFQNASAHIAiEIQkgAkEBaq0hCkIBIQcCQANAAkAgAyAJIAIgB6drQQN0rYc8AAwgACADQQxqQQEgACgCACgCABEBACIFIAQgBUEASBshBCAFQX9MDQAgCiAHQgF8IgdSDQEMAgsLIAQNAgtCAQJ/QQEgASkDMCIHQv8AVA0AGkECIAdC//8AVA0AGkEDIAdC////AFQNABpBBCAHQv////8AVA0AGkEFIAdC//////8AVA0AGkEGIAdC////////AFQNABpBB0EIIAdC/////////wBUGwsiAkEHbK2GIglCfnwgB1QNASAHIAmEIQkgAkEBaq0hCkIBIQcCQANAAkAgAyAJIAIgB6drQQN0rYc8AA0gACADQQ1qQQEgACgCACgCABEBACIFIAQgBUEASBshBCAFQX9MDQAgCiAHQgF8IgdSDQEMAgsLIAQNAgsgAyAQQgiIPAAOIAAgA0EOakEBIAAoAgAoAgARAQAiBEEASA0BIAMgEDwADiAAIANBDmpBASAAKAIAKAIAEQEAIgJBf0xBACACIAQgAkEASBsbDQEgAyABLQAkQQBHQQd0OgAPIAAgA0EPakEBIAAoAgAoAgARAQBBAEgNASAAIAEoAiAgASgCKCAAKAIAKAIAEQEADQECfkIGIAhC/wBUDQAaQgcgCEL//wBUDQAaQgggCEL///8AVA0AGkIJIAhC/////wBUDQAaQgogCEL//////wBUDQAaQgsgCEL///////8AVA0AGkIMQg0gCEL/////////AFQbCyABKQMofCENDAELIAIpAyghDSABKAIIBEBCASEHAn5CASABKQMQIglC/wBUDQAaQgIgCUL//wBUDQAaQgMgCUL///8AVA0AGkIEIAlC/////wBUDQAaQgUgCUL//////wBUDQAaQgYgCUL///////8AVA0AGkIHQgggCUL/////////AFQbCyEKAkAgASkDACIIQoACVA0AQgIhByAIQoCABFQNAEIDIQcgCEKAgIAIVA0AQgQhByAIQoCAgIAQVA0AQgUhByAIQoCAgICAIFQNAEIGIQcgCEKAgICAgIDAAFQNAEIHQgggCEKAgICAgICAgAFUGyEHC0IBIQgCfkIBIAkgCnwgB3xCA3wiCUL/AFQNABpCAiAJQv//AFQNABpCAyAJQv///wBUDQAaQgQgCUL/////AFQNABpCBSAJQv//////AFQNABpCBiAJQv///////wBUDQAaQgdCCCAJQv////////8AVBsLIQcCQCAHIAl8QgF8IgpC/wBUDQBCAiEIIApC//8AVA0AQgMhCCAKQv///wBUDQBCBCEIIApC/////wBUDQBCBSEIIApC//////8AVA0AQgYhCCAKQv///////wBUDQBCB0IIIApC/////////wBUGyEICyAIIAp8QgJ8IQgLIAEpA0AiB1BFBEACfkIBIAdCP4cgB4VCAYYiB0KAAlQNABpCAiAHQoCABFQNABpCAyAHQoCAgAhUDQAaQgQgB0KAgICAEFQNABpCBSAHQoCAgICAIFQNABpCBiAHQoCAgICAgMAAVA0AGkIHQgggB0KAgICAgICAgAFUGwtCA3whEQsgASkDSCANgCELIAEtACRFBEACfkIBIAtCgAJUDQAaQgIgC0KAgARUDQAaQgMgC0KAgIAIVA0AGkIEIAtCgICAgBBUDQAaQgUgC0KAgICAgCBUDQAaQgYgC0KAgICAgIDAAFQNABpCB0IIIAtCgICAgICAgIABVBsLQgJ8IQ8LIAEpAxgiByANgCEMIAcgDVQiBkUEQAJ+QgEgDEKAAlQNABpCAiAMQoCABFQNABpCAyAMQoCAgAhUDQAaQgQgDEKAgICAEFQNABpCBSAMQoCAgICAIFQNABpCBiAMQoCAgICAgMAAVA0AGkIHQgggDEKAgICAgICAgAFUGwtCAnwhDgtCACENIABCoAECfkIBIAEpAyhCBHwiB0L/AFQNABpCAiAHQv//AFQNABpCAyAHQv///wBUDQAaQgQgB0L/////AFQNABpCBSAHQv//////AFQNABpCBiAHQv///////wBUDQAaQgdCCCAHQv////////8AVBsLIAggEXwgD3wgDnwgB3x8QgF8IggQFUUNACAAQqEBIAcQFUUNAEIBAn9BASABKQMwIgdC/wBUDQAaQQIgB0L//wBUDQAaQQMgB0L///8AVA0AGkEEIAdC/////wBUDQAaQQUgB0L//////wBUDQAaQQYgB0L///////8AVA0AGkEHQQggB0L/////////AFQbCyICQQdsrYYiDkJ+fCAHVA0AIAcgDoQhDiACQQFqrSEPQgEhBwJAA0ACQCADIA4gAiAHp2tBA3SthzwACiAAIANBCmpBASAAKAIAKAIAEQEAIgUgBCAFQQBIGyEEIAVBf0wNACAPIAdCAXwiB1INAQwCCwsgBA0BCyADIBBCCIg8AAkgACADQQlqQQEgACgCACgCABEBACIEQQBIDQAgAyAQPAAJIAAgA0EJakEBIAAoAgAoAgARAQAiAkF/TEEAIAIgBCACQQBIGxsNACADQQA6AAggACADQQhqQQEgACgCACgCABEBAEEASA0AIAAgASgCICABKAIoIAAoAgAoAgARAQANACABKAIIBEAgAEKh6wEgChAVRQ0BIABCpgEgCRAVRQ0BIABC7gEgASkDABATRQ0BIABCpQEgASgCCCABKQMQEEhFDQELIAEpA0AiB1BFBEAgACAHEMcBRQ0BCyABLQAkRQRAIABC+wEgCxATRQ0BCyAGRQRAIABCmwEgDBATRQ0BCwJ+QgIgCEL/AFQNABpCAyAIQv//AFQNABpCBCAIQv///wBUDQAaQgUgCEL/////AFQNABpCBiAIQv//////AFQNABpCByAIQv///////wBUDQAaQghCCSAIQv////////8AVBsLIAh8IQ0LIANBEGokACANC5QEAgR/AX4jAEEQayIDJAACQCAARQ0AIABC4YgBIAAgACgCACgCBBEAACAAKAIAKAIQEQsAQgEhBgJAA0ACQCADQuGIAUECIAana0EDdK2HPAANIAAgA0ENakEBIAAoAgAoAgARAQAiBCACIARBAEgbIQIgBEF/TA0AIAZCAXwiBkIDUg0BDAILCyACDQELIANBiAE6AA4gACADQQ5qQQEgACgCACgCABEBAEEASA0AIAMgAUI4iDwADwJAIAAgA0EPakEBIAAoAgAoAgARAQAiBEEASA0AIAMgAUIwiDwADyAAIANBD2pBASAAKAIAKAIAEQEAIgIgBCACQQBIGyEEIAJBf0wNACADIAFCKIg8AA8gACADQQ9qQQEgACgCACgCABEBACICIAQgAkEASCICGyEEIAINACADIAFCIIg8AA8gACADQQ9qQQEgACgCACgCABEBACICIAQgAkEASCICGyEEIAINACADIAFCGIg8AA8gACADQQ9qQQEgACgCACgCABEBACICIAQgAkEASCICGyEEIAINACADIAFCEIg8AA8gACADQQ9qQQEgACgCACgCABEB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BEH/////A3EgBEcbEBciAwR/An8CQAJAQTgQFyIBBEAgAUIANwMwIAFCATcDKCABQgE3AyAgAUIBNwMYIAFCADcDECABQQA2AgggAUIFNwMAIAAoAlghAiAFRQ0BA0AgAyAGQQJ0IgdqIAIgB2ooAgA2AgAgBkEBaiIGIAVHDQALDAILIAMQDkEADwsgAg0AQQAMAQsgAhAOIAAoAlwLIQIgACADNgJYIAMgAkECdGogATYCACAAIAQ2AlxBAQVBAAsLzwEBAn8jAEEQayIBJAACQCAAvUIgiKdB/////wdxIgJB+8Ok/wNNBEAgAkGAgMDyA0kNASAARAAAAAAAAAAAQQAQMiEADAELIAJBgIDA/wdPBEAgACAAoSEADAELIAAgARCEAUEDcSICQQJNBEACQAJAAkAgAkEBaw4CAQIACyABKwMAIAErAwhBARAyIQAMAwsgASsDACABKwMIEDMhAAwCCyABKwMAIAErAwhBARAymiEADAELIAErAwAgASsDCBAzmiEACyABQRBqJAAgAAu6FwEDfyMAQeABayIDJAAgAyACNgLcASAAIAAoAgBqIQRBeyECAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQeBgaiIFQS9LBEAgAUHhsX9qIgVBC00NASABQYaqf2oiAUERSw0mAkACQAJAIAFBAWsOESkpKSkpKSkpKSkpKSkpKQABAgsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFqQeUASw0oIAAgATYCjAFBACECDCgLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwoCyABIAAoAowBNgIAQQAhAgwnCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUGYeGpBA08EQEF/IQIgAUGYeEcNJwsgACABNgKIAUEAIQIMJgsgBUEBaw4vIyIhHh0SERwbGBcWFRQTGhklJRAPIB8ODSUMAQslCiUlJSUJCCUlBwYFBCUlAwIkCwJAAkACQCAFQQFrDgsnJycnJycnJwInAQALIAMgAygC3AEiAEEEajYC3AEgACgCACIARQRAQX8hAgwnCyADIAA2AnAgBEGfzgAgA0HwAGoQEiECDCYLIAMgAygC3AEiAUEEajYC3AEgACABKAIAIgA2AshuIAMgADYCYCAEQarOACADQeAAahASIQIMJQsgAyADKALcASIBQQRqNgLcASAAIAEoAgAiADYCsAEgAyAANgJQIARBqM4AIANB0ABqEBIhAgwkCyAAKAIEIQEgAEG8AWoiAkEMakEAQcDsABARGiACQs2Zs+7jzJmzPzcCwEBBACECIABBiO4AakEAQeweEBEaIARBvB9BABASGiAAIAFqIAAoArQBIANB+ABqEFcaIABBATYCxG4gAEGAgID8AzYClG4gAEGAgAE7AYxuIABB0Qg2ArhuIABB6Qc2AqhuIAAgACgCcDYCiG4gAEE8EBZBCHQ2ApBuDCMLIAMgAygC3AEiAEEEajYC3AEgACgCACIARQRAQX8hAgwjCyADIAA2AkAgBEHPHyADQUBrEBIaQQAhAgwiCyADIAMoAtwBIgBBBGo2AtwBQX8hAiAAKAIAIgBBAUsNISADIAA2AjAgBEHOHyADQTBqEBIaQQAhAgwhCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMIQsgASAAKAJMNgIAQQAhAgwgCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFBAUsNHyAAIAE2AkxBACECDB8LIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwfCyABIAAoApwBNgIAQQAhAgweCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFB+FhqQQlLDR0gACABNgKcASADIAE2AiAgBEHIHyADQSBqEBIaQQAhAgwdCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMHQsgASAAKAKoATYCAEEAIQIMHAsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQXhqQRBLDRsgACABNgKoAUEAIQIMGwsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDBsLIAEgACgC8IwBNgIAQQAhAgwaCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMGgsgASAAKAKQATYCAEEAIQIMGQsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDBkLIAEgACgCkAFBkANtIgQ2AgBBACECIAAoAmxBgxBGDRggASAAKAJ0IARqNgIADBgLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwYCyABIAAoAnw2AgBBACECDBcLIAMgAygC3AEiAUEEajYC3AEgASgCACIBQcdoakECTwRAQX8hAiABQZh4Rw0XCyAAIAE2AnxBACECDBYLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwWCyABIAAoApgBNgIAQQAhAgwVCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFBAUsNFCAAIAE2ApgBQQAhAgwUCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMFAsgASAAKAKUATYCAEEAIQIMEwsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFLDRIgACABNgKUASAAQQEgAWs2AjxBACECDBILIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwSCyABIAAoAig2AgBBACECDBELIAMgAygC3AEiAUEEajYC3AFBfyECIAEoAgAiAUHkAEsNECAAIAE2AiggAyABNgIQIARBrh8gA0EQahASGkEAIQIMEAsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDBALIAEgACgCMDYCAEEAIQIMDwsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFLDQ4gACABNgIwQQAhAgwOCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMDgsgASAAKAIsNgIAQQAhAgwNCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFBCksNDCAAIAE2AiwgAyABNgIAIARBqh8gAxASGkEAIQIMDAsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDAwLIAEgACgCuAE2AgBBACECDAsLIAMgAygC3AEiAUEEajYC3AFBfyECIAEoAgAiAUEBSw0KIAAgATYCuAFBACECDAoLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwKCyABIAAoArhuNgIAQQAhAgwJCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUGzd2pBBU8EQEF/IQIgAUGYeEcNCQsgACABNgKAASABQc0IRgRAIABBwD42AhRBACECDAkLIAFBzghGBEAg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IApqQQF0ai4BAEEDdSIMIAxsaiEDIAJBAWoiAiAFRw0ACyABIANqIgFB/////wcgAUH/////B0kbIQEgCEEBdCEKIAYoAgAhDEEAIQJBACEDA0AgAyAEIAIgCmogDGpBAXRqLgEAQQN1Ig4gDmxqIQMgAkEBaiICIAVHDQALIAEgA2oiAUH/////ByABQf////8HSRshASAIQQNsIQggBigCACEGQQAhAkEAIQMDQCADIAQgAiAIaiAGakEBdGouAQBBA3UiCiAKbGohAyACQQFqIgIgBUcNAAsLIAsgASADQQF2aiIBQf////8HIAFB/////wdJGzYCACANIAM2AjggCUEBaiIJQQRHDQALQQAhBSAAKAKMASIJQecHTARAQf//ASAJQQR1QQFqbSEFC0H/////ByAHKAIgIgggACgCfGoiAUH/////ByABQf////8HSRsiBG4hA0GAASEBIAACf0GAASAEIAAoAlwiAkEDdEoNABpBgAggBCACSA0AGiACQRB0QRB1IgQgA0EQdmwgAyACQQ91QQFqQQF1bGogA0H//wNxIARsQRB1aiICQRB1QQt0IAJBBXZB/w9xcgsiAiAFIAIgBUobQRB0QRB1IgIgAyAAKAJsIgNrIgRBEHVsIANqIAIgBEH//wNxbEEQdWoiAzYCbCAAQf////8HIANtIgNB////ByADQf///wdIGyIDNgJcQf////8HIAcoAiQiCiAAKAKAAWoiAkH/////ByACQf////8HSRsiBm4hAgJAIAYgACgCYCIEQQN0Sg0AQYAIIQEgBiAESA0AIARBEHRBEHUiASACQRB2bCACIARBD3VBAWpBAXVsaiACQf//A3EgAWxBEHVqIgFBEHVBC3QgAUEFdkH/D3FyIQELIAAgASAFIAEgBUobQRB0QRB1IgEgAiAAKAJwIgJrIgRBEHVsIAJqIAEgBEH//wNxbEEQdWoiATYCcCAAQf////8HIAFtIgFB////ByABQf///wdIGzYCYEH/////ByAHKAIoIgwgACgChAFqIgFB/////wcgAUH/////B0kbIgZuIQJBgAEhASAAAn9BgAEgBiAAKAJkIgRBA3RKDQAaQYAIIAYgBEgNABogBEEQdEEQdSIGIAJBEHZsIAIgBEEPdUEBakEBdWxqIAJB//8DcSAGbEEQdWoiBEEQdUELdCAE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GkEAIAFFDQAaQQAgARD6AiIBRQ0AGiADQX82AhQgAyAANgIQIANBADYCDCADIAE2AgggA0EYakEAQScQERogA0EBNgI4IAEgA0EIaiACKAIAQQEgASgCACgCHBEDAEEAIAMoAiBBAUcNABogAiADKAIYNgIAQQELIQAgA0FAayQAIAALCQBB7xUQtwEACzMBAX8jAEEQayIBJAAgAUEIaiAAKAIEELUBKAIAQQE6AAAgACgCCEEBOgAAIAFBEGokAAs0AQJ/AkAgACgCCCIALQAAIgJBAUcEfyACQQJxDQEgAEECOgAAQQEFQQALDwtBuRUQtwEACzYBAn8jAEEQayIBJAAgAUEIaiAAKAIEELUBKAIALQAAQQFHBEAgABD+AiECCyABQRBqJAAgAgt6AQF/IAAoAkxBAEgEQAJAIAAsAEtBCkYNACAAKAIUIgEgACgCEE8NACAAIAFBAWo2AhQgAUEKOgAADwsgABCuAQ8LAkACQCAALABLQQpGDQAgACgCFCIBIAAoAhBPDQAgACABQQFqNgIUIAFBCjoAAAwBCyAAEK4BCwskACAAQQtPBH8gAEEQakFwcSIAIABBf2oiACAAQQtGGwVBCgsLnAEBA38jAEEQayICJABBbyAATwRAAkAgAEEKTQRAQZveAiAAOgAAQZDeAiEBDAELQX8gABCBA0EBaiIDIgFJBEAQuQEAC0GQ3gIgARAXIgE2AgBBmN4CIANBgICAgHhyNgIAQZTeAiAANgIACyAABEAgAUH5DCAAEA0aCyACQQA6AA8gACABaiACLQAPOgAAIAJBEGokAA8LELkBAAvZAwICfwJ+IwBBIGsiAiQAAkAgAUL///////////8AgyIFQoCAgICAgMD/Q3wgBUKAgICAgIDAgLx/fFQEQCABQgSGIABCPIiEIQQgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhBAwCCyAEQoCAgICAgICAQH0hBCAAQoCAgICAgICACIVCAFINASAEQgGDIAR8IQQMAQsgAFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCABQgSGIABCPIiEQv////////8Dg0KAgICAgICA/P8AhCEEDAELQoCAgICAgID4/wAhBCAFQv///////7//wwBWDQBCACEEIAVCMIin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","base64"))
        };


        let node = this.master.createMediaStreamDestination()
        let encoder = new MediaRecorder(node.stream, {audioBitsPerSecond:bps, mimeType:mime}, workerOptions)
        this.encoders[id] = encoder
        var first = false
        encoder.addEventListener('dataavailable', e => {
          btob(e.data, (err, buf) => {
            //console.log(new shajs('sha256').update(buf).digest('hex'))
            //console.log(buf, id)
            if(buf.length) {
              window.parent.postMessage({
                type: 'audioSourceBuffer', 
                data: buf,
                id
              })
            }
          })
        })

        source.connect(node)

        return {encoder, node}
      }
    }

  var audio = new App(new WebAudioContext({sampleRate: 48000}), broadcasting)

  cb(null, audio)
  }

  


    function tob(buf, type="application/wasm"){
      return URL.createObjectURL(new Blob([new Buffer(buf).buffer], {type}))
    }
     

    function addMedia(cb, audio=true, video=false){
      var gam = require('getusermedia')
      // Web worker and .wasm configuration. Note: This is NOT a part of W3C standard.
      gam({video, audio}, function(err, stream){
        //console.log(stream.getAudioTracks())


        cb(err, stream)
      })
     }    
     })
}


}).call(this)}).call(this,require("buffer").Buffer)

},{"../jsynth-file-sample":3,"../jsynth-mic/stream":4,"../since-when":120,"blob-to-buffer":9,"buffer":124,"events":128,"getusermedia":21,"hyperscript":22,"ogg-opus-decoder":30,"opus-media-recorder":31,"run-waterfall":49,"sha.js":53,"short-uuid":60,"store":72,"through2":92,"to-arraybuffer":93}],6:[function(require,module,exports){
(function (process){(function (){

require('domready')(re => {
  var h = require('hyperscript')
  var ui = require('getids')()
  var Emitter = require('events')//.EventEmitter //require('./sharedEmitter')
  var bus = new Emitter()
  bus.once('iframeLoaded', e => {
    console.log(e)
    bus.emit('pong', {goat: 1})
    bus.on('clock', e => console.log(e))
  })

  
  var Peer = require('simple-peer')
  var signalhub = require('signalhub')
  const {makeAutoObservable,  autorun} = require('mobx')
  const short = require('short-uuid');
  const toa = require('to-arraybuffer')
  const btob = require('blob-to-buffer')
  const thru = require('through2')
  var store = require('store')
  var shajs = require('sha.js')
  const Time = require('../since-when')
  var runp =require('run-waterfall')
  var qs = require('querystring')
  var minimist = require('minimist')
  var argv = minimist(process.argv, {
    default: {
      host: 'folkstack.com',
      port: 80,
      protocol: 'https'
    }
  })
  var debub = signalhub('https://folkstack.com:80', 'debug')
  //var ret=debub.subscribe('return')
  var mime = 'audio/ogg'
  var mime = 'audio/ogg;codecs=opus'
  function dlink(buf, mime=mime){
  let file = new Blob([buf], {type:mime})
   let a = h('a', 'download', {href: URL.createObjectURL(file), name:new shajs('sha256').update(buf).digest('hex')+'.ogg', download:true})
   console.log(a)
  ui.tracks.appendChild(a)
  }

  var app 

  window.store = store
  if(!store.get('reset')) {
     
    store.clearAll();
    store.set('reset', true)
  }
  runp([initState, initUI, captureNetwork], (err, app)=>{
    app = app

    ui.init.addEventListener('change', e => {
      app._log('init')

      try{
        initAudio(app, (err, app)=>{
          app._log(err)
          //app.audio.sourceStream.pipe(app.audio.sinkStream) // heh
          if(app.session.broadcasting) {
            app.network.distance = 1
//            app.network.sourceStream = app.audio.sourceStream
           app.network.isSeekWorthy()
            app.network.allowCalls(app.session.stream)
            setTimeout(e => app.audio.start({broadcasing:true}), 1000)
             
          }
          else {
            app.audio.send('resume') 
            app.network.sourceSeek()
            bus.on('sourcePeerCaptured', id => {
              //app.audio.start(1000)
              app.network.connections[id].on('data', buf => {
              
                app.audio.send('sourceBuffer', buf)
              })
            })
          }

          bus.on('callSourceCaptured', id => {
//            app.audio.send('addPeer', 'caller', id)
            
            app.network.conncections[id].on('data', buf => {
              console.log(buf)
              app.audio.send('callBuffer', buf)
              
            })
            
          })
      })} catch (err){
        app._log(err)
      }
    })
    
  })



  function initState(cb){

    class App {
    
      constructor(){
        this.mic = 1/2
        this.monitor = 0
        this.call = 1/2
        this.track = 1/2
        this.quality = 64000
        this.update = null
        makeAutoObservable(this)
      }

      setGain(dial, value){
        this[dial] = value
        this.update = [dial, value]
      }
    
    }

    const app = new App
    bus.on('appStateChange', e =>{
      app.setGain(e[0], e[1])
      app.audio.send('param', e[1], e[0])
    })
    let hash = window.location.hash.slice(1)
    var session = store.get('session')
    if(!session) {
      session = {id: short().generate().split().reverse().join().slice(0,11)}
    }
    session.broadcasting =true 
    if(hash.length){
      session.stream = hash //short().generate().split().reverse().join().slice(0,11)
      session.broadcasting = false
    }
    else session.stream = session.id //short().generate().split().reverse().join().slice(0,11)

    app.session = session
  app._log = function(_id) { return e => {
      //ui.debug.appendChild(h('p', e.toString()))    
      debub.broadcast('debug', JSON.stringify({id: _id, log: e}))
      console.log(e)
  } }(session.broadcasting ? session.id : session.stream)
    store.set('session', session)
    console.log(app)
    cb(null, app)
  }


  function initUI(app, cb){
  
    bus.on('caller', msg => {
      let c = h('button', {id: msg.peerId, onclick: e => bus.emit('call', {peerId: e.target.id})})
      ui.tracks.appendChild(c)
    })

    ui.livelink.innerText = `${window.location.href}#${app.session.stream}`
    ui.copybutton.onchange = e => {
      navigator.clipboard.writeText(ui.livelink.innerText)
    }
    ui.request.addEventListener('change', e => {
      app.network.initCall(app.session.stream)
      app.audio.send('captureMic', null, app.session.stream)
    })
    ui.file.addEventListener('change', e => {
      console.log(e.target.files[0])
      //var a = h('audio.invert', {controls: true, src : URL.createObjectURL(e.target.files[0])})
      //ui.tracks.appendChild(a)
      //var c= app.audio.master.createMediaElementSource(a)
      //console.log(a)
      //c.connect(app.audio.trackmixer)
      let id = short().generate()
      //app.tracks[id] = 
      app.audio.send('addAudioTrack', e.target.files[0], id) 
      btob(e.target.files[0], (err, buf) => {
       // sampler(app.audio.master, buf.buffer, (err, node) =>{
          //node.connect(app.audio.master.destination)
          //node.start(0)
       // })      
      })
    })

    ;[].forEach.call(document.querySelectorAll('input[type=range]'), e => {
      e.addEventListener('input', ev => {
        bus.emit('appStateChange', [ev.target.name, Number(ev.target.value)])
      })
    })

    ;[].forEach.call(document.querySelectorAll('[data-mute]'), e => {
      e.addEventListener('change', ev => {
        bus.emit('appStateChange', [ev.target.dataset.mute, - app[ev.target.dataset.mute]])
      })
    })


    ui.monitorRange.addEventListener('change', e => {
      console.log(e.target.value)
      //bus.emit('appStateChange', ['monitor', Number(e.target.value)])
      //app.setGain('monitor', Number(e.target.value))
    })

    cb(null,app)

  }

  function initAudio(app, cb){
    var iframe = require('../iframarfi')

    var audio = iframe(require('./audio.js'))
    ui.tracks.appendChild(audio)
    
    window.addEventListener('message', msg => {
      //console.log(msg.data.data.length)
      //audio.contentWindow.postMessage({type: 'sinkBuffer', data: msg.data.data})
      
      var t = msg.data.type 
      if(t == 'debug'){
        app._log(msg.data.data)
      }
      if(t == 'audioSourceBuffer') {
        if(msg.data.id == 'record'){}
        else {
          let u = app.network.connections[msg.data.id] || {}
          //console.log(msg, u)
          if(u.writable) u.write(msg.data.data)
        }
      }
    })


    function send(type, data, id){
      audio.contentWindow.postMessage({type, data, id})
    }


    //setTimeout( e=> audio.contentWindow.postMessage({type: 'startBroadcast'}), 1000)

    app.audio = {
      iframe : audio,
      send: send,
      start: e => send('startBroadcast'),
      stop: e => send('stopBroadcast')
    }
    cb(null, app) 
  }
  
  function initCast(app, cb){
  
      app._log('stateInit')
      cb(null, app)
    
  }
  function captureNetwork(app, cb) {
  class Network { 

    constructor(app, addr){
      const self = this
      //console.log(state, addr)
      this.app = app
      this.hub = signalhub(addr, app.session.stream)
      this.channel = app.session.stream
      this.id = app.session.id
      this.state = app.state
      this.connections = {}
      this.hubs = {} 
      this.peers = {}
      this.callers = {}
      this.connecting = {}
      this.distance = 1
      this.offersOut = 0
      this.maxConnections = 4 // start low, test high, also helps spread early pcast testing
      this.duration = null // since-when
      this.channels = {}
      this.duration = new Time
      this.sinkStream = thru(buf => {
        for(var n in this.peers){
          let p = this.peers[n]
          if(p.writable) p.write(buf)
        }
      }, function close(){})
    }

    broadcast(buf){
      for(var n in this.peers) this.peers[n].write(buf)
    }

    send(buf){
      for(var n in this.callers) this.callers[n].write(buf)
    }

    log(){
      console.log.apply(this, arguments)
    }

    closePeerSignal(addr){
      this.hub.unsubscribe(addr)
      //delete this.connections[addr]
    }

    disallowCalls(id){
      this.hub.unsubscribe('caller:'+this.id)
    }

    allowCalls(id){
      console.log(id)
      let calls = this.hub.subscribe('caller:'+id)
      calls.on('data', msg=>{
        console.log(msg)
        //msg=JSON.parse(msg)
        bus.emit('caller', msg)
      })
      bus.once('call', msg =>{
        this.callDirect(msg.peerId)
      })

    }

    initCall(id){
      let mask = short().generate() 
      this.hub.broadcast('caller:'+id, {peerId: mask})
      let peer = this.initConnect(id, false, mask)
            app.audio.send('addPeer', 'caller', id)
      peer.on('connect', e =>{
        this.callers[id] = peer
        bus.emit('callSourceCaptured', id)
        peer.on('data', e => console.log(e))
        
      })
      
      
    }

    callDirect(id){
      let peer = this.initConnect(id, true, this.id)
            app.audio.send('addPeer', 'caller', id)
      peer.on('connect', e =>{
        this.callers[id] = peer
        bus.emit('callSourceCaptured', id)
        console.log('CALL PEER CONNECTED')
        peer.on('data', e => console.log(e))

      })
    }

    sourceSeek(){ // id for a peer stream
      var self = this 
      let mask = short().generate()
      let offerings = this.hub.subscribe(mask)
      var best = 0//Infinity
      var chosen
      var start = new Time
      offerings.on('data', offer => {
        offer = JSON.parse(offer)
        self.app._log(offer)
        let score = (1 / offer.distance) * offer.duration
        if(score > best) {
          best = score //offer.distance
          chosen = offer
        }
      console.log(chosen)
      })
      let t0 = setTimeout(e => {
      console.log(chosen)
        if(chosen) {
    //      this.hub.unsubscribe(mask)
          // do chosen
          bus.emit('sourcePeerIdCaptured', chosen.peerId)
          //self.sourceCap(chosen)
          let peer = this.initConnect(chosen.peerId, true, mask)
          peer.once('connect', e => {
            bus.emit('sourcePeerCaptured', chosen.peerId)
            this.distance = chosen.distance + 1
            this.sourceStream = peer
            self.app._log('Source Peer Captured.')
            self.isSeekWorthy()
          })
          peer.on('close', e => {
            self.app._log('Source Peer Closed')

          })
        } else {
          self.app._log('Err: No source peer found.')    
        }
      }, 3000)
      

      this.hub.broadcast('source', 
        JSON.stringify({
          peerId: mask
        })
      )
      
    }

    set sourceStream(stream){
      this._sourceStream = stream
      this.duration = new Time()
      //stream.pipe(this.sinkStream)
      //stream.pipe(app.audio.sinkStream)
    }

    get sourceStream(){
      return this._sourceStream
    }

    unseekable(session){
      if(sesion) this.hub.unsubscribe(session)
    }

    isSeekWorthy(){
      let r = this.offersOut < this.maxConnections
      let s = this.maxConnections > Object.keys(this.connections).length  
      let q = r && s 
      this._seekable = q
      if(q) {
        this.sourcer = this.hub.subscribe('source')
        this.sourcer.on('data', msg => this.seekable(JSON.parse(msg)))
      }
      else {
        if(this.sourcer) this.sourcer.close()
        
      }
      return this._seekable
    }

    setsub(id){
      if(this.hubs[id]) return this.hubs[id]
      else this.hubs[id] = this.hub.subscribe(id)
    }
    getsub(id){
      return this.hubs[id]
    }

    unsub(id){
      if(this.hubs[id]) {
        this.hub.unsubscribe(id) 
        delete this.hubs[id] 
      }
    }

    seekable(msg){ 
    this.app._log(msg)
      let self = this
      if(false) return // || Math.random() < 1 / Math.pow(self.distance, 2)) return
      else{
        self.offersOut += 1
        setTimeout(e=>{
          this.offersOut--
          //this.disnit(msg.peerId, mask)
        }, 1111*30)
        let mask = short().generate()
        let peer = this.initConnect(msg.peerId, false, mask)
        peer.once('connect', e =>{
          self.peers[msg.peerId] = peer
          app.audio.send('addPeer', 'broadcast', msg.peerId)
          self.isSeekWorthy()
          //if(app.audio.firstBroadcastBuffer) peer.write(app.audio.firstBroadcastBuffer)
        })
        peer.once('close', e =>{
          delete self.peers[msg.peerId]
          self.isSeekWorthy()
        })
        this.hub.broadcast(msg.peerId, JSON.stringify({
          peerId: mask,
          to: msg.peerId,
          distance: this.distance,
          duration: this.duration.sinceBeginNS()
        }))
      }
    }

    disnit(id, mask){
      delete this.connecting[id]
      this.isSeekWorthy()
      //this.hub.unsubscribe(mask)
    }

    initConnect(id, init, mask){
      var self = this
      let pipe = this.hub.subscribe(mask)
      var caller = new Peer({initiator: init, trickle: false, objectMode: false})
      this.connecting[id] = caller
      pipe.on('error', e => console.log.apply(this, arguments))
      pipe.on('data', function(data){
        data = JSON.parse(data)
        // callerID
        var peer = self.connecting[data.peerId]
        peer.signal(data.signal)
        peer.once('connect', e => {
          // close mask hub
        })
        //ui.callers.appendChild(h('div.caller', h('button.connect', `Connect to ${data.name || from}`, {onclick: _connect})))  
      })
      caller._debug = console.log
      caller.on('signal', sig => this.hub.broadcast(id, JSON.stringify({peerId: mask, to: id, signal: sig })))
      caller.once('connect', e => {
        this.connections[id] = caller
        this.connecting[id] = null
        console.log(`connected to ${Object.keys(this.connections).length} peers`)
      })
      caller.on('close', e => {
        this.disnit(id, mask)
      })
      caller.on('error', e => console.log(e))
      return caller
    }
  }
    var network = new Network(app, argv.protocol + '://' + argv.host + ':' + argv.port)
    app._log('netCap')
    app.network = network

    cb(null, app)
  }

})


}).call(this)}).call(this,require('_process'))

},{"../iframarfi":1,"../since-when":120,"./audio.js":5,"_process":143,"blob-to-buffer":9,"domready":16,"events":128,"getids":20,"hyperscript":22,"minimist":25,"mobx":26,"querystring":146,"run-waterfall":49,"sha.js":53,"short-uuid":60,"signalhub":61,"simple-peer":71,"store":72,"through2":92,"to-arraybuffer":93}],7:[function(require,module,exports){
var Converter = require('./src/converter');

/**
 * Function get source and destination alphabet and return convert function
 *
 * @param {string|Array} srcAlphabet
 * @param {string|Array} dstAlphabet
 *
 * @returns {function(number|Array)}
 */
function anyBase(srcAlphabet, dstAlphabet) {
    var converter = new Converter(srcAlphabet, dstAlphabet);
    /**
     * Convert function
     *
     * @param {string|Array} number
     *
     * @return {string|Array} number
     */
    return function (number) {
        return converter.convert(number);
    }
};

anyBase.BIN = '01';
anyBase.OCT = '01234567';
anyBase.DEC = '0123456789';
anyBase.HEX = '0123456789abcdef';

module.exports = anyBase;
},{"./src/converter":8}],8:[function(require,module,exports){
'use strict';

/**
 * Converter
 *
 * @param {string|Array} srcAlphabet
 * @param {string|Array} dstAlphabet
 * @constructor
 */
function Converter(srcAlphabet, dstAlphabet) {
    if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
        throw new Error('Bad alphabet');
    }
    this.srcAlphabet = srcAlphabet;
    this.dstAlphabet = dstAlphabet;
}

/**
 * Convert number from source alphabet to destination alphabet
 *
 * @param {string|Array} number - number represented as a string or array of points
 *
 * @returns {string|Array}
 */
Converter.prototype.convert = function(number) {
    var i, divide, newlen,
    numberMap = {},
    fromBase = this.srcAlphabet.length,
    toBase = this.dstAlphabet.length,
    length = number.length,
    result = typeof number === 'string' ? '' : [];

    if (!this.isValid(number)) {
        throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ')');
    }

    if (this.srcAlphabet === this.dstAlphabet) {
        return number;
    }

    for (i = 0; i < length; i++) {
        numberMap[i] = this.srcAlphabet.indexOf(number[i]);
    }
    do {
        divide = 0;
        newlen = 0;
        for (i = 0; i < length; i++) {
            divide = divide * fromBase + numberMap[i];
            if (divide >= toBase) {
                numberMap[newlen++] = parseInt(divide / toBase, 10);
                divide = divide % toBase;
            } else if (newlen > 0) {
                numberMap[newlen++] = 0;
            }
        }
        length = newlen;
        result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
    } while (newlen !== 0);

    return result;
};

/**
 * Valid number with source alphabet
 *
 * @param {number} number
 *
 * @returns {boolean}
 */
Converter.prototype.isValid = function(number) {
    var i = 0;
    for (; i < number.length; ++i) {
        if (this.srcAlphabet.indexOf(number[i]) === -1) {
            return false;
        }
    }
    return true;
};

module.exports = Converter;
},{}],9:[function(require,module,exports){
(function (Buffer){(function (){
/*! blob-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* global Blob, FileReader */

module.exports = function blobToBuffer (blob, cb) {
  if (typeof Blob === 'undefined' || !(blob instanceof Blob)) {
    throw new Error('first argument must be a Blob')
  }
  if (typeof cb !== 'function') {
    throw new Error('second argument must be a function')
  }

  const reader = new FileReader()

  function onLoadEnd (e) {
    reader.removeEventListener('loadend', onLoadEnd, false)
    if (e.error) cb(e.error)
    else cb(null, Buffer.from(reader.result))
  }

  reader.addEventListener('loadend', onLoadEnd, false)
  reader.readAsArrayBuffer(blob)
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":124}],10:[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],11:[function(require,module,exports){
// contains, add, remove, toggle
var indexof = require('indexof')

module.exports = ClassList

function ClassList(elem) {
    var cl = elem.classList

    if (cl) {
        return cl
    }

    var classList = {
        add: add
        , remove: remove
        , contains: contains
        , toggle: toggle
        , toString: $toString
        , length: 0
        , item: item
    }

    return classList

    function add(token) {
        var list = getTokens()
        if (indexof(list, token) > -1) {
            return
        }
        list.push(token)
        setTokens(list)
    }

    function remove(token) {
        var list = getTokens()
            , index = indexof(list, token)

        if (index === -1) {
            return
        }

        list.splice(index, 1)
        setTokens(list)
    }

    function contains(token) {
        return indexof(getTokens(), token) > -1
    }

    function toggle(token) {
        if (contains(token)) {
            remove(token)
            return false
        } else {
            add(token)
            return true
        }
    }

    function $toString() {
        return elem.className
    }

    function item(index) {
        var tokens = getTokens()
        return tokens[index] || null
    }

    function getTokens() {
        var className = elem.className

        return filter(className.split(" "), isTruthy)
    }

    function setTokens(list) {
        var length = list.length

        elem.className = list.join(" ")
        classList.length = length

        for (var i = 0; i < list.length; i++) {
            classList[i] = list[i]
        }

        delete list[length]
    }
}

function filter (arr, fn) {
    var ret = []
    for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i])) ret.push(arr[i])
    }
    return ret
}

function isTruthy(value) {
    return !!value
}

},{"indexof":23}],12:[function(require,module,exports){
(function (Buffer){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this)}).call(this,{"isBuffer":require("../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})

},{"../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":140}],13:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))

},{"./common":14,"_process":143}],14:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":29}],15:[function(require,module,exports){
(function (process){(function (){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BrowserInfo = /** @class */ (function () {
    function BrowserInfo(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
    }
    return BrowserInfo;
}());
exports.BrowserInfo = BrowserInfo;
var NodeInfo = /** @class */ (function () {
    function NodeInfo(version) {
        this.version = version;
        this.name = 'node';
        this.os = process.platform;
    }
    return NodeInfo;
}());
exports.NodeInfo = NodeInfo;
var BotInfo = /** @class */ (function () {
    function BotInfo() {
        this.bot = true; // NOTE: deprecated test name instead
        this.name = 'bot';
        this.version = null;
        this.os = null;
    }
    return BotInfo;
}());
exports.BotInfo = BotInfo;
// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk)|(Googlebot)|(Yammybot)|(Openbot)|(Slurp)|(MSNBot)|(Ask Jeeves\/Teoma)|(ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
    ['aol', /AOLShield\/([0-9\._]+)/],
    ['edge', /Edge\/([0-9\._]+)/],
    ['edge-ios', /EdgiOS\/([0-9\._]+)/],
    ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
    ['vivaldi', /Vivaldi\/([0-9\.]+)/],
    ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
    ['samsung', /SamsungBrowser\/([0-9\.]+)/],
    ['silk', /\bSilk\/([0-9._-]+)\b/],
    ['miui', /MiuiBrowser\/([0-9\.]+)$/],
    ['beaker', /BeakerBrowser\/([0-9\.]+)/],
    ['edge-chromium', /Edg\/([0-9\.]+)/],
    [
        'chromium-webview',
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
    ['fxios', /FxiOS\/([0-9\.]+)/],
    ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
    ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
    ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ['android', /Android\s([0-9\.]+)/],
    ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9\._]+).*Safari/],
    ['facebook', /FBAV\/([0-9\.]+)/],
    ['instagram', /Instagram\s([0-9\.]+)/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ['searchbot', SEARCHBOX_UA_REGEX],
];
var operatingSystemRules = [
    ['iOS', /iP(hone|od|ad)/],
    ['Android OS', /Android/],
    ['BlackBerry OS', /BlackBerry|BB10/],
    ['Windows Mobile', /IEMobile/],
    ['Amazon OS', /Kindle/],
    ['Windows 3.11', /Win16/],
    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
    ['Windows 98', /(Windows 98)|(Win98)/],
    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
    ['Windows Server 2003', /(Windows NT 5.2)/],
    ['Windows Vista', /(Windows NT 6.0)/],
    ['Windows 7', /(Windows NT 6.1)/],
    ['Windows 8', /(Windows NT 6.2)/],
    ['Windows 8.1', /(Windows NT 6.3)/],
    ['Windows 10', /(Windows NT 10.0)/],
    ['Windows ME', /Windows ME/],
    ['Open BSD', /OpenBSD/],
    ['Sun OS', /SunOS/],
    ['Chrome OS', /CrOS/],
    ['Linux', /(Linux)|(X11)/],
    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
    ['QNX', /QNX/],
    ['BeOS', /BeOS/],
    ['OS/2', /OS\/2/],
    ['Search Bot', SEARCHBOT_OS_REGEX],
];
function detect(userAgent) {
    if (!!userAgent) {
        return parseUserAgent(userAgent);
    }
    if (typeof navigator !== 'undefined') {
        return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
}
exports.detect = detect;
function parseUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    var matchedRule = ua !== '' &&
        userAgentRules.reduce(function (matched, _a) {
            var browser = _a[0], regex = _a[1];
            if (matched) {
                return matched;
            }
            var uaMatch = regex.exec(ua);
            return !!uaMatch && [browser, uaMatch];
        }, false);
    if (!matchedRule) {
        return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === 'searchbot') {
        return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
    if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
            versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
        }
    }
    else {
        versionParts = [];
    }
    return new BrowserInfo(name, versionParts.join('.'), detectOS(ua));
}
exports.parseUserAgent = parseUserAgent;
function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.test(ua);
        if (match) {
            return os;
        }
    }
    return null;
}
exports.detectOS = detectOS;
function getNodeVersion() {
    var isNode = typeof process !== 'undefined' && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
exports.getNodeVersion = getNodeVersion;
function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
        output.push('0');
    }
    return output;
}

}).call(this)}).call(this,require('_process'))

},{"_process":143}],16:[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? setTimeout(fn, 0) : fns.push(fn)
  }

});

},{}],17:[function(require,module,exports){
'use strict';

/**
 * @typedef {{ [key: string]: any }} Extensions
 * @typedef {Error} Err
 * @property {string} message
 */

/**
 *
 * @param {Error} obj
 * @param {Extensions} props
 * @returns {Error & Extensions}
 */
function assign(obj, props) {
    for (const key in props) {
        Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true,
        });
    }

    return obj;
}

/**
 *
 * @param {any} err - An Error
 * @param {string|Extensions} code - A string code or props to set on the error
 * @param {Extensions} [props] - Props to set on the error
 * @returns {Error & Extensions}
 */
function createError(err, code, props) {
    if (!err || typeof err === 'string') {
        throw new TypeError('Please pass an Error to err-code');
    }

    if (!props) {
        props = {};
    }

    if (typeof code === 'object') {
        props = code;
        code = '';
    }

    if (code) {
        props.code = code;
    }

    try {
        return assign(err, props);
    } catch (_) {
        props.message = err.message;
        props.stack = err.stack;

        const ErrClass = function () {};

        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));

        // @ts-ignore
        const output = assign(new ErrClass(), props);

        return output;
    }
}

module.exports = createError;

},{}],18:[function(require,module,exports){
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * @typedef {object} PrivateData
 * @property {EventTarget} eventTarget The event target.
 * @property {{type:string}} event The original event object.
 * @property {number} eventPhase The current event phase.
 * @property {EventTarget|null} currentTarget The current event target.
 * @property {boolean} canceled The flag to prevent default.
 * @property {boolean} stopped The flag to stop propagation immediately.
 * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.
 * @property {number} timeStamp The unix time.
 * @private
 */

/**
 * Private data for event wrappers.
 * @type {WeakMap<Event, PrivateData>}
 * @private
 */
const privateData = new WeakMap();

/**
 * Cache for wrapper classes.
 * @type {WeakMap<Object, Function>}
 * @private
 */
const wrappers = new WeakMap();

/**
 * Get private data.
 * @param {Event} event The event object to get private data.
 * @returns {PrivateData} The private data of the event.
 * @private
 */
function pd(event) {
    const retv = privateData.get(event);
    console.assert(retv != null, "'this' is expected an Event object, but got", event);
    return retv
}

/**
 * @see https://dom.spec.whatwg.org/#interface-event
 * @private
 */
/**
 * The event wrapper.
 * @constructor
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Event|{type:string}} event The original event to wrap.
 */
function Event(eventTarget, event) {
    privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now(),
    });

    // https://heycam.github.io/webidl/#Unforgeable
    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });

    // Define accessors
    const keys = Object.keys(event);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
            Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
    }
}

// Should be enumerable, but class methods are not enumerable.
Event.prototype = {
    /**
     * The type of this event.
     * @type {string}
     */
    get type() {
        return pd(this).event.type
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get target() {
        return pd(this).eventTarget
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get currentTarget() {
        return pd(this).currentTarget
    },

    /**
     * @returns {EventTarget[]} The composed path of this event.
     */
    composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
            return []
        }
        return [currentTarget]
    },

    /**
     * Constant of NONE.
     * @type {number}
     */
    get NONE() {
        return 0
    },

    /**
     * Constant of CAPTURING_PHASE.
     * @type {number}
     */
    get CAPTURING_PHASE() {
        return 1
    },

    /**
     * Constant of AT_TARGET.
     * @type {number}
     */
    get AT_TARGET() {
        return 2
    },

    /**
     * Constant of BUBBLING_PHASE.
     * @type {number}
     */
    get BUBBLING_PHASE() {
        return 3
    },

    /**
     * The target of this event.
     * @type {number}
     */
    get eventPhase() {
        return pd(this).eventPhase
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopPropagation() {
        const data = pd(this);
        if (typeof data.event.stopPropagation === "function") {
            data.event.stopPropagation();
        }
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopImmediatePropagation() {
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
            data.event.stopImmediatePropagation();
        }
    },

    /**
     * The flag to be bubbling.
     * @type {boolean}
     */
    get bubbles() {
        return Boolean(pd(this).event.bubbles)
    },

    /**
     * The flag to be cancelable.
     * @type {boolean}
     */
    get cancelable() {
        return Boolean(pd(this).event.cancelable)
    },

    /**
     * Cancel this event.
     * @returns {void}
     */
    preventDefault() {
        const data = pd(this);
        if (data.passiveListener != null) {
            console.warn("Event#preventDefault() was called from a passive listener:", data.passiveListener);
            return
        }
        if (!data.event.cancelable) {
            return
        }

        data.canceled = true;
        if (typeof data.event.preventDefault === "function") {
            data.event.preventDefault();
        }
    },

    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     */
    get defaultPrevented() {
        return pd(this).canceled
    },

    /**
     * The flag to be composed.
     * @type {boolean}
     */
    get composed() {
        return Boolean(pd(this).event.composed)
    },

    /**
     * The unix time of this event.
     * @type {number}
     */
    get timeStamp() {
        return pd(this).timeStamp
    },
};

// `constructor` is not enumerable.
Object.defineProperty(Event.prototype, "constructor", { value: Event, configurable: true, writable: true });

// Ensure `event instanceof window.Event` is `true`.
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);

    // Make association for wrappers.
    wrappers.set(window.Event.prototype, Event);
}

/**
 * Get the property descriptor to redirect a given property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to redirect the property.
 * @private
 */
function defineRedirectDescriptor(key) {
    return {
        get() {
            return pd(this).event[key]
        },
        set(value) {
            pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Get the property descriptor to call a given method property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to call the method property.
 * @private
 */
function defineCallDescriptor(key) {
    return {
        value() {
            const event = pd(this).event;
            return event[key].apply(event, arguments)
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define new wrapper class.
 * @param {Function} BaseEvent The base wrapper class.
 * @param {Object} proto The prototype of the original event.
 * @returns {Function} The defined wrapper class.
 * @private
 */
function defineWrapper(BaseEvent, proto) {
    const keys = Object.keys(proto);
    if (keys.length === 0) {
        return BaseEvent
    }

    /** CustomEvent */
    function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
    }

    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true },
    });

    // Define accessors.
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(proto, key);
            const isFunc = (typeof descriptor.value === "function");
            Object.defineProperty(
                CustomEvent.prototype,
                key,
                isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
            );
        }
    }

    return CustomEvent
}

/**
 * Get the wrapper class of a given prototype.
 * @param {Object} proto The prototype of the original event to get its wrapper.
 * @returns {Function} The wrapper class.
 * @private
 */
function getWrapper(proto) {
    if (proto == null || proto === Object.prototype) {
        return Event
    }

    let wrapper = wrappers.get(proto);
    if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
    }
    return wrapper
}

/**
 * Wrap a given event to management a dispatching.
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Object} event The event to wrap.
 * @returns {Event} The wrapper instance.
 * @private
 */
function wrapEvent(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event)
}

/**
 * Get the stopped flag of a given event.
 * @param {Event} event The event to get.
 * @returns {boolean} The flag to stop propagation immediately.
 * @private
 */
function isStopped(event) {
    return pd(event).stopped
}

/**
 * Set the current event phase of a given event.
 * @param {Event} event The event to set current target.
 * @param {number} eventPhase New event phase.
 * @returns {void}
 * @private
 */
function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
}

/**
 * Set the current target of a given event.
 * @param {Event} event The event to set current target.
 * @param {EventTarget|null} currentTarget New current target.
 * @returns {void}
 * @private
 */
function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
}

/**
 * Set a passive listener of a given event.
 * @param {Event} event The event to set current target.
 * @param {Function|null} passiveListener New passive listener.
 * @returns {void}
 * @private
 */
function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
}

/**
 * @typedef {object} ListenerNode
 * @property {Function} listener
 * @property {1|2|3} listenerType
 * @property {boolean} passive
 * @property {boolean} once
 * @property {ListenerNode|null} next
 * @private
 */

/**
 * @type {WeakMap<object, Map<string, ListenerNode>>}
 * @private
 */
const listenersMap = new WeakMap();

// Listener types
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;

/**
 * Check whether a given value is an object or not.
 * @param {any} x The value to check.
 * @returns {boolean} `true` if the value is an object.
 */
function isObject(x) {
    return x !== null && typeof x === "object" //eslint-disable-line no-restricted-syntax
}

/**
 * Get listeners.
 * @param {EventTarget} eventTarget The event target to get.
 * @returns {Map<string, ListenerNode>} The listeners.
 * @private
 */
function getListeners(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
        throw new TypeError("'this' is expected an EventTarget object, but got another value.")
    }
    return listeners
}

/**
 * Get the property descriptor for the event attribute of a given event.
 * @param {string} eventName The event name to get property descriptor.
 * @returns {PropertyDescriptor} The property descriptor.
 * @private
 */
function defineEventAttributeDescriptor(eventName) {
    return {
        get() {
            const listeners = getListeners(this);
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    return node.listener
                }
                node = node.next;
            }
            return null
        },

        set(listener) {
            if (typeof listener !== "function" && !isObject(listener)) {
                listener = null; // eslint-disable-line no-param-reassign
            }
            const listeners = getListeners(this);

            // Traverse to the tail while removing old value.
            let prev = null;
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    // Remove old value.
                    if (prev !== null) {
                        prev.next = node.next;
                    }
                    else if (node.next !== null) {
                        listeners.set(eventName, node.next);
                    }
                    else {
                        listeners.delete(eventName);
                    }
                }
                else {
                    prev = node;
                }

                node = node.next;
            }

            // Add new value.
            if (listener !== null) {
                const newNode = {
                    listener,
                    listenerType: ATTRIBUTE,
                    passive: false,
                    once: false,
                    next: null,
                };
                if (prev === null) {
                    listeners.set(eventName, newNode);
                }
                else {
                    prev.next = newNode;
                }
            }
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define an event attribute (e.g. `eventTarget.onclick`).
 * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.
 * @param {string} eventName The event name to define.
 * @returns {void}
 */
function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
}

/**
 * Define a custom EventTarget with event attributes.
 * @param {string[]} eventNames Event names for event attributes.
 * @returns {EventTarget} The custom EventTarget.
 * @private
 */
function defineCustomEventTarget(eventNames) {
    /** CustomEventTarget */
    function CustomEventTarget() {
        EventTarget.call(this);
    }

    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: { value: CustomEventTarget, configurable: true, writable: true },
    });

    for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    }

    return CustomEventTarget
}

/**
 * EventTarget.
 *
 * - This is constructor if no arguments.
 * - This is a function which returns a CustomEventTarget constructor if there are arguments.
 *
 * For example:
 *
 *     class A extends EventTarget {}
 *     class B extends EventTarget("message") {}
 *     class C extends EventTarget("message", "error") {}
 *     class D extends EventTarget(["message", "error"]) {}
 */
function EventTarget() {
    /*eslint-disable consistent-return */
    if (this instanceof EventTarget) {
        listenersMap.set(this, new Map());
        return
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0])
    }
    if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
            types[i] = arguments[i];
        }
        return defineCustomEventTarget(types)
    }
    throw new TypeError("Cannot call a class as a function")
    /*eslint-enable consistent-return */
}

// Should be enumerable, but class methods are not enumerable.
EventTarget.prototype = {
    /**
     * Add a given listener to this event target.
     * @param {string} eventName The event name to add.
     * @param {Function} listener The listener to add.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {boolean} `true` if the listener was added actually.
     */
    addEventListener(eventName, listener, options) {
        if (listener == null) {
            return false
        }
        if (typeof listener !== "function" && !isObject(listener)) {
            throw new TypeError("'listener' should be a function or an object.")
        }

        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = (capture ? CAPTURE : BUBBLE);
        const newNode = {
            listener,
            listenerType,
            passive: optionsIsObj && Boolean(options.passive),
            once: optionsIsObj && Boolean(options.once),
            next: null,
        };

        // Set it as the first node if the first node is null.
        let node = listeners.get(eventName);
        if (node === undefined) {
            listeners.set(eventName, newNode);
            return true
        }

        // Traverse to the tail while checking duplication..
        let prev = null;
        while (node != null) {
            if (node.listener === listener && node.listenerType === listenerType) {
                // Should ignore duplication.
                return false
            }
            prev = node;
            node = node.next;
        }

        // Add it.
        prev.next = newNode;
        return true
    },

    /**
     * Remove a given listener from this event target.
     * @param {string} eventName The event name to remove.
     * @param {Function} listener The listener to remove.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {boolean} `true` if the listener was removed actually.
     */
    removeEventListener(eventName, listener, options) {
        if (listener == null) {
            return false
        }

        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = (capture ? CAPTURE : BUBBLE);

        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
            if (node.listener === listener && node.listenerType === listenerType) {
                if (prev !== null) {
                    prev.next = node.next;
                }
                else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                }
                else {
                    listeners.delete(eventName);
                }
                return true
            }

            prev = node;
            node = node.next;
        }

        return false
    },

    /**
     * Dispatch a given event.
     * @param {Event|{type:string}} event The event to dispatch.
     * @returns {boolean} `false` if canceled.
     */
    dispatchEvent(event) { //eslint-disable-line complexity
        if (event == null || typeof event.type !== "string") {
            throw new TypeError("\"event.type\" should be a string.")
        }

        // If listeners aren't registered, terminate.
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
            return true
        }

        // Since we cannot rewrite several properties, so wrap object.
        const wrappedEvent = wrapEvent(this, event);

        // This doesn't process capturing phase and bubbling phase.
        // This isn't participating in a tree.
        let prev = null;
        while (node != null) {
            // Remove this listener if it's once
            if (node.once) {
                if (prev !== null) {
                    prev.next = node.next;
                }
                else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                }
                else {
                    listeners.delete(eventName);
                }
            }
            else {
                prev = node;
            }

            // Call this listener
            setPassiveListener(wrappedEvent, (node.passive ? node.listener : null));
            if (typeof node.listener === "function") {
                try {
                    node.listener.call(this, wrappedEvent);
                }
                catch (err) {
                    /*eslint-disable no-console */
                    if (typeof console !== "undefined" && typeof console.error === "function") {
                        console.error(err);
                    }
                    /*eslint-enable no-console */
                }
            }
            else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
                node.listener.handleEvent(wrappedEvent);
            }

            // Break if `event.stopImmediatePropagation` was called.
            if (isStopped(wrappedEvent)) {
                break
            }

            node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);

        return !wrappedEvent.defaultPrevented
    },
};

// `constructor` is not enumerable.
Object.defineProperty(EventTarget.prototype, "constructor", { value: EventTarget, configurable: true, writable: true });

// Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}

exports.defineEventAttribute = defineEventAttribute;
exports.EventTarget = EventTarget;
exports.default = EventTarget;

module.exports = EventTarget
module.exports.EventTarget = module.exports["default"] = EventTarget
module.exports.defineEventAttribute = defineEventAttribute


},{}],19:[function(require,module,exports){
// originally pulled out of simple-peer

module.exports = function getBrowserRTC () {
  if (typeof globalThis === 'undefined') return null
  var wrtc = {
    RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection ||
      globalThis.webkitRTCPeerConnection,
    RTCSessionDescription: globalThis.RTCSessionDescription ||
      globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
    RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate ||
      globalThis.webkitRTCIceCandidate
  }
  if (!wrtc.RTCPeerConnection) return null
  return wrtc
}

},{}],20:[function(require,module,exports){
module.exports = function(el){

    var ids = {};

    if('string' == typeof el) el = document.getElementById(el);

    if(!el) el = document;

    var children = el.getElementsByTagName('*');

    Array.prototype.forEach.call(children, function(e){

	if(e.id.length > 0){

	    ids[e.id] = e

	}

    })

    return ids

}

},{}],21:[function(require,module,exports){
// getUserMedia helper by @HenrikJoreteg used for navigator.getUserMedia shim
var adapter = require('webrtc-adapter');

module.exports = function (constraints, cb) {
    var error;
    var haveOpts = arguments.length === 2;
    var defaultOpts = {video: true, audio: true};

    var denied = 'PermissionDeniedError';
    var altDenied = 'PERMISSION_DENIED';
    var notSatisfied = 'ConstraintNotSatisfiedError';

    // make constraints optional
    if (!haveOpts) {
        cb = constraints;
        constraints = defaultOpts;
    }

    // treat lack of browser support like an error
    if (typeof navigator === 'undefined' || !navigator.mediaDevices){ //getUserMedia) {
        // throw proper error per spec
        error = new Error('MediaStreamError');
        error.name = 'NotSupportedError';

        // keep all callbacks async
        return setTimeout(function () {
            cb(error);
        }, 0);
    }

    // normalize error handling when no media types are requested
    if (!constraints.audio && !constraints.video) {
        error = new Error('MediaStreamError');
        error.name = 'NoMediaRequestedError';

        // keep all callbacks async
        return setTimeout(function () {
            cb(error);
        }, 0);
    }

    navigator.mediaDevices.getUserMedia(constraints)
    .then(function (stream) {
        cb(null, stream);
    }).catch(function (err) {
        var error;
        // coerce into an error object since FF gives us a string
        // there are only two valid names according to the spec
        // we coerce all non-denied to "constraint not satisfied".
        if (typeof err === 'string') {
            error = new Error('MediaStreamError');
            if (err === denied || err === altDenied) {
                error.name = denied;
            } else {
                error.name = notSatisfied;
            }
        } else {
            // if we get an error object make sure '.name' property is set
            // according to spec: http://dev.w3.org/2011/webrtc/editor/getusermedia.html#navigatorusermediaerror-and-navigatorusermediaerrorcallback
            error = err;
            if (!error.name) {
                // this is likely chrome which
                // sets a property called "ERROR_DENIED" on the error object
                // if so we make sure to set a name
                if (error[denied]) {
                    err.name = denied;
                } else {
                    err.name = notSatisfied;
                }
            }
        }

        cb(error);
    });
};

},{"webrtc-adapter":110}],22:[function(require,module,exports){
var split = require('browser-split')
var ClassList = require('class-list')

var w = typeof window === 'undefined' ? require('html-element') : window
var document = w.document
var Text = w.Text

function context () {

  var cleanupFuncs = []

  function h() {
    var args = [].slice.call(arguments), e = null
    function item (l) {
      var r
      function parseClass (string) {
        // Our minimal parser doesnt understand escaping CSS special
        // characters like `#`. Dont use them. More reading:
        // https://mathiasbynens.be/notes/css-escapes .

        var m = split(string, /([\.#]?[^\s#.]+)/)
        if(/^\.|#/.test(m[1]))
          e = document.createElement('div')
        forEach(m, function (v) {
          var s = v.substring(1,v.length)
          if(!v) return
          if(!e)
            e = document.createElement(v)
          else if (v[0] === '.')
            ClassList(e).add(s)
          else if (v[0] === '#')
            e.setAttribute('id', s)
        })
      }

      if(l == null)
        ;
      else if('string' === typeof l) {
        if(!e)
          parseClass(l)
        else
          e.appendChild(r = document.createTextNode(l))
      }
      else if('number' === typeof l
        || 'boolean' === typeof l
        || l instanceof Date
        || l instanceof RegExp ) {
          e.appendChild(r = document.createTextNode(l.toString()))
      }
      //there might be a better way to handle this...
      else if (isArray(l))
        forEach(l, item)
      else if(isNode(l))
        e.appendChild(r = l)
      else if(l instanceof Text)
        e.appendChild(r = l)
      else if ('object' === typeof l) {
        for (var k in l) {
          if('function' === typeof l[k]) {
            if(/^on\w+/.test(k)) {
              (function (k, l) { // capture k, l in the closure
                if (e.addEventListener){
                  e.addEventListener(k.substring(2), l[k], false)
                  cleanupFuncs.push(function(){
                    e.removeEventListener(k.substring(2), l[k], false)
                  })
                }else{
                  e.attachEvent(k, l[k])
                  cleanupFuncs.push(function(){
                    e.detachEvent(k, l[k])
                  })
                }
              })(k, l)
            } else {
              // observable
              e[k] = l[k]()
              cleanupFuncs.push(l[k](function (v) {
                e[k] = v
              }))
            }
          }
          else if(k === 'style') {
            if('string' === typeof l[k]) {
              e.style.cssText = l[k]
            }else{
              for (var s in l[k]) (function(s, v) {
                if('function' === typeof v) {
                  // observable
                  e.style.setProperty(s, v())
                  cleanupFuncs.push(v(function (val) {
                    e.style.setProperty(s, val)
                  }))
                } else
                  var match = l[k][s].match(/(.*)\W+!important\W*$/);
                  if (match) {
                    e.style.setProperty(s, match[1], 'important')
                  } else {
                    e.style.setProperty(s, l[k][s])
                  }
              })(s, l[k][s])
            }
          } else if(k === 'attrs') {
            for (var v in l[k]) {
              e.setAttribute(v, l[k][v])
            }
          }
          else if (k.substr(0, 5) === "data-") {
            e.setAttribute(k, l[k])
          } else {
            e[k] = l[k]
          }
        }
      } else if ('function' === typeof l) {
        //assume it's an observable!
        var v = l()
        e.appendChild(r = isNode(v) ? v : document.createTextNode(v))

        cleanupFuncs.push(l(function (v) {
          if(isNode(v) && r.parentElement)
            r.parentElement.replaceChild(v, r), r = v
          else
            r.textContent = v
        }))
      }

      return r
    }
    while(args.length)
      item(args.shift())

    return e
  }

  h.cleanup = function () {
    for (var i = 0; i < cleanupFuncs.length; i++){
      cleanupFuncs[i]()
    }
    cleanupFuncs.length = 0
  }

  return h
}

var h = module.exports = context()
h.context = context

function isNode (el) {
  return el && el.nodeName && el.nodeType
}

function forEach (arr, fn) {
  if (arr.forEach) return arr.forEach(fn)
  for (var i = 0; i < arr.length; i++) fn(arr[i], i)
}

function isArray (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}



},{"browser-split":10,"class-list":11,"html-element":123}],23:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],24:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],25:[function(require,module,exports){
module.exports = function (args, opts) {
    if (!opts) opts = {};
    
    var flags = { bools : {}, strings : {}, unknownFn: null };

    if (typeof opts['unknown'] === 'function') {
        flags.unknownFn = opts['unknown'];
    }

    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
      flags.allBools = true;
    } else {
      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
          flags.bools[key] = true;
      });
    }
    
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function (key) {
        aliases[key] = [].concat(opts.alias[key]);
        aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
                return x !== y;
            }));
        });
    });

    [].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true;
        if (aliases[key]) {
            flags.strings[aliases[key]] = true;
        }
     });

    var defaults = opts['default'] || {};
    
    var argv = { _ : [] };
    Object.keys(flags.bools).forEach(function (key) {
        setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });
    
    var notFlags = [];

    if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--')+1);
        args = args.slice(0, args.indexOf('--'));
    }

    function argDefined(key, arg) {
        return (flags.allBools && /^--[^=]+$/.test(arg)) ||
            flags.strings[key] || flags.bools[key] || aliases[key];
    }

    function setArg (key, val, arg) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg) === false) return;
        }

        var value = !flags.strings[key] && isNumber(val)
            ? Number(val) : val
        ;
        setKey(argv, key.split('.'), value);
        
        (aliases[key] || []).forEach(function (x) {
            setKey(argv, x.split('.'), value);
        });
    }

    function setKey (obj, keys, value) {
        var o = obj;
        for (var i = 0; i < keys.length-1; i++) {
            var key = keys[i];
            if (key === '__proto__') return;
            if (o[key] === undefined) o[key] = {};
            if (o[key] === Object.prototype || o[key] === Number.prototype
                || o[key] === String.prototype) o[key] = {};
            if (o[key] === Array.prototype) o[key] = [];
            o = o[key];
        }

        var key = keys[keys.length - 1];
        if (key === '__proto__') return;
        if (o === Object.prototype || o === Number.prototype
            || o === String.prototype) o = {};
        if (o === Array.prototype) o = [];
        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
            o[key] = value;
        }
        else if (Array.isArray(o[key])) {
            o[key].push(value);
        }
        else {
            o[key] = [ o[key], value ];
        }
    }
    
    function aliasIsBoolean(key) {
      return aliases[key].some(function (x) {
          return flags.bools[x];
      });
    }

    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        
        if (/^--.+=/.test(arg)) {
            // Using [\s\S] instead of . because js doesn't support the
            // 'dotall' regex modifier. See:
            // http://stackoverflow.com/a/1068308/13216
            var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
            var key = m[1];
            var value = m[2];
            if (flags.bools[key]) {
                value = value !== 'false';
            }
            setArg(key, value, arg);
        }
        else if (/^--no-.+/.test(arg)) {
            var key = arg.match(/^--no-(.+)/)[1];
            setArg(key, false, arg);
        }
        else if (/^--.+/.test(arg)) {
            var key = arg.match(/^--(.+)/)[1];
            var next = args[i + 1];
            if (next !== undefined && !/^-/.test(next)
            && !flags.bools[key]
            && !flags.allBools
            && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i++;
            }
            else if (/^(true|false)$/.test(next)) {
                setArg(key, next === 'true', arg);
                i++;
            }
            else {
                setArg(key, flags.strings[key] ? '' : true, arg);
            }
        }
        else if (/^-[^-]+/.test(arg)) {
            var letters = arg.slice(1,-1).split('');
            
            var broken = false;
            for (var j = 0; j < letters.length; j++) {
                var next = arg.slice(j+2);
                
                if (next === '-') {
                    setArg(letters[j], next, arg)
                    continue;
                }
                
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split('=')[1], arg);
                    broken = true;
                    break;
                }
                
                if (/[A-Za-z]/.test(letters[j])
                && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                
                if (letters[j+1] && letters[j+1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j+2), arg);
                    broken = true;
                    break;
                }
                else {
                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                }
            }
            
            var key = arg.slice(-1)[0];
            if (!broken && key !== '-') {
                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                && !flags.bools[key]
                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i+1], arg);
                    i++;
                }
                else if (args[i+1] && /^(true|false)$/.test(args[i+1])) {
                    setArg(key, args[i+1] === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
        }
        else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(
                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                );
            }
            if (opts.stopEarly) {
                argv._.push.apply(argv._, args.slice(i + 1));
                break;
            }
        }
    }
    
    Object.keys(defaults).forEach(function (key) {
        if (!hasKey(argv, key.split('.'))) {
            setKey(argv, key.split('.'), defaults[key]);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), defaults[key]);
            });
        }
    });
    
    if (opts['--']) {
        argv['--'] = new Array();
        notFlags.forEach(function(key) {
            argv['--'].push(key);
        });
    }
    else {
        notFlags.forEach(function(key) {
            argv._.push(key);
        });
    }

    return argv;
};

function hasKey (obj, keys) {
    var o = obj;
    keys.slice(0,-1).forEach(function (key) {
        o = (o[key] || {});
    });

    var key = keys[keys.length - 1];
    return key in o;
}

function isNumber (x) {
    if (typeof x === 'number') return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}


},{}],26:[function(require,module,exports){
(function (process){(function (){

'use strict'

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./mobx.cjs.production.min.js')
} else {
  module.exports = require('./mobx.cjs.development.js')
}

}).call(this)}).call(this,require('_process'))

},{"./mobx.cjs.development.js":27,"./mobx.cjs.production.min.js":28,"_process":143}],27:[function(require,module,exports){
(function (global){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var niceErrors = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function _(annotationType, key) {
    return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
  },

  /*
  2(prop) {
      return `invalid decorator for '${prop.toString()}'`
  },
  3(prop) {
      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
  },
  4(prop) {
      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
  },
  */
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function _(index, length) {
    return "[mobx.array] Index out of bounds, " + index + " is larger than " + length;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function _(other) {
    return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
  },
  20: function _(other) {
    return "Cannot initialize map from " + other;
  },
  21: function _(dataStructure) {
    return "Cannot convert to map from '" + dataStructure + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function _(thing) {
    return "Cannot obtain administration from " + thing;
  },
  25: function _(property, name) {
    return "the entry '" + property + "' does not exist in the observable map '" + name + "'";
  },
  26: "please specify a property",
  27: function _(property, name) {
    return "no observable property '" + property.toString() + "' found on the observable object '" + name + "'";
  },
  28: function _(thing) {
    return "Cannot obtain atom from " + thing;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function _(name, derivation) {
    return "Cycle detected in computation " + name + ": " + derivation;
  },
  33: function _(name) {
    return "The setter of computed value '" + name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function _(name) {
    return "[ComputedValue '" + name + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function _(method) {
    return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
  },
  38: "'ownKeys()' can only be used on observable objects",
  39: "'defineProperty()' can only be used on observable objects"
};
var errors =  niceErrors ;
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  {
    var e = typeof error === "string" ? error : errors[error];
    if (typeof e === "function") e = e.apply(null, args);
    throw new Error("[MobX] " + e);
  }
}

var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }

  if (typeof window !== "undefined") {
    return window;
  }

  if (typeof global !== "undefined") {
    return global;
  }

  if (typeof self !== "undefined") {
    return self;
  }

  return mockGlobal;
}

var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = /*#__PURE__*/Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die( "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" );
  }
}
function warnAboutProxyRequirement(msg) {
  if ( globalState.verifyProxies) {
    die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + msg);
  }
}
function getNextId() {
  return ++globalState.mobxGuid;
}
/**
 * Makes sure that the provided function is invoked at most once.
 */

function once(func) {
  var invoked = false;
  return function () {
    if (invoked) return;
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop = function noop() {};
function isFunction(fn) {
  return typeof fn === "function";
}
function isStringish(value) {
  var t = typeof value;

  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }

  return false;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  var _proto$constructor;

  if (!isObject(value)) return false;
  var proto = Object.getPrototypeOf(value);
  if (proto == null) return true;
  return ((_proto$constructor = proto.constructor) == null ? void 0 : _proto$constructor.toString()) === plainObjectString;
} // https://stackoverflow.com/a/37865170

function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) return false;
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) return true;
  return false;
}
function addHiddenProp(object, propName, value) {
  defineProperty(object, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value: value
  });
}
function addHiddenFinalProp(object, propName, value) {
  defineProperty(object, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value: value
  });
}
function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function (x) {
    return isObject(x) && x[propName] === true;
  };
}
function isES6Map(thing) {
  return thing instanceof Map;
}
function isES6Set(thing) {
  return thing instanceof Set;
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
/**
 * Returns the following: own enumerable keys and symbols.
 */

function getPlainObjectKeys(object) {
  var keys = Object.keys(object); // Not supported in IE, so there are not going to be symbol props anyway...

  if (!hasGetOwnPropertySymbols) return keys;
  var symbols = Object.getOwnPropertySymbols(object);
  if (!symbols.length) return keys;
  return [].concat(keys, symbols.filter(function (s) {
    return objectPrototype.propertyIsEnumerable.call(object, s);
  }));
} // From Immer utils
// Returns all own keys, including non-enumerable and symbolic

var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function (obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} :
/* istanbul ignore next */
Object.getOwnPropertyNames;
function stringifyKey(key) {
  if (typeof key === "string") return key;
  if (typeof key === "symbol") return key.toString();
  return new String(key).toString();
}
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
} // From Immer utils

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
  var res = {}; // Note: without polyfill for ownKeys, symbols won't be picked up

  ownKeys(target).forEach(function (key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var storedAnnotationsSymbol = /*#__PURE__*/Symbol("mobx-stored-annotations");
/**
 * Creates a function that acts as
 * - decorator
 * - annotation object
 */

function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    storeAnnotation(target, property, annotation);
  }

  return Object.assign(decorator, annotation);
}
/**
 * Stores annotation to prototype,
 * so it can be inspected later by `makeObservable` called from constructor
 */

function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
  } // @override must override something


  if ( isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    die("'" + fieldName + "' is decorated with 'override', " + "but no such decorated member was found on prototype.");
  } // Cannot re-decorate


  assertNotDecorated(prototype, annotation, key); // Ignore override

  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}

function assertNotDecorated(prototype, annotation, key) {
  if ( !isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed." + "\nUse '@override' decorator for methods overriden by subclass.");
  }
}
/**
 * Collects annotations from prototypes and stores them on target (instance)
 */


function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    if ( !target[storedAnnotationsSymbol]) {
      die("No annotations were passed to makeObservable, but no decorated members have been found either");
    } // We need a copy as we will remove annotation from the list once it's applied.


    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
  }

  return target[storedAnnotationsSymbol];
}

var $mobx = /*#__PURE__*/Symbol("mobx administration");
var Atom = /*#__PURE__*/function () {
  // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed

  /**
   * Create a new atom. For debugging purposes it is recommended to give it a name.
   * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
   */
  function Atom(name_) {
    if (name_ === void 0) {
      name_ =  "Atom@" + getNextId() ;
    }

    this.name_ = void 0;
    this.isPendingUnobservation_ = false;
    this.isBeingObserved_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
  } // onBecomeObservedListeners


  var _proto = Atom.prototype;

  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function (listener) {
        return listener();
      });
    }
  };

  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function (listener) {
        return listener();
      });
    }
  }
  /**
   * Invoke this method to notify mobx that your atom has been used somehow.
   * Returns true if there is currently a reactive context.
   */
  ;

  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  }
  /**
   * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
   */
  ;

  _proto.reportChanged = function reportChanged() {
    startBatch();
    propagateChanged(this);
    endBatch();
  };

  _proto.toString = function toString() {
    return this.name_;
  };

  return Atom;
}();
var isAtom = /*#__PURE__*/createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }

  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }

  var atom = new Atom(name); // default `noop` listener will not initialize the hook Set

  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }

  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }

  return atom;
}

function identityComparer(a, b) {
  return a === b;
}

function structuralComparer(a, b) {
  return deepEqual(a, b);
}

function shallowComparer(a, b) {
  return deepEqual(a, b, 1);
}

function defaultComparer(a, b) {
  if (Object.is) return Object.is(a, b);
  return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;
}

var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};

function deepEnhancer(v, _, name) {
  // it is an observable already, done
  if (isObservable(v)) return v; // something that can be converted and mutated?

  if (Array.isArray(v)) return observable.array(v, {
    name: name
  });
  if (isPlainObject(v)) return observable.object(v, undefined, {
    name: name
  });
  if (isES6Map(v)) return observable.map(v, {
    name: name
  });
  if (isES6Set(v)) return observable.set(v, {
    name: name
  });

  if (typeof v === "function" && !isAction(v) && !isFlow(v)) {
    if (isGenerator(v)) {
      return flow(v);
    } else {
      return autoAction(name, v);
    }
  }

  return v;
}
function shallowEnhancer(v, _, name) {
  if (v === undefined || v === null) return v;
  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) return v;
  if (Array.isArray(v)) return observable.array(v, {
    name: name,
    deep: false
  });
  if (isPlainObject(v)) return observable.object(v, undefined, {
    name: name,
    deep: false
  });
  if (isES6Map(v)) return observable.map(v, {
    name: name,
    deep: false
  });
  if (isES6Set(v)) return observable.set(v, {
    name: name,
    deep: false
  });
  die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function referenceEnhancer(newValue) {
  // never turn into an observable
  return newValue;
}
function refStructEnhancer(v, oldValue) {
  if ( isObservable(v)) die("observable.struct should not be used with observable values");
  if (deepEqual(v, oldValue)) return oldValue;
  return v;
}

var OVERRIDE = "override";
var override = /*#__PURE__*/createDecoratorAnnotation({
  annotationType_: OVERRIDE,
  make_: make_,
  extend_: extend_
});
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}

function make_(adm, key) {
  // Must not be plain object
  if ( adm.isPlainObject_) {
    die("Cannot apply '" + this.annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + this.annotationType_ + "' cannot be used on plain objects."));
  } // Must override something


  if ( !hasProp(adm.appliedAnnotations_, key)) {
    die("'" + adm.name_ + "." + key.toString() + "' is annotated with '" + this.annotationType_ + "', " + "but no such annotated member was found on prototype.");
  }

  return 0
  /* Cancel */
  ;
}

function extend_(adm, key, descriptor, proxyTrap) {
  die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}

function createActionAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$1,
    extend_: extend_$1
  };
}

function make_$1(adm, key, descriptor, source) {
  var _this$options_;

  // bound
  if ((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0
    /* Cancel */
    : 1
    /* Break */
    ;
  } // own


  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0
    /* Cancel */
    : 2
    /* Continue */
    ;
  } // prototype


  if (isAction(descriptor.value)) {
    // A prototype could have been annotated already by other constructor,
    // rest of the proto chain must be annotated already
    return 1
    /* Break */
    ;
  }

  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2
  /* Continue */
  ;
}

function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}

function assertActionDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;

  if ( !isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
  }
}

function createActionDescriptor(adm, annotation, key, descriptor, // provides ability to disable safeDescriptors for prototypes
safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3;

  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }

  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;

  if ((_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.bound) {
    var _adm$proxy_;

    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }

  return {
    value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}

function createFlowAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$2,
    extend_: extend_$2
  };
}

function make_$2(adm, key, descriptor, source) {
  var _this$options_;

  // own
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0
    /* Cancel */
    : 2
    /* Continue */
    ;
  } // prototype
  // bound - must annotate protos to support super.flow()


  if (((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) && !isFlow(adm.target_[key])) {
    if (this.extend_(adm, key, descriptor, false) === null) return 0
    /* Cancel */
    ;
  }

  if (isFlow(descriptor.value)) {
    // A prototype could have been annotated already by other constructor,
    // rest of the proto chain must be annotated already
    return 1
    /* Break */
    ;
  }

  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2
  /* Continue */
  ;
}

function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;

  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}

function assertFlowDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;

  if ( !isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
  }
}

function createFlowDescriptor(adm, annotation, key, descriptor, bound, // provides ability to disable safeDescriptors for prototypes
safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }

  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;

  if (bound) {
    var _adm$proxy_;

    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }

  return {
    value: flow(value),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}

function createComputedAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$3,
    extend_: extend_$3
  };
}

function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0
  /* Cancel */
  : 1
  /* Break */
  ;
}

function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}

function assertComputedDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var get = _ref2.get;

  if ( !get) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
  }
}

function createObservableAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$4,
    extend_: extend_$4
  };
}

function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0
  /* Cancel */
  : 1
  /* Break */
  ;
}

function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;

  assertObservableDescriptor(adm, this, key, descriptor);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}

function assertObservableDescriptor(adm, _ref, key, descriptor) {
  var annotationType_ = _ref.annotationType_;

  if ( !("value" in descriptor)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
  }
}

var AUTO = "true";
var autoAnnotation = /*#__PURE__*/createAutoAnnotation();
function createAutoAnnotation(options) {
  return {
    annotationType_: AUTO,
    options_: options,
    make_: make_$5,
    extend_: extend_$5
  };
}

function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;

  // getter -> computed
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  } // lone setter -> action setter


  if (descriptor.set) {
    // TODO make action applicable to setter and delegate to action.make_
    var set = createAction(key.toString(), descriptor.set); // own

    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set
      }) === null ? 0
      /* Cancel */
      : 2
      /* Continue */
      ;
    } // proto


    defineProperty(source, key, {
      configurable: true,
      set: set
    });
    return 2
    /* Continue */
    ;
  } // function on proto -> autoAction/flow


  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;

    if (isGenerator(descriptor.value)) {
      var _this$options_;

      var flowAnnotation = ((_this$options_ = this.options_) == null ? void 0 : _this$options_.autoBind) ? flow.bound : flow;
      return flowAnnotation.make_(adm, key, descriptor, source);
    }

    var actionAnnotation = ((_this$options_2 = this.options_) == null ? void 0 : _this$options_2.autoBind) ? autoAction.bound : autoAction;
    return actionAnnotation.make_(adm, key, descriptor, source);
  } // other -> observable
  // Copy props from proto as well, see test:
  // "decorate should work with Object.create"


  var observableAnnotation = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable; // if function respect autoBind option

  if (typeof descriptor.value === "function" && ((_this$options_4 = this.options_) == null ? void 0 : _this$options_4.autoBind)) {
    var _adm$proxy_;

    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }

  return observableAnnotation.make_(adm, key, descriptor, source);
}

function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;

  // getter -> computed
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  } // lone setter -> action setter


  if (descriptor.set) {
    // TODO make action applicable to setter and delegate to action.extend_
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  } // other -> observable
  // if function respect autoBind option


  if (typeof descriptor.value === "function" && ((_this$options_5 = this.options_) == null ? void 0 : _this$options_5.autoBind)) {
    var _adm$proxy_2;

    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }

  var observableAnnotation = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
  return observableAnnotation.extend_(adm, key, descriptor, proxyTrap);
}

var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct"; // Predefined bags of create observable options, to avoid allocating temporarily option objects
// in the majority of cases

var defaultCreateObservableOptions = {
  deep: true,
  name: undefined,
  defaultDecorator: undefined,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = /*#__PURE__*/createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options) {
  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
}
function getAnnotationFromOptions(options) {
  var _options$defaultDecor;

  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : undefined;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;

  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
/**
 * Turns an object, array or function into a reactive structure.
 * @param v the value which should become observable.
 */

function createObservable(v, arg2, arg3) {
  // @observable someProp;
  if (isStringish(arg2)) {
    storeAnnotation(v, arg2, observableAnnotation);
    return;
  } // already observable - ignore


  if (isObservable(v)) return v; // plain object

  if (isPlainObject(v)) return observable.object(v, arg2, arg3); // Array

  if (Array.isArray(v)) return observable.array(v, arg2); // Map

  if (isES6Map(v)) return observable.map(v, arg2); // Set

  if (isES6Set(v)) return observable.set(v, arg2); // other object - ignore

  if (typeof v === "object" && v !== null) return v; // anything else

  return observable.box(v, arg2);
}

Object.assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
  },
  array: function array(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
  },
  map: function map(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
  },
  set: function set(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
  },
  object: function object(props, decorators, options) {
    return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
  },
  ref: /*#__PURE__*/createDecoratorAnnotation(observableRefAnnotation),
  shallow: /*#__PURE__*/createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /*#__PURE__*/createDecoratorAnnotation(observableStructAnnotation)
}; // eslint-disable-next-line

var observable = /*#__PURE__*/assign(createObservable, observableFactories);

var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED);
var computedStructAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
/**
 * Decorator for class properties: @computed get value() { return expr; }.
 * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
 */

var computed = function computed(arg1, arg2) {
  if (isStringish(arg2)) {
    // @computed
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }

  if (isPlainObject(arg1)) {
    // @computed({ options })
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  } // computed(expr, options?)


  {
    if (!isFunction(arg1)) die("First argument to `computed` should be an expression.");
    if (isFunction(arg2)) die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
  }

  var opts = isPlainObject(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  /* for generated name */

  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = /*#__PURE__*/createDecoratorAnnotation(computedStructAnnotation);

var _getDescriptor$config, _getDescriptor;
// mobx versions

var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /*#__PURE__*/getDescriptor(function () {}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false; // we can safely recycle this object

var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn, autoAction, ref) {
  if (autoAction === void 0) {
    autoAction = false;
  }

  {
    if (!isFunction(fn)) die("`action` can only be invoked on functions");
    if (typeof actionName !== "string" || !actionName) die("actions should have valid names, got: '" + actionName + "'");
  }

  function res() {
    return executeAction(actionName, autoAction, fn, ref || this, arguments);
  }

  res.isMobxAction = true;

  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    Object.defineProperty(res, "name", tmpNameDescriptor);
  }

  return res;
}
function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);

  try {
    return fn.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, // true for autoAction
scope, args) {
  var notifySpy_ =  isSpyEnabled() && !!actionName;
  var startTime_ = 0;

  if ( notifySpy_) {
    startTime_ = Date.now();
    var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: actionName,
      object: scope,
      arguments: flattenedArgs
    });
  }

  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges; // by default preserve previous allow

  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }

  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_: prevDerivation_,
    prevAllowStateChanges_: prevAllowStateChanges_,
    prevAllowStateReads_: prevAllowStateReads_,
    notifySpy_: notifySpy_,
    startTime_: startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }

  currentActionId = runInfo.parentActionId_;

  if (runInfo.error_ !== undefined) {
    globalState.suppressReactionErrors = true;
  }

  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) untrackedEnd(runInfo.prevDerivation_);

  if ( runInfo.notifySpy_) {
    spyReportEnd({
      time: Date.now() - runInfo.startTime_
    });
  }

  globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges, func) {
  var prev = allowStateChangesStart(allowStateChanges);

  try {
    return func();
  } finally {
    allowStateChangesEnd(prev);
  }
}
function allowStateChangesStart(allowStateChanges) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}

var _Symbol$toPrimitive;
var CREATE = "create";
_Symbol$toPrimitive = Symbol.toPrimitive;
var ObservableValue = /*#__PURE__*/function (_Atom) {
  _inheritsLoose(ObservableValue, _Atom);

  function ObservableValue(value, enhancer, name_, notifySpy, equals) {
    var _this;

    if (name_ === void 0) {
      name_ =  "ObservableValue@" + getNextId() ;
    }

    if (notifySpy === void 0) {
      notifySpy = true;
    }

    if (equals === void 0) {
      equals = comparer["default"];
    }

    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, undefined, name_);

    if ( notifySpy && isSpyEnabled()) {
      // only notify spy if this is a stand-alone observable
      spyReport({
        type: CREATE,
        object: _assertThisInitialized(_this),
        observableKind: "value",
        debugObjectName: _this.name_,
        newValue: "" + _this.value_
      });
    }

    return _this;
  }

  var _proto = ObservableValue.prototype;

  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== undefined) return this.dehancer(value);
    return value;
  };

  _proto.set = function set(newValue) {
    var oldValue = this.value_;
    newValue = this.prepareNewValue_(newValue);

    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();

      if ( notifySpy) {
        spyReportStart({
          type: UPDATE,
          object: this,
          observableKind: "value",
          debugObjectName: this.name_,
          newValue: newValue,
          oldValue: oldValue
        });
      }

      this.setNewValue_(newValue);
      if ( notifySpy) spyReportEnd();
    }
  };

  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    checkIfStateModificationsAreAllowed(this);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue: newValue
      });
      if (!change) return globalState.UNCHANGED;
      newValue = change.newValue;
    } // apply modifier


    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };

  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();

    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue: newValue,
        oldValue: oldValue
      });
    }
  };

  _proto.get = function get() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately) listener({
      observableKind: "value",
      debugObjectName: this.name_,
      object: this,
      type: UPDATE,
      newValue: this.value_,
      oldValue: undefined
    });
    return registerListener(this, listener);
  };

  _proto.raw = function raw() {
    // used by MST ot get undehanced value
    return this.value_;
  };

  _proto.toJSON = function toJSON() {
    return this.get();
  };

  _proto.toString = function toString() {
    return this.name_ + "[" + this.value_ + "]";
  };

  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };

  _proto[_Symbol$toPrimitive] = function () {
    return this.valueOf();
  };

  return ObservableValue;
}(Atom);
var isObservableValue = /*#__PURE__*/createInstanceofPredicate("ObservableValue", ObservableValue);

var _Symbol$toPrimitive$1;
/**
 * A node in the state dependency root that observes other nodes, and can be observed itself.
 *
 * ComputedValue will remember the result of the computation for the duration of the batch, or
 * while being observed.
 *
 * During this time it will recompute only when one of its direct dependencies changed,
 * but only when it is being accessed with `ComputedValue.get()`.
 *
 * Implementation description:
 * 1. First time it's being accessed it will compute and remember result
 *    give back remembered result until 2. happens
 * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
 * 3. When it's being accessed, recompute if any shallow dependency changed.
 *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
 *    go to step 2. either way
 *
 * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
 */

_Symbol$toPrimitive$1 = Symbol.toPrimitive;
var ComputedValue = /*#__PURE__*/function () {
  // nodes we are looking at. Our value depends on these nodes
  // during tracking it's an array with new observed observers
  // to check for cycles
  // N.B: unminified as it is used by MST

  /**
   * Create a new computed value based on a function expression.
   *
   * The `name` property is for debug purposes only.
   *
   * The `equals` property specifies the comparer function to use to determine if a newly produced
   * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
   * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.
   * Structural comparison can be convenient if you always produce a new aggregated object and
   * don't want to notify observers if it is structurally the same.
   * This is useful for working with vectors, mouse coordinates etc.
   */
  function ComputedValue(options) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.isBeingObserved_ = false;
    this.isPendingUnobservation_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.isComputing_ = false;
    this.isRunningSetter_ = false;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options.get) die(31);
    this.derivation = options.get;
    this.name_ = options.name || ( "ComputedValue@" + getNextId() );

    if (options.set) {
      this.setter_ = createAction( this.name_ + "-setter" , options.set);
    }

    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options.context;
    this.requiresReaction_ = !!options.requiresReaction;
    this.keepAlive_ = !!options.keepAlive;
  }

  var _proto = ComputedValue.prototype;

  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };

  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function (listener) {
        return listener();
      });
    }
  };

  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function (listener) {
        return listener();
      });
    }
  }
  /**
   * Returns the current value of this computed value.
   * Will evaluate its computation first if needed.
   */
  ;

  _proto.get = function get() {
    if (this.isComputing_) die(32, this.name_, this.derivation);

    if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch(); // See perf test 'computed memoization'

        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);

      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext) globalState.trackingContext = this;
        if (this.trackAndCompute()) propagateChangeConfirmed(this);
        globalState.trackingContext = prevTrackingContext;
      }
    }

    var result = this.value_;
    if (isCaughtException(result)) throw result.cause;
    return result;
  };

  _proto.set = function set(value) {
    if (this.setter_) {
      if (this.isRunningSetter_) die(33, this.name_);
      this.isRunningSetter_ = true;

      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter_ = false;
      }
    } else die(34, this.name_);
  };

  _proto.trackAndCompute = function trackAndCompute() {
    // N.B: unminified as it is used by MST
    var oldValue = this.value_;
    var wasSuspended =
    /* see #1208 */
    this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;
    var newValue = this.computeValue_(true);

    if ( isSpyEnabled()) {
      spyReport({
        observableKind: "computed",
        debugObjectName: this.name_,
        object: this.scope_,
        type: "update",
        oldValue: this.value_,
        newValue: newValue
      });
    }

    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);

    if (changed) {
      this.value_ = newValue;
    }

    return changed;
  };

  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing_ = true; // don't allow state changes during computation

    var prev = allowStateChangesStart(false);
    var res;

    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e) {
          res = new CaughtException(e);
        }
      }
    }

    allowStateChangesEnd(prev);
    this.isComputing_ = false;
    return res;
  };

  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = undefined; // don't hold on to computed value!

      if ( this.isTracing_ !== TraceMode.NONE) {
        console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
      }
    }
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;

    var firstTime = true;
    var prevValue = undefined;
    return autorun(function () {
      // TODO: why is this in a different place than the spyReport() function? in all other observables it's called in the same place
      var newValue = _this.get();

      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue: newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }

      firstTime = false;
      prevValue = newValue;
    });
  };

  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {

    if (this.isTracing_ !== TraceMode.NONE) {
      console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }

    if (globalState.computedRequiresReaction || this.requiresReaction_) {
      console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
  };

  _proto.toString = function toString() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };

  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };

  _proto[_Symbol$toPrimitive$1] = function () {
    return this.valueOf();
  };

  return ComputedValue;
}();
var isComputedValue = /*#__PURE__*/createInstanceofPredicate("ComputedValue", ComputedValue);

var IDerivationState_;

(function (IDerivationState_) {
  // before being run or (outside batch and not being observed)
  // at this point derivation is not holding any data about dependency tree
  IDerivationState_[IDerivationState_["NOT_TRACKING_"] = -1] = "NOT_TRACKING_"; // no shallow dependency changed since last computation
  // won't recalculate derivation
  // this is what makes mobx fast

  IDerivationState_[IDerivationState_["UP_TO_DATE_"] = 0] = "UP_TO_DATE_"; // some deep dependency changed, but don't know if shallow dependency changed
  // will require to check first if UP_TO_DATE or POSSIBLY_STALE
  // currently only ComputedValue will propagate POSSIBLY_STALE
  //
  // having this state is second big optimization:
  // don't have to recompute on every dependency change, but only when it's needed

  IDerivationState_[IDerivationState_["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_"; // A shallow dependency has changed since last computation and the derivation
  // will need to recompute when it's needed next.

  IDerivationState_[IDerivationState_["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));

var TraceMode;

(function (TraceMode) {
  TraceMode[TraceMode["NONE"] = 0] = "NONE";
  TraceMode[TraceMode["LOG"] = 1] = "LOG";
  TraceMode[TraceMode["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));

var CaughtException = function CaughtException(cause) {
  this.cause = void 0;
  this.cause = cause; // Empty
};
function isCaughtException(e) {
  return e instanceof CaughtException;
}
/**
 * Finds out whether any dependency of the derivation has actually changed.
 * If dependenciesState is 1 then it will recalculate dependencies,
 * if any dependency changed it will propagate it by changing dependenciesState to 2.
 *
 * By iterating over the dependencies in the same order that they were reported and
 * stopping on the first change, all the recalculations are only called for ComputedValues
 * that will be tracked by derivation. That is because we assume that if the first x
 * dependencies of the derivation doesn't change then the derivation should run the same way
 * up until accessing x-th dependency.
 */

function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;

    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;

    case IDerivationState_.POSSIBLY_STALE_:
      {
        // state propagation can occur outside of action/reactive context #2195
        var prevAllowStateReads = allowStateReadsStart(true);
        var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.

        var obs = derivation.observing_,
            l = obs.length;

        for (var i = 0; i < l; i++) {
          var obj = obs[i];

          if (isComputedValue(obj)) {
            if (globalState.disableErrorBoundaries) {
              obj.get();
            } else {
              try {
                obj.get();
              } catch (e) {
                // we are not interested in the value *or* exception at this moment, but if there is one, notify all
                untrackedEnd(prevUntracked);
                allowStateReadsEnd(prevAllowStateReads);
                return true;
              }
            } // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.
            // and `derivation` is an observer of `obj`
            // invariantShouldCompute(derivation)


            if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
        }

        changeDependenciesStateTo0(derivation);
        untrackedEnd(prevUntracked);
        allowStateReadsEnd(prevAllowStateReads);
        return false;
      }
  }
}
function isComputingDerivation() {
  return globalState.trackingDerivation !== null; // filter out actions inside computations
}
function checkIfStateModificationsAreAllowed(atom) {

  var hasObservers = atom.observers_.size > 0; // Should not be possible to change observed state outside strict mode, except during initialization, see #563

  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "always")) console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
}
function checkIfStateReadsAreAllowed(observable) {
  if ( !globalState.allowStateReads && globalState.observableRequiresReaction) {
    console.warn("[mobx] Observable '" + observable.name_ + "' being read outside a reactive context.");
  }
}
/**
 * Executes the provided function `f` and tracks which observables are being accessed.
 * The tracking information is stored on the `derivation` object and the derivation is registered
 * as observer of any of the accessed observables.
 */

function trackDerivedFunction(derivation, f, context) {
  var prevAllowStateReads = allowStateReadsStart(true); // pre allocate array allocation + room for variation in deps
  // array will be trimmed by bindDependencies

  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(derivation.observing_.length + 100);
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;

  if (globalState.disableErrorBoundaries === true) {
    result = f.call(context);
  } else {
    try {
      result = f.call(context);
    } catch (e) {
      result = new CaughtException(e);
    }
  }

  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  warnAboutDerivationWithoutDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}

function warnAboutDerivationWithoutDependencies(derivation) {
  if (derivation.observing_.length !== 0) return;

  if (globalState.reactionRequiresObservable || derivation.requiresObservable_) {
    console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
  }
}
/**
 * diffs newObserving with observing.
 * update observing to be newObserving with unique observables
 * notify observers that become observed/unobserved
 */


function bindDependencies(derivation) {
  // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_; // Go through all new observables and check diffValue: (this list can contain duplicates):
  //   0: first occurrence, change to 1 and keep it
  //   1: extra occurrence, drop it

  var i0 = 0,
      l = derivation.unboundDepsCount_;

  for (var i = 0; i < l; i++) {
    var dep = observing[i];

    if (dep.diffValue_ === 0) {
      dep.diffValue_ = 1;
      if (i0 !== i) observing[i0] = dep;
      i0++;
    } // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
    // not hitting the condition


    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }

  observing.length = i0;
  derivation.newObserving_ = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)
  // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
  //   0: it's not in new observables, unobserve it
  //   1: it keeps being observed, don't want to notify it. change to 0

  l = prevObserving.length;

  while (l--) {
    var _dep = prevObserving[l];

    if (_dep.diffValue_ === 0) {
      removeObserver(_dep, derivation);
    }

    _dep.diffValue_ = 0;
  } // Go through all new observables and check diffValue: (now it should be unique)
  //   0: it was set to 0 in last loop. don't need to do anything.
  //   1: it wasn't observed, let's observe it. set back to 0


  while (i0--) {
    var _dep2 = observing[i0];

    if (_dep2.diffValue_ === 1) {
      _dep2.diffValue_ = 0;
      addObserver(_dep2, derivation);
    }
  } // Some new observed derivations may become stale during this derivation computation
  // so they have had no chance to propagate staleness (#916)


  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}

function clearObserving(derivation) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i = obs.length;

  while (i--) {
    removeObserver(obs[i], derivation);
  }

  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action) {
  var prev = untrackedStart();

  try {
    return action();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
/**
 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
 *
 */

function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) return;
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i = obs.length;

  while (i--) {
    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}

/**
 * These values will persist if global state is reset
 */

var persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"];
var MobXGlobals = function MobXGlobals() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
};
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = /*#__PURE__*/function () {
  var global = /*#__PURE__*/getGlobal();
  if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals) canMergeGlobalState = false;
  if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version) canMergeGlobalState = false;

  if (!canMergeGlobalState) {
    setTimeout(function () {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global.__mobxGlobals) {
    global.__mobxInstanceCount += 1;
    if (!global.__mobxGlobals.UNCHANGED) global.__mobxGlobals.UNCHANGED = {}; // make merge backward compatible

    return global.__mobxGlobals;
  } else {
    global.__mobxInstanceCount = 1;
    return global.__mobxGlobals = /*#__PURE__*/new MobXGlobals();
  }
}();
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) die(36);
  isolateCalled = true;

  if (canMergeGlobalState) {
    var global = getGlobal();
    if (--global.__mobxInstanceCount === 0) global.__mobxGlobals = undefined;
    globalState = new MobXGlobals();
  }
}
function getGlobalState() {
  return globalState;
}
/**
 * For testing purposes only; this will break the internal state of existing observables,
 * but can be used to get back at a stable state after throwing errors
 */

function resetGlobalState() {
  var defaultGlobals = new MobXGlobals();

  for (var key in defaultGlobals) {
    if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];
  }

  globalState.allowStateChanges = !globalState.enforceActions;
}

function hasObservers(observable) {
  return observable.observers_ && observable.observers_.size > 0;
}
function getObservers(observable) {
  return observable.observers_;
} // function invariantObservers(observable: IObservable) {
//     const list = observable.observers
//     const map = observable.observersIndexes
//     const l = list.length
//     for (let i = 0; i < l; i++) {
//         const id = list[i].__mapid
//         if (i) {
//             invariant(map[id] === i, "INTERNAL ERROR maps derivation.__mapid to index in list") // for performance
//         } else {
//             invariant(!(id in map), "INTERNAL ERROR observer on index 0 shouldn't be held in map.") // for performance
//         }
//     }
//     invariant(
//         list.length === 0 || Object.keys(map).length === list.length - 1,
//         "INTERNAL ERROR there is no junk in map"
//     )
// }

function addObserver(observable, node) {
  // invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");
  // invariantObservers(observable);
  observable.observers_.add(node);
  if (observable.lowestObserverState_ > node.dependenciesState_) observable.lowestObserverState_ = node.dependenciesState_; // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR didn't add node");
}
function removeObserver(observable, node) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");
  // invariantObservers(observable);
  observable.observers_["delete"](node);

  if (observable.observers_.size === 0) {
    // deleting last observer
    queueForUnobservation(observable);
  } // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR remove already removed node2");

}
function queueForUnobservation(observable) {
  if (observable.isPendingUnobservation_ === false) {
    // invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");
    observable.isPendingUnobservation_ = true;
    globalState.pendingUnobservations.push(observable);
  }
}
/**
 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
 * During a batch `onBecomeUnobserved` will be called at most once per observable.
 * Avoids unnecessary recalculations.
 */

function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions(); // the batch is actually about to finish, all unobserving should happen here.

    var list = globalState.pendingUnobservations;

    for (var i = 0; i < list.length; i++) {
      var observable = list[i];
      observable.isPendingUnobservation_ = false;

      if (observable.observers_.size === 0) {
        if (observable.isBeingObserved_) {
          // if this observable had reactive observers, trigger the hooks
          observable.isBeingObserved_ = false;
          observable.onBUO();
        }

        if (observable instanceof ComputedValue) {
          // computed values are automatically teared down when the last observer leaves
          // this process happens recursively, this computed might be the last observabe of another, etc..
          observable.suspend_();
        }
      }
    }

    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable) {
  checkIfStateReadsAreAllowed(observable);
  var derivation = globalState.trackingDerivation;

  if (derivation !== null) {
    /**
     * Simple optimization, give each derivation run an unique id (runId)
     * Check if last time this observable was accessed the same runId is used
     * if this is the case, the relation is already known
     */
    if (derivation.runId_ !== observable.lastAccessedBy_) {
      observable.lastAccessedBy_ = derivation.runId_; // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...

      derivation.newObserving_[derivation.unboundDepsCount_++] = observable;

      if (!observable.isBeingObserved_ && globalState.trackingContext) {
        observable.isBeingObserved_ = true;
        observable.onBO();
      }
    }

    return true;
  } else if (observable.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable);
  }

  return false;
} // function invariantLOS(observable: IObservable, msg: string) {
//     // it's expensive so better not run it in produciton. but temporarily helpful for testing
//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)
//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`
//     throw new Error(
//         "lowestObserverState is wrong for " +
//             msg +
//             " because " +
//             min +
//             " < " +
//             observable.lowestObserverState
//     )
// }

/**
 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
 * It will propagate changes to observers from previous run
 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
 * Hopefully self reruning autoruns aren't a feature people should depend on
 * Also most basic use cases should be ok
 */
// Called by Atom when its value changes

function propagateChanged(observable) {
  // invariantLOS(observable, "changed start");
  if (observable.lowestObserverState_ === IDerivationState_.STALE_) return;
  observable.lowestObserverState_ = IDerivationState_.STALE_; // Ideally we use for..of here, but the downcompiled version is really slow...

  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      if ( d.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d, observable);
      }

      d.onBecomeStale_();
    }

    d.dependenciesState_ = IDerivationState_.STALE_;
  }); // invariantLOS(observable, "changed end");
} // Called by ComputedValue when it recalculate and its value changed

function propagateChangeConfirmed(observable) {
  // invariantLOS(observable, "confirmed start");
  if (observable.lowestObserverState_ === IDerivationState_.STALE_) return;
  observable.lowestObserverState_ = IDerivationState_.STALE_;
  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d.dependenciesState_ = IDerivationState_.STALE_;

      if ( d.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d, observable);
      }
    } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ // this happens during computing of `d`, just keep lowestObserverState up to date.
    ) {
        observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
      }
  }); // invariantLOS(observable, "confirmed end");
} // Used by computed when its dependency changed, but we don't wan't to immediately recompute.

function propagateMaybeChanged(observable) {
  // invariantLOS(observable, "maybe start");
  if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) return;
  observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d.onBecomeStale_();
    }
  }); // invariantLOS(observable, "maybe end");
}

function logTraceInfo(derivation, observable) {
  console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable.name_ + "'");

  if (derivation.isTracing_ === TraceMode.BREAK) {
    var lines = [];
    printDepTree(getDependencyTree(derivation), lines, 1); // prettier-ignore

    new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
}

function printDepTree(tree, lines, depth) {
  if (lines.length >= 1000) {
    lines.push("(and many more)");
    return;
  }

  lines.push("" + new Array(depth).join("\t") + tree.name); // MWE: not the fastest, but the easiest way :)

  if (tree.dependencies) tree.dependencies.forEach(function (child) {
    return printDepTree(child, lines, depth + 1);
  });
}

var Reaction = /*#__PURE__*/function () {
  // nodes we are looking at. Our value depends on these nodes
  function Reaction(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ =  "Reaction@" + getNextId() ;
    }

    if (requiresObservable_ === void 0) {
      requiresObservable_ = false;
    }

    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.isDisposed_ = false;
    this.isScheduled_ = false;
    this.isTrackPending_ = false;
    this.isRunning_ = false;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }

  var _proto = Reaction.prototype;

  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };

  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled_) {
      this.isScheduled_ = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };

  _proto.isScheduled = function isScheduled() {
    return this.isScheduled_;
  }
  /**
   * internal, use schedule() if you intend to kick off a reaction
   */
  ;

  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed_) {
      startBatch();
      this.isScheduled_ = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;

      if (shouldCompute(this)) {
        this.isTrackPending_ = true;

        try {
          this.onInvalidate_();

          if ("development" !== "production" && this.isTrackPending_ && isSpyEnabled()) {
            // onInvalidate didn't trigger track right away..
            spyReport({
              name: this.name_,
              type: "scheduled-reaction"
            });
          }
        } catch (e) {
          this.reportExceptionInDerivation_(e);
        }
      }

      globalState.trackingContext = prev;
      endBatch();
    }
  };

  _proto.track = function track(fn) {
    if (this.isDisposed_) {
      return; // console.warn("Reaction already disposed") // Note: Not a warning / error in mobx 4 either
    }

    startBatch();
    var notify = isSpyEnabled();
    var startTime;

    if ( notify) {
      startTime = Date.now();
      spyReportStart({
        name: this.name_,
        type: "reaction"
      });
    }

    this.isRunning_ = true;
    var prevReaction = globalState.trackingContext; // reactions could create reactions...

    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn, undefined);
    globalState.trackingContext = prevReaction;
    this.isRunning_ = false;
    this.isTrackPending_ = false;

    if (this.isDisposed_) {
      // disposed during last run. Clean up everything that was bound after the dispose call.
      clearObserving(this);
    }

    if (isCaughtException(result)) this.reportExceptionInDerivation_(result.cause);

    if ( notify) {
      spyReportEnd({
        time: Date.now() - startTime
      });
    }

    endBatch();
  };

  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;

    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }

    if (globalState.disableErrorBoundaries) throw error;
    var message =  "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" ;

    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
      /** If debugging brought you here, please, read the above message :-). Tnx! */
    } else console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)"); // prettier-ignore


    if ( isSpyEnabled()) {
      spyReport({
        type: "error",
        name: this.name_,
        message: message,
        error: "" + error
      });
    }

    globalState.globalReactionErrorHandlers.forEach(function (f) {
      return f(error, _this);
    });
  };

  _proto.dispose = function dispose() {
    if (!this.isDisposed_) {
      this.isDisposed_ = true;

      if (!this.isRunning_) {
        // if disposed while running, clean up later. Maybe not optimal, but rare case
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };

  _proto.getDisposer_ = function getDisposer_() {
    var r = this.dispose.bind(this);
    r[$mobx] = this;
    return r;
  };

  _proto.toString = function toString() {
    return "Reaction[" + this.name_ + "]";
  };

  _proto.trace = function trace$1(enterBreakPoint) {
    if (enterBreakPoint === void 0) {
      enterBreakPoint = false;
    }

    trace(this, enterBreakPoint);
  };

  return Reaction;
}();
function onReactionError(handler) {
  globalState.globalReactionErrorHandlers.push(handler);
  return function () {
    var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
    if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);
  };
}
/**
 * Magic number alert!
 * Defines within how many times a reaction is allowed to re-trigger itself
 * until it is assumed that this is gonna be a never ending loop...
 */

var MAX_REACTION_ITERATIONS = 100;

var reactionScheduler = function reactionScheduler(f) {
  return f();
};

function runReactions() {
  // Trampolining, if runReactions are already running, new reactions will be picked up
  if (globalState.inBatch > 0 || globalState.isRunningReactions) return;
  reactionScheduler(runReactionsHelper);
}

function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0; // While running reactions, new reactions might be triggered.
  // Hence we work with two variables and check whether
  // we converge to no remaining reactions after a while.

  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error( "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) );
      allReactions.splice(0); // clear reactions
    }

    var remainingReactions = allReactions.splice(0);

    for (var i = 0, l = remainingReactions.length; i < l; i++) {
      remainingReactions[i].runReaction_();
    }
  }

  globalState.isRunningReactions = false;
}

var isReaction = /*#__PURE__*/createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;

  reactionScheduler = function reactionScheduler(f) {
    return fn(function () {
      return baseScheduler(f);
    });
  };
}

function isSpyEnabled() {
  return  !!globalState.spyListeners.length;
}
function spyReport(event) {

  if (!globalState.spyListeners.length) return;
  var listeners = globalState.spyListeners;

  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](event);
  }
}
function spyReportStart(event) {

  var change = _extends({}, event, {
    spyReportStart: true
  });

  spyReport(change);
}
var END_EVENT = {
  type: "report-end",
  spyReportEnd: true
};
function spyReportEnd(change) {
  if (change) spyReport(_extends({}, change, {
    type: "report-end",
    spyReportEnd: true
  }));else spyReport(END_EVENT);
}
function spy(listener) {
  {
    globalState.spyListeners.push(listener);
    return once(function () {
      globalState.spyListeners = globalState.spyListeners.filter(function (l) {
        return l !== listener;
      });
    });
  }
}

var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = /*#__PURE__*/createActionAnnotation(ACTION);
var actionBoundAnnotation = /*#__PURE__*/createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});

function createActionFactory(autoAction) {
  var res = function action(arg1, arg2) {
    // action(fn() {})
    if (isFunction(arg1)) return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction); // action("name", fn() {})

    if (isFunction(arg2)) return createAction(arg1, arg2, autoAction); // @action

    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation);
    } // action("name") & @action("name")


    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction
      }));
    }

    die("Invalid arguments for `action`");
  };

  return res;
}

var action = /*#__PURE__*/createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = /*#__PURE__*/createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /*#__PURE__*/createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /*#__PURE__*/createDecoratorAnnotation(autoActionBoundAnnotation);
function runInAction(fn) {
  return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined);
}
function isAction(thing) {
  return isFunction(thing) && thing.isMobxAction === true;
}

/**
 * Creates a named reactive view and keeps it alive, so that the view is always
 * updated if one of the dependencies changes, even when the view is not further used by something else.
 * @param view The reactive view
 * @returns disposer function, which can be used to stop the view from being updated in the future.
 */

function autorun(view, opts) {
  var _opts$name, _opts;

  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }

  {
    if (!isFunction(view)) die("Autorun expects a function as first argument");
    if (isAction(view)) die("Autorun does not accept actions since actions are untrackable");
  }

  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name :  view.name || "Autorun@" + getNextId() ;
  var runSync = !opts.scheduler && !opts.delay;
  var reaction;

  if (runSync) {
    // normal autorun
    reaction = new Reaction(name, function () {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts); // debounced autorun

    var isScheduled = false;
    reaction = new Reaction(name, function () {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function () {
          isScheduled = false;
          if (!reaction.isDisposed_) reaction.track(reactionRunner);
        });
      }
    }, opts.onError, opts.requiresObservable);
  }

  function reactionRunner() {
    view(reaction);
  }

  reaction.schedule_();
  return reaction.getDisposer_();
}

var run = function run(f) {
  return f();
};

function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function (f) {
    return setTimeout(f, opts.delay);
  } : run;
}

function reaction(expression, effect, opts) {
  var _opts$name2;

  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }

  {
    if (!isFunction(expression) || !isFunction(effect)) die("First and second argument to reaction should be functions");
    if (!isPlainObject(opts)) die("Third argument of reactions should be an object");
  }

  var name = (_opts$name2 = opts.name) != null ? _opts$name2 :  "Reaction@" + getNextId() ;
  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var oldValue = undefined; // only an issue with fireImmediately

  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
  var r = new Reaction(name, function () {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);

  function reactionRunner() {
    isScheduled = false;
    if (r.isDisposed_) return;
    var changed = false;
    r.track(function () {
      var nextValue = allowStateChanges(false, function () {
        return expression(r);
      });
      changed = firstTime || !equals(value, nextValue);
      oldValue = value;
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately) effectAction(value, oldValue, r);else if (!firstTime && changed) effectAction(value, oldValue, r);
    firstTime = false;
  }

  r.schedule_();
  return r.getDisposer_();
}

function wrapErrorHandler(errorHandler, baseFn) {
  return function () {
    try {
      return baseFn.apply(this, arguments);
    } catch (e) {
      errorHandler.call(this, e);
    }
  };
}

var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}

function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";

  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = new Set([cb]);
  }

  return function () {
    var hookListeners = atom[listenersKey];

    if (hookListeners) {
      hookListeners["delete"](cb);

      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}

var NEVER = "never";
var ALWAYS = "always";
var OBSERVED = "observed"; // const IF_AVAILABLE = "ifavailable"

function configure(options) {
  if (options.isolateGlobalState === true) {
    isolateGlobalState();
  }

  var useProxies = options.useProxies,
      enforceActions = options.enforceActions;

  if (useProxies !== undefined) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
  }

  if (useProxies === "ifavailable") globalState.verifyProxies = true;

  if (enforceActions !== undefined) {
    var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea;
    globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function (key) {
    if (key in options) globalState[key] = !!options[key];
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;

  if ( globalState.disableErrorBoundaries === true) {
    console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
  }

  if (options.reactionScheduler) {
    setReactionScheduler(options.reactionScheduler);
  }
}

function extendObservable(target, properties, annotations, options) {
  {
    if (arguments.length > 4) die("'extendObservable' expected 2-4 arguments");
    if (typeof target !== "object") die("'extendObservable' expects an object as first argument");
    if (isObservableMap(target)) die("'extendObservable' should not be used on maps, use map.merge instead");
    if (!isPlainObject(properties)) die("'extendObservabe' only accepts plain objects as second argument");
    if (isObservable(properties) || isObservable(annotations)) die("Extending an object with another observable (object) is not supported");
  } // Pull descriptors first, so we don't have to deal with props added by administration ($mobx)


  var descriptors = getOwnPropertyDescriptors(properties);
  var adm = asObservableObject(target, options)[$mobx];
  startBatch();

  try {
    ownKeys(descriptors).forEach(function (key) {
      adm.extend_(key, descriptors[key], // must pass "undefined" for { key: undefined }
      !annotations ? true : key in annotations ? annotations[key] : true);
    });
  } finally {
    endBatch();
  }

  return target;
}

function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}

function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0) result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  return result;
}

function getObserverTree(thing, property) {
  return nodeToObserverTree(getAtom(thing, property));
}

function nodeToObserverTree(node) {
  var result = {
    name: node.name_
  };
  if (hasObservers(node)) result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);
  return result;
}

function unique(list) {
  return Array.from(new Set(list));
}

var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /*#__PURE__*/Object.create(Error.prototype);
function isFlowCancellationError(error) {
  return error instanceof FlowCancellationError;
}
var flowAnnotation = /*#__PURE__*/createFlowAnnotation("flow");
var flowBoundAnnotation = /*#__PURE__*/createFlowAnnotation("flow.bound", {
  bound: true
});
var flow = /*#__PURE__*/Object.assign(function flow(arg1, arg2) {
  // @flow
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  } // flow(fn)


  if ( arguments.length !== 1) die("Flow expects single argument with generator function");
  var generator = arg1;
  var name = generator.name || "<unnamed flow>"; // Implementation based on https://github.com/tj/co/blob/master/index.js

  var res = function res() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = undefined;
    var promise = new Promise(function (resolve, reject) {
      var stepId = 0;
      rejector = reject;

      function onFulfilled(res) {
        pendingPromise = undefined;
        var ret;

        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res);
        } catch (e) {
          return reject(e);
        }

        next(ret);
      }

      function onRejected(err) {
        pendingPromise = undefined;
        var ret;

        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e) {
          return reject(e);
        }

        next(ret);
      }

      function next(ret) {
        if (isFunction(ret == null ? void 0 : ret.then)) {
          // an async iterator
          ret.then(next, reject);
          return;
        }

        if (ret.done) return resolve(ret.value);
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }

      onFulfilled(undefined); // kick off the process
    });
    promise.cancel = action(name + " - runid: " + runId + " - cancel", function () {
      try {
        if (pendingPromise) cancelPromise(pendingPromise); // Finally block can return (or yield) stuff..

        var _res = gen["return"](undefined); // eat anything that promise would do, it's cancelled!


        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop, noop);
        cancelPromise(yieldedPromise); // maybe it can be cancelled :)
        // reject our original promise

        rejector(new FlowCancellationError());
      } catch (e) {
        rejector(e); // there could be a throwing finally block
      }
    });
    return promise;
  };

  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow.bound = /*#__PURE__*/createDecoratorAnnotation(flowBoundAnnotation);

function cancelPromise(promise) {
  if (isFunction(promise.cancel)) promise.cancel();
}

function flowResult(result) {
  return result; // just tricking TypeScript :)
}
function isFlow(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}

function interceptReads(thing, propOrHandler, handler) {
  var target;

  if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
    target = getAdministration(thing);
  } else if (isObservableObject(thing)) {
    if ( !isStringish(propOrHandler)) return die("InterceptReads can only be used with a specific property, not with an object in general");
    target = getAdministration(thing, propOrHandler);
  } else {
    return die("Expected observable map, object or array as first array");
  }

  if ( target.dehancer !== undefined) return die("An intercept reader was already established");
  target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
  return function () {
    target.dehancer = undefined;
  };
}

function intercept(thing, propOrHandler, handler) {
  if (isFunction(handler)) return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);
}

function interceptInterceptable(thing, handler) {
  return getAdministration(thing).intercept_(handler);
}

function interceptProperty(thing, property, handler) {
  return getAdministration(thing, property).intercept_(handler);
}

function _isComputed(value, property) {
  if (property !== undefined) {
    if (isObservableObject(value) === false) return false;
    if (!value[$mobx].values_.has(property)) return false;
    var atom = getAtom(value, property);
    return isComputedValue(atom);
  }

  return isComputedValue(value);
}
function isComputed(value) {
  if ( arguments.length > 1) return die("isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property");
  return _isComputed(value);
}
function isComputedProp(value, propName) {
  if ( !isStringish(propName)) return die("isComputed expected a property name as second argument");
  return _isComputed(value, propName);
}

function _isObservable(value, property) {
  if (!value) return false;

  if (property !== undefined) {
    if ( (isObservableMap(value) || isObservableArray(value))) return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");

    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }

    return false;
  } // For first check, see #701


  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}

function isObservable(value) {
  if ( arguments.length !== 1) die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  return _isObservable(value);
}
function isObservableProp(value, propName) {
  if ( !isStringish(propName)) return die("expected a property name as second argument");
  return _isObservable(value, propName);
}

function keys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].keys_();
  }

  if (isObservableMap(obj) || isObservableSet(obj)) {
    return Array.from(obj.keys());
  }

  if (isObservableArray(obj)) {
    return obj.map(function (_, index) {
      return index;
    });
  }

  die(5);
}
function values(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return obj[key];
    });
  }

  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return obj.get(key);
    });
  }

  if (isObservableSet(obj)) {
    return Array.from(obj.values());
  }

  if (isObservableArray(obj)) {
    return obj.slice();
  }

  die(6);
}
function entries(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj[key]];
    });
  }

  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj.get(key)];
    });
  }

  if (isObservableSet(obj)) {
    return Array.from(obj.entries());
  }

  if (isObservableArray(obj)) {
    return obj.map(function (key, index) {
      return [index, key];
    });
  }

  die(7);
}
function set(obj, key, value) {
  if (arguments.length === 2 && !isObservableSet(obj)) {
    startBatch();
    var _values = key;

    try {
      for (var _key in _values) {
        set(obj, _key, _values[_key]);
      }
    } finally {
      endBatch();
    }

    return;
  }

  if (isObservableObject(obj)) {
    obj[$mobx].set_(key, value);
  } else if (isObservableMap(obj)) {
    obj.set(key, value);
  } else if (isObservableSet(obj)) {
    obj.add(key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") key = parseInt(key, 10);
    if (key < 0) die("Invalid index: '" + key + "'");
    startBatch();
    if (key >= obj.length) obj.length = key + 1;
    obj[key] = value;
    endBatch();
  } else die(8);
}
function remove(obj, key) {
  if (isObservableObject(obj)) {
    obj[$mobx].delete_(key);
  } else if (isObservableMap(obj)) {
    obj["delete"](key);
  } else if (isObservableSet(obj)) {
    obj["delete"](key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") key = parseInt(key, 10);
    obj.splice(key, 1);
  } else {
    die(9);
  }
}
function has(obj, key) {
  if (isObservableObject(obj)) {
    return obj[$mobx].has_(key);
  } else if (isObservableMap(obj)) {
    return obj.has(key);
  } else if (isObservableSet(obj)) {
    return obj.has(key);
  } else if (isObservableArray(obj)) {
    return key >= 0 && key < obj.length;
  }

  die(10);
}
function get(obj, key) {
  if (!has(obj, key)) return undefined;

  if (isObservableObject(obj)) {
    return obj[$mobx].get_(key);
  } else if (isObservableMap(obj)) {
    return obj.get(key);
  } else if (isObservableArray(obj)) {
    return obj[key];
  }

  die(11);
}
function apiDefineProperty(obj, key, descriptor) {
  if (isObservableObject(obj)) {
    return obj[$mobx].defineProperty_(key, descriptor);
  }

  die(39);
}
function apiOwnKeys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].ownKeys_();
  }

  die(38);
}

function observe(thing, propOrCb, cbOrFire, fireImmediately) {
  if (isFunction(cbOrFire)) return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);
}

function observeObservable(thing, listener, fireImmediately) {
  return getAdministration(thing).observe_(listener, fireImmediately);
}

function observeObservableProperty(thing, property, listener, fireImmediately) {
  return getAdministration(thing, property).observe_(listener, fireImmediately);
}

function cache(map, key, value) {
  map.set(key, value);
  return value;
}

function toJSHelper(source, __alreadySeen) {
  if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) return source;
  if (isObservableValue(source) || isComputedValue(source)) return toJSHelper(source.get(), __alreadySeen);

  if (__alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }

  if (isObservableArray(source)) {
    var res = cache(__alreadySeen, source, new Array(source.length));
    source.forEach(function (value, idx) {
      res[idx] = toJSHelper(value, __alreadySeen);
    });
    return res;
  }

  if (isObservableSet(source)) {
    var _res = cache(__alreadySeen, source, new Set());

    source.forEach(function (value) {
      _res.add(toJSHelper(value, __alreadySeen));
    });
    return _res;
  }

  if (isObservableMap(source)) {
    var _res2 = cache(__alreadySeen, source, new Map());

    source.forEach(function (value, key) {
      _res2.set(key, toJSHelper(value, __alreadySeen));
    });
    return _res2;
  } else {
    // must be observable object
    var _res3 = cache(__alreadySeen, source, {});

    apiOwnKeys(source).forEach(function (key) {
      if (objectPrototype.propertyIsEnumerable.call(source, key)) {
        _res3[key] = toJSHelper(source[key], __alreadySeen);
      }
    });
    return _res3;
  }
}
/**
 * Basically, a deep clone, so that no reactive property will exist anymore.
 */


function toJS(source, options) {
  if ( options) die("toJS no longer supports options");
  return toJSHelper(source, new Map());
}

function trace() {
  var enterBreakPoint = false;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (typeof args[args.length - 1] === "boolean") enterBreakPoint = args.pop();
  var derivation = getAtomFromArgs(args);

  if (!derivation) {
    return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }

  if (derivation.isTracing_ === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
  }

  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}

function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;

    case 1:
      return getAtom(args[0]);

    case 2:
      return getAtom(args[0], args[1]);
  }
}

/**
 * During a transaction no views are updated until the end of the transaction.
 * The transaction will be run synchronously nonetheless.
 *
 * @param action a function that updates some reactive state
 * @returns any value that was returned by the 'action' parameter.
 */

function transaction(action, thisArg) {
  if (thisArg === void 0) {
    thisArg = undefined;
  }

  startBatch();

  try {
    return action.apply(thisArg);
  } finally {
    endBatch();
  }
}

function when(predicate, arg1, arg2) {
  if (arguments.length === 1 || arg1 && typeof arg1 === "object") return whenPromise(predicate, arg1);
  return _when(predicate, arg1, arg2 || {});
}

function _when(predicate, effect, opts) {
  var timeoutHandle;

  if (typeof opts.timeout === "number") {
    var error = new Error("WHEN_TIMEOUT");
    timeoutHandle = setTimeout(function () {
      if (!disposer[$mobx].isDisposed_) {
        disposer();
        if (opts.onError) opts.onError(error);else throw error;
      }
    }, opts.timeout);
  }

  opts.name =  opts.name || "When@" + getNextId() ;
  var effectAction = createAction( opts.name + "-effect" , effect); // eslint-disable-next-line

  var disposer = autorun(function (r) {
    // predicate should not change state
    var cond = allowStateChanges(false, predicate);

    if (cond) {
      r.dispose();
      if (timeoutHandle) clearTimeout(timeoutHandle);
      effectAction();
    }
  }, opts);
  return disposer;
}

function whenPromise(predicate, opts) {
  if ( opts && opts.onError) return die("the options 'onError' and 'promise' cannot be combined");
  var cancel;
  var res = new Promise(function (resolve, reject) {
    var disposer = _when(predicate, resolve, _extends({}, opts, {
      onError: reject
    }));

    cancel = function cancel() {
      disposer();
      reject("WHEN_CANCELLED");
    };
  });
  res.cancel = cancel;
  return res;
}

function getAdm(target) {
  return target[$mobx];
} // Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,
// and skip either the internal values map, or the base object with its property descriptors!


var objectProxyTraps = {
  has: function has(target, name) {
    if ( globalState.trackingDerivation) warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
    return getAdm(target).has_(name);
  },
  get: function get(target, name) {
    return getAdm(target).get_(name);
  },
  set: function set(target, name, value) {
    var _getAdm$set_;

    if (!isStringish(name)) return false;

    if ( !getAdm(target).values_.has(name)) {
      warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
    } // null (intercepted) -> true (success)


    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name) {
    var _getAdm$delete_;

    {
      warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
    }

    if (!isStringish(name)) return false; // null (intercepted) -> true (success)

    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty(target, name, descriptor) {
    var _getAdm$definePropert;

    {
      warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
    } // null (intercepted) -> true (success)


    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys(target) {
    if ( globalState.trackingDerivation) warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options) {
  var _target$$mobx, _target$$mobx$proxy_;

  assertProxies();
  target = asObservableObject(target, options);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}

function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function () {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) interceptors.splice(idx, 1);
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();

  try {
    // Interceptor can modify the array, copy it to avoid concurrent modification, see #1950
    var interceptors = [].concat(interceptable.interceptors_ || []);

    for (var i = 0, l = interceptors.length; i < l; i++) {
      change = interceptors[i](change);
      if (change && !change.type) die(14);
      if (!change) break;
    }

    return change;
  } finally {
    untrackedEnd(prevU);
  }
}

function hasListeners(listenable) {
  return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function () {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) listeners.splice(idx, 1);
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) return;
  listeners = listeners.slice();

  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](change);
  }

  untrackedEnd(prevU);
}

function makeObservable(target, annotations, options) {
  var adm = asObservableObject(target, options)[$mobx];
  startBatch();

  try {
    var _annotations;

    // Default to decorators
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target); // Annotate

    ownKeys(annotations).forEach(function (key) {
      return adm.make_(key, annotations[key]);
    });
  } finally {
    endBatch();
  }

  return target;
} // proto[keysSymbol] = new Set<PropertyKey>()

var keysSymbol = /*#__PURE__*/Symbol("mobx-keys");
function makeAutoObservable(target, overrides, options) {
  {
    if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target))) die("'makeAutoObservable' can only be used for classes that don't have a superclass");
    if (isObservableObject(target)) die("makeAutoObservable can only be used on objects not already made observable");
  } // Optimization: avoid visiting protos
  // Assumes that annotation.make_/.extend_ works the same for plain objects


  if (isPlainObject(target)) {
    return extendObservable(target, target, overrides, options);
  }

  var adm = asObservableObject(target, options)[$mobx]; // Optimization: cache keys on proto
  // Assumes makeAutoObservable can be called only once per object and can't be used in subclass

  if (!target[keysSymbol]) {
    var proto = Object.getPrototypeOf(target);
    var keys = new Set([].concat(ownKeys(target), ownKeys(proto)));
    keys["delete"]("constructor");
    keys["delete"]($mobx);
    addHiddenProp(proto, keysSymbol, keys);
  }

  startBatch();

  try {
    target[keysSymbol].forEach(function (key) {
      return adm.make_(key, // must pass "undefined" for { key: undefined }
      !overrides ? true : key in overrides ? overrides[key] : true);
    });
  } finally {
    endBatch();
  }

  return target;
}

var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859

var arrayTraps = {
  get: function get(target, name) {
    var adm = target[$mobx];
    if (name === $mobx) return adm;
    if (name === "length") return adm.getArrayLength_();

    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }

    if (hasProp(arrayExtensions, name)) {
      return arrayExtensions[name];
    }

    return target[name];
  },
  set: function set(target, name, value) {
    var adm = target[$mobx];

    if (name === "length") {
      adm.setArrayLength_(value);
    }

    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      // numeric string
      adm.set_(parseInt(name), value);
    }

    return true;
  },
  preventExtensions: function preventExtensions() {
    die(15);
  }
};
var ObservableArrayAdministration = /*#__PURE__*/function () {
  // this is the prop that gets proxied, so can't replace it!
  function ObservableArrayAdministration(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name =  "ObservableArray@" + getNextId() ;
    }

    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name);

    this.enhancer_ = function (newV, oldV) {
      return enhancer(newV, oldV,  name + "[..]" );
    };
  }

  var _proto = ObservableArrayAdministration.prototype;

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) return this.dehancer(value);
    return value;
  };

  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== undefined && values.length > 0) return values.map(this.dehancer);
    return values;
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }

    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }

    return registerListener(this, listener);
  };

  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };

  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || newLength < 0) die("Out of range: " + newLength);
    var currentLength = this.values_.length;
    if (newLength === currentLength) return;else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);

      for (var i = 0; i < newLength - currentLength; i++) {
        newItems[i] = undefined;
      } // No Array.fill everywhere...


      this.spliceWithArray_(currentLength, 0, newItems);
    } else this.spliceWithArray_(newLength, currentLength - newLength);
  };

  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_) die(16);
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0) reserveArrayBuffer(oldLength + delta + 1);
  };

  _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {
    var _this = this;

    checkIfStateModificationsAreAllowed(this.atom_);
    var length = this.values_.length;
    if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);
    if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));
    if (newItems === undefined) newItems = EMPTY_ARRAY;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: index,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) return EMPTY_ARRAY;
      deleteCount = change.removedCount;
      newItems = change.added;
    }

    newItems = newItems.length === 0 ? newItems : newItems.map(function (v) {
      return _this.enhancer_(v, undefined);
    });

    if (this.legacyMode_ || "development" !== "production") {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length, lengthDelta); // checks if internal array wasn't modified
    }

    var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice_(index, newItems, res);
    return this.dehanceValues_(res);
  };

  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;

      return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index, index + deleteCount);
      var oldItems = this.values_.slice(index + deleteCount);
      this.values_.length = index + newItems.length - deleteCount;

      for (var i = 0; i < newItems.length; i++) {
        this.values_[index + i] = newItems[i];
      }

      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index + newItems.length + _i] = oldItems[_i];
      }

      return res;
    }
  };

  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: index,
      newValue: newValue,
      oldValue: oldValue
    } : null; // The reason why this is on right hand side here (and not above), is this way the uglifier will drop it, but it won't
    // cause any runtime overhead in development mode without NODE_ENV set, unless spying is enabled

    if ( notifySpy) spyReportStart(change);
    this.atom_.reportChanged();
    if (notify) notifyListeners(this, change);
    if ( notifySpy) spyReportEnd();
  };

  _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: index,
      removed: removed,
      added: added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    if ( notifySpy) spyReportStart(change);
    this.atom_.reportChanged(); // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe

    if (notify) notifyListeners(this, change);
    if ( notifySpy) spyReportEnd();
  };

  _proto.get_ = function get_(index) {
    if (index < this.values_.length) {
      this.atom_.reportObserved();
      return this.dehanceValue_(this.values_[index]);
    }

    console.warn( "[mobx] Out of bounds read: " + index );
  };

  _proto.set_ = function set_(index, newValue) {
    var values = this.values_;

    if (index < values.length) {
      // update at index in range
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values[index];

      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          index: index,
          newValue: newValue
        });
        if (!change) return;
        newValue = change.newValue;
      }

      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;

      if (changed) {
        values[index] = newValue;
        this.notifyArrayChildUpdate_(index, newValue, oldValue);
      }
    } else if (index === values.length) {
      // add a new item
      this.spliceWithArray_(index, 0, [newValue]);
    } else {
      // out of bounds
      die(17, index, values.length);
    }
  };

  return ObservableArrayAdministration;
}();
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name =  "ObservableArray@" + getNextId() ;
  }

  if (owned === void 0) {
    owned = false;
  }

  assertProxies();
  var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
  addHiddenFinalProp(adm.values_, $mobx, adm);
  var proxy = new Proxy(adm.values_, arrayTraps);
  adm.proxy_ = proxy;

  if (initialValues && initialValues.length) {
    var prev = allowStateChangesStart(true);
    adm.spliceWithArray_(0, 0, initialValues);
    allowStateChangesEnd(prev);
  }

  return proxy;
} // eslint-disable-next-line

var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  // Used by JSON.stringify
  toJSON: function toJSON() {
    return this.slice();
  },

  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function splice(index, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }

    var adm = this[$mobx];

    switch (arguments.length) {
      case 0:
        return [];

      case 1:
        return adm.spliceWithArray_(index);

      case 2:
        return adm.spliceWithArray_(index, deleteCount);
    }

    return adm.spliceWithArray_(index, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];

    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }

    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];

    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }

    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    // reverse by default mutates in place before returning the result
    // which makes it both a 'derivation' and a 'mutation'.
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }

    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    // sort by default mutates in place before returning the result
    // which goes against all good practices. Let's not change the array in place!
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }

    var copy = this.slice();
    copy.sort.apply(copy, arguments);
    this.replace(copy);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);

    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }

    return false;
  }
};
/**
 * Wrap function from prototype
 * Without this, everything works as well, but this works
 * faster as everything works on unproxied values
 */

addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc); // map

addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc); // reduce

addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);

function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
} // Report and delegate to dehanced array


function simpleFunc(funcName) {
  return function () {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
} // Make sure callbacks recieve correct array arg #2326


function mapLikeFunc(funcName) {
  return function (callback, thisArg) {
    var _this2 = this;

    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function (element, index) {
      return callback.call(thisArg, element, index, _this2);
    });
  };
} // Make sure callbacks recieve correct array arg #2326


function reduceLikeFunc(funcName) {
  return function () {
    var _this3 = this;

    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_); // #2432 - reduce behavior depends on arguments.length

    var callback = arguments[0];

    arguments[0] = function (accumulator, currentValue, index) {
      return callback(accumulator, currentValue, index, _this3);
    };

    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}

var isObservableArrayAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}

var _Symbol$iterator, _Symbol$toStringTag;
var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete"; // just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54
// But: https://github.com/mobxjs/mobx/issues/1556

_Symbol$iterator = Symbol.iterator;
_Symbol$toStringTag = Symbol.toStringTag;
var ObservableMap = /*#__PURE__*/function () {
  // hasMap, not hashMap >-).
  function ObservableMap(initialData, enhancer_, name_) {
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }

    if (name_ === void 0) {
      name_ =  "ObservableMap@" + getNextId() ;
    }

    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;

    if (!isFunction(Map)) {
      die(18);
    }

    this.keysAtom_ = createAtom( this.name_ + ".keys()" );
    this.data_ = new Map();
    this.hasMap_ = new Map();
    this.merge(initialData);
  }

  var _proto = ObservableMap.prototype;

  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };

  _proto.has = function has(key) {
    var _this = this;

    if (!globalState.trackingDerivation) return this.has_(key);
    var entry = this.hasMap_.get(key);

    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer,  this.name_ + "." + stringifyKey(key) + "?" , false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function () {
        return _this.hasMap_["delete"](key);
      });
    }

    return entry.get();
  };

  _proto.set = function set(key, value) {
    var hasKey = this.has_(key);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change) return this;
      value = change.newValue;
    }

    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }

    return this;
  };

  _proto["delete"] = function _delete(key) {
    var _this2 = this;

    checkIfStateModificationsAreAllowed(this.keysAtom_);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change) return false;
    }

    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);

      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;

      if ( notifySpy) spyReportStart(_change);
      transaction(function () {
        _this2.keysAtom_.reportChanged();

        _this2.updateHasMapEntry_(key, false);

        var observable = _this2.data_.get(key);

        observable.setNewValue_(undefined);

        _this2.data_["delete"](key);
      });
      if (notify) notifyListeners(this, _change);
      if ( notifySpy) spyReportEnd();
      return true;
    }

    return false;
  };

  _proto.updateHasMapEntry_ = function updateHasMapEntry_(key, value) {
    var entry = this.hasMap_.get(key);

    if (entry) {
      entry.setNewValue_(value);
    }
  };

  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable = this.data_.get(key);
    newValue = observable.prepareNewValue_(newValue);

    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable.value_,
        name: key,
        newValue: newValue
      } : null;
      if ( notifySpy) spyReportStart(change);
      observable.setNewValue_(newValue);
      if (notify) notifyListeners(this, change);
      if ( notifySpy) spyReportEnd();
    }
  };

  _proto.addValue_ = function addValue_(key, newValue) {
    var _this3 = this;

    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function () {
      var observable = new ObservableValue(newValue, _this3.enhancer_,  _this3.name_ + "." + stringifyKey(key) , false);

      _this3.data_.set(key, observable);

      newValue = observable.value_; // value might have been changed

      _this3.updateHasMapEntry_(key, true);

      _this3.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue: newValue
    } : null;
    if ( notifySpy) spyReportStart(change);
    if (notify) notifyListeners(this, change);
    if ( notifySpy) spyReportEnd();
  };

  _proto.get = function get(key) {
    if (this.has(key)) return this.dehanceValue_(this.data_.get(key).get());
    return this.dehanceValue_(undefined);
  };

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }

    return value;
  };

  _proto.keys = function keys() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };

  _proto.values = function values() {
    var self = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next = keys.next(),
            done = _keys$next.done,
            value = _keys$next.value;

        return {
          done: done,
          value: done ? undefined : self.get(value)
        };
      }
    });
  };

  _proto.entries = function entries() {
    var self = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next2 = keys.next(),
            done = _keys$next2.done,
            value = _keys$next2.value;

        return {
          done: done,
          value: done ? undefined : [value, self.get(value)]
        };
      }
    });
  };

  _proto[_Symbol$iterator] = function () {
    return this.entries();
  };

  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          key = _step$value[0],
          value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  }
  /** Merge another object into this object, returns this. */
  ;

  _proto.merge = function merge(other) {
    var _this4 = this;

    if (isObservableMap(other)) {
      other = new Map(other);
    }

    transaction(function () {
      if (isPlainObject(other)) getPlainObjectKeys(other).forEach(function (key) {
        return _this4.set(key, other[key]);
      });else if (Array.isArray(other)) other.forEach(function (_ref) {
        var key = _ref[0],
            value = _ref[1];
        return _this4.set(key, value);
      });else if (isES6Map(other)) {
        if (other.constructor !== Map) die(19, other);
        other.forEach(function (value, key) {
          return _this4.set(key, value);
        });
      } else if (other !== null && other !== undefined) die(20, other);
    });
    return this;
  };

  _proto.clear = function clear() {
    var _this5 = this;

    transaction(function () {
      untracked(function () {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this5.keys()), _step2; !(_step2 = _iterator2()).done;) {
          var key = _step2.value;

          _this5["delete"](key);
        }
      });
    });
  };

  _proto.replace = function replace(values) {
    var _this6 = this;

    // Implementation requirements:
    // - respect ordering of replacement map
    // - allow interceptors to run and potentially prevent individual operations
    // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)
    // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)
    // - note that result map may differ from replacement map due to the interceptors
    transaction(function () {
      // Convert to map so we can do quick key lookups
      var replacementMap = convertToMap(values);
      var orderedData = new Map(); // Used for optimization

      var keysReportChangedCalled = false; // Delete keys that don't exist in replacement map
      // if the key deletion is prevented by interceptor
      // add entry at the beginning of the result map

      for (var _iterator3 = _createForOfIteratorHelperLoose(_this6.data_.keys()), _step3; !(_step3 = _iterator3()).done;) {
        var key = _step3.value;

        // Concurrently iterating/deleting keys
        // iterator should handle this correctly
        if (!replacementMap.has(key)) {
          var deleted = _this6["delete"](key); // Was the key removed?


          if (deleted) {
            // _keysAtom.reportChanged() was already called
            keysReportChangedCalled = true;
          } else {
            // Delete prevented by interceptor
            var value = _this6.data_.get(key);

            orderedData.set(key, value);
          }
        }
      } // Merge entries


      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done;) {
        var _step4$value = _step4.value,
            _key = _step4$value[0],
            _value = _step4$value[1];

        // We will want to know whether a new key is added
        var keyExisted = _this6.data_.has(_key); // Add or update value


        _this6.set(_key, _value); // The addition could have been prevent by interceptor


        if (_this6.data_.has(_key)) {
          // The update could have been prevented by interceptor
          // and also we want to preserve existing values
          // so use value from _data map (instead of replacement map)
          var _value2 = _this6.data_.get(_key);

          orderedData.set(_key, _value2); // Was a new key added?

          if (!keyExisted) {
            // _keysAtom.reportChanged() was already called
            keysReportChangedCalled = true;
          }
        }
      } // Check for possible key order change


      if (!keysReportChangedCalled) {
        if (_this6.data_.size !== orderedData.size) {
          // If size differs, keys are definitely modified
          _this6.keysAtom_.reportChanged();
        } else {
          var iter1 = _this6.data_.keys();

          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();

          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this6.keysAtom_.reportChanged();

              break;
            }

            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      } // Use correctly ordered map


      _this6.data_ = orderedData;
    });
    return this;
  };

  _proto.toString = function toString() {
    return "[object ObservableMap]";
  };

  _proto.toJSON = function toJSON() {
    return Array.from(this);
  };

  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if ( fireImmediately === true) die("`observe` doesn't support fireImmediately=true in combination with maps.");
    return registerListener(this, listener);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _createClass(ObservableMap, [{
    key: "size",
    get: function get() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return "Map";
    }
  }]);

  return ObservableMap;
}(); // eslint-disable-next-line

var isObservableMap = /*#__PURE__*/createInstanceofPredicate("ObservableMap", ObservableMap);

function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map = new Map();

    for (var key in dataStructure) {
      map.set(key, dataStructure[key]);
    }

    return map;
  } else {
    return die(21, dataStructure);
  }
}

var _Symbol$iterator$1, _Symbol$toStringTag$1;
var ObservableSetMarker = {};
_Symbol$iterator$1 = Symbol.iterator;
_Symbol$toStringTag$1 = Symbol.toStringTag;
var ObservableSet = /*#__PURE__*/function () {
  function ObservableSet(initialData, enhancer, name_) {
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }

    if (name_ === void 0) {
      name_ =  "ObservableSet@" + getNextId() ;
    }

    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;

    if (!isFunction(Set)) {
      die(22);
    }

    this.atom_ = createAtom(this.name_);

    this.enhancer_ = function (newV, oldV) {
      return enhancer(newV, oldV, name_);
    };

    if (initialData) {
      this.replace(initialData);
    }
  }

  var _proto = ObservableSet.prototype;

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }

    return value;
  };

  _proto.clear = function clear() {
    var _this = this;

    transaction(function () {
      untracked(function () {
        for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done;) {
          var value = _step.value;

          _this["delete"](value);
        }
      });
    });
  };

  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done;) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };

  _proto.add = function add(value) {
    var _this2 = this;

    checkIfStateModificationsAreAllowed(this.atom_);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change) return this; // ideally, value = change.value would be done here, so that values can be
      // changed by interceptor. Same applies for other Set and Map api's.
    }

    if (!this.has(value)) {
      transaction(function () {
        _this2.data_.add(_this2.enhancer_(value, undefined));

        _this2.atom_.reportChanged();
      });
      var notifySpy =  isSpyEnabled();
      var notify = hasListeners(this);

      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;

      if (notifySpy && "development" !== "production") spyReportStart(_change);
      if (notify) notifyListeners(this, _change);
      if (notifySpy && "development" !== "production") spyReportEnd();
    }

    return this;
  };

  _proto["delete"] = function _delete(value) {
    var _this3 = this;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change) return false;
    }

    if (this.has(value)) {
      var notifySpy =  isSpyEnabled();
      var notify = hasListeners(this);

      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;

      if (notifySpy && "development" !== "production") spyReportStart(_change2);
      transaction(function () {
        _this3.atom_.reportChanged();

        _this3.data_["delete"](value);
      });
      if (notify) notifyListeners(this, _change2);
      if (notifySpy && "development" !== "production") spyReportEnd();
      return true;
    }

    return false;
  };

  _proto.has = function has(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };

  _proto.entries = function entries() {
    var nextIndex = 0;
    var keys = Array.from(this.keys());
    var values = Array.from(this.values());
    return makeIterable({
      next: function next() {
        var index = nextIndex;
        nextIndex += 1;
        return index < values.length ? {
          value: [keys[index], values[index]],
          done: false
        } : {
          done: true
        };
      }
    });
  };

  _proto.keys = function keys() {
    return this.values();
  };

  _proto.values = function values() {
    this.atom_.reportObserved();
    var self = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterable({
      next: function next() {
        return nextIndex < observableValues.length ? {
          value: self.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          done: true
        };
      }
    });
  };

  _proto.replace = function replace(other) {
    var _this4 = this;

    if (isObservableSet(other)) {
      other = new Set(other);
    }

    transaction(function () {
      if (Array.isArray(other)) {
        _this4.clear();

        other.forEach(function (value) {
          return _this4.add(value);
        });
      } else if (isES6Set(other)) {
        _this4.clear();

        other.forEach(function (value) {
          return _this4.add(value);
        });
      } else if (other !== null && other !== undefined) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    // ... 'fireImmediately' could also be true?
    if ( fireImmediately === true) die("`observe` doesn't support fireImmediately=true in combination with sets.");
    return registerListener(this, listener);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.toJSON = function toJSON() {
    return Array.from(this);
  };

  _proto.toString = function toString() {
    return "[object ObservableSet]";
  };

  _proto[_Symbol$iterator$1] = function () {
    return this.values();
  };

  _createClass(ObservableSet, [{
    key: "size",
    get: function get() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag$1,
    get: function get() {
      return "Set";
    }
  }]);

  return ObservableSet;
}(); // eslint-disable-next-line

var isObservableSet = /*#__PURE__*/createInstanceofPredicate("ObservableSet", ObservableSet);

var descriptorCache = /*#__PURE__*/Object.create(null);
var REMOVE = "remove";
var ObservableObjectAdministration = /*#__PURE__*/function () {
  function ObservableObjectAdministration(target_, values_, name_, // Used anytime annotation is not explicitely provided
  defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = new Map();
    }

    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }

    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom( this.name_ + ".keys" ); // Optimization: we use this frequently

    this.isPlainObject_ = isPlainObject(this.target_);

    if ( !isAnnotation(this.defaultAnnotation_)) {
      die("defaultAnnotation must be valid annotation");
    }

    {
      // Prepare structure for tracking which fields were already annotated
      this.appliedAnnotations_ = {};
    }
  }

  var _proto = ObservableObjectAdministration.prototype;

  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };

  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable = this.values_.get(key);

    if (observable instanceof ComputedValue) {
      observable.set(newValue);
      return true;
    } // intercept


    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: newValue
      });
      if (!change) return null;
      newValue = change.newValue;
    }

    newValue = observable.prepareNewValue_(newValue); // notify spy & observers

    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy =  isSpyEnabled();

      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable.value_,
        name: key,
        newValue: newValue
      } : null;

      if ( notifySpy) spyReportStart(_change);
      observable.setNewValue_(newValue);
      if (notify) notifyListeners(this, _change);
      if ( notifySpy) spyReportEnd();
    }

    return true;
  };

  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      // Key doesn't exist yet, subscribe for it in case it's added later
      this.has_(key);
    }

    return this.target_[key];
  }
  /**
   * @param {PropertyKey} key
   * @param {any} value
   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    // Don't use .has(key) - we care about own
    if (hasProp(this.target_, key)) {
      // Existing prop
      if (this.values_.has(key)) {
        // Observable (can be intercepted)
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        // Non-observable - proxy
        return Reflect.set(this.target_, key, value);
      } else {
        // Non-observable
        this.target_[key] = value;
        return true;
      }
    } else {
      // New prop
      return this.extend_(key, {
        value: value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  } // Trap for "in"
  ;

  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      // Skip key subscription outside derivation
      return key in this.target_;
    }

    this.pendingKeys_ || (this.pendingKeys_ = new Map());
    var entry = this.pendingKeys_.get(key);

    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer,  this.name_ + "." + stringifyKey(key) + "?" , false);
      this.pendingKeys_.set(key, entry);
    }

    return entry.get();
  }
  /**
   * @param {PropertyKey} key
   * @param {Annotation|boolean} annotation true - use default annotation, false - ignore prop
   */
  ;

  _proto.make_ = function make_(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }

    if (annotation === false) {
      return;
    }

    assertAnnotable(this, annotation, key);

    if (!(key in this.target_)) {
      var _this$target_$storedA;

      // Throw on missing key, except for decorators:
      // Decorator annotations are collected from whole prototype chain.
      // When called from super() some props may not exist yet.
      // However we don't have to worry about missing prop,
      // because the decorator must have been applied to something.
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) == null ? void 0 : _this$target_$storedA[key]) {
        return; // will be annotated by subclass constructor
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }

    var source = this.target_;

    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key);

      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0
        /* Cancel */
        ) return;
        if (outcome === 1
        /* Break */
        ) break;
      }

      source = Object.getPrototypeOf(source);
    }

    recordAnnotationApplied(this, annotation, key);
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }

    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }

    assertAnnotable(this, annotation, key);
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);

    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }

    return outcome;
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change) return null;
        var newValue = change.newValue;

        if (descriptor.value !== newValue) {
          descriptor = _extends({}, descriptor, {
            value: newValue
          });
        }
      } // Define


      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      } // Notify


      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }

    return true;
  } // If original descriptor becomes relevant, move this to annotation directly
  ;

  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change) return null;
        value = change.newValue;
      }

      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      }; // Define

      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }

      var observable = new ObservableValue(value, enhancer, "development" !== "production" ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
      this.values_.set(key, observable); // Notify (value possibly changed by ObservableValue)

      this.notifyPropertyAddition_(key, observable.value_);
    } finally {
      endBatch();
    }

    return true;
  } // If original descriptor becomes relevant, move this to annotation directly
  ;

  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: undefined
        });
        if (!change) return null;
      }

      options.name || (options.name = "development" !== "production" ? this.name_ + "." + key.toString() : "ObservableObject.key");
      options.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      }; // Define

      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }

      this.values_.set(key, new ComputedValue(options)); // Notify

      this.notifyPropertyAddition_(key, undefined);
    } finally {
      endBatch();
    }

    return true;
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    // No such prop
    if (!hasProp(this.target_, key)) {
      return true;
    } // Intercept


    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      }); // Cancelled

      if (!change) return null;
    } // Delete


    try {
      var _this$pendingKeys_, _this$pendingKeys_$ge;

      startBatch();
      var notify = hasListeners(this);
      var notifySpy = "development" !== "production" && isSpyEnabled();
      var observable = this.values_.get(key); // Value needed for spies/listeners

      var value = undefined; // Optimization: don't pull the value unless we will need it

      if (!observable && (notify || notifySpy)) {
        var _getDescriptor;

        value = (_getDescriptor = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor.value;
      } // delete prop (do first, may fail)


      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      } // Allow re-annotating this field


      if ("development" !== "production") {
        delete this.appliedAnnotations_[key];
      } // Clear observable


      if (observable) {
        this.values_["delete"](key); // for computed, value is undefined

        if (observable instanceof ObservableValue) {
          value = observable.value_;
        } // Notify: autorun(() => obj[key]), see #1796


        propagateChanged(observable);
      } // Notify "keys/entries/values" observers


      this.keysAtom_.reportChanged(); // Notify "has" observers
      // "in" as it may still exist in proto

      (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_); // Notify spies/listeners

      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if ("development" !== "production" && notifySpy) spyReportStart(_change2);
        if (notify) notifyListeners(this, _change2);
        if ("development" !== "production" && notifySpy) spyReportEnd();
      }
    } finally {
      endBatch();
    }

    return true;
  }
  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */
  ;

  _proto.observe_ = function observe_(callback, fireImmediately) {
    if ( fireImmediately === true) die("`observe` doesn't support the fire immediately property for observable objects.");
    return registerListener(this, callback);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2, _this$pendingKeys_2$g;

    var notify = hasListeners(this);
    var notifySpy =  isSpyEnabled();

    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if ( notifySpy) spyReportStart(change);
      if (notify) notifyListeners(this, change);
      if ( notifySpy) spyReportEnd();
    }

    (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true); // Notify "keys/entries/values" observers

    this.keysAtom_.reportChanged();
  };

  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };

  _proto.keys_ = function keys_() {
    // Returns enumerable && own, but unfortunately keysAtom will report on ANY key change.
    // There is no way to distinguish between Object.keys(object) and Reflect.ownKeys(object) - both are handled by ownKeys trap.
    // We can either over-report in Object.keys(object) or under-report in Reflect.ownKeys(object)
    // We choose to over-report in Object.keys(object), because:
    // - typically it's used with simple data objects
    // - when symbolic/non-enumerable keys are relevant Reflect.ownKeys works as expected
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };

  return ObservableObjectAdministration;
}();
function asObservableObject(target, options) {
  var _options$name;

  if ( options && isObservableObject(target)) {
    die("Options can't be provided for already observable objects.");
  }

  if (hasProp(target, $mobx)) {
    if ( !(getAdministration(target) instanceof ObservableObjectAdministration)) {
      die("Cannot convert '" + getDebugName(target) + "' into observable object:" + "\nThe target is already observable of different type." + "\nExtending builtins is not supported.");
    }

    return target;
  }

  if ( !Object.isExtensible(target)) die("Cannot make the designated object observable; it is not extensible");
  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name :  (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() ;
  var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options));
  addHiddenProp(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);

function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}

function isObservableObject(thing) {
  if (isObject(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }

  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;

  {
    adm.appliedAnnotations_[key] = annotation;
  } // Remove applied decorator annotation so we don't try to apply it again in subclass constructor


  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];
}

function assertAnnotable(adm, annotation, key) {
  // Valid annotation
  if ( !isAnnotation(annotation)) {
    die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
  }
  /*
  // Configurable, not sealed, not frozen
  // Possibly not needed, just a little better error then the one thrown by engine.
  // Cases where this would be useful the most (subclass field initializer) are not interceptable by this.
  if (__DEV__) {
      const configurable = getDescriptor(adm.target_, key)?.configurable
      const frozen = Object.isFrozen(adm.target_)
      const sealed = Object.isSealed(adm.target_)
      if (!configurable || frozen || sealed) {
          const fieldName = `${adm.name_}.${key.toString()}`
          const requestedAnnotationType = annotation.annotationType_
          let error = `Cannot apply '${requestedAnnotationType}' to '${fieldName}':`
          if (frozen) {
              error += `\nObject is frozen.`
          }
          if (sealed) {
              error += `\nObject is sealed.`
          }
          if (!configurable) {
              error += `\nproperty is not configurable.`
              // Mention only if caused by us to avoid confusion
              if (hasProp(adm.appliedAnnotations!, key)) {
                  error += `\nTo prevent accidental re-definition of a field by a subclass, `
                  error += `all annotated fields of non-plain objects (classes) are not configurable.`
              }
          }
          die(error)
      }
  }
  */
  // Not annotated


  if ( !isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {
    var fieldName = adm.name_ + "." + key.toString();
    var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed." + "\nUse 'override' annotation for methods overriden by subclass.");
  }
}

/**
 * This array buffer contains two lists of properties, so that all arrays
 * can recycle their property definitions, which significantly improves performance of creating
 * properties on the fly.
 */

var OBSERVABLE_ARRAY_BUFFER_SIZE = 0; // Typescript workaround to make sure ObservableArray extends Array

var StubArray = function StubArray() {};

function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== undefined) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}

inherit(StubArray, Array.prototype); // Weex proto freeze protection was here,
// but it is unclear why the hack is need as MobX never changed the prototype
// anyway, so removed it in V6

var LegacyObservableArray = /*#__PURE__*/function (_StubArray) {
  _inheritsLoose(LegacyObservableArray, _StubArray);

  function LegacyObservableArray(initialValues, enhancer, name, owned) {
    var _this;

    if (name === void 0) {
      name =  "ObservableArray@" + getNextId() ;
    }

    if (owned === void 0) {
      owned = false;
    }

    _this = _StubArray.call(this) || this;
    var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
    adm.proxy_ = _assertThisInitialized(_this);
    addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);

    if (initialValues && initialValues.length) {
      var prev = allowStateChangesStart(true); // @ts-ignore

      _this.spliceWithArray(0, 0, initialValues);

      allowStateChangesEnd(prev);
    }

    return _this;
  }

  var _proto = LegacyObservableArray.prototype;

  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();

    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }

    return Array.prototype.concat.apply(this.slice(), //@ts-ignore
    arrays.map(function (a) {
      return isObservableArray(a) ? a.slice() : a;
    }));
  };

  _proto[Symbol.iterator] = function () {
    var self = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        // @ts-ignore
        return nextIndex < self.length ? {
          value: self[nextIndex++],
          done: false
        } : {
          done: true,
          value: undefined
        };
      }
    });
  };

  _createClass(LegacyObservableArray, [{
    key: "length",
    get: function get() {
      return this[$mobx].getArrayLength_();
    },
    set: function set(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return "Array";
    }
  }]);

  return LegacyObservableArray;
}(StubArray);

Object.entries(arrayExtensions).forEach(function (_ref) {
  var prop = _ref[0],
      fn = _ref[1];
  if (prop !== "concat") addHiddenProp(LegacyObservableArray.prototype, prop, fn);
});

function createArrayEntryDescriptor(index) {
  return {
    enumerable: false,
    configurable: true,
    get: function get() {
      return this[$mobx].get_(index);
    },
    set: function set(value) {
      this[$mobx].set_(index, value);
    }
  };
}

function createArrayBufferItem(index) {
  defineProperty(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
}

function reserveArrayBuffer(max) {
  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {
      createArrayBufferItem(index);
    }

    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
  }
}
reserveArrayBuffer(1000);
function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}

function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== undefined) die(23);
      return thing[$mobx].atom_;
    }

    if (isObservableSet(thing)) {
      return thing[$mobx];
    }

    if (isObservableMap(thing)) {
      if (property === undefined) return thing.keysAtom_;
      var observable = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable) die(25, property, getDebugName(thing));
      return observable;
    }

    if (isObservableObject(thing)) {
      if (!property) return die(26);

      var _observable = thing[$mobx].values_.get(property);

      if (!_observable) die(27, property, getDebugName(thing));
      return _observable;
    }

    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction(thing)) {
    if (isReaction(thing[$mobx])) {
      // disposer function
      return thing[$mobx];
    }
  }

  die(28);
}
function getAdministration(thing, property) {
  if (!thing) die(29);
  if (property !== undefined) return getAdministration(getAtom(thing, property));
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;
  if (isObservableMap(thing) || isObservableSet(thing)) return thing;
  if (thing[$mobx]) return thing[$mobx];
  die(24, thing);
}
function getDebugName(thing, property) {
  var named;

  if (property !== undefined) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    // valid for arrays as well
    named = getAtom(thing);
  }

  return named.name_;
}

var toString = objectPrototype.toString;
function deepEqual(a, b, depth) {
  if (depth === void 0) {
    depth = -1;
  }

  return eq(a, b, depth);
} // Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289
// Internal recursive comparison function for `isEqual`.

function eq(a, b, depth, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) return a !== 0 || 1 / a === 1 / b; // `null` or `undefined` only equal to itself (strict comparison).

  if (a == null || b == null) return false; // `NaN`s are equivalent, but non-reflexive.

  if (a !== a) return b !== b; // Exhaust primitive checks

  var type = typeof a;
  if (!isFunction(type) && type !== "object" && typeof b != "object") return false; // Compare `[[Class]]` names.

  var className = toString.call(a);
  if (className !== toString.call(b)) return false;

  switch (className) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case "[object RegExp]": // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')

    case "[object String]":
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return "" + a === "" + b;

    case "[object Number]":
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values.

      return +a === 0 ? 1 / +a === 1 / b : +a === +b;

    case "[object Date]":
    case "[object Boolean]":
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;

    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);

    case "[object Map]":
    case "[object Set]":
      // Maps and Sets are unwrapped to arrays of entry-pairs, adding an incidental level.
      // Hide this extra level by increasing the depth.
      if (depth >= 0) {
        depth++;
      }

      break;
  } // Unwrap any wrapped objects.


  a = unwrap(a);
  b = unwrap(b);
  var areArrays = className === "[object Array]";

  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.

    var aCtor = a.constructor,
        bCtor = b.constructor;

    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
      return false;
    }
  }

  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  } // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.


  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;

  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) return bStack[length] === b;
  } // Add the first object to the stack of traversed objects.


  aStack.push(a);
  bStack.push(b); // Recursively compare objects and arrays.

  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties.

    while (length--) {
      if (!eq(a[length], b[length], depth - 1, aStack, bStack)) return false;
    }
  } else {
    // Deep compare objects.
    var keys = Object.keys(a);
    var key;
    length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality.

    if (Object.keys(b).length !== length) return false;

    while (length--) {
      // Deep compare each member
      key = keys[length];
      if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) return false;
    }
  } // Remove the first object from the stack of traversed objects.


  aStack.pop();
  bStack.pop();
  return true;
}

function unwrap(a) {
  if (isObservableArray(a)) return a.slice();
  if (isES6Map(a) || isObservableMap(a)) return Array.from(a.entries());
  if (isES6Set(a) || isObservableSet(a)) return Array.from(a.entries());
  return a;
}

function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return iterator;
}

function getSelf() {
  return this;
}

function isAnnotation(thing) {
  return (// Can be function
    thing instanceof Object && typeof thing.annotationType_ === "string" && isFunction(thing.make_) && isFunction(thing.extend_)
  );
}

/**
 * (c) Michel Weststrate 2015 - 2020
 * MIT Licensed
 *
 * Welcome to the mobx sources! To get an global overview of how MobX internally works,
 * this is a good place to start:
 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 *
 * Source folders:
 * ===============
 *
 * - api/     Most of the public static methods exposed by the module can be found here.
 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
 * - utils/   Utility stuff.
 *
 */
["Symbol", "Map", "Set"].forEach(function (m) {
  var g = getGlobal();

  if (typeof g[m] === "undefined") {
    die("MobX requires global '" + m + "' to be available or polyfilled");
  }
});

if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  // See: https://github.com/andykog/mobx-devtools/
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy: spy,
    extras: {
      getDebugName: getDebugName
    },
    $mobx: $mobx
  });
}

exports.$mobx = $mobx;
exports.FlowCancellationError = FlowCancellationError;
exports.ObservableMap = ObservableMap;
exports.ObservableSet = ObservableSet;
exports.Reaction = Reaction;
exports._allowStateChanges = allowStateChanges;
exports._allowStateChangesInsideComputed = runInAction;
exports._allowStateReadsEnd = allowStateReadsEnd;
exports._allowStateReadsStart = allowStateReadsStart;
exports._autoAction = autoAction;
exports._endAction = _endAction;
exports._getAdministration = getAdministration;
exports._getGlobalState = getGlobalState;
exports._interceptReads = interceptReads;
exports._isComputingDerivation = isComputingDerivation;
exports._resetGlobalState = resetGlobalState;
exports._startAction = _startAction;
exports.action = action;
exports.autorun = autorun;
exports.comparer = comparer;
exports.computed = computed;
exports.configure = configure;
exports.createAtom = createAtom;
exports.defineProperty = apiDefineProperty;
exports.entries = entries;
exports.extendObservable = extendObservable;
exports.flow = flow;
exports.flowResult = flowResult;
exports.get = get;
exports.getAtom = getAtom;
exports.getDebugName = getDebugName;
exports.getDependencyTree = getDependencyTree;
exports.getObserverTree = getObserverTree;
exports.has = has;
exports.intercept = intercept;
exports.isAction = isAction;
exports.isBoxedObservable = isObservableValue;
exports.isComputed = isComputed;
exports.isComputedProp = isComputedProp;
exports.isFlow = isFlow;
exports.isFlowCancellationError = isFlowCancellationError;
exports.isObservable = isObservable;
exports.isObservableArray = isObservableArray;
exports.isObservableMap = isObservableMap;
exports.isObservableObject = isObservableObject;
exports.isObservableProp = isObservableProp;
exports.isObservableSet = isObservableSet;
exports.keys = keys;
exports.makeAutoObservable = makeAutoObservable;
exports.makeObservable = makeObservable;
exports.observable = observable;
exports.observe = observe;
exports.onBecomeObserved = onBecomeObserved;
exports.onBecomeUnobserved = onBecomeUnobserved;
exports.onReactionError = onReactionError;
exports.override = override;
exports.ownKeys = apiOwnKeys;
exports.reaction = reaction;
exports.remove = remove;
exports.runInAction = runInAction;
exports.set = set;
exports.spy = spy;
exports.toJS = toJS;
exports.trace = trace;
exports.transaction = transaction;
exports.untracked = untracked;
exports.values = values;
exports.when = when;


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],28:[function(require,module,exports){
(function (global){(function (){
function t(t){for(var n=arguments.length,i=new Array(n>1?n-1:0),r=1;r<n;r++)i[r-1]=arguments[r];throw new Error("number"==typeof t?"[MobX] minified error nr: "+t+(i.length?" "+i.map(String).join(","):"")+". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts":"[MobX] "+t)}function n(){return"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:xn}function i(){Vn||t("Proxy not available")}function r(t){var n=!1;return function(){if(!n)return n=!0,t.apply(this,arguments)}}function e(t){return"function"==typeof t}function o(t){switch(typeof t){case"string":case"symbol":case"number":return!0}return!1}function u(t){return null!==t&&"object"==typeof t}function s(t){var n;if(!u(t))return!1;var i=Object.getPrototypeOf(t);return null==i||(null==(n=i.constructor)?void 0:n.toString())===Nn}function f(t){var n=null==t?void 0:t.constructor;return!!n&&("GeneratorFunction"===n.name||"GeneratorFunction"===n.displayName)}function a(t,n,i){gn(t,n,{enumerable:!1,writable:!0,configurable:!0,value:i})}function c(t,n,i){gn(t,n,{enumerable:!1,writable:!1,configurable:!0,value:i})}function h(t,n){var i="isMobX"+t;return n.prototype[i]=!0,function(t){return u(t)&&!0===t[i]}}function v(t){return t instanceof Map}function l(t){return t instanceof Set}function d(t){return null===t?null:"object"==typeof t?""+t:t}function b(t,n){return _n.hasOwnProperty.call(t,n)}function p(t,n){for(var i=0;i<n.length;i++){var r=n[i];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function y(t,n,i){return n&&p(t.prototype,n),i&&p(t,i),t}function m(){return(m=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var i=arguments[n];for(var r in i)Object.prototype.hasOwnProperty.call(i,r)&&(t[r]=i[r])}return t}).apply(this,arguments)}function w(t,n){t.prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n}function j(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function x(t,n){(null==n||n>t.length)&&(n=t.length);for(var i=0,r=new Array(n);i<n;i++)r[i]=t[i];return r}function O(t,n){var i;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(i=function(t){if(t){if("string"==typeof t)return x(t,void 0);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?x(t,void 0):void 0}}(t))||n&&t&&"number"==typeof t.length){i&&(t=i);var r=0;return function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}return(i=t[Symbol.iterator]()).next.bind(i)}function A(t){return Object.assign((function(n,i){g(n,i,t)}),t)}function g(t,n,i){b(t,Cn)||a(t,Cn,m({},t[Cn])),function(t){return"override"===t.t}(i)||(t[Cn][n]=i)}function _(t,n,i){void 0===n&&(n=Rn),void 0===i&&(i=Rn);var r=new Ln(t);return n!==Rn&&St(r,n),i!==Rn&&Mt(r,i),r}function S(t,n,i){return It(t)?t:Array.isArray(t)?$n.array(t,{name:i}):s(t)?$n.object(t,void 0,{name:i}):v(t)?$n.map(t,{name:i}):l(t)?$n.set(t,{name:i}):"function"!=typeof t||At(t)||Ct(t)?t:f(t)?Ri(t):_i(i,t)}function M(t){return t}function V(t,n){return{t:t,i:n,o:N,u:R}}function N(t,n,i,r){var e;if(null==(e=this.i)?void 0:e.bound)return null===this.u(t,n,i,!1)?0:1;if(r===t.s)return null===this.u(t,n,i,!1)?0:2;if(At(i.value))return 1;var o=k(t,this,n,i,!1);return gn(r,n,o),2}function R(t,n,i,r){var e=k(t,this,n,i);return t.h(n,e,r)}function k(t,n,i,r,e){var o,u,s,f,a;void 0===e&&(e=pi.safeDescriptors);var c,h=r.value;return(null==(o=n.i)?void 0:o.bound)&&(h=h.bind(null!=(c=t.v)?c:t.s)),{value:z(null!=(u=null==(s=n.i)?void 0:s.name)?u:i.toString(),h,null!=(f=null==(a=n.i)?void 0:a.autoAction)&&f),configurable:!e||t.l,enumerable:!1,writable:!e}}function E(t,n){return{t:t,i:n,o:T,u:C}}function T(t,n,i,r){var e;if(r===t.s)return null===this.u(t,n,i,!1)?0:2;if((null==(e=this.i)?void 0:e.bound)&&!Ct(t.s[n])&&null===this.u(t,n,i,!1))return 0;if(Ct(i.value))return 1;var o=K(t,0,0,i,!1,!1);return gn(r,n,o),2}function C(t,n,i,r){var e,o=K(t,0,0,i,null==(e=this.i)?void 0:e.bound);return t.h(n,o,r)}function K(t,n,i,r,e,o){void 0===o&&(o=pi.safeDescriptors);var u,s=r.value;return e&&(s=s.bind(null!=(u=t.v)?u:t.s)),{value:Ri(s),configurable:!o||t.l,enumerable:!1,writable:!o}}function L(t,n){return{t:t,i:n,o:I,u:P}}function I(t,n,i){return null===this.u(t,n,i,!1)?0:1}function P(t,n,i,r){return t.p(n,m({},this.i,{get:i.get,set:i.set}),r)}function D(t,n){return{t:t,i:n,o:B,u:q}}function B(t,n,i){return null===this.u(t,n,i,!1)?0:1}function q(t,n,i,r){var e,o;return t.m(n,i.value,null!=(e=null==(o=this.i)?void 0:o.enhancer)?e:S,r)}function G(t){return{t:"true",i:t,o:X,u:W}}function X(t,n,i,r){var e,o,u,s;if(i.get)return Qn.o(t,n,i,r);if(i.set){var a=z(n.toString(),i.set);return r===t.s?null===t.h(n,{configurable:!pi.safeDescriptors||t.l,set:a})?0:2:(gn(r,n,{configurable:!0,set:a}),2)}if(r!==t.s&&"function"==typeof i.value)return f(i.value)?((null==(s=this.i)?void 0:s.autoBind)?Ri.bound:Ri).o(t,n,i,r):((null==(u=this.i)?void 0:u.autoBind)?_i.bound:_i).o(t,n,i,r);var c,h=!1===(null==(e=this.i)?void 0:e.deep)?$n.ref:$n;return"function"==typeof i.value&&(null==(o=this.i)?void 0:o.autoBind)&&(i.value=i.value.bind(null!=(c=t.v)?c:t.s)),h.o(t,n,i,r)}function W(t,n,i,r){var e,o,u;return i.get?Qn.u(t,n,i,r):i.set?t.h(n,{configurable:!pi.safeDescriptors||t.l,set:z(n.toString(),i.set)},r):("function"==typeof i.value&&(null==(e=this.i)?void 0:e.autoBind)&&(i.value=i.value.bind(null!=(u=t.v)?u:t.s)),(!1===(null==(o=this.i)?void 0:o.deep)?$n.ref:$n).u(t,n,i,r))}function H(t){return t||qn}function U(t){return!0===t.deep?S:!1===t.deep?M:(n=t.defaultDecorator)&&null!=(i=null==(r=n.i)?void 0:r.enhancer)?i:S;var n,i,r}function F(t,n,i){if(!o(n))return It(t)?t:s(t)?$n.object(t,n,i):Array.isArray(t)?$n.array(t,n):v(t)?$n.map(t,n):l(t)?$n.set(t,n):"object"==typeof t&&null!==t?t:$n.box(t,n);g(t,n,Gn)}function z(t,n,i,r){function e(){return $(0,i,n,r||this,arguments)}return void 0===i&&(i=!1),e.isMobxAction=!0,ii&&(ri.value=t,Object.defineProperty(e,"name",ri)),e}function $(t,n,i,r,e){var o=J(0,n);try{return i.apply(r,e)}catch(t){throw o.j=t,t}finally{Y(o)}}function J(t,n){var i=pi.trackingDerivation,r=!n||!i;dt();var e=pi.allowStateChanges;r&&(ut(),e=Z(!0));var o={O:r,A:i,g:e,_:ft(!0),S:!1,M:0,V:ni++,N:ti};return ti=o.V,o}function Y(n){ti!==n.V&&t(30),ti=n.N,void 0!==n.j&&(pi.suppressReactionErrors=!0),tt(n.g),at(n._),bt(),n.O&&st(n.A),pi.suppressReactionErrors=!1}function Q(t,n){var i=Z(t);try{return n()}finally{tt(i)}}function Z(t){var n=pi.allowStateChanges;return pi.allowStateChanges=t,n}function tt(t){pi.allowStateChanges=t}function nt(t){return t instanceof hi}function it(t){switch(t.R){case si.k:return!1;case si.T:case si.C:return!0;case si.K:for(var n=ft(!0),i=ut(),r=t.L,e=r.length,o=0;o<e;o++){var u=r[o];if(ci(u)){if(pi.disableErrorBoundaries)u.get();else try{u.get()}catch(t){return st(i),at(n),!0}if(t.R===si.C)return st(i),at(n),!0}}return ct(t),st(i),at(n),!1}}function rt(t,n,i){var r=ft(!0);ct(t),t.I=new Array(t.L.length+100),t.P=0,t.D=++pi.runId;var e,o=pi.trackingDerivation;if(pi.trackingDerivation=t,pi.inBatch++,!0===pi.disableErrorBoundaries)e=n.call(i);else try{e=n.call(i)}catch(t){e=new hi(t)}return pi.inBatch--,pi.trackingDerivation=o,function(t){for(var n=t.L,i=t.L=t.I,r=si.k,e=0,o=t.P,u=0;u<o;u++){var s=i[u];0===s.B&&(s.B=1,e!==u&&(i[e]=s),e++),s.R>r&&(r=s.R)}for(i.length=e,t.I=null,o=n.length;o--;){var f=n[o];0===f.B&&vt(f,t),f.B=0}for(;e--;){var a=i[e];1===a.B&&(a.B=0,ht(a,t))}r!==si.k&&(t.R=r,t.q())}(t),at(r),e}function et(t){var n=t.L;t.L=[];for(var i=n.length;i--;)vt(n[i],t);t.R=si.T}function ot(t){var n=ut();try{return t()}finally{st(n)}}function ut(){var t=pi.trackingDerivation;return pi.trackingDerivation=null,t}function st(t){pi.trackingDerivation=t}function ft(t){var n=pi.allowStateReads;return pi.allowStateReads=t,n}function at(t){pi.allowStateReads=t}function ct(t){if(t.R!==si.k){t.R=si.k;for(var n=t.L,i=n.length;i--;)n[i].G=si.k}}function ht(t,n){t.X.add(n),t.G>n.R&&(t.G=n.R)}function vt(t,n){t.X.delete(n),0===t.X.size&&lt(t)}function lt(t){!1===t.W&&(t.W=!0,pi.pendingUnobservations.push(t))}function dt(){pi.inBatch++}function bt(){if(0==--pi.inBatch){mt();for(var t=pi.pendingUnobservations,n=0;n<t.length;n++){var i=t[n];i.W=!1,0===i.X.size&&(i.H&&(i.H=!1,i.onBUO()),i instanceof ai&&i.U())}pi.pendingUnobservations=[]}}function pt(t){var n=pi.trackingDerivation;return null!==n?(n.D!==t.F&&(t.F=n.D,n.I[n.P++]=t,!t.H&&pi.trackingContext&&(t.H=!0,t.onBO())),!0):(0===t.X.size&&pi.inBatch>0&&lt(t),!1)}function yt(t){t.G!==si.C&&(t.G=si.C,t.X.forEach((function(t){t.R===si.k&&t.q(),t.R=si.C})))}function mt(){pi.inBatch>0||pi.isRunningReactions||mi(wt)}function wt(){pi.isRunningReactions=!0;for(var t=pi.pendingReactions,n=0;t.length>0;){100==++n&&(console.error("[mobx] cycle in reaction: "+t[0]),t.splice(0));for(var i=t.splice(0),r=0,e=i.length;r<e;r++)i[r].$()}pi.isRunningReactions=!1}function jt(){return console.warn("[mobx.spy] Is a no-op in production builds"),function(){}}function xt(t){return function(n,i){return e(n)?z(n.name||"<unnamed action>",n,t):e(i)?z(n,i,t):o(i)?g(n,i,t?Oi:ji):o(n)?A(V(t?"autoAction":"action",{name:n,autoAction:t})):void 0}}function Ot(t){return $(0,!1,t,this,void 0)}function At(t){return e(t)&&!0===t.isMobxAction}function gt(t,n){function i(){t(o)}var r,e;void 0===n&&(n=Mn);var o,u=null!=(r=null==(e=n)?void 0:e.name)?r:"Autorun";if(n.scheduler||n.delay){var s=_t(n),f=!1;o=new yi(u,(function(){f||(f=!0,s((function(){f=!1,o.J||o.track(i)})))}),n.onError,n.requiresObservable)}else o=new yi(u,(function(){this.track(i)}),n.onError,n.requiresObservable);return o.Y(),o.Z()}function _t(t){return t.scheduler?t.scheduler:t.delay?function(n){return setTimeout(n,t.delay)}:Si}function St(t,n,i){return Vt("onBO",t,n,i)}function Mt(t,n,i){return Vt("onBUO",t,n,i)}function Vt(t,n,i,r){var o="function"==typeof r?dn(n,i):dn(n),u=e(r)?r:i,s=t+"L";return o[s]?o[s].add(u):o[s]=new Set([u]),function(){var t=o[s];t&&(t.delete(u),0===t.size&&delete o[s])}}function Nt(t,n,i,r){var e=Tn(n),o=sn(t,r)[Kn];dt();try{En(e).forEach((function(t){o.u(t,e[t],!i||!(t in i)||i[t])}))}finally{bt()}return t}function Rt(t){var n,i={name:t.tt};return t.L&&t.L.length>0&&(i.dependencies=(n=t.L,Array.from(new Set(n))).map(Rt)),i}function kt(t){var n={name:t.tt};return function(t){return t.X&&t.X.size>0}(t)&&(n.observers=Array.from(function(t){return t.X}(t)).map(kt)),n}function Et(){this.message="FLOW_CANCELLED"}function Tt(t){e(t.cancel)&&t.cancel()}function Ct(t){return!0===(null==t?void 0:t.isMobXFlow)}function Kt(t,n){if(void 0!==n){if(!1===an(t))return!1;if(!t[Kn].nt.has(n))return!1;var i=dn(t,n);return ci(i)}return ci(t)}function Lt(t,n){return!!t&&(void 0!==n?!!an(t)&&t[Kn].nt.has(n):an(t)||!!t[Kn]||In(t)||wi(t)||ci(t))}function It(t){return Lt(t)}function Pt(n){return an(n)?n[Kn].it():Hi(n)||Ji(n)?Array.from(n.keys()):un(n)?n.map((function(t,n){return n})):void t(5)}function Dt(n,i){return an(n)?n[Kn].rt(i):Hi(n)||Ji(n)?n.has(i):un(n)?i>=0&&i<n.length:void t(10)}function Bt(n){if(an(n))return n[Kn].et();t(38)}function qt(t,n,i){return t.set(n,i),i}function Gt(){t("trace() is not available in production builds");for(var n=!1,i=arguments.length,r=new Array(i),e=0;e<i;e++)r[e]=arguments[e];"boolean"==typeof r[r.length-1]&&(n=r.pop());var o=Xt(r);if(!o)return t("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");o.ot===fi.NONE&&console.log("[mobx.trace] '"+o.tt+"' tracing enabled"),o.ot=n?fi.BREAK:fi.LOG}function Xt(t){switch(t.length){case 0:return pi.trackingDerivation;case 1:return dn(t[0]);case 2:return dn(t[0],t[1])}}function Wt(t,n){void 0===n&&(n=void 0),dt();try{return t.apply(n)}finally{bt()}}function Ht(t,n,i){var r;if("number"==typeof i.timeout){var e=new Error("WHEN_TIMEOUT");r=setTimeout((function(){if(!u[Kn].J){if(u(),!i.onError)throw e;i.onError(e)}}),i.timeout)}i.name="When";var o=z("When-effect",n),u=gt((function(n){Q(!1,t)&&(n.dispose(),r&&clearTimeout(r),o())}),i);return u}function Ut(t,n){var i,r=new Promise((function(r,e){var o=Ht(t,r,m({},n,{onError:e}));i=function(){o(),e("WHEN_CANCELLED")}}));return r.cancel=i,r}function Ft(t){return t[Kn]}function zt(t){return void 0!==t.ut&&t.ut.length>0}function $t(t,n){var i=t.ut||(t.ut=[]);return i.push(n),r((function(){var t=i.indexOf(n);-1!==t&&i.splice(t,1)}))}function Jt(n,i){var r=ut();try{for(var e=[].concat(n.ut||[]),o=0,u=e.length;o<u&&((i=e[o](i))&&!i.type&&t(14),i);o++);return i}finally{st(r)}}function Yt(t){return void 0!==t.st&&t.st.length>0}function Qt(t,n){var i=t.st||(t.st=[]);return i.push(n),r((function(){var t=i.indexOf(n);-1!==t&&i.splice(t,1)}))}function Zt(t,n){var i=ut(),r=t.st;if(r){for(var e=0,o=(r=r.slice()).length;e<o;e++)r[e](n);st(i)}}function tn(t,n,r,e){void 0===r&&(r="ObservableArray"),void 0===e&&(e=!1),i();var o=new Ki(r,n,e,!1);c(o.nt,Kn,o);var u=new Proxy(o.nt,Ci);if(o.v=u,t&&t.length){var s=Z(!0);o.ft(0,0,t),tt(s)}return u}function nn(t,n){"function"==typeof Array.prototype[t]&&(Li[t]=n(t))}function rn(t){return function(){var n=this[Kn];n.at.reportObserved();var i=n.ct(n.nt);return i[t].apply(i,arguments)}}function en(t){return function(n,i){var r=this,e=this[Kn];return e.at.reportObserved(),e.ct(e.nt)[t]((function(t,e){return n.call(i,t,e,r)}))}}function on(t){return function(){var n=this,i=this[Kn];i.at.reportObserved();var r=i.ct(i.nt),e=arguments[0];return arguments[0]=function(t,i,r){return e(t,i,r,n)},r[t].apply(r,arguments)}}function un(t){return u(t)&&Di(t[Kn])}function sn(t,n){var i;if(b(t,Kn))return t;var r=null!=(i=null==n?void 0:n.name)?i:"ObservableObject",e=new Qi(t,new Map,String(r),function(t){var n;return t?null!=(n=t.defaultDecorator)?n:G(t):void 0}(n));return a(t,Kn,e),t}function fn(t){return Yi[t]||(Yi[t]={get:function(){return this[Kn].ht(t)},set:function(n){return this[Kn].vt(t,n)}})}function an(t){return!!u(t)&&Zi(t[Kn])}function cn(t,n,i){var r;null==(r=t.s[Cn])||delete r[i]}function hn(t){gn(ir.prototype,""+t,function(t){return{enumerable:!1,configurable:!0,get:function(){return this[Kn].lt(t)},set:function(n){this[Kn].dt(t,n)}}}(t))}function vn(t){if(t>tr){for(var n=tr;n<t+100;n++)hn(n);tr=t}}function ln(t,n,i){return new ir(t,n,i)}function dn(n,i){if("object"==typeof n&&null!==n){if(un(n))return void 0!==i&&t(23),n[Kn].at;if(Ji(n))return n[Kn];if(Hi(n)){if(void 0===i)return n.bt;var r=n.pt.get(i)||n.yt.get(i);return r||t(25,i,pn(n)),r}if(an(n)){if(!i)return t(26);var o=n[Kn].nt.get(i);return o||t(27,i,pn(n)),o}if(In(n)||ci(n)||wi(n))return n}else if(e(n)&&wi(n[Kn]))return n[Kn];t(28)}function bn(n,i){return n||t(29),void 0!==i?bn(dn(n,i)):In(n)||ci(n)||wi(n)||Hi(n)||Ji(n)?n:n[Kn]?n[Kn]:void t(24,n)}function pn(t,n){var i;if(void 0!==n)i=dn(t,n);else{if(At(t))return t.name;i=an(t)||Hi(t)||Ji(t)?bn(t):dn(t)}return i.tt}function yn(t,n,i){return void 0===i&&(i=-1),function t(n,i,r,o,u){if(n===i)return 0!==n||1/n==1/i;if(null==n||null==i)return!1;if(n!=n)return i!=i;var s=typeof n;if(!e(s)&&"object"!==s&&"object"!=typeof i)return!1;var f=rr.call(n);if(f!==rr.call(i))return!1;switch(f){case"[object RegExp]":case"[object String]":return""+n==""+i;case"[object Number]":return+n!=+n?+i!=+i:0==+n?1/+n==1/i:+n==+i;case"[object Date]":case"[object Boolean]":return+n==+i;case"[object Symbol]":return"undefined"!=typeof Symbol&&Symbol.valueOf.call(n)===Symbol.valueOf.call(i);case"[object Map]":case"[object Set]":r>=0&&r++}n=mn(n),i=mn(i);var a="[object Array]"===f;if(!a){if("object"!=typeof n||"object"!=typeof i)return!1;var c=n.constructor,h=i.constructor;if(c!==h&&!(e(c)&&c instanceof c&&e(h)&&h instanceof h)&&"constructor"in n&&"constructor"in i)return!1}if(0===r)return!1;r<0&&(r=-1),u=u||[];for(var v=(o=o||[]).length;v--;)if(o[v]===n)return u[v]===i;if(o.push(n),u.push(i),a){if((v=n.length)!==i.length)return!1;for(;v--;)if(!t(n[v],i[v],r-1,o,u))return!1}else{var l,d=Object.keys(n);if(v=d.length,Object.keys(i).length!==v)return!1;for(;v--;)if(!b(i,l=d[v])||!t(n[l],i[l],r-1,o,u))return!1}return o.pop(),u.pop(),!0}(t,n,i)}function mn(t){return un(t)?t.slice():v(t)||Hi(t)||l(t)||Ji(t)?Array.from(t.entries()):t}function wn(t){return t[Symbol.iterator]=jn,t}function jn(){return this}Object.defineProperty(exports,"__esModule",{value:!0});var xn={},On=Object.assign,An=Object.getOwnPropertyDescriptor,gn=Object.defineProperty,_n=Object.prototype,Sn=[];Object.freeze(Sn);var Mn={};Object.freeze(Mn);var Vn="undefined"!=typeof Proxy,Nn=Object.toString(),Rn=function(){},kn=void 0!==Object.getOwnPropertySymbols,En="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:kn?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:Object.getOwnPropertyNames,Tn=Object.getOwnPropertyDescriptors||function(t){var n={};return En(t).forEach((function(i){n[i]=An(t,i)})),n},Cn=Symbol("mobx-stored-annotations"),Kn=Symbol("mobx administration"),Ln=function(){function t(t){void 0===t&&(t="Atom"),this.tt=void 0,this.W=!1,this.H=!1,this.X=new Set,this.B=0,this.F=0,this.G=si.T,this.onBOL=void 0,this.onBUOL=void 0,this.tt=t}var n=t.prototype;return n.onBO=function(){this.onBOL&&this.onBOL.forEach((function(t){return t()}))},n.onBUO=function(){this.onBUOL&&this.onBUOL.forEach((function(t){return t()}))},n.reportObserved=function(){return pt(this)},n.reportChanged=function(){dt(),yt(this),bt()},n.toString=function(){return this.tt},t}(),In=h("Atom",Ln),Pn={identity:function(t,n){return t===n},structural:function(t,n){return yn(t,n)},default:function(t,n){return Object.is?Object.is(t,n):t===n?0!==t||1/t==1/n:t!=t&&n!=n},shallow:function(t,n){return yn(t,n,1)}},Dn=A({t:"override",o:function(){return 0},u:function(){t("'"+this.t+"' can only be used with 'makeObservable'")}}),Bn=G(),qn={deep:!0,name:void 0,defaultDecorator:void 0,proxy:!0};Object.freeze(qn);var Gn=D("observable"),Xn=D("observable.ref",{enhancer:M}),Wn=D("observable.shallow",{enhancer:function(t,n,i){return null==t||an(t)||un(t)||Hi(t)||Ji(t)?t:Array.isArray(t)?$n.array(t,{name:i,deep:!1}):s(t)?$n.object(t,void 0,{name:i,deep:!1}):v(t)?$n.map(t,{name:i,deep:!1}):l(t)?$n.set(t,{name:i,deep:!1}):void 0}}),Hn=D("observable.struct",{enhancer:function(t,n){return yn(t,n)?n:t}}),Un=A(Gn);Object.assign(F,Un);var Fn,zn,$n=On(F,{box:function(t,n){var i=H(n);return new oi(t,U(i),i.name,!0,i.equals)},array:function(t,n){var i=H(n);return(!1===pi.useProxies||!1===i.proxy?ln:tn)(t,U(i),i.name)},map:function(t,n){var i=H(n);return new Wi(t,U(i),i.name)},set:function(t,n){var i=H(n);return new $i(t,U(i),i.name)},object:function(t,n,r){return Nt(!1===pi.useProxies||!1===(null==r?void 0:r.proxy)?sn({},r):function(t,n){var r,e;return i(),null!=(e=(r=(t=sn(t,n))[Kn]).v)?e:r.v=new Proxy(t,ki)}({},r),t,n)},ref:A(Xn),shallow:A(Wn),deep:Un,struct:A(Hn)}),Jn=L("computed"),Yn=L("computed.struct",{equals:Pn.structural}),Qn=function(t,n){if(o(n))return g(t,n,Jn);if(s(t))return A(L("computed",t));var i=s(n)?n:{};return i.get=t,i.name||(i.name=t.name||""),new ai(i)};Object.assign(Qn,Jn),Qn.struct=A(Yn);var Zn,ti=0,ni=1,ii=null!=(Fn=null==(zn=An((function(){}),"name"))?void 0:zn.configurable)&&Fn,ri={value:"action",configurable:!0,writable:!1,enumerable:!1};Zn=Symbol.toPrimitive;var ei,oi=function(t){function n(n,i,r,e,o){var u;return void 0===r&&(r="ObservableValue"),void 0===o&&(o=Pn.default),(u=t.call(this,r)||this).enhancer=void 0,u.tt=void 0,u.equals=void 0,u.wt=!1,u.ut=void 0,u.st=void 0,u.jt=void 0,u.dehancer=void 0,u.enhancer=i,u.tt=r,u.equals=o,u.jt=i(n,void 0,r),u}w(n,t);var i=n.prototype;return i.dehanceValue=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.set=function(t){(t=this.xt(t))!==pi.UNCHANGED&&this.Ot(t)},i.xt=function(t){if(zt(this)){var n=Jt(this,{object:this,type:Ti,newValue:t});if(!n)return pi.UNCHANGED;t=n.newValue}return t=this.enhancer(t,this.jt,this.tt),this.equals(this.jt,t)?pi.UNCHANGED:t},i.Ot=function(t){var n=this.jt;this.jt=t,this.reportChanged(),Yt(this)&&Zt(this,{type:Ti,object:this,newValue:t,oldValue:n})},i.get=function(){return this.reportObserved(),this.dehanceValue(this.jt)},i.At=function(t){return $t(this,t)},i.gt=function(t,n){return n&&t({observableKind:"value",debugObjectName:this.tt,object:this,type:Ti,newValue:this.jt,oldValue:void 0}),Qt(this,t)},i.raw=function(){return this.jt},i.toJSON=function(){return this.get()},i.toString=function(){return this.tt+"["+this.jt+"]"},i.valueOf=function(){return d(this.get())},i[Zn]=function(){return this.valueOf()},n}(Ln),ui=h("ObservableValue",oi);ei=Symbol.toPrimitive;var si,fi,ai=function(){function n(n){this.R=si.T,this.L=[],this.I=null,this.H=!1,this.W=!1,this.X=new Set,this.B=0,this.D=0,this.F=0,this.G=si.k,this.P=0,this.jt=new hi(null),this.tt=void 0,this._t=void 0,this.St=!1,this.Mt=!1,this.derivation=void 0,this.Vt=void 0,this.ot=fi.NONE,this.Nt=void 0,this.Rt=void 0,this.kt=void 0,this.Et=void 0,this.onBOL=void 0,this.onBUOL=void 0,n.get||t(31),this.derivation=n.get,this.tt=n.name||"ComputedValue",n.set&&(this.Vt=z("ComputedValue-setter",n.set)),this.Rt=n.equals||(n.compareStructural||n.struct?Pn.structural:Pn.default),this.Nt=n.context,this.kt=!!n.requiresReaction,this.Et=!!n.keepAlive}var i=n.prototype;return i.q=function(){!function(t){t.G===si.k&&(t.G=si.K,t.X.forEach((function(t){t.R===si.k&&(t.R=si.K,t.q())})))}(this)},i.onBO=function(){this.onBOL&&this.onBOL.forEach((function(t){return t()}))},i.onBUO=function(){this.onBUOL&&this.onBUOL.forEach((function(t){return t()}))},i.get=function(){if(this.St&&t(32,this.tt,this.derivation),0!==pi.inBatch||0!==this.X.size||this.Et){if(pt(this),it(this)){var n=pi.trackingContext;this.Et&&!n&&(pi.trackingContext=this),this.trackAndCompute()&&function(t){t.G!==si.C&&(t.G=si.C,t.X.forEach((function(n){n.R===si.K?n.R=si.C:n.R===si.k&&(t.G=si.k)})))}(this),pi.trackingContext=n}}else it(this)&&(this.Tt(),dt(),this.jt=this.Ct(!1),bt());var i=this.jt;if(nt(i))throw i.cause;return i},i.set=function(n){if(this.Vt){this.Mt&&t(33,this.tt),this.Mt=!0;try{this.Vt.call(this.Nt,n)}finally{this.Mt=!1}}else t(34,this.tt)},i.trackAndCompute=function(){var t=this.jt,n=this.R===si.T,i=this.Ct(!0),r=n||nt(t)||nt(i)||!this.Rt(t,i);return r&&(this.jt=i),r},i.Ct=function(t){this.St=!0;var n,i=Z(!1);if(t)n=rt(this,this.derivation,this.Nt);else if(!0===pi.disableErrorBoundaries)n=this.derivation.call(this.Nt);else try{n=this.derivation.call(this.Nt)}catch(t){n=new hi(t)}return tt(i),this.St=!1,n},i.U=function(){this.Et||(et(this),this.jt=void 0)},i.gt=function(t,n){var i=this,r=!0,e=void 0;return gt((function(){var o=i.get();if(!r||n){var u=ut();t({observableKind:"computed",debugObjectName:i.tt,type:Ti,object:i,newValue:o,oldValue:e}),st(u)}r=!1,e=o}))},i.Tt=function(){},i.toString=function(){return this.tt+"["+this.derivation.toString()+"]"},i.valueOf=function(){return d(this.get())},i[ei]=function(){return this.valueOf()},n}(),ci=h("ComputedValue",ai);!function(t){t[t.T=-1]="NOT_TRACKING_",t[t.k=0]="UP_TO_DATE_",t[t.K=1]="POSSIBLY_STALE_",t[t.C=2]="STALE_"}(si||(si={})),function(t){t[t.NONE=0]="NONE",t[t.LOG=1]="LOG",t[t.BREAK=2]="BREAK"}(fi||(fi={}));var hi=function(t){this.cause=void 0,this.cause=t},vi=["mobxGuid","spyListeners","enforceActions","computedRequiresReaction","reactionRequiresObservable","observableRequiresReaction","allowStateReads","disableErrorBoundaries","runId","UNCHANGED","useProxies"],li=function(){this.version=6,this.UNCHANGED={},this.trackingDerivation=null,this.trackingContext=null,this.runId=0,this.mobxGuid=0,this.inBatch=0,this.pendingUnobservations=[],this.pendingReactions=[],this.isRunningReactions=!1,this.allowStateChanges=!1,this.allowStateReads=!0,this.enforceActions=!0,this.spyListeners=[],this.globalReactionErrorHandlers=[],this.computedRequiresReaction=!1,this.reactionRequiresObservable=!1,this.observableRequiresReaction=!1,this.disableErrorBoundaries=!1,this.suppressReactionErrors=!1,this.useProxies=!0,this.verifyProxies=!1,this.safeDescriptors=!0},di=!0,bi=!1,pi=function(){var i=n();return i.__mobxInstanceCount>0&&!i.__mobxGlobals&&(di=!1),i.__mobxGlobals&&i.__mobxGlobals.version!==(new li).version&&(di=!1),di?i.__mobxGlobals?(i.__mobxInstanceCount+=1,i.__mobxGlobals.UNCHANGED||(i.__mobxGlobals.UNCHANGED={}),i.__mobxGlobals):(i.__mobxInstanceCount=1,i.__mobxGlobals=new li):(setTimeout((function(){bi||t(35)}),1),new li)}(),yi=function(){function t(t,n,i,r){void 0===t&&(t="Reaction"),void 0===r&&(r=!1),this.tt=void 0,this.Kt=void 0,this.Lt=void 0,this.It=void 0,this.L=[],this.I=[],this.R=si.T,this.B=0,this.D=0,this.P=0,this.J=!1,this.Pt=!1,this.Dt=!1,this.Bt=!1,this.ot=fi.NONE,this.tt=t,this.Kt=n,this.Lt=i,this.It=r}var n=t.prototype;return n.q=function(){this.Y()},n.Y=function(){this.Pt||(this.Pt=!0,pi.pendingReactions.push(this),mt())},n.isScheduled=function(){return this.Pt},n.$=function(){if(!this.J){dt(),this.Pt=!1;var t=pi.trackingContext;if(pi.trackingContext=this,it(this)){this.Dt=!0;try{this.Kt()}catch(t){this.qt(t)}}pi.trackingContext=t,bt()}},n.track=function(t){if(!this.J){dt(),this.Bt=!0;var n=pi.trackingContext;pi.trackingContext=this;var i=rt(this,t,void 0);pi.trackingContext=n,this.Bt=!1,this.Dt=!1,this.J&&et(this),nt(i)&&this.qt(i.cause),bt()}},n.qt=function(t){var n=this;if(this.Lt)this.Lt(t,this);else{if(pi.disableErrorBoundaries)throw t;pi.suppressReactionErrors||console.error("[mobx] uncaught error in '"+this+"'",t),pi.globalReactionErrorHandlers.forEach((function(i){return i(t,n)}))}},n.dispose=function(){this.J||(this.J=!0,this.Bt||(dt(),et(this),bt()))},n.Z=function(){var t=this.dispose.bind(this);return t[Kn]=this,t},n.toString=function(){return"Reaction["+this.tt+"]"},n.trace=function(t){void 0===t&&(t=!1),Gt(this,t)},t}(),mi=function(t){return t()},wi=h("Reaction",yi),ji=V("action"),xi=V("action.bound",{bound:!0}),Oi=V("autoAction",{autoAction:!0}),Ai=V("autoAction.bound",{autoAction:!0,bound:!0}),gi=xt(!1);Object.assign(gi,ji);var _i=xt(!0);Object.assign(_i,Oi),gi.bound=A(xi),_i.bound=A(Ai);var Si=function(t){return t()},Mi=0;Et.prototype=Object.create(Error.prototype);var Vi=E("flow"),Ni=E("flow.bound",{bound:!0}),Ri=Object.assign((function(t,n){if(o(n))return g(t,n,Vi);var i=t,r=i.name||"<unnamed flow>",u=function(){var t,n=this,o=arguments,u=++Mi,s=gi(r+" - runid: "+u+" - init",i).apply(n,o),f=void 0,a=new Promise((function(n,i){function o(t){var n;f=void 0;try{n=gi(r+" - runid: "+u+" - yield "+h++,s.next).call(s,t)}catch(t){return i(t)}c(n)}function a(t){var n;f=void 0;try{n=gi(r+" - runid: "+u+" - yield "+h++,s.throw).call(s,t)}catch(t){return i(t)}c(n)}function c(t){if(!e(null==t?void 0:t.then))return t.done?n(t.value):(f=Promise.resolve(t.value)).then(o,a);t.then(c,i)}var h=0;t=i,o(void 0)}));return a.cancel=gi(r+" - runid: "+u+" - cancel",(function(){try{f&&Tt(f);var n=s.return(void 0),i=Promise.resolve(n.value);i.then(Rn,Rn),Tt(i),t(new Et)}catch(n){t(n)}})),a};return u.isMobXFlow=!0,u}),Vi);Ri.bound=A(Ni);var ki={has:function(t,n){return Ft(t).rt(n)},get:function(t,n){return Ft(t).lt(n)},set:function(t,n,i){var r;return!!o(n)&&(null==(r=Ft(t).dt(n,i,!0))||r)},deleteProperty:function(t,n){var i;return!!o(n)&&(null==(i=Ft(t).Gt(n,!0))||i)},defineProperty:function(t,n,i){var r;return null==(r=Ft(t).h(n,i))||r},ownKeys:function(t){return Ft(t).et()},preventExtensions:function(){t(13)}},Ei=Symbol("mobx-keys"),Ti="update",Ci={get:function(t,n){var i=t[Kn];return n===Kn?i:"length"===n?i.Xt():"string"!=typeof n||isNaN(n)?b(Li,n)?Li[n]:t[n]:i.lt(parseInt(n))},set:function(t,n,i){var r=t[Kn];return"length"===n&&r.Wt(i),"symbol"==typeof n||isNaN(n)?t[n]=i:r.dt(parseInt(n),i),!0},preventExtensions:function(){t(15)}},Ki=function(){function n(t,n,i,r){void 0===t&&(t="ObservableArray"),this.Ht=void 0,this.Ut=void 0,this.at=void 0,this.nt=[],this.ut=void 0,this.st=void 0,this.Ft=void 0,this.dehancer=void 0,this.v=void 0,this.zt=0,this.Ht=i,this.Ut=r,this.at=new Ln(t),this.Ft=function(t,i){return n(t,i,"ObservableArray[..]")}}var i=n.prototype;return i.$t=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.ct=function(t){return void 0!==this.dehancer&&t.length>0?t.map(this.dehancer):t},i.At=function(t){return $t(this,t)},i.gt=function(t,n){return void 0===n&&(n=!1),n&&t({observableKind:"array",object:this.v,debugObjectName:this.at.tt,type:"splice",index:0,added:this.nt.slice(),addedCount:this.nt.length,removed:[],removedCount:0}),Qt(this,t)},i.Xt=function(){return this.at.reportObserved(),this.nt.length},i.Wt=function(n){("number"!=typeof n||n<0)&&t("Out of range: "+n);var i=this.nt.length;if(n!==i)if(n>i){for(var r=new Array(n-i),e=0;e<n-i;e++)r[e]=void 0;this.ft(i,0,r)}else this.ft(n,i-n)},i.Jt=function(n,i){n!==this.zt&&t(16),this.zt+=i,this.Ut&&i>0&&vn(n+i+1)},i.ft=function(t,n,i){var r=this,e=this.nt.length;if(void 0===t?t=0:t>e?t=e:t<0&&(t=Math.max(0,e+t)),n=1===arguments.length?e-t:null==n?0:Math.max(0,Math.min(n,e-t)),void 0===i&&(i=Sn),zt(this)){var o=Jt(this,{object:this.v,type:"splice",index:t,removedCount:n,added:i});if(!o)return Sn;n=o.removedCount,i=o.added}if(i=0===i.length?i:i.map((function(t){return r.Ft(t,void 0)})),this.Ut){var u=i.length-n;this.Jt(e,u)}var s=this.Yt(t,n,i);return 0===n&&0===i.length||this.Qt(t,i,s),this.ct(s)},i.Yt=function(t,n,i){var r;if(i.length<1e4)return(r=this.nt).splice.apply(r,[t,n].concat(i));var e=this.nt.slice(t,t+n),o=this.nt.slice(t+n);this.nt.length=t+i.length-n;for(var u=0;u<i.length;u++)this.nt[t+u]=i[u];for(var s=0;s<o.length;s++)this.nt[t+i.length+s]=o[s];return e},i.Zt=function(t,n,i){var r=!this.Ht&&!1,e=Yt(this),o=e||r?{observableKind:"array",object:this.v,type:Ti,debugObjectName:this.at.tt,index:t,newValue:n,oldValue:i}:null;this.at.reportChanged(),e&&Zt(this,o)},i.Qt=function(t,n,i){var r=!this.Ht&&!1,e=Yt(this),o=e||r?{observableKind:"array",object:this.v,debugObjectName:this.at.tt,type:"splice",index:t,removed:i,added:n,removedCount:i.length,addedCount:n.length}:null;this.at.reportChanged(),e&&Zt(this,o)},i.lt=function(t){if(t<this.nt.length)return this.at.reportObserved(),this.$t(this.nt[t]);console.warn("[mobx.array] Attempt to read an array index ("+t+") that is out of bounds ("+this.nt.length+"). Please check length first. Out of bound indices will not be tracked by MobX")},i.dt=function(n,i){var r=this.nt;if(n<r.length){var e=r[n];if(zt(this)){var o=Jt(this,{type:Ti,object:this.v,index:n,newValue:i});if(!o)return;i=o.newValue}(i=this.Ft(i,e))!==e&&(r[n]=i,this.Zt(n,i,e))}else n===r.length?this.ft(n,0,[i]):t(17,n,r.length)},n}(),Li={clear:function(){return this.splice(0)},replace:function(t){var n=this[Kn];return n.ft(0,n.nt.length,t)},toJSON:function(){return this.slice()},splice:function(t,n){for(var i=arguments.length,r=new Array(i>2?i-2:0),e=2;e<i;e++)r[e-2]=arguments[e];var o=this[Kn];switch(arguments.length){case 0:return[];case 1:return o.ft(t);case 2:return o.ft(t,n)}return o.ft(t,n,r)},spliceWithArray:function(t,n,i){return this[Kn].ft(t,n,i)},push:function(){for(var t=this[Kn],n=arguments.length,i=new Array(n),r=0;r<n;r++)i[r]=arguments[r];return t.ft(t.nt.length,0,i),t.nt.length},pop:function(){return this.splice(Math.max(this[Kn].nt.length-1,0),1)[0]},shift:function(){return this.splice(0,1)[0]},unshift:function(){for(var t=this[Kn],n=arguments.length,i=new Array(n),r=0;r<n;r++)i[r]=arguments[r];return t.ft(0,0,i),t.nt.length},reverse:function(){return pi.trackingDerivation&&t(37,"reverse"),this.replace(this.slice().reverse()),this},sort:function(){pi.trackingDerivation&&t(37,"sort");var n=this.slice();return n.sort.apply(n,arguments),this.replace(n),this},remove:function(t){var n=this[Kn],i=n.ct(n.nt).indexOf(t);return i>-1&&(this.splice(i,1),!0)}};nn("concat",rn),nn("flat",rn),nn("includes",rn),nn("indexOf",rn),nn("join",rn),nn("lastIndexOf",rn),nn("slice",rn),nn("toString",rn),nn("toLocaleString",rn),nn("every",en),nn("filter",en),nn("find",en),nn("findIndex",en),nn("flatMap",en),nn("forEach",en),nn("map",en),nn("some",en),nn("reduce",on),nn("reduceRight",on);var Ii,Pi,Di=h("ObservableArrayAdministration",Ki),Bi={},qi="add";Ii=Symbol.iterator,Pi=Symbol.toStringTag;var Gi,Xi,Wi=function(){function n(n,i,r){void 0===i&&(i=S),void 0===r&&(r="ObservableMap"),this.Ft=void 0,this.tt=void 0,this[Kn]=Bi,this.pt=void 0,this.yt=void 0,this.bt=void 0,this.ut=void 0,this.st=void 0,this.dehancer=void 0,this.Ft=i,this.tt=r,e(Map)||t(18),this.bt=_("ObservableMap.keys()"),this.pt=new Map,this.yt=new Map,this.merge(n)}var i=n.prototype;return i.rt=function(t){return this.pt.has(t)},i.has=function(t){var n=this;if(!pi.trackingDerivation)return this.rt(t);var i=this.yt.get(t);if(!i){var r=i=new oi(this.rt(t),M,"ObservableMap.key?",!1);this.yt.set(t,r),Mt(r,(function(){return n.yt.delete(t)}))}return i.get()},i.set=function(t,n){var i=this.rt(t);if(zt(this)){var r=Jt(this,{type:i?Ti:qi,object:this,newValue:n,name:t});if(!r)return this;n=r.newValue}return i?this.tn(t,n):this.nn(t,n),this},i.delete=function(t){var n=this;if(zt(this)&&!Jt(this,{type:"delete",object:this,name:t}))return!1;if(this.rt(t)){var i=Yt(this),r=i?{observableKind:"map",debugObjectName:this.tt,type:"delete",object:this,oldValue:this.pt.get(t).jt,name:t}:null;return Wt((function(){n.bt.reportChanged(),n.in(t,!1),n.pt.get(t).Ot(void 0),n.pt.delete(t)})),i&&Zt(this,r),!0}return!1},i.in=function(t,n){var i=this.yt.get(t);i&&i.Ot(n)},i.tn=function(t,n){var i=this.pt.get(t);if((n=i.xt(n))!==pi.UNCHANGED){var r=Yt(this),e=r?{observableKind:"map",debugObjectName:this.tt,type:Ti,object:this,oldValue:i.jt,name:t,newValue:n}:null;i.Ot(n),r&&Zt(this,e)}},i.nn=function(t,n){var i=this;Wt((function(){var r=new oi(n,i.Ft,"ObservableMap.key",!1);i.pt.set(t,r),n=r.jt,i.in(t,!0),i.bt.reportChanged()}));var r=Yt(this);r&&Zt(this,r?{observableKind:"map",debugObjectName:this.tt,type:qi,object:this,name:t,newValue:n}:null)},i.get=function(t){return this.has(t)?this.$t(this.pt.get(t).get()):this.$t(void 0)},i.$t=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.keys=function(){return this.bt.reportObserved(),this.pt.keys()},i.values=function(){var t=this,n=this.keys();return wn({next:function(){var i=n.next(),r=i.done;return{done:r,value:r?void 0:t.get(i.value)}}})},i.entries=function(){var t=this,n=this.keys();return wn({next:function(){var i=n.next(),r=i.done,e=i.value;return{done:r,value:r?void 0:[e,t.get(e)]}}})},i[Ii]=function(){return this.entries()},i.forEach=function(t,n){for(var i,r=O(this);!(i=r()).done;){var e=i.value;t.call(n,e[1],e[0],this)}},i.merge=function(n){var i=this;return Hi(n)&&(n=new Map(n)),Wt((function(){s(n)?function(t){var n=Object.keys(t);if(!kn)return n;var i=Object.getOwnPropertySymbols(t);return i.length?[].concat(n,i.filter((function(n){return _n.propertyIsEnumerable.call(t,n)}))):n}(n).forEach((function(t){return i.set(t,n[t])})):Array.isArray(n)?n.forEach((function(t){return i.set(t[0],t[1])})):v(n)?(n.constructor!==Map&&t(19,n),n.forEach((function(t,n){return i.set(n,t)}))):null!=n&&t(20,n)})),this},i.clear=function(){var t=this;Wt((function(){ot((function(){for(var n,i=O(t.keys());!(n=i()).done;)t.delete(n.value)}))}))},i.replace=function(n){var i=this;return Wt((function(){for(var r,e=function(n){if(v(n)||Hi(n))return n;if(Array.isArray(n))return new Map(n);if(s(n)){var i=new Map;for(var r in n)i.set(r,n[r]);return i}return t(21,n)}(n),o=new Map,u=!1,f=O(i.pt.keys());!(r=f()).done;){var a=r.value;if(!e.has(a))if(i.delete(a))u=!0;else{var c=i.pt.get(a);o.set(a,c)}}for(var h,l=O(e.entries());!(h=l()).done;){var d=h.value,b=d[0],p=d[1],y=i.pt.has(b);if(i.set(b,p),i.pt.has(b)){var m=i.pt.get(b);o.set(b,m),y||(u=!0)}}if(!u)if(i.pt.size!==o.size)i.bt.reportChanged();else for(var w=i.pt.keys(),j=o.keys(),x=w.next(),A=j.next();!x.done;){if(x.value!==A.value){i.bt.reportChanged();break}x=w.next(),A=j.next()}i.pt=o})),this},i.toString=function(){return"[object ObservableMap]"},i.toJSON=function(){return Array.from(this)},i.gt=function(t){return Qt(this,t)},i.At=function(t){return $t(this,t)},y(n,[{key:"size",get:function(){return this.bt.reportObserved(),this.pt.size}},{key:Pi,get:function(){return"Map"}}]),n}(),Hi=h("ObservableMap",Wi),Ui={};Gi=Symbol.iterator,Xi=Symbol.toStringTag;var Fi,zi,$i=function(){function n(n,i,r){void 0===i&&(i=S),void 0===r&&(r="ObservableSet"),this.tt=void 0,this[Kn]=Ui,this.pt=new Set,this.at=void 0,this.st=void 0,this.ut=void 0,this.dehancer=void 0,this.Ft=void 0,this.tt=r,e(Set)||t(22),this.at=_(this.tt),this.Ft=function(t,n){return i(t,n,r)},n&&this.replace(n)}var i=n.prototype;return i.$t=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.clear=function(){var t=this;Wt((function(){ot((function(){for(var n,i=O(t.pt.values());!(n=i()).done;)t.delete(n.value)}))}))},i.forEach=function(t,n){for(var i,r=O(this);!(i=r()).done;){var e=i.value;t.call(n,e,e,this)}},i.add=function(t){var n=this;if(zt(this)&&!Jt(this,{type:qi,object:this,newValue:t}))return this;if(!this.has(t)){Wt((function(){n.pt.add(n.Ft(t,void 0)),n.at.reportChanged()}));var i=Yt(this);i&&Zt(this,i?{observableKind:"set",debugObjectName:this.tt,type:qi,object:this,newValue:t}:null)}return this},i.delete=function(t){var n=this;if(zt(this)&&!Jt(this,{type:"delete",object:this,oldValue:t}))return!1;if(this.has(t)){var i=Yt(this),r=i?{observableKind:"set",debugObjectName:this.tt,type:"delete",object:this,oldValue:t}:null;return Wt((function(){n.at.reportChanged(),n.pt.delete(t)})),i&&Zt(this,r),!0}return!1},i.has=function(t){return this.at.reportObserved(),this.pt.has(this.$t(t))},i.entries=function(){var t=0,n=Array.from(this.keys()),i=Array.from(this.values());return wn({next:function(){var r=t;return t+=1,r<i.length?{value:[n[r],i[r]],done:!1}:{done:!0}}})},i.keys=function(){return this.values()},i.values=function(){this.at.reportObserved();var t=this,n=0,i=Array.from(this.pt.values());return wn({next:function(){return n<i.length?{value:t.$t(i[n++]),done:!1}:{done:!0}}})},i.replace=function(n){var i=this;return Ji(n)&&(n=new Set(n)),Wt((function(){Array.isArray(n)||l(n)?(i.clear(),n.forEach((function(t){return i.add(t)}))):null!=n&&t("Cannot initialize set from "+n)})),this},i.gt=function(t){return Qt(this,t)},i.At=function(t){return $t(this,t)},i.toJSON=function(){return Array.from(this)},i.toString=function(){return"[object ObservableSet]"},i[Gi]=function(){return this.values()},y(n,[{key:"size",get:function(){return this.at.reportObserved(),this.pt.size}},{key:Xi,get:function(){return"Set"}}]),n}(),Ji=h("ObservableSet",$i),Yi=Object.create(null),Qi=function(){function n(t,n,i,r){void 0===n&&(n=new Map),void 0===r&&(r=Bn),this.s=void 0,this.nt=void 0,this.tt=void 0,this.rn=void 0,this.bt=void 0,this.st=void 0,this.ut=void 0,this.v=void 0,this.l=void 0,this.en=void 0,this.on=void 0,this.s=t,this.nt=n,this.tt=i,this.rn=r,this.bt=new Ln("ObservableObject.keys"),this.l=s(this.s)}var i=n.prototype;return i.ht=function(t){return this.nt.get(t).get()},i.vt=function(t,n){var i=this.nt.get(t);if(i instanceof ai)return i.set(n),!0;if(zt(this)){var r=Jt(this,{type:Ti,object:this.v||this.s,name:t,newValue:n});if(!r)return null;n=r.newValue}if((n=i.xt(n))!==pi.UNCHANGED){var e=Yt(this),o=e?{type:Ti,observableKind:"object",debugObjectName:this.tt,object:this.v||this.s,oldValue:i.jt,name:t,newValue:n}:null;i.Ot(n),e&&Zt(this,o)}return!0},i.lt=function(t){return pi.trackingDerivation&&!b(this.s,t)&&this.rt(t),this.s[t]},i.dt=function(t,n,i){return void 0===i&&(i=!1),b(this.s,t)?this.nt.has(t)?this.vt(t,n):i?Reflect.set(this.s,t,n):(this.s[t]=n,!0):this.u(t,{value:n,enumerable:!0,writable:!0,configurable:!0},this.rn,i)},i.rt=function(t){if(!pi.trackingDerivation)return t in this.s;this.on||(this.on=new Map);var n=this.on.get(t);return n||(n=new oi(t in this.s,M,"ObservableObject.key?",!1),this.on.set(t,n)),n.get()},i.o=function(n,i){if(!0===i&&(i=this.rn),!1!==i){if(!(n in this.s)){var r;if(null==(r=this.s[Cn])?void 0:r[n])return;t(1,i.t,this.tt+"."+n.toString())}for(var e=this.s;e&&e!==_n;){var o=An(e,n);if(o){var u=i.o(this,n,o,e);if(0===u)return;if(1===u)break}e=Object.getPrototypeOf(e)}cn(this,0,n)}},i.u=function(t,n,i,r){if(void 0===r&&(r=!1),!0===i&&(i=this.rn),!1===i)return this.h(t,n,r);var e=i.u(this,t,n,r);return e&&cn(this,0,t),e},i.h=function(t,n,i){void 0===i&&(i=!1);try{dt();var r=this.Gt(t);if(!r)return r;if(zt(this)){var e=Jt(this,{object:this.v||this.s,name:t,type:qi,newValue:n.value});if(!e)return null;var o=e.newValue;n.value!==o&&(n=m({},n,{value:o}))}if(i){if(!Reflect.defineProperty(this.s,t,n))return!1}else gn(this.s,t,n);this.un(t,n.value)}finally{bt()}return!0},i.m=function(t,n,i,r){void 0===r&&(r=!1);try{dt();var e=this.Gt(t);if(!e)return e;if(zt(this)){var o=Jt(this,{object:this.v||this.s,name:t,type:qi,newValue:n});if(!o)return null;n=o.newValue}var u=fn(t),s={configurable:!pi.safeDescriptors||this.l,enumerable:!0,get:u.get,set:u.set};if(r){if(!Reflect.defineProperty(this.s,t,s))return!1}else gn(this.s,t,s);var f=new oi(n,i,"ObservableObject.key",!1);this.nt.set(t,f),this.un(t,f.jt)}finally{bt()}return!0},i.p=function(t,n,i){void 0===i&&(i=!1);try{dt();var r=this.Gt(t);if(!r)return r;if(zt(this)&&!Jt(this,{object:this.v||this.s,name:t,type:qi,newValue:void 0}))return null;n.name||(n.name="ObservableObject.key"),n.context=this.v||this.s;var e=fn(t),o={configurable:!pi.safeDescriptors||this.l,enumerable:!1,get:e.get,set:e.set};if(i){if(!Reflect.defineProperty(this.s,t,o))return!1}else gn(this.s,t,o);this.nt.set(t,new ai(n)),this.un(t,void 0)}finally{bt()}return!0},i.Gt=function(t,n){if(void 0===n&&(n=!1),!b(this.s,t))return!0;if(zt(this)&&!Jt(this,{object:this.v||this.s,name:t,type:"remove"}))return null;try{var i,r;dt();var e,o=Yt(this),u=this.nt.get(t),s=void 0;if(!u&&o&&(s=null==(e=An(this.s,t))?void 0:e.value),n){if(!Reflect.deleteProperty(this.s,t))return!1}else delete this.s[t];u&&(this.nt.delete(t),u instanceof oi&&(s=u.jt),yt(u)),this.bt.reportChanged(),null==(i=this.on)||null==(r=i.get(t))||r.set(t in this.s),o&&o&&Zt(this,{type:"remove",observableKind:"object",object:this.v||this.s,debugObjectName:this.tt,oldValue:s,name:t})}finally{bt()}return!0},i.gt=function(t){return Qt(this,t)},i.At=function(t){return $t(this,t)},i.un=function(t,n){var i,r,e=Yt(this);e&&e&&Zt(this,e?{type:qi,observableKind:"object",debugObjectName:this.tt,object:this.v||this.s,name:t,newValue:n}:null),null==(i=this.on)||null==(r=i.get(t))||r.set(!0),this.bt.reportChanged()},i.et=function(){return this.bt.reportObserved(),En(this.s)},i.it=function(){return this.bt.reportObserved(),Object.keys(this.s)},n}(),Zi=h("ObservableObjectAdministration",Qi),tr=0,nr=function(){};Fi=nr,zi=Array.prototype,Object.setPrototypeOf?Object.setPrototypeOf(Fi.prototype,zi):void 0!==Fi.prototype.__proto__?Fi.prototype.__proto__=zi:Fi.prototype=zi;var ir=function(t){function n(n,i,r,e){var o;void 0===r&&(r="ObservableArray"),void 0===e&&(e=!1),o=t.call(this)||this;var u=new Ki(r,i,e,!0);if(u.v=j(o),c(j(o),Kn,u),n&&n.length){var s=Z(!0);o.spliceWithArray(0,0,n),tt(s)}return o}w(n,t);var i=n.prototype;return i.concat=function(){this[Kn].at.reportObserved();for(var t=arguments.length,n=new Array(t),i=0;i<t;i++)n[i]=arguments[i];return Array.prototype.concat.apply(this.slice(),n.map((function(t){return un(t)?t.slice():t})))},i[Symbol.iterator]=function(){var t=this,n=0;return wn({next:function(){return n<t.length?{value:t[n++],done:!1}:{done:!0,value:void 0}}})},y(n,[{key:"length",get:function(){return this[Kn].Xt()},set:function(t){this[Kn].Wt(t)}},{key:Symbol.toStringTag,get:function(){return"Array"}}]),n}(nr);Object.entries(Li).forEach((function(t){var n=t[0];"concat"!==n&&a(ir.prototype,n,t[1])})),vn(1e3);var rr=_n.toString;["Symbol","Map","Set"].forEach((function(i){void 0===n()[i]&&t("MobX requires global '"+i+"' to be available or polyfilled")})),"object"==typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__&&__MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({spy:jt,extras:{getDebugName:pn},$mobx:Kn}),exports.$mobx=Kn,exports.FlowCancellationError=Et,exports.ObservableMap=Wi,exports.ObservableSet=$i,exports.Reaction=yi,exports._allowStateChanges=Q,exports._allowStateChangesInsideComputed=Ot,exports._allowStateReadsEnd=at,exports._allowStateReadsStart=ft,exports._autoAction=_i,exports._endAction=Y,exports._getAdministration=bn,exports._getGlobalState=function(){return pi},exports._interceptReads=function(t,n,i){var r;return Hi(t)||un(t)||ui(t)?r=bn(t):an(t)&&(r=bn(t,n)),r.dehancer="function"==typeof n?n:i,function(){r.dehancer=void 0}},exports._isComputingDerivation=function(){return null!==pi.trackingDerivation},exports._resetGlobalState=function(){var t=new li;for(var n in t)-1===vi.indexOf(n)&&(pi[n]=t[n]);pi.allowStateChanges=!pi.enforceActions},exports._startAction=J,exports.action=gi,exports.autorun=gt,exports.comparer=Pn,exports.computed=Qn,exports.configure=function(i){!0===i.isolateGlobalState&&function(){if((pi.pendingReactions.length||pi.inBatch||pi.isRunningReactions)&&t(36),bi=!0,di){var i=n();0==--i.__mobxInstanceCount&&(i.__mobxGlobals=void 0),pi=new li}}();var r,e,o=i.useProxies,u=i.enforceActions;if(void 0!==o&&(pi.useProxies="always"===o||"never"!==o&&"undefined"!=typeof Proxy),"ifavailable"===o&&(pi.verifyProxies=!0),void 0!==u){var s="always"===u?"always":"observed"===u;pi.enforceActions=s,pi.allowStateChanges=!0!==s&&"always"!==s}["computedRequiresReaction","reactionRequiresObservable","observableRequiresReaction","disableErrorBoundaries","safeDescriptors"].forEach((function(t){t in i&&(pi[t]=!!i[t])})),pi.allowStateReads=!pi.observableRequiresReaction,i.reactionScheduler&&(r=i.reactionScheduler,e=mi,mi=function(t){return r((function(){return e(t)}))})},exports.createAtom=_,exports.defineProperty=function(n,i,r){if(an(n))return n[Kn].h(i,r);t(39)},exports.entries=function(n){return an(n)?Pt(n).map((function(t){return[t,n[t]]})):Hi(n)?Pt(n).map((function(t){return[t,n.get(t)]})):Ji(n)?Array.from(n.entries()):un(n)?n.map((function(t,n){return[n,t]})):void t(7)},exports.extendObservable=Nt,exports.flow=Ri,exports.flowResult=function(t){return t},exports.get=function(n,i){if(Dt(n,i))return an(n)?n[Kn].lt(i):Hi(n)?n.get(i):un(n)?n[i]:void t(11)},exports.getAtom=dn,exports.getDebugName=pn,exports.getDependencyTree=function(t,n){return Rt(dn(t,n))},exports.getObserverTree=function(t,n){return kt(dn(t,n))},exports.has=Dt,exports.intercept=function(t,n,i){return e(i)?function(t,n,i){return bn(t,n).At(i)}(t,n,i):function(t,n){return bn(t).At(n)}(t,n)},exports.isAction=At,exports.isBoxedObservable=ui,exports.isComputed=function(t){return Kt(t)},exports.isComputedProp=function(t,n){return Kt(t,n)},exports.isFlow=Ct,exports.isFlowCancellationError=function(t){return t instanceof Et},exports.isObservable=It,exports.isObservableArray=un,exports.isObservableMap=Hi,exports.isObservableObject=an,exports.isObservableProp=function(t,n){return Lt(t,n)},exports.isObservableSet=Ji,exports.keys=Pt,exports.makeAutoObservable=function(t,n,i){if(s(t))return Nt(t,t,n,i);var r=sn(t,i)[Kn];if(!t[Ei]){var e=Object.getPrototypeOf(t),o=new Set([].concat(En(t),En(e)));o.delete("constructor"),o.delete(Kn),a(e,Ei,o)}dt();try{t[Ei].forEach((function(t){return r.o(t,!n||!(t in n)||n[t])}))}finally{bt()}return t},exports.makeObservable=function(t,n,i){var r=sn(t,i)[Kn];dt();try{null!=n||(n=function(t){return b(t,Cn)||a(t,Cn,m({},t[Cn])),t[Cn]}(t)),En(n).forEach((function(t){return r.o(t,n[t])}))}finally{bt()}return t},exports.observable=$n,exports.observe=function(t,n,i,r){return e(i)?function(t,n,i,r){return bn(t,n).gt(i,r)}(t,n,i,r):function(t,n,i){return bn(t).gt(n,i)}(t,n,i)},exports.onBecomeObserved=St,exports.onBecomeUnobserved=Mt,exports.onReactionError=function(t){return pi.globalReactionErrorHandlers.push(t),function(){var n=pi.globalReactionErrorHandlers.indexOf(t);n>=0&&pi.globalReactionErrorHandlers.splice(n,1)}},exports.override=Dn,exports.ownKeys=Bt,exports.reaction=function(t,n,i){function r(){if(l=!1,!p.J){var n=!1;p.track((function(){var i=Q(!1,(function(){return t(p)}));n=v||!b(s,i),d=s,s=i})),(v&&i.fireImmediately||!v&&n)&&a(s,d,p),v=!1}}var e;void 0===i&&(i=Mn);var o,u,s,f=null!=(e=i.name)?e:"Reaction",a=gi(f,i.onError?(o=i.onError,u=n,function(){try{return u.apply(this,arguments)}catch(t){o.call(this,t)}}):n),c=!i.scheduler&&!i.delay,h=_t(i),v=!0,l=!1,d=void 0,b=i.compareStructural?Pn.structural:i.equals||Pn.default,p=new yi(f,(function(){v||c?r():l||(l=!0,h(r))}),i.onError,i.requiresObservable);return p.Y(),p.Z()},exports.remove=function(n,i){an(n)?n[Kn].Gt(i):Hi(n)||Ji(n)?n.delete(i):un(n)?("number"!=typeof i&&(i=parseInt(i,10)),n.splice(i,1)):t(9)},exports.runInAction=Ot,exports.set=function n(i,r,e){if(2!==arguments.length||Ji(i))an(i)?i[Kn].dt(r,e):Hi(i)?i.set(r,e):Ji(i)?i.add(r):un(i)?("number"!=typeof r&&(r=parseInt(r,10)),r<0&&t("Invalid index: '"+r+"'"),dt(),r>=i.length&&(i.length=r+1),i[r]=e,bt()):t(8);else{dt();var o=r;try{for(var u in o)n(i,u,o[u])}finally{bt()}}},exports.spy=jt,exports.toJS=function(t){return function t(n,i){if(null==n||"object"!=typeof n||n instanceof Date||!It(n))return n;if(ui(n)||ci(n))return t(n.get(),i);if(i.has(n))return i.get(n);if(un(n)){var r=qt(i,n,new Array(n.length));return n.forEach((function(n,e){r[e]=t(n,i)})),r}if(Ji(n)){var e=qt(i,n,new Set);return n.forEach((function(n){e.add(t(n,i))})),e}if(Hi(n)){var o=qt(i,n,new Map);return n.forEach((function(n,r){o.set(r,t(n,i))})),o}var u=qt(i,n,{});return Bt(n).forEach((function(r){_n.propertyIsEnumerable.call(n,r)&&(u[r]=t(n[r],i))})),u}(t,new Map)},exports.trace=Gt,exports.transaction=Wt,exports.untracked=ot,exports.values=function(n){return an(n)?Pt(n).map((function(t){return n[t]})):Hi(n)?Pt(n).map((function(t){return n.get(t)})):Ji(n)?Array.from(n.values()):un(n)?n.slice():void t(6)},exports.when=function(t,n,i){return 1===arguments.length||n&&"object"==typeof n?Ut(t,n):Ht(t,n,i||{})};


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],29:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],30:[function(require,module,exports){
(function (global){(function (){
!function(){function t(){this.table=new Uint16Array(16),this.t=new Uint16Array(288)}function f(f,v){this.source=f,this.sourceIndex=0,this.tag=0,this.v=0,this.M=v,this.J=0,this.o=new t,this.u=new t}var v=new t,b=new t,M=new Uint8Array(30),J=new Uint16Array(30),r=new Uint8Array(30),e=new Uint16Array(30),a=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),n=new t,i=new Uint8Array(320);function o(t,f,v,b){var M,J;for(M=0;M<v;++M)t[M]=0;for(M=0;M<30-v;++M)t[M+v]=M/v|0;for(J=b,M=0;M<30;++M)f[M]=J,J+=1<<t[M]}var s=new Uint16Array(16);function u(t,f,v,b){var M,J;for(M=0;M<16;++M)t.table[M]=0;for(M=0;M<b;++M)t.table[f[v+M]]++;for(t.table[0]=0,J=0,M=0;M<16;++M)s[M]=J,J+=t.table[M];for(M=0;M<b;++M)f[v+M]&&(t.t[s[f[v+M]]++]=M)}function c(t){t.v--||(t.tag=t.source[t.sourceIndex++],t.v=7);var f=1&t.tag;return t.tag>>>=1,f}function h(t,f,v){if(!f)return v;for(;t.v<24;)t.tag|=t.source[t.sourceIndex++]<<t.v,t.v+=8;var b=t.tag&65535>>>16-f;return t.tag>>>=f,t.v-=f,b+v}function d(t,f){for(;t.v<24;)t.tag|=t.source[t.sourceIndex++]<<t.v,t.v+=8;var v=0,b=0,M=0,J=t.tag;do{b=2*b+(1&J),J>>>=1,++M,v+=f.table[M],b-=f.table[M]}while(b>=0);return t.tag=J,t.v-=M,f.t[v+b]}function w(t,f,v){var b,M,J,r,e,o;for(b=h(t,5,257),M=h(t,5,1),J=h(t,4,4),r=0;r<19;++r)i[r]=0;for(r=0;r<J;++r){var s=h(t,3,0);i[a[r]]=s}for(u(n,i,0,19),e=0;e<b+M;){var c=d(t,n);switch(c){case 16:var w=i[e-1];for(o=h(t,2,3);o;--o)i[e++]=w;break;case 17:for(o=h(t,3,3);o;--o)i[e++]=0;break;case 18:for(o=h(t,7,11);o;--o)i[e++]=0;break;default:i[e++]=c}}u(f,i,0,b),u(v,i,b,M)}function l(t,f,v){for(;;){var b,a,n,i,o=d(t,f);if(256===o)return 0;if(o<256)t.M[t.J++]=o;else for(b=h(t,M[o-=257],J[o]),a=d(t,v),i=n=t.J-h(t,r[a],e[a]);i<n+b;++i)t.M[t.J++]=t.M[i]}}function y(t){for(var f,v;t.v>8;)t.sourceIndex--,t.v-=8;if((f=256*(f=t.source[t.sourceIndex+1])+t.source[t.sourceIndex])!==(65535&~(256*t.source[t.sourceIndex+3]+t.source[t.sourceIndex+2])))return-3;for(t.sourceIndex+=4,v=f;v;--v)t.M[t.J++]=t.source[t.sourceIndex++];return t.v=0,0}!function(t,f){var v;for(v=0;v<7;++v)t.table[v]=0;for(t.table[7]=24,t.table[8]=152,t.table[9]=112,v=0;v<24;++v)t.t[v]=256+v;for(v=0;v<144;++v)t.t[24+v]=v;for(v=0;v<8;++v)t.t[168+v]=280+v;for(v=0;v<112;++v)t.t[176+v]=144+v;for(v=0;v<5;++v)f.table[v]=0;for(f.table[5]=32,v=0;v<32;++v)f.t[v]=v}(v,b),o(M,J,4,3),o(r,e,2,1),M[28]=0,J[28]=258;var p,Q,O=O;function g(){}O=module;for(var A=new Uint8Array(123),S=25;S>=0;--S)A[48+S]=52+S,A[65+S]=S,A[97+S]=26+S;A[43]=62,A[47]=63,O.wasm=function(t,M){var J,r,e=new f(t,new Uint8Array(116210));do{switch(J=c(e),h(e,2,0)){case 0:r=y(e);break;case 1:r=l(e,v,b);break;case 2:w(e,e.o,e.u),r=l(e,e.o,e.u);break;default:r=-3}if(0!==r)throw Error("Data error")}while(!J);return e.J<e.M.length?"function"==typeof e.M.slice?e.M.slice(0,e.J):e.M.subarray(0,e.J):e.M}((t=>{const f=new Uint8Array(72374);let v,b=!1,M=0;for(let J=0;J<72374;J++)v=t.charCodeAt(J),13!==v&&10!==v&&(61!==v||b?(b&&(b=!1,v-=64),f[M++]=v<42&&v>0?v+214:v-42):b=!0);return f.subarray(0,M)})("5GQ0]-\f-.N2L^\",DJow@1+8z\b?mu[?||<~t\\?&(\t$GVv!h'[Wss^~^H|{sr,AX!{|kz}5?\\~]o(, v:ydXoIWtat=@\t!]p'QsWp|^#la\b=}u N_re__)]\\{e=@^WMwPiSu \b&&^yYN\tt3u\tQ\\O\"^h)DsUQDmWNKzMGh=@bIAyvx)\f|iH~6|bz=@\vvR:Dk6S!\by+l\v=M'#&du\tA=@=J%'#\tGy9%\tGy$\"+Yao$3yvPey*=JSR1;su(u4d7=Mfq[}/w{C:Wpr0^?EWL4P/:K7oWg5+&l$\"-dW[(!:,\"1BA-D>v9?_X7sI?gT2H,,``iDw3]h.$\"ndGl*Xfz?-uUd^[>'A!-{U<\fD<7-Sl/Un,Im:0rd*\v6wo\b>l]!Ia/mygN=MT)7(\b\by=@n_k}w%\tBYgUJw9#`!`8_0j{'Q(aouz:B#Lr[a2Y\\uK[aP`qp$=@&uoK5hy})&pTt|xJ&@@BD>9QQ%Do%=}ipqWi=@vH'=@\v`UzE`?A7\v[7tcR6=@Zs5/)V0^jl[B~E7=@gK4!.x\fl8uX'Y2~%nx\\i>*Zmu+wt_\b'$*d/(|.1aByUk{_L7j!^'\v+B,LS@W1Z:iFX\"\faT)|\bxY=@\vv9Z:ECFZP:eg\byYTXHb/r(e\f(&h{%[Q$$H4=J+3=@Ufl.S.V7%-s;!MwO;99VQ}o0Qf'uH 7%ADq#L,dSt9dQ=Jo:a\\+:=@]]s7_O2.bD=@ka.kU_EU!jfB\\@H^`lwu{\"s1NvlR`B8o2GK?Wna0G9l?6~1k#Rj_\v\".*z@<}@/3{w^|iMi$}n'>y$MyK?($x\t\\rD~@VQg.g}p\bOn0F!S)])=J8)_(;x-Ng1OFi_eN<N_?S_y\bXhv-H(\"e!qi[\\cf*km&s sk*wZjCfhq=}qw3RE\fgQ~7Y1dW.hgI'IL'jv:i%6=}=J=@5m9 _7*xdeCD\tw!5l]u +]% -/z(wKTp\"9+Mpb3EJD:P`C=@'Z8]$_D^KxibTC:9')*sISw|RoY//lBD@EXlPr1[N].EsI$'8l_7^n;gIP^n!bw.WYS)BMvP~zRQ|s\bgBW('L{iTI8rnp\tvxX[@h\f;0GlB6g^NGLX-;]N?AQ>_({=JVc$^=@=}-g)prks=M6}c}t=}tn\vK=M,9*N0[=@VP=}RuR)\t$=}Q(&f>@7qXrH?1=}pU-wj_k!#Nx?\f{gqVKF;_7aoN&)/l}C3\\RF_k3}roXkRV^No;2@6ql8J%pibIlFDW[K\t?1(%N3>#?&lao;UACrtf-O\fpm2=}M7}rizfx7!V)#)\f$\"6(&CU\bj[+\\>lFRl5&VE w1o*Tx=M6tz~Z+=@t`iwS[|\v$]QK\t#qYA4j^v\f|@Y!=Jab8hZ`.\t=}$\bpft+t[ZwY=}|Z`=JSZo*;HYQ\tY~tomWp<sy.KfVo-)\"cv,m71@Tt<!5~Xt\boS9_VN=MY{M&WA>uelA{[A1~Yb\bAvQ#K-=@n,{`R^9Xuvb$n}o7~K?b\"N[ZLsIEG#!}F\bv%5Qks;<A=MDct_H\v<JB)=@RPM\b$C'pJ0;m3B70t:QwvPvO(am_FloprqJ\\v=@Rt=}W=}]pY\fs]M$|x4>\vd5`\bdvPV3zn#58_gHzZ]ch gxe?k:QaVo\v=Mn7S\\g8/}Dd.g>V=}:9uoJ -Z74|=}=}@~=})FvdSIlc-=JwHpZM14,W<vI(Eh\\GSzsD-y; >=Mcw,Oh?Ns@DR0\"fV}{Up_\"Lw{qxH@t1Jyu:WLC*D;<b({5=@ZI=}a#hX\fUP`)K348\faI?hYYQ,.2G6nCN#@|\"^gWoS8>6aG@Y4=Jpl=J?9^R}dPv=}NUt7YZKV`#Y@_Fv{.Dc *A}G#}TV`\v jgAU+#4WEsxIPjld?BFC,rX/{@7qA=Mo{v5\b^5;9d0#WJwsg1=}-~U=MD@_fi=}=@axqjT36>Cvw8+\\I+Aed]yE*.[2vf/B]%-0 Q,^?E'i\b(0e]j5~=@H=}?XPRm!=MUPIH6?0;]TB;]!L5Y\\ex/+#|7(LkIZ\\6=}s[=}K=@\vp\vj=Md2E]H52l\f>=M:\"7A?Dz2V8$`H]#/O30Al\fpk4kM0.dwcMz=Jstse#=J@s.`g{YJfc\fm)a)c$'fZV.+1)=@}&X.Nc#Dl>'j8B<=M{ak8Y#lL{Vr!caFHO]S{pZ_\tO$i24U\\l|a=}e)$Q2,YOoM1qxAav|]9x8^CX#U$\b!`;q\tII+v[FqjFY7[A%kq\b:7mTQ\\fjm=@DoN+[T6=J<H7j4TpI-%vK\fl\")d[F@:7ZO't-}=MCp=@bH-wwz>p(;D*2S,\tV&\\r0Z3P{9R`gVR2e02*o,]G7\f1&=@+Y_F>T\feKC=M`e.N\bZb7;Mx@b\v9aU=}|9\vv&K#q+L5aj\t'\tO$t>Q4{>;`,ZV.\tHH|W.]b1GG@lzeU)W9\tI`?1a?\"aY}k9x:J1ph+l.d\t$=}.F@ex7skBR9@>S'R1g'LHtP&0Y`L|Smr\\\\Emz^aR\t1-6B#oyX\f(P9_IC=J+\t]$dW94hxc ''\b&0sS\"\\:u*`=@oiA`Hgwa0V*\vuYDuQ{*;_t=M'od9WXE=Ji>2S.\\O+2/xuX\\EwLx\taZ3#k!U=@E=@8\tL\f=MFX)gf`qVFX)bzWeqEJf0{k g9=@$,Q\fY\bfCQHs=J=}t}Y$wYVg''=@A-'Yxee|,U\\F[SKKPosPNT6xzN^QM`\vGQ&$c\\=JSc+7Bd|\t4J#q=MqY\bQ_/7SgeZ}\\\"ae2N-mA\te6cR^]OLH`Z[xENii\tW6mr];^IznY-d0&[{XjM=MN.X=JM+-!)q0b&]S?+[t.BKLXvjXa1\fP~MJX=MmzZ i:pN7Us9WMERv$<D\"REZmE&#@=J1^+G3@OvIt\bd>';G/P`YX{\t]Nk)4a-p|0EpOp7E>IAaL-\v9Jj['Ti;.k6Ov30#pH;7x>tb[D)\b3W99#0z5%$tFO[X&;xzLdT#8ra;rTZQHW=}}=@4]NR9-RlD#cT%B=JY]Nt%CcR[/n_cc^S!KAMe1}'/D@u\fu,uR6~CRy\f!C>DI1WZG&T\tuHK)!{Fi4R\tp{W*=JQV #=}.I=@0{. 8a c^!$p\vG9YK.P(WV]>\v9uTZ}V2xzW=Jtki*9D#\"!:_,Y7{z;aj.kb-l%+qC3Tvt}9h+5/U3MmuS\b3Rj)L\f2B =M.BY1/x3G$XK33=J5KYx|u=Mg'^-keKTl@*a?w=}HMFcz=};I/BTw=}9c:MFH(O\bA@*q\f=M=}C9Z{P,~UiB%kJ#j=@*=}X\tVL\"4iq_a530dw=}A@t/&pQ&%b^.~C\vca5wg\vt6=@XB|S/}lf5Dw<kW]xZ:m%51=}H^Lt\t+1?/s\tK AnPA$c\v[T`%29bU( <Hw*O=MUGPewr>hE=MKWR%qH<G`OseJ#n}\t\\043i=}@$@6l\t^@VM:PmD\feGW?VSPBsGbtU3[Sky=}j\f*cDcEG01kMM?wJ5Tp=}d?x&5d,PhhR`pLxeRZ\t&A\f3:>'q/NoVC/ U''9\b>\baj=}&=@JK|>S{V%KB\"xqFkb|SZ$w/%\t4A~t8[&7DDq\f=}S{J)tsBU\t;<yZw&4/<!l,3>>(_FVP?H#()'#,fK3IC`&i?JZye%]S=M(=JfB8*#C6{Kd<yCdK\"kwJ4?# \fgW#=@do{nISvUO[JR@A3S=}T(~G+tzNCo8/@Za4@}\"lKJ{;>?`=MFxqb}=M6REQ \bs\vf\b;\fgoE\v:hZDKDfJ~y\f/M?!+}{m/@@; *cY\v=}=M=MK\v=};3jqApJ4_\t4N7l\vC|y;Y\t~UZ/2M1YG3HCHn\"%=};9l=@Ql0m7/<b_4)`8oSH~c%$=JfEn=Mw/@bB*%BF=JZB@-Htt|os-^Ew->\t+94=}6V>*`|I'm\\@OB838_*u-XF/[V|}\\SeHg2X'cWvbA[o(b.5$in5x]gU}~V:;R)ZR0\t|X#q9\\\tuiu&d#[#'^1s1M`hi? Sp=@k=@;=@1a^`k9$&LHAQ/@T|Q~yI=J^Hi:Qb\b'rgh`|S'H#.[=M\v$e\f]epI5'ZH!q\fWUGa\bp#>?\bKjm[Zbpt45r<\vfX4l\f=M{[]Bho;=}2uCaR+q#[J\bo:!\bw99Sm;=@48s%J[o6JZWun7-^<.O4Nk):q{pB}\"AG;K\"'getUEGJ9`ms  \ftY[C?1n@Rk=}HAE0{&p&#$7h[|n WP2aRA#7;>?\bm<%[Z~M5*8[\to)SVUb=M<f7eAVdQ*{UV3/BiM=Mvl+=@Z5tPI[0/&4}\fb>\\t|Kr[I=J;Rd#KWe]\\~}p!,{yw Z&K9#5lQFPy(R;F^0Uv#s}_{Ra=JRqGH`[r2ucQ/}\fTUW=MU\vwgME:wnliBMXQ*A=@bXV1nqG=JLu>(dX'&@Pz-:#X7nh>TuM9Y=Mz1O<=@VsE\vvl2<>A{!xuB8z{8{\"XK_.22DXO5C34bA8ebP@n{'<JJi$tv}MK!=@^Ye'>%\tE%>'A\fH}kO9TPL4=}|3m7o}\bm3%UI$^'hQj`fY8 2``V NpO6 <Toc!i6g?Hxe|=@R%=}gfA\b^=JJ'g`NWClEJr\fOdq[5Q2wx9&e886j=JiB9\fW}rSmyv['RM$O l=M~DxZn=M!_=}^y]ex++diTK`*=M7=J%omN\\_ye%oNTRtL 7gt2=J?@G\tF_Q0uG`2U1\b5\v(\b@z?I.3b3Cm$iFs%14<cv'xm>D=@KC<=}$D0D,j:A.P_2>^ J$,k: \f0+h.z[Nlxz}Hx=MG#8K W}$}S%?^M&,^DRzxoQ6V%0\bNkIeHnld*4V+F\vp`D:3k}P\\M]@l(K>=}3,:=@k?/\f!=}k=}a$J=MqXWmF4BMLvP!Ly^\vwQLC$?\bnbPqvmpWZ=@i6ftAkaAaRoRln6\b%=Jb,>t=}w}z73bJ \b,c(1.EgIG:0{M1f7W/G*+/[4z<\"J,(N2)AUT`Z&H/$C1<%#e.|v?TI7A`}oz^uknl3\"?W^h0NNl!?ovS>5i>=M}7f}QvX]85I``!|_dSC=}(mXk^3JF'\fD}4b+'m26!bPF |CD(%=@Z<As: _\vd&[aX?fV=J=}rW\"Zb/8Gu}&C[${`(El\v=@c|L]S25 p1B\"oQ[=JRwqJ#'r.gf=}=J$\bpo2I=@8HZdlnar~y1Xk#0j>Ncob[N8=@\b(U4cGd'Z\vk'S##7E:ZrdYW~PSq%Fqe^G6*|,x_;M;LZJKp:lV*`\b%]\"xrI\"eQ;=}CF=M\v &(=}(=@i?un9;M{x>\bq<KBf=}=@(=Jgf}]F{#,w~y#fVN3@\t;}Q\foOx9}>I Fv3M{b.FBoTwI=M<iZ`$XVOa7Sk\t4>?4\\=J+{o#<si=JZ|=MmSFZTfQK\tKEjtWv#rtUV#x]b}U}s!|=}nv44'xQ(r&NwWG\f> \ts\\j*@Ul%g\v?qcI}z=M$0r}9\fVvU_\"?~=M%}tWUNum[!smQk\fu&&TYZsLA%g% F<P{a6x\\5~u.}SU_\b7\b4eLWy=@-7AOVXtSJgr${^=J#*S\"f$6 cJp5tMONSVErlEUoV<\bHWHQIDegEo]O?0fy}(s/`V-7B`1Q}cwqtiPPEr0RtXn=}]$\"*v@{B~F[D?.v,A#=M-7|sgQzp\b=Jq\f(\f99__?=JKI=J^=JrG=}{SSV9#s=}\f>qY6hfa5O!_rhYs<\bU#y'iX!S%qT,Cps[Mr>E<- --$+%\bvk/of=}\tm7B GV1J=}`xju87.\f0nYF!SaARi]Gbiu61=MDu/Y,\t<l.^[<|^L4Nu=MO}$GULo\\aFbM>H=@;SMFgft~b471M1Ph\":`=M2>v\t'&lU)K&u( hY`T!=JK(li9j\t\"N\fQP`\\0O3[SG94t+AlsdJSaDf;y+pINuW_h_1qvX\\\";IbG+bn,3Hv8ZZYAbd0|W+=}2\\O>%.k3C6E4c)_tEY7=Jdxn.rUm{{nrD=}AuL!T\\k&pFiV%b0r=Js,WRJJyZkFOu-YM\bR@OQosJu4Y7 iH\v=M\"sP/|*t@JS](Lm\v=JD40_4'\\/O$c8ebDtio7%8R8$OJz0Sk>8f$^~$Ue:90ufDg4no6/Gq%\fny$Rhh0N[vJH[:4&{4K YR?gZ.f\f=J7q)!r>!&\v)`wTCsObE#XW>EZAhqw=@,PF{6 k%8v#V|QTL.&XDX\bn4!8Cia3yE(F/su-\"eC7zXG~bP\"__#,\"mufudi$V'=}K=M\va>xjLISt+6~c0GyW*OHj:hWK<U<L=}iQKHC\tqq>=}I7-k+&V)m?4.rMM&RumVq;'V}DJcmQ\"RH9Qh\fc7[O#iJJ?\b~wxe3c(TgEP^T2;6\\mY6V]d=@^J0W0\b^}9F[cn7e=MHpSjkvf5a=M[AoUW`sKv@=@bc,7&YX=}zW'C.t'9B.(j24h.2?=@].?hU=@m\"1^H0BvH!&'znK'Vw#i[\"Qbm?f]\fl/($\bYHCa H#!#?I)d#y||HC#39y88y8y]Q\vQ5)3Q=}#}\v&b\"=}Blscv/U}\"7-f$$h}uY ^')y&ZQbK(\tv^r#9sc&\tawa bi'$)w=}28J+x|a#fLg~9=@HAD'Cp^44`C?n(MP}|\bI-=M2`5i=@=@%Q=Jl~\tCE+d3[)m#@F0B \v\b\b^+@(\v|%K\f6~a{C^9hRx&&a~-ptk-\fTTzDpu=}25+zG|-#{\t\v]_RrJuF\fSaX]p#:t\f)$$d&+g\vX eP|f(LP%v;+&4p=}\f=}/mz8%:8#1m&}C=@b>34Q4@QQ'=}$88CDH\"7]ih=M=@xi CE-l9:<th6|NVw`^V{\\r=M=}*G=Moqa,uQFgZ+td,f'NF#'Oox=@ lv=M$!jl/|F8@%u<=@!,uNURB2V=}qoQUKg$SbT@6k\t1e;W],!5CSJ]`7n\"A?buDc@/Mq\b-`cXQc;-xg;[Bw6@0qo7k4=}*\"6j=J=},H\fa(]qo[f!'Afo{\"y4m7k7~?$G1l&rdwtww=}0-_.]O8+Q9?p_9;@ULB7cf#%P)>$=@jC'cI2\\8(.=M\bkdvF}H=}z\"6C\v1D=M+}3P%*;!t\bTho>%p9a1<\f\fL=Md:~\t[#08U1P82vd{l.@#NQ)]fqBlin\t;,1?O~f.H0!8^v\v\"\f0]$=M4T}YE]hy@=MRo[\\J+Jb\\d\bL2v%jChr\tQ1jcV]=@_GR\f_\ti>=}b-fMK=}\tD?\t\tj54Csdy#i^X}!@*)=}a#l8-\fq+9JLS_=@)K/e=}$_]]B+$M\\v\f/c Z;iJ!cLA/r<T\tlOnwBBq\\=J JHy~R)a1R8q*gJR&uF1z&Y#*}lC_=}fn:yv88`|<1N:i\v]l&DMWDg2u 0&JPONG`+EpA<a7(\bN=}Hhb>\\4KZ<GJqh|5O|.1{H^s%RX33yjvhc)\fQ\"&@s8h'*sr;sK=MQy^\\f9hM=MPPFZW\tKs)c;\f`\t$u~YTD,I\tX=MJ'\vse\tC5E\f)=MPH9bL~GPal1@*8Ot;5U}=@E2;6i=JT$7fdI=}6ucc*\\R+D\b*\v2G9BSUu&z9Uh`D=MHS]dd;=}uWOn=}<02eeWu76#,PWYc{%NP,hBx0(2'<zh=}bVht|2\tU6r4]I\tMMG=@X=M_Z\t?aRH-u S\vR77c#_DHvT.TE(6O[e0=}=Ms8C@dJ0R\b=MtlJv7u8w\bs\"XqN52GzWgP*0x(UX^GDS8sERr9pSHk(?6YX*GgNZB?O.E\\3c9iQq=} RH\\Y3\"iNl/LQ9~\b9gbI\v@\vs\\spw{ym*~\bH{MsVdr\t[ }o9Kw/D1(@^=}(xUcnhKT5=@y3c=}yu82{J=@=M4!ZF9,K_-fThF#1<Ba@tDh`\\]x~~I\f=J:*;K:& Q/C6Qv0o\fe?bBN&|s3O<6341K1mCmCiQM=J<:z3s1:g.<gS8?%AmU>S\vJ5`la-B$Q=J(L;?gle7cm`V;rF%+hG\b:Nc6U|L2Aq'CFfQi>nRc%=@[lxCi8~sW'L*5$2/Hh\b5r$RQ,egF=M,-9>-e8K2l6EzXb;~jZ,,~=}[R\v`y.o)a)f\t_`,@8K)\bmal08c,>|vh9w*Ap^\"Z&~ u?=MY3}6r\vktgKn\\LA]I5Uq{c\f~/9_-q\"`6{_\tLO0\\\\+:(\vt;r\"&#\\_oc1=Mpf\"8L\bswRZl=JKtG|^ZYZT4N;6&ZM1.sA=J+\vJ@]8,76)M0|CV\vcj=M)g\\F7(_\\6{PEDi{i?yGj6tY[-k/\vBR[sp7`;?8Ax!|k]X\\6=}Ze:\b\tDi_u/b}P=@X!l%H&uC5\"A+tDD\v62dlffd,>=@\\\"{y\\Tzq>F6a(;W/e,bu^K17m\"=}5eAQN\tjfGE>9slN*p7Y|^z?NlOd>2=@tS\\V~%oQ9 u\bO? <=@;o4.rS&I=@V#8GYFStv'{>\v&>OEi:&;r&Rwn7ZdnOisPxu=J&=}*O^ExzbWI-lV[TC^;Q|Lg=}7>C)\f1K/Lj':#-wfA8\f~c,C'5a\ta=Mf \":8xl<v2swGQ+l2|,/FboX;n7=M@KO@uEplU`<t%)!=MKLX\b)'q0^ZKN8?\vrWzl(j$qaS\fWl)J&o4};0HSV'\"Ju'p^[fcwlkqFMjVNiU;=@DsJ~'wf7h\t,wJ]8gCakWAAV?+gu<5y4|9Wp|D`S7e9>XzR+U2Y7vduwb=}|ev5BMMrO~2+k}=Jbs(z7T+{Ro;?#?Qn+ya|b:kG[M*.U\f_[[r]=@*\"p-=J+Rl~=JT@mLao@q 8yP!4HzC$0jFko:_GK0x<F% g =@_T8=J>D!Knk7?8#-/c\\AI%\"@b)T$T8UW^2OwUMqo~qQ)v7HS[qk|A WD=JWb`dw\\,Nk'TjdB5X|X+6hZ#^@:).tyV/=M7RUOS|vk\vo!ub1=M&oR)E\v@1\\a{d\"${Ac_U+zCtb?d\v=}TJ4H4\\p=}> J'iLBu6=}~v}=}&$+lopHRM|~>}%w0.FAa\\n=@;X8x ?u=J\f2\\G=}3QQ&tkvNd<N\vX4U]$r!;lN/RF7@c.Ti!*F\b1>=}A!~g?55.\"i)O%Ohd(*\\ZIsP3Sj\vR3?a&vG8k}1\"'\"=JJLh@ *~=JQ-,Ur\b)!\tZ0#\\Hm'oQ1X\v\v+N!xcbk[?F\v=J3#d.Cb!|SAKH<)?f*&-B[D?OdXBK\tr2\tWkVdEEges>M`tf>;Bh3J\\NR4Yk'+1R&-,4I}m:`gw'P^tRc9\t=@14FtcI*Ufn\";Z\b1?&4>\vIm=MK\\jMGN;.Avq>=M_9Q&mGKL/{.W`5(-g=}d}sX=@%I['\v,Tn:1?^k+I!'6OIMQ3Z/R66ooF<Yy=MS53u[\\[To+Vi-`#XZ!SZZl SS|7S!;G)hK2\"i8xx=@EAAqezN=}(Du -=}^|m}t+rm+^?`a094vS-ExVR?&j`*kn)NCM =@K>-e~{abXW)pC\\R`'HR6iS&Q?X{=M\t|\fp?rMe7\vq48%2y'Qcj\bB=}\"RDq#!f1dIK4IHIW\v=McGUMbS9\bFU|EN4;H7B=J{SL?sGBKM6P{OmX&\\3B4m\tXHi-!%\"/G\b=M\fIQGaUy\"*\"Z$nTd^@Im{\bR f=JQc>S_,1rOQ^_?g1BHO{K\be;8Hp\"`dJw`*5}u%=McpQJ=}=JKzFJgR;Cj\"~e|;\f2\"=MnV]b/?H p\\\t6qP4j2da-{\t#*p o=JuOpklMbcToXc_/D;3cp!He`jp~.`loI>Y!?vWJ|nCV$;prHP<t'-o;WI!w~aOynsg}E$O6S\tPn;*_bDE*T.f/K~\f\v*&Xc=}a0>+\f|xbZ=}BIobQ!4FkQA=}NA\v~4GgN=@w\b.}LWWFr`*0)-|}%K')f\"!X+.M\bQ+#7u@s0Odnp5HZSL1\t\"'#Qn=MMe*z5x5'\b8~^5Zbu 3?IF2y#5i]LPwSimf\\f=M9Q:=M7`],Pe%d%&6Ms'u2'7w\vR{lvl7{mA5nY*i[\tfv\t\"[Z/ac=}>K,YUF_)}@<F1~[H=Jq^p#.Vt3[+=Jfc^8h6E^+:\\;'A[3Ow&+rV,maEbK `{@mM=}XX(V!s8K;.!*=MEm=M<aQr\v=}$Aof;rX8FR<:9!=J9.y\bW*vo]\t=Jjf!JpIqS<0RYb)[.f02b)=@q+^H7ehO~\\^$NF=J(;'\b\\!cO^N`}!8i\t-q\\KI'\vgiYQQf\"Z\\}c9#'b\"nH%-Igc`k'dHm&)M\tS8&Wh>=MeS9Nuk,w=}r+eFZv*!GX\\s~J1N5i]\v.Q+HzjJ?l)TpY9D3-3ouP%[5z^5i\t2\\6*\\*^\tnKR7k1sona0m=JJ-.uko:\\Z\\ \bo_#w\fI!Nuoe2G\b-q.<lp@/9!5}D\fl8n1G~,tsV\b@k=M+bEzqHsV2U!tsyRk?jK-K24NlEB>TR3LgZqL\\gnlk8B:Bi\vT1F/>3Qc76@FCz4sEP~l[y.=JISdjLE}W! HfC?BZnR^0{\\=MT1=@m6/uFmQ\\fT2Rih8m6j6\b\tJ>L{$[#0E]kD\v\v=M/m2qN*d2=@Ax\td?PK*M!esiUoOuZhu)Xk2*oq(U-jc+\fL50h>vl#*o=J9=MZ(jZm;{P3nWI'wEzi?|h\v$6sFyKH8\b+\\OGp7Gpbhq=J1ok\b;OhlI.E_S,7ssK3SknUUo`r&U[?8T95@?0}VW4o[KvRT4EJrWCSryePVhqfv0\"j=}Z/D,Dgq:p+ x{zJ;kS*INf@QP\"SS1\blSZb\t,4:i/\fv*bd8)_a~qcRO*Zl=J\"Z.r2g=@/(67P=M8Kv44\tQ1mU=J2bBJ:Z0*qC5~`1?'.9X$B\\\\*~~1L~k'XO-v1o=Mz2>(h=JFq)\b%nWe.RD \f-=@WFR\tw|=@;\f5.pPE`jT}jax*{kd3Q=J\bry=M3t{5N,X@!WMx%O>\v.X$E=}oMLM)(:F{~_ByixhITIzC^\"2;mco%^>\fQ\\8:&QK\b.O}R]lI,'&f!/U7]]U>ok7aJk/MDlc/4CuP:u:od}:Q2E$nhrJ$nhi3hd|g%U3<iZg&m(D^sB_yo\v6RX$NCS([aj{43[}%=M Vv8~g:Y7wkT 5\\xpB'Ejd<7'tF#,=@\b[eF>qI]#-$5U*pie\fqJYMld=M\\D\fZmkA*4]:!}e7W=}Jq#\bo}A0|v\bze{.evIz#d?\"8Qg?DEhxEz~Ihw<>\brVjc$GfSpQr~a1pcoeB&vaJI`Pb\\=}}@_M>OU1w/8t(7F||\tjMG((dj&YP?5.r_hf=}L^Bx&C:'.OWT/-GUy>=Jru/4\\H ldke7=@XCt@&z^V_mex]P9'r}%@f6%r}g+$uh\\&o5AL?G0n?gZu@n9O'3r>6g}jZv{g]\bI%\bwov\\\\8r>@,F)rEBw$jJ \b;A\vJ\vBRi\"p y`CMK3w#I6KJCy9\"%9k]\t*>2l(ZY*&Z#@t=MKWgAlx?=JdG2{a&Ec&LBO9\fOp=@=@wE]~5@bsBa~\bYY[fsO[p}-i uf#e\tkCw|E ldSZtGD6\fq0-2=}zjO$6/tHC?]*>VzXE\\_C]f$\tQ=@R3n=JcNl{dM!F[3=@Mq'o\"zcXsh~\b!'t%66Uu`Fps|u\t\\p0p'A1rK8N/oYFh.%=J*3TB=@^Rk~+9:=@~x51C_^jx%gH#AL|r{FY}\f.gPkd)p!b\vAau~+00\t%rWCD=J.\tXC|QgK\b3bB&0+L]YObn\fy- iIqfW=M%HcyF\tGW)uGpUOc\b2#v/8znJqoJk|0<JhdoYTBo\bBnT]=Jw8Q^@JJX\\%{<\b{MSxV4x94XdK _H6];b.v/7\vLydlL=}%DIv3\vYd8~j/.7S3% &/_ ;!A[)Y&PU=@o7<>r'=MHi?B{L%%#q8sxh`gmb\fNC!wD_\t/\veE^7^(_eyI\ta4H~3Ea(Y6=J9=MuOx\b8\"qL'Pk\boDV++M.U\"yuG8\fV4W2PAS'GHi5ma~bq#\vna;+SvAW)S}7B|N`pV\\/1h,\tQ7>=@C{t@lw&X{G\\;SB^p\tR'}5y=MxmP9dOvp6.7I5Fy5|XMN[/i^O&3ND-=@s=@gXbdXw`Jtj1aiE3x%+*awlC-L6-!>=MfvX73QwR(e`D\b5@KePQFl[T&q >eomY{HtyY~p:4`wP.Oc!}_fr=M\fK~z8vcy-o\b/%a=J\\\fuvxu5=JC9g+vkue'F9`(=Mgza~fTvAC_|x:Pw)peoeq6bd]%@Fs>/\"6A\\#`D=@kcStiM[mj)\t'b=}:nb4fc{24[N)]@EXqouaTyHe\"K<{0@\fs'#s*!{M%f=MQvx)h,|XixpRo^w\"c,uw`Sr-P/FnEq\bukj1_ajw]=M;L?x/rt\"PhQ^A$D< oWe\"<].OJ[|w=J|}(hy8\vx/AFO1LMZP/\\N\t|lcWmLs*mwBXDd;z2+=@\tRU=}N,W>W\b#GY=@LGb(tQ{|i4MMND+&Ay`HI#=@\\mV\v=@M%nIc=@t`E8'+M9{O=}NS\bixWeC (*LG}\"<B\v33m>vH6Y^^lG?\"?\"?\"?\"?\"=MuE@uE@6g&@e_S/nNWT'1>r=@7Jq!|q\\#x=M.Nr.=MPp..=M.3Y0r.*U/0TLJ&=Jq=@vj6e\f3d3.&r.=M3PM_=}hG`fy%D\t`3@_+t9JAtZuM/WON}C_O?t'KF9>Z=}^A3!c31>@%2~[L0n\b/v8\v}4-y@8qeyX)h_Bc >9hap\bNB_{>LWqg;_ .enUF@,uM'.Eo%w\t+Ah]9PA9=}!&**<r=}(\\6*%BRdH{c:<5I/aeq\bm(&:@bT&(\v)I(RU/Sgcz|dY79.Ehh|7w[01dvQ!=@V\f^[}*va=}B5x\b5>7qc~Z!ppS8JDw~q9Ev.SD/L;P=}9rRRW=@&/id<pi<1ld5+LR<f\b(\b(&#)]qBWR^#3FQ#*eZfIEN+Zbq40WTOQ~VNRLaMaN\b&5E}&6D1Njbq;7]+aB=J}<\"\\YqE|fmSA\\i2~.V2gAjse3BOfO=}Bl,\t[X;U:d^l\b@=@O/}u[/OV$[3W6h{[@0vC|;'g52~^'#u1<=MaHXXc_Y_N$'E}l:EG&Yf]u%QDa\"'\t#,J`OwKN9=@i\t\bz8E~\vvbe\t=@n&zup>+5%y$SwC9\\LcIOU@8:U=J*k=M{5=Jsj=JBlg3xo{>XZ+*wEe*z5pEuUq+z=MR'%/z`~=M,<\fo\"v=J\bVz&*@\\.s04BE&Laf?4g--ZAh[yZJ<aJ!` %B\tNFz\t3W#'rXqlwEAy.d.6fd{go4P=}%gR+!6ww$;W3_I=@/D4v#wI+jt!XZM]J/f3|jc(#`mjL!'zdj {gGq=ME9ZdLz6k0nZ9 parsH4[8w 9w}VQ~kf\b=J4*I.qO;DLucP:4brd_9Am&Ishjm\b<hO2s:=}\v=Jqofr\t\v(Pf|e$;&qTnV\"&J_VLskYw7\bnj?5M\"mT1w=M2p95&4hYbRFq;F5X|GfIxGJnlI`e9L;{c\"7b>^e3\bt- F0O\f}(Q\vboUME;r6n74[W+Q,?$z)(QmvUK\tn\vrUWXZlPy'Z;[ysf\b-rmo\v[V6dVAw\"y[<Rh!sL@fuBGoEO\\v1DO\b<=@noH\bzP8L9`nBVDb'C&.^su:o\v:\fonHOFh|@ l>dl6[>=@4OdvS885h5#>Sl\"^x}XZW0dO\\EF]YAj~^:&$x@rl9\v\\Gbyhfx<C@E'&M-=}jB9''4)4/[/\v/zb--~dSL0.ya'4x\\/25/X*\v(AE=M#Q1rCF`whuJS)pqX0`\b=@AcUOj+FE<m z`\t#mUW&::zo*vh#3c2'pt\tRoQ%&<&J\"lu(,2+O4S1w.\tI7rRVcxJtt(%VLIbiA$,|xD!![xMorLtYQqw85S3tuz,T\"dF>F8QzrlYscOX=}BF<=@-+@|EjyN|9*\tm<9{.c(\t,iIHr^'KC:`*U;gM=MHf.UIwrqhTPf',HOA\tB=@M\\0=J8]:;|LI_>au(@WdlY>;X@UaI.71@;WeXRu,S4{!R-_n0H6`XvMz=@ftdUEq/KPL=M=Jg2ZE?T\tA:L\fLY)gt?}-%QI$~N5=}nry`/H;1WH(T9Y#rRg'Yx5|RFGy~;v\b~YF=}\f:/KP+xb%]Qr0,Nw.*:{ {ZD,h`vfFcFL=J,lFx|]D\\l;Z@i*q@Qmpu<nq\\|Z\v/ :~JNAN;rNY1w:R\fw3en}T#G1L_Q]\"8jTnT\bABldFKr|0TMr7~?l>t\\=M=}bz~{5t#1Thy>>JyB+>$W},#U,9UTp3g=Jyw=@~_z<#lIfuSgQ\vFaoJVwUfBdh*%eX5Dlvl$?t2jlSUoYy<+{qkwYAbE cXr;L{ ?,{]nT&d}#U3]vjhc\bjk0V0iLB@St];i57>7?]0W=}=JRQd[Tnk^5<'BzR X_RTm[P &X\vH!y0yAsg@~#{+JK\tU=Mn=@HuNwc`4>XM<[72w!&atHt=}e:3$ap'?r~)'z7~i~r*~WjO/CA;^TZ;j=}w$|\b:5em\\s-CfFE>,6?=}4$\\7flOVz7D=JdM6TH8=M=@VTzN,{)Uf<H7=}?%8y@X:V\b*&?-X{Wgnf9fw5^Wf->\f%\\\fGe=MG[9vlK3YCYs_{VX15y=}bI,N]]e/o&.(<)YP#.GSI5--@'Mm~9QSLt&h [A.2-Mp&=}fRl0G<=MJ)]I~5i#3+!Tr<VQujn2=MWs]ltSGY[T/sV 9O[_ 0f'q^SV>W3\t`z\v^\"@#q:st,><g_Th\\BUi]2&<=}f${Dx;c2=}dZh` |8^LNB6wMn-d\vE0/N>%838?L$$ck=JouE-j1p=}b$;>SzZwv\b$zX[Ep/M|hs4{_'n`oph5Rc9p7O9R(5yq}*n6~vQFc\\Dtngo=@;gp^*?uEKsMn#3L=MJ<\tE[qdLfTq|VK-=}\b}OTLIy1pe_V>MUwW5bV+Cwr+\\t\f<{SyxT}qzPbM'ya9?u>+gNRb04~OYy*e3|nwP/!1k(m.S\"*q>r(\v=J0h*It%lB#ZLwkD}ELQgTakC6Q_v n#z9ks)q^2iH8wj6z4F7(^0C5?S\v^\\t\bycQzYrE\t4%am\t%;T}!R=M?\"KU-Jjp&6=MaXD34XQD {{-dOGt-y;0wp#T7cga;\\RL=M=Jw2E/6HJ2Qj)LX<fE-!u*O 5TfOvU&=J!TMEy=@Sr{L1e\\C\"}WsHL}-t5SwFDXQ}8:n8*t2p+=MxW &19J=@-N00e+{\fdxtR/.=J?AiW$,.g0uTJjFk,lxrt8YEI\\uSz+?n5}1E915p[&W.c@@J7U);=JH.T-b$UEJyET=ME=M+#%h//29;!l~{#Y\f2]M!s%N)m[zC9HeoRi^+nhI_RBS^a^E2lD<xiwf!i1=MRK=}oO>oe(%{5-\"q\v\"N-N#_xH6>8)aK\vzcH?m2[e5KSdr1EX}f`!=JG<k9\v}mrT_&!jO5!&Ky-{K$uhzW$q[Xc1_!\\z#UC\f;P\",=@p'6pDa)G&}+|aDt)XU4q8{4k\b\t ej\"h>A(b ib<=M[P=J.][yd3jp+bsp)ud:wjhaCg82{s6\f\\Jxe\"[41CJ_~$\"}O$R:h\b0Cm=J:=}4&'%] RY~kFg-j1MN9=@-fO?=@j/j3T-P}2OAX-MxLi{6.xSMsv]:r-5Dvjs\\\\x>4k\b]5O=}SS*E>TPanSS\"W =@na^36M|MI}~SO\f^cQJEzq3GC\\5l=M26>SE0jMD?+{F}x=M3p;Z7=@o=J=Jt@*Rl=@^/=}\f\bHPD=@)TjY=}|k@W0<oNv$X><pdCwxt4y1\t=}1@Y]N'D]Rg]9)^qf(t>IJJNl,@-No)_z=ML=JJP:8ky\"Y:vT!Hzk!=MgJQB^o[w=}4SL7`~,;&^Ca`TYkQyPxjs\v-9k^<mPo0=}t=J(h-gjR88q\f0L\f]jz\\#v^oar**#S\b\bJ!c3lmuT{Ot4f<O\f\t 5h[`1|x%w{p=}kVPS=J,BvU=@t:UJCzkx\bXr\f\f\v83{:\bM1W\vu:;ouR)\fZ&?\tVX.AavB5r\fG:A6~Sz\f=}ON3~4A\f3hbV<A7@BSzz,+g=@2T<0`/RHJ=}k~8Z=}5dNwl\f=@r}o|f5(*OyUYM.\fM$]es7ZbIe2&7,lNAenWJHtugYkW'R,sz/<\bsfLNm58v'd&\bS^Y`\v\vmz`g.\"_nB5[=}`FK(Y^w5)4N\b^[nGi}Q<:6n/J,B+h8\fZ=MFHb~D,T5\v1cmJ+Jc(^fsR0fx.=}9nC=M{EC.S}!8I@0Qy4\bH&&@+xpnz@U]\fxizE, BX1y\fo-qMOZ6?-%bK;m4c2974con=@#s+S\"a/'v%&\tYH5+\\crc2dC\\W|+(wSIq8f2%aE:3;NJ8G{n1*i11}Lv7N2Q!J%#Fo G4};4dE\"im_UPeh/R[7#S&pmM=@*z4`JSQ\vDYH-Zj6o])\t~{EGC|{bU6D\brgdu%<\"eL\f~Pv@. Lsf-j=@-B57<=}*6\v1-0-$\vO8WJ3=@7JO1]O~[D\tF1<`FC,A]/B>(>rO=J\b0S=JzSuFsJ;9cFJa$8(,v1}[\v?K|f1qj8L/9=@ B^%S#o^jLS,FL;3hf=@%w|E}0Q`L#-_`)=JI\fa3m5D=@u&?]R\tN[xyM$)!{.IZdm\bcMN.??kzj<N2OVRl[1~@0=}?Jc)%\b9!$WKO\\.k_KE3B19pk\vlqWfj'07;xT*U/X$-FsVI251@ux=Jew &jSy|%EXZ\"!Oe[%&Tsol\b zZ2?N^plvQ90B>:5{RWf3~cx+.sr@`J<bY`TvB1isd.VRfQGrj$l:im:av8J\tR<!M?H7sM9dK|>2C`J=}\v)])}xEYL=J6[#(Fb_Aq<,\b/Csq_\\vcUq~Q5=J`fOn-C5<05\vNvs0D<6(:C1[\f=@3@bQ/dtogy#&U8':<o\fM+\f`N>{jYc>u/g+>HFp!L\t0U=ME+QH5J!N|C0}TR1w.?\vbNE/tTve8GX~;fJzer2&\"O7y=}Sau8 X-V)d\f/]kCEUKt6E(_W_=M\\}OCVv=@$[0p=}\bKh9s*T<\\1s(OP\v~3[NO`5JgsVz:y6\bp&)Z{!\\8|Na+EY=}0uAV\f.uVLV)yMQuZxLU2gN 5xzgLGNv6{Z\"{)><t*\fO&)\b\firE')9h6MxPJ&byAoq}')\"t(-2\\=Jk=}UwW+*ckBriLhH[N_S4Tzn\"M\vOM=JmI[=J)k\f@V1+|5'Al+)N*M;xLV6GDSW@zJtx,t@LTinU9uOmQ!~)P'sfDvUZf&ZLi)@@S\f[cQ:tbM\\6TnD)D`O6~g|\\7=}^faGL3$A}>OL<F$=JsQ!=MIQC\f4%=MN)QP)y6pjiHl=Jr,=@`AZX0L)#Jv&w)Pk$N)E42]1\\+g_\f3N=}KGB#.SNcc1:T&_ T7[>s=M\f?Hb::G<\\S+5/K;7f1/r|1+6X+AT=}qQCN}_@\fq05/mr|}J<=}2Y,u-6h</W-3Fa9RS\"{i0KH.\fNrOXBW=@:|}r$i0u.))zKs))]m=MUT9m[]#v>A/ MRR,J5r1@ge,r][/]IpzOdp6a<DTn@.;BP)WQ=MXsmoLk~DnQprQ~5PPmca\v4SHk|-u?uf6O\f(\\`Y9R7VB-=JT\fZ^1}tbP:aw=MJKSC[/Q1v5=J&`:V~~3;9G{@b7?%V\f[MPMa8dY=@?~YcL{KWNxP&ZT.].l=J=}SqjM10/e|OGk8,=Mx/G#Q-CFw+J'vFc=J=}kRE6s?*x/4\vE =};eO`WyuG<e@r!+w26CR4/{Ojz1^2PPx\\F}gq\\kKrr\f9rIns:Q5bzuwi\\wWP4+P&;?~=MsB5L~_\f.(LFmj+=J5,j.'cu,s*JkT<n\tr_JB~jr\fEJHmLGK^gmHwAB<YFkF+ZbKOIB.[sNN5!;@U]q`|?L\f\fY)L\bvz\vW$kquY}8'BnAkjI0E3j)k^2RkDCo2VNI\vF&\\Zqn&=}8>wFjM07+_i9Y,N2MoQs+tf,p1N:{[C|`:d|Or_\v7NfEKjvb,S0;&zX3|=M,-rIa~8J\\=J+}X$LO5$z>BK\vo73be{8s5kw}{,7^Ta1 xLAiJoo ]L7=}|{9-\\iDN7r{j=@j _d%_>~-$lHH>z8[\ffycJ;$R=J<X'yd@<)\t\\ZT,MNuw+).5[(q'=@n'n/n5@z(Yt<l*16][:pxO$)D*Uz8M=@u,E}194kd&M(7l.q]-m\t1vG\f,jb}{E?M7=}a9&K0O\fC2YLEFDu1pe0VBR[xvhVxV0]@9X1\fsV.OhXO<\\^h)4H1t/)aM3CQ>5)[\fK=MPY:y=}q{8m10q0=@c\tTCI=Mp@\vPZkQmfp\v=J@TneGi>.{T4\\:#Y=MS>yxpi|st4f6:3t%%h|\vFF9(}/c5>7AN9&!{>mb_.)tts! r!&(MOQY-/n4H\"-!pFsOLC(%ApXQ/'%pqqx l!XHVk+SRo:=MH'A%R_TY'QqzRG9%|$H/?M{\voIa:obxw]![zW\"^S5i%=@;\t\\\\w]\thOuguo}i|x-#?)!Lt ^m\thSt,e5sygL%(OC=}*$!1&Y7atrw#)l]aTtqKJ ]iywSiHx=J\"Uh.WeYgt$'h&$U_92RPiw\b_cs3\td=Mn=Mp5&hCX]\\Z\t)\b3md'=@FqmM'c?t?>/A\"(z\bV|h|uzlI!!\"]%~\t\t5G$#QSE'hi%9h%C$7(\\#Ab!HiD) G7GGe888~1i4Z=@|Nz?I;Na{{f(\"wUxsIeTLydRy{Qf2E~x\\'%4p) yt`dh01_VIm1'$h&lHz+^u!(%~7`i$(^PB'>>h)0>nI'\bSez\v/i4>(GR}O%uvCbMuSUB#w\\-|i(A%HG!=@Iawj\f\f}jjyefY~vmQY\t\tSE<zQ$'ny=J}OkPw=J5?hxX`C%pbflEBbh(935;BeQ3/5\fIqP/=JG#_71XC0pwT'gkh\v/Uf_Z!\t=M|XfZ:Bidp3`(50[=JFd)ePW\t\vq]\vOD7%-MYuUY4=}\v,-q,w^94\fLfu\"OqYh%vs_e:Y?X>\fUzFr\b;&>RP/afo=@};>a?'t\"=JKA5Yc%=My=J1\bmSF|V9!4M?\f5@(y(Jy.m(TU_#>P\"&|f*#'`|KA>=JC!#6'ta>#c&Ri4tt/H0#P3UUR\",|4IS_Q.yb\b<!058QkiUFFw8{UA-f5[:VR,(UC5Hf%SR~ojA,\vk+Obi\vKwpe\vHH\b\t^>$z\v\v\bT/M6%~Cg\\~b3~%'!Xdttv!j15mw7oV=@O[\t=J=J\f=J_tNiuuu9F<B:QOJvj(?IiS++%Ig'%=Mi&$Mq9'hi(%9ii$=J>I\twi)\t\t\by'KhEVG&f?Q1gI8=J8\bIM1eNBh^msmQOZWI1H7KE=J%po=}FV9 01mfEt-r6h0|8\b\fhZ\")q{c.mp+,#R},JGKY\bOge!K\vcF&4;Tx5DC[w}qI^1B{G?})\"7wHzG[(U;{g#17}u[]b\vq`IbAc(\b]taHg\t(~=}R'Dp'gPAY&d@'glQ=@jf(b27Ed{;^`id8tY%I>PqI63Gb M]&yh#fCC{~X !D\v[OiSb9RUhRb646y\\S)\vq_5;=Mi}kifS$LtKUfA_gt{DP-5V\"66Bz[Npx\v=JgZN\\K!iR3(i@QuVDxSm<tBh\"~@T=@T@g,A0\bzf3xRU<RQ(wbDItRSV~fIWz7Ed\t7O@(WYmr(f/i#\t-1/>5\\^=JE??`5rX4\vSh_YvDR\fj\vR0\"Y#fs@\b,N4KNgTgZYs(\\:\by|~|N@^#TTptQ;c/f26z-wTt3[tts\\WO9k1JlN1i&g)zZitwF/,ls]*bD0y,=JL4aE]f6)03MQVrJyDt\tNN\t3&M);)n>P6JcOIc&kw:W&Z!,z$vb)bqD?TY$\f;(Tw~+rA/k>)* MLnfF+dm3$N,xi.S}\\\fNoU\tMmb`TLR?4nM/1Zs\fi\v7=@@OO6B\f$(\fmhVeWK,cC! _mxH4&5nAh!=J>,&1xwU=@r|{M\\x<\"^Rrjtz_q8!#OC-=J!u=@N=@GthPcZJ*u=J$=@CC{S9=@?yu\t[}%#q^AWS4P@wo&=@2S\fL\"!1!:e9(!>8\ty9\v8(c<Kf@G\bAVu_=J6S28T<G87(j87amdIIk8u'&\\x;iz#i;/20tChbL7gaHkBz|U=@3,,`qxi?|Iy1[R'/\tIX1BCD2E/zY <!T(Z%_DSpmw'`7$!aXH's\\9CNGd>5\b^qQ9le\\[d3tF=MjC9( \bG`bev!*}g7?OWuEdj}YQmV\"pi=}6f$BTU?y=J`A<dj,=JroFU(9e)\t]a9ZEx$f)\b'n<'U}'0ST6A\t#K^tqUI\bV4{9ava~Lk.{mQWv{QT=M~g|$Nj'ihty$\v^'@T~!T8hgN]' &y=}O8Y4hc1~2{ (.yigd\\=@leR\\;\\+9F'[j$ ^p}(Xs732\tKNF8'GCx/<D&syj ((\"=J0r?c|5EEt$Ny\t\b^ot}Af~\b!`wJ-pv&)[xDMgdJt-=@\\eI`Y~OYMO 1hB^AhrLh+ SH|JqQRjg8aaNc:X&# =}Dg&(\td.k]7I0,_#\v <%hAr_7V$#p?g.-&mqydQz_aLlgwrU&gS) ^VNW'\fx#bi9ExsF)C3JrgTpOj6'=MF!FJ7\t*um6!@imp+oR36|Tib~VtyqRU=JdJH;Ny'N\tZ..r}?K2{jRuiQ->5`89jj\f/\t]QSGC)$))Y<+R+Z+V+P+U+P+D0:tZo;oC*+R=}\\?o+REJeJ:31*i.]UJJJyj.Z/L*/+*7-4/D3>0>8^0R4Fz6jIR8Rb\bP,,-*+w0/u4;2.MjLTj]FzGj@,W04FOzgDj`,04r_Pj -G.d6>ba~0M,*0duX,044GPej!H*g,,>cuj\b-.$6/E9JBe(*+~G*#-k-pk=}u:oJJ_J7JWJGJgJ-JMJ=}J]J|++*+c*c,Tl*JkjB3.KIAI2z:z2Zzjj\vj+;fzFnQ\b;Llxpx\"nn\b/CSad=}l*.*kuAr5j{8@F*re5>418WY|**-2jO*Pq.9tz1+h,G(rG*fk0+kj$}**C*T*\"l=M<*2*\v@06C9,BJR*Q^3*XA*M*72=J^,@41+-u/-r#k-*~*uZR.d8$.>6$U+JI=J[3je;j02r0k\f0\\.,=JH.=JX.=J:**e*H*3U5+l|*O*H*8U.=J+=J,A,F.=Jh,=JeeE=JJ9**P*A`QA9G*Aq2B.;?d6'F*@D70f, ,r\b/\b+j\f?*y+A+O**\fg.O.5w$h0g,;vH[00C0KW\v=JH3\vd5\"+m(\vz{~kOt*2Ew}#uW*=MQ&v}\tk15$(|~StBP8Zt{>TwIu}D\\RnIkiVoA|Zjql~VcWcvlcZ,jw|$>RmHq\v{Lyhy?tYuj\v,8|ItFRS}=}W}\t~DnmS#\b>743^jW@}Hd~5Gt3g,H$hj0D|7S#p\b4]N_Yp\vM~5*un\v=@~7$F\v1t\bI\vr(~=}dTDj0AA%1|~\ta\fovNKO:$|iIN2JE69R{Qh8$2t(Btn>h@p}&=MSPv*(Q{S^\tNJ<MS9m:95D9puG=J1,kpJ\t^t}Z86=}>Yx},dsjU|#~Tx_|~XjpI]zeGR\bpQU_\f3Se'q7\fmrFm=M+>Y\\n#?{|@| z=MTPk_x%rt(zWhq/^IucyoG^yl}|GP|]|5MlDRO)6ykXDKwv_V%V(< m{0QY=MVk{r'2mfW=MK!F#3?,<>=ME?D'S\" \\O9qhy!d4d..h=@TU=}R7~fCT\\?5~szY9FWs!G?6p(\tO\bdq$fK>m\tp.\"1`=@xeg7?\t[kq~\\06r1l30pU\\peMSEAzA)T}G;_OQI8!|k(>@{zXz`A{BQrdd]&8Pbv#bm=MHrQ.)lR=@`)V&s4'=M#I\tK#)SxTc\bj]\b0yp5fBh!K, gy=M=@k87=M#3:A$c`4S!GS!\bLh2-@lEw}=}?o7J<0$Tk58}S\t&+T$GI'pCg=M$\f[|qGu8o'XL8I<w{ |s-l_G#s=M|FG\vf3m=@b\"s?x=@10cr}DRr2#VYg~6o~4}pW9~=M_4m\v4!NpiTwi<mxmw5i7!?e\\s'n^RthL3\t#=J%A5\v-A`n/Co`@<C|PRpfvE`wW!Xg\"d!dwt3|l\\1ys9^W2{H??u%gk\tP-!r{} ^87y;uP9WC|].d\\W}hU].4NnDQ AdO'}\fzL!SIt}-WP1LOESVbKhbj6?}M/OkqD`.6_a~QTYecdn\"{,19_{KHYRQW\"iaQE}g_otlBe5MGh1$l$Tu5PQpDYI=Js\\NY]OhdL^2\b\t\b&cQnve&c7U~k!<Stq%qAd 3>\tNHESi [ \b9g9Zo\bEEg''8$~Z&z\vMlYoB%z=@Yfd=}as=Mb8nZbRX\f]UXtH^ZcZ7]\f9][=}cSVc({6f(\"%|N8{0GPCP57YjR3k\"+r?_MZO],lK_+ujN=}{~KG=MR%&Ft4Hv=@M*oRn@aGOR~}ToPk#~c[jT?/=}[Lx?Uoh;fYln;k8=}oI;?K#h;60A-^\\Pu-VJf>+9*.L*l-+w$UlJy;(.\t=J!]b):\t<UL^)^2_@n22;;Tv<;LGJlo2~?\b4/X~?)4>Xj|Uz4,`jUT&F/XTq##F=@Xq\bi\\>6Vm9C&-u|zfu^|Nc?/I`l=}\v~nTOr3?-n[5Wpo};TTl2?zK5Fl'*#Yj4+'q%~%W9zHa/=}J\v>NXk8JFN<wpPM}$q`l{`dSp_QVhn0OP\\R6h3Qka\f>YcDf?~^4Ghvnxn{'Qq\\Ns)rLGsjo\v3R f~=}pb,d+wjE=MlVD!g0d[MDZ8nmYDpKR^}Nnk(U;n.ZF\v2E\bpB$a4xIqEM{NZ.f,\bN^F7g6gB6oL{o2$?J[W2g5n!-;2Id.3jXH+i\vm?'t)1vk!:c>K=}6k5DoKu{izy=Jfz]e7&k!jNIg:WoA!*Eg*]g3#I cwq}9jH8 4$8m8LAW_pO=@R<_jC4]m[!=}DM~zKh7hxZg`sA=@kWdR_sEf4o0<'m{T_$T=M\\$\"Ln,-IO\fDyH4jeRL{8oJ?6<pTz>Im7=JQ\bG){%6]WTZP\t\\789h]51@F'p\ta=@=})l)v8=}C&e%8SaY{Y]U\t\fYZ[m\\y]Iy[`[dsii3cbGgcbW\bHa[m\\x]5D\\hX^Z+a[5\\]uBEB%lha3ubap{HD\\}CQ,p}`E[!au=}=@{=}Bk6v>f54J*&9~[[=M\\mCiS\t\"O]5VPlmH6~g=}ZARZ;Vgd!4'>h%VUF-\vk\v\f58;v$P@\v4UtA3W>B:=@\bS=}0@x@v>:HG;N~SyLPAOMf\"&wq/yC'|\t\f=J19\bpGI\t\\n\"=}y=}x\b\fmY)Qdi[cDGx+`\v(c`#xo^Q\t#1Y(%~ oAY2M\ba9=JA=M\\uM\t)H|{P[/ b7 H`7hDwq *=@j =J{R!0'(;(9b=@J_[_# yM8wQ'TnT\b \vv7eW%kG\t`8SHYK%[3RCOOWrQe=M^k0e{GI w%c1m]A |=}#@=@SC\v!}Au p& =J`=@!=@{X\b%I=MivHaWEY=Mu #=@'E\\'x$-i!&)k\f=M>{q=M|>HD)N\"g&F 2pg/hBUIX?DOctCr=Ja%n}40\b-Y=@t@ZyEU=Jq|FI\\Usi-*X]shpb;(B=JywoS\\c6u4L_`@5\fhGXay1\t6c\f'=}h37c{*/f\tj&p:p1ja'79\f=JH\"Q=}%\b\v\"a%:aQ6H#=JGA'i&m*(#f*F6Q,EJaU2{7k2`.yB6_G=MfV>\f(M2\vZ<`q\vEp\vAZ_DI\veFI<\to=JQ$[rO<o> ]DiI)=M\bbfbKLDS[\"$BO@\v\"C%w{P=J3YW8bf(PPE3W;UQ\fl<d3!t_\f\\9qt=J3S\"TQB\f~pT8v^f]G\b=M<Wu\\OC6fPaa=}9qd\vVfW5A=MQ'\\i\\(\\`\"ZCYcFDb4a4hf/AP9Iux\v]#bNJI=M{7*m/\"p+H*'Rm5lf}K\b:A\vo\";d>Mf_BU8W&[`TOb.gRD}TbYTT=@he?i#f?)=@U3(i>YS}q6d\v\\6V_qbC[=M\"V8=Ma\f?b,i~=J?p/tU1?4ztn_fnZ2A;]LFyyLf=M2qLf(25\tL&&2a(<\v=M2#5L7y%`k?$\tJl=MXz;;RloPqq:HJlo7/XN4pRqMdR^6ToHG8xo)<.Rp9@\vr;V^5l+$c*?q+#\f%fi_9d/De/of0k%^~`Y5P|8/z2\"`f{'^^yTd e/[Srn^#~\\nONJ;7\tFg+sF>[Aqi=MzL4Dks;'^d6?lOpgM\t\vZ^!z)Dp7p=}I1y:~Q*v'^9nhM'QOaN%JTt+ryCIDF{i>/E%3`RDnd5Yr3[B*gqaSgw1G2p\bD\tjTD&q\b\v4WWt0sIl?+^\\I[d\\YhdCyvm7{=MO}4H\\[ wIZI\\pI=Jy]}x\\6c^)ZedU=}Q\\fBnD]I\\zS=M1}z.y]3;N5,=MBOU3=MX}/6u[;x{$Ve~ubl'z\v{\voA4-}5C9\v,MS\vr\b3K\bHIVDA\"$=}g\v#5vm=M\tw=@ Km{^\f<' ['e-EDCioZa6EcN=@o9Q\\`?xs8T'=@hf8`AgDFGC@=@C`P'fzg F\bK8\f=ME# yY&&`i{D'dfHk+ET+6R\v>s/e }e=M/_WsE(QMh8\\B\b#3<5-5Qg`#WHF&'Z$3*5=@9\v1=MA}Q<Cf<\vhbYh9&*VWA0\vrK.iG8[9\f*.@8He1'f~aF\fo=JMNc<E\f=M\"=J,%U@`HYb+@vM+\to=}<B*L8tY}q{DX7r=MPC\"6&Px \vob\\xhCFM1\tx[4]kh4p+\t}SURLL[BITO\"\b<TuXwxP\\>gYT\v\\F6ye{lc8}q=M?,DT=M4&=Mu/X;eY;@L;XR ;\tTIq}Ib`\"GY2c>L^}tFo\t4/<bJ|p9WqA=J\\mST.C\tTpf\vz,-5,^L`In_4o4c\v`]{J-uqMS$nsl=}RP8q6>Hf@VnpJ$R\v2&bR:1(,I`1\"SZunwrjJxr;wq/d\b>_p6`yjwGt~mf>zVUF-%X#=@C'y\vI)`MY\\yy]cyZ!I(]X\\=@ZAZG[q9vy[bD(yeZD]kv~^{#;\v=M_iU3yFSYu%[=}{Bn=@wM.\txU^x@`|2EdUXG8TEXf@Sf]\t8`Y: 19dXm/Yls(9(a]Hh\"F)5obDH=MK=@8Cu_aG(\"\"6'/IH_2)m=MD0If%]=M=J,J2H=Ml(37[r LD\f=Mb=M}yP\fK\"\"Z?i\tP\"6F]=}}P=M&d4@/:YuVdBe=JOTXIW~,U\v4/8n~;hmA)9L*Z/.Uu;!M6Yo\tt;$9m4`n5(>>b3Y=Jr%bNnL\f;tpJ3Q|De ?l#R*O=@ltM{{h:((\\\bFvf=@x<[G[|vO&=}V^%{\v=}yP_\t&$,Q1@F=@M_ x=@Rc$;e &IZ!n8S\f8h=@1FCH9C]IR3NYFsc=M3ch+vw]|&sPF`C/2)^XulI>X4IRTo\"Q;()@&S`{A/W1=}dShj&)>9-8q)&\ted [#Z=M>d()\b[*yF/g$@F))o\bQ+X-17 @\\2#$#16364^HSE<>\\\"{n:b[_gM]etk{so33SC4uTa5+MOvSc\va=J\b\"i(vSmY\b((I_5>c =@(\"g=}![/@e&eXg!a^#x'hEh)=}~Y$'&d& t$RaZQ8\f=MG\b'm2rL^O=J% ;'e3G=Ju\vGWmA#M$eN\f=}$t=J(xdrEe!FimMWbAy<^C9/=}$Nj+>wv7?6}W/d*z]*A!gTmZIXkg?VH5u(\b(CA~*8*Cz'ci8Dx}e[v$4s}<J$xo12*smr_mQ.2}fIlbk,^ZY4=}ZWgCNW^9\f]XljG8?lpd.Pd%+5+Z)5'\tuk.DuJ=MH=Msl>pAn,FkfHl\tK,VnKJ=MO=}j~VghuUkfs5}lnRV@4[Dt@=@:H.HiJ=@=JJg01,$`.LJ7Wfm&;V 2 |tx]-V\\+l<}^ng_q7mzwYEAXLU_\bq {z1o{$BGwGt{=@7wjbJ8zzDq!{;X.|`r,aC9KtX,TC+PVgS?I:DLh@:aFa`(:+MwQ+\b\"-nrGZ;C-Ll^?kdF^f$P* -71mIbxj+tiKfn`:Dok:My,T:4PQ#6M:lyG&-Q\v#/NRe3+g^hTFL$3kpP^A: ;\fRTl`e;K3nr=MkL$4d4N\b,GHY=MR=@w7WmiG?.!|:%VT$TSk(P\bI{\fBS\t/@yl4aK\t@7S\fw!{rF_p@0Zg=}hHHEIYumTm`ngCuOar\fQ=@eH\"m5$ Q&T|=J>ABx\fT/i<?31;\\(_DT<=@0M`(Fd\ve0Pi.S]&6;,!=J=JuC6pd 5\f7X\"J.\vBc6:\v.@kDBlP;-:=};+m:3m\b:;m;Cm\b;+m:3reDm;Cm;*-Y:.-:2-:K=JK0\\}6B*[+C/-\\JE0k66BK0\\J}6jB[+G56.0jq+e6:0jZ@-dkBc68o0<\\B+6Z0j[`-dkC6*0Z+v0-B?K0-K6<,Zu2B_K8- k6>,P[EZ+\bvc!3QO!=}3s.NhIi|H|h||9IYiyL9LILYLiLyLLL9.ni2:<'KO$nuEXi.ni3c/<'OO$vueX19AIQYa8qylMg6kLeesHrrr\brHsss\bsCrrrrCsss392Y2y22222293Y3y333336Vv6Vv8:Jdk2?]n8;LdoB_n!8<NdsRn8=}Pdwbn!302@2P2`2p222222222=@22 203@3P3`3p333\tF3O!QNgJk:s&7N#L|QsrP\v9dyiXNsv3)<#WO=M|QusX9Qn3<'\f4rurLyKns<'TsrP1=@`yIWN.sv3(<WO\"Pu=JsXI#$/wJb6$OwKbF$owL\tbV$wMIcf$wNcv$wOc$wP\tc$wQIb /wRb OwSb owT\tb wUIc wVc&@v=}6%swQBP;63%2%3s2s(juZvyZvmZvqZvuZvyZv\"kZv\"mZv\"oZv\"qZv\"sZv\"uZv\"wZv\"yZvkZvmZvoZvqZvsZvuZvwZvyZv1ZAi.n2;6=}MBP$qi.ni3<6=}'OBP$vZveZ19AIQYaiqyN ^MsD<umP\brHO h|0sUESj=JmNMfqb\b<Hu$UF6N'Cx`np(8QeLmsWi0;sGm(BnN'_x!8t$<G!bOdV9wjkZLKBqc;s$F 20O'@r/=J|o0kL1\\j]W+yP?*w=JaL=M*x41\"u40`|.:3HU:_Fte/3rr,/<51C0|/(:_2&gu=M/U>`j\\0fi1!pq;2+{M\"d@?M=J7-(JMFj=JA0>,Ho=J{'Q0.n0\th{=J0AT:Rwo1:\"\"z)N\"!e\"c(=J1[6DY6?=JvP/9^.i\"s`,h8(:8(=J+|1,y2o6A1\"{F=Jg9J/)3L,=}O8&NBfO>+aP-6#z9afVl/|yZ,1kD5[@m0Nc:6.p_k+Jry9D,|NgkJebVr:L4N^0/C,S*\"J7YNgrRDN1F-*=JJ:t*G0?*q1-y]8B=JfG\"4+xo+J\fAF1P;]TOk)3E}3[e%=Jl\vT@*FZ/H=}t5-JO_RG1^|lzpRFB0 tm6J7-*#80x\\@=Moacx5 jnNzX*G+8+?,cj+W,Q#.=@)m#GT}*#~GCeL>''?!!4!eH~=M[bOZyH|eTu\"Lp/oId>,,#5Az\tQ\tVTmSm53C[X~\t\b\b/-u%GRHZ}0t#?xEG>cvn\t=JC-~X];<Z=@?7_H{d^oI\\n~Phb\brp\v-51[@4jup@g^P-Cj%/vLc4L<|=J3*Ab\t\vl=Mmpq IP(=J+W\foP^\bg\\DCC =@4\\h{%VF?1dr15`fPbgxWHZe/asL~}_t`h3#GVn\b5gAYh] q)f[8\fE9(\"xk/X'R\v0)'d=J|Ot&#C&Yt$)$aI04=@EPM?=@^Em-l)>@%=@_Uq\t&%>>XRm5I=J\fQIRW/1:]K${~t&N$Kt,kMdIgi_\f cc^\vc$yy\ta6sPO840)$bbc@$hDfOi`g!8TIia\\CY`{.2t4}`PMUekp=}'lHn9#&ruA`|$Iw Z`{\"3!,=My{\\i)h(#\fxFi't`W)oP/`3}c/!eG4;hXD\bp8B$\f'oM-S4/_m\\AeNd\"Fgx]<Z<%=MD_Mw\"Wdp8=@{XHH=My9XH)ehC_X#w$\bMq9(~\t\f=Mw!W=M^E|8n-h@ET7irk#@(o%)=JG)\v\t<]`@BU=@9}8hR]<GUB| q$0E\t=@{M,\tW'$wj9u`)d =JQaFUbEE%-u\t}Io5<~@C#%&Y3 l#yG=}7Wp5486>)PSPalQh%Cq@F=@=}!uQ{Y=@(+St1\fHY2sah\f\ve.v/IPovb~\t\fCDuVw'%A97IBq/7t'|=}IFv_V5KxjoyT<r=Mjg#^~#'rl=MHUU@4-)sx)=J$]4z`|'=M,^)Ic_Zyzgu7q\"? \t7P%!icrrT`V$S=@c%K&p=MX\"7YgS=};'|U{.&pAHp-xU>~N)\b#y_Mov;BN%$$9\t\"w1i`7}A\b(cc,<@_or/b(\\w=}7xu\b\tij5`w:g[uYf[\v+m\t]?Pf\"P  |u=J9muy'x$GQvAYYYhV=@WY76Hq\vn#=MV7<NA~#tA~\tbi\tw?51E3x)J\b#eq|-&C@\t9d\b1V,5fQ AW&8?[E>a}B'v=JhA)Yr92)=@d\tD(wiW_=}.xi=@`/v(f9Q(=}c^R6%#9AcaX'\\P^!yOi7=Mt!xRSP\fXg9S{w^]Y7|}Pgn?=}_tu\fs|8QBF3)aq^0nGZK184=@' h5wA#627]~{wZ7a\vXTq$Wtb=J[p=}hu3bc(E&D=MsHe\b[(Ii%by)\bK7a\\=M\tH&6H &z#+ae`W' UhF=M'uv\tEuT8%=J(\t\"\bD$e&%\\(\t\bG){ \b\tXuZ%$>/aV3[ Q0=}p*AyaiCDe97X=@z\b?x']y>#PE_%(mfcK\t\f&M0`_9H\v\vMu$YW=MW)$-!Ai^%Ad)#@^pie8%x\t&_#Wh{@dcG!`Ey\"6(h=M1Gv=}7OPg}8ge;#|bHd\\\"ZxIr#P&)U#=}'h8I&IdT\vg'=}%\f)RQ](x]Vy%_Ub\\ HEG_HXTf<%]Qt>'E9(`M3BNT\\Y\t/h(@ (5dd\v+iY%:$'`h\\d/W'!afpKf?quodYhy^=@af\f&W(Hj=M$]Mqgd!H_P\vbXa[+;IIQ'=JiPeW_lOQ+CQo\vM?vvi}!\v)fa'TJT=@M~yTaXt\vsmO\f>%h@g)s9}9=@ts\\_X\bB/YK\"=J\t)r}N%=@}xa=M(!?W=MS<'n>[&#=MPsa%}x5=@s\b!P~T\" 9TPXB>c=}`}eH6UX!W'k&pMM7)|a#(7@Y&p''D\\YUEyaKq{%G5)vmz@@Uz\f@Le>/Ny\\&3gCO5,Rl\t'uDP|;KNk=J8f(=J;ZWJ*Du>QFfsS@=J/CImh(kOe\"E=}Ax9P<L@!Je\vS&\v&+ReL%h1*\v1*[iT|j(x=}E($bE`,sAJ\vuOB563||/cghGLH2vfhz;DlwM#eb?2QUX*i=MG71TzygYBlH]d&{yCq|DB]btuI=M(3&k3~=@=Ja\fp7Sz9=MPc=M@,*=@\vTG-gk3P7L'1ksLc\f~ uGhF.z\\c*rZv'\vk53U\"nO=@|\"L,D{Hj;(Lg\v2y y-\t|)(`N[\\a[4_2h#41i|-_Wjw642Bq:TFQ0{-=Mx/#g\tekaq2=}=M9QsBFpcvV^VZ42=M@UV=@,k\tl>h]aLub99<,FZr4A|?`v2'R=@chV*#}U=MK'`)\\?|g=}It;Oy=@#k_+F~<=}tE*!6TP9jVL]U4]vv>:=}\\_B4gI6+H, ,'ZB\"=@;FJpv<U=@ wPcU#Y3@<=@%t~ta6D;PASn/;HQz!9)G70$\"Ad=MOdb?\vvkpR\\@UQO=@\v8{GG$}b>jOn(\"H1HiQ~Nzhp<\"r\"]8.:w@+$Y !5jHE1HBy~M*HVf&;WSk`5gxQ\\h&A$iQOu\"JpksQa$HmO5y)pyj|Hmfc55\fK=@B\f5t3J?C6pQa\v3#{-R1x<UStv'D\b/\b=JqZF3NwDE\f?xf{K7p;qJ|^gNnF:(\vk3N_mYI/2abmeQHN\\59sTB=MNz/U\ved$xIo!o\v}{mIh6`=M>0PVQ_&7ac%n'J\tq_ z+tBP_kV)q`]=Mhuvy/a7Vw\b=M{>RhiIvt\"[AS}Mo?EG~DLO!<2g'4 Whga0#{Afq\tc-!]$%6p)}j}=@w1pA?A/`nc(U5T&I2Ov_xz9=Mj.SQ.Bf=@jP,t#)h8uCS(.>^#Sh5h=JpJQL[c<sZzO`y=JL-/<I=}\b\f6dKXR`Z5.3Wg7EHHA\tDIa=@YHt1/nR=}GQ[=@8g^{M\\aOd6=@B{*n&Lhe' \b>Dr7Q=J:=@)Qq'v\\6]Idg0_,209~]Y}8ViS}x_\t(d<C%WDLUr8$6W^ 8w[IQZTUufsB2'6BWVspY[cG1eH,3NP&&=M[_bf~\fjIJ:w`97.w=@]eB Q2*@NE+.i1g&&-Se?v)${pNNXZXNO=@#Br!uf/ohO.wy(`<kb2ZXi+\\^5Ns3dPbhy%[\b*G\b<Bp]?5p GL`glm}R)n8\by@/1\\:XOFjG6i'Tt$v%>}#@cROV\"-k}\vho+i!=JI'$9Gb|I=MFWRO\fE2qXmI]hA,qg\f1]{q@,~\fVHY4Wqi@(SG@'^JHo{[:'{pHA=@YJ6X_\"l:'I(_.wAtIFBdd\vFu7kwv0HY5#dwU.7x(\vfQ?fDY[r!A0pHRmlW\fvfs:# $'.tR/hx[vj\tQT\\J PN2_SUo5Vap/<#!v1~iY>Z7i]7Obw@fWyx|n$$G8cZ=J/6ug-1_<4^Rq:[gwJ\vSs5BJvG|Wdz^b'/)=MYmW[_wVHfa3>0.jL_lZ YuCz&>8Hz|[gv}$ONnS8j?,]+y>.~+\fG;H,>\fr^=JW|W=JDsIy[Xt\f7*=ME;}NFi6s\v#\feiikL=M\\wU\t13VG!\\;v\fF}L[>#9@vf 0kt5g|7=J_3Et> *-)E_/39KSTf\vm=Jkjd|7shVcBy>]\t\v9lRfYDtJ|i1Om0.:7LGqcg=M]w}/#WeX{.0^\b*D9k=@_XM{\vLcY'7=JtzZxT\"4JlipU`=@NO\"\b#8=MlSB1|jbl&BD$',GOY>(u09f$%J/ij\\/svc<rn)Nk\\uby\fntew8=@=}wZDaQdLw\bK=JGt2c{@_\bw)<z]4SyMFBgmYstRP!MR1&E^)%A%]Cl]N=}qHGW\t+\bD0ht!]=@mlI+Z@mS2m_W$\f\v=JE;D\"jr0) \\Qi(.,g\vj\b*\bm@*\vo*C=J5Y$#WFO=}\"b!/:5YA8d6o)Yyx0\bOZ$A'\t)=J6(1"));var $,m,H,I,q,R,k={a:{b:function(t){return Math.cos(t)},a:function(t){return Math.exp(t)},c:function(t,f,v){p.copyWithin(t,f,f+v)},d:function(t){p.length,function(t){throw"OOM"}()}}};WebAssembly.instantiate(O.wasm,k).then((function(t){var f,v=t.instance.exports;$=v.g,m=v.h,H=v.i,I=v.j,q=v.k,R=v.l,v.m,f=v.e.buffer,new Int8Array(f),new Int16Array(f),new Int32Array(f),p=new Uint8Array(f),new Uint16Array(f),new Uint32Array(f),Q=new Float32Array(f),new Float64Array(f),function(t){t.f()}(v),g()}));const T=new Promise((t=>{g=t})),Y=(t,f)=>{const v=new Float32Array(f);let b=0;for(const M of t)v.set(M,b),b+=M.length;return v};class Z{constructor(t,f){this.channelData=t,this.samplesDecoded=f,this.sampleRate=48e3}}class N{constructor(t){this.ready=T,this.onDecode=t.onDecode,this.onDecodeAll=t.onDecodeAll}p(t){const f=I(Float32Array.BYTES_PER_ELEMENT*t);return[f,new Float32Array(Q.buffer,f,t)]}decode(t){if(!(t instanceof Uint8Array))throw Error("Data to decode must be Uint8Array");this.O||(this.O=H());let f,v,b,M,J,r,e,a=[],n=[],i=0;try{const o=11520;[v,b]=this.p(o),[M,J]=this.p(o/2),[r,e]=this.p(o/2);let s,u=65536,c=0;const h=t.byteLength;for(f=I(t.BYTES_PER_ELEMENT*u);c<h;){if(s=Math.min(u,h-c),p.set(t.subarray(c,c+s),f),c+=s,!$(this.O,f,s))throw Error("Could not enqueue bytes for decoding.  You may also have invalid Ogg Opus file.");let b;for(;(b=m(this.O,v,o,M,r))>0;){const t=J.slice(0,b),f=e.slice(0,b);this.onDecode&&this.onDecode(new Z([t,f],b)),this.onDecodeAll&&(a.push(t),n.push(f),i+=b)}if(b<0)throw Error(`libopusfile ${b}: ${{[-1]:"A request did not succeed.",[-3]:"There was a hole in the page sequence numbers (e.g., a page was corrupt or missing).",[-128]:"An underlying read, seek, or tell operation failed when it should have succeeded.",[-129]:"A NULL pointer was passed where one was unexpected, or an internal memory allocation failed, or an internal library error was encountered.",[-130]:"The stream used a feature that is not implemented, such as an unsupported channel family.",[-131]:"One or more parameters to a function were invalid.",[-132]:'A purported Ogg Opus stream did not begin with an Ogg page, a purported header packet did not start with one of the required strings, "OpusHead" or "OpusTags", or a link in a chained file was encountered that did not contain any logical Opus streams.',[-133]:"A required header packet was not properly formatted, contained illegal values, or was missing altogether.",[-134]:"The ID header contained an unrecognized version number.",[-136]:"An audio packet failed to decode properly. This is usually caused by a multistream Ogg packet where the durations of the individual Opus packets contained in it are not all the same.",[-137]:"We failed to find data we had seen before, or the bitstream structure was sufficiently malformed that seeking to the target destination was impossible.",[-138]:"An operation that requires seeking was requested on an unseekable stream.",[-139]:"The first or last granule position of a link failed basic validity checks."}[b]||"Unknown Error"}`)}this.onDecodeAll&&i&&this.onDecodeAll(new Z([Y(a,i),Y(n,i)],i))}catch(o){throw o}finally{R(f),R(v),R(M),R(r)}}free(){this.O&&q(this.O)}}O.OggOpusDecoder=N,"undefined"!=typeof global&&exports&&(module.exports.OggOpusDecoder=N)}();

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],31:[function(require,module,exports){
(function (global){(function (){
const { EventTarget, defineEventAttribute } = require('event-target-shim');
const { detect } = require('detect-browser');
const browser = detect();

const AudioContext = global.AudioContext || global.webkitAudioContext;
const BUFFER_SIZE = 4096;

/**
 * Reference: https://w3c.github.io/mediacapture-record/#mediarecorder-api
 * @extends EventTarget
 */
class OpusMediaRecorder extends EventTarget {
  /**
   * A function that returns the encoder web worker
   * @name workerFactory
   * @function
   * @returns {worker} An instance of ./encoderWorker.js web worker.
   */

  /**
   *
   * @param {MediaStream} stream - The MediaStream to be recorded. This will
   *          be the value of the stream attribute.
   * @param {MediaRecorderOptions} [options] - A dictionary of options to for
   *          the UA instructing how the recording will take part.
   *          options.mimeType, if present, will become the value of mimeType
   *          attribute.
   * @param {Object} [workerOptions] This is a NON-STANDARD options to
   *          configure how to import the web worker .wasm compiled binaries
   *          used for encoding.
   * @param {workerFactory} [workerOptions.encoderWorkerFactory] A factory
   *          function that create a web worker instance of ./encoderWorker.js
   *          and returns it. function(){return new Worker('./encoderWorker.umd.js')}
   *          is used by default. This is NON-STANDARD.
   * @param {string} [workerOptions.OggOpusEncoderWasmPath]
   *          Path of ./OggOpusEncoder.wasm which is used for OGG Opus encoding
   *          by the encoder worker. This is NON-STANDARD.
   * @param {string} [workerOptions.WebMOpusEncoderWasmPath]
   *          Path of ./WebMOpusEncoder.wasm which is used for WebM Opus encoding
   *          by the encoder worker. This is NON-STANDARD.
   */
  constructor (stream, options = {}, workerOptions = {}) {
    const { mimeType, audioBitsPerSecond, videoBitsPerSecond, bitsPerSecond } = options; // eslint-disable-line
    // NON-STANDARD options
    const { encoderWorkerFactory, OggOpusEncoderWasmPath, WebMOpusEncoderWasmPath } = workerOptions;

    super();
    // Attributes for the specification conformance. These have their own getters.
    this._stream = stream;
    this._state = 'inactive';
    this._mimeType = mimeType || '';
    this._audioBitsPerSecond = audioBitsPerSecond || bitsPerSecond;
    /** @type {'inactive'|'readyToInit'|'encoding'|'closed'} */
    this.workerState = 'inactive';

    // Parse MIME Type
    if (!OpusMediaRecorder.isTypeSupported(this._mimeType)) {
      throw new TypeError('invalid arguments, a MIME Type is not supported');
    }
    switch (OpusMediaRecorder._parseType(this._mimeType).subtype) {
      case 'wave':
      case 'wav':
        this._mimeType = 'audio/wave';
        break;

      case 'webm':
        this._mimeType = 'audio/webm';
        break;

      case 'ogg':
        this._mimeType = 'audio/ogg';
        break;

      default:
        // Select a type depending on OS.
        switch (browser && browser.name) {
          case 'chrome':
            this._mimeType = 'audio/webm';
            break;

          case 'firefox':
            this._mimeType = 'audio/ogg';
            break;

          case 'edge':
            this._mimeType = 'audio/webm';
            break;

          case 'ios':
          case 'safari':
            this._mimeType = 'audio/wave';
            break;

          default:
            this._mimeType = 'audio/webm';
        }
    }
    switch (this._mimeType) {
      case 'audio/wave':
        this._wasmPath = ''; // wasm is not used
        break;

      case 'audio/webm':
        this._wasmPath = WebMOpusEncoderWasmPath || '';
        break;

      case 'audio/ogg':
        this._wasmPath = OggOpusEncoderWasmPath || '';
        break;

      default:
        throw new Error(`Internal Error: Unexpected MIME Type: ${this._mimeType}`);
    }

    // Get current directory for worker
    let workerDir = '';
    if (document.currentScript) {
      workerDir = document.currentScript.src;
    } else if (self.location) {
      workerDir = self.location.href;
    }
    workerDir = workerDir.substr(0, workerDir.lastIndexOf('/')) +
                '/encoderWorker.umd.js';
    // If worker function is imported via <script> tag, make it blob to get URL.
    if (typeof OpusMediaRecorder.encoderWorker === 'function') {
      workerDir = URL.createObjectURL(new Blob([`(${OpusMediaRecorder.encoderWorker})()`]));
    }

    // Spawn a encoder worker
    this._workerFactory = typeof encoderWorkerFactory === 'function'
                            ? encoderWorkerFactory
                            : _ => new Worker(workerDir);
    this._spawnWorker();
  }

  /**
   * The MediaStream [GETUSERMEDIA] to be recorded.
   * @return {MediaStream}
   */
  get stream () {
    return this._stream;
  }

  /**
   * The MIME type [RFC2046] that has been selected as the container for
   * recording. This entry includes all the parameters to the base
   * mimeType. The UA should be able to play back any of the MIME types
   * it supports for recording. For example, it should be able to display
   * a video recording in the HTML <video> tag. The default value for
   * this property is platform-specific.
   * @return {string}
   */
  get mimeType () {
    return this._mimeType;
  }

  /**
   * The current state of the OpusMediaRecorder object. When the OpusMediaRecorder
   * is created, the UA MUST set this attribute to inactive.
   * @return {"inactive"|"recording"|"paused"}
   */
  get state () {
    return this._state;
  }

  /**
   * The value of the Video encoding. Unsupported.
   * @return {undefined}
   */
  get videoBitsPerSecond () {
    // Video encoding is not supported
    return undefined;
  }

  /**
   * The value of the Audio encoding target bit rate that was passed to
   * the Platform (potentially truncated, rounded, etc), or the calculated one
   * if the user has specified bitsPerSecond.
   * @return {number|undefined}
   */
  get audioBitsPerSecond () {
    return this._audioBitsPerSecond;
  }

  /**
   * Initialize worker
   */
  _spawnWorker () {
    this.worker = this._workerFactory();
    this.worker.onmessage = (e) => this._onmessageFromWorker(e);
    this.worker.onerror = (e) => this._onerrorFromWorker(e);

    this._postMessageToWorker('loadEncoder',
                              { mimeType: this._mimeType,
                                wasmPath: this._wasmPath });
  }

  /**
   * Post message to the encoder web worker.
   * @param {"init"|"pushInputData"|"getEncodedData"|"done"} command - Type of message to send to the worker
   * @param {object} message - Payload to the worker
   */
  _postMessageToWorker (command, message = {}) {
    switch (command) {
      case 'loadEncoder':
        let { mimeType, wasmPath } = message;
        this.worker.postMessage({ command, mimeType, wasmPath });
        break;

      case 'init':
        // Initialize the worker
        let { sampleRate, channelCount, bitsPerSecond } = message;
        this.worker.postMessage({ command, sampleRate, channelCount, bitsPerSecond });
        this.workerState = 'encoding';

        // Start streaming
        this.source.connect(this.processor);
        this.processor.connect(this.context.destination);
        let eventToPush = new global.Event('start');
        this.dispatchEvent(eventToPush);
        break;

      case 'pushInputData':
        // Pass input audio buffer to the encoder to encode.
        // The worker MAY trigger 'encodedData'.
        let { channelBuffers, length, duration } = message;
        this.worker.postMessage({
          command, channelBuffers, length, duration
        });
        break;

      case 'getEncodedData':
        // Request encoded result.
        // Expected 'encodedData' event from the worker
        this.worker.postMessage({ command });
        break;

      case 'done':
        // Tell encoder finallize the job and destory itself.
        // Expected 'lastEncodedData' event from the worker.
        this.worker.postMessage({ command });
        break;

      default:
        // This is an error case
        throw new Error('Internal Error: Incorrect postMessage requested.');
    }
  }

  /**
   * onmessage() callback from the worker.
   * @param {message} event - message from the worker
   */
  _onmessageFromWorker (event) {
    const { command, buffers } = event.data;
    let eventToPush;
    switch (command) {
      case 'readyToInit':
        const { sampleRate, channelCount } = this;
        this.workerState = 'readyToInit';

        // If start() is already called initialize worker
        if (this.state === 'recording') {
          this._postMessageToWorker('init',
                                    { sampleRate,
                                      channelCount,
                                      bitsPerSecond: this.audioBitsPerSecond});
        }
        break;

      case 'encodedData':
      case 'lastEncodedData':
        let data = new Blob(buffers, {'type': this._mimeType});
        eventToPush = new global.Event('dataavailable');
        eventToPush.data = data;
        this.dispatchEvent(eventToPush);

        // Detect of stop() called before
        if (command === 'lastEncodedData') {
          eventToPush = new global.Event('stop');
          this.dispatchEvent(eventToPush);

          this.workerState = 'closed';
        }
        break;

      default:
        break; // Ignore
    }
  }

  /**
   * onerror() callback from the worker.
   * @param {ErrorEvent} error - error object from the worker
   */
  _onerrorFromWorker (error) {
    // Stop stream first
    this.source.disconnect();
    this.processor.disconnect();

    this.worker.terminate();
    this.workerState = 'closed';

    // Send message to host
    let message = [
      'FileName: ' + error.filename,
      'LineNumber: ' + error.lineno,
      'Message: ' + error.message
    ].join(' - ');
    let errorToPush = new global.Event('error');
    errorToPush.name = 'UnknownError';
    errorToPush.message = message;
    this.dispatchEvent(errorToPush);
  }

  /**
   * Enable onaudioprocess() callback.
   * @param {number} timeslice - In seconds. OpusMediaRecorder should request data
   *                              from the worker every timeslice seconds.
   */
  _enableAudioProcessCallback (timeslice) {
    // pass frame buffers to the worker
    let elapsedTime = 0;
    this.processor.onaudioprocess = (e) => {
      const { inputBuffer, playbackTime } = e; // eslint-disable-line
      const { sampleRate, length, duration, numberOfChannels } = inputBuffer; // eslint-disable-line

      // Create channel buffers to pass to the worker
      const channelBuffers = new Array(numberOfChannels);
      for (let i = 0; i < numberOfChannels; i++) {
        channelBuffers[i] = inputBuffer.getChannelData(i);
      }

      // Pass data to the worker
      const message = { channelBuffers, length, duration };
      this._postMessageToWorker('pushInputData', message);

      // Calculate time
      elapsedTime += duration;
      if (elapsedTime >= timeslice) {
        this._postMessageToWorker('getEncodedData');
        elapsedTime = 0;
      }
    };
  }

  /**
   * Begins recording media; this method can optionally be passed a timeslice
   * argument with a value in milliseconds.
   * @param {number} timeslice - If this is specified, the media will be captured
   *        in separate chunks of that duration, rather than the default behavior
   *        of recording the media in a single large chunk. In other words, an
   *        undefined value of timeslice will be understood as the largest long value.
   */
  start (timeslice = Number.MAX_SAFE_INTEGER) {
    if (this.state !== 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must be inactive.');
    }
    if (timeslice < 0) {
      throw new TypeError('invalid arguments, timeslice should be 0 or higher.');
    }
    timeslice /= 1000; // Convert milliseconds to seconds

    // Check worker is closed (usually by stop()) and init.
    if (this.workerState === 'closed') {
      this._spawnWorker();
    }

    // Get channel count and sampling rate
    // channelCount: https://www.w3.org/TR/mediacapture-streams/#media-track-settings
    // sampleRate: https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/sampleRate
    this.context = new AudioContext();
    let tracks = this.stream.getAudioTracks();
    if (!tracks[0]) {
      throw new Error('DOMException: UnkownError, media track not found.');
    }
    this.channelCount = tracks[0].getSettings().channelCount || 1;
    this.sampleRate = this.context.sampleRate;

    /** @type {MediaStreamAudioSourceNode} */
    this.source = this.context.createMediaStreamSource(this.stream);
    /** @type {ScriptProcessorNode} */
    this.processor = this.context.createScriptProcessor(BUFFER_SIZE, this.channelCount, this.channelCount);

    // Start recording
    this._state = 'recording';
    this._enableAudioProcessCallback(timeslice);

    // If the worker is already loaded then start
    if (this.workerState === 'readyToInit') {
      const { sampleRate, channelCount } = this;
      this._postMessageToWorker('init',
                                { sampleRate,
                                  channelCount,
                                  bitsPerSecond: this.audioBitsPerSecond });
    }
  }

  /**
   * Stops recording, at which point a dataavailable event containing
   * the final Blob of saved data is fired. No more recording occurs.
   */
  stop () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // Stop stream first
    this.source.disconnect();
    this.processor.disconnect();
    this.context.close();

    // Stop event will be triggered at _onmessageFromWorker(),
    this._postMessageToWorker('done');

    this._state = 'inactive';
  }

  /**
   * Pauses the recording of media.
   */
  pause () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // Stop stream first
    this.source.disconnect();
    this.processor.disconnect();

    let event = new global.Event('pause');
    this.dispatchEvent(event);
    this._state = 'paused';
  }

  /**
   * Resumes recording of media after having been paused.
   */
  resume () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // Restart streaming data
    this.source.connect(this.processor);
    this.processor.connect(this.context.destination);

    let event = new global.Event('resume');
    this.dispatchEvent(event);
    this._state = 'recording';
  }

  /**
   * Requests a Blob containing the saved data received thus far (or since
   * the last time requestData() was called. After calling this method,
   * recording continues, but in a new Blob.
   */
  requestData () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // dataavailable event will be triggerd at _onmessageFromWorker()
    this._postMessageToWorker('getEncodedData');
  }

  /**
   * Returns a Boolean value indicating if the given MIME type is supported
   * by the current user agent .
   * @param {string} typeType - A MIME Type, including parameters when needed,
   *          specifying a container and/or codec formats for recording.
   * @return {boolean}
   */
  static isTypeSupported (mimeType) {
    // See: https://w3c.github.io/mediacapture-record/#dom-mediarecorder-istypesupported

    // 1. If empty string, return true.
    if (typeof mimeType === 'string' && !mimeType) {
      return true;
    }
    try {
      var {type, subtype, codec} = OpusMediaRecorder._parseType(mimeType);
    } catch (error) {
      // 2. If not a valid string, return false.
      return false;
    }
    if (type !== 'audio' ||
      !(subtype === 'ogg' || subtype === 'webm' ||
        subtype === 'wave' || subtype === 'wav')) {
      // 3,4. If type and subtype are unsupported the return false.
      return false;
    }
    // 5. If codec is unsupported then return false.
    // 6. If the specified combination of all is not supported than return false.
    switch (subtype) {
      case 'ogg':
        if (codec !== 'opus' && codec) {
          return false;
        }
        break;
      case 'webm':
        if (codec !== 'opus' && codec) {
          return false;
        }
        break;
      case 'wave':
      case 'wav':
        if (codec) {
          return false; // Currently only supports signed 16 bits
        }
        break;
    }
    // 7. return true.
    return true;
  }

  /**
   * Parse MIME. A helper function for isTypeSupported() and etc.
   * @param {string} mimeType - typeType - A MIME Type, including parameters when needed,
   *          specifying a container and/or codec formats for recording.
   * @return {?object} - An object with type, subtype, codec attributes
   *          if parsed correctly. null is returned if parsing failed.
   *          If mimeType is an empty string then return an object with attributes
   *          are empty strings
   */
  static _parseType (mimeType) {
    try {
      const regex = /^(\w+)\/(\w+)(;\s*codecs=(\w+))?$/;
      var [, type, subtype, , codec] = mimeType.match(regex);
    } catch (error) {
      if (typeof mimeType === 'string' && !mimeType) {
        return {type: '', subtype: '', codec: ''};
      }
      return null;
    }
    return {type, subtype, codec};
  }
}

// EventHandler attributes.
// This code is a non-standard EventTarget but required by event-target-shim.
[
  'start', // Called to handle the {@link MediaRecorder#start} event.
  'stop', // Called to handle the stop event.
  'dataavailable', /* Called to handle the dataavailable event. The Blob of
                        recorded data is contained in this event and can be
                        accessed via its data attribute. */
  'pause', // Called to handle the pause event.
  'resume', // Called to handle the resume event.
  'error' // Called to handle a MediaRecorderErrorEvent.
].forEach(name => defineEventAttribute(OpusMediaRecorder.prototype, name));

// MS Edge specific monkey patching:
// onaudioprocess callback cannot be triggered more than twice when postMessage
// uses the seconde transfer argument. So disable the transfer argument only in Edge.
if (browser && browser.name === 'edge') {
  (function () {
    var original = Worker.prototype.postMessage;
    Worker.prototype.postMessage = function (message, transfer = null) {
      original.apply(this, [message]);
    };
  })();
}

module.exports = OpusMediaRecorder;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"detect-browser":15,"event-target-shim":18}],32:[function(require,module,exports){
(function (global){(function (){
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise

module.exports = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0))

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],33:[function(require,module,exports){
(function (process,global){(function (){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":143,"safe-buffer":50}],34:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],35:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":37,"./_stream_writable":39,"_process":143,"inherits":24}],36:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":38,"inherits":24}],37:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":34,"./_stream_duplex":35,"./internal/streams/async_iterator":40,"./internal/streams/buffer_list":41,"./internal/streams/destroy":42,"./internal/streams/from":44,"./internal/streams/state":46,"./internal/streams/stream":47,"_process":143,"buffer":124,"events":128,"inherits":24,"string_decoder/":84,"util":123}],38:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":34,"./_stream_duplex":35,"inherits":24}],39:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":34,"./_stream_duplex":35,"./internal/streams/destroy":42,"./internal/streams/state":46,"./internal/streams/stream":47,"_process":143,"buffer":124,"inherits":24,"util-deprecate":94}],40:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

},{"./end-of-stream":43,"_process":143}],41:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":124,"util":123}],42:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

},{"_process":143}],43:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":34}],44:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],45:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":34,"./end-of-stream":43}],46:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":34}],47:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":128}],48:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":35,"./lib/_stream_passthrough.js":36,"./lib/_stream_readable.js":37,"./lib/_stream_transform.js":38,"./lib/_stream_writable.js":39,"./lib/internal/streams/end-of-stream.js":43,"./lib/internal/streams/pipeline.js":45}],49:[function(require,module,exports){
(function (process){(function (){
/*! run-waterfall. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = runWaterfall

function runWaterfall (tasks, cb) {
  var current = 0
  var isSync = true

  function done (err, args) {
    function end () {
      args = args ? [].concat(err, args) : [err]
      if (cb) cb.apply(undefined, args)
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (err) {
    var args = Array.prototype.slice.call(arguments, 1)
    if (++current >= tasks.length || err) {
      done(err, args)
    } else {
      tasks[current].apply(undefined, [].concat(args, each))
    }
  }

  if (tasks.length) {
    tasks[0](each)
  } else {
    done(null)
  }

  isSync = false
}

}).call(this)}).call(this,require('_process'))

},{"_process":143}],50:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":124}],51:[function(require,module,exports){
 /* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parts[1],
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress); // was: relAddr
    sdp.push('rport');
    sdp.push(candidate.relatedPort); // was: relPort
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
}

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  // was: channels
  parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      params.push(param + '=' + codec.parameters[param]);
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
}

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  caps.headerExtensions.forEach(function(extension) {
    sdp += SDPUtils.writeExtmap(extension);
  });
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.split(' ');
    parts.shift();
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
        rtx: {
          ssrc: secondarySsrc
        }
      };
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: secondarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(5), 10);
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  var cname;
  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

SDPUtils.writeSessionBoilerplate = function() {
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

// Expose public methods.
module.exports = SDPUtils;

},{}],52:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

},{"safe-buffer":50}],53:[function(require,module,exports){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":54,"./sha1":55,"./sha224":56,"./sha256":57,"./sha384":58,"./sha512":59}],54:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

},{"./hash":52,"inherits":24,"safe-buffer":50}],55:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

},{"./hash":52,"inherits":24,"safe-buffer":50}],56:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

},{"./hash":52,"./sha256":57,"inherits":24,"safe-buffer":50}],57:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

},{"./hash":52,"inherits":24,"safe-buffer":50}],58:[function(require,module,exports){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

},{"./hash":52,"./sha512":59,"inherits":24,"safe-buffer":50}],59:[function(require,module,exports){
var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

},{"./hash":52,"inherits":24,"safe-buffer":50}],60:[function(require,module,exports){
/**
 * Created by Samuel on 6/4/2016.
 * Simple wrapper functions to produce shorter UUIDs for cookies, maybe everything?
 */

const { v4: uuidv4 } = require('uuid');
const anyBase = require('any-base');

const flickrBase58 = '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ';
const cookieBase90 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&'()*+-./:<=>?@[]^_`{|}~";

const baseOptions = {
  consistentLength: true,
};

// A default generator, instantiated only if used.
let toFlickr;

/**
 * Takes a UUID, strips the dashes, and translates.
 * @param {string} longId
 * @param {function(string)} translator
 * @param {Object} [paddingParams]
 * @returns {string}
 */
const shortenUUID = (longId, translator, paddingParams) => {
  const translated = translator(longId.toLowerCase().replace(/-/g, ''));

  if (!paddingParams || !paddingParams.consistentLength) return translated;

  return translated.padStart(
    paddingParams.shortIdLength,
    paddingParams.paddingChar,
  );
};

/**
 * Translate back to hex and turn back into UUID format, with dashes
 * @param {string} shortId
 * @param {function(string)} translator
 * @returns {string}
 */
const enlargeUUID = (shortId, translator) => {
  const uu1 = translator(shortId).padStart(32, '0');

  // Join the zero padding and the UUID and then slice it up with match
  const m = uu1.match(/(\w{8})(\w{4})(\w{4})(\w{4})(\w{12})/);

  // Accumulate the matches and join them.
  return [m[1], m[2], m[3], m[4], m[5]].join('-');
};

// Calculate length for the shortened ID
const getShortIdLength = (alphabetLength) => (
  Math.ceil(Math.log(2 ** 128) / Math.log(alphabetLength)));

module.exports = (() => {
  /**
   * @param {string} toAlphabet - Defaults to flickrBase58 if not provided
   * @param {Object} [options]
   *
   * @returns {{new: (function()),
   *  uuid: (function()),
   *  fromUUID: (function(string)),
   *  toUUID: (function(string)),
   *  alphabet: (string)}}
   */
  const makeConvertor = (toAlphabet, options) => {
    // Default to Flickr 58
    const useAlphabet = toAlphabet || flickrBase58;

    // Default to baseOptions
    const selectedOptions = { ...baseOptions, ...options };

    // Check alphabet for duplicate entries
    if ([...new Set(Array.from(useAlphabet))].length !== useAlphabet.length) {
      throw new Error('The provided Alphabet has duplicate characters resulting in unreliable results');
    }

    const shortIdLength = getShortIdLength(useAlphabet.length);

    // Padding Params
    const paddingParams = {
      shortIdLength,
      consistentLength: selectedOptions.consistentLength,
      paddingChar: useAlphabet[0],
    };

    // UUIDs are in hex, so we translate to and from.
    const fromHex = anyBase(anyBase.HEX, useAlphabet);
    const toHex = anyBase(useAlphabet, anyBase.HEX);
    const generate = () => shortenUUID(uuidv4(), fromHex, paddingParams);

    const translator = {
      new: generate,
      generate,
      uuid: uuidv4,
      fromUUID: (uuid) => shortenUUID(uuid, fromHex, paddingParams),
      toUUID: (shortUuid) => enlargeUUID(shortUuid, toHex),
      alphabet: useAlphabet,
      maxLength: shortIdLength,
    };

    Object.freeze(translator);

    return translator;
  };

  // Expose the constants for other purposes.
  makeConvertor.constants = {
    flickrBase58,
    cookieBase90,
  };

  // Expose the generic v4 UUID generator for convenience
  makeConvertor.uuid = uuidv4;

  // Provide a generic generator
  makeConvertor.generate = () => {
    if (!toFlickr) {
      // Generate on first use;
      toFlickr = makeConvertor(flickrBase58).generate;
    }
    return toFlickr();
  };

  return makeConvertor;
})();

},{"any-base":7,"uuid":95}],61:[function(require,module,exports){
var ess = require('event-source-stream')
var nets = require('nets')

var noop = function () {}

module.exports = function (url, app) {
  if (!url) throw new Error('signalhub url required')
  if (!app) throw new Error('app name required as 2nd argument')
  var that = {}

  if (url.indexOf('://') === -1) url = 'http://' + url

  that.subscribe = function (channel) {
    return ess(url + '/v1/' + app + '/' + channel, {json: true})
  }

  that.broadcast = function (channel, message, cb) {
    if (!cb) cb = noop
    nets({
      method: 'POST',
      json: message,
      url: url + '/v1/' + app + '/' + channel
    }, function (err, res) {
      if (err) return cb(err)
      if (res.statusCode !== 200) return cb(new Error('Bad status: ' + res.statusCode))
      cb()
    })
  }

  return that
}

},{"event-source-stream":62,"nets":63}],62:[function(require,module,exports){
var stream = require('stream')

module.exports = function(url, opts) {
  if (!opts) opts = {}

  var es = new EventSource(url)
  var rs = new stream.Readable({objectMode:true})

  var json = !!opts.json
  var decode = function (data) {
    try {
      if (json) return JSON.parse(data)
      return data
    } catch (err) {
      return undefined
    }
  }

  rs._read = function() {}

  es.onmessage = function(e) {
    rs.push(decode(e.data))
  }

  es.onerror = function(err) {
    if (rs.listeners('error').length) rs.emit('error', err)
  }

  var destroyed = false
  rs.destroy = function() {
    if (destroyed) return
    destroyed = true
    es.close()
    parse.emit('close')
  }

  return rs
}
},{"stream":148}],63:[function(require,module,exports){
(function (process,Buffer){(function (){
var req = require('request')

module.exports = Nets

function Nets (opts, cb) {
  if (typeof opts === 'string') opts = { uri: opts }

  // in node, if encoding === null then response will be a Buffer. we want this to be the default
  if (!opts.hasOwnProperty('encoding')) opts.encoding = null

  // in browser, we should by default convert the arraybuffer into a Buffer
  if (process.browser && !opts.hasOwnProperty('json') && opts.encoding === null) {
    opts.responseType = 'arraybuffer'
    var originalCb = cb
    cb = bufferify
  }

  function bufferify (err, resp, body) {
    if (body) body = new Buffer(new Uint8Array(body))
    originalCb(err, resp, body)
  }

  return req(opts, cb)
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":143,"buffer":124,"request":64}],64:[function(require,module,exports){
"use strict";
var window = require("global/window")
var once = require("once")
var parseHeaders = require("parse-headers")


var XHR = window.XMLHttpRequest || noop
var XDR = "withCredentials" in (new XHR()) ? XHR : window.XDomainRequest

module.exports = createXHR

function createXHR(options, callback) {
    function readystatechange() {
        if (xhr.readyState === 4) {
            loadFunc()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === "text" || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }
    
    var failureResponse = {
                body: undefined,
                headers: {},
                statusCode: 0,
                method: method,
                url: uri,
                rawRequest: xhr
            }
    
    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "unknown") )
        }
        evt.statusCode = 0
        callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        clearTimeout(timeoutTimer)
        
        var status = (xhr.status === 1223 ? 204 : xhr.status)
        var response = failureResponse
        var err = null
        
        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        callback(err, response, response.body)
        
    }
    
    if (typeof options === "string") {
        options = { uri: options }
    }

    options = options || {}
    if(typeof callback === "undefined"){
        throw new Error("callback argument missing")
    }
    callback = once(callback)

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new XDR()
        }else{
            xhr = new XHR()
        }
    }

    var key
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer

    if ("json" in options) {
        isJson = true
        headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["Content-Type"] = "application/json"
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync)
    //has to be after open
    xhr.withCredentials = !!options.withCredentials
    
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            xhr.abort("timeout");
        }, options.timeout+2 );
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }
    
    if ("beforeSend" in options && 
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr


}


function noop() {}

},{"global/window":65,"once":66,"parse-headers":70}],65:[function(require,module,exports){
(function (global){(function (){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],66:[function(require,module,exports){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

},{}],67:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":68}],68:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],69:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],70:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":67,"trim":69}],71:[function(require,module,exports){
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
const debug = require('debug')('simple-peer')
const getBrowserRTC = require('get-browser-rtc')
const randombytes = require('randombytes')
const stream = require('readable-stream')
const queueMicrotask = require('queue-microtask') // TODO: remove when Node 10 is not supported
const errCode = require('err-code')
const { Buffer } = require('buffer')

const MAX_BUFFERED_AMOUNT = 64 * 1024
const ICECOMPLETE_TIMEOUT = 5 * 1000
const CHANNEL_CLOSING_TIMEOUT = 5 * 1000

// HACK: Filter trickle lines when trickle is disabled #354
function filterTrickle (sdp) {
  return sdp.replace(/a=ice-options:trickle\s\n/g, '')
}

function warn (message) {
  console.warn(message)
}

/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */
class Peer extends stream.Duplex {
  constructor (opts) {
    opts = Object.assign({
      allowHalfOpen: false
    }, opts)

    super(opts)

    this._id = randombytes(4).toString('hex').slice(0, 7)
    this._debug('new peer %o', opts)

    this.channelName = opts.initiator
      ? opts.channelName || randombytes(20).toString('hex')
      : null

    this.initiator = opts.initiator || false
    this.channelConfig = opts.channelConfig || Peer.channelConfig
    this.channelNegotiated = this.channelConfig.negotiated
    this.config = Object.assign({}, Peer.config, opts.config)
    this.offerOptions = opts.offerOptions || {}
    this.answerOptions = opts.answerOptions || {}
    this.sdpTransform = opts.sdpTransform || (sdp => sdp)
    this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old "stream" option
    this.trickle = opts.trickle !== undefined ? opts.trickle : true
    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false
    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT

    this.destroyed = false
    this.destroying = false
    this._connected = false

    this.remoteAddress = undefined
    this.remoteFamily = undefined
    this.remotePort = undefined
    this.localAddress = undefined
    this.localFamily = undefined
    this.localPort = undefined

    this._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')
      ? opts.wrtc
      : getBrowserRTC()

    if (!this._wrtc) {
      if (typeof window === 'undefined') {
        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')
      } else {
        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')
      }
    }

    this._pcReady = false
    this._channelReady = false
    this._iceComplete = false // ice candidate trickle done (got null candidate)
    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout
    this._channel = null
    this._pendingCandidates = []

    this._isNegotiating = false // is this peer waiting for negotiation to complete?
    this._firstNegotiation = true
    this._batchedNegotiation = false // batch synchronous negotiations
    this._queuedNegotiation = false // is there a queued negotiation request?
    this._sendersAwaitingStable = []
    this._senderMap = new Map()
    this._closingInterval = null

    this._remoteTracks = []
    this._remoteStreams = []

    this._chunk = null
    this._cb = null
    this._interval = null

    try {
      this._pc = new (this._wrtc.RTCPeerConnection)(this.config)
    } catch (err) {
      this.destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))
      return
    }

    // We prefer feature detection whenever possible, but sometimes that's not
    // possible for certain implementations.
    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'

    this._pc.oniceconnectionstatechange = () => {
      this._onIceStateChange()
    }
    this._pc.onicegatheringstatechange = () => {
      this._onIceStateChange()
    }
    this._pc.onconnectionstatechange = () => {
      this._onConnectionStateChange()
    }
    this._pc.onsignalingstatechange = () => {
      this._onSignalingStateChange()
    }
    this._pc.onicecandidate = event => {
      this._onIceCandidate(event)
    }

    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783
    if (typeof this._pc.peerIdentity === 'object') {
      this._pc.peerIdentity.catch(err => {
        this.destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))
      })
    }

    // Other spec events, unused by this implementation:
    // - onconnectionstatechange
    // - onicecandidateerror
    // - onfingerprintfailure
    // - onnegotiationneeded

    if (this.initiator || this.channelNegotiated) {
      this._setupData({
        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
      })
    } else {
      this._pc.ondatachannel = event => {
        this._setupData(event)
      }
    }

    if (this.streams) {
      this.streams.forEach(stream => {
        this.addStream(stream)
      })
    }
    this._pc.ontrack = event => {
      this._onTrack(event)
    }

    this._debug('initial negotiation')
    this._needsNegotiation()

    this._onFinishBound = () => {
      this._onFinish()
    }
    this.once('finish', this._onFinishBound)
  }

  get bufferSize () {
    return (this._channel && this._channel.bufferedAmount) || 0
  }

  // HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
  get connected () {
    return (this._connected && this._channel.readyState === 'open')
  }

  address () {
    return { port: this.localPort, family: this.localFamily, address: this.localAddress }
  }

  signal (data) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data)
      } catch (err) {
        data = {}
      }
    }
    this._debug('signal()')

    if (data.renegotiate && this.initiator) {
      this._debug('got request to renegotiate')
      this._needsNegotiation()
    }
    if (data.transceiverRequest && this.initiator) {
      this._debug('got request for transceiver')
      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)
    }
    if (data.candidate) {
      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
        this._addIceCandidate(data.candidate)
      } else {
        this._pendingCandidates.push(data.candidate)
      }
    }
    if (data.sdp) {
      this._pc.setRemoteDescription(new (this._wrtc.RTCSessionDescription)(data))
        .then(() => {
          if (this.destroyed) return

          this._pendingCandidates.forEach(candidate => {
            this._addIceCandidate(candidate)
          })
          this._pendingCandidates = []

          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()
        })
        .catch(err => {
          this.destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))
        })
    }
    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
      this.destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))
    }
  }

  _addIceCandidate (candidate) {
    const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate)
    this._pc.addIceCandidate(iceCandidateObj)
      .catch(err => {
        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {
          warn('Ignoring unsupported ICE candidate.')
        } else {
          this.destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))
        }
      })
  }

  /**
   * Send text/binary data to the remote peer.
   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
   */
  send (chunk) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')
    this._channel.send(chunk)
  }

  /**
   * Add a Transceiver to the connection.
   * @param {String} kind
   * @param {Object} init
   */
  addTransceiver (kind, init) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot addTransceiver after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('addTransceiver()')

    if (this.initiator) {
      try {
        this._pc.addTransceiver(kind, init)
        this._needsNegotiation()
      } catch (err) {
        this.destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'))
      }
    } else {
      this.emit('signal', { // request initiator to renegotiate
        type: 'transceiverRequest',
        transceiverRequest: { kind, init }
      })
    }
  }

  /**
   * Add a MediaStream to the connection.
   * @param {MediaStream} stream
   */
  addStream (stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot addStream after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('addStream()')

    stream.getTracks().forEach(track => {
      this.addTrack(track, stream)
    })
  }

  /**
   * Add a MediaStreamTrack to the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */
  addTrack (track, stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot addTrack after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('addTrack()')

    const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender
    let sender = submap.get(stream)
    if (!sender) {
      sender = this._pc.addTrack(track, stream)
      submap.set(stream, sender)
      this._senderMap.set(track, submap)
      this._needsNegotiation()
    } else if (sender.removed) {
      throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED')
    } else {
      throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED')
    }
  }

  /**
   * Replace a MediaStreamTrack by another in the connection.
   * @param {MediaStreamTrack} oldTrack
   * @param {MediaStreamTrack} newTrack
   * @param {MediaStream} stream
   */
  replaceTrack (oldTrack, newTrack, stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot replaceTrack after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('replaceTrack()')

    const submap = this._senderMap.get(oldTrack)
    const sender = submap ? submap.get(stream) : null
    if (!sender) {
      throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED')
    }
    if (newTrack) this._senderMap.set(newTrack, submap)

    if (sender.replaceTrack != null) {
      sender.replaceTrack(newTrack)
    } else {
      this.destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'))
    }
  }

  /**
   * Remove a MediaStreamTrack from the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */
  removeTrack (track, stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot removeTrack after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('removeSender()')

    const submap = this._senderMap.get(track)
    const sender = submap ? submap.get(stream) : null
    if (!sender) {
      throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED')
    }
    try {
      sender.removed = true
      this._pc.removeTrack(sender)
    } catch (err) {
      if (err.name === 'NS_ERROR_UNEXPECTED') {
        this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874
      } else {
        this.destroy(errCode(err, 'ERR_REMOVE_TRACK'))
      }
    }
    this._needsNegotiation()
  }

  /**
   * Remove a MediaStream from the connection.
   * @param {MediaStream} stream
   */
  removeStream (stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot removeStream after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('removeSenders()')

    stream.getTracks().forEach(track => {
      this.removeTrack(track, stream)
    })
  }

  _needsNegotiation () {
    this._debug('_needsNegotiation')
    if (this._batchedNegotiation) return // batch synchronous renegotiations
    this._batchedNegotiation = true
    queueMicrotask(() => {
      this._batchedNegotiation = false
      if (this.initiator || !this._firstNegotiation) {
        this._debug('starting batched negotiation')
        this.negotiate()
      } else {
        this._debug('non-initiator initial negotiation request discarded')
      }
      this._firstNegotiation = false
    })
  }

  negotiate () {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')

    if (this.initiator) {
      if (this._isNegotiating) {
        this._queuedNegotiation = true
        this._debug('already negotiating, queueing')
      } else {
        this._debug('start negotiation')
        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer
          this._createOffer()
        }, 0)
      }
    } else {
      if (this._isNegotiating) {
        this._queuedNegotiation = true
        this._debug('already negotiating, queueing')
      } else {
        this._debug('requesting negotiation from initiator')
        this.emit('signal', { // request initiator to renegotiate
          type: 'renegotiate',
          renegotiate: true
        })
      }
    }
    this._isNegotiating = true
  }

  // TODO: Delete this method once readable-stream is updated to contain a default
  // implementation of destroy() that automatically calls _destroy()
  // See: https://github.com/nodejs/readable-stream/issues/283
  destroy (err) {
    this._destroy(err, () => {})
  }

  _destroy (err, cb) {
    if (this.destroyed || this.destroying) return
    this.destroying = true

    this._debug('destroying (error: %s)', err && (err.message || err))

    queueMicrotask(() => { // allow events concurrent with the call to _destroy() to fire (see #692)
      this.destroyed = true
      this.destroying = false

      this._debug('destroy (error: %s)', err && (err.message || err))

      this.readable = this.writable = false

      if (!this._readableState.ended) this.push(null)
      if (!this._writableState.finished) this.end()

      this._connected = false
      this._pcReady = false
      this._channelReady = false
      this._remoteTracks = null
      this._remoteStreams = null
      this._senderMap = null

      clearInterval(this._closingInterval)
      this._closingInterval = null

      clearInterval(this._interval)
      this._interval = null
      this._chunk = null
      this._cb = null

      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)
      this._onFinishBound = null

      if (this._channel) {
        try {
          this._channel.close()
        } catch (err) {}

        // allow events concurrent with destruction to be handled
        this._channel.onmessage = null
        this._channel.onopen = null
        this._channel.onclose = null
        this._channel.onerror = null
      }
      if (this._pc) {
        try {
          this._pc.close()
        } catch (err) {}

        // allow events concurrent with destruction to be handled
        this._pc.oniceconnectionstatechange = null
        this._pc.onicegatheringstatechange = null
        this._pc.onsignalingstatechange = null
        this._pc.onicecandidate = null
        this._pc.ontrack = null
        this._pc.ondatachannel = null
      }
      this._pc = null
      this._channel = null

      if (err) this.emit('error', err)
      this.emit('close')
      cb()
    })
  }

  _setupData (event) {
    if (!event.channel) {
      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),
      // which is invalid behavior. Handle it gracefully.
      // See: https://github.com/feross/simple-peer/issues/163
      return this.destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))
    }

    this._channel = event.channel
    this._channel.binaryType = 'arraybuffer'

    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {
      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT
    }

    this.channelName = this._channel.label

    this._channel.onmessage = event => {
      this._onChannelMessage(event)
    }
    this._channel.onbufferedamountlow = () => {
      this._onChannelBufferedAmountLow()
    }
    this._channel.onopen = () => {
      this._onChannelOpen()
    }
    this._channel.onclose = () => {
      this._onChannelClose()
    }
    this._channel.onerror = event => {
      const err = event.error instanceof Error
        ? event.error
        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)
      this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
    }

    // HACK: Chrome will sometimes get stuck in readyState "closing", let's check for this condition
    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
    let isClosing = false
    this._closingInterval = setInterval(() => { // No "onclosing" event
      if (this._channel && this._channel.readyState === 'closing') {
        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing
        isClosing = true
      } else {
        isClosing = false
      }
    }, CHANNEL_CLOSING_TIMEOUT)
  }

  _read () {}

  _write (chunk, encoding, cb) {
    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))

    if (this._connected) {
      try {
        this.send(chunk)
      } catch (err) {
        return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
      }
      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)
        this._cb = cb
      } else {
        cb(null)
      }
    } else {
      this._debug('write before connect')
      this._chunk = chunk
      this._cb = cb
    }
  }

  // When stream finishes writing, close socket. Half open connections are not
  // supported.
  _onFinish () {
    if (this.destroyed) return

    // Wait a bit before destroying so the socket flushes.
    // TODO: is there a more reliable way to accomplish this?
    const destroySoon = () => {
      setTimeout(() => this.destroy(), 1000)
    }

    if (this._connected) {
      destroySoon()
    } else {
      this.once('connect', destroySoon)
    }
  }

  _startIceCompleteTimeout () {
    if (this.destroyed) return
    if (this._iceCompleteTimer) return
    this._debug('started iceComplete timeout')
    this._iceCompleteTimer = setTimeout(() => {
      if (!this._iceComplete) {
        this._iceComplete = true
        this._debug('iceComplete timeout completed')
        this.emit('iceTimeout')
        this.emit('_iceComplete')
      }
    }, this.iceCompleteTimeout)
  }

  _createOffer () {
    if (this.destroyed) return

    this._pc.createOffer(this.offerOptions)
      .then(offer => {
        if (this.destroyed) return
        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)
        offer.sdp = this.sdpTransform(offer.sdp)

        const sendOffer = () => {
          if (this.destroyed) return
          const signal = this._pc.localDescription || offer
          this._debug('signal')
          this.emit('signal', {
            type: signal.type,
            sdp: signal.sdp
          })
        }

        const onSuccess = () => {
          this._debug('createOffer success')
          if (this.destroyed) return
          if (this.trickle || this._iceComplete) sendOffer()
          else this.once('_iceComplete', sendOffer) // wait for candidates
        }

        const onError = err => {
          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))
        }

        this._pc.setLocalDescription(offer)
          .then(onSuccess)
          .catch(onError)
      })
      .catch(err => {
        this.destroy(errCode(err, 'ERR_CREATE_OFFER'))
      })
  }

  _requestMissingTransceivers () {
    if (this._pc.getTransceivers) {
      this._pc.getTransceivers().forEach(transceiver => {
        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
          transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid
          this.addTransceiver(transceiver.sender.track.kind)
        }
      })
    }
  }

  _createAnswer () {
    if (this.destroyed) return

    this._pc.createAnswer(this.answerOptions)
      .then(answer => {
        if (this.destroyed) return
        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)
        answer.sdp = this.sdpTransform(answer.sdp)

        const sendAnswer = () => {
          if (this.destroyed) return
          const signal = this._pc.localDescription || answer
          this._debug('signal')
          this.emit('signal', {
            type: signal.type,
            sdp: signal.sdp
          })
          if (!this.initiator) this._requestMissingTransceivers()
        }

        const onSuccess = () => {
          if (this.destroyed) return
          if (this.trickle || this._iceComplete) sendAnswer()
          else this.once('_iceComplete', sendAnswer)
        }

        const onError = err => {
          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))
        }

        this._pc.setLocalDescription(answer)
          .then(onSuccess)
          .catch(onError)
      })
      .catch(err => {
        this.destroy(errCode(err, 'ERR_CREATE_ANSWER'))
      })
  }

  _onConnectionStateChange () {
    if (this.destroyed) return
    if (this._pc.connectionState === 'failed') {
      this.destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))
    }
  }

  _onIceStateChange () {
    if (this.destroyed) return
    const iceConnectionState = this._pc.iceConnectionState
    const iceGatheringState = this._pc.iceGatheringState

    this._debug(
      'iceStateChange (connection: %s) (gathering: %s)',
      iceConnectionState,
      iceGatheringState
    )
    this.emit('iceStateChange', iceConnectionState, iceGatheringState)

    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
      this._pcReady = true
      this._maybeReady()
    }
    if (iceConnectionState === 'failed') {
      this.destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))
    }
    if (iceConnectionState === 'closed') {
      this.destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))
    }
  }

  getStats (cb) {
    // statreports can come with a value array instead of properties
    const flattenValues = report => {
      if (Object.prototype.toString.call(report.values) === '[object Array]') {
        report.values.forEach(value => {
          Object.assign(report, value)
        })
      }
      return report
    }

    // Promise-based getStats() (standard)
    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
      this._pc.getStats()
        .then(res => {
          const reports = []
          res.forEach(report => {
            reports.push(flattenValues(report))
          })
          cb(null, reports)
        }, err => cb(err))

    // Single-parameter callback-based getStats() (non-standard)
    } else if (this._pc.getStats.length > 0) {
      this._pc.getStats(res => {
        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed
        if (this.destroyed) return

        const reports = []
        res.result().forEach(result => {
          const report = {}
          result.names().forEach(name => {
            report[name] = result.stat(name)
          })
          report.id = result.id
          report.type = result.type
          report.timestamp = result.timestamp
          reports.push(flattenValues(report))
        })
        cb(null, reports)
      }, err => cb(err))

    // Unknown browser, skip getStats() since it's anyone's guess which style of
    // getStats() they implement.
    } else {
      cb(null, [])
    }
  }

  _maybeReady () {
    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)
    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return

    this._connecting = true

    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339
    const findCandidatePair = () => {
      if (this.destroyed) return

      this.getStats((err, items) => {
        if (this.destroyed) return

        // Treat getStats error as non-fatal. It's not essential.
        if (err) items = []

        const remoteCandidates = {}
        const localCandidates = {}
        const candidatePairs = {}
        let foundSelectedCandidatePair = false

        items.forEach(item => {
          // TODO: Once all browsers support the hyphenated stats report types, remove
          // the non-hypenated ones
          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {
            remoteCandidates[item.id] = item
          }
          if (item.type === 'localcandidate' || item.type === 'local-candidate') {
            localCandidates[item.id] = item
          }
          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {
            candidatePairs[item.id] = item
          }
        })

        const setSelectedCandidatePair = selectedCandidatePair => {
          foundSelectedCandidatePair = true

          let local = localCandidates[selectedCandidatePair.localCandidateId]

          if (local && (local.ip || local.address)) {
            // Spec
            this.localAddress = local.ip || local.address
            this.localPort = Number(local.port)
          } else if (local && local.ipAddress) {
            // Firefox
            this.localAddress = local.ipAddress
            this.localPort = Number(local.portNumber)
          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {
            // TODO: remove this once Chrome 58 is released
            local = selectedCandidatePair.googLocalAddress.split(':')
            this.localAddress = local[0]
            this.localPort = Number(local[1])
          }
          if (this.localAddress) {
            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'
          }

          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]

          if (remote && (remote.ip || remote.address)) {
            // Spec
            this.remoteAddress = remote.ip || remote.address
            this.remotePort = Number(remote.port)
          } else if (remote && remote.ipAddress) {
            // Firefox
            this.remoteAddress = remote.ipAddress
            this.remotePort = Number(remote.portNumber)
          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {
            // TODO: remove this once Chrome 58 is released
            remote = selectedCandidatePair.googRemoteAddress.split(':')
            this.remoteAddress = remote[0]
            this.remotePort = Number(remote[1])
          }
          if (this.remoteAddress) {
            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'
          }

          this._debug(
            'connect local: %s:%s remote: %s:%s',
            this.localAddress,
            this.localPort,
            this.remoteAddress,
            this.remotePort
          )
        }

        items.forEach(item => {
          // Spec-compliant
          if (item.type === 'transport' && item.selectedCandidatePairId) {
            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])
          }

          // Old implementations
          if (
            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||
            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)
          ) {
            setSelectedCandidatePair(item)
          }
        })

        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates
        // But wait until at least 1 candidate pair is available
        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
          setTimeout(findCandidatePair, 100)
          return
        } else {
          this._connecting = false
          this._connected = true
        }

        if (this._chunk) {
          try {
            this.send(this._chunk)
          } catch (err) {
            return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
          }
          this._chunk = null
          this._debug('sent chunk from "write before connect"')

          const cb = this._cb
          this._cb = null
          cb(null)
        }

        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,
        // fallback to using setInterval to implement backpressure.
        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {
          this._interval = setInterval(() => this._onInterval(), 150)
          if (this._interval.unref) this._interval.unref()
        }

        this._debug('connect')
        this.emit('connect')
      })
    }
    findCandidatePair()
  }

  _onInterval () {
    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      return
    }
    this._onChannelBufferedAmountLow()
  }

  _onSignalingStateChange () {
    if (this.destroyed) return

    if (this._pc.signalingState === 'stable') {
      this._isNegotiating = false

      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'
      this._debug('flushing sender queue', this._sendersAwaitingStable)
      this._sendersAwaitingStable.forEach(sender => {
        this._pc.removeTrack(sender)
        this._queuedNegotiation = true
      })
      this._sendersAwaitingStable = []

      if (this._queuedNegotiation) {
        this._debug('flushing negotiation queue')
        this._queuedNegotiation = false
        this._needsNegotiation() // negotiate again
      } else {
        this._debug('negotiated')
        this.emit('negotiated')
      }
    }

    this._debug('signalingStateChange %s', this._pc.signalingState)
    this.emit('signalingStateChange', this._pc.signalingState)
  }

  _onIceCandidate (event) {
    if (this.destroyed) return
    if (event.candidate && this.trickle) {
      this.emit('signal', {
        type: 'candidate',
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      })
    } else if (!event.candidate && !this._iceComplete) {
      this._iceComplete = true
      this.emit('_iceComplete')
    }
    // as soon as we've received one valid candidate start timeout
    if (event.candidate) {
      this._startIceCompleteTimeout()
    }
  }

  _onChannelMessage (event) {
    if (this.destroyed) return
    let data = event.data
    if (data instanceof ArrayBuffer) data = Buffer.from(data)
    this.push(data)
  }

  _onChannelBufferedAmountLow () {
    if (this.destroyed || !this._cb) return
    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)
    const cb = this._cb
    this._cb = null
    cb(null)
  }

  _onChannelOpen () {
    if (this._connected || this.destroyed) return
    this._debug('on channel open')
    this._channelReady = true
    this._maybeReady()
  }

  _onChannelClose () {
    if (this.destroyed) return
    this._debug('on channel close')
    this.destroy()
  }

  _onTrack (event) {
    if (this.destroyed) return

    event.streams.forEach(eventStream => {
      this._debug('on track')
      this.emit('track', event.track, eventStream)

      this._remoteTracks.push({
        track: event.track,
        stream: eventStream
      })

      if (this._remoteStreams.some(remoteStream => {
        return remoteStream.id === eventStream.id
      })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream

      this._remoteStreams.push(eventStream)
      queueMicrotask(() => {
        this._debug('on stream')
        this.emit('stream', eventStream) // ensure all tracks have been added
      })
    })
  }

  _debug () {
    const args = [].slice.call(arguments)
    args[0] = '[' + this._id + '] ' + args[0]
    debug.apply(null, args)
  }
}

Peer.WEBRTC_SUPPORT = !!getBrowserRTC()

/**
 * Expose peer and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config or opts.channelConfig
 * when constructing a Peer.
 */
Peer.config = {
  iceServers: [
    {
      urls: [
        'stun:stun.l.google.com:19302',
        'stun:global.stun.twilio.com:3478'
      ]
    }
  ],
  sdpSemantics: 'unified-plan'
}

Peer.channelConfig = {}

module.exports = Peer

},{"buffer":124,"debug":13,"err-code":17,"get-browser-rtc":19,"queue-microtask":32,"randombytes":33,"readable-stream":48}],72:[function(require,module,exports){
var engine = require('../src/store-engine')

var storages = require('../storages/all')
var plugins = [require('../plugins/json2')]

module.exports = engine.createStore(storages, plugins)

},{"../plugins/json2":73,"../src/store-engine":75,"../storages/all":77}],73:[function(require,module,exports){
module.exports = json2Plugin

function json2Plugin() {
	require('./lib/json2')
	return {}
}

},{"./lib/json2":74}],74:[function(require,module,exports){
/* eslint-disable */

//  json2.js
//  2016-10-28
//  Public Domain.
//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
//  See http://www.JSON.org/js.html
//  This code should be minified before deployment.
//  See http://javascript.crockford.com/jsmin.html

//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
//  NOT CONTROL.

//  This file creates a global JSON object containing two methods: stringify
//  and parse. This file provides the ES5 JSON capability to ES3 systems.
//  If a project might run on IE8 or earlier, then this file should be included.
//  This file does nothing on ES5 systems.

//      JSON.stringify(value, replacer, space)
//          value       any JavaScript value, usually an object or array.
//          replacer    an optional parameter that determines how object
//                      values are stringified for objects. It can be a
//                      function or an array of strings.
//          space       an optional parameter that specifies the indentation
//                      of nested structures. If it is omitted, the text will
//                      be packed without extra whitespace. If it is a number,
//                      it will specify the number of spaces to indent at each
//                      level. If it is a string (such as "\t" or "&nbsp;"),
//                      it contains the characters used to indent at each level.
//          This method produces a JSON text from a JavaScript value.
//          When an object value is found, if the object contains a toJSON
//          method, its toJSON method will be called and the result will be
//          stringified. A toJSON method does not serialize: it returns the
//          value represented by the name/value pair that should be serialized,
//          or undefined if nothing should be serialized. The toJSON method
//          will be passed the key associated with the value, and this will be
//          bound to the value.

//          For example, this would serialize Dates as ISO strings.

//              Date.prototype.toJSON = function (key) {
//                  function f(n) {
//                      // Format integers to have at least two digits.
//                      return (n < 10)
//                          ? "0" + n
//                          : n;
//                  }
//                  return this.getUTCFullYear()   + "-" +
//                       f(this.getUTCMonth() + 1) + "-" +
//                       f(this.getUTCDate())      + "T" +
//                       f(this.getUTCHours())     + ":" +
//                       f(this.getUTCMinutes())   + ":" +
//                       f(this.getUTCSeconds())   + "Z";
//              };

//          You can provide an optional replacer method. It will be passed the
//          key and value of each member, with this bound to the containing
//          object. The value that is returned from your method will be
//          serialized. If your method returns undefined, then the member will
//          be excluded from the serialization.

//          If the replacer parameter is an array of strings, then it will be
//          used to select the members to be serialized. It filters the results
//          such that only members with keys listed in the replacer array are
//          stringified.

//          Values that do not have JSON representations, such as undefined or
//          functions, will not be serialized. Such values in objects will be
//          dropped; in arrays they will be replaced with null. You can use
//          a replacer function to replace those with JSON values.

//          JSON.stringify(undefined) returns undefined.

//          The optional space parameter produces a stringification of the
//          value that is filled with line breaks and indentation to make it
//          easier to read.

//          If the space parameter is a non-empty string, then that string will
//          be used for indentation. If the space parameter is a number, then
//          the indentation will be that many spaces.

//          Example:

//          text = JSON.stringify(["e", {pluribus: "unum"}]);
//          // text is '["e",{"pluribus":"unum"}]'

//          text = JSON.stringify(["e", {pluribus: "unum"}], null, "\t");
//          // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

//          text = JSON.stringify([new Date()], function (key, value) {
//              return this[key] instanceof Date
//                  ? "Date(" + this[key] + ")"
//                  : value;
//          });
//          // text is '["Date(---current time---)"]'

//      JSON.parse(text, reviver)
//          This method parses a JSON text to produce an object or array.
//          It can throw a SyntaxError exception.

//          The optional reviver parameter is a function that can filter and
//          transform the results. It receives each of the keys and values,
//          and its return value is used instead of the original value.
//          If it returns what it received, then the structure is not modified.
//          If it returns undefined then the member is deleted.

//          Example:

//          // Parse the text. Values that look like ISO date strings will
//          // be converted to Date objects.

//          myData = JSON.parse(text, function (key, value) {
//              var a;
//              if (typeof value === "string") {
//                  a =
//   /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
//                  if (a) {
//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
//                          +a[5], +a[6]));
//                  }
//              }
//              return value;
//          });

//          myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
//              var d;
//              if (typeof value === "string" &&
//                      value.slice(0, 5) === "Date(" &&
//                      value.slice(-1) === ")") {
//                  d = new Date(value.slice(5, -1));
//                  if (d) {
//                      return d;
//                  }
//              }
//              return value;
//          });

//  This is a reference implementation. You are free to copy, modify, or
//  redistribute.

/*jslint
    eval, for, this
*/

/*property
    JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== "object") {
    JSON = {};
}

(function () {
    "use strict";

    var rx_one = /^[\],:{}\s]*$/;
    var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
    var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
    var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10
            ? "0" + n
            : n;
    }

    function this_value() {
        return this.valueOf();
    }

    if (typeof Date.prototype.toJSON !== "function") {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear() + "-" +
                        f(this.getUTCMonth() + 1) + "-" +
                        f(this.getUTCDate()) + "T" +
                        f(this.getUTCHours()) + ":" +
                        f(this.getUTCMinutes()) + ":" +
                        f(this.getUTCSeconds()) + "Z"
                : null;
        };

        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
    }

    var gap;
    var indent;
    var meta;
    var rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string)
            ? "\"" + string.replace(rx_escapable, function (a) {
                var c = meta[a];
                return typeof c === "string"
                    ? c
                    : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }) + "\""
            : "\"" + string + "\"";
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i;          // The loop counter.
        var k;          // The member key.
        var v;          // The member value.
        var length;
        var mind = gap;
        var partial;
        var value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === "object" &&
                typeof value.toJSON === "function") {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === "function") {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case "string":
            return quote(value);

        case "number":

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value)
                ? String(value)
                : "null";

        case "boolean":
        case "null":

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce "null". The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is "object", we might be dealing with an object or an array or
// null.

        case "object":

// Due to a specification blunder in ECMAScript, typeof null is "object",
// so watch out for that case.

            if (!value) {
                return "null";
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === "[object Array]") {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || "null";
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? "[]"
                    : gap
                        ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
                        : "[" + partial.join(",") + "]";
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === "object") {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === "string") {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? "{}"
                : gap
                    ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                    : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== "function") {
        meta = {    // table of character substitutions
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\"": "\\\"",
            "\\": "\\\\"
        };
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = "";
            indent = "";

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === "number") {
                for (i = 0; i < space; i += 1) {
                    indent += " ";
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === "string") {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== "function" &&
                    (typeof replacer !== "object" ||
                    typeof replacer.length !== "number")) {
                throw new Error("JSON.stringify");
            }

// Make a fake root object containing our value under the key of "".
// Return the result of stringifying the value.

            return str("", {"": value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== "function") {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k;
                var v;
                var value = holder[key];
                if (value && typeof value === "object") {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return "\\u" +
                            ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with "()" and "new"
// because they can cause invocation, and "=" because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with "@" (a non-JSON character). Second, we
// replace all simple value tokens with "]" characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or "]" or
// "," or ":" or "{" or "}". If that is so, then the text is safe for eval.

            if (
                rx_one.test(
                    text
                        .replace(rx_two, "@")
                        .replace(rx_three, "]")
                        .replace(rx_four, "")
                )
            ) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The "{" operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval("(" + text + ")");

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return (typeof reviver === "function")
                    ? walk({"": j}, "")
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError("JSON.parse");
        };
    }
}());
},{}],75:[function(require,module,exports){
var util = require('./util')
var slice = util.slice
var pluck = util.pluck
var each = util.each
var bind = util.bind
var create = util.create
var isList = util.isList
var isFunction = util.isFunction
var isObject = util.isObject

module.exports = {
	createStore: createStore
}

var storeAPI = {
	version: '2.0.12',
	enabled: false,
	
	// get returns the value of the given key. If that value
	// is undefined, it returns optionalDefaultValue instead.
	get: function(key, optionalDefaultValue) {
		var data = this.storage.read(this._namespacePrefix + key)
		return this._deserialize(data, optionalDefaultValue)
	},

	// set will store the given value at key and returns value.
	// Calling set with value === undefined is equivalent to calling remove.
	set: function(key, value) {
		if (value === undefined) {
			return this.remove(key)
		}
		this.storage.write(this._namespacePrefix + key, this._serialize(value))
		return value
	},

	// remove deletes the key and value stored at the given key.
	remove: function(key) {
		this.storage.remove(this._namespacePrefix + key)
	},

	// each will call the given callback once for each key-value pair
	// in this store.
	each: function(callback) {
		var self = this
		this.storage.each(function(val, namespacedKey) {
			callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''))
		})
	},

	// clearAll will remove all the stored key-value pairs in this store.
	clearAll: function() {
		this.storage.clearAll()
	},

	// additional functionality that can't live in plugins
	// ---------------------------------------------------

	// hasNamespace returns true if this store instance has the given namespace.
	hasNamespace: function(namespace) {
		return (this._namespacePrefix == '__storejs_'+namespace+'_')
	},

	// createStore creates a store.js instance with the first
	// functioning storage in the list of storage candidates,
	// and applies the the given mixins to the instance.
	createStore: function() {
		return createStore.apply(this, arguments)
	},
	
	addPlugin: function(plugin) {
		this._addPlugin(plugin)
	},
	
	namespace: function(namespace) {
		return createStore(this.storage, this.plugins, namespace)
	}
}

function _warn() {
	var _console = (typeof console == 'undefined' ? null : console)
	if (!_console) { return }
	var fn = (_console.warn ? _console.warn : _console.log)
	fn.apply(_console, arguments)
}

function createStore(storages, plugins, namespace) {
	if (!namespace) {
		namespace = ''
	}
	if (storages && !isList(storages)) {
		storages = [storages]
	}
	if (plugins && !isList(plugins)) {
		plugins = [plugins]
	}

	var namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '')
	var namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null)
	var legalNamespaces = /^[a-zA-Z0-9_\-]*$/ // alpha-numeric + underscore and dash
	if (!legalNamespaces.test(namespace)) {
		throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes')
	}
	
	var _privateStoreProps = {
		_namespacePrefix: namespacePrefix,
		_namespaceRegexp: namespaceRegexp,

		_testStorage: function(storage) {
			try {
				var testStr = '__storejs__test__'
				storage.write(testStr, testStr)
				var ok = (storage.read(testStr) === testStr)
				storage.remove(testStr)
				return ok
			} catch(e) {
				return false
			}
		},

		_assignPluginFnProp: function(pluginFnProp, propName) {
			var oldFn = this[propName]
			this[propName] = function pluginFn() {
				var args = slice(arguments, 0)
				var self = this

				// super_fn calls the old function which was overwritten by
				// this mixin.
				function super_fn() {
					if (!oldFn) { return }
					each(arguments, function(arg, i) {
						args[i] = arg
					})
					return oldFn.apply(self, args)
				}

				// Give mixing function access to super_fn by prefixing all mixin function
				// arguments with super_fn.
				var newFnArgs = [super_fn].concat(args)

				return pluginFnProp.apply(self, newFnArgs)
			}
		},

		_serialize: function(obj) {
			return JSON.stringify(obj)
		},

		_deserialize: function(strVal, defaultVal) {
			if (!strVal) { return defaultVal }
			// It is possible that a raw string value has been previously stored
			// in a storage without using store.js, meaning it will be a raw
			// string value instead of a JSON serialized string. By defaulting
			// to the raw string value in case of a JSON parse error, we allow
			// for past stored values to be forwards-compatible with store.js
			var val = ''
			try { val = JSON.parse(strVal) }
			catch(e) { val = strVal }

			return (val !== undefined ? val : defaultVal)
		},
		
		_addStorage: function(storage) {
			if (this.enabled) { return }
			if (this._testStorage(storage)) {
				this.storage = storage
				this.enabled = true
			}
		},

		_addPlugin: function(plugin) {
			var self = this

			// If the plugin is an array, then add all plugins in the array.
			// This allows for a plugin to depend on other plugins.
			if (isList(plugin)) {
				each(plugin, function(plugin) {
					self._addPlugin(plugin)
				})
				return
			}

			// Keep track of all plugins we've seen so far, so that we
			// don't add any of them twice.
			var seenPlugin = pluck(this.plugins, function(seenPlugin) {
				return (plugin === seenPlugin)
			})
			if (seenPlugin) {
				return
			}
			this.plugins.push(plugin)

			// Check that the plugin is properly formed
			if (!isFunction(plugin)) {
				throw new Error('Plugins must be function values that return objects')
			}

			var pluginProperties = plugin.call(this)
			if (!isObject(pluginProperties)) {
				throw new Error('Plugins must return an object of function properties')
			}

			// Add the plugin function properties to this store instance.
			each(pluginProperties, function(pluginFnProp, propName) {
				if (!isFunction(pluginFnProp)) {
					throw new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')
				}
				self._assignPluginFnProp(pluginFnProp, propName)
			})
		},
		
		// Put deprecated properties in the private API, so as to not expose it to accidential
		// discovery through inspection of the store object.
		
		// Deprecated: addStorage
		addStorage: function(storage) {
			_warn('store.addStorage(storage) is deprecated. Use createStore([storages])')
			this._addStorage(storage)
		}
	}

	var store = create(_privateStoreProps, storeAPI, {
		plugins: []
	})
	store.raw = {}
	each(store, function(prop, propName) {
		if (isFunction(prop)) {
			store.raw[propName] = bind(store, prop)			
		}
	})
	each(storages, function(storage) {
		store._addStorage(storage)
	})
	each(plugins, function(plugin) {
		store._addPlugin(plugin)
	})
	return store
}

},{"./util":76}],76:[function(require,module,exports){
(function (global){(function (){
var assign = make_assign()
var create = make_create()
var trim = make_trim()
var Global = (typeof window !== 'undefined' ? window : global)

module.exports = {
	assign: assign,
	create: create,
	trim: trim,
	bind: bind,
	slice: slice,
	each: each,
	map: map,
	pluck: pluck,
	isList: isList,
	isFunction: isFunction,
	isObject: isObject,
	Global: Global
}

function make_assign() {
	if (Object.assign) {
		return Object.assign
	} else {
		return function shimAssign(obj, props1, props2, etc) {
			for (var i = 1; i < arguments.length; i++) {
				each(Object(arguments[i]), function(val, key) {
					obj[key] = val
				})
			}			
			return obj
		}
	}
}

function make_create() {
	if (Object.create) {
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1)
			return assign.apply(this, [Object.create(obj)].concat(assignArgsList))
		}
	} else {
		function F() {} // eslint-disable-line no-inner-declarations
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1)
			F.prototype = obj
			return assign.apply(this, [new F()].concat(assignArgsList))
		}
	}
}

function make_trim() {
	if (String.prototype.trim) {
		return function trim(str) {
			return String.prototype.trim.call(str)
		}
	} else {
		return function trim(str) {
			return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
		}
	}
}

function bind(obj, fn) {
	return function() {
		return fn.apply(obj, Array.prototype.slice.call(arguments, 0))
	}
}

function slice(arr, index) {
	return Array.prototype.slice.call(arr, index || 0)
}

function each(obj, fn) {
	pluck(obj, function(val, key) {
		fn(val, key)
		return false
	})
}

function map(obj, fn) {
	var res = (isList(obj) ? [] : {})
	pluck(obj, function(v, k) {
		res[k] = fn(v, k)
		return false
	})
	return res
}

function pluck(obj, fn) {
	if (isList(obj)) {
		for (var i=0; i<obj.length; i++) {
			if (fn(obj[i], i)) {
				return obj[i]
			}
		}
	} else {
		for (var key in obj) {
			if (obj.hasOwnProperty(key)) {
				if (fn(obj[key], key)) {
					return obj[key]
				}
			}
		}
	}
}

function isList(val) {
	return (val != null && typeof val != 'function' && typeof val.length == 'number')
}

function isFunction(val) {
	return val && {}.toString.call(val) === '[object Function]'
}

function isObject(val) {
	return val && {}.toString.call(val) === '[object Object]'
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],77:[function(require,module,exports){
module.exports = [
	// Listed in order of usage preference
	require('./localStorage'),
	require('./oldFF-globalStorage'),
	require('./oldIE-userDataStorage'),
	require('./cookieStorage'),
	require('./sessionStorage'),
	require('./memoryStorage')
]

},{"./cookieStorage":78,"./localStorage":79,"./memoryStorage":80,"./oldFF-globalStorage":81,"./oldIE-userDataStorage":82,"./sessionStorage":83}],78:[function(require,module,exports){
// cookieStorage is useful Safari private browser mode, where localStorage
// doesn't work but cookies do. This implementation is adopted from
// https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage

var util = require('../src/util')
var Global = util.Global
var trim = util.trim

module.exports = {
	name: 'cookieStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var doc = Global.document

function read(key) {
	if (!key || !_has(key)) { return null }
	var regexpStr = "(?:^|.*;\\s*)" +
		escape(key).replace(/[\-\.\+\*]/g, "\\$&") +
		"\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"
	return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"))
}

function each(callback) {
	var cookies = doc.cookie.split(/; ?/g)
	for (var i = cookies.length - 1; i >= 0; i--) {
		if (!trim(cookies[i])) {
			continue
		}
		var kvp = cookies[i].split('=')
		var key = unescape(kvp[0])
		var val = unescape(kvp[1])
		callback(val, key)
	}
}

function write(key, data) {
	if(!key) { return }
	doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/"
}

function remove(key) {
	if (!key || !_has(key)) {
		return
	}
	doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/"
}

function clearAll() {
	each(function(_, key) {
		remove(key)
	})
}

function _has(key) {
	return (new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(doc.cookie)
}

},{"../src/util":76}],79:[function(require,module,exports){
var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'localStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

function localStorage() {
	return Global.localStorage
}

function read(key) {
	return localStorage().getItem(key)
}

function write(key, data) {
	return localStorage().setItem(key, data)
}

function each(fn) {
	for (var i = localStorage().length - 1; i >= 0; i--) {
		var key = localStorage().key(i)
		fn(read(key), key)
	}
}

function remove(key) {
	return localStorage().removeItem(key)
}

function clearAll() {
	return localStorage().clear()
}

},{"../src/util":76}],80:[function(require,module,exports){
// memoryStorage is a useful last fallback to ensure that the store
// is functions (meaning store.get(), store.set(), etc will all function).
// However, stored values will not persist when the browser navigates to
// a new page or reloads the current page.

module.exports = {
	name: 'memoryStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var memoryStorage = {}

function read(key) {
	return memoryStorage[key]
}

function write(key, data) {
	memoryStorage[key] = data
}

function each(callback) {
	for (var key in memoryStorage) {
		if (memoryStorage.hasOwnProperty(key)) {
			callback(memoryStorage[key], key)
		}
	}
}

function remove(key) {
	delete memoryStorage[key]
}

function clearAll(key) {
	memoryStorage = {}
}

},{}],81:[function(require,module,exports){
// oldFF-globalStorage provides storage for Firefox
// versions 6 and 7, where no localStorage, etc
// is available.

var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'oldFF-globalStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var globalStorage = Global.globalStorage

function read(key) {
	return globalStorage[key]
}

function write(key, data) {
	globalStorage[key] = data
}

function each(fn) {
	for (var i = globalStorage.length - 1; i >= 0; i--) {
		var key = globalStorage.key(i)
		fn(globalStorage[key], key)
	}
}

function remove(key) {
	return globalStorage.removeItem(key)
}

function clearAll() {
	each(function(key, _) {
		delete globalStorage[key]
	})
}

},{"../src/util":76}],82:[function(require,module,exports){
// oldIE-userDataStorage provides storage for Internet Explorer
// versions 6 and 7, where no localStorage, sessionStorage, etc
// is available.

var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'oldIE-userDataStorage',
	write: write,
	read: read,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var storageName = 'storejs'
var doc = Global.document
var _withStorageEl = _makeIEStorageElFunction()
var disable = (Global.navigator ? Global.navigator.userAgent : '').match(/ (MSIE 8|MSIE 9|MSIE 10)\./) // MSIE 9.x, MSIE 10.x

function write(unfixedKey, data) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey)
	_withStorageEl(function(storageEl) {
		storageEl.setAttribute(fixedKey, data)
		storageEl.save(storageName)
	})
}

function read(unfixedKey) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey)
	var res = null
	_withStorageEl(function(storageEl) {
		res = storageEl.getAttribute(fixedKey)
	})
	return res
}

function each(callback) {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes
		for (var i=attributes.length-1; i>=0; i--) {
			var attr = attributes[i]
			callback(storageEl.getAttribute(attr.name), attr.name)
		}
	})
}

function remove(unfixedKey) {
	var fixedKey = fixKey(unfixedKey)
	_withStorageEl(function(storageEl) {
		storageEl.removeAttribute(fixedKey)
		storageEl.save(storageName)
	})
}

function clearAll() {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes
		storageEl.load(storageName)
		for (var i=attributes.length-1; i>=0; i--) {
			storageEl.removeAttribute(attributes[i].name)
		}
		storageEl.save(storageName)
	})
}

// Helpers
//////////

// In IE7, keys cannot start with a digit or contain certain chars.
// See https://github.com/marcuswestin/store.js/issues/40
// See https://github.com/marcuswestin/store.js/issues/83
var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g")
function fixKey(key) {
	return key.replace(/^\d/, '___$&').replace(forbiddenCharsRegex, '___')
}

function _makeIEStorageElFunction() {
	if (!doc || !doc.documentElement || !doc.documentElement.addBehavior) {
		return null
	}
	var scriptTag = 'script',
		storageOwner,
		storageContainer,
		storageEl

	// Since #userData storage applies only to specific paths, we need to
	// somehow link our data to a specific path.  We choose /favicon.ico
	// as a pretty safe option, since all browsers already make a request to
	// this URL anyway and being a 404 will not hurt us here.  We wrap an
	// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
	// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
	// since the iframe access rules appear to allow direct access and
	// manipulation of the document element, even for a 404 page.  This
	// document can be used instead of the current document (which would
	// have been limited to the current path) to perform #userData storage.
	try {
		/* global ActiveXObject */
		storageContainer = new ActiveXObject('htmlfile')
		storageContainer.open()
		storageContainer.write('<'+scriptTag+'>document.w=window</'+scriptTag+'><iframe src="/favicon.ico"></iframe>')
		storageContainer.close()
		storageOwner = storageContainer.w.frames[0].document
		storageEl = storageOwner.createElement('div')
	} catch(e) {
		// somehow ActiveXObject instantiation failed (perhaps some special
		// security settings or otherwse), fall back to per-path storage
		storageEl = doc.createElement('div')
		storageOwner = doc.body
	}

	return function(storeFunction) {
		var args = [].slice.call(arguments, 0)
		args.unshift(storageEl)
		// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
		// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
		storageOwner.appendChild(storageEl)
		storageEl.addBehavior('#default#userData')
		storageEl.load(storageName)
		storeFunction.apply(this, args)
		storageOwner.removeChild(storageEl)
		return
	}
}

},{"../src/util":76}],83:[function(require,module,exports){
var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'sessionStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll
}

function sessionStorage() {
	return Global.sessionStorage
}

function read(key) {
	return sessionStorage().getItem(key)
}

function write(key, data) {
	return sessionStorage().setItem(key, data)
}

function each(fn) {
	for (var i = sessionStorage().length - 1; i >= 0; i--) {
		var key = sessionStorage().key(i)
		fn(read(key), key)
	}
}

function remove(key) {
	return sessionStorage().removeItem(key)
}

function clearAll() {
	return sessionStorage().clear()
}

},{"../src/util":76}],84:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":50}],85:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":86,"./_stream_writable":88,"_process":143,"core-util-is":12,"inherits":24}],86:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;
  var ret;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    ret = null;

    // In cases where the decoder did not receive enough data
    // to produce a full chunk, then immediately received an
    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
    // howMuchToRead will see this and coerce the amount to
    // read to zero (because it's looking at the length of the
    // first <Buffer > in state.buffer), and we'll end up here.
    //
    // This can only happen via state.decoder -- no other venue
    // exists for pushing a zero-length chunk into state.buffer
    // and triggering this behavior. In this case, we return our
    // remaining data and end the stream, if appropriate.
    if (state.length > 0 && state.decoder) {
      ret = fromList(n, state);
      state.length -= ret.length;
    }

    if (state.length === 0)
      endReadable(this);

    return ret;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    //if (state.objectMode && util.isNullOrUndefined(chunk))
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this)}).call(this,require('_process'))

},{"_process":143,"buffer":124,"core-util-is":12,"events":128,"inherits":24,"isarray":89,"stream":148,"string_decoder/":90}],87:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":85,"core-util-is":12,"inherits":24}],88:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this)}).call(this,require('_process'))

},{"./_stream_duplex":85,"_process":143,"buffer":124,"core-util-is":12,"inherits":24,"stream":148}],89:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],90:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":124}],91:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":87}],92:[function(require,module,exports){
(function (process){(function (){
var Transform = require('readable-stream/transform')
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

},{"_process":143,"readable-stream/transform":91,"util":168,"xtend":119}],93:[function(require,module,exports){
var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":124}],94:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./nil.js":97,"./parse.js":98,"./stringify.js":102,"./v1.js":103,"./v3.js":104,"./v4.js":106,"./v5.js":107,"./validate.js":108,"./version.js":109}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
},{}],97:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
},{}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
},{"./validate.js":108}],99:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
},{}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
},{}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
},{}],102:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
},{"./validate.js":108}],103:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;
},{"./rng.js":100,"./stringify.js":102}],104:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
},{"./md5.js":96,"./v35.js":105}],105:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
},{"./parse.js":98,"./stringify.js":102}],106:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;
},{"./rng.js":100,"./stringify.js":102}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
},{"./sha1.js":101,"./v35.js":105}],108:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
},{"./regex.js":99}],109:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
},{"./validate.js":108}],110:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

// Shimming starts here.
(function() {
  // Utils.
  var logging = require('./utils').log;
  var browserDetails = require('./utils').browserDetails;
  // Export to the adapter global object visible in the browser.
  module.exports.browserDetails = browserDetails;
  module.exports.extractVersion = require('./utils').extractVersion;
  module.exports.disableLog = require('./utils').disableLog;

  // Uncomment the line below if you want logging to occur, including logging
  // for the switch statement below. Can also be turned on in the browser via
  // adapter.disableLog(false), but then logging from the switch statement below
  // will not appear.
  // require('./utils').disableLog(false);

  // Browser shims.
  var chromeShim = require('./chrome/chrome_shim') || null;
  var edgeShim = require('./edge/edge_shim') || null;
  var firefoxShim = require('./firefox/firefox_shim') || null;
  var safariShim = require('./safari/safari_shim') || null;

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'opera': // fallthrough as it uses chrome shims
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection) {
        logging('Chrome shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = chromeShim;

      chromeShim.shimGetUserMedia();
      chromeShim.shimMediaStream();
      chromeShim.shimSourceObject();
      chromeShim.shimPeerConnection();
      chromeShim.shimOnTrack();
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection) {
        logging('Firefox shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = firefoxShim;

      firefoxShim.shimGetUserMedia();
      firefoxShim.shimSourceObject();
      firefoxShim.shimPeerConnection();
      firefoxShim.shimOnTrack();
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection) {
        logging('MS edge shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = edgeShim;

      edgeShim.shimGetUserMedia();
      edgeShim.shimPeerConnection();
      break;
    case 'safari':
      if (!safariShim) {
        logging('Safari shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = safariShim;

      safariShim.shimGetUserMedia();
      break;
    default:
      logging('Unsupported browser!');
  }
})();

},{"./chrome/chrome_shim":111,"./edge/edge_shim":113,"./firefox/firefox_shim":115,"./safari/safari_shim":117,"./utils":118}],111:[function(require,module,exports){

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var logging = require('../utils.js').log;
var browserDetails = require('../utils.js').browserDetails;

var chromeShim = {
  shimMediaStream: function() {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  },

  shimOnTrack: function() {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          var self = this;
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function(te) {
              var event = new Event('track');
              event.track = te.track;
              event.receiver = {track: te.track};
              event.streams = [e.stream];
              self.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        }
      });
    }
  },

  shimSourceObject: function() {
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this._srcObject;
          },
          set: function(stream) {
            var self = this;
            // Use _srcObject as a private property for this shim
            this._srcObject = stream;
            if (this.src) {
              URL.revokeObjectURL(this.src);
            }

            if (!stream) {
              this.src = '';
              return;
            }
            this.src = URL.createObjectURL(stream);
            // We need to recreate the blob url when a track is added or
            // removed. Doing it manually since we want to avoid a recursion.
            stream.addEventListener('addtrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
            stream.addEventListener('removetrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
          }
        });
      }
    }
  },

  shimPeerConnection: function() {
    // The RTCPeerConnection object.
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      // Translate iceTransportPolicy to iceTransports,
      // see https://code.google.com/p/webrtc/issues/detail?id=4869
      logging('PeerConnection');
      if (pcConfig && pcConfig.iceTransportPolicy) {
        pcConfig.iceTransports = pcConfig.iceTransportPolicy;
      }

      var pc = new webkitRTCPeerConnection(pcConfig, pcConstraints);
      var origGetStats = pc.getStats.bind(pc);
      pc.getStats = function(selector, successCallback, errorCallback) {
        var self = this;
        var args = arguments;

        // If selector is a function then we are in the old style stats so just
        // pass back the original getStats format to avoid breaking old users.
        if (arguments.length > 0 && typeof selector === 'function') {
          return origGetStats(selector, successCallback);
        }

        var fixChromeStats_ = function(response) {
          var standardReport = {};
          var reports = response.result();
          reports.forEach(function(report) {
            var standardStats = {
              id: report.id,
              timestamp: report.timestamp,
              type: report.type
            };
            report.names().forEach(function(name) {
              standardStats[name] = report.stat(name);
            });
            standardReport[standardStats.id] = standardStats;
          });

          return standardReport;
        };

        // shim getStats with maplike support
        var makeMapStats = function(stats, legacyStats) {
          var map = new Map(Object.keys(stats).map(function(key) {
            return[key, stats[key]];
          }));
          legacyStats = legacyStats || stats;
          Object.keys(legacyStats).forEach(function(key) {
            map[key] = legacyStats[key];
          });
          return map;
        };

        if (arguments.length >= 2) {
          var successCallbackWrapper_ = function(response) {
            args[1](makeMapStats(fixChromeStats_(response)));
          };

          return origGetStats.apply(this, [successCallbackWrapper_,
              arguments[0]]);
        }

        // promise-support
        return new Promise(function(resolve, reject) {
          if (args.length === 1 && typeof selector === 'object') {
            origGetStats.apply(self, [
              function(response) {
                resolve(makeMapStats(fixChromeStats_(response)));
              }, reject]);
          } else {
            // Preserve legacy chrome stats only on legacy access of stats obj
            origGetStats.apply(self, [
              function(response) {
                resolve(makeMapStats(fixChromeStats_(response),
                    response.result()));
              }, reject]);
          }
        }).then(successCallback, errorCallback);
      };

      return pc;
    };
    window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype;

    // wrap static methods. Currently just generateCertificate.
    if (webkitRTCPeerConnection.generateCertificate) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return webkitRTCPeerConnection.generateCertificate;
        }
      });
    }

    ['createOffer', 'createAnswer'].forEach(function(method) {
      var nativeMethod = webkitRTCPeerConnection.prototype[method];
      webkitRTCPeerConnection.prototype[method] = function() {
        var self = this;
        if (arguments.length < 1 || (arguments.length === 1 &&
            typeof arguments[0] === 'object')) {
          var opts = arguments.length === 1 ? arguments[0] : undefined;
          return new Promise(function(resolve, reject) {
            nativeMethod.apply(self, [resolve, reject, opts]);
          });
        }
        return nativeMethod.apply(this, arguments);
      };
    });

    // add promise support -- natively available in Chrome 51
    if (browserDetails.version < 51) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
          .forEach(function(method) {
            var nativeMethod = webkitRTCPeerConnection.prototype[method];
            webkitRTCPeerConnection.prototype[method] = function() {
              var args = arguments;
              var self = this;
              var promise = new Promise(function(resolve, reject) {
                nativeMethod.apply(self, [args[0], resolve, reject]);
              });
              if (args.length < 2) {
                return promise;
              }
              return promise.then(function() {
                args[1].apply(null, []);
              },
              function(err) {
                if (args.length >= 3) {
                  args[2].apply(null, [err]);
                }
              });
            };
          });
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = webkitRTCPeerConnection.prototype[method];
          webkitRTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                RTCIceCandidate : RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        RTCPeerConnection.prototype.addIceCandidate;
    RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }
};


// Expose public methods.
module.exports = {
  shimMediaStream: chromeShim.shimMediaStream,
  shimOnTrack: chromeShim.shimOnTrack,
  shimSourceObject: chromeShim.shimSourceObject,
  shimPeerConnection: chromeShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils.js":118,"./getusermedia":112}],112:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var logging = require('../utils.js').log;

// Expose public methods.
module.exports = function() {
  var constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function(mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function(constraints, func) {
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && constraints.audio) {
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile, where it defaults to "user".
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode)) {
        delete constraints.video.facingMode;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          // Look for "back" in label, or use last cam (typically back cam).
          return navigator.mediaDevices.enumerateDevices()
          .then(function(devices) {
            devices = devices.filter(function(d) {
              return d.kind === 'videoinput';
            });
            var back = devices.find(function(d) {
              return d.label.toLowerCase().indexOf('back') !== -1;
            }) || (devices.length && devices[devices.length - 1]);
            if (back) {
              constraints.video.deviceId = face.exact ? {exact: back.deviceId} :
                                                        {ideal: back.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function(e) {
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        ConstraintNotSatisfiedError: 'OverconstrainedError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraintName,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function(c) {
      navigator.webkitGetUserMedia(c, onSuccess, function(e) {
        onError(shimError_(e));
      });
    });
  };

  navigator.getUserMedia = getUserMedia_;

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      navigator.getUserMedia(constraints, resolve, reject);
    });
  };

  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {
      getUserMedia: getUserMediaPromise_,
      enumerateDevices: function() {
        return new Promise(function(resolve) {
          var kinds = {audio: 'audioinput', video: 'videoinput'};
          return MediaStreamTrack.getSources(function(devices) {
            resolve(devices.map(function(device) {
              return {label: device.label,
                      kind: kinds[device.kind],
                      deviceId: device.id,
                      groupId: ''};
            }));
          });
        });
      }
    };
  }

  // A shim for getUserMedia method on the mediaDevices object.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (!navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      return getUserMediaPromise_(constraints);
    };
  } else {
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, function(c) {
        return origGetUserMedia(c).then(function(stream) {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function(e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }

  // Dummy devicechange event methods.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
    navigator.mediaDevices.addEventListener = function() {
      logging('Dummy mediaDevices.addEventListener called.');
    };
  }
  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
    navigator.mediaDevices.removeEventListener = function() {
      logging('Dummy mediaDevices.removeEventListener called.');
    };
  }
};

},{"../utils.js":118}],113:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');
var browserDetails = require('../utils').browserDetails;

var edgeShim = {
  shimPeerConnection: function() {
    if (window.RTCIceGatherer) {
      // ORTC defines an RTCIceCandidate object but no constructor.
      // Not implemented in Edge.
      if (!window.RTCIceCandidate) {
        window.RTCIceCandidate = function(args) {
          return args;
        };
      }
      // ORTC does not have a session description object but
      // other browsers (i.e. Chrome) that will support both PC and ORTC
      // in the future might have this defined already.
      if (!window.RTCSessionDescription) {
        window.RTCSessionDescription = function(args) {
          return args;
        };
      }
      // this adds an additional event listener to MediaStrackTrack that signals
      // when a tracks enabled property was changed.
      var origMSTEnabled = Object.getOwnPropertyDescriptor(
          MediaStreamTrack.prototype, 'enabled');
      Object.defineProperty(MediaStreamTrack.prototype, 'enabled', {
        set: function(value) {
          origMSTEnabled.set.call(this, value);
          var ev = new Event('enabled');
          ev.enabled = value;
          this.dispatchEvent(ev);
        }
      });
    }

    window.RTCPeerConnection = function(config) {
      var self = this;

      var _eventTarget = document.createDocumentFragment();
      ['addEventListener', 'removeEventListener', 'dispatchEvent']
          .forEach(function(method) {
            self[method] = _eventTarget[method].bind(_eventTarget);
          });

      this.onicecandidate = null;
      this.onaddstream = null;
      this.ontrack = null;
      this.onremovestream = null;
      this.onsignalingstatechange = null;
      this.oniceconnectionstatechange = null;
      this.onnegotiationneeded = null;
      this.ondatachannel = null;

      this.localStreams = [];
      this.remoteStreams = [];
      this.getLocalStreams = function() {
        return self.localStreams;
      };
      this.getRemoteStreams = function() {
        return self.remoteStreams;
      };

      this.localDescription = new RTCSessionDescription({
        type: '',
        sdp: ''
      });
      this.remoteDescription = new RTCSessionDescription({
        type: '',
        sdp: ''
      });
      this.signalingState = 'stable';
      this.iceConnectionState = 'new';
      this.iceGatheringState = 'new';

      this.iceOptions = {
        gatherPolicy: 'all',
        iceServers: []
      };
      if (config && config.iceTransportPolicy) {
        switch (config.iceTransportPolicy) {
          case 'all':
          case 'relay':
            this.iceOptions.gatherPolicy = config.iceTransportPolicy;
            break;
          case 'none':
            // FIXME: remove once implementation and spec have added this.
            throw new TypeError('iceTransportPolicy "none" not supported');
          default:
            // don't set iceTransportPolicy.
            break;
        }
      }
      this.usingBundle = config && config.bundlePolicy === 'max-bundle';

      if (config && config.iceServers) {
        // Edge does not like
        // 1) stun:
        // 2) turn: that does not have all of turn:host:port?transport=udp
        // 3) turn: with ipv6 addresses
        var iceServers = JSON.parse(JSON.stringify(config.iceServers));
        this.iceOptions.iceServers = iceServers.filter(function(server) {
          if (server && server.urls) {
            var urls = server.urls;
            if (typeof urls === 'string') {
              urls = [urls];
            }
            urls = urls.filter(function(url) {
              return (url.indexOf('turn:') === 0 &&
                  url.indexOf('transport=udp') !== -1 &&
                  url.indexOf('turn:[') === -1) ||
                  (url.indexOf('stun:') === 0 &&
                    browserDetails.version >= 14393);
            })[0];
            return !!urls;
          }
          return false;
        });
      }
      this._config = config;

      // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
      // everything that is needed to describe a SDP m-line.
      this.transceivers = [];

      // since the iceGatherer is currently created in createOffer but we
      // must not emit candidates until after setLocalDescription we buffer
      // them in this array.
      this._localIceCandidatesBuffer = [];
    };

    window.RTCPeerConnection.prototype._emitBufferedCandidates = function() {
      var self = this;
      var sections = SDPUtils.splitSections(self.localDescription.sdp);
      // FIXME: need to apply ice candidates in a way which is async but
      // in-order
      this._localIceCandidatesBuffer.forEach(function(event) {
        var end = !event.candidate || Object.keys(event.candidate).length === 0;
        if (end) {
          for (var j = 1; j < sections.length; j++) {
            if (sections[j].indexOf('\r\na=end-of-candidates\r\n') === -1) {
              sections[j] += 'a=end-of-candidates\r\n';
            }
          }
        } else if (event.candidate.candidate.indexOf('typ endOfCandidates')
            === -1) {
          sections[event.candidate.sdpMLineIndex + 1] +=
              'a=' + event.candidate.candidate + '\r\n';
        }
        self.localDescription.sdp = sections.join('');
        self.dispatchEvent(event);
        if (self.onicecandidate !== null) {
          self.onicecandidate(event);
        }
        if (!event.candidate && self.iceGatheringState !== 'complete') {
          var complete = self.transceivers.every(function(transceiver) {
            return transceiver.iceGatherer &&
                transceiver.iceGatherer.state === 'completed';
          });
          if (complete) {
            self.iceGatheringState = 'complete';
          }
        }
      });
      this._localIceCandidatesBuffer = [];
    };

    window.RTCPeerConnection.prototype.getConfiguration = function() {
      return this._config;
    };

    window.RTCPeerConnection.prototype.addStream = function(stream) {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      this.localStreams.push(clonedStream);
      this._maybeFireNegotiationNeeded();
    };

    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var idx = this.localStreams.indexOf(stream);
      if (idx > -1) {
        this.localStreams.splice(idx, 1);
        this._maybeFireNegotiationNeeded();
      }
    };

    window.RTCPeerConnection.prototype.getSenders = function() {
      return this.transceivers.filter(function(transceiver) {
        return !!transceiver.rtpSender;
      })
      .map(function(transceiver) {
        return transceiver.rtpSender;
      });
    };

    window.RTCPeerConnection.prototype.getReceivers = function() {
      return this.transceivers.filter(function(transceiver) {
        return !!transceiver.rtpReceiver;
      })
      .map(function(transceiver) {
        return transceiver.rtpReceiver;
      });
    };

    // Determines the intersection of local and remote capabilities.
    window.RTCPeerConnection.prototype._getCommonCapabilities =
        function(localCapabilities, remoteCapabilities) {
          var commonCapabilities = {
            codecs: [],
            headerExtensions: [],
            fecMechanisms: []
          };
          localCapabilities.codecs.forEach(function(lCodec) {
            for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
              var rCodec = remoteCapabilities.codecs[i];
              if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
                  lCodec.clockRate === rCodec.clockRate) {
                // number of channels is the highest common number of channels
                rCodec.numChannels = Math.min(lCodec.numChannels,
                    rCodec.numChannels);
                // push rCodec so we reply with offerer payload type
                commonCapabilities.codecs.push(rCodec);

                // determine common feedback mechanisms
                rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
                  for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
                    if (lCodec.rtcpFeedback[j].type === fb.type &&
                        lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                      return true;
                    }
                  }
                  return false;
                });
                // FIXME: also need to determine .parameters
                //  see https://github.com/openpeer/ortc/issues/569
                break;
              }
            }
          });

          localCapabilities.headerExtensions
              .forEach(function(lHeaderExtension) {
                for (var i = 0; i < remoteCapabilities.headerExtensions.length;
                     i++) {
                  var rHeaderExtension = remoteCapabilities.headerExtensions[i];
                  if (lHeaderExtension.uri === rHeaderExtension.uri) {
                    commonCapabilities.headerExtensions.push(rHeaderExtension);
                    break;
                  }
                }
              });

          // FIXME: fecMechanisms
          return commonCapabilities;
        };

    // Create ICE gatherer, ICE transport and DTLS transport.
    window.RTCPeerConnection.prototype._createIceAndDtlsTransports =
        function(mid, sdpMLineIndex) {
          var self = this;
          var iceGatherer = new RTCIceGatherer(self.iceOptions);
          var iceTransport = new RTCIceTransport(iceGatherer);
          iceGatherer.onlocalcandidate = function(evt) {
            var event = new Event('icecandidate');
            event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

            var cand = evt.candidate;
            var end = !cand || Object.keys(cand).length === 0;
            // Edge emits an empty object for RTCIceCandidateComplete
            if (end) {
              // polyfill since RTCIceGatherer.state is not implemented in
              // Edge 10547 yet.
              if (iceGatherer.state === undefined) {
                iceGatherer.state = 'completed';
              }

              // Emit a candidate with type endOfCandidates to make the samples
              // work. Edge requires addIceCandidate with this empty candidate
              // to start checking. The real solution is to signal
              // end-of-candidates to the other side when getting the null
              // candidate but some apps (like the samples) don't do that.
              event.candidate.candidate =
                  'candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates';
            } else {
              // RTCIceCandidate doesn't have a component, needs to be added
              cand.component = iceTransport.component === 'RTCP' ? 2 : 1;
              event.candidate.candidate = SDPUtils.writeCandidate(cand);
            }

            // update local description.
            var sections = SDPUtils.splitSections(self.localDescription.sdp);
            if (event.candidate.candidate.indexOf('typ endOfCandidates')
                === -1) {
              sections[event.candidate.sdpMLineIndex + 1] +=
                  'a=' + event.candidate.candidate + '\r\n';
            } else {
              sections[event.candidate.sdpMLineIndex + 1] +=
                  'a=end-of-candidates\r\n';
            }
            self.localDescription.sdp = sections.join('');

            var complete = self.transceivers.every(function(transceiver) {
              return transceiver.iceGatherer &&
                  transceiver.iceGatherer.state === 'completed';
            });

            // Emit candidate if localDescription is set.
            // Also emits null candidate when all gatherers are complete.
            switch (self.iceGatheringState) {
              case 'new':
                self._localIceCandidatesBuffer.push(event);
                if (end && complete) {
                  self._localIceCandidatesBuffer.push(
                      new Event('icecandidate'));
                }
                break;
              case 'gathering':
                self._emitBufferedCandidates();
                self.dispatchEvent(event);
                if (self.onicecandidate !== null) {
                  self.onicecandidate(event);
                }
                if (complete) {
                  self.dispatchEvent(new Event('icecandidate'));
                  if (self.onicecandidate !== null) {
                    self.onicecandidate(new Event('icecandidate'));
                  }
                  self.iceGatheringState = 'complete';
                }
                break;
              case 'complete':
                // should not happen... currently!
                break;
              default: // no-op.
                break;
            }
          };
          iceTransport.onicestatechange = function() {
            self._updateConnectionState();
          };

          var dtlsTransport = new RTCDtlsTransport(iceTransport);
          dtlsTransport.ondtlsstatechange = function() {
            self._updateConnectionState();
          };
          dtlsTransport.onerror = function() {
            // onerror does not set state to failed by itself.
            dtlsTransport.state = 'failed';
            self._updateConnectionState();
          };

          return {
            iceGatherer: iceGatherer,
            iceTransport: iceTransport,
            dtlsTransport: dtlsTransport
          };
        };

    // Start the RTP Sender and Receiver for a transceiver.
    window.RTCPeerConnection.prototype._transceive = function(transceiver,
        send, recv) {
      var params = this._getCommonCapabilities(transceiver.localCapabilities,
          transceiver.remoteCapabilities);
      if (send && transceiver.rtpSender) {
        params.encodings = transceiver.sendEncodingParameters;
        params.rtcp = {
          cname: SDPUtils.localCName
        };
        if (transceiver.recvEncodingParameters.length) {
          params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
        }
        transceiver.rtpSender.send(params);
      }
      if (recv && transceiver.rtpReceiver) {
        // remove RTX field in Edge 14942
        if (transceiver.kind === 'video'
            && transceiver.recvEncodingParameters) {
          transceiver.recvEncodingParameters.forEach(function(p) {
            delete p.rtx;
          });
        }
        params.encodings = transceiver.recvEncodingParameters;
        params.rtcp = {
          cname: transceiver.cname
        };
        if (transceiver.sendEncodingParameters.length) {
          params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
        }
        transceiver.rtpReceiver.receive(params);
      }
    };

    window.RTCPeerConnection.prototype.setLocalDescription =
        function(description) {
          var self = this;
          var sections;
          var sessionpart;
          if (description.type === 'offer') {
            // FIXME: What was the purpose of this empty if statement?
            // if (!this._pendingOffer) {
            // } else {
            if (this._pendingOffer) {
              // VERY limited support for SDP munging. Limited to:
              // * changing the order of codecs
              sections = SDPUtils.splitSections(description.sdp);
              sessionpart = sections.shift();
              sections.forEach(function(mediaSection, sdpMLineIndex) {
                var caps = SDPUtils.parseRtpParameters(mediaSection);
                self._pendingOffer[sdpMLineIndex].localCapabilities = caps;
              });
              this.transceivers = this._pendingOffer;
              delete this._pendingOffer;
            }
          } else if (description.type === 'answer') {
            sections = SDPUtils.splitSections(self.remoteDescription.sdp);
            sessionpart = sections.shift();
            var isIceLite = SDPUtils.matchPrefix(sessionpart,
                'a=ice-lite').length > 0;
            sections.forEach(function(mediaSection, sdpMLineIndex) {
              var transceiver = self.transceivers[sdpMLineIndex];
              var iceGatherer = transceiver.iceGatherer;
              var iceTransport = transceiver.iceTransport;
              var dtlsTransport = transceiver.dtlsTransport;
              var localCapabilities = transceiver.localCapabilities;
              var remoteCapabilities = transceiver.remoteCapabilities;

              var rejected = mediaSection.split('\n', 1)[0]
                  .split(' ', 2)[1] === '0';

              if (!rejected && !transceiver.isDatachannel) {
                var remoteIceParameters = SDPUtils.getIceParameters(
                    mediaSection, sessionpart);
                if (isIceLite) {
                  var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
                  .map(function(cand) {
                    return SDPUtils.parseCandidate(cand);
                  })
                  .filter(function(cand) {
                    return cand.component === '1';
                  });
                  // ice-lite only includes host candidates in the SDP so we can
                  // use setRemoteCandidates (which implies an
                  // RTCIceCandidateComplete)
                  if (cands.length) {
                    iceTransport.setRemoteCandidates(cands);
                  }
                }
                var remoteDtlsParameters = SDPUtils.getDtlsParameters(
                    mediaSection, sessionpart);
                if (isIceLite) {
                  remoteDtlsParameters.role = 'server';
                }

                if (!self.usingBundle || sdpMLineIndex === 0) {
                  iceTransport.start(iceGatherer, remoteIceParameters,
                      isIceLite ? 'controlling' : 'controlled');
                  dtlsTransport.start(remoteDtlsParameters);
                }

                // Calculate intersection of capabilities.
                var params = self._getCommonCapabilities(localCapabilities,
                    remoteCapabilities);

                // Start the RTCRtpSender. The RTCRtpReceiver for this
                // transceiver has already been started in setRemoteDescription.
                self._transceive(transceiver,
                    params.codecs.length > 0,
                    false);
              }
            });
          }

          this.localDescription = {
            type: description.type,
            sdp: description.sdp
          };
          switch (description.type) {
            case 'offer':
              this._updateSignalingState('have-local-offer');
              break;
            case 'answer':
              this._updateSignalingState('stable');
              break;
            default:
              throw new TypeError('unsupported type "' + description.type +
                  '"');
          }

          // If a success callback was provided, emit ICE candidates after it
          // has been executed. Otherwise, emit callback after the Promise is
          // resolved.
          var hasCallback = arguments.length > 1 &&
            typeof arguments[1] === 'function';
          if (hasCallback) {
            var cb = arguments[1];
            window.setTimeout(function() {
              cb();
              if (self.iceGatheringState === 'new') {
                self.iceGatheringState = 'gathering';
              }
              self._emitBufferedCandidates();
            }, 0);
          }
          var p = Promise.resolve();
          p.then(function() {
            if (!hasCallback) {
              if (self.iceGatheringState === 'new') {
                self.iceGatheringState = 'gathering';
              }
              // Usually candidates will be emitted earlier.
              window.setTimeout(self._emitBufferedCandidates.bind(self), 500);
            }
          });
          return p;
        };

    window.RTCPeerConnection.prototype.setRemoteDescription =
        function(description) {
          var self = this;
          var stream = new MediaStream();
          var receiverList = [];
          var sections = SDPUtils.splitSections(description.sdp);
          var sessionpart = sections.shift();
          var isIceLite = SDPUtils.matchPrefix(sessionpart,
              'a=ice-lite').length > 0;
          this.usingBundle = SDPUtils.matchPrefix(sessionpart,
              'a=group:BUNDLE ').length > 0;
          sections.forEach(function(mediaSection, sdpMLineIndex) {
            var lines = SDPUtils.splitLines(mediaSection);
            var mline = lines[0].substr(2).split(' ');
            var kind = mline[0];
            var rejected = mline[1] === '0';
            var direction = SDPUtils.getDirection(mediaSection, sessionpart);

            var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:');
            if (mid.length) {
              mid = mid[0].substr(6);
            } else {
              mid = SDPUtils.generateIdentifier();
            }

            // Reject datachannels which are not implemented yet.
            if (kind === 'application' && mline[2] === 'DTLS/SCTP') {
              self.transceivers[sdpMLineIndex] = {
                mid: mid,
                isDatachannel: true
              };
              return;
            }

            var transceiver;
            var iceGatherer;
            var iceTransport;
            var dtlsTransport;
            var rtpSender;
            var rtpReceiver;
            var sendEncodingParameters;
            var recvEncodingParameters;
            var localCapabilities;

            var track;
            // FIXME: ensure the mediaSection has rtcp-mux set.
            var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
            var remoteIceParameters;
            var remoteDtlsParameters;
            if (!rejected) {
              remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
                  sessionpart);
              remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
                  sessionpart);
              remoteDtlsParameters.role = 'client';
            }
            recvEncodingParameters =
                SDPUtils.parseRtpEncodingParameters(mediaSection);

            var cname;
            // Gets the first SSRC. Note that with RTX there might be multiple
            // SSRCs.
            var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
                .map(function(line) {
                  return SDPUtils.parseSsrcMedia(line);
                })
                .filter(function(obj) {
                  return obj.attribute === 'cname';
                })[0];
            if (remoteSsrc) {
              cname = remoteSsrc.value;
            }

            var isComplete = SDPUtils.matchPrefix(mediaSection,
                'a=end-of-candidates', sessionpart).length > 0;
            var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
                .map(function(cand) {
                  return SDPUtils.parseCandidate(cand);
                })
                .filter(function(cand) {
                  return cand.component === '1';
                });
            if (description.type === 'offer' && !rejected) {
              var transports = self.usingBundle && sdpMLineIndex > 0 ? {
                iceGatherer: self.transceivers[0].iceGatherer,
                iceTransport: self.transceivers[0].iceTransport,
                dtlsTransport: self.transceivers[0].dtlsTransport
              } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);

              if (isComplete) {
                transports.iceTransport.setRemoteCandidates(cands);
              }

              localCapabilities = RTCRtpReceiver.getCapabilities(kind);

              // filter RTX until additional stuff needed for RTX is implemented
              // in adapter.js
              localCapabilities.codecs = localCapabilities.codecs.filter(
                  function(codec) {
                    return codec.name !== 'rtx';
                  });

              sendEncodingParameters = [{
                ssrc: (2 * sdpMLineIndex + 2) * 1001
              }];

              rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);

              track = rtpReceiver.track;
              receiverList.push([track, rtpReceiver]);
              // FIXME: not correct when there are multiple streams but that is
              // not currently supported in this shim.
              stream.addTrack(track);

              // FIXME: look at direction.
              if (self.localStreams.length > 0 &&
                  self.localStreams[0].getTracks().length >= sdpMLineIndex) {
                var localTrack;
                if (kind === 'audio') {
                  localTrack = self.localStreams[0].getAudioTracks()[0];
                } else if (kind === 'video') {
                  localTrack = self.localStreams[0].getVideoTracks()[0];
                }
                if (localTrack) {
                  rtpSender = new RTCRtpSender(localTrack,
                      transports.dtlsTransport);
                }
              }

              self.transceivers[sdpMLineIndex] = {
                iceGatherer: transports.iceGatherer,
                iceTransport: transports.iceTransport,
                dtlsTransport: transports.dtlsTransport,
                localCapabilities: localCapabilities,
                remoteCapabilities: remoteCapabilities,
                rtpSender: rtpSender,
                rtpReceiver: rtpReceiver,
                kind: kind,
                mid: mid,
                cname: cname,
                sendEncodingParameters: sendEncodingParameters,
                recvEncodingParameters: recvEncodingParameters
              };
              // Start the RTCRtpReceiver now. The RTPSender is started in
              // setLocalDescription.
              self._transceive(self.transceivers[sdpMLineIndex],
                  false,
                  direction === 'sendrecv' || direction === 'sendonly');
            } else if (description.type === 'answer' && !rejected) {
              transceiver = self.transceivers[sdpMLineIndex];
              iceGatherer = transceiver.iceGatherer;
              iceTransport = transceiver.iceTransport;
              dtlsTransport = transceiver.dtlsTransport;
              rtpSender = transceiver.rtpSender;
              rtpReceiver = transceiver.rtpReceiver;
              sendEncodingParameters = transceiver.sendEncodingParameters;
              localCapabilities = transceiver.localCapabilities;

              self.transceivers[sdpMLineIndex].recvEncodingParameters =
                  recvEncodingParameters;
              self.transceivers[sdpMLineIndex].remoteCapabilities =
                  remoteCapabilities;
              self.transceivers[sdpMLineIndex].cname = cname;

              if ((isIceLite || isComplete) && cands.length) {
                iceTransport.setRemoteCandidates(cands);
              }
              if (!self.usingBundle || sdpMLineIndex === 0) {
                iceTransport.start(iceGatherer, remoteIceParameters,
                    'controlling');
                dtlsTransport.start(remoteDtlsParameters);
              }

              self._transceive(transceiver,
                  direction === 'sendrecv' || direction === 'recvonly',
                  direction === 'sendrecv' || direction === 'sendonly');

              if (rtpReceiver &&
                  (direction === 'sendrecv' || direction === 'sendonly')) {
                track = rtpReceiver.track;
                receiverList.push([track, rtpReceiver]);
                stream.addTrack(track);
              } else {
                // FIXME: actually the receiver should be created later.
                delete transceiver.rtpReceiver;
              }
            }
          });

          this.remoteDescription = {
            type: description.type,
            sdp: description.sdp
          };
          switch (description.type) {
            case 'offer':
              this._updateSignalingState('have-remote-offer');
              break;
            case 'answer':
              this._updateSignalingState('stable');
              break;
            default:
              throw new TypeError('unsupported type "' + description.type +
                  '"');
          }
          if (stream.getTracks().length) {
            self.remoteStreams.push(stream);
            window.setTimeout(function() {
              var event = new Event('addstream');
              event.stream = stream;
              self.dispatchEvent(event);
              if (self.onaddstream !== null) {
                window.setTimeout(function() {
                  self.onaddstream(event);
                }, 0);
              }

              receiverList.forEach(function(item) {
                var track = item[0];
                var receiver = item[1];
                var trackEvent = new Event('track');
                trackEvent.track = track;
                trackEvent.receiver = receiver;
                trackEvent.streams = [stream];
                self.dispatchEvent(event);
                if (self.ontrack !== null) {
                  window.setTimeout(function() {
                    self.ontrack(trackEvent);
                  }, 0);
                }
              });
            }, 0);
          }
          if (arguments.length > 1 && typeof arguments[1] === 'function') {
            window.setTimeout(arguments[1], 0);
          }
          return Promise.resolve();
        };

    window.RTCPeerConnection.prototype.close = function() {
      this.transceivers.forEach(function(transceiver) {
        /* not yet
        if (transceiver.iceGatherer) {
          transceiver.iceGatherer.close();
        }
        */
        if (transceiver.iceTransport) {
          transceiver.iceTransport.stop();
        }
        if (transceiver.dtlsTransport) {
          transceiver.dtlsTransport.stop();
        }
        if (transceiver.rtpSender) {
          transceiver.rtpSender.stop();
        }
        if (transceiver.rtpReceiver) {
          transceiver.rtpReceiver.stop();
        }
      });
      // FIXME: clean up tracks, local streams, remote streams, etc
      this._updateSignalingState('closed');
    };

    // Update the signaling state.
    window.RTCPeerConnection.prototype._updateSignalingState =
        function(newState) {
          this.signalingState = newState;
          var event = new Event('signalingstatechange');
          this.dispatchEvent(event);
          if (this.onsignalingstatechange !== null) {
            this.onsignalingstatechange(event);
          }
        };

    // Determine whether to fire the negotiationneeded event.
    window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded =
        function() {
          // Fire away (for now).
          var event = new Event('negotiationneeded');
          this.dispatchEvent(event);
          if (this.onnegotiationneeded !== null) {
            this.onnegotiationneeded(event);
          }
        };

    // Update the connection state.
    window.RTCPeerConnection.prototype._updateConnectionState = function() {
      var self = this;
      var newState;
      var states = {
        'new': 0,
        closed: 0,
        connecting: 0,
        checking: 0,
        connected: 0,
        completed: 0,
        failed: 0
      };
      this.transceivers.forEach(function(transceiver) {
        states[transceiver.iceTransport.state]++;
        states[transceiver.dtlsTransport.state]++;
      });
      // ICETransport.completed and connected are the same for this purpose.
      states.connected += states.completed;

      newState = 'new';
      if (states.failed > 0) {
        newState = 'failed';
      } else if (states.connecting > 0 || states.checking > 0) {
        newState = 'connecting';
      } else if (states.disconnected > 0) {
        newState = 'disconnected';
      } else if (states.new > 0) {
        newState = 'new';
      } else if (states.connected > 0 || states.completed > 0) {
        newState = 'connected';
      }

      if (newState !== self.iceConnectionState) {
        self.iceConnectionState = newState;
        var event = new Event('iceconnectionstatechange');
        this.dispatchEvent(event);
        if (this.oniceconnectionstatechange !== null) {
          this.oniceconnectionstatechange(event);
        }
      }
    };

    window.RTCPeerConnection.prototype.createOffer = function() {
      var self = this;
      if (this._pendingOffer) {
        throw new Error('createOffer called while there is a pending offer.');
      }
      var offerOptions;
      if (arguments.length === 1 && typeof arguments[0] !== 'function') {
        offerOptions = arguments[0];
      } else if (arguments.length === 3) {
        offerOptions = arguments[2];
      }

      var tracks = [];
      var numAudioTracks = 0;
      var numVideoTracks = 0;
      // Default to sendrecv.
      if (this.localStreams.length) {
        numAudioTracks = this.localStreams[0].getAudioTracks().length;
        numVideoTracks = this.localStreams[0].getVideoTracks().length;
      }
      // Determine number of audio and video tracks we need to send/recv.
      if (offerOptions) {
        // Reject Chrome legacy constraints.
        if (offerOptions.mandatory || offerOptions.optional) {
          throw new TypeError(
              'Legacy mandatory/optional constraints not supported.');
        }
        if (offerOptions.offerToReceiveAudio !== undefined) {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
        if (offerOptions.offerToReceiveVideo !== undefined) {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
      if (this.localStreams.length) {
        // Push local streams.
        this.localStreams[0].getTracks().forEach(function(track) {
          tracks.push({
            kind: track.kind,
            track: track,
            wantReceive: track.kind === 'audio' ?
                numAudioTracks > 0 : numVideoTracks > 0
          });
          if (track.kind === 'audio') {
            numAudioTracks--;
          } else if (track.kind === 'video') {
            numVideoTracks--;
          }
        });
      }
      // Create M-lines for recvonly streams.
      while (numAudioTracks > 0 || numVideoTracks > 0) {
        if (numAudioTracks > 0) {
          tracks.push({
            kind: 'audio',
            wantReceive: true
          });
          numAudioTracks--;
        }
        if (numVideoTracks > 0) {
          tracks.push({
            kind: 'video',
            wantReceive: true
          });
          numVideoTracks--;
        }
      }

      var sdp = SDPUtils.writeSessionBoilerplate();
      var transceivers = [];
      tracks.forEach(function(mline, sdpMLineIndex) {
        // For each track, create an ice gatherer, ice transport,
        // dtls transport, potentially rtpsender and rtpreceiver.
        var track = mline.track;
        var kind = mline.kind;
        var mid = SDPUtils.generateIdentifier();

        var transports = self.usingBundle && sdpMLineIndex > 0 ? {
          iceGatherer: transceivers[0].iceGatherer,
          iceTransport: transceivers[0].iceTransport,
          dtlsTransport: transceivers[0].dtlsTransport
        } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);

        var localCapabilities = RTCRtpSender.getCapabilities(kind);
        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
        localCapabilities.codecs.forEach(function(codec) {
          // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
          // by adding level-asymmetry-allowed=1
          if (codec.name === 'H264' &&
              codec.parameters['level-asymmetry-allowed'] === undefined) {
            codec.parameters['level-asymmetry-allowed'] = '1';
          }
        });

        var rtpSender;
        var rtpReceiver;

        // generate an ssrc now, to be used later in rtpSender.send
        var sendEncodingParameters = [{
          ssrc: (2 * sdpMLineIndex + 1) * 1001
        }];
        if (track) {
          rtpSender = new RTCRtpSender(track, transports.dtlsTransport);
        }

        if (mline.wantReceive) {
          rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);
        }

        transceivers[sdpMLineIndex] = {
          iceGatherer: transports.iceGatherer,
          iceTransport: transports.iceTransport,
          dtlsTransport: transports.dtlsTransport,
          localCapabilities: localCapabilities,
          remoteCapabilities: null,
          rtpSender: rtpSender,
          rtpReceiver: rtpReceiver,
          kind: kind,
          mid: mid,
          sendEncodingParameters: sendEncodingParameters,
          recvEncodingParameters: null
        };
      });
      if (this.usingBundle) {
        sdp += 'a=group:BUNDLE ' + transceivers.map(function(t) {
          return t.mid;
        }).join(' ') + '\r\n';
      }
      tracks.forEach(function(mline, sdpMLineIndex) {
        var transceiver = transceivers[sdpMLineIndex];
        sdp += SDPUtils.writeMediaSection(transceiver,
            transceiver.localCapabilities, 'offer', self.localStreams[0]);
      });

      this._pendingOffer = transceivers;
      var desc = new RTCSessionDescription({
        type: 'offer',
        sdp: sdp
      });
      if (arguments.length && typeof arguments[0] === 'function') {
        window.setTimeout(arguments[0], 0, desc);
      }
      return Promise.resolve(desc);
    };

    window.RTCPeerConnection.prototype.createAnswer = function() {
      var self = this;

      var sdp = SDPUtils.writeSessionBoilerplate();
      if (this.usingBundle) {
        sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {
          return t.mid;
        }).join(' ') + '\r\n';
      }
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.isDatachannel) {
          sdp += 'm=application 0 DTLS/SCTP 5000\r\n' +
              'c=IN IP4 0.0.0.0\r\n' +
              'a=mid:' + transceiver.mid + '\r\n';
          return;
        }
        // Calculate intersection of capabilities.
        var commonCapabilities = self._getCommonCapabilities(
            transceiver.localCapabilities,
            transceiver.remoteCapabilities);

        sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,
            'answer', self.localStreams[0]);
      });

      var desc = new RTCSessionDescription({
        type: 'answer',
        sdp: sdp
      });
      if (arguments.length && typeof arguments[0] === 'function') {
        window.setTimeout(arguments[0], 0, desc);
      }
      return Promise.resolve(desc);
    };

    window.RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
      if (!candidate) {
        this.transceivers.forEach(function(transceiver) {
          transceiver.iceTransport.addRemoteCandidate({});
        });
      } else {
        var mLineIndex = candidate.sdpMLineIndex;
        if (candidate.sdpMid) {
          for (var i = 0; i < this.transceivers.length; i++) {
            if (this.transceivers[i].mid === candidate.sdpMid) {
              mLineIndex = i;
              break;
            }
          }
        }
        var transceiver = this.transceivers[mLineIndex];
        if (transceiver) {
          var cand = Object.keys(candidate.candidate).length > 0 ?
              SDPUtils.parseCandidate(candidate.candidate) : {};
          // Ignore Chrome's invalid candidates since Edge does not like them.
          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
            return;
          }
          // Ignore RTCP candidates, we assume RTCP-MUX.
          if (cand.component !== '1') {
            return;
          }
          // A dirty hack to make samples work.
          if (cand.type === 'endOfCandidates') {
            cand = {};
          }
          transceiver.iceTransport.addRemoteCandidate(cand);

          // update the remoteDescription.
          var sections = SDPUtils.splitSections(this.remoteDescription.sdp);
          sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim()
              : 'a=end-of-candidates') + '\r\n';
          this.remoteDescription.sdp = sections.join('');
        }
      }
      if (arguments.length > 1 && typeof arguments[1] === 'function') {
        window.setTimeout(arguments[1], 0);
      }
      return Promise.resolve();
    };

    window.RTCPeerConnection.prototype.getStats = function() {
      var promises = [];
      this.transceivers.forEach(function(transceiver) {
        ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
            'dtlsTransport'].forEach(function(method) {
              if (transceiver[method]) {
                promises.push(transceiver[method].getStats());
              }
            });
      });
      var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&
          arguments[1];
      return new Promise(function(resolve) {
        // shim getStats with maplike support
        var results = new Map();
        Promise.all(promises).then(function(res) {
          res.forEach(function(result) {
            Object.keys(result).forEach(function(id) {
              results.set(id, result[id]);
              results[id] = result[id];
            });
          });
          if (cb) {
            window.setTimeout(cb, 0, results);
          }
          resolve(results);
        });
      });
    };
  }
};

// Expose public methods.
module.exports = {
  shimPeerConnection: edgeShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils":118,"./getusermedia":114,"sdp":51}],114:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

// Expose public methods.
module.exports = function() {
  var shimError_ = function(e) {
    return {
      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.
      bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function(c) {
    return origGetUserMedia(c).catch(function(e) {
      return Promise.reject(shimError_(e));
    });
  };
};

},{}],115:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var browserDetails = require('../utils').browserDetails;

var firefoxShim = {
  shimOnTrack: function() {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        }
      });
    }
  },

  shimSourceObject: function() {
    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this.mozSrcObject;
          },
          set: function(stream) {
            this.mozSrcObject = stream;
          }
        });
      }
    }
  },

  shimPeerConnection: function() {
    if (typeof window !== 'object' || !(window.RTCPeerConnection ||
        window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (browserDetails.version < 38) {
          // .urls is not supported in FF < 38.
          // create RTCIceServers with a single url.
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (server.hasOwnProperty('urls')) {
                for (var j = 0; j < server.urls.length; j++) {
                  var newServer = {
                    url: server.urls[j]
                  };
                  if (server.urls[j].indexOf('turn') === 0) {
                    newServer.username = server.username;
                    newServer.credential = server.credential;
                  }
                  newIceServers.push(newServer);
                }
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
        }
        return new mozRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype;

      // wrap static methods. Currently just generateCertificate.
      if (mozRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return mozRTCPeerConnection.generateCertificate;
          }
        });
      }

      window.RTCSessionDescription = mozRTCSessionDescription;
      window.RTCIceCandidate = mozRTCIceCandidate;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = RTCPeerConnection.prototype[method];
          RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                RTCIceCandidate : RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        RTCPeerConnection.prototype.addIceCandidate;
    RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    if (browserDetails.version < 48) {
      // shim getStats with maplike support
      var makeMapStats = function(stats) {
        var map = new Map();
        Object.keys(stats).forEach(function(key) {
          map.set(key, stats[key]);
          map[key] = stats[key];
        });
        return map;
      };

      var nativeGetStats = RTCPeerConnection.prototype.getStats;
      RTCPeerConnection.prototype.getStats = function(selector, onSucc, onErr) {
        return nativeGetStats.apply(this, [selector || null])
          .then(function(stats) {
            return makeMapStats(stats);
          })
          .then(onSucc, onErr);
      };
    }
  }
};

// Expose public methods.
module.exports = {
  shimOnTrack: firefoxShim.shimOnTrack,
  shimSourceObject: firefoxShim.shimSourceObject,
  shimPeerConnection: firefoxShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils":118,"./getusermedia":116}],116:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logging = require('../utils').log;
var browserDetails = require('../utils').browserDetails;

// Expose public methods.
module.exports = function() {
  var shimError_ = function(e) {
    return {
      name: {
        SecurityError: 'NotAllowedError',
        PermissionDeniedError: 'NotAllowedError'
      }[e.name] || e.name,
      message: {
        'The operation is insecure.': 'The request is not allowed by the ' +
        'user agent or the platform in the current context.'
      }[e.message] || e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  // getUserMedia constraints shim.
  var getUserMedia_ = function(constraints, onSuccess, onError) {
    var constraintsToFF37_ = function(c) {
      if (typeof c !== 'object' || c.require) {
        return c;
      }
      var require = [];
      Object.keys(c).forEach(function(key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = c[key] = (typeof c[key] === 'object') ?
            c[key] : {ideal: c[key]};
        if (r.min !== undefined ||
            r.max !== undefined || r.exact !== undefined) {
          require.push(key);
        }
        if (r.exact !== undefined) {
          if (typeof r.exact === 'number') {
            r. min = r.max = r.exact;
          } else {
            c[key] = r.exact;
          }
          delete r.exact;
        }
        if (r.ideal !== undefined) {
          c.advanced = c.advanced || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[key] = {min: r.ideal, max: r.ideal};
          } else {
            oc[key] = r.ideal;
          }
          c.advanced.push(oc);
          delete r.ideal;
          if (!Object.keys(r).length) {
            delete c[key];
          }
        }
      });
      if (require.length) {
        c.require = require;
      }
      return c;
    };
    constraints = JSON.parse(JSON.stringify(constraints));
    if (browserDetails.version < 38) {
      logging('spec: ' + JSON.stringify(constraints));
      if (constraints.audio) {
        constraints.audio = constraintsToFF37_(constraints.audio);
      }
      if (constraints.video) {
        constraints.video = constraintsToFF37_(constraints.video);
      }
      logging('ff37: ' + JSON.stringify(constraints));
    }
    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {
      onError(shimError_(e));
    });
  };

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      getUserMedia_(constraints, resolve, reject);
    });
  };

  // Shim for mediaDevices on older versions.
  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
      addEventListener: function() { },
      removeEventListener: function() { }
    };
  }
  navigator.mediaDevices.enumerateDevices =
      navigator.mediaDevices.enumerateDevices || function() {
        return new Promise(function(resolve) {
          var infos = [
            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
          ];
          resolve(infos);
        });
      };

  if (browserDetails.version < 41) {
    // Work around http://bugzil.la/1169665
    var orgEnumerateDevices =
        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
    navigator.mediaDevices.enumerateDevices = function() {
      return orgEnumerateDevices().then(undefined, function(e) {
        if (e.name === 'NotFoundError') {
          return [];
        }
        throw e;
      });
    };
  }
  if (browserDetails.version < 49) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      return origGetUserMedia(c).then(function(stream) {
        // Work around https://bugzil.la/802326
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(function(track) {
            track.stop();
          });
          throw new DOMException('The object can not be found here.',
                                 'NotFoundError');
        }
        return stream;
      }, function(e) {
        return Promise.reject(shimError_(e));
      });
    };
  }
  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    if (browserDetails.version < 44) {
      return getUserMedia_(constraints, onSuccess, onError);
    }
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    console.warn('navigator.getUserMedia has been replaced by ' +
                 'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
};

},{"../utils":118}],117:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';
var safariShim = {
  // TODO: DrAlex, should be here, double check against LayoutTests
  // shimOnTrack: function() { },

  // TODO: once the back-end for the mac port is done, add.
  // TODO: check for webkitGTK+
  // shimPeerConnection: function() { },

  shimGetUserMedia: function() {
    navigator.getUserMedia = navigator.webkitGetUserMedia;
  }
};

// Expose public methods.
module.exports = {
  shimGetUserMedia: safariShim.shimGetUserMedia
  // TODO
  // shimOnTrack: safariShim.shimOnTrack,
  // shimPeerConnection: safariShim.shimPeerConnection
};

},{}],118:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logDisabled_ = true;

// Utility methods.
var utils = {
  disableLog: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
        'adapter.js logging enabled';
  },

  log: function() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  },

  /**
   * Extract browser version out of the provided user agent string.
   *
   * @param {!string} uastring userAgent string.
   * @param {!string} expr Regular expression used as match criteria.
   * @param {!number} pos position in the version string to be returned.
   * @return {!number} browser version.
   */
  extractVersion: function(uastring, expr, pos) {
    var match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  },

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  detectBrowser: function() {
    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    // Firefox.
    if (navigator.mozGetUserMedia) {
      result.browser = 'firefox';
      result.version = this.extractVersion(navigator.userAgent,
          /Firefox\/([0-9]+)\./, 1);

    // all webkit-based browsers
    } else if (navigator.webkitGetUserMedia) {
      // Chrome, Chromium, Webview, Opera, all use the chrome shim for now
      if (window.webkitRTCPeerConnection) {
        result.browser = 'chrome';
        result.version = this.extractVersion(navigator.userAgent,
          /Chrom(e|ium)\/([0-9]+)\./, 2);

      // Safari or unknown webkit-based
      // for the time being Safari has support for MediaStreams but not webRTC
      } else {
        // Safari UA substrings of interest for reference:
        // - webkit version:           AppleWebKit/602.1.25 (also used in Op,Cr)
        // - safari UI version:        Version/9.0.3 (unique to Safari)
        // - safari UI webkit version: Safari/601.4.4 (also used in Op,Cr)
        //
        // if the webkit version and safari UI webkit versions are equals,
        // ... this is a stable version.
        //
        // only the internal webkit version is important today to know if
        // media streams are supported
        //
        if (navigator.userAgent.match(/Version\/(\d+).(\d+)/)) {
          result.browser = 'safari';
          result.version = this.extractVersion(navigator.userAgent,
            /AppleWebKit\/([0-9]+)\./, 1);

        // unknown webkit-based browser
        } else {
          result.browser = 'Unsupported webkit-based browser ' +
              'with GUM support but no WebRTC support.';
          return result;
        }
      }

    // Edge.
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
      result.browser = 'edge';
      result.version = this.extractVersion(navigator.userAgent,
          /Edge\/(\d+).(\d+)$/, 2);

    // Default fallthrough: not supported.
    } else {
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  }
};

// Export.
module.exports = {
  log: utils.log,
  disableLog: utils.disableLog,
  browserDetails: utils.detectBrowser(),
  extractVersion: utils.extractVersion
};

},{}],119:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],120:[function(require,module,exports){
(function (process,setImmediate){(function (){
var ms2s = 1.0 / 1000.0;
var ns2ms = 1.0 / 1000000.0
var ns2s = 1e-9

module.exports = T

function T(){
	if(!process.hrtime){ // browser fill

		process.hrtime = function(){

			if(arguments.length){
				arguments[1] = new Date().getTime();
				arguments[0] =  arguments[1] - millies(arguments[0])
			}

			else {
				arguments[0] = new Date().getTime();
			}
			
			return [parseInt(arguments[0] * ms2s), parseInt(((arguments[0] * ms2s) % 1) / ns2s)];
			
		}
	}
  if(!(this instanceof T)) return new T();
  var self = this;
  self.start = self.last = self.beat = process.hrtime();
  self.x = []
  self.end = []
  self.beats =  []
  self.averageSetSize = 333
  self.threshold = 1e6 // 10,000,000 ns ( 10 ms )
  self.skip = false
};

T.prototype.sinceBegin = function(){
  return process.hrtime(this.start)
};

T.prototype.sinceLast = function(){
  this.x = process.hrtime(this.last)
  this.last = process.hrtime()
  return this.x
}

T.prototype.sinceLastNS = function(){
  return nanos(this.sinceLast())
};

T.prototype.sinceBeginNS = function(){
  return nanos(this.sinceBegin())
};

T.prototype.avg = function(){
  var ns = nanos(this.sinceLast())
  this.beats.push(ns);
  this.beats = this.beats.splice(-this.averageSetSize)
  return avg(this.beats);
};

T.prototype.everyS = function(s, fn, go){
	this.every(s * 1e9, fn, go)
}

T.prototype.every = function(ns, fn, go){

  var self = new T();
  var timer = new T();

  var inter = ns || 0
    , fn = fn || function(t,c){c()}
    ;   
      
  function tick(){

    var ns = nanos(self.sinceLast());
//  unnecessary cuz no longer trying to optimize in loop()
//    self.beats.push(ns);
    loop()

  };

  function loop(){
    var d = inter - (nanos(process.hrtime()) - nanos(self.beat));

    if(d < 10000) {
      tock()
    }

    else if(self.skip) {
     setImmediate(loop)
    }

    else if(d < self.threshold) {
      // under the threshold, its nextTicks until the interval is up
      self.skip = true; setImmediate(loop) 
    }

    else {
      if(false && self.beats.length > 9) {
        var r = self.beats.length / self.averageSetSize;
        self.threshold = avg(self.beats) * .45 * r * 2
      }

      // for future reference:
      // console.log(avg(self.beats), self.beats.length, 'threshold = ' + self.threshold)

      self.skip = false; 
      setTimeout(loop, self.threshold / 1e6)
    }
  };

  function tock(){
    self.beat = process.hrtime();
    self.skip = false;
    fn(tick, nanos(timer.sinceLast()))
  };
  
  if(go) tock()

  else loop()

}

function millies(arr){
	return (arr[0] * 1e3) + (arr[1] * ns2ms)
}

function nanos(arr){
  return arr[0] * 1e9 + arr[1]
}

function add(a, b){
  var ns = a[1] + b[1];
  b[0] += a[0];
  b[1] = ns % 1e9;
  if(ns !== b[1]) b[0]++;
  return b
};

function avg(){

  return Array.prototype.slice.call(arguments[0]).reduce(function(a,i){return a += i },0) / arguments[0].length

}

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":143,"timers":164}],121:[function(require,module,exports){
(function (global){(function (){
'use strict';

var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? global : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],122:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],123:[function(require,module,exports){

},{}],124:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":122,"buffer":124,"ieee754":137}],125:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"./":126,"get-intrinsic":132}],126:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"function-bind":131,"get-intrinsic":132}],127:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"get-intrinsic":132}],128:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],129:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],130:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],131:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":130}],132:[function(require,module,exports){
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"function-bind":131,"has":136,"has-symbols":133}],133:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":134}],134:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],135:[function(require,module,exports){
'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

},{"has-symbols/shams":134}],136:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":131}],137:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],138:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],139:[function(require,module,exports){
'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"call-bind/callBound":125,"has-tostringtag/shams":135}],140:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],141:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require('has-tostringtag/shams')();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};

},{"has-tostringtag/shams":135}],142:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"available-typed-arrays":121,"call-bind/callBound":125,"es-abstract/helpers/getOwnPropertyDescriptor":127,"foreach":129,"has-tostringtag/shams":135}],143:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],144:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],145:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],146:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":144,"./encode":145}],147:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"buffer":124,"dup":50}],148:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":128,"inherits":138,"readable-stream/lib/_stream_duplex.js":150,"readable-stream/lib/_stream_passthrough.js":151,"readable-stream/lib/_stream_readable.js":152,"readable-stream/lib/_stream_transform.js":153,"readable-stream/lib/_stream_writable.js":154,"readable-stream/lib/internal/streams/end-of-stream.js":158,"readable-stream/lib/internal/streams/pipeline.js":160}],149:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],150:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":152,"./_stream_writable":154,"_process":143,"inherits":138}],151:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./_stream_transform":153,"dup":36,"inherits":138}],152:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":149,"./_stream_duplex":150,"./internal/streams/async_iterator":155,"./internal/streams/buffer_list":156,"./internal/streams/destroy":157,"./internal/streams/from":159,"./internal/streams/state":161,"./internal/streams/stream":162,"_process":143,"buffer":124,"events":128,"inherits":138,"string_decoder/":163,"util":123}],153:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"../errors":149,"./_stream_duplex":150,"dup":38,"inherits":138}],154:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":149,"./_stream_duplex":150,"./internal/streams/destroy":157,"./internal/streams/state":161,"./internal/streams/stream":162,"_process":143,"buffer":124,"inherits":138,"util-deprecate":165}],155:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

},{"./end-of-stream":158,"_process":143}],156:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"buffer":124,"dup":41,"util":123}],157:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

},{"_process":143}],158:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"../../../errors":149,"dup":43}],159:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],160:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"../../../errors":149,"./end-of-stream":158,"dup":45}],161:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"../../../errors":149,"dup":46}],162:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"events":128}],163:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"dup":84,"safe-buffer":147}],164:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":143,"timers":164}],165:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],166:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],167:[function(require,module,exports){
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

'use strict';

var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

},{"is-arguments":139,"is-generator-function":141,"is-typed-array":142,"which-typed-array":169}],168:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

}).call(this)}).call(this,require('_process'))

},{"./support/isBuffer":166,"./support/types":167,"_process":143,"inherits":138}],169:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof g[typedArray] === 'function') {
			var arr = new g[typedArray]();
			if (Symbol.toStringTag in arr) {
				var proto = getPrototypeOf(arr);
				var descriptor = gOPD(proto, Symbol.toStringTag);
				if (!descriptor) {
					var superProto = getPrototypeOf(proto);
					descriptor = gOPD(superProto, Symbol.toStringTag);
				}
				toStrTags[typedArray] = descriptor.get;
			}
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = require('is-typed-array');

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"available-typed-arrays":121,"call-bind/callBound":125,"es-abstract/helpers/getOwnPropertyDescriptor":127,"foreach":129,"has-tostringtag/shams":135,"is-typed-array":142}]},{},[6])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uL2lmcmFtYXJmaS9pbmRleC5qcyIsIi4uL2lmcmFtYXJmaS9ub2RlX21vZHVsZXMvd2luZG9yZmVyL2luZGV4LmpzIiwiLi4vanN5bnRoLWZpbGUtc2FtcGxlL2luZGV4LmpzIiwiLi4vanN5bnRoLW1pYy9zdHJlYW0uanMiLCIvaG9tZS9qb2hubnkvcHJvamVjdHMvcDJwY29uc2VudC9hdWRpby5qcyIsIi9ob21lL2pvaG5ueS9wcm9qZWN0cy9wMnBjb25zZW50L2hvc3QuanMiLCJub2RlX21vZHVsZXMvYW55LWJhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYW55LWJhc2Uvc3JjL2NvbnZlcnRlci5qcyIsIm5vZGVfbW9kdWxlcy9ibG9iLXRvLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXNwbGl0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzLWxpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJub2RlX21vZHVsZXMvZGV0ZWN0LWJyb3dzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZG9tcmVhZHkvcmVhZHkuanMiLCJub2RlX21vZHVsZXMvZXJyLWNvZGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXZlbnQtdGFyZ2V0LXNoaW0vZGlzdC9ldmVudC10YXJnZXQtc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy9nZXQtYnJvd3Nlci1ydGMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2V0aWRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dldHVzZXJtZWRpYS9nZXR1c2VybWVkaWEuanMiLCJub2RlX21vZHVsZXMvaHlwZXJzY3JpcHQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5kZXhvZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL21pbmltaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vYngvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb2J4L2Rpc3QvbW9ieC5janMuZGV2ZWxvcG1lbnQuanMiLCJub2RlX21vZHVsZXMvbW9ieC9kaXN0L21vYnguY2pzLnByb2R1Y3Rpb24ubWluLmpzIiwibm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29nZy1vcHVzLWRlY29kZXIvZGlzdC9vZ2ctb3B1cy1kZWNvZGVyLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9vcHVzLW1lZGlhLXJlY29yZGVyL09wdXNNZWRpYVJlY29yZGVyLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXVlLW1pY3JvdGFzay9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYW5kb21ieXRlcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9lcnJvcnMtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZnJvbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3J1bi13YXRlcmZhbGwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2RwL3NkcC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvaGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhMS5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjI0LmpzIiwibm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyNTYuanMiLCJub2RlX21vZHVsZXMvc2hhLmpzL3NoYTM4NC5qcyIsIm5vZGVfbW9kdWxlcy9zaGEuanMvc2hhNTEyLmpzIiwibm9kZV9tb2R1bGVzL3Nob3J0LXV1aWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvZXZlbnQtc291cmNlLXN0cmVhbS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaWduYWxodWIvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaWduYWxodWIvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvZ2xvYmFsL3dpbmRvdy5qcyIsIm5vZGVfbW9kdWxlcy9zaWduYWxodWIvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvb25jZS9vbmNlLmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy9mb3ItZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaWduYWxodWIvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9ub2RlX21vZHVsZXMvZm9yLWVhY2gvbm9kZV9tb2R1bGVzL2lzLWZ1bmN0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy90cmltL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL3BhcnNlLWhlYWRlcnMuanMiLCJub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RvcmUvZGlzdC9zdG9yZS5sZWdhY3kuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvcGx1Z2lucy9qc29uMi5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9wbHVnaW5zL2xpYi9qc29uMi5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9zcmMvc3RvcmUtZW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9zdG9yYWdlcy9jb29raWVTdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL2xvY2FsU3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9zdG9yYWdlcy9tZW1vcnlTdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL29sZEZGLWdsb2JhbFN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvb2xkSUUtdXNlckRhdGFTdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL3Nlc3Npb25TdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy90aHJvdWdoMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJvdWdoMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJvdWdoMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJvdWdoMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy90aHJvdWdoMi90aHJvdWdoMi5qcyIsIm5vZGVfbW9kdWxlcy90by1hcnJheWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvbWQ1LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L25pbC5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3JlZ2V4LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9ybmctYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3Qvc2hhMS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3YxLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92My5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjM1LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92NC5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjUuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3ZhbGlkYXRlLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9hZGFwdGVyX2NvcmUuanMiLCJub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2Nocm9tZS9jaHJvbWVfc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvY2hyb21lL2dldHVzZXJtZWRpYS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZWRnZS9lZGdlX3NoaW0uanMiLCJub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2VkZ2UvZ2V0dXNlcm1lZGlhLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9maXJlZm94L2ZpcmVmb3hfc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZmlyZWZveC9nZXR1c2VybWVkaWEuanMiLCJub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL3NhZmFyaS9zYWZhcmlfc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzIiwiLi4vc2luY2Utd2hlbi9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9oYXMtdG9zdHJpbmd0YWcvc2hhbXMuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLXR5cGVkLWFycmF5L2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDclFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDenNMQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEtBO0FBQ0E7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25tQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0OUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbFlBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25tQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM3NCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwidmFyIGlmcmFtZSA9IHJlcXVpcmUoJ3dpbmRvcmZlcicpXG5cbnZhciBidW5kbGVGbiA9IGFyZ3VtZW50c1szXTtcbnZhciBzb3VyY2VzID0gYXJndW1lbnRzWzRdO1xudmFyIGNhY2hlID0gYXJndW1lbnRzWzVdO1xudmFyIHN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgbmFtZSwgcGFyYW1zKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICB2YXIgd2tleTtcbiAgICB2YXIgY2FjaGVLZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICBpZiAoY2FjaGVba2V5XS5leHBvcnRzID09PSBmbikge1xuICAgICAgICAgICAgd2tleSA9IGtleTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICghd2tleSkge1xuICAgICAgICB3a2V5ID0gTWF0aC5mbG9vcihNYXRoLnBvdygxNiwgOCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNik7XG4gICAgICAgIHZhciB3Y2FjaGUgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICAgICAgd2NhY2hlW2tleV0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlc1t3a2V5XSA9IFtcbiAgICAgICAgICAgIEZ1bmN0aW9uKFsncmVxdWlyZScsJ21vZHVsZScsJ2V4cG9ydHMnXSwgJygnICsgZm4gKyAnKShzZWxmKScpLFxuICAgICAgICAgICAgd2NhY2hlXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZhciBza2V5ID0gTWF0aC5mbG9vcihNYXRoLnBvdygxNiwgOCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNik7XG4gICAgXG4gICAgdmFyIHNjYWNoZSA9IHt9OyBzY2FjaGVbd2tleV0gPSB3a2V5O1xuICAgIHNvdXJjZXNbc2tleV0gPSBbXG4gICAgICAgIEZ1bmN0aW9uKFsncmVxdWlyZSddLCdyZXF1aXJlKCcgKyBzdHJpbmdpZnkod2tleSkgKyAnKShzZWxmKScpLFxuICAgICAgICBzY2FjaGVcbiAgICBdO1xuICAgIFxuICAgIHZhciBzcmMgPSAnKCcgKyBidW5kbGVGbiArICcpKHsnXG4gICAgICAgICsgT2JqZWN0LmtleXMoc291cmNlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoa2V5KSArICc6WydcbiAgICAgICAgICAgICAgICArIHNvdXJjZXNba2V5XVswXVxuICAgICAgICAgICAgICAgICsgJywnICsgc3RyaW5naWZ5KHNvdXJjZXNba2V5XVsxXSkgKyAnXSdcbiAgICAgICAgICAgIDtcbiAgICAgICAgfSkuam9pbignLCcpXG4gICAgICAgICsgJ30se30sWycgKyBzdHJpbmdpZnkoc2tleSkgKyAnXSknXG4gICAgIDtcbiAgICBcbiAgICBzcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbc3JjXSwge3R5cGU6J3RleHQvamF2YXNjcmlwdCd9KSlcbiAgICBzcmMgPSAnPHNjcmlwdCB0eXBlPXRleHQvamF2YXNjcmlwdCBzcmM9JytzcmMrJz48L3NjcmlwdD4nXG4gICAgdmFyIGZyYW1lID0gaWZyYW1lKHtib2R5OiBzcmMsIG5hbWU6IG5hbWUsIHBhcmFtczogcGFyYW1zfSlcbiAgICByZXR1cm4gZnJhbWUucmVmXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHJldHVybiBuZXcgSUZyYW1lKG9wdHMpXG59XG5cbmZ1bmN0aW9uIElGcmFtZShvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIHRoaXMub3B0cyA9IG9wdHNcbiAgdGhpcy5jb250YWluZXIgPSBvcHRzLmNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5XG4gIHRoaXMucmVmID0gdGhpcy5zZXRIVE1MKG9wdHMpXG59XG5cbklGcmFtZS5wcm90b3R5cGUucGFyc2VIVE1MT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykgb3B0cyA9IHtodG1sOiBvcHRzfVxuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBpZiAodHJ1ZSkge1xuICAgIGlmICghb3B0cy5ib2R5KSBvcHRzLmJvZHkgPSBcIlwiXG4gICAgaWYgKCFvcHRzLmhlYWQpIG9wdHMuaGVhZCA9IFwiXCJcbiAgICBvcHRzLmh0bWwgPSAnPCFET0NUWVBFIGh0bWw+PGh0bWw+PGhlYWQ+JyArIG9wdHMuaGVhZCArICc8L2hlYWQ+PGJvZHk+JyArIG9wdHMuYm9keSArICc8L2JvZHk+PC9odG1sPidcbiAgfVxuICBpZiAoIW9wdHMuc2FuZGJveEF0dHJpYnV0ZXMpIG9wdHMuc2FuZGJveEF0dHJpYnV0ZXMgPSBbJ2FsbG93LXNjcmlwdHMnXVxuICByZXR1cm4gb3B0c1xufVxuXG5JRnJhbWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuLy8gIGlmICh0aGlzLmlmcmFtZSkgdGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5pZnJhbWUpXG59XG5cbklGcmFtZS5wcm90b3R5cGUuc2V0SFRNTCA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgb3B0cyA9IHRoaXMucGFyc2VIVE1MT3B0aW9ucyhvcHRzKVxuICBpZiAoIW9wdHMuaHRtbCkgcmV0dXJuXG4vLyAgdGhpcy5yZW1vdmUoKVxuICAvLyBjcmVhdGUgYSBibG9iIGZvciBvcHRzLmh0bWwgYW5kIHNldCBhcyBpZnJhbWUgYHNyY2AgYXR0cmlidXRlXG4gIHZhciBibG9iID0gbmV3IEJsb2IoW29wdHMuaHRtbF0sIHsgZW5jb2Rpbmc6ICdVVEYtOCcsIHR5cGU6ICd0ZXh0L2h0bWwnIH0pXG4gIHZhciBVID0gdHlwZW9mIFVSTCAhPT0gJ3VuZGVmaW5lZCcgPyBVUkwgOiB3ZWJraXRVUkxcbiAgdmFyIHRhcmdldFVybCA9IFUuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gIC8vIGNyZWF0ZSB0ZW1wb3JhcnkgaWZyYW1lIGZvciBnZW5lcmF0aW5nIEhUTUwgc3RyaW5nXG4gIC8vIGVsZW1lbnQgaXMgaW5zZXJ0ZWQgaW50byB0aGUgRE9NIGFzIGEgc3RyaW5nIHNvIHRoYXQgdGhlIHNlY3VyaXR5IHBvbGljaWVzIGRvIG5vdCBpbnRlcmZlcmVcbiAgLy8gc2VlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9rdW1hdmlzLzgyMDI0NDdcbiAgdmFyIGZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJylcbiAgZnJhbWUuc3JjID0gdGFyZ2V0VXJsXG5cbiAgLy92YXIgdyA9IHdpbmRvdy5vcGVuKHRhcmdldFVybCwgb3B0cy5uYW1lIHx8ICdqb2hubnknLCBvcHRzLnBhcmFtcyB8fCAnJylcbiAgcmV0dXJuIGZyYW1lXG59XG4iLCIvLyBoYW5kbGVzIGF1ZGlvIGZpbGVzIGFuZCByYXcsIG1vbm8sIGF1ZGlvIGJ1ZmZlcnNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb250ZXh0LCBidWZmLCBjYil7XG4gIFxuICB2YXIgbmFtZSA9IGJ1ZmYuY29uc3RydWN0b3IubmFtZVxuICAvL2lmKE1hdGgucmFuZG9tKCkgPCAuMDUpIGNvbnNvbGUubG9nKGJ1ZmYpXG4gIGlmKG5hbWUgPT0gJ0FycmF5QnVmZmVyJyl7XG4gICAgY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoYnVmZikudGhlbihmdW5jdGlvbihkYXRhKXtcbiAgICAgIHZhciBzb3VyY2UgPSBjb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpXG4gICAgICBzb3VyY2UuYnVmZmVyID0gZGF0YVxuLyogICAgICB2YXIgZ2FpbiA9IGNvbnRleHQuY3JlYXRlR2FpbigpXG4gICAgICBnYWluLmNoYW5uZWxDb3VudCA9IDFcbiAgICAgIGdhaW4uY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCdcbiAgICAgIGdhaW4uY2hhbm5lbEludGVycHJldGF0aW9uID0gJ3NwZWFrZXJzJ1xuICAgICAgc291cmNlLmNvbm5lY3QoZ2FpbilcbiAgICAgIHNvdXJjZS5fY29ubmVjdCA9IHNvdXJjZS5jb25uZWN0XG4gICAgICBzb3VyY2UuY29ubmVjdCA9IGdhaW4uY29ubmVjdFxuICovICAgICBjYihudWxsLCBzb3VyY2UpIFxuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycil7Y2IoZXJyLCBudWxsKX0pXG5cdFxuICB9ZWxzZSBpZihuYW1lID09ICdBcnJheScpe1xuICBcbiAgICB2YXIgc291cmNlID0gY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgIFxuICAgIHZhciBidWZmZXIgPSBjb250ZXh0LmNyZWF0ZUJ1ZmZlcigyLCBidWZmWzBdLmxlbmd0aCwgY29udGV4dC5zYW1wbGVSYXRlKVxuXG4gICAgdHJ5eyAvLyBuZXdcbiAgICAgIGJ1ZmZlci5jb3B5VG9DaGFubmVsKGJ1ZmZbMF0sIDAsIDApXG4gICAgICBidWZmZXIuY29weVRvQ2hhbm5lbChidWZmWzFdLCAxLCAwKVxuXG4gICAgfWNhdGNoKGVycil7IC8vIG9sZFxuICAgICAgLy9idWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCkuc2V0KGJ1ZmYpXG4gICAgfVxuICAgIFxuICAgIHNvdXJjZS5idWZmZXIgPSBidWZmZXI7XG4gICAgXG4gICAgLypcbiAgICB2YXIgZ2FpbiA9IGNvbnRleHQuY3JlYXRlR2FpbigpXG4gICAgZ2Fpbi5jaGFubmVsQ291bnQgPSAyXG4gICAgZ2Fpbi5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0J1xuICAgIGdhaW4uY2hhbm5lbEludGVycHJldGF0aW9uID0gJ3NwZWFrZXJzJ1xuICAgIHNvdXJjZS5nYWluID0gZ2FpblxuICAgIHNvdXJjZS5jb25uZWN0KGdhaW4pXG4gICAgc291cmNlLl9jb25uZWN0ID0gc291cmNlLmNvbm5lY3RcbiAgICBzb3VyY2UuY29ubmVjdCA9IGdhaW4uY29ubmVjdFxuICAgIGlmKGNiKSBjYihudWxsLCBzb3VyY2UpXG4gICAgKi9cbiAgICByZXR1cm4gc291cmNlXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWFzdGVyLCBzdHJlYW0pe1xuICAgIHZhciBub2RlID0gbWFzdGVyLmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSlcbiAgICB2YXIgZ2FpbiA9IG1hc3Rlci5jcmVhdGVHYWluKClcbiAgICBnYWluLmNoYW5uZWxDb3VudCA9IDFcbiAgICBnYWluLmNoYW5uZWxDb3VudE1vZGUgPSAnZXhwbGljaXQnXG4gICAgZ2Fpbi4gY2hhbm5lbEludGVycHJldGF0aW9uID0gJ3NwZWFrZXJzJ1xuICAgIG5vZGUuY29ubmVjdChnYWluKVxuICAgIHJldHVybiBnYWluXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbGYpe1xuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBldGMgPT4ge1xuICAgIGNvbnN0IFdlYkF1ZGlvQ29udGV4dCA9IHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dFxuICAgIHZhciBtYXN0ZXIgXG4gICAgdmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS8vLkV2ZW50RW1pdHRlciAvL3JlcXVpcmUoJy4vc2hhcmVkRW1pdHRlcicpXG4gICAgdmFyIGJ1cyA9IG5ldyBFbWl0dGVyKClcbiAgICBidXMub25jZSgnaWZyYW1lTG9hZGVkJywgZSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhlKVxuICAgICAgYnVzLmVtaXQoJ3BvbmcnLCB7Z29hdDogMX0pXG4gICAgICBidXMub24oJ2Nsb2NrJywgZSA9PiBjb25zb2xlLmxvZyhlKSlcbiAgICB9KVxuICAgIC8vdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4uL2lmcmFtYXJmaScpXG4gICAgLy92YXIgcGVlcmluZyA9IGlmcmFtZShyZXF1aXJlKCcuL3BlZXJpbmcuanMnKSlcbiAgICAvL3VpLnBlZXJpbmcuYXBwZW5kQ2hpbGQocGVlcmluZylcbiAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpXG4gICAgY29uc3Qgc2hvcnQgPSByZXF1aXJlKCdzaG9ydC11dWlkJyk7XG4gICAgY29uc3QgdG9hID0gcmVxdWlyZSgndG8tYXJyYXlidWZmZXInKVxuICAgIGNvbnN0IGJ0b2IgPSByZXF1aXJlKCdibG9iLXRvLWJ1ZmZlcicpXG4gICAgY29uc3QgdGhydSA9IHJlcXVpcmUoJ3Rocm91Z2gyJylcbiAgICB2YXIgc3RvcmUgPSByZXF1aXJlKCdzdG9yZScpXG4gICAgdmFyIGggPSByZXF1aXJlKCdoeXBlcnNjcmlwdCcpXG4gICAgdmFyIHNoYWpzID0gcmVxdWlyZSgnc2hhLmpzJylcbiAgICBjb25zdCBUaW1lID0gcmVxdWlyZSgnLi4vc2luY2Utd2hlbicpXG4gICAgdmFyIGptaWMgPSByZXF1aXJlKCcuLi9qc3ludGgtbWljL3N0cmVhbScpXG4gICAgdmFyIHNhbXBsZXIgPSByZXF1aXJlKCcuLi9qc3ludGgtZmlsZS1zYW1wbGUnKVxuICAgIHZhciBtZWRpYSBcbiAgICB2YXIgaW50ZXJ2YWwgPSAyMFxuICAgIHZhciBtaW1lID0gJ2F1ZGlvL29nZztjb2RlY3M9b3B1cydcbiAgICB2YXIgcnVucCA9cmVxdWlyZSgncnVuLXdhdGVyZmFsbCcpXG4gICAgdmFyIHtPZ2dPcHVzRGVjb2Rlcn0gPSByZXF1aXJlKCdvZ2ctb3B1cy1kZWNvZGVyJylcbiAgICB2YXIgT3B1c01lZGlhUmVjb3JkZXIgPSByZXF1aXJlKCdvcHVzLW1lZGlhLXJlY29yZGVyJykgXG4gICAgd2luZG93Lk1lZGlhUmVjb3JkZXIgPSBPcHVzTWVkaWFSZWNvcmRlcjtcblxuICAgIGJyb2FkY2FzdGluZyA9ICFzZWxmLnBhcmVudC5sb2NhdGlvbi5oYXNoLmxlbmd0aFxuICAgIHZhciBicHMgPSA0ODAwMFxuICAgIHRyeXtcbiAgICBnZXRBcHAoYnJvYWRjYXN0aW5nLCAoZXJyLCBhdWRpbykgPT57XG4gICAgICBjb25zb2xlLmxvZyhlcnIsIGF1ZGlvKVxuICAgICAgc2VsZi5wYXJlbnQucG9zdE1lc3NhZ2Uoe3R5cGU6ICdkZWJ1ZycsIGRhdGE6IGVycn0pXG4gICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBtc2cgPT57XG4gICAgICAvL2NvbnNvbGUubG9nKG1zZylcbiAgICAgICAgc3dpdGNoIChtc2cuZGF0YS50eXBlKXtcbiAgICAgICAgICBjYXNlICdwYXJhbSc6XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtc2cpXG4gICAgICAgICAgICBhdWRpb1ttc2cuZGF0YS5pZF0uZ2Fpbi52YWx1ZSA9IE1hdGgubWF4KDAsIG1zZy5kYXRhLmRhdGEpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncmVzdW1lJzpcbiAgICAgICAgICAgIGF1ZGlvLm1hc3Rlci5yZXN1bWUoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NhcHR1cmVNaWMnOlxuICAgICAgICAgICAgYXVkaW8ubWFzdGVyLnJlc3VtZSgpXG4gICAgICAgICAgICBhdWRpby5jYXB0dXJlTWljKChlcnIsIG1pYyk9PntcbiAgICAgIHNlbGYucGFyZW50LnBvc3RNZXNzYWdlKHt0eXBlOiAnZGVidWcnLCBkYXRhOiBlcnJ9KVxuICAgICAgc2VsZi5wYXJlbnQucG9zdE1lc3NhZ2Uoe3R5cGU6ICdkZWJ1ZycsIGRhdGE6ICEhbWljfSlcbiAgICAgICAgICAvLyAgICBsZXQge2VuY29kZXIsIG5vZGV9ICA9IGF1ZGlvLmNyZWF0ZUVuY29kZXIobXNnLmRhdGEuaWQpXG4gICAgICAgICAgLy8gICAgZW5jb2Rlci5zdGFydChpbnRlcnZhbClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvL3NldFRpbWVvdXQoZSA9PiB7YXVkaW8uYnJvYWRjYXN0ZW5jb2Rlci5zdG9wKCl9LCAzMDAwKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3N0YXJ0QnJvYWRjYXN0JzpcbiAgICAgICAgICAgIGF1ZGlvLm1hc3Rlci5yZXN1bWUoKVxuICAgICAgICAgICAgYXVkaW8uY2FwdHVyZU1pYygoZXJyLCBtaWMpPT57XG4gICAgICBzZWxmLnBhcmVudC5wb3N0TWVzc2FnZSh7dHlwZTogJ2RlYnVnJywgZGF0YTogZXJyfSlcbiAgICAgIHNlbGYucGFyZW50LnBvc3RNZXNzYWdlKHt0eXBlOiAnZGVidWcnLCBkYXRhOiAhIW1pY30pXG4gICAgICAgICAgICAgIGxldCB7ZW5jb2Rlciwgbm9kZX0gID0gYXVkaW8uY3JlYXRlRW5jb2RlcihhdWRpby5zcGxpdHRlciwgJ3JlY29yZCcpXG4gICAgICAgICAgICAgIGVuY29kZXIuc3RhcnQoaW50ZXJ2YWwpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy9zZXRUaW1lb3V0KGUgPT4ge2F1ZGlvLmJyb2FkY2FzdGVuY29kZXIuc3RvcCgpfSwgMzAwMClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhZGRQZWVyJzpcbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSBtc2cuZGF0YS5kYXRhID09ICdicm9hZGNhc3QnID8gYXVkaW8uc3BsaXR0ZXIgOiBhdWRpby5jYWxsbWl4ZXJcbiAgICAgICAgICAgIGxldCB7ZW5jb2Rlciwgbm9kZX0gPSBhdWRpby5jcmVhdGVFbmNvZGVyKHNvdXJjZSwgbXNnLmRhdGEuaWQpXG4gICAgICAgICAgICBlbmNvZGVyLnN0YXJ0KG1zZy5kYXRhLmludGVydmFsIHx8IGludGVydmFsKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3N0b3BCcm9hZGNhc3QnOlxuICAgICAgICAgICAgYXVkaW8uZW5jb2RlcnNbJ3JlY29yZCddLnN0b3AoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NhbGxCdWZmZXInOlxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhuZXcgc2hhanMoJ3NoYTI1NicpLnVwZGF0ZShtc2cuZGF0YS5kYXRhKS5kaWdlc3QoJ2hleCcpLG1zZy5kYXRhLmRhdGEubGVuZ3RoKVxuICAgICAgICAgIC8vYXBwLl9sb2cobmV3IHNoYWpzKCdzaGEyNTYnKS51cGRhdGUoYWIpLmRpZ2VzdCgnaGV4JykpXG4gICAgICAgICAgY29uc29sZS5sb2cobXNnKVxuICAgICAgICAgIGF1ZGlvLmNhbGxkZWNvZGVyLmRlY29kZShtc2cuZGF0YS5kYXRhKSBcblxuICAgICAgICAgIC8vY2IobnVsbCwgYXVkaW8pIFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NvdXJjZUJ1ZmZlcic6XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKG5ldyBzaGFqcygnc2hhMjU2JykudXBkYXRlKG1zZy5kYXRhLmRhdGEpLmRpZ2VzdCgnaGV4JyksbXNnLmRhdGEuZGF0YS5sZW5ndGgpXG4gICAgICAgICAgLy9hcHAuX2xvZyhuZXcgc2hhanMoJ3NoYTI1NicpLnVwZGF0ZShhYikuZGlnZXN0KCdoZXgnKSlcbiAgICAgICAgICBhdWRpby5zb3VyY2VkZWNvZGVyLmRlY29kZShtc2cuZGF0YS5kYXRhKSBcblxuICAgICAgICAgIC8vY2IobnVsbCwgYXVkaW8pIFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2FkZEF1ZGlvVHJhY2snOlxuICAgICAgICAgICAgYXVkaW8uYWRkQXVkaW9UcmFjayhtc2cuZGF0YS5pZCwgIG1zZy5kYXRhLmRhdGEpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXVkaW9UcmFja0NvbnRyb2wnOlxuICAgICAgICAgICAgbGV0IHRyYWNrID0gYXVkaW8udHJhY2tzW21zZy5kYXRhLmlkXSAvLz0gbXNnLmRhdGEuZGF0YVxuICAgICAgICAgICAgbGV0IGNtZCA9IGRhdGEubXNnLmRhdGFcbiAgICAgICAgICAgIGF1ZGlvW2NtZF0odHJhY2spXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSl9IGNhdGNoKGVycil7XG4gICAgICBzZWxmLnBhcmVudC5wb3N0TWVzc2FnZSh7dHlwZTogJ2RlYnVnJywgZGF0YTogZXJyLnRvU3RyaW5nKCl9KVxuICAgIFxuICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0QXBwKGJyb2FkY2FzdGluZywgY2Ipe1xuXG4gICAgY2xhc3MgQXBwIGV4dGVuZHMgcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyIHtcbiAgICBcbiAgICAgIGNvbnN0cnVjdG9yKG1hc3RlciwgYnJvYWRjYXN0aW5nPXRydWUpe1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0aW5nID0gYnJvYWRjYXN0aW5nXG4gICAgICAgIHRoaXMuZGVjb2RlcnMgPSB7fVxuICAgICAgICB0aGlzLmVuY29kZXJzID0ge31cbiAgICAgICAgdGhpcy50cmFja3MgPSB7fVxuICAgICAgICB0aGlzLm1hc3RlciA9IG1hc3RlclxuICAgICAgICB0aGlzLm1peGVyID0gbWFzdGVyLmNyZWF0ZUNoYW5uZWxNZXJnZXIoMTIpXG4gICAgICAgIHRoaXMuY2FsbG1peGVyID0gbWFzdGVyLmNyZWF0ZUNoYW5uZWxNZXJnZXIoMilcbiAgICAgICAgdGhpcy5tb25pdG9ybWl4ID0gbWFzdGVyLmNyZWF0ZUNoYW5uZWxNZXJnZXIoMTIpXG4gICAgICAgIHRoaXMubW9uaXRvciA9IG1hc3Rlci5jcmVhdGVHYWluKClcbiAgICAgICAgdGhpcy5zcGxpdHRlciA9IG1hc3Rlci5jcmVhdGVDaGFubmVsU3BsaXR0ZXIoMTIpXG4gICAgICAgIHRoaXMubWljID0gbWFzdGVyLmNyZWF0ZUdhaW4oKVxuICAgICAgICB0aGlzLmNhbGwgPSBtYXN0ZXIuY3JlYXRlR2FpbigpXG4gICAgICAgIHRoaXMudHJhY2sgPSBtYXN0ZXIuY3JlYXRlR2FpbigpXG4gICAgICAgIHRoaXMuc291cmNlID0gbWFzdGVyLmNyZWF0ZUdhaW4oKVxuXG4gICAgICAgIHRoaXMubWl4ZXIuY29ubmVjdCh0aGlzLnNwbGl0dGVyKVxuXG4gICAgICAgIHRoaXMubW9uaXRvcm1peC5jb25uZWN0KHRoaXMubW9uaXRvcilcbiAgICAgICAgdGhpcy5tb25pdG9yLmNvbm5lY3QobWFzdGVyLmRlc3RpbmF0aW9uKVxuXG4gICAgICAgIHRoaXMubWljLmNvbm5lY3QodGhpcy5jYWxsbWl4ZXIpXG4gICAgICAgIHRoaXMudHJhY2suY29ubmVjdCh0aGlzLmNhbGxtaXhlcilcbiAgICAgICAgXG4gICAgICAgIHRoaXMuY3JlYXRlRGVjb2Rlcih0aGlzLmNhbGwsICh7ZGVjb2Rlcn0pID0+IHtcbiAgICAgICAgICB0aGlzLmNhbGxkZWNvZGVyID0gZGVjb2RlclxuICAgICAgICAgfSlcbiAgICAgICAgdGhpcy5jcmVhdGVEZWNvZGVyKHRoaXMuc291cmNlLCAoe2RlY29kZXJ9KSA9PiB7XG4gICAgICAgICAgdGhpcy5zb3VyY2VkZWNvZGVyID0gZGVjb2RlclxuICAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIGlmKGJyb2FkY2FzdGluZyl7XG4gICAgICAgICAgdGhpcy5taWMuY29ubmVjdCh0aGlzLm1peGVyKVxuICAgICAgICAgIHRoaXMuY2FsbC5jb25uZWN0KHRoaXMubWl4ZXIpXG4gICAgICAgICAgdGhpcy50cmFjay5jb25uZWN0KHRoaXMubWl4ZXIpXG4gICAgICAgICAgdGhpcy5taWMuY29ubmVjdCh0aGlzLm1vbml0b3JtaXgpXG4gICAgICAgICAgdGhpcy5jYWxsLmNvbm5lY3QodGhpcy5tb25pdG9ybWl4KVxuICAgICAgICAgIHRoaXMudHJhY2suY29ubmVjdCh0aGlzLm1vbml0b3JtaXgpXG4gICAgICAgIH1cblxuICAgICAgICBlbHNle1xuICAgICAgICAgIHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5tb25pdG9ybWl4KVxuICAgICAgICAgIHRoaXMuY2FsbC5jb25uZWN0KHRoaXMubW9uaXRvcm1peClcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGFkZEF1ZGlvVHJhY2soaWQsIGJ1Zil7XG4gICAgICAgIHZhciBhID0gaCgnYXVkaW8uaW52ZXJ0Jywge2NvbnRyb2xzOiB0cnVlLCBpZDogaWQsIHNyYyA6IFVSTC5jcmVhdGVPYmplY3RVUkwoYnVmKX0pXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSlcbiAgICAgICAgdmFyIGMgPSB0aGlzLm1hc3Rlci5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UoYSlcbiAgICAgICAgY29uc29sZS5sb2coYSlcbiAgICAgICAgLy9hLmxvb3AgPSB0cnVlXG4gICAgICAgIGMuY29ubmVjdCh0aGlzLnRyYWNrKVxuXG4gICAgICB9XG5cbiAgICAgIHBsYXkoaWQpe1xuICAgICAgICBcbiAgICAgIH1cblxuICAgICAgY2FwdHVyZU1pYyAoY2IsIGNvbm5lY3QpIHtcbiAgICAgIC8vIFRPRE8gc291cmNlIGlzIGVpdGhlciB0aGUgbWVkaWFzdHJlYW0gb3IgYSBwZWVyIGNvbm5lY3Rpb25cbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICAgICAgYWRkTWVkaWEoKGVyciwgc3RyZWFtKSA9PntcblxuICAgICAgICAgIGlmKGVycikgY29uc29sZS5sb2coZXJyKVxuXG4gICAgICAgICAgY29uc3QgbWljID0gc2VsZi5tYXN0ZXIuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKSBcbiAgICAgICAgICBtaWMuY29ubmVjdChzZWxmLm1pYylcblxuICAgICAgICAgIHNlbGYubWVkaWFzdHJlYW0gPSBzdHJlYW1cbiAgICAgICAgICBzZWxmLm1pY25vZGUgPSBtaWNcbiAgICAgIFxuICAgICAgICAgIGNiKGVyciwgc3RyZWFtKVxuICAgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgfSlcbiAgICAgIH1cblxuXG4gICAgICBjcmVhdGVEZWNvZGVyKGNvbm5lY3QsIGNiKXtcbiAgICAgIFxuICAgICAgICBhc3luYyBmdW5jdGlvbiB3c20oc2VsZiwgY29ubmVjdCwgY2Ipe1xuXG4gICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBPZ2dPcHVzRGVjb2Rlcih7b25EZWNvZGUsIG9uRGVjb2RlQWxsfSlcblxuICAgICAgICAgIGZ1bmN0aW9uIG9uRGVjb2RlICgpIHtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBvbkRlY29kZUFsbCAoe2NoYW5uZWxEYXRhLCBzYW1wbGVzRGVjb2RlZCwgc2FtcGxlUmF0ZX0pIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coY2hhbm5lbERhdGEpXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHtzYW1wbGVzRGVjb2RlZCwgc2FtcGxlUmF0ZX0pXG4gICAgICAgICAgICBsZXQgc2FtID0gc2FtcGxlcihzZWxmLm1hc3RlciwgY2hhbm5lbERhdGEpXG4gICAgICAgICAgICBzYW0uY29ubmVjdChjb25uZWN0KVxuICAgICAgICAgICAgc2FtLnN0YXJ0KDApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgZGVjb2Rlci5yZWFkeVxuXG4gICAgICAgICAgbGV0IHBpZCA9IHNob3J0KCkuZ2VuZXJhdGUoKVxuXG4gICAgICAgICAgc2VsZi5kZWNvZGVyc1twaWRdID0ge1xuICAgICAgICAgICAgZGVjb2RlcjogZGVjb2RlclxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKGNiKSBjYih7ZGVjb2RlciwgcGlkfSlcbiAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHdzbSh0aGlzLCBjb25uZWN0LCBjYilcblxuICAgICAgfVxuXG4gICAgICBjcmVhdGVFbmNvZGVyKHNvdXJjZSwgaWQsIGNiKXtcbiAgICAgICAgY29uc3Qgd29ya2VyT3B0aW9ucyA9IHtcbiAgICAgICAgICBlbmNvZGVyV29ya2VyRmFjdG9yeTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JrZXIodG9iKGZzLnJlYWRGaWxlU3luYygnLi9wdWJsaWMvc3RhdGljL2VuY29kZXJXb3JrZXIudW1kLmpzJykpKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgT2dnT3B1c0VuY29kZXJXYXNtUGF0aDogdG9iKGZzLnJlYWRGaWxlU3luYygnLi9wdWJsaWMvc3RhdGljL09nZ09wdXNFbmNvZGVyLndhc20nKSksXG4gICAgICAgICAgV2ViTU9wdXNFbmNvZGVyV2FzbVBhdGg6IHRvYihmcy5yZWFkRmlsZVN5bmMoJy4vcHVibGljL3N0YXRpYy9XZWJNT3B1c0VuY29kZXIud2FzbScpKVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLm1hc3Rlci5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKClcbiAgICAgICAgbGV0IGVuY29kZXIgPSBuZXcgTWVkaWFSZWNvcmRlcihub2RlLnN0cmVhbSwge2F1ZGlvQml0c1BlclNlY29uZDpicHMsIG1pbWVUeXBlOm1pbWV9LCB3b3JrZXJPcHRpb25zKVxuICAgICAgICB0aGlzLmVuY29kZXJzW2lkXSA9IGVuY29kZXJcbiAgICAgICAgdmFyIGZpcnN0ID0gZmFsc2VcbiAgICAgICAgZW5jb2Rlci5hZGRFdmVudExpc3RlbmVyKCdkYXRhYXZhaWxhYmxlJywgZSA9PiB7XG4gICAgICAgICAgYnRvYihlLmRhdGEsIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhuZXcgc2hhanMoJ3NoYTI1NicpLnVwZGF0ZShidWYpLmRpZ2VzdCgnaGV4JykpXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGJ1ZiwgaWQpXG4gICAgICAgICAgICBpZihidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhdWRpb1NvdXJjZUJ1ZmZlcicsIFxuICAgICAgICAgICAgICAgIGRhdGE6IGJ1ZixcbiAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG5cbiAgICAgICAgc291cmNlLmNvbm5lY3Qobm9kZSlcblxuICAgICAgICByZXR1cm4ge2VuY29kZXIsIG5vZGV9XG4gICAgICB9XG4gICAgfVxuXG4gIHZhciBhdWRpbyA9IG5ldyBBcHAobmV3IFdlYkF1ZGlvQ29udGV4dCh7c2FtcGxlUmF0ZTogNDgwMDB9KSwgYnJvYWRjYXN0aW5nKVxuXG4gIGNiKG51bGwsIGF1ZGlvKVxuICB9XG5cbiAgXG5cblxuICAgIGZ1bmN0aW9uIHRvYihidWYsIHR5cGU9XCJhcHBsaWNhdGlvbi93YXNtXCIpe1xuICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW25ldyBCdWZmZXIoYnVmKS5idWZmZXJdLCB7dHlwZX0pKVxuICAgIH1cbiAgICAgXG5cbiAgICBmdW5jdGlvbiBhZGRNZWRpYShjYiwgYXVkaW89dHJ1ZSwgdmlkZW89ZmFsc2Upe1xuICAgICAgdmFyIGdhbSA9IHJlcXVpcmUoJ2dldHVzZXJtZWRpYScpXG4gICAgICAvLyBXZWIgd29ya2VyIGFuZCAud2FzbSBjb25maWd1cmF0aW9uLiBOb3RlOiBUaGlzIGlzIE5PVCBhIHBhcnQgb2YgVzNDIHN0YW5kYXJkLlxuICAgICAgZ2FtKHt2aWRlbywgYXVkaW99LCBmdW5jdGlvbihlcnIsIHN0cmVhbSl7XG4gICAgICAgIC8vY29uc29sZS5sb2coc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkpXG5cblxuICAgICAgICBjYihlcnIsIHN0cmVhbSlcbiAgICAgIH0pXG4gICAgIH0gICAgXG4gICAgIH0pXG59XG4iLCJcbnJlcXVpcmUoJ2RvbXJlYWR5JykocmUgPT4ge1xuICB2YXIgaCA9IHJlcXVpcmUoJ2h5cGVyc2NyaXB0JylcbiAgdmFyIHVpID0gcmVxdWlyZSgnZ2V0aWRzJykoKVxuICB2YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLy8uRXZlbnRFbWl0dGVyIC8vcmVxdWlyZSgnLi9zaGFyZWRFbWl0dGVyJylcbiAgdmFyIGJ1cyA9IG5ldyBFbWl0dGVyKClcbiAgYnVzLm9uY2UoJ2lmcmFtZUxvYWRlZCcsIGUgPT4ge1xuICAgIGNvbnNvbGUubG9nKGUpXG4gICAgYnVzLmVtaXQoJ3BvbmcnLCB7Z29hdDogMX0pXG4gICAgYnVzLm9uKCdjbG9jaycsIGUgPT4gY29uc29sZS5sb2coZSkpXG4gIH0pXG5cbiAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKVxuICB2YXIgUGVlciA9IHJlcXVpcmUoJ3NpbXBsZS1wZWVyJylcbiAgdmFyIHNpZ25hbGh1YiA9IHJlcXVpcmUoJ3NpZ25hbGh1YicpXG4gIGNvbnN0IHttYWtlQXV0b09ic2VydmFibGUsICBhdXRvcnVufSA9IHJlcXVpcmUoJ21vYngnKVxuICBjb25zdCBzaG9ydCA9IHJlcXVpcmUoJ3Nob3J0LXV1aWQnKTtcbiAgY29uc3QgdG9hID0gcmVxdWlyZSgndG8tYXJyYXlidWZmZXInKVxuICBjb25zdCBidG9iID0gcmVxdWlyZSgnYmxvYi10by1idWZmZXInKVxuICBjb25zdCB0aHJ1ID0gcmVxdWlyZSgndGhyb3VnaDInKVxuICB2YXIgc3RvcmUgPSByZXF1aXJlKCdzdG9yZScpXG4gIHZhciBzaGFqcyA9IHJlcXVpcmUoJ3NoYS5qcycpXG4gIGNvbnN0IFRpbWUgPSByZXF1aXJlKCcuLi9zaW5jZS13aGVuJylcbiAgdmFyIHJ1bnAgPXJlcXVpcmUoJ3J1bi13YXRlcmZhbGwnKVxuICB2YXIgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpXG4gIHZhciBtaW5pbWlzdCA9IHJlcXVpcmUoJ21pbmltaXN0JylcbiAgdmFyIGFyZ3YgPSBtaW5pbWlzdChwcm9jZXNzLmFyZ3YsIHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBob3N0OiAnZm9sa3N0YWNrLmNvbScsXG4gICAgICBwb3J0OiA4MCxcbiAgICAgIHByb3RvY29sOiAnaHR0cHMnXG4gICAgfVxuICB9KVxuICB2YXIgZGVidWIgPSBzaWduYWxodWIoJ2h0dHBzOi8vZm9sa3N0YWNrLmNvbTo4MCcsICdkZWJ1ZycpXG4gIC8vdmFyIHJldD1kZWJ1Yi5zdWJzY3JpYmUoJ3JldHVybicpXG4gIHZhciBtaW1lID0gJ2F1ZGlvL29nZydcbiAgdmFyIG1pbWUgPSAnYXVkaW8vb2dnO2NvZGVjcz1vcHVzJ1xuICBmdW5jdGlvbiBkbGluayhidWYsIG1pbWU9bWltZSl7XG4gIGxldCBmaWxlID0gbmV3IEJsb2IoW2J1Zl0sIHt0eXBlOm1pbWV9KVxuICAgbGV0IGEgPSBoKCdhJywgJ2Rvd25sb2FkJywge2hyZWY6IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSksIG5hbWU6bmV3IHNoYWpzKCdzaGEyNTYnKS51cGRhdGUoYnVmKS5kaWdlc3QoJ2hleCcpKycub2dnJywgZG93bmxvYWQ6dHJ1ZX0pXG4gICBjb25zb2xlLmxvZyhhKVxuICB1aS50cmFja3MuYXBwZW5kQ2hpbGQoYSlcbiAgfVxuXG4gIHZhciBhcHAgXG5cbiAgd2luZG93LnN0b3JlID0gc3RvcmVcbiAgaWYoIXN0b3JlLmdldCgncmVzZXQnKSkge1xuICAgICBcbiAgICBzdG9yZS5jbGVhckFsbCgpO1xuICAgIHN0b3JlLnNldCgncmVzZXQnLCB0cnVlKVxuICB9XG4gIHJ1bnAoW2luaXRTdGF0ZSwgaW5pdFVJLCBjYXB0dXJlTmV0d29ya10sIChlcnIsIGFwcCk9PntcbiAgICBhcHAgPSBhcHBcblxuICAgIHVpLmluaXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICBhcHAuX2xvZygnaW5pdCcpXG5cbiAgICAgIHRyeXtcbiAgICAgICAgaW5pdEF1ZGlvKGFwcCwgKGVyciwgYXBwKT0+e1xuICAgICAgICAgIGFwcC5fbG9nKGVycilcbiAgICAgICAgICAvL2FwcC5hdWRpby5zb3VyY2VTdHJlYW0ucGlwZShhcHAuYXVkaW8uc2lua1N0cmVhbSkgLy8gaGVoXG4gICAgICAgICAgaWYoYXBwLnNlc3Npb24uYnJvYWRjYXN0aW5nKSB7XG4gICAgICAgICAgICBhcHAubmV0d29yay5kaXN0YW5jZSA9IDFcbi8vICAgICAgICAgICAgYXBwLm5ldHdvcmsuc291cmNlU3RyZWFtID0gYXBwLmF1ZGlvLnNvdXJjZVN0cmVhbVxuICAgICAgICAgICBhcHAubmV0d29yay5pc1NlZWtXb3J0aHkoKVxuICAgICAgICAgICAgYXBwLm5ldHdvcmsuYWxsb3dDYWxscyhhcHAuc2Vzc2lvbi5zdHJlYW0pXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGUgPT4gYXBwLmF1ZGlvLnN0YXJ0KHticm9hZGNhc2luZzp0cnVlfSksIDEwMDApXG4gICAgICAgICAgICAgXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXBwLmF1ZGlvLnNlbmQoJ3Jlc3VtZScpIFxuICAgICAgICAgICAgYXBwLm5ldHdvcmsuc291cmNlU2VlaygpXG4gICAgICAgICAgICBidXMub24oJ3NvdXJjZVBlZXJDYXB0dXJlZCcsIGlkID0+IHtcbiAgICAgICAgICAgICAgLy9hcHAuYXVkaW8uc3RhcnQoMTAwMClcbiAgICAgICAgICAgICAgYXBwLm5ldHdvcmsuY29ubmVjdGlvbnNbaWRdLm9uKCdkYXRhJywgYnVmID0+IHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYXBwLmF1ZGlvLnNlbmQoJ3NvdXJjZUJ1ZmZlcicsIGJ1ZilcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnVzLm9uKCdjYWxsU291cmNlQ2FwdHVyZWQnLCBpZCA9PiB7XG4vLyAgICAgICAgICAgIGFwcC5hdWRpby5zZW5kKCdhZGRQZWVyJywgJ2NhbGxlcicsIGlkKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBhcHAubmV0d29yay5jb25uY2VjdGlvbnNbaWRdLm9uKCdkYXRhJywgYnVmID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYnVmKVxuICAgICAgICAgICAgICBhcHAuYXVkaW8uc2VuZCgnY2FsbEJ1ZmZlcicsIGJ1ZilcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgXG4gICAgICAgICAgfSlcbiAgICAgIH0pfSBjYXRjaCAoZXJyKXtcbiAgICAgICAgYXBwLl9sb2coZXJyKVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gIH0pXG5cblxuXG4gIGZ1bmN0aW9uIGluaXRTdGF0ZShjYil7XG5cbiAgICBjbGFzcyBBcHAge1xuICAgIFxuICAgICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5taWMgPSAxLzJcbiAgICAgICAgdGhpcy5tb25pdG9yID0gMFxuICAgICAgICB0aGlzLmNhbGwgPSAxLzJcbiAgICAgICAgdGhpcy50cmFjayA9IDEvMlxuICAgICAgICB0aGlzLnF1YWxpdHkgPSA2NDAwMFxuICAgICAgICB0aGlzLnVwZGF0ZSA9IG51bGxcbiAgICAgICAgbWFrZUF1dG9PYnNlcnZhYmxlKHRoaXMpXG4gICAgICB9XG5cbiAgICAgIHNldEdhaW4oZGlhbCwgdmFsdWUpe1xuICAgICAgICB0aGlzW2RpYWxdID0gdmFsdWVcbiAgICAgICAgdGhpcy51cGRhdGUgPSBbZGlhbCwgdmFsdWVdXG4gICAgICB9XG4gICAgXG4gICAgfVxuXG4gICAgY29uc3QgYXBwID0gbmV3IEFwcFxuICAgIGJ1cy5vbignYXBwU3RhdGVDaGFuZ2UnLCBlID0+e1xuICAgICAgYXBwLnNldEdhaW4oZVswXSwgZVsxXSlcbiAgICAgIGFwcC5hdWRpby5zZW5kKCdwYXJhbScsIGVbMV0sIGVbMF0pXG4gICAgfSlcbiAgICBsZXQgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpXG4gICAgdmFyIHNlc3Npb24gPSBzdG9yZS5nZXQoJ3Nlc3Npb24nKVxuICAgIGlmKCFzZXNzaW9uKSB7XG4gICAgICBzZXNzaW9uID0ge2lkOiBzaG9ydCgpLmdlbmVyYXRlKCkuc3BsaXQoKS5yZXZlcnNlKCkuam9pbigpLnNsaWNlKDAsMTEpfVxuICAgIH1cbiAgICBzZXNzaW9uLmJyb2FkY2FzdGluZyA9dHJ1ZSBcbiAgICBpZihoYXNoLmxlbmd0aCl7XG4gICAgICBzZXNzaW9uLnN0cmVhbSA9IGhhc2ggLy9zaG9ydCgpLmdlbmVyYXRlKCkuc3BsaXQoKS5yZXZlcnNlKCkuam9pbigpLnNsaWNlKDAsMTEpXG4gICAgICBzZXNzaW9uLmJyb2FkY2FzdGluZyA9IGZhbHNlXG4gICAgfVxuICAgIGVsc2Ugc2Vzc2lvbi5zdHJlYW0gPSBzZXNzaW9uLmlkIC8vc2hvcnQoKS5nZW5lcmF0ZSgpLnNwbGl0KCkucmV2ZXJzZSgpLmpvaW4oKS5zbGljZSgwLDExKVxuXG4gICAgYXBwLnNlc3Npb24gPSBzZXNzaW9uXG4gIGFwcC5fbG9nID0gZnVuY3Rpb24oX2lkKSB7IHJldHVybiBlID0+IHtcbiAgICAgIC8vdWkuZGVidWcuYXBwZW5kQ2hpbGQoaCgncCcsIGUudG9TdHJpbmcoKSkpICAgIFxuICAgICAgZGVidWIuYnJvYWRjYXN0KCdkZWJ1ZycsIEpTT04uc3RyaW5naWZ5KHtpZDogX2lkLCBsb2c6IGV9KSlcbiAgICAgIGNvbnNvbGUubG9nKGUpXG4gIH0gfShzZXNzaW9uLmJyb2FkY2FzdGluZyA/IHNlc3Npb24uaWQgOiBzZXNzaW9uLnN0cmVhbSlcbiAgICBzdG9yZS5zZXQoJ3Nlc3Npb24nLCBzZXNzaW9uKVxuICAgIGNvbnNvbGUubG9nKGFwcClcbiAgICBjYihudWxsLCBhcHApXG4gIH1cblxuXG4gIGZ1bmN0aW9uIGluaXRVSShhcHAsIGNiKXtcbiAgXG4gICAgYnVzLm9uKCdjYWxsZXInLCBtc2cgPT4ge1xuICAgICAgbGV0IGMgPSBoKCdidXR0b24nLCB7aWQ6IG1zZy5wZWVySWQsIG9uY2xpY2s6IGUgPT4gYnVzLmVtaXQoJ2NhbGwnLCB7cGVlcklkOiBlLnRhcmdldC5pZH0pfSlcbiAgICAgIHVpLnRyYWNrcy5hcHBlbmRDaGlsZChjKVxuICAgIH0pXG5cbiAgICB1aS5saXZlbGluay5pbm5lclRleHQgPSBgJHt3aW5kb3cubG9jYXRpb24uaHJlZn0jJHthcHAuc2Vzc2lvbi5zdHJlYW19YFxuICAgIHVpLmNvcHlidXR0b24ub25jaGFuZ2UgPSBlID0+IHtcbiAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHVpLmxpdmVsaW5rLmlubmVyVGV4dClcbiAgICB9XG4gICAgdWkucmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgIGFwcC5uZXR3b3JrLmluaXRDYWxsKGFwcC5zZXNzaW9uLnN0cmVhbSlcbiAgICAgIGFwcC5hdWRpby5zZW5kKCdjYXB0dXJlTWljJywgbnVsbCwgYXBwLnNlc3Npb24uc3RyZWFtKVxuICAgIH0pXG4gICAgdWkuZmlsZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0LmZpbGVzWzBdKVxuICAgICAgLy92YXIgYSA9IGgoJ2F1ZGlvLmludmVydCcsIHtjb250cm9sczogdHJ1ZSwgc3JjIDogVVJMLmNyZWF0ZU9iamVjdFVSTChlLnRhcmdldC5maWxlc1swXSl9KVxuICAgICAgLy91aS50cmFja3MuYXBwZW5kQ2hpbGQoYSlcbiAgICAgIC8vdmFyIGM9IGFwcC5hdWRpby5tYXN0ZXIuY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKGEpXG4gICAgICAvL2NvbnNvbGUubG9nKGEpXG4gICAgICAvL2MuY29ubmVjdChhcHAuYXVkaW8udHJhY2ttaXhlcilcbiAgICAgIGxldCBpZCA9IHNob3J0KCkuZ2VuZXJhdGUoKVxuICAgICAgLy9hcHAudHJhY2tzW2lkXSA9IFxuICAgICAgYXBwLmF1ZGlvLnNlbmQoJ2FkZEF1ZGlvVHJhY2snLCBlLnRhcmdldC5maWxlc1swXSwgaWQpIFxuICAgICAgYnRvYihlLnRhcmdldC5maWxlc1swXSwgKGVyciwgYnVmKSA9PiB7XG4gICAgICAgLy8gc2FtcGxlcihhcHAuYXVkaW8ubWFzdGVyLCBidWYuYnVmZmVyLCAoZXJyLCBub2RlKSA9PntcbiAgICAgICAgICAvL25vZGUuY29ubmVjdChhcHAuYXVkaW8ubWFzdGVyLmRlc3RpbmF0aW9uKVxuICAgICAgICAgIC8vbm9kZS5zdGFydCgwKVxuICAgICAgIC8vIH0pICAgICAgXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICA7W10uZm9yRWFjaC5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9cmFuZ2VdJyksIGUgPT4ge1xuICAgICAgZS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGV2ID0+IHtcbiAgICAgICAgYnVzLmVtaXQoJ2FwcFN0YXRlQ2hhbmdlJywgW2V2LnRhcmdldC5uYW1lLCBOdW1iZXIoZXYudGFyZ2V0LnZhbHVlKV0pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICA7W10uZm9yRWFjaC5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW11dGVdJyksIGUgPT4ge1xuICAgICAgZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBldiA9PiB7XG4gICAgICAgIGJ1cy5lbWl0KCdhcHBTdGF0ZUNoYW5nZScsIFtldi50YXJnZXQuZGF0YXNldC5tdXRlLCAtIGFwcFtldi50YXJnZXQuZGF0YXNldC5tdXRlXV0pXG4gICAgICB9KVxuICAgIH0pXG5cblxuICAgIHVpLm1vbml0b3JSYW5nZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0LnZhbHVlKVxuICAgICAgLy9idXMuZW1pdCgnYXBwU3RhdGVDaGFuZ2UnLCBbJ21vbml0b3InLCBOdW1iZXIoZS50YXJnZXQudmFsdWUpXSlcbiAgICAgIC8vYXBwLnNldEdhaW4oJ21vbml0b3InLCBOdW1iZXIoZS50YXJnZXQudmFsdWUpKVxuICAgIH0pXG5cbiAgICBjYihudWxsLGFwcClcblxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEF1ZGlvKGFwcCwgY2Ipe1xuICAgIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuLi9pZnJhbWFyZmknKVxuXG4gICAgdmFyIGF1ZGlvID0gaWZyYW1lKHJlcXVpcmUoJy4vYXVkaW8uanMnKSlcbiAgICB1aS50cmFja3MuYXBwZW5kQ2hpbGQoYXVkaW8pXG4gICAgXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBtc2cgPT4ge1xuICAgICAgLy9jb25zb2xlLmxvZyhtc2cuZGF0YS5kYXRhLmxlbmd0aClcbiAgICAgIC8vYXVkaW8uY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZSh7dHlwZTogJ3NpbmtCdWZmZXInLCBkYXRhOiBtc2cuZGF0YS5kYXRhfSlcbiAgICAgIFxuICAgICAgdmFyIHQgPSBtc2cuZGF0YS50eXBlIFxuICAgICAgaWYodCA9PSAnZGVidWcnKXtcbiAgICAgICAgYXBwLl9sb2cobXNnLmRhdGEuZGF0YSlcbiAgICAgIH1cbiAgICAgIGlmKHQgPT0gJ2F1ZGlvU291cmNlQnVmZmVyJykge1xuICAgICAgICBpZihtc2cuZGF0YS5pZCA9PSAncmVjb3JkJyl7fVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsZXQgdSA9IGFwcC5uZXR3b3JrLmNvbm5lY3Rpb25zW21zZy5kYXRhLmlkXSB8fCB7fVxuICAgICAgICAgIC8vY29uc29sZS5sb2cobXNnLCB1KVxuICAgICAgICAgIGlmKHUud3JpdGFibGUpIHUud3JpdGUobXNnLmRhdGEuZGF0YSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cblxuICAgIGZ1bmN0aW9uIHNlbmQodHlwZSwgZGF0YSwgaWQpe1xuICAgICAgYXVkaW8uY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZSh7dHlwZSwgZGF0YSwgaWR9KVxuICAgIH1cblxuXG4gICAgLy9zZXRUaW1lb3V0KCBlPT4gYXVkaW8uY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZSh7dHlwZTogJ3N0YXJ0QnJvYWRjYXN0J30pLCAxMDAwKVxuXG4gICAgYXBwLmF1ZGlvID0ge1xuICAgICAgaWZyYW1lIDogYXVkaW8sXG4gICAgICBzZW5kOiBzZW5kLFxuICAgICAgc3RhcnQ6IGUgPT4gc2VuZCgnc3RhcnRCcm9hZGNhc3QnKSxcbiAgICAgIHN0b3A6IGUgPT4gc2VuZCgnc3RvcEJyb2FkY2FzdCcpXG4gICAgfVxuICAgIGNiKG51bGwsIGFwcCkgXG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGluaXRDYXN0KGFwcCwgY2Ipe1xuICBcbiAgICAgIGFwcC5fbG9nKCdzdGF0ZUluaXQnKVxuICAgICAgY2IobnVsbCwgYXBwKVxuICAgIFxuICB9XG4gIGZ1bmN0aW9uIGNhcHR1cmVOZXR3b3JrKGFwcCwgY2IpIHtcbiAgY2xhc3MgTmV0d29yayB7IFxuXG4gICAgY29uc3RydWN0b3IoYXBwLCBhZGRyKXtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgICAvL2NvbnNvbGUubG9nKHN0YXRlLCBhZGRyKVxuICAgICAgdGhpcy5hcHAgPSBhcHBcbiAgICAgIHRoaXMuaHViID0gc2lnbmFsaHViKGFkZHIsIGFwcC5zZXNzaW9uLnN0cmVhbSlcbiAgICAgIHRoaXMuY2hhbm5lbCA9IGFwcC5zZXNzaW9uLnN0cmVhbVxuICAgICAgdGhpcy5pZCA9IGFwcC5zZXNzaW9uLmlkXG4gICAgICB0aGlzLnN0YXRlID0gYXBwLnN0YXRlXG4gICAgICB0aGlzLmNvbm5lY3Rpb25zID0ge31cbiAgICAgIHRoaXMuaHVicyA9IHt9IFxuICAgICAgdGhpcy5wZWVycyA9IHt9XG4gICAgICB0aGlzLmNhbGxlcnMgPSB7fVxuICAgICAgdGhpcy5jb25uZWN0aW5nID0ge31cbiAgICAgIHRoaXMuZGlzdGFuY2UgPSAxXG4gICAgICB0aGlzLm9mZmVyc091dCA9IDBcbiAgICAgIHRoaXMubWF4Q29ubmVjdGlvbnMgPSA0IC8vIHN0YXJ0IGxvdywgdGVzdCBoaWdoLCBhbHNvIGhlbHBzIHNwcmVhZCBlYXJseSBwY2FzdCB0ZXN0aW5nXG4gICAgICB0aGlzLmR1cmF0aW9uID0gbnVsbCAvLyBzaW5jZS13aGVuXG4gICAgICB0aGlzLmNoYW5uZWxzID0ge31cbiAgICAgIHRoaXMuZHVyYXRpb24gPSBuZXcgVGltZVxuICAgICAgdGhpcy5zaW5rU3RyZWFtID0gdGhydShidWYgPT4ge1xuICAgICAgICBmb3IodmFyIG4gaW4gdGhpcy5wZWVycyl7XG4gICAgICAgICAgbGV0IHAgPSB0aGlzLnBlZXJzW25dXG4gICAgICAgICAgaWYocC53cml0YWJsZSkgcC53cml0ZShidWYpXG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uIGNsb3NlKCl7fSlcbiAgICB9XG5cbiAgICBicm9hZGNhc3QoYnVmKXtcbiAgICAgIGZvcih2YXIgbiBpbiB0aGlzLnBlZXJzKSB0aGlzLnBlZXJzW25dLndyaXRlKGJ1ZilcbiAgICB9XG5cbiAgICBzZW5kKGJ1Zil7XG4gICAgICBmb3IodmFyIG4gaW4gdGhpcy5jYWxsZXJzKSB0aGlzLmNhbGxlcnNbbl0ud3JpdGUoYnVmKVxuICAgIH1cblxuICAgIGxvZygpe1xuICAgICAgY29uc29sZS5sb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgIH1cblxuICAgIGNsb3NlUGVlclNpZ25hbChhZGRyKXtcbiAgICAgIHRoaXMuaHViLnVuc3Vic2NyaWJlKGFkZHIpXG4gICAgICAvL2RlbGV0ZSB0aGlzLmNvbm5lY3Rpb25zW2FkZHJdXG4gICAgfVxuXG4gICAgZGlzYWxsb3dDYWxscyhpZCl7XG4gICAgICB0aGlzLmh1Yi51bnN1YnNjcmliZSgnY2FsbGVyOicrdGhpcy5pZClcbiAgICB9XG5cbiAgICBhbGxvd0NhbGxzKGlkKXtcbiAgICAgIGNvbnNvbGUubG9nKGlkKVxuICAgICAgbGV0IGNhbGxzID0gdGhpcy5odWIuc3Vic2NyaWJlKCdjYWxsZXI6JytpZClcbiAgICAgIGNhbGxzLm9uKCdkYXRhJywgbXNnPT57XG4gICAgICAgIGNvbnNvbGUubG9nKG1zZylcbiAgICAgICAgLy9tc2c9SlNPTi5wYXJzZShtc2cpXG4gICAgICAgIGJ1cy5lbWl0KCdjYWxsZXInLCBtc2cpXG4gICAgICB9KVxuICAgICAgYnVzLm9uY2UoJ2NhbGwnLCBtc2cgPT57XG4gICAgICAgIHRoaXMuY2FsbERpcmVjdChtc2cucGVlcklkKVxuICAgICAgfSlcblxuICAgIH1cblxuICAgIGluaXRDYWxsKGlkKXtcbiAgICAgIGxldCBtYXNrID0gc2hvcnQoKS5nZW5lcmF0ZSgpIFxuICAgICAgdGhpcy5odWIuYnJvYWRjYXN0KCdjYWxsZXI6JytpZCwge3BlZXJJZDogbWFza30pXG4gICAgICBsZXQgcGVlciA9IHRoaXMuaW5pdENvbm5lY3QoaWQsIGZhbHNlLCBtYXNrKVxuICAgICAgICAgICAgYXBwLmF1ZGlvLnNlbmQoJ2FkZFBlZXInLCAnY2FsbGVyJywgaWQpXG4gICAgICBwZWVyLm9uKCdjb25uZWN0JywgZSA9PntcbiAgICAgICAgdGhpcy5jYWxsZXJzW2lkXSA9IHBlZXJcbiAgICAgICAgYnVzLmVtaXQoJ2NhbGxTb3VyY2VDYXB0dXJlZCcsIGlkKVxuICAgICAgICBwZWVyLm9uKCdkYXRhJywgZSA9PiBjb25zb2xlLmxvZyhlKSlcbiAgICAgICAgXG4gICAgICB9KVxuICAgICAgXG4gICAgICBcbiAgICB9XG5cbiAgICBjYWxsRGlyZWN0KGlkKXtcbiAgICAgIGxldCBwZWVyID0gdGhpcy5pbml0Q29ubmVjdChpZCwgdHJ1ZSwgdGhpcy5pZClcbiAgICAgICAgICAgIGFwcC5hdWRpby5zZW5kKCdhZGRQZWVyJywgJ2NhbGxlcicsIGlkKVxuICAgICAgcGVlci5vbignY29ubmVjdCcsIGUgPT57XG4gICAgICAgIHRoaXMuY2FsbGVyc1tpZF0gPSBwZWVyXG4gICAgICAgIGJ1cy5lbWl0KCdjYWxsU291cmNlQ2FwdHVyZWQnLCBpZClcbiAgICAgICAgY29uc29sZS5sb2coJ0NBTEwgUEVFUiBDT05ORUNURUQnKVxuICAgICAgICBwZWVyLm9uKCdkYXRhJywgZSA9PiBjb25zb2xlLmxvZyhlKSlcblxuICAgICAgfSlcbiAgICB9XG5cbiAgICBzb3VyY2VTZWVrKCl7IC8vIGlkIGZvciBhIHBlZXIgc3RyZWFtXG4gICAgICB2YXIgc2VsZiA9IHRoaXMgXG4gICAgICBsZXQgbWFzayA9IHNob3J0KCkuZ2VuZXJhdGUoKVxuICAgICAgbGV0IG9mZmVyaW5ncyA9IHRoaXMuaHViLnN1YnNjcmliZShtYXNrKVxuICAgICAgdmFyIGJlc3QgPSAwLy9JbmZpbml0eVxuICAgICAgdmFyIGNob3NlblxuICAgICAgdmFyIHN0YXJ0ID0gbmV3IFRpbWVcbiAgICAgIG9mZmVyaW5ncy5vbignZGF0YScsIG9mZmVyID0+IHtcbiAgICAgICAgb2ZmZXIgPSBKU09OLnBhcnNlKG9mZmVyKVxuICAgICAgICBzZWxmLmFwcC5fbG9nKG9mZmVyKVxuICAgICAgICBsZXQgc2NvcmUgPSAoMSAvIG9mZmVyLmRpc3RhbmNlKSAqIG9mZmVyLmR1cmF0aW9uXG4gICAgICAgIGlmKHNjb3JlID4gYmVzdCkge1xuICAgICAgICAgIGJlc3QgPSBzY29yZSAvL29mZmVyLmRpc3RhbmNlXG4gICAgICAgICAgY2hvc2VuID0gb2ZmZXJcbiAgICAgICAgfVxuICAgICAgY29uc29sZS5sb2coY2hvc2VuKVxuICAgICAgfSlcbiAgICAgIGxldCB0MCA9IHNldFRpbWVvdXQoZSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhjaG9zZW4pXG4gICAgICAgIGlmKGNob3Nlbikge1xuICAgIC8vICAgICAgdGhpcy5odWIudW5zdWJzY3JpYmUobWFzaylcbiAgICAgICAgICAvLyBkbyBjaG9zZW5cbiAgICAgICAgICBidXMuZW1pdCgnc291cmNlUGVlcklkQ2FwdHVyZWQnLCBjaG9zZW4ucGVlcklkKVxuICAgICAgICAgIC8vc2VsZi5zb3VyY2VDYXAoY2hvc2VuKVxuICAgICAgICAgIGxldCBwZWVyID0gdGhpcy5pbml0Q29ubmVjdChjaG9zZW4ucGVlcklkLCB0cnVlLCBtYXNrKVxuICAgICAgICAgIHBlZXIub25jZSgnY29ubmVjdCcsIGUgPT4ge1xuICAgICAgICAgICAgYnVzLmVtaXQoJ3NvdXJjZVBlZXJDYXB0dXJlZCcsIGNob3Nlbi5wZWVySWQpXG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gY2hvc2VuLmRpc3RhbmNlICsgMVxuICAgICAgICAgICAgdGhpcy5zb3VyY2VTdHJlYW0gPSBwZWVyXG4gICAgICAgICAgICBzZWxmLmFwcC5fbG9nKCdTb3VyY2UgUGVlciBDYXB0dXJlZC4nKVxuICAgICAgICAgICAgc2VsZi5pc1NlZWtXb3J0aHkoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcGVlci5vbignY2xvc2UnLCBlID0+IHtcbiAgICAgICAgICAgIHNlbGYuYXBwLl9sb2coJ1NvdXJjZSBQZWVyIENsb3NlZCcpXG5cbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuYXBwLl9sb2coJ0VycjogTm8gc291cmNlIHBlZXIgZm91bmQuJykgICAgXG4gICAgICAgIH1cbiAgICAgIH0sIDMwMDApXG4gICAgICBcblxuICAgICAgdGhpcy5odWIuYnJvYWRjYXN0KCdzb3VyY2UnLCBcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHBlZXJJZDogbWFza1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgXG4gICAgfVxuXG4gICAgc2V0IHNvdXJjZVN0cmVhbShzdHJlYW0pe1xuICAgICAgdGhpcy5fc291cmNlU3RyZWFtID0gc3RyZWFtXG4gICAgICB0aGlzLmR1cmF0aW9uID0gbmV3IFRpbWUoKVxuICAgICAgLy9zdHJlYW0ucGlwZSh0aGlzLnNpbmtTdHJlYW0pXG4gICAgICAvL3N0cmVhbS5waXBlKGFwcC5hdWRpby5zaW5rU3RyZWFtKVxuICAgIH1cblxuICAgIGdldCBzb3VyY2VTdHJlYW0oKXtcbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VTdHJlYW1cbiAgICB9XG5cbiAgICB1bnNlZWthYmxlKHNlc3Npb24pe1xuICAgICAgaWYoc2VzaW9uKSB0aGlzLmh1Yi51bnN1YnNjcmliZShzZXNzaW9uKVxuICAgIH1cblxuICAgIGlzU2Vla1dvcnRoeSgpe1xuICAgICAgbGV0IHIgPSB0aGlzLm9mZmVyc091dCA8IHRoaXMubWF4Q29ubmVjdGlvbnNcbiAgICAgIGxldCBzID0gdGhpcy5tYXhDb25uZWN0aW9ucyA+IE9iamVjdC5rZXlzKHRoaXMuY29ubmVjdGlvbnMpLmxlbmd0aCAgXG4gICAgICBsZXQgcSA9IHIgJiYgcyBcbiAgICAgIHRoaXMuX3NlZWthYmxlID0gcVxuICAgICAgaWYocSkge1xuICAgICAgICB0aGlzLnNvdXJjZXIgPSB0aGlzLmh1Yi5zdWJzY3JpYmUoJ3NvdXJjZScpXG4gICAgICAgIHRoaXMuc291cmNlci5vbignZGF0YScsIG1zZyA9PiB0aGlzLnNlZWthYmxlKEpTT04ucGFyc2UobXNnKSkpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYodGhpcy5zb3VyY2VyKSB0aGlzLnNvdXJjZXIuY2xvc2UoKVxuICAgICAgICBcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9zZWVrYWJsZVxuICAgIH1cblxuICAgIHNldHN1YihpZCl7XG4gICAgICBpZih0aGlzLmh1YnNbaWRdKSByZXR1cm4gdGhpcy5odWJzW2lkXVxuICAgICAgZWxzZSB0aGlzLmh1YnNbaWRdID0gdGhpcy5odWIuc3Vic2NyaWJlKGlkKVxuICAgIH1cbiAgICBnZXRzdWIoaWQpe1xuICAgICAgcmV0dXJuIHRoaXMuaHVic1tpZF1cbiAgICB9XG5cbiAgICB1bnN1YihpZCl7XG4gICAgICBpZih0aGlzLmh1YnNbaWRdKSB7XG4gICAgICAgIHRoaXMuaHViLnVuc3Vic2NyaWJlKGlkKSBcbiAgICAgICAgZGVsZXRlIHRoaXMuaHVic1tpZF0gXG4gICAgICB9XG4gICAgfVxuXG4gICAgc2Vla2FibGUobXNnKXsgXG4gICAgdGhpcy5hcHAuX2xvZyhtc2cpXG4gICAgICBsZXQgc2VsZiA9IHRoaXNcbiAgICAgIGlmKGZhbHNlKSByZXR1cm4gLy8gfHwgTWF0aC5yYW5kb20oKSA8IDEgLyBNYXRoLnBvdyhzZWxmLmRpc3RhbmNlLCAyKSkgcmV0dXJuXG4gICAgICBlbHNle1xuICAgICAgICBzZWxmLm9mZmVyc091dCArPSAxXG4gICAgICAgIHNldFRpbWVvdXQoZT0+e1xuICAgICAgICAgIHRoaXMub2ZmZXJzT3V0LS1cbiAgICAgICAgICAvL3RoaXMuZGlzbml0KG1zZy5wZWVySWQsIG1hc2spXG4gICAgICAgIH0sIDExMTEqMzApXG4gICAgICAgIGxldCBtYXNrID0gc2hvcnQoKS5nZW5lcmF0ZSgpXG4gICAgICAgIGxldCBwZWVyID0gdGhpcy5pbml0Q29ubmVjdChtc2cucGVlcklkLCBmYWxzZSwgbWFzaylcbiAgICAgICAgcGVlci5vbmNlKCdjb25uZWN0JywgZSA9PntcbiAgICAgICAgICBzZWxmLnBlZXJzW21zZy5wZWVySWRdID0gcGVlclxuICAgICAgICAgIGFwcC5hdWRpby5zZW5kKCdhZGRQZWVyJywgJ2Jyb2FkY2FzdCcsIG1zZy5wZWVySWQpXG4gICAgICAgICAgc2VsZi5pc1NlZWtXb3J0aHkoKVxuICAgICAgICAgIC8vaWYoYXBwLmF1ZGlvLmZpcnN0QnJvYWRjYXN0QnVmZmVyKSBwZWVyLndyaXRlKGFwcC5hdWRpby5maXJzdEJyb2FkY2FzdEJ1ZmZlcilcbiAgICAgICAgfSlcbiAgICAgICAgcGVlci5vbmNlKCdjbG9zZScsIGUgPT57XG4gICAgICAgICAgZGVsZXRlIHNlbGYucGVlcnNbbXNnLnBlZXJJZF1cbiAgICAgICAgICBzZWxmLmlzU2Vla1dvcnRoeSgpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuaHViLmJyb2FkY2FzdChtc2cucGVlcklkLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcGVlcklkOiBtYXNrLFxuICAgICAgICAgIHRvOiBtc2cucGVlcklkLFxuICAgICAgICAgIGRpc3RhbmNlOiB0aGlzLmRpc3RhbmNlLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLnNpbmNlQmVnaW5OUygpXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIGRpc25pdChpZCwgbWFzayl7XG4gICAgICBkZWxldGUgdGhpcy5jb25uZWN0aW5nW2lkXVxuICAgICAgdGhpcy5pc1NlZWtXb3J0aHkoKVxuICAgICAgLy90aGlzLmh1Yi51bnN1YnNjcmliZShtYXNrKVxuICAgIH1cblxuICAgIGluaXRDb25uZWN0KGlkLCBpbml0LCBtYXNrKXtcbiAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgbGV0IHBpcGUgPSB0aGlzLmh1Yi5zdWJzY3JpYmUobWFzaylcbiAgICAgIHZhciBjYWxsZXIgPSBuZXcgUGVlcih7aW5pdGlhdG9yOiBpbml0LCB0cmlja2xlOiBmYWxzZSwgb2JqZWN0TW9kZTogZmFsc2V9KVxuICAgICAgdGhpcy5jb25uZWN0aW5nW2lkXSA9IGNhbGxlclxuICAgICAgcGlwZS5vbignZXJyb3InLCBlID0+IGNvbnNvbGUubG9nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpXG4gICAgICBwaXBlLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgICAgIC8vIGNhbGxlcklEXG4gICAgICAgIHZhciBwZWVyID0gc2VsZi5jb25uZWN0aW5nW2RhdGEucGVlcklkXVxuICAgICAgICBwZWVyLnNpZ25hbChkYXRhLnNpZ25hbClcbiAgICAgICAgcGVlci5vbmNlKCdjb25uZWN0JywgZSA9PiB7XG4gICAgICAgICAgLy8gY2xvc2UgbWFzayBodWJcbiAgICAgICAgfSlcbiAgICAgICAgLy91aS5jYWxsZXJzLmFwcGVuZENoaWxkKGgoJ2Rpdi5jYWxsZXInLCBoKCdidXR0b24uY29ubmVjdCcsIGBDb25uZWN0IHRvICR7ZGF0YS5uYW1lIHx8IGZyb219YCwge29uY2xpY2s6IF9jb25uZWN0fSkpKSAgXG4gICAgICB9KVxuICAgICAgY2FsbGVyLl9kZWJ1ZyA9IGNvbnNvbGUubG9nXG4gICAgICBjYWxsZXIub24oJ3NpZ25hbCcsIHNpZyA9PiB0aGlzLmh1Yi5icm9hZGNhc3QoaWQsIEpTT04uc3RyaW5naWZ5KHtwZWVySWQ6IG1hc2ssIHRvOiBpZCwgc2lnbmFsOiBzaWcgfSkpKVxuICAgICAgY2FsbGVyLm9uY2UoJ2Nvbm5lY3QnLCBlID0+IHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uc1tpZF0gPSBjYWxsZXJcbiAgICAgICAgdGhpcy5jb25uZWN0aW5nW2lkXSA9IG51bGxcbiAgICAgICAgY29uc29sZS5sb2coYGNvbm5lY3RlZCB0byAke09iamVjdC5rZXlzKHRoaXMuY29ubmVjdGlvbnMpLmxlbmd0aH0gcGVlcnNgKVxuICAgICAgfSlcbiAgICAgIGNhbGxlci5vbignY2xvc2UnLCBlID0+IHtcbiAgICAgICAgdGhpcy5kaXNuaXQoaWQsIG1hc2spXG4gICAgICB9KVxuICAgICAgY2FsbGVyLm9uKCdlcnJvcicsIGUgPT4gY29uc29sZS5sb2coZSkpXG4gICAgICByZXR1cm4gY2FsbGVyXG4gICAgfVxuICB9XG4gICAgdmFyIG5ldHdvcmsgPSBuZXcgTmV0d29yayhhcHAsIGFyZ3YucHJvdG9jb2wgKyAnOi8vJyArIGFyZ3YuaG9zdCArICc6JyArIGFyZ3YucG9ydClcbiAgICBhcHAuX2xvZygnbmV0Q2FwJylcbiAgICBhcHAubmV0d29yayA9IG5ldHdvcmtcblxuICAgIGNiKG51bGwsIGFwcClcbiAgfVxuXG59KVxuIiwidmFyIENvbnZlcnRlciA9IHJlcXVpcmUoJy4vc3JjL2NvbnZlcnRlcicpO1xuXG4vKipcbiAqIEZ1bmN0aW9uIGdldCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFscGhhYmV0IGFuZCByZXR1cm4gY29udmVydCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBzcmNBbHBoYWJldFxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IGRzdEFscGhhYmV0XG4gKlxuICogQHJldHVybnMge2Z1bmN0aW9uKG51bWJlcnxBcnJheSl9XG4gKi9cbmZ1bmN0aW9uIGFueUJhc2Uoc3JjQWxwaGFiZXQsIGRzdEFscGhhYmV0KSB7XG4gICAgdmFyIGNvbnZlcnRlciA9IG5ldyBDb252ZXJ0ZXIoc3JjQWxwaGFiZXQsIGRzdEFscGhhYmV0KTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8QXJyYXl9IG51bWJlclxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0ZXIuY29udmVydChudW1iZXIpO1xuICAgIH1cbn07XG5cbmFueUJhc2UuQklOID0gJzAxJztcbmFueUJhc2UuT0NUID0gJzAxMjM0NTY3JztcbmFueUJhc2UuREVDID0gJzAxMjM0NTY3ODknO1xuYW55QmFzZS5IRVggPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG5cbm1vZHVsZS5leHBvcnRzID0gYW55QmFzZTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29udmVydGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHNyY0FscGhhYmV0XG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gZHN0QWxwaGFiZXRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb252ZXJ0ZXIoc3JjQWxwaGFiZXQsIGRzdEFscGhhYmV0KSB7XG4gICAgaWYgKCFzcmNBbHBoYWJldCB8fCAhZHN0QWxwaGFiZXQgfHwgIXNyY0FscGhhYmV0Lmxlbmd0aCB8fCAhZHN0QWxwaGFiZXQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIGFscGhhYmV0Jyk7XG4gICAgfVxuICAgIHRoaXMuc3JjQWxwaGFiZXQgPSBzcmNBbHBoYWJldDtcbiAgICB0aGlzLmRzdEFscGhhYmV0ID0gZHN0QWxwaGFiZXQ7XG59XG5cbi8qKlxuICogQ29udmVydCBudW1iZXIgZnJvbSBzb3VyY2UgYWxwaGFiZXQgdG8gZGVzdGluYXRpb24gYWxwaGFiZXRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gbnVtYmVyIC0gbnVtYmVyIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9yIGFycmF5IG9mIHBvaW50c1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd8QXJyYXl9XG4gKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgIHZhciBpLCBkaXZpZGUsIG5ld2xlbixcbiAgICBudW1iZXJNYXAgPSB7fSxcbiAgICBmcm9tQmFzZSA9IHRoaXMuc3JjQWxwaGFiZXQubGVuZ3RoLFxuICAgIHRvQmFzZSA9IHRoaXMuZHN0QWxwaGFiZXQubGVuZ3RoLFxuICAgIGxlbmd0aCA9IG51bWJlci5sZW5ndGgsXG4gICAgcmVzdWx0ID0gdHlwZW9mIG51bWJlciA9PT0gJ3N0cmluZycgPyAnJyA6IFtdO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQobnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBcIicgKyBudW1iZXIgKyAnXCIgY29udGFpbnMgb2Ygbm9uLWFscGhhYmV0aWMgZGlnaXRzICgnICsgdGhpcy5zcmNBbHBoYWJldCArICcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3JjQWxwaGFiZXQgPT09IHRoaXMuZHN0QWxwaGFiZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbnVtYmVyTWFwW2ldID0gdGhpcy5zcmNBbHBoYWJldC5pbmRleE9mKG51bWJlcltpXSk7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgICAgZGl2aWRlID0gMDtcbiAgICAgICAgbmV3bGVuID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkaXZpZGUgPSBkaXZpZGUgKiBmcm9tQmFzZSArIG51bWJlck1hcFtpXTtcbiAgICAgICAgICAgIGlmIChkaXZpZGUgPj0gdG9CYXNlKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyTWFwW25ld2xlbisrXSA9IHBhcnNlSW50KGRpdmlkZSAvIHRvQmFzZSwgMTApO1xuICAgICAgICAgICAgICAgIGRpdmlkZSA9IGRpdmlkZSAlIHRvQmFzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3bGVuID4gMCkge1xuICAgICAgICAgICAgICAgIG51bWJlck1hcFtuZXdsZW4rK10gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IG5ld2xlbjtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5kc3RBbHBoYWJldC5zbGljZShkaXZpZGUsIGRpdmlkZSArIDEpLmNvbmNhdChyZXN1bHQpO1xuICAgIH0gd2hpbGUgKG5ld2xlbiAhPT0gMCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZCBudW1iZXIgd2l0aCBzb3VyY2UgYWxwaGFiZXRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IG51bWJlci5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGhpcy5zcmNBbHBoYWJldC5pbmRleE9mKG51bWJlcltpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnZlcnRlcjsiLCIvKiEgYmxvYi10by1idWZmZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbi8qIGdsb2JhbCBCbG9iLCBGaWxlUmVhZGVyICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvYlRvQnVmZmVyIChibG9iLCBjYikge1xuICBpZiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnIHx8ICEoYmxvYiBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgQmxvYicpXG4gIH1cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpXG4gIH1cblxuICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG5cbiAgZnVuY3Rpb24gb25Mb2FkRW5kIChlKSB7XG4gICAgcmVhZGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBvbkxvYWRFbmQsIGZhbHNlKVxuICAgIGlmIChlLmVycm9yKSBjYihlLmVycm9yKVxuICAgIGVsc2UgY2IobnVsbCwgQnVmZmVyLmZyb20ocmVhZGVyLnJlc3VsdCkpXG4gIH1cblxuICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIG9uTG9hZEVuZCwgZmFsc2UpXG4gIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxufVxuIiwiLyohXG4gKiBDcm9zcy1Ccm93c2VyIFNwbGl0IDEuMS4xXG4gKiBDb3B5cmlnaHQgMjAwNy0yMDEyIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPlxuICogQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogRUNNQVNjcmlwdCBjb21wbGlhbnQsIHVuaWZvcm0gY3Jvc3MtYnJvd3NlciBzcGxpdCBtZXRob2RcbiAqL1xuXG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYSByZWdleCBvciBzdHJpbmcgc2VwYXJhdG9yLiBNYXRjaGVzIG9mIHRoZVxuICogc2VwYXJhdG9yIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBhcnJheS4gSG93ZXZlciwgaWYgYHNlcGFyYXRvcmAgaXMgYSByZWdleCB0aGF0IGNvbnRhaW5zXG4gKiBjYXB0dXJpbmcgZ3JvdXBzLCBiYWNrcmVmZXJlbmNlcyBhcmUgc3BsaWNlZCBpbnRvIHRoZSByZXN1bHQgZWFjaCB0aW1lIGBzZXBhcmF0b3JgIGlzIG1hdGNoZWQuXG4gKiBGaXhlcyBicm93c2VyIGJ1Z3MgY29tcGFyZWQgdG8gdGhlIG5hdGl2ZSBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgYW5kIGNhbiBiZSB1c2VkIHJlbGlhYmx5XG4gKiBjcm9zcy1icm93c2VyLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXQuXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHNlcGFyYXRvciBSZWdleCBvciBzdHJpbmcgdG8gdXNlIGZvciBzZXBhcmF0aW5nIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0XSBNYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHQgYXJyYXkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHN1YnN0cmluZ3MuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEJhc2ljIHVzZVxuICogc3BsaXQoJ2EgYiBjIGQnLCAnICcpO1xuICogLy8gLT4gWydhJywgJ2InLCAnYycsICdkJ11cbiAqXG4gKiAvLyBXaXRoIGxpbWl0XG4gKiBzcGxpdCgnYSBiIGMgZCcsICcgJywgMik7XG4gKiAvLyAtPiBbJ2EnLCAnYiddXG4gKlxuICogLy8gQmFja3JlZmVyZW5jZXMgaW4gcmVzdWx0IGFycmF5XG4gKiBzcGxpdCgnLi53b3JkMSB3b3JkMi4uJywgLyhbYS16XSspKFxcZCspL2kpO1xuICogLy8gLT4gWycuLicsICd3b3JkJywgJzEnLCAnICcsICd3b3JkJywgJzInLCAnLi4nXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBzcGxpdCh1bmRlZikge1xuXG4gIHZhciBuYXRpdmVTcGxpdCA9IFN0cmluZy5wcm90b3R5cGUuc3BsaXQsXG4gICAgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYyhcIlwiKVsxXSA9PT0gdW5kZWYsXG4gICAgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICBzZWxmO1xuXG4gIHNlbGYgPSBmdW5jdGlvbihzdHIsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIGBuYXRpdmVTcGxpdGBcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09IFwiW29iamVjdCBSZWdFeHBdXCIpIHtcbiAgICAgIHJldHVybiBuYXRpdmVTcGxpdC5jYWxsKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSArIChzZXBhcmF0b3IubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiKSArIChzZXBhcmF0b3IuZXh0ZW5kZWQgPyBcInhcIiA6IFwiXCIpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyBcInlcIiA6IFwiXCIpLFxuICAgICAgLy8gRmlyZWZveCAzK1xuICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArIFwiZ1wiKSxcbiAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgc3RyICs9IFwiXCI7IC8vIFR5cGUtY29udmVydFxuICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoXCJeXCIgKyBzZXBhcmF0b3Iuc291cmNlICsgXCIkKD8hXFxcXHMpXCIsIGZsYWdzKTtcbiAgICB9XG4gICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAqL1xuICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmID8gLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgbGltaXQgPj4+IDA7IC8vIFRvVWludDMyKGxpbWl0KVxuICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cikpIHtcbiAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB1bmRlZjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdChcIlwiKSkge1xuICAgICAgICBvdXRwdXQucHVzaChcIlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59KSgpO1xuIiwiLy8gY29udGFpbnMsIGFkZCwgcmVtb3ZlLCB0b2dnbGVcbnZhciBpbmRleG9mID0gcmVxdWlyZSgnaW5kZXhvZicpXG5cbm1vZHVsZS5leHBvcnRzID0gQ2xhc3NMaXN0XG5cbmZ1bmN0aW9uIENsYXNzTGlzdChlbGVtKSB7XG4gICAgdmFyIGNsID0gZWxlbS5jbGFzc0xpc3RcblxuICAgIGlmIChjbCkge1xuICAgICAgICByZXR1cm4gY2xcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NMaXN0ID0ge1xuICAgICAgICBhZGQ6IGFkZFxuICAgICAgICAsIHJlbW92ZTogcmVtb3ZlXG4gICAgICAgICwgY29udGFpbnM6IGNvbnRhaW5zXG4gICAgICAgICwgdG9nZ2xlOiB0b2dnbGVcbiAgICAgICAgLCB0b1N0cmluZzogJHRvU3RyaW5nXG4gICAgICAgICwgbGVuZ3RoOiAwXG4gICAgICAgICwgaXRlbTogaXRlbVxuICAgIH1cblxuICAgIHJldHVybiBjbGFzc0xpc3RcblxuICAgIGZ1bmN0aW9uIGFkZCh0b2tlbikge1xuICAgICAgICB2YXIgbGlzdCA9IGdldFRva2VucygpXG4gICAgICAgIGlmIChpbmRleG9mKGxpc3QsIHRva2VuKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBsaXN0LnB1c2godG9rZW4pXG4gICAgICAgIHNldFRva2VucyhsaXN0KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZSh0b2tlbikge1xuICAgICAgICB2YXIgbGlzdCA9IGdldFRva2VucygpXG4gICAgICAgICAgICAsIGluZGV4ID0gaW5kZXhvZihsaXN0LCB0b2tlbilcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICBzZXRUb2tlbnMobGlzdClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250YWlucyh0b2tlbikge1xuICAgICAgICByZXR1cm4gaW5kZXhvZihnZXRUb2tlbnMoKSwgdG9rZW4pID4gLTFcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2dnbGUodG9rZW4pIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zKHRva2VuKSkge1xuICAgICAgICAgICAgcmVtb3ZlKHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGQodG9rZW4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gZWxlbS5jbGFzc05hbWVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVtKGluZGV4KSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBnZXRUb2tlbnMoKVxuICAgICAgICByZXR1cm4gdG9rZW5zW2luZGV4XSB8fCBudWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VG9rZW5zKCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gZWxlbS5jbGFzc05hbWVcblxuICAgICAgICByZXR1cm4gZmlsdGVyKGNsYXNzTmFtZS5zcGxpdChcIiBcIiksIGlzVHJ1dGh5KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFRva2VucyhsaXN0KSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aFxuXG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gbGlzdC5qb2luKFwiIFwiKVxuICAgICAgICBjbGFzc0xpc3QubGVuZ3RoID0gbGVuZ3RoXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3RbaV0gPSBsaXN0W2ldXG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgbGlzdFtsZW5ndGhdXG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXIgKGFyciwgZm4pIHtcbiAgICB2YXIgcmV0ID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZm4oYXJyW2ldKSkgcmV0LnB1c2goYXJyW2ldKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGlzVHJ1dGh5KHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWVcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IGVuYWJsZU92ZXJyaWRlID09PSBudWxsID8gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpIDogZW5hYmxlT3ZlcnJpZGUsXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQnJvd3NlckluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckluZm8obmFtZSwgdmVyc2lvbiwgb3MpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5vcyA9IG9zO1xuICAgIH1cbiAgICByZXR1cm4gQnJvd3NlckluZm87XG59KCkpO1xuZXhwb3J0cy5Ccm93c2VySW5mbyA9IEJyb3dzZXJJbmZvO1xudmFyIE5vZGVJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGVJbmZvKHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ25vZGUnO1xuICAgICAgICB0aGlzLm9zID0gcHJvY2Vzcy5wbGF0Zm9ybTtcbiAgICB9XG4gICAgcmV0dXJuIE5vZGVJbmZvO1xufSgpKTtcbmV4cG9ydHMuTm9kZUluZm8gPSBOb2RlSW5mbztcbnZhciBCb3RJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdEluZm8oKSB7XG4gICAgICAgIHRoaXMuYm90ID0gdHJ1ZTsgLy8gTk9URTogZGVwcmVjYXRlZCB0ZXN0IG5hbWUgaW5zdGVhZFxuICAgICAgICB0aGlzLm5hbWUgPSAnYm90JztcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBCb3RJbmZvO1xufSgpKTtcbmV4cG9ydHMuQm90SW5mbyA9IEJvdEluZm87XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG52YXIgU0VBUkNIQk9YX1VBX1JFR0VYID0gL2FsZXhhfGJvdHxjcmF3bChlcnxpbmcpfGZhY2Vib29rZXh0ZXJuYWxoaXR8ZmVlZGJ1cm5lcnxnb29nbGUgd2ViIHByZXZpZXd8bmFnaW9zfHBvc3RyYW5rfHBpbmdkb218c2x1cnB8c3BpZGVyfHlhaG9vIXx5YW5kZXgvO1xudmFyIFNFQVJDSEJPVF9PU19SRUdFWCA9IC8obnVoayl8KEdvb2dsZWJvdCl8KFlhbW15Ym90KXwoT3BlbmJvdCl8KFNsdXJwKXwoTVNOQm90KXwoQXNrIEplZXZlc1xcL1Rlb21hKXwoaWFfYXJjaGl2ZXIpLztcbnZhciBSRVFVSVJFRF9WRVJTSU9OX1BBUlRTID0gMztcbnZhciB1c2VyQWdlbnRSdWxlcyA9IFtcbiAgICBbJ2FvbCcsIC9BT0xTaGllbGRcXC8oWzAtOVxcLl9dKykvXSxcbiAgICBbJ2VkZ2UnLCAvRWRnZVxcLyhbMC05XFwuX10rKS9dLFxuICAgIFsnZWRnZS1pb3MnLCAvRWRnaU9TXFwvKFswLTlcXC5fXSspL10sXG4gICAgWyd5YW5kZXhicm93c2VyJywgL1lhQnJvd3NlclxcLyhbMC05XFwuX10rKS9dLFxuICAgIFsndml2YWxkaScsIC9WaXZhbGRpXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2tha2FvdGFsaycsIC9LQUtBT1RBTEtcXHMoWzAtOVxcLl0rKS9dLFxuICAgIFsnc2Ftc3VuZycsIC9TYW1zdW5nQnJvd3NlclxcLyhbMC05XFwuXSspL10sXG4gICAgWydzaWxrJywgL1xcYlNpbGtcXC8oWzAtOS5fLV0rKVxcYi9dLFxuICAgIFsnbWl1aScsIC9NaXVpQnJvd3NlclxcLyhbMC05XFwuXSspJC9dLFxuICAgIFsnYmVha2VyJywgL0JlYWtlckJyb3dzZXJcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnZWRnZS1jaHJvbWl1bScsIC9FZGdcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFtcbiAgICAgICAgJ2Nocm9taXVtLXdlYnZpZXcnLFxuICAgICAgICAvKD8hQ2hyb20uKk9QUil3dlxcKS4qQ2hyb20oPzplfGl1bSlcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS8sXG4gICAgXSxcbiAgICBbJ2Nocm9tZScsIC8oPyFDaHJvbS4qT1BSKUNocm9tKD86ZXxpdW0pXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgICBbJ3BoYW50b21qcycsIC9QaGFudG9tSlNcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnY3Jpb3MnLCAvQ3JpT1NcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnZmlyZWZveCcsIC9GaXJlZm94XFwvKFswLTlcXC5dKykoPzpcXHN8JCkvXSxcbiAgICBbJ2Z4aW9zJywgL0Z4aU9TXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ29wZXJhLW1pbmknLCAvT3BlcmEgTWluaS4qVmVyc2lvblxcLyhbMC05XFwuXSspL10sXG4gICAgWydvcGVyYScsIC9PcGVyYVxcLyhbMC05XFwuXSspKD86XFxzfCQpL10sXG4gICAgWydvcGVyYScsIC9PUFJcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnaWUnLCAvVHJpZGVudFxcLzdcXC4wLipydlxcOihbMC05XFwuXSspLipcXCkuKkdlY2tvJC9dLFxuICAgIFsnaWUnLCAvTVNJRVxccyhbMC05XFwuXSspOy4qVHJpZGVudFxcL1s0LTddLjAvXSxcbiAgICBbJ2llJywgL01TSUVcXHMoN1xcLjApL10sXG4gICAgWydiYjEwJywgL0JCMTA7XFxzVG91Y2guKlZlcnNpb25cXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnYW5kcm9pZCcsIC9BbmRyb2lkXFxzKFswLTlcXC5dKykvXSxcbiAgICBbJ2lvcycsIC9WZXJzaW9uXFwvKFswLTlcXC5fXSspLipNb2JpbGUuKlNhZmFyaS4qL10sXG4gICAgWydzYWZhcmknLCAvVmVyc2lvblxcLyhbMC05XFwuX10rKS4qU2FmYXJpL10sXG4gICAgWydmYWNlYm9vaycsIC9GQkFWXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2luc3RhZ3JhbScsIC9JbnN0YWdyYW1cXHMoWzAtOVxcLl0rKS9dLFxuICAgIFsnaW9zLXdlYnZpZXcnLCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS4qTW9iaWxlL10sXG4gICAgWydpb3Mtd2VidmlldycsIC9BcHBsZVdlYktpdFxcLyhbMC05XFwuXSspLipHZWNrb1xcKSQvXSxcbiAgICBbJ3NlYXJjaGJvdCcsIFNFQVJDSEJPWF9VQV9SRUdFWF0sXG5dO1xudmFyIG9wZXJhdGluZ1N5c3RlbVJ1bGVzID0gW1xuICAgIFsnaU9TJywgL2lQKGhvbmV8b2R8YWQpL10sXG4gICAgWydBbmRyb2lkIE9TJywgL0FuZHJvaWQvXSxcbiAgICBbJ0JsYWNrQmVycnkgT1MnLCAvQmxhY2tCZXJyeXxCQjEwL10sXG4gICAgWydXaW5kb3dzIE1vYmlsZScsIC9JRU1vYmlsZS9dLFxuICAgIFsnQW1hem9uIE9TJywgL0tpbmRsZS9dLFxuICAgIFsnV2luZG93cyAzLjExJywgL1dpbjE2L10sXG4gICAgWydXaW5kb3dzIDk1JywgLyhXaW5kb3dzIDk1KXwoV2luOTUpfChXaW5kb3dzXzk1KS9dLFxuICAgIFsnV2luZG93cyA5OCcsIC8oV2luZG93cyA5OCl8KFdpbjk4KS9dLFxuICAgIFsnV2luZG93cyAyMDAwJywgLyhXaW5kb3dzIE5UIDUuMCl8KFdpbmRvd3MgMjAwMCkvXSxcbiAgICBbJ1dpbmRvd3MgWFAnLCAvKFdpbmRvd3MgTlQgNS4xKXwoV2luZG93cyBYUCkvXSxcbiAgICBbJ1dpbmRvd3MgU2VydmVyIDIwMDMnLCAvKFdpbmRvd3MgTlQgNS4yKS9dLFxuICAgIFsnV2luZG93cyBWaXN0YScsIC8oV2luZG93cyBOVCA2LjApL10sXG4gICAgWydXaW5kb3dzIDcnLCAvKFdpbmRvd3MgTlQgNi4xKS9dLFxuICAgIFsnV2luZG93cyA4JywgLyhXaW5kb3dzIE5UIDYuMikvXSxcbiAgICBbJ1dpbmRvd3MgOC4xJywgLyhXaW5kb3dzIE5UIDYuMykvXSxcbiAgICBbJ1dpbmRvd3MgMTAnLCAvKFdpbmRvd3MgTlQgMTAuMCkvXSxcbiAgICBbJ1dpbmRvd3MgTUUnLCAvV2luZG93cyBNRS9dLFxuICAgIFsnT3BlbiBCU0QnLCAvT3BlbkJTRC9dLFxuICAgIFsnU3VuIE9TJywgL1N1bk9TL10sXG4gICAgWydDaHJvbWUgT1MnLCAvQ3JPUy9dLFxuICAgIFsnTGludXgnLCAvKExpbnV4KXwoWDExKS9dLFxuICAgIFsnTWFjIE9TJywgLyhNYWNfUG93ZXJQQyl8KE1hY2ludG9zaCkvXSxcbiAgICBbJ1FOWCcsIC9RTlgvXSxcbiAgICBbJ0JlT1MnLCAvQmVPUy9dLFxuICAgIFsnT1MvMicsIC9PU1xcLzIvXSxcbiAgICBbJ1NlYXJjaCBCb3QnLCBTRUFSQ0hCT1RfT1NfUkVHRVhdLFxuXTtcbmZ1bmN0aW9uIGRldGVjdCh1c2VyQWdlbnQpIHtcbiAgICBpZiAoISF1c2VyQWdlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVXNlckFnZW50KHVzZXJBZ2VudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gcGFyc2VVc2VyQWdlbnQobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICAgIHJldHVybiBnZXROb2RlVmVyc2lvbigpO1xufVxuZXhwb3J0cy5kZXRlY3QgPSBkZXRlY3Q7XG5mdW5jdGlvbiBwYXJzZVVzZXJBZ2VudCh1YSkge1xuICAgIC8vIG9wdGVkIGZvciB1c2luZyByZWR1Y2UgaGVyZSByYXRoZXIgdGhhbiBBcnJheSNmaXJzdCB3aXRoIGEgcmVnZXgudGVzdCBjYWxsXG4gICAgLy8gdGhpcyBpcyBwcmltYXJpbHkgYmVjYXVzZSB1c2luZyB0aGUgcmVkdWNlIHdlIG9ubHkgcGVyZm9ybSB0aGUgcmVnZXhcbiAgICAvLyBleGVjdXRpb24gb25jZSByYXRoZXIgdGhhbiBvbmNlIGZvciB0aGUgdGVzdCBhbmQgZm9yIHRoZSBleGVjIGFnYWluIGJlbG93XG4gICAgLy8gcHJvYmFibHkgc29tZXRoaW5nIHRoYXQgbmVlZHMgdG8gYmUgYmVuY2htYXJrZWQgdGhvdWdoXG4gICAgdmFyIG1hdGNoZWRSdWxlID0gdWEgIT09ICcnICYmXG4gICAgICAgIHVzZXJBZ2VudFJ1bGVzLnJlZHVjZShmdW5jdGlvbiAobWF0Y2hlZCwgX2EpIHtcbiAgICAgICAgICAgIHZhciBicm93c2VyID0gX2FbMF0sIHJlZ2V4ID0gX2FbMV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVhTWF0Y2ggPSByZWdleC5leGVjKHVhKTtcbiAgICAgICAgICAgIHJldHVybiAhIXVhTWF0Y2ggJiYgW2Jyb3dzZXIsIHVhTWF0Y2hdO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgaWYgKCFtYXRjaGVkUnVsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBtYXRjaGVkUnVsZVswXSwgbWF0Y2ggPSBtYXRjaGVkUnVsZVsxXTtcbiAgICBpZiAobmFtZSA9PT0gJ3NlYXJjaGJvdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCb3RJbmZvKCk7XG4gICAgfVxuICAgIHZhciB2ZXJzaW9uUGFydHMgPSBtYXRjaFsxXSAmJiBtYXRjaFsxXS5zcGxpdCgvWy5fXS8pLnNsaWNlKDAsIDMpO1xuICAgIGlmICh2ZXJzaW9uUGFydHMpIHtcbiAgICAgICAgaWYgKHZlcnNpb25QYXJ0cy5sZW5ndGggPCBSRVFVSVJFRF9WRVJTSU9OX1BBUlRTKSB7XG4gICAgICAgICAgICB2ZXJzaW9uUGFydHMgPSBfX3NwcmVhZEFycmF5cyh2ZXJzaW9uUGFydHMsIGNyZWF0ZVZlcnNpb25QYXJ0cyhSRVFVSVJFRF9WRVJTSU9OX1BBUlRTIC0gdmVyc2lvblBhcnRzLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2ZXJzaW9uUGFydHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCcm93c2VySW5mbyhuYW1lLCB2ZXJzaW9uUGFydHMuam9pbignLicpLCBkZXRlY3RPUyh1YSkpO1xufVxuZXhwb3J0cy5wYXJzZVVzZXJBZ2VudCA9IHBhcnNlVXNlckFnZW50O1xuZnVuY3Rpb24gZGV0ZWN0T1ModWEpIHtcbiAgICBmb3IgKHZhciBpaSA9IDAsIGNvdW50ID0gb3BlcmF0aW5nU3lzdGVtUnVsZXMubGVuZ3RoOyBpaSA8IGNvdW50OyBpaSsrKSB7XG4gICAgICAgIHZhciBfYSA9IG9wZXJhdGluZ1N5c3RlbVJ1bGVzW2lpXSwgb3MgPSBfYVswXSwgcmVnZXggPSBfYVsxXTtcbiAgICAgICAgdmFyIG1hdGNoID0gcmVnZXgudGVzdCh1YSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG9zO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5kZXRlY3RPUyA9IGRldGVjdE9TO1xuZnVuY3Rpb24gZ2V0Tm9kZVZlcnNpb24oKSB7XG4gICAgdmFyIGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb247XG4gICAgcmV0dXJuIGlzTm9kZSA/IG5ldyBOb2RlSW5mbyhwcm9jZXNzLnZlcnNpb24uc2xpY2UoMSkpIDogbnVsbDtcbn1cbmV4cG9ydHMuZ2V0Tm9kZVZlcnNpb24gPSBnZXROb2RlVmVyc2lvbjtcbmZ1bmN0aW9uIGNyZWF0ZVZlcnNpb25QYXJ0cyhjb3VudCkge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgY291bnQ7IGlpKyspIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJzAnKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbiIsIi8qIVxuICAqIGRvbXJlYWR5IChjKSBEdXN0aW4gRGlheiAyMDE0IC0gTGljZW5zZSBNSVRcbiAgKi9cbiFmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbikge1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnKSBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKVxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcpIGRlZmluZShkZWZpbml0aW9uKVxuICBlbHNlIHRoaXNbbmFtZV0gPSBkZWZpbml0aW9uKClcblxufSgnZG9tcmVhZHknLCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGZucyA9IFtdLCBsaXN0ZW5lclxuICAgICwgZG9jID0gZG9jdW1lbnRcbiAgICAsIGhhY2sgPSBkb2MuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsXG4gICAgLCBkb21Db250ZW50TG9hZGVkID0gJ0RPTUNvbnRlbnRMb2FkZWQnXG4gICAgLCBsb2FkZWQgPSAoaGFjayA/IC9ebG9hZGVkfF5jLyA6IC9ebG9hZGVkfF5pfF5jLykudGVzdChkb2MucmVhZHlTdGF0ZSlcblxuXG4gIGlmICghbG9hZGVkKVxuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihkb21Db250ZW50TG9hZGVkLCBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb21Db250ZW50TG9hZGVkLCBsaXN0ZW5lcilcbiAgICBsb2FkZWQgPSAxXG4gICAgd2hpbGUgKGxpc3RlbmVyID0gZm5zLnNoaWZ0KCkpIGxpc3RlbmVyKClcbiAgfSlcblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgbG9hZGVkID8gc2V0VGltZW91dChmbiwgMCkgOiBmbnMucHVzaChmbilcbiAgfVxuXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAdHlwZWRlZiB7eyBba2V5OiBzdHJpbmddOiBhbnkgfX0gRXh0ZW5zaW9uc1xuICogQHR5cGVkZWYge0Vycm9yfSBFcnJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gb2JqXG4gKiBAcGFyYW0ge0V4dGVuc2lvbnN9IHByb3BzXG4gKiBAcmV0dXJucyB7RXJyb3IgJiBFeHRlbnNpb25zfVxuICovXG5mdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge2FueX0gZXJyIC0gQW4gRXJyb3JcbiAqIEBwYXJhbSB7c3RyaW5nfEV4dGVuc2lvbnN9IGNvZGUgLSBBIHN0cmluZyBjb2RlIG9yIHByb3BzIHRvIHNldCBvbiB0aGUgZXJyb3JcbiAqIEBwYXJhbSB7RXh0ZW5zaW9uc30gW3Byb3BzXSAtIFByb3BzIHRvIHNldCBvbiB0aGUgZXJyb3JcbiAqIEByZXR1cm5zIHtFcnJvciAmIEV4dGVuc2lvbnN9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKGVyciwgY29kZSwgcHJvcHMpIHtcbiAgICBpZiAoIWVyciB8fCB0eXBlb2YgZXJyID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgcGFzcyBhbiBFcnJvciB0byBlcnItY29kZScpO1xuICAgIH1cblxuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvZGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHByb3BzID0gY29kZTtcbiAgICAgICAgY29kZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChjb2RlKSB7XG4gICAgICAgIHByb3BzLmNvZGUgPSBjb2RlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhc3NpZ24oZXJyLCBwcm9wcyk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgICBwcm9wcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgIHByb3BzLnN0YWNrID0gZXJyLnN0YWNrO1xuXG4gICAgICAgIGNvbnN0IEVyckNsYXNzID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgRXJyQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXJyKSk7XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBvdXRwdXQgPSBhc3NpZ24obmV3IEVyckNsYXNzKCksIHByb3BzKTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVFcnJvcjtcbiIsIi8qKlxuICogQGF1dGhvciBUb3J1IE5hZ2FzaGltYSA8aHR0cHM6Ly9naXRodWIuY29tL215c3RpY2F0ZWE+XG4gKiBAY29weXJpZ2h0IDIwMTUgVG9ydSBOYWdhc2hpbWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTZWUgTElDRU5TRSBmaWxlIGluIHJvb3QgZGlyZWN0b3J5IGZvciBmdWxsIGxpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQcml2YXRlRGF0YVxuICogQHByb3BlcnR5IHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwcm9wZXJ0eSB7e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBldmVudFBoYXNlIFRoZSBjdXJyZW50IGV2ZW50IHBoYXNlLlxuICogQHByb3BlcnR5IHtFdmVudFRhcmdldHxudWxsfSBjdXJyZW50VGFyZ2V0IFRoZSBjdXJyZW50IGV2ZW50IHRhcmdldC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2FuY2VsZWQgVGhlIGZsYWcgdG8gcHJldmVudCBkZWZhdWx0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBzdG9wcGVkIFRoZSBmbGFnIHRvIHN0b3AgcHJvcGFnYXRpb24gaW1tZWRpYXRlbHkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufG51bGx9IHBhc3NpdmVMaXN0ZW5lciBUaGUgbGlzdGVuZXIgaWYgdGhlIGN1cnJlbnQgbGlzdGVuZXIgaXMgcGFzc2l2ZS4gT3RoZXJ3aXNlIHRoaXMgaXMgbnVsbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lU3RhbXAgVGhlIHVuaXggdGltZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBQcml2YXRlIGRhdGEgZm9yIGV2ZW50IHdyYXBwZXJzLlxuICogQHR5cGUge1dlYWtNYXA8RXZlbnQsIFByaXZhdGVEYXRhPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHByaXZhdGVEYXRhID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBDYWNoZSBmb3Igd3JhcHBlciBjbGFzc2VzLlxuICogQHR5cGUge1dlYWtNYXA8T2JqZWN0LCBGdW5jdGlvbj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB3cmFwcGVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogR2V0IHByaXZhdGUgZGF0YS5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCBvYmplY3QgdG8gZ2V0IHByaXZhdGUgZGF0YS5cbiAqIEByZXR1cm5zIHtQcml2YXRlRGF0YX0gVGhlIHByaXZhdGUgZGF0YSBvZiB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwZChldmVudCkge1xuICAgIGNvbnN0IHJldHYgPSBwcml2YXRlRGF0YS5nZXQoZXZlbnQpO1xuICAgIGNvbnNvbGUuYXNzZXJ0KHJldHYgIT0gbnVsbCwgXCIndGhpcycgaXMgZXhwZWN0ZWQgYW4gRXZlbnQgb2JqZWN0LCBidXQgZ290XCIsIGV2ZW50KTtcbiAgICByZXR1cm4gcmV0dlxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbi8qKlxuICogVGhlIGV2ZW50IHdyYXBwZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgb2YgdGhpcyBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50IHRvIHdyYXAuXG4gKi9cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIHByaXZhdGVEYXRhLnNldCh0aGlzLCB7XG4gICAgICAgIGV2ZW50VGFyZ2V0LFxuICAgICAgICBldmVudCxcbiAgICAgICAgZXZlbnRQaGFzZTogMixcbiAgICAgICAgY3VycmVudFRhcmdldDogZXZlbnRUYXJnZXQsXG4gICAgICAgIGNhbmNlbGVkOiBmYWxzZSxcbiAgICAgICAgc3RvcHBlZDogZmFsc2UsXG4gICAgICAgIHBhc3NpdmVMaXN0ZW5lcjogbnVsbCxcbiAgICAgICAgdGltZVN0YW1wOiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKSxcbiAgICB9KTtcblxuICAgIC8vIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI1VuZm9yZ2VhYmxlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNUcnVzdGVkXCIsIHsgdmFsdWU6IGZhbHNlLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4gICAgLy8gRGVmaW5lIGFjY2Vzc29yc1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhldmVudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghKGtleSBpbiB0aGlzKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBTaG91bGQgYmUgZW51bWVyYWJsZSwgYnV0IGNsYXNzIG1ldGhvZHMgYXJlIG5vdCBlbnVtZXJhYmxlLlxuRXZlbnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50LnR5cGVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKi9cbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRUYXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH1cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudFRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmN1cnJlbnRUYXJnZXRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0V2ZW50VGFyZ2V0W119IFRoZSBjb21wb3NlZCBwYXRoIG9mIHRoaXMgZXZlbnQuXG4gICAgICovXG4gICAgY29tcG9zZWRQYXRoKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gcGQodGhpcykuY3VycmVudFRhcmdldDtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtjdXJyZW50VGFyZ2V0XVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBOT05FLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IE5PTkUoKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIENBUFRVUklOR19QSEFTRS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBDQVBUVVJJTkdfUEhBU0UoKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIEFUX1RBUkdFVC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBBVF9UQVJHRVQoKSB7XG4gICAgICAgIHJldHVybiAyXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIEJVQkJMSU5HX1BIQVNFLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IEJVQkJMSU5HX1BIQVNFKCkge1xuICAgICAgICByZXR1cm4gM1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRQaGFzZSgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50UGhhc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcyk7XG5cbiAgICAgICAgZGF0YS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGJ1YmJsaW5nLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBidWJibGVzKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5idWJibGVzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBjYW5jZWxhYmxlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjYW5jZWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5jYW5jZWxhYmxlKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgdGhpcyBldmVudC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHBkKHRoaXMpO1xuICAgICAgICBpZiAoZGF0YS5wYXNzaXZlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRXZlbnQjcHJldmVudERlZmF1bHQoKSB3YXMgY2FsbGVkIGZyb20gYSBwYXNzaXZlIGxpc3RlbmVyOlwiLCBkYXRhLnBhc3NpdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEuZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBpbmRpY2F0ZSBjYW5jZWxsYXRpb24gc3RhdGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGRlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5jYW5jZWxlZFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBjb21wb3NlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY29tcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmNvbXBvc2VkKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdW5peCB0aW1lIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgdGltZVN0YW1wKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykudGltZVN0YW1wXG4gICAgfSxcbn07XG5cbi8vIGBjb25zdHJ1Y3RvcmAgaXMgbm90IGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEV2ZW50LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuXG4vLyBFbnN1cmUgYGV2ZW50IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50YCBpcyBgdHJ1ZWAuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LkV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEV2ZW50LnByb3RvdHlwZSwgd2luZG93LkV2ZW50LnByb3RvdHlwZSk7XG5cbiAgICAvLyBNYWtlIGFzc29jaWF0aW9uIGZvciB3cmFwcGVycy5cbiAgICB3cmFwcGVycy5zZXQod2luZG93LkV2ZW50LnByb3RvdHlwZSwgRXZlbnQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byByZWRpcmVjdCBhIGdpdmVuIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBQcm9wZXJ0eSBuYW1lIHRvIGRlZmluZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcmVkaXJlY3QgdGhlIHByb3BlcnR5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFtrZXldXG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgcGQodGhpcykuZXZlbnRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byBjYWxsIGEgZ2l2ZW4gbWV0aG9kIHByb3BlcnR5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBQcm9wZXJ0eSBuYW1lIHRvIGRlZmluZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gY2FsbCB0aGUgbWV0aG9kIHByb3BlcnR5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUoKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHBkKHRoaXMpLmV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50W2tleV0uYXBwbHkoZXZlbnQsIGFyZ3VtZW50cylcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH1cbn1cblxuLyoqXG4gKiBEZWZpbmUgbmV3IHdyYXBwZXIgY2xhc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBCYXNlRXZlbnQgVGhlIGJhc2Ugd3JhcHBlciBjbGFzcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgcHJvdG90eXBlIG9mIHRoZSBvcmlnaW5hbCBldmVudC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIGRlZmluZWQgd3JhcHBlciBjbGFzcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVdyYXBwZXIoQmFzZUV2ZW50LCBwcm90bykge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm90byk7XG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCYXNlRXZlbnRcbiAgICB9XG5cbiAgICAvKiogQ3VzdG9tRXZlbnQgKi9cbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudFRhcmdldCwgZXZlbnQpIHtcbiAgICAgICAgQmFzZUV2ZW50LmNhbGwodGhpcywgZXZlbnRUYXJnZXQsIGV2ZW50KTtcbiAgICB9XG5cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IEN1c3RvbUV2ZW50LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgfSk7XG5cbiAgICAvLyBEZWZpbmUgYWNjZXNzb3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIShrZXkgaW4gQmFzZUV2ZW50LnByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBrZXkpO1xuICAgICAgICAgICAgY29uc3QgaXNGdW5jID0gKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgaXNGdW5jID8gZGVmaW5lQ2FsbERlc2NyaXB0b3Ioa2V5KSA6IGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50XG59XG5cbi8qKlxuICogR2V0IHRoZSB3cmFwcGVyIGNsYXNzIG9mIGEgZ2l2ZW4gcHJvdG90eXBlLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBwcm90b3R5cGUgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRvIGdldCBpdHMgd3JhcHBlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIHdyYXBwZXIgY2xhc3MuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRXcmFwcGVyKHByb3RvKSB7XG4gICAgaWYgKHByb3RvID09IG51bGwgfHwgcHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50XG4gICAgfVxuXG4gICAgbGV0IHdyYXBwZXIgPSB3cmFwcGVycy5nZXQocHJvdG8pO1xuICAgIGlmICh3cmFwcGVyID09IG51bGwpIHtcbiAgICAgICAgd3JhcHBlciA9IGRlZmluZVdyYXBwZXIoZ2V0V3JhcHBlcihPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pKSwgcHJvdG8pO1xuICAgICAgICB3cmFwcGVycy5zZXQocHJvdG8sIHdyYXBwZXIpO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlclxufVxuXG4vKipcbiAqIFdyYXAgYSBnaXZlbiBldmVudCB0byBtYW5hZ2VtZW50IGEgZGlzcGF0Y2hpbmcuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IG9mIHRoaXMgZGlzcGF0Y2hpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHRvIHdyYXAuXG4gKiBAcmV0dXJucyB7RXZlbnR9IFRoZSB3cmFwcGVyIGluc3RhbmNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgIGNvbnN0IFdyYXBwZXIgPSBnZXRXcmFwcGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkpO1xuICAgIHJldHVybiBuZXcgV3JhcHBlcihldmVudFRhcmdldCwgZXZlbnQpXG59XG5cbi8qKlxuICogR2V0IHRoZSBzdG9wcGVkIGZsYWcgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGZsYWcgdG8gc3RvcCBwcm9wYWdhdGlvbiBpbW1lZGlhdGVseS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU3RvcHBlZChldmVudCkge1xuICAgIHJldHVybiBwZChldmVudCkuc3RvcHBlZFxufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCBldmVudCBwaGFzZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHNldCBjdXJyZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBldmVudFBoYXNlIE5ldyBldmVudCBwaGFzZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0RXZlbnRQaGFzZShldmVudCwgZXZlbnRQaGFzZSkge1xuICAgIHBkKGV2ZW50KS5ldmVudFBoYXNlID0gZXZlbnRQaGFzZTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgdGFyZ2V0IG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtFdmVudFRhcmdldHxudWxsfSBjdXJyZW50VGFyZ2V0IE5ldyBjdXJyZW50IHRhcmdldC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0Q3VycmVudFRhcmdldChldmVudCwgY3VycmVudFRhcmdldCkge1xuICAgIHBkKGV2ZW50KS5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbn1cblxuLyoqXG4gKiBTZXQgYSBwYXNzaXZlIGxpc3RlbmVyIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbnxudWxsfSBwYXNzaXZlTGlzdGVuZXIgTmV3IHBhc3NpdmUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldFBhc3NpdmVMaXN0ZW5lcihldmVudCwgcGFzc2l2ZUxpc3RlbmVyKSB7XG4gICAgcGQoZXZlbnQpLnBhc3NpdmVMaXN0ZW5lciA9IHBhc3NpdmVMaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBMaXN0ZW5lck5vZGVcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiBAcHJvcGVydHkgezF8MnwzfSBsaXN0ZW5lclR5cGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGFzc2l2ZVxuICogQHByb3BlcnR5IHtib29sZWFufSBvbmNlXG4gKiBAcHJvcGVydHkge0xpc3RlbmVyTm9kZXxudWxsfSBuZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogQHR5cGUge1dlYWtNYXA8b2JqZWN0LCBNYXA8c3RyaW5nLCBMaXN0ZW5lck5vZGU+Pn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGxpc3RlbmVyc01hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIExpc3RlbmVyIHR5cGVzXG5jb25zdCBDQVBUVVJFID0gMTtcbmNvbnN0IEJVQkJMRSA9IDI7XG5jb25zdCBBVFRSSUJVVEUgPSAzO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3Qgb3Igbm90LlxuICogQHBhcmFtIHthbnl9IHggVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG59XG5cbi8qKlxuICogR2V0IGxpc3RlbmVycy5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgdG8gZ2V0LlxuICogQHJldHVybnMge01hcDxzdHJpbmcsIExpc3RlbmVyTm9kZT59IFRoZSBsaXN0ZW5lcnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZXZlbnRUYXJnZXQpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNNYXAuZ2V0KGV2ZW50VGFyZ2V0KTtcbiAgICBpZiAobGlzdGVuZXJzID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIid0aGlzJyBpcyBleHBlY3RlZCBhbiBFdmVudFRhcmdldCBvYmplY3QsIGJ1dCBnb3QgYW5vdGhlciB2YWx1ZS5cIilcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RlbmVyc1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgdGhlIGV2ZW50IGF0dHJpYnV0ZSBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBnZXQgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxpc3RlbmVyVHlwZSA9PT0gQVRUUklCVVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmxpc3RlbmVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LFxuXG4gICAgICAgIHNldChsaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiICYmICFpc09iamVjdChsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcblxuICAgICAgICAgICAgLy8gVHJhdmVyc2UgdG8gdGhlIHRhaWwgd2hpbGUgcmVtb3Zpbmcgb2xkIHZhbHVlLlxuICAgICAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXJUeXBlID09PSBBVFRSSUJVVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgbmV3IHZhbHVlLlxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyVHlwZTogQVRUUklCVVRFLFxuICAgICAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb25jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBuZXdOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH1cbn1cblxuLyoqXG4gKiBEZWZpbmUgYW4gZXZlbnQgYXR0cmlidXRlIChlLmcuIGBldmVudFRhcmdldC5vbmNsaWNrYCkuXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRUYXJnZXRQcm90b3R5cGUgVGhlIGV2ZW50IHRhcmdldCBwcm90b3R5cGUgdG8gZGVmaW5lIGFuIGV2ZW50IGF0dHJiaXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBkZWZpbmUuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGVmaW5lRXZlbnRBdHRyaWJ1dGUoZXZlbnRUYXJnZXRQcm90b3R5cGUsIGV2ZW50TmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudFRhcmdldFByb3RvdHlwZSwgYG9uJHtldmVudE5hbWV9YCwgZGVmaW5lRXZlbnRBdHRyaWJ1dGVEZXNjcmlwdG9yKGV2ZW50TmFtZSkpO1xufVxuXG4vKipcbiAqIERlZmluZSBhIGN1c3RvbSBFdmVudFRhcmdldCB3aXRoIGV2ZW50IGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBldmVudE5hbWVzIEV2ZW50IG5hbWVzIGZvciBldmVudCBhdHRyaWJ1dGVzLlxuICogQHJldHVybnMge0V2ZW50VGFyZ2V0fSBUaGUgY3VzdG9tIEV2ZW50VGFyZ2V0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQoZXZlbnROYW1lcykge1xuICAgIC8qKiBDdXN0b21FdmVudFRhcmdldCAqL1xuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50VGFyZ2V0KCkge1xuICAgICAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBDdXN0b21FdmVudFRhcmdldCwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgIH0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGRlZmluZUV2ZW50QXR0cmlidXRlKEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgZXZlbnROYW1lc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50VGFyZ2V0XG59XG5cbi8qKlxuICogRXZlbnRUYXJnZXQuXG4gKlxuICogLSBUaGlzIGlzIGNvbnN0cnVjdG9yIGlmIG5vIGFyZ3VtZW50cy5cbiAqIC0gVGhpcyBpcyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBDdXN0b21FdmVudFRhcmdldCBjb25zdHJ1Y3RvciBpZiB0aGVyZSBhcmUgYXJndW1lbnRzLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgICBjbGFzcyBBIGV4dGVuZHMgRXZlbnRUYXJnZXQge31cbiAqICAgICBjbGFzcyBCIGV4dGVuZHMgRXZlbnRUYXJnZXQoXCJtZXNzYWdlXCIpIHt9XG4gKiAgICAgY2xhc3MgQyBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiLCBcImVycm9yXCIpIHt9XG4gKiAgICAgY2xhc3MgRCBleHRlbmRzIEV2ZW50VGFyZ2V0KFtcIm1lc3NhZ2VcIiwgXCJlcnJvclwiXSkge31cbiAqL1xuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgbGlzdGVuZXJzTWFwLnNldCh0aGlzLCBuZXcgTWFwKCkpO1xuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmVDdXN0b21FdmVudFRhcmdldChhcmd1bWVudHNbMF0pXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0eXBlcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHR5cGVzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZpbmVDdXN0b21FdmVudFRhcmdldCh0eXBlcylcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKVxuICAgIC8qZXNsaW50LWVuYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xufVxuXG4vLyBTaG91bGQgYmUgZW51bWVyYWJsZSwgYnV0IGNsYXNzIG1ldGhvZHMgYXJlIG5vdCBlbnVtZXJhYmxlLlxuRXZlbnRUYXJnZXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEFkZCBhIGdpdmVuIGxpc3RlbmVyIHRvIHRoaXMgZXZlbnQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBhZGQuXG4gICAgICogQHBhcmFtIHtib29sZWFufHtjYXB0dXJlPzpib29sZWFuLHBhc3NpdmU/OmJvb2xlYW4sb25jZT86Ym9vbGVhbn19IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhpcyBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBsaXN0ZW5lciB3YXMgYWRkZWQgYWN0dWFsbHkuXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIgJiYgIWlzT2JqZWN0KGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidsaXN0ZW5lcicgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0LlwiKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBjb25zdCBvcHRpb25zSXNPYmogPSBpc09iamVjdChvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IG9wdGlvbnNJc09iaiA/IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKSA6IEJvb2xlYW4ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyVHlwZSA9IChjYXB0dXJlID8gQ0FQVFVSRSA6IEJVQkJMRSk7XG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgIGxpc3RlbmVyVHlwZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IG9wdGlvbnNJc09iaiAmJiBCb29sZWFuKG9wdGlvbnMucGFzc2l2ZSksXG4gICAgICAgICAgICBvbmNlOiBvcHRpb25zSXNPYmogJiYgQm9vbGVhbihvcHRpb25zLm9uY2UpLFxuICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTZXQgaXQgYXMgdGhlIGZpcnN0IG5vZGUgaWYgdGhlIGZpcnN0IG5vZGUgaXMgbnVsbC5cbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmF2ZXJzZSB0byB0aGUgdGFpbCB3aGlsZSBjaGVja2luZyBkdXBsaWNhdGlvbi4uXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmIG5vZGUubGlzdGVuZXJUeXBlID09PSBsaXN0ZW5lclR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgaWdub3JlIGR1cGxpY2F0aW9uLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGl0LlxuICAgICAgICBwcmV2Lm5leHQgPSBuZXdOb2RlO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBnaXZlbiBsaXN0ZW5lciBmcm9tIHRoaXMgZXZlbnQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufHtjYXB0dXJlPzpib29sZWFuLHBhc3NpdmU/OmJvb2xlYW4sb25jZT86Ym9vbGVhbn19IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhpcyBsaXN0ZW5lci5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZCBhY3R1YWxseS5cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBjb25zdCBjYXB0dXJlID0gaXNPYmplY3Qob3B0aW9ucykgPyBCb29sZWFuKG9wdGlvbnMuY2FwdHVyZSkgOiBCb29sZWFuKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lclR5cGUgPSAoY2FwdHVyZSA/IENBUFRVUkUgOiBCVUJCTEUpO1xuXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJiBub2RlLmxpc3RlbmVyVHlwZSA9PT0gbGlzdGVuZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBhIGdpdmVuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7RXZlbnR8e3R5cGU6c3RyaW5nfX0gZXZlbnQgVGhlIGV2ZW50IHRvIGRpc3BhdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgZmFsc2VgIGlmIGNhbmNlbGVkLlxuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIGNvbXBsZXhpdHlcbiAgICAgICAgaWYgKGV2ZW50ID09IG51bGwgfHwgdHlwZW9mIGV2ZW50LnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJcXFwiZXZlbnQudHlwZVxcXCIgc2hvdWxkIGJlIGEgc3RyaW5nLlwiKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbGlzdGVuZXJzIGFyZW4ndCByZWdpc3RlcmVkLCB0ZXJtaW5hdGUuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gZXZlbnQudHlwZTtcbiAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW5jZSB3ZSBjYW5ub3QgcmV3cml0ZSBzZXZlcmFsIHByb3BlcnRpZXMsIHNvIHdyYXAgb2JqZWN0LlxuICAgICAgICBjb25zdCB3cmFwcGVkRXZlbnQgPSB3cmFwRXZlbnQodGhpcywgZXZlbnQpO1xuXG4gICAgICAgIC8vIFRoaXMgZG9lc24ndCBwcm9jZXNzIGNhcHR1cmluZyBwaGFzZSBhbmQgYnViYmxpbmcgcGhhc2UuXG4gICAgICAgIC8vIFRoaXMgaXNuJ3QgcGFydGljaXBhdGluZyBpbiBhIHRyZWUuXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgbGlzdGVuZXIgaWYgaXQncyBvbmNlXG4gICAgICAgICAgICBpZiAobm9kZS5vbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGwgdGhpcyBsaXN0ZW5lclxuICAgICAgICAgICAgc2V0UGFzc2l2ZUxpc3RlbmVyKHdyYXBwZWRFdmVudCwgKG5vZGUucGFzc2l2ZSA/IG5vZGUubGlzdGVuZXIgOiBudWxsKSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUubGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIuY2FsbCh0aGlzLCB3cmFwcGVkRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5saXN0ZW5lclR5cGUgIT09IEFUVFJJQlVURSAmJiB0eXBlb2Ygbm9kZS5saXN0ZW5lci5oYW5kbGVFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lci5oYW5kbGVFdmVudCh3cmFwcGVkRXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCcmVhayBpZiBgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uYCB3YXMgY2FsbGVkLlxuICAgICAgICAgICAgaWYgKGlzU3RvcHBlZCh3cmFwcGVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBzZXRQYXNzaXZlTGlzdGVuZXIod3JhcHBlZEV2ZW50LCBudWxsKTtcbiAgICAgICAgc2V0RXZlbnRQaGFzZSh3cmFwcGVkRXZlbnQsIDApO1xuICAgICAgICBzZXRDdXJyZW50VGFyZ2V0KHdyYXBwZWRFdmVudCwgbnVsbCk7XG5cbiAgICAgICAgcmV0dXJuICF3cmFwcGVkRXZlbnQuZGVmYXVsdFByZXZlbnRlZFxuICAgIH0sXG59O1xuXG4vLyBgY29uc3RydWN0b3JgIGlzIG5vdCBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBFdmVudFRhcmdldCwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcblxuLy8gRW5zdXJlIGBldmVudFRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5FdmVudFRhcmdldGAgaXMgYHRydWVgLlxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5FdmVudFRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFdmVudFRhcmdldC5wcm90b3R5cGUsIHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUpO1xufVxuXG5leHBvcnRzLmRlZmluZUV2ZW50QXR0cmlidXRlID0gZGVmaW5lRXZlbnRBdHRyaWJ1dGU7XG5leHBvcnRzLkV2ZW50VGFyZ2V0ID0gRXZlbnRUYXJnZXQ7XG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFRhcmdldDtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldFxubW9kdWxlLmV4cG9ydHMuRXZlbnRUYXJnZXQgPSBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBFdmVudFRhcmdldFxubW9kdWxlLmV4cG9ydHMuZGVmaW5lRXZlbnRBdHRyaWJ1dGUgPSBkZWZpbmVFdmVudEF0dHJpYnV0ZVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnQtdGFyZ2V0LXNoaW0uanMubWFwXG4iLCIvLyBvcmlnaW5hbGx5IHB1bGxlZCBvdXQgb2Ygc2ltcGxlLXBlZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRCcm93c2VyUlRDICgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGxcbiAgdmFyIHdydGMgPSB7XG4gICAgUlRDUGVlckNvbm5lY3Rpb246IGdsb2JhbFRoaXMuUlRDUGVlckNvbm5lY3Rpb24gfHwgZ2xvYmFsVGhpcy5tb3pSVENQZWVyQ29ubmVjdGlvbiB8fFxuICAgICAgZ2xvYmFsVGhpcy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbixcbiAgICBSVENTZXNzaW9uRGVzY3JpcHRpb246IGdsb2JhbFRoaXMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIHx8XG4gICAgICBnbG9iYWxUaGlzLm1velJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fCBnbG9iYWxUaGlzLndlYmtpdFJUQ1Nlc3Npb25EZXNjcmlwdGlvbixcbiAgICBSVENJY2VDYW5kaWRhdGU6IGdsb2JhbFRoaXMuUlRDSWNlQ2FuZGlkYXRlIHx8IGdsb2JhbFRoaXMubW96UlRDSWNlQ2FuZGlkYXRlIHx8XG4gICAgICBnbG9iYWxUaGlzLndlYmtpdFJUQ0ljZUNhbmRpZGF0ZVxuICB9XG4gIGlmICghd3J0Yy5SVENQZWVyQ29ubmVjdGlvbikgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHdydGNcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWwpe1xuXG4gICAgdmFyIGlkcyA9IHt9O1xuXG4gICAgaWYoJ3N0cmluZycgPT0gdHlwZW9mIGVsKSBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsKTtcblxuICAgIGlmKCFlbCkgZWwgPSBkb2N1bWVudDtcblxuICAgIHZhciBjaGlsZHJlbiA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJyk7XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGNoaWxkcmVuLCBmdW5jdGlvbihlKXtcblxuXHRpZihlLmlkLmxlbmd0aCA+IDApe1xuXG5cdCAgICBpZHNbZS5pZF0gPSBlXG5cblx0fVxuXG4gICAgfSlcblxuICAgIHJldHVybiBpZHNcblxufVxuIiwiLy8gZ2V0VXNlck1lZGlhIGhlbHBlciBieSBASGVucmlrSm9yZXRlZyB1c2VkIGZvciBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHNoaW1cbnZhciBhZGFwdGVyID0gcmVxdWlyZSgnd2VicnRjLWFkYXB0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIGNiKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIHZhciBoYXZlT3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDI7XG4gICAgdmFyIGRlZmF1bHRPcHRzID0ge3ZpZGVvOiB0cnVlLCBhdWRpbzogdHJ1ZX07XG5cbiAgICB2YXIgZGVuaWVkID0gJ1Blcm1pc3Npb25EZW5pZWRFcnJvcic7XG4gICAgdmFyIGFsdERlbmllZCA9ICdQRVJNSVNTSU9OX0RFTklFRCc7XG4gICAgdmFyIG5vdFNhdGlzZmllZCA9ICdDb25zdHJhaW50Tm90U2F0aXNmaWVkRXJyb3InO1xuXG4gICAgLy8gbWFrZSBjb25zdHJhaW50cyBvcHRpb25hbFxuICAgIGlmICghaGF2ZU9wdHMpIHtcbiAgICAgICAgY2IgPSBjb25zdHJhaW50cztcbiAgICAgICAgY29uc3RyYWludHMgPSBkZWZhdWx0T3B0cztcbiAgICB9XG5cbiAgICAvLyB0cmVhdCBsYWNrIG9mIGJyb3dzZXIgc3VwcG9ydCBsaWtlIGFuIGVycm9yXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKXsgLy9nZXRVc2VyTWVkaWEpIHtcbiAgICAgICAgLy8gdGhyb3cgcHJvcGVyIGVycm9yIHBlciBzcGVjXG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNZWRpYVN0cmVhbUVycm9yJyk7XG4gICAgICAgIGVycm9yLm5hbWUgPSAnTm90U3VwcG9ydGVkRXJyb3InO1xuXG4gICAgICAgIC8vIGtlZXAgYWxsIGNhbGxiYWNrcyBhc3luY1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSBlcnJvciBoYW5kbGluZyB3aGVuIG5vIG1lZGlhIHR5cGVzIGFyZSByZXF1ZXN0ZWRcbiAgICBpZiAoIWNvbnN0cmFpbnRzLmF1ZGlvICYmICFjb25zdHJhaW50cy52aWRlbykge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTWVkaWFTdHJlYW1FcnJvcicpO1xuICAgICAgICBlcnJvci5uYW1lID0gJ05vTWVkaWFSZXF1ZXN0ZWRFcnJvcic7XG5cbiAgICAgICAgLy8ga2VlcCBhbGwgY2FsbGJhY2tzIGFzeW5jXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG4gICAgLnRoZW4oZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICBjYihudWxsLCBzdHJlYW0pO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBjb2VyY2UgaW50byBhbiBlcnJvciBvYmplY3Qgc2luY2UgRkYgZ2l2ZXMgdXMgYSBzdHJpbmdcbiAgICAgICAgLy8gdGhlcmUgYXJlIG9ubHkgdHdvIHZhbGlkIG5hbWVzIGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAgICAgICAvLyB3ZSBjb2VyY2UgYWxsIG5vbi1kZW5pZWQgdG8gXCJjb25zdHJhaW50IG5vdCBzYXRpc2ZpZWRcIi5cbiAgICAgICAgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTWVkaWFTdHJlYW1FcnJvcicpO1xuICAgICAgICAgICAgaWYgKGVyciA9PT0gZGVuaWVkIHx8IGVyciA9PT0gYWx0RGVuaWVkKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IGRlbmllZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IG5vdFNhdGlzZmllZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGdldCBhbiBlcnJvciBvYmplY3QgbWFrZSBzdXJlICcubmFtZScgcHJvcGVydHkgaXMgc2V0XG4gICAgICAgICAgICAvLyBhY2NvcmRpbmcgdG8gc3BlYzogaHR0cDovL2Rldi53My5vcmcvMjAxMS93ZWJydGMvZWRpdG9yL2dldHVzZXJtZWRpYS5odG1sI25hdmlnYXRvcnVzZXJtZWRpYWVycm9yLWFuZC1uYXZpZ2F0b3J1c2VybWVkaWFlcnJvcmNhbGxiYWNrXG4gICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIGlmICghZXJyb3IubmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbGlrZWx5IGNocm9tZSB3aGljaFxuICAgICAgICAgICAgICAgIC8vIHNldHMgYSBwcm9wZXJ0eSBjYWxsZWQgXCJFUlJPUl9ERU5JRURcIiBvbiB0aGUgZXJyb3Igb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gaWYgc28gd2UgbWFrZSBzdXJlIHRvIHNldCBhIG5hbWVcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JbZGVuaWVkXSkge1xuICAgICAgICAgICAgICAgICAgICBlcnIubmFtZSA9IGRlbmllZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnIubmFtZSA9IG5vdFNhdGlzZmllZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYihlcnJvcik7XG4gICAgfSk7XG59O1xuIiwidmFyIHNwbGl0ID0gcmVxdWlyZSgnYnJvd3Nlci1zcGxpdCcpXG52YXIgQ2xhc3NMaXN0ID0gcmVxdWlyZSgnY2xhc3MtbGlzdCcpXG5cbnZhciB3ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCdodG1sLWVsZW1lbnQnKSA6IHdpbmRvd1xudmFyIGRvY3VtZW50ID0gdy5kb2N1bWVudFxudmFyIFRleHQgPSB3LlRleHRcblxuZnVuY3Rpb24gY29udGV4dCAoKSB7XG5cbiAgdmFyIGNsZWFudXBGdW5jcyA9IFtdXG5cbiAgZnVuY3Rpb24gaCgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZSA9IG51bGxcbiAgICBmdW5jdGlvbiBpdGVtIChsKSB7XG4gICAgICB2YXIgclxuICAgICAgZnVuY3Rpb24gcGFyc2VDbGFzcyAoc3RyaW5nKSB7XG4gICAgICAgIC8vIE91ciBtaW5pbWFsIHBhcnNlciBkb2VzbuKAmXQgdW5kZXJzdGFuZCBlc2NhcGluZyBDU1Mgc3BlY2lhbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIGxpa2UgYCNgLiBEb27igJl0IHVzZSB0aGVtLiBNb3JlIHJlYWRpbmc6XG4gICAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9jc3MtZXNjYXBlcyAuXG5cbiAgICAgICAgdmFyIG0gPSBzcGxpdChzdHJpbmcsIC8oW1xcLiNdP1teXFxzIy5dKykvKVxuICAgICAgICBpZigvXlxcLnwjLy50ZXN0KG1bMV0pKVxuICAgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICBmb3JFYWNoKG0sIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgdmFyIHMgPSB2LnN1YnN0cmluZygxLHYubGVuZ3RoKVxuICAgICAgICAgIGlmKCF2KSByZXR1cm5cbiAgICAgICAgICBpZighZSlcbiAgICAgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHYpXG4gICAgICAgICAgZWxzZSBpZiAodlswXSA9PT0gJy4nKVxuICAgICAgICAgICAgQ2xhc3NMaXN0KGUpLmFkZChzKVxuICAgICAgICAgIGVsc2UgaWYgKHZbMF0gPT09ICcjJylcbiAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKCdpZCcsIHMpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmKGwgPT0gbnVsbClcbiAgICAgICAgO1xuICAgICAgZWxzZSBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGwpIHtcbiAgICAgICAgaWYoIWUpXG4gICAgICAgICAgcGFyc2VDbGFzcyhsKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobCkpXG4gICAgICB9XG4gICAgICBlbHNlIGlmKCdudW1iZXInID09PSB0eXBlb2YgbFxuICAgICAgICB8fCAnYm9vbGVhbicgPT09IHR5cGVvZiBsXG4gICAgICAgIHx8IGwgaW5zdGFuY2VvZiBEYXRlXG4gICAgICAgIHx8IGwgaW5zdGFuY2VvZiBSZWdFeHAgKSB7XG4gICAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobC50b1N0cmluZygpKSlcbiAgICAgIH1cbiAgICAgIC8vdGhlcmUgbWlnaHQgYmUgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG4gICAgICBlbHNlIGlmIChpc0FycmF5KGwpKVxuICAgICAgICBmb3JFYWNoKGwsIGl0ZW0pXG4gICAgICBlbHNlIGlmKGlzTm9kZShsKSlcbiAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gbClcbiAgICAgIGVsc2UgaWYobCBpbnN0YW5jZW9mIFRleHQpXG4gICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGwpXG4gICAgICBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZW9mIGwpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBsKSB7XG4gICAgICAgICAgaWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGxba10pIHtcbiAgICAgICAgICAgIGlmKC9eb25cXHcrLy50ZXN0KGspKSB7XG4gICAgICAgICAgICAgIChmdW5jdGlvbiAoaywgbCkgeyAvLyBjYXB0dXJlIGssIGwgaW4gdGhlIGNsb3N1cmVcbiAgICAgICAgICAgICAgICBpZiAoZS5hZGRFdmVudExpc3RlbmVyKXtcbiAgICAgICAgICAgICAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihrLnN1YnN0cmluZygyKSwgbFtrXSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUV2ZW50TGlzdGVuZXIoay5zdWJzdHJpbmcoMiksIGxba10sIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgIGUuYXR0YWNoRXZlbnQoaywgbFtrXSlcbiAgICAgICAgICAgICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGUuZGV0YWNoRXZlbnQoaywgbFtrXSlcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KShrLCBsKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgICBlW2tdID0gbFtrXSgpXG4gICAgICAgICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKGxba10oZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBlW2tdID0gdlxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZihrID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGxba10pIHtcbiAgICAgICAgICAgICAgZS5zdHlsZS5jc3NUZXh0ID0gbFtrXVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGZvciAodmFyIHMgaW4gbFtrXSkgKGZ1bmN0aW9uKHMsIHYpIHtcbiAgICAgICAgICAgICAgICBpZignZnVuY3Rpb24nID09PSB0eXBlb2Ygdikge1xuICAgICAgICAgICAgICAgICAgLy8gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCB2KCkpXG4gICAgICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaCh2KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCB2YWwpXG4gICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxba11bc10ubWF0Y2goLyguKilcXFcrIWltcG9ydGFudFxcVyokLyk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCBtYXRjaFsxXSwgJ2ltcG9ydGFudCcpXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlLnN0eWxlLnNldFByb3BlcnR5KHMsIGxba11bc10pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKHMsIGxba11bc10pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKGsgPT09ICdhdHRycycpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHYgaW4gbFtrXSkge1xuICAgICAgICAgICAgICBlLnNldEF0dHJpYnV0ZSh2LCBsW2tdW3ZdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChrLnN1YnN0cigwLCA1KSA9PT0gXCJkYXRhLVwiKSB7XG4gICAgICAgICAgICBlLnNldEF0dHJpYnV0ZShrLCBsW2tdKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlW2tdID0gbFtrXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgbCkge1xuICAgICAgICAvL2Fzc3VtZSBpdCdzIGFuIG9ic2VydmFibGUhXG4gICAgICAgIHZhciB2ID0gbCgpXG4gICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGlzTm9kZSh2KSA/IHYgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2KSlcblxuICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChsKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgaWYoaXNOb2RlKHYpICYmIHIucGFyZW50RWxlbWVudClcbiAgICAgICAgICAgIHIucGFyZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQodiwgciksIHIgPSB2XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgci50ZXh0Q29udGVudCA9IHZcbiAgICAgICAgfSkpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByXG4gICAgfVxuICAgIHdoaWxlKGFyZ3MubGVuZ3RoKVxuICAgICAgaXRlbShhcmdzLnNoaWZ0KCkpXG5cbiAgICByZXR1cm4gZVxuICB9XG5cbiAgaC5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xlYW51cEZ1bmNzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGNsZWFudXBGdW5jc1tpXSgpXG4gICAgfVxuICAgIGNsZWFudXBGdW5jcy5sZW5ndGggPSAwXG4gIH1cblxuICByZXR1cm4gaFxufVxuXG52YXIgaCA9IG1vZHVsZS5leHBvcnRzID0gY29udGV4dCgpXG5oLmNvbnRleHQgPSBjb250ZXh0XG5cbmZ1bmN0aW9uIGlzTm9kZSAoZWwpIHtcbiAgcmV0dXJuIGVsICYmIGVsLm5vZGVOYW1lICYmIGVsLm5vZGVUeXBlXG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKGFyciwgZm4pIHtcbiAgaWYgKGFyci5mb3JFYWNoKSByZXR1cm4gYXJyLmZvckVhY2goZm4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBmbihhcnJbaV0sIGkpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJ1xufVxuXG5cbiIsIlxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTsiLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmdzLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgXG4gICAgdmFyIGZsYWdzID0geyBib29scyA6IHt9LCBzdHJpbmdzIDoge30sIHVua25vd25GbjogbnVsbCB9O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRzWyd1bmtub3duJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmxhZ3MudW5rbm93bkZuID0gb3B0c1sndW5rbm93biddO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0c1snYm9vbGVhbiddID09PSAnYm9vbGVhbicgJiYgb3B0c1snYm9vbGVhbiddKSB7XG4gICAgICBmbGFncy5hbGxCb29scyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIFtdLmNvbmNhdChvcHRzWydib29sZWFuJ10pLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBmbGFncy5ib29sc1trZXldID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG9wdHMuYWxpYXMgfHwge30pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBhbGlhc2VzW2tleV0gPSBbXS5jb25jYXQob3B0cy5hbGlhc1trZXldKTtcbiAgICAgICAgYWxpYXNlc1trZXldLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGFsaWFzZXNbeF0gPSBba2V5XS5jb25jYXQoYWxpYXNlc1trZXldLmZpbHRlcihmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4ICE9PSB5O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIFtdLmNvbmNhdChvcHRzLnN0cmluZykuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBmbGFncy5zdHJpbmdzW2tleV0gPSB0cnVlO1xuICAgICAgICBpZiAoYWxpYXNlc1trZXldKSB7XG4gICAgICAgICAgICBmbGFncy5zdHJpbmdzW2FsaWFzZXNba2V5XV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgIH0pO1xuXG4gICAgdmFyIGRlZmF1bHRzID0gb3B0c1snZGVmYXVsdCddIHx8IHt9O1xuICAgIFxuICAgIHZhciBhcmd2ID0geyBfIDogW10gfTtcbiAgICBPYmplY3Qua2V5cyhmbGFncy5ib29scykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHNldEFyZyhrZXksIGRlZmF1bHRzW2tleV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogZGVmYXVsdHNba2V5XSk7XG4gICAgfSk7XG4gICAgXG4gICAgdmFyIG5vdEZsYWdzID0gW107XG5cbiAgICBpZiAoYXJncy5pbmRleE9mKCctLScpICE9PSAtMSkge1xuICAgICAgICBub3RGbGFncyA9IGFyZ3Muc2xpY2UoYXJncy5pbmRleE9mKCctLScpKzEpO1xuICAgICAgICBhcmdzID0gYXJncy5zbGljZSgwLCBhcmdzLmluZGV4T2YoJy0tJykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFyZ0RlZmluZWQoa2V5LCBhcmcpIHtcbiAgICAgICAgcmV0dXJuIChmbGFncy5hbGxCb29scyAmJiAvXi0tW149XSskLy50ZXN0KGFyZykpIHx8XG4gICAgICAgICAgICBmbGFncy5zdHJpbmdzW2tleV0gfHwgZmxhZ3MuYm9vbHNba2V5XSB8fCBhbGlhc2VzW2tleV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0QXJnIChrZXksIHZhbCwgYXJnKSB7XG4gICAgICAgIGlmIChhcmcgJiYgZmxhZ3MudW5rbm93bkZuICYmICFhcmdEZWZpbmVkKGtleSwgYXJnKSkge1xuICAgICAgICAgICAgaWYgKGZsYWdzLnVua25vd25GbihhcmcpID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gIWZsYWdzLnN0cmluZ3Nba2V5XSAmJiBpc051bWJlcih2YWwpXG4gICAgICAgICAgICA/IE51bWJlcih2YWwpIDogdmFsXG4gICAgICAgIDtcbiAgICAgICAgc2V0S2V5KGFyZ3YsIGtleS5zcGxpdCgnLicpLCB2YWx1ZSk7XG4gICAgICAgIFxuICAgICAgICAoYWxpYXNlc1trZXldIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBzZXRLZXkoYXJndiwgeC5zcGxpdCgnLicpLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEtleSAob2JqLCBrZXlzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgbyA9IG9iajtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aC0xOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChvW2tleV0gPT09IHVuZGVmaW5lZCkgb1trZXldID0ge307XG4gICAgICAgICAgICBpZiAob1trZXldID09PSBPYmplY3QucHJvdG90eXBlIHx8IG9ba2V5XSA9PT0gTnVtYmVyLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgIHx8IG9ba2V5XSA9PT0gU3RyaW5nLnByb3RvdHlwZSkgb1trZXldID0ge307XG4gICAgICAgICAgICBpZiAob1trZXldID09PSBBcnJheS5wcm90b3R5cGUpIG9ba2V5XSA9IFtdO1xuICAgICAgICAgICAgbyA9IG9ba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2tleXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSByZXR1cm47XG4gICAgICAgIGlmIChvID09PSBPYmplY3QucHJvdG90eXBlIHx8IG8gPT09IE51bWJlci5wcm90b3R5cGVcbiAgICAgICAgICAgIHx8IG8gPT09IFN0cmluZy5wcm90b3R5cGUpIG8gPSB7fTtcbiAgICAgICAgaWYgKG8gPT09IEFycmF5LnByb3RvdHlwZSkgbyA9IFtdO1xuICAgICAgICBpZiAob1trZXldID09PSB1bmRlZmluZWQgfHwgZmxhZ3MuYm9vbHNba2V5XSB8fCB0eXBlb2Ygb1trZXldID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob1trZXldKSkge1xuICAgICAgICAgICAgb1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb1trZXldID0gWyBvW2tleV0sIHZhbHVlIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gYWxpYXNJc0Jvb2xlYW4oa2V5KSB7XG4gICAgICByZXR1cm4gYWxpYXNlc1trZXldLnNvbWUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gZmxhZ3MuYm9vbHNbeF07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICAgIFxuICAgICAgICBpZiAoL14tLS4rPS8udGVzdChhcmcpKSB7XG4gICAgICAgICAgICAvLyBVc2luZyBbXFxzXFxTXSBpbnN0ZWFkIG9mIC4gYmVjYXVzZSBqcyBkb2Vzbid0IHN1cHBvcnQgdGhlXG4gICAgICAgICAgICAvLyAnZG90YWxsJyByZWdleCBtb2RpZmllci4gU2VlOlxuICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTA2ODMwOC8xMzIxNlxuICAgICAgICAgICAgdmFyIG0gPSBhcmcubWF0Y2goL14tLShbXj1dKyk9KFtcXHNcXFNdKikkLyk7XG4gICAgICAgICAgICB2YXIga2V5ID0gbVsxXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG1bMl07XG4gICAgICAgICAgICBpZiAoZmxhZ3MuYm9vbHNba2V5XSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgIT09ICdmYWxzZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRBcmcoa2V5LCB2YWx1ZSwgYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXi0tbm8tLisvLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGFyZy5tYXRjaCgvXi0tbm8tKC4rKS8pWzFdO1xuICAgICAgICAgICAgc2V0QXJnKGtleSwgZmFsc2UsIGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14tLS4rLy50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBhcmcubWF0Y2goL14tLSguKykvKVsxXTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gYXJnc1tpICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkICYmICEvXi0vLnRlc3QobmV4dClcbiAgICAgICAgICAgICYmICFmbGFncy5ib29sc1trZXldXG4gICAgICAgICAgICAmJiAhZmxhZ3MuYWxsQm9vbHNcbiAgICAgICAgICAgICYmIChhbGlhc2VzW2tleV0gPyAhYWxpYXNJc0Jvb2xlYW4oa2V5KSA6IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgbmV4dCwgYXJnKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXih0cnVlfGZhbHNlKSQvLnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0ID09PSAndHJ1ZScsIGFyZyk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgZmxhZ3Muc3RyaW5nc1trZXldID8gJycgOiB0cnVlLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eLVteLV0rLy50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIHZhciBsZXR0ZXJzID0gYXJnLnNsaWNlKDEsLTEpLnNwbGl0KCcnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGJyb2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZXR0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBhcmcuc2xpY2UoaisyKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBuZXh0LCBhcmcpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoL1tBLVphLXpdLy50ZXN0KGxldHRlcnNbal0pICYmIC89Ly50ZXN0KG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBuZXh0LnNwbGl0KCc9JylbMV0sIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoL1tBLVphLXpdLy50ZXN0KGxldHRlcnNbal0pXG4gICAgICAgICAgICAgICAgJiYgLy0/XFxkKyhcXC5cXGQqKT8oZS0/XFxkKyk/JC8udGVzdChuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgbmV4dCwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChsZXR0ZXJzW2orMV0gJiYgbGV0dGVyc1tqKzFdLm1hdGNoKC9cXFcvKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgYXJnLnNsaWNlKGorMiksIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIGZsYWdzLnN0cmluZ3NbbGV0dGVyc1tqXV0gPyAnJyA6IHRydWUsIGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIga2V5ID0gYXJnLnNsaWNlKC0xKVswXTtcbiAgICAgICAgICAgIGlmICghYnJva2VuICYmIGtleSAhPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbaSsxXSAmJiAhL14oLXwtLSlbXi1dLy50ZXN0KGFyZ3NbaSsxXSlcbiAgICAgICAgICAgICAgICAmJiAhZmxhZ3MuYm9vbHNba2V5XVxuICAgICAgICAgICAgICAgICYmIChhbGlhc2VzW2tleV0gPyAhYWxpYXNJc0Jvb2xlYW4oa2V5KSA6IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIGFyZ3NbaSsxXSwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmdzW2krMV0gJiYgL14odHJ1ZXxmYWxzZSkkLy50ZXN0KGFyZ3NbaSsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgYXJnc1tpKzFdID09PSAndHJ1ZScsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIGZsYWdzLnN0cmluZ3Nba2V5XSA/ICcnIDogdHJ1ZSwgYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWZsYWdzLnVua25vd25GbiB8fCBmbGFncy51bmtub3duRm4oYXJnKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBhcmd2Ll8ucHVzaChcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3Muc3RyaW5nc1snXyddIHx8ICFpc051bWJlcihhcmcpID8gYXJnIDogTnVtYmVyKGFyZylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuc3RvcEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgYXJndi5fLnB1c2guYXBwbHkoYXJndi5fLCBhcmdzLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWhhc0tleShhcmd2LCBrZXkuc3BsaXQoJy4nKSkpIHtcbiAgICAgICAgICAgIHNldEtleShhcmd2LCBrZXkuc3BsaXQoJy4nKSwgZGVmYXVsdHNba2V5XSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIChhbGlhc2VzW2tleV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBzZXRLZXkoYXJndiwgeC5zcGxpdCgnLicpLCBkZWZhdWx0c1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKG9wdHNbJy0tJ10pIHtcbiAgICAgICAgYXJndlsnLS0nXSA9IG5ldyBBcnJheSgpO1xuICAgICAgICBub3RGbGFncy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgYXJndlsnLS0nXS5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm90RmxhZ3MuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGFyZ3YuXy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcmd2O1xufTtcblxuZnVuY3Rpb24gaGFzS2V5IChvYmosIGtleXMpIHtcbiAgICB2YXIgbyA9IG9iajtcbiAgICBrZXlzLnNsaWNlKDAsLTEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBvID0gKG9ba2V5XSB8fCB7fSk7XG4gICAgfSk7XG5cbiAgICB2YXIga2V5ID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBrZXkgaW4gbztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIgKHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoL14weFswLTlhLWZdKyQvaS50ZXN0KHgpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gL15bLStdPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoZVstK10/XFxkKyk/JC8udGVzdCh4KTtcbn1cblxuIiwiXG4ndXNlIHN0cmljdCdcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vYnguY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2J4LmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBuaWNlRXJyb3JzID0ge1xuICAwOiBcIkludmFsaWQgdmFsdWUgZm9yIGNvbmZpZ3VyYXRpb24gJ2VuZm9yY2VBY3Rpb25zJywgZXhwZWN0ZWQgJ25ldmVyJywgJ2Fsd2F5cycgb3IgJ29ic2VydmVkJ1wiLFxuICAxOiBmdW5jdGlvbiBfKGFubm90YXRpb25UeXBlLCBrZXkpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGUgKyBcIicgdG8gJ1wiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6IEZpZWxkIG5vdCBmb3VuZC5cIjtcbiAgfSxcblxuICAvKlxyXG4gIDIocHJvcCkge1xyXG4gICAgICByZXR1cm4gYGludmFsaWQgZGVjb3JhdG9yIGZvciAnJHtwcm9wLnRvU3RyaW5nKCl9J2BcclxuICB9LFxyXG4gIDMocHJvcCkge1xyXG4gICAgICByZXR1cm4gYENhbm5vdCBkZWNvcmF0ZSAnJHtwcm9wLnRvU3RyaW5nKCl9JzogYWN0aW9uIGNhbiBvbmx5IGJlIHVzZWQgb24gcHJvcGVydGllcyB3aXRoIGEgZnVuY3Rpb24gdmFsdWUuYFxyXG4gIH0sXHJcbiAgNChwcm9wKSB7XHJcbiAgICAgIHJldHVybiBgQ2Fubm90IGRlY29yYXRlICcke3Byb3AudG9TdHJpbmcoKX0nOiBjb21wdXRlZCBjYW4gb25seSBiZSB1c2VkIG9uIGdldHRlciBwcm9wZXJ0aWVzLmBcclxuICB9LFxyXG4gICovXG4gIDU6IFwiJ2tleXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cywgc2V0cyBhbmQgbWFwc1wiLFxuICA2OiBcIid2YWx1ZXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cywgc2V0cyBhbmQgbWFwc1wiLFxuICA3OiBcIidlbnRyaWVzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgODogXCInc2V0KCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgOTogXCIncmVtb3ZlKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgMTA6IFwiJ2hhcygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDExOiBcIidnZXQoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICAxMjogXCJJbnZhbGlkIGFubm90YXRpb25cIixcbiAgMTM6IFwiRHluYW1pYyBvYnNlcnZhYmxlIG9iamVjdHMgY2Fubm90IGJlIGZyb3plblwiLFxuICAxNDogXCJJbnRlcmNlcHQgaGFuZGxlcnMgc2hvdWxkIHJldHVybiBub3RoaW5nIG9yIGEgY2hhbmdlIG9iamVjdFwiLFxuICAxNTogXCJPYnNlcnZhYmxlIGFycmF5cyBjYW5ub3QgYmUgZnJvemVuXCIsXG4gIDE2OiBcIk1vZGlmaWNhdGlvbiBleGNlcHRpb246IHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmUgb2YgYW4gb2JzZXJ2YWJsZSBhcnJheSB3YXMgY2hhbmdlZC5cIixcbiAgMTc6IGZ1bmN0aW9uIF8oaW5kZXgsIGxlbmd0aCkge1xuICAgIHJldHVybiBcIlttb2J4LmFycmF5XSBJbmRleCBvdXQgb2YgYm91bmRzLCBcIiArIGluZGV4ICsgXCIgaXMgbGFyZ2VyIHRoYW4gXCIgKyBsZW5ndGg7XG4gIH0sXG4gIDE4OiBcIm1vYngubWFwIHJlcXVpcmVzIE1hcCBwb2x5ZmlsbCBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci4gQ2hlY2sgYmFiZWwtcG9seWZpbGwgb3IgY29yZS1qcy9lczYvbWFwLmpzXCIsXG4gIDE5OiBmdW5jdGlvbiBfKG90aGVyKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IGluaXRpYWxpemUgZnJvbSBjbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tIE1hcDogXCIgKyBvdGhlci5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9LFxuICAyMDogZnVuY3Rpb24gXyhvdGhlcikge1xuICAgIHJldHVybiBcIkNhbm5vdCBpbml0aWFsaXplIG1hcCBmcm9tIFwiICsgb3RoZXI7XG4gIH0sXG4gIDIxOiBmdW5jdGlvbiBfKGRhdGFTdHJ1Y3R1cmUpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgY29udmVydCB0byBtYXAgZnJvbSAnXCIgKyBkYXRhU3RydWN0dXJlICsgXCInXCI7XG4gIH0sXG4gIDIyOiBcIm1vYnguc2V0IHJlcXVpcmVzIFNldCBwb2x5ZmlsbCBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci4gQ2hlY2sgYmFiZWwtcG9seWZpbGwgb3IgY29yZS1qcy9lczYvc2V0LmpzXCIsXG4gIDIzOiBcIkl0IGlzIG5vdCBwb3NzaWJsZSB0byBnZXQgaW5kZXggYXRvbXMgZnJvbSBhcnJheXNcIixcbiAgMjQ6IGZ1bmN0aW9uIF8odGhpbmcpIHtcbiAgICByZXR1cm4gXCJDYW5ub3Qgb2J0YWluIGFkbWluaXN0cmF0aW9uIGZyb20gXCIgKyB0aGluZztcbiAgfSxcbiAgMjU6IGZ1bmN0aW9uIF8ocHJvcGVydHksIG5hbWUpIHtcbiAgICByZXR1cm4gXCJ0aGUgZW50cnkgJ1wiICsgcHJvcGVydHkgKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG9ic2VydmFibGUgbWFwICdcIiArIG5hbWUgKyBcIidcIjtcbiAgfSxcbiAgMjY6IFwicGxlYXNlIHNwZWNpZnkgYSBwcm9wZXJ0eVwiLFxuICAyNzogZnVuY3Rpb24gXyhwcm9wZXJ0eSwgbmFtZSkge1xuICAgIHJldHVybiBcIm5vIG9ic2VydmFibGUgcHJvcGVydHkgJ1wiICsgcHJvcGVydHkudG9TdHJpbmcoKSArIFwiJyBmb3VuZCBvbiB0aGUgb2JzZXJ2YWJsZSBvYmplY3QgJ1wiICsgbmFtZSArIFwiJ1wiO1xuICB9LFxuICAyODogZnVuY3Rpb24gXyh0aGluZykge1xuICAgIHJldHVybiBcIkNhbm5vdCBvYnRhaW4gYXRvbSBmcm9tIFwiICsgdGhpbmc7XG4gIH0sXG4gIDI5OiBcIkV4cGVjdGluZyBzb21lIG9iamVjdFwiLFxuICAzMDogXCJpbnZhbGlkIGFjdGlvbiBzdGFjay4gZGlkIHlvdSBmb3JnZXQgdG8gZmluaXNoIGFuIGFjdGlvbj9cIixcbiAgMzE6IFwibWlzc2luZyBvcHRpb24gZm9yIGNvbXB1dGVkOiBnZXRcIixcbiAgMzI6IGZ1bmN0aW9uIF8obmFtZSwgZGVyaXZhdGlvbikge1xuICAgIHJldHVybiBcIkN5Y2xlIGRldGVjdGVkIGluIGNvbXB1dGF0aW9uIFwiICsgbmFtZSArIFwiOiBcIiArIGRlcml2YXRpb247XG4gIH0sXG4gIDMzOiBmdW5jdGlvbiBfKG5hbWUpIHtcbiAgICByZXR1cm4gXCJUaGUgc2V0dGVyIG9mIGNvbXB1dGVkIHZhbHVlICdcIiArIG5hbWUgKyBcIicgaXMgdHJ5aW5nIHRvIHVwZGF0ZSBpdHNlbGYuIERpZCB5b3UgaW50ZW5kIHRvIHVwZGF0ZSBhbiBfb2JzZXJ2YWJsZV8gdmFsdWUsIGluc3RlYWQgb2YgdGhlIGNvbXB1dGVkIHByb3BlcnR5P1wiO1xuICB9LFxuICAzNDogZnVuY3Rpb24gXyhuYW1lKSB7XG4gICAgcmV0dXJuIFwiW0NvbXB1dGVkVmFsdWUgJ1wiICsgbmFtZSArIFwiJ10gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGFzc2lnbiBhIG5ldyB2YWx1ZSB0byBhIGNvbXB1dGVkIHZhbHVlLlwiO1xuICB9LFxuICAzNTogXCJUaGVyZSBhcmUgbXVsdGlwbGUsIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBNb2JYIGFjdGl2ZS4gTWFrZSBzdXJlIE1vYlggaXMgbG9hZGVkIG9ubHkgb25jZSBvciB1c2UgYGNvbmZpZ3VyZSh7IGlzb2xhdGVHbG9iYWxTdGF0ZTogdHJ1ZSB9KWBcIixcbiAgMzY6IFwiaXNvbGF0ZUdsb2JhbFN0YXRlIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIE1vYlggaXMgcnVubmluZyBhbnkgcmVhY3Rpb25zXCIsXG4gIDM3OiBmdW5jdGlvbiBfKG1ldGhvZCkge1xuICAgIHJldHVybiBcIlttb2J4XSBgb2JzZXJ2YWJsZUFycmF5LlwiICsgbWV0aG9kICsgXCIoKWAgbXV0YXRlcyB0aGUgYXJyYXkgaW4tcGxhY2UsIHdoaWNoIGlzIG5vdCBhbGxvd2VkIGluc2lkZSBhIGRlcml2YXRpb24uIFVzZSBgYXJyYXkuc2xpY2UoKS5cIiArIG1ldGhvZCArIFwiKClgIGluc3RlYWRcIjtcbiAgfSxcbiAgMzg6IFwiJ293bktleXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHNcIixcbiAgMzk6IFwiJ2RlZmluZVByb3BlcnR5KCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzXCJcbn07XG52YXIgZXJyb3JzID0gIG5pY2VFcnJvcnMgO1xuZnVuY3Rpb24gZGllKGVycm9yKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHtcbiAgICB2YXIgZSA9IHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIiA/IGVycm9yIDogZXJyb3JzW2Vycm9yXTtcbiAgICBpZiAodHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIikgZSA9IGUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW01vYlhdIFwiICsgZSk7XG4gIH1cbn1cblxudmFyIG1vY2tHbG9iYWwgPSB7fTtcbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIH1cblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIHJldHVybiBtb2NrR2xvYmFsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbnZhciBnZXREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEVNUFRZX0FSUkFZID0gW107XG5PYmplY3QuZnJlZXplKEVNUFRZX0FSUkFZKTtcbnZhciBFTVBUWV9PQkpFQ1QgPSB7fTtcbk9iamVjdC5mcmVlemUoRU1QVFlfT0JKRUNUKTtcbnZhciBoYXNQcm94eSA9IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBwbGFpbk9iamVjdFN0cmluZyA9IC8qI19fUFVSRV9fKi9PYmplY3QudG9TdHJpbmcoKTtcbmZ1bmN0aW9uIGFzc2VydFByb3hpZXMoKSB7XG4gIGlmICghaGFzUHJveHkpIHtcbiAgICBkaWUoIFwiYFByb3h5YCBvYmplY3RzIGFyZSBub3QgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiBQbGVhc2UgY29uZmlndXJlIE1vYlggdG8gZW5hYmxlIGEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24uYFwiICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQobXNnKSB7XG4gIGlmICggZ2xvYmFsU3RhdGUudmVyaWZ5UHJveGllcykge1xuICAgIGRpZShcIk1vYlggaXMgY3VycmVudGx5IGNvbmZpZ3VyZWQgdG8gYmUgYWJsZSB0byBydW4gaW4gRVM1IG1vZGUsIGJ1dCBpbiBFUzUgTW9iWCB3b24ndCBiZSBhYmxlIHRvIFwiICsgbXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TmV4dElkKCkge1xuICByZXR1cm4gKytnbG9iYWxTdGF0ZS5tb2J4R3VpZDtcbn1cbi8qKlxyXG4gKiBNYWtlcyBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGlzIGludm9rZWQgYXQgbW9zdCBvbmNlLlxyXG4gKi9cblxuZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gIHZhciBpbnZva2VkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGludm9rZWQpIHJldHVybjtcbiAgICBpbnZva2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5naXNoKHZhbHVlKSB7XG4gIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuXG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICB2YXIgX3Byb3RvJGNvbnN0cnVjdG9yO1xuXG4gIGlmICghaXNPYmplY3QodmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIGlmIChwcm90byA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuICgoX3Byb3RvJGNvbnN0cnVjdG9yID0gcHJvdG8uY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfcHJvdG8kY29uc3RydWN0b3IudG9TdHJpbmcoKSkgPT09IHBsYWluT2JqZWN0U3RyaW5nO1xufSAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzc4NjUxNzBcblxuZnVuY3Rpb24gaXNHZW5lcmF0b3Iob2JqKSB7XG4gIHZhciBjb25zdHJ1Y3RvciA9IG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqLmNvbnN0cnVjdG9yO1xuICBpZiAoIWNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG4gIGlmIChcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IGNvbnN0cnVjdG9yLm5hbWUgfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFkZEhpZGRlblByb3Aob2JqZWN0LCBwcm9wTmFtZSwgdmFsdWUpIHtcbiAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wTmFtZSwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRIaWRkZW5GaW5hbFByb3Aob2JqZWN0LCBwcm9wTmFtZSwgdmFsdWUpIHtcbiAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wTmFtZSwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShuYW1lLCB0aGVDbGFzcykge1xuICB2YXIgcHJvcE5hbWUgPSBcImlzTW9iWFwiICsgbmFtZTtcbiAgdGhlQ2xhc3MucHJvdG90eXBlW3Byb3BOYW1lXSA9IHRydWU7XG4gIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBpc09iamVjdCh4KSAmJiB4W3Byb3BOYW1lXSA9PT0gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRVM2TWFwKHRoaW5nKSB7XG4gIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIE1hcDtcbn1cbmZ1bmN0aW9uIGlzRVM2U2V0KHRoaW5nKSB7XG4gIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIFNldDtcbn1cbnZhciBoYXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gXCJ1bmRlZmluZWRcIjtcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBmb2xsb3dpbmc6IG93biBlbnVtZXJhYmxlIGtleXMgYW5kIHN5bWJvbHMuXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRQbGFpbk9iamVjdEtleXMob2JqZWN0KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgLy8gTm90IHN1cHBvcnRlZCBpbiBJRSwgc28gdGhlcmUgYXJlIG5vdCBnb2luZyB0byBiZSBzeW1ib2wgcHJvcHMgYW55d2F5Li4uXG5cbiAgaWYgKCFoYXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHJldHVybiBrZXlzO1xuICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgaWYgKCFzeW1ib2xzLmxlbmd0aCkgcmV0dXJuIGtleXM7XG4gIHJldHVybiBbXS5jb25jYXQoa2V5cywgc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gb2JqZWN0UHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzKTtcbiAgfSkpO1xufSAvLyBGcm9tIEltbWVyIHV0aWxzXG4vLyBSZXR1cm5zIGFsbCBvd24ga2V5cywgaW5jbHVkaW5nIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xpY1xuXG52YXIgb3duS2V5cyA9IHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Qub3duS2V5cyA/IFJlZmxlY3Qub3duS2V5cyA6IGhhc0dldE93blByb3BlcnR5U3ltYm9scyA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSk7XG59IDpcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbmZ1bmN0aW9uIHN0cmluZ2lmeUtleShrZXkpIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHJldHVybiBrZXk7XG4gIGlmICh0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiKSByZXR1cm4ga2V5LnRvU3RyaW5nKCk7XG4gIHJldHVybiBuZXcgU3RyaW5nKGtleSkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgPyBcIlwiICsgdmFsdWUgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGhhc1Byb3AodGFyZ2V0LCBwcm9wKSB7XG4gIHJldHVybiBvYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHByb3ApO1xufSAvLyBGcm9tIEltbWVyIHV0aWxzXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0YXJnZXQpIHtcbiAgLy8gUG9seWZpbGwgbmVlZGVkIGZvciBIZXJtZXMgYW5kIElFLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2hlcm1lcy9pc3N1ZXMvMjc0XG4gIHZhciByZXMgPSB7fTsgLy8gTm90ZTogd2l0aG91dCBwb2x5ZmlsbCBmb3Igb3duS2V5cywgc3ltYm9scyB3b24ndCBiZSBwaWNrZWQgdXBcblxuICBvd25LZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmVzW2tleV0gPSBnZXREZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgfSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gaXQubmV4dC5iaW5kKGl0KTtcbn1cblxudmFyIHN0b3JlZEFubm90YXRpb25zU3ltYm9sID0gLyojX19QVVJFX18qL1N5bWJvbChcIm1vYngtc3RvcmVkLWFubm90YXRpb25zXCIpO1xuLyoqXHJcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjdHMgYXNcclxuICogLSBkZWNvcmF0b3JcclxuICogLSBhbm5vdGF0aW9uIG9iamVjdFxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihhbm5vdGF0aW9uKSB7XG4gIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgc3RvcmVBbm5vdGF0aW9uKHRhcmdldCwgcHJvcGVydHksIGFubm90YXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVjb3JhdG9yLCBhbm5vdGF0aW9uKTtcbn1cbi8qKlxyXG4gKiBTdG9yZXMgYW5ub3RhdGlvbiB0byBwcm90b3R5cGUsXHJcbiAqIHNvIGl0IGNhbiBiZSBpbnNwZWN0ZWQgbGF0ZXIgYnkgYG1ha2VPYnNlcnZhYmxlYCBjYWxsZWQgZnJvbSBjb25zdHJ1Y3RvclxyXG4gKi9cblxuZnVuY3Rpb24gc3RvcmVBbm5vdGF0aW9uKHByb3RvdHlwZSwga2V5LCBhbm5vdGF0aW9uKSB7XG4gIGlmICghaGFzUHJvcChwcm90b3R5cGUsIHN0b3JlZEFubm90YXRpb25zU3ltYm9sKSkge1xuICAgIGFkZEhpZGRlblByb3AocHJvdG90eXBlLCBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCwgX2V4dGVuZHMoe30sIHByb3RvdHlwZVtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pKTtcbiAgfSAvLyBAb3ZlcnJpZGUgbXVzdCBvdmVycmlkZSBzb21ldGhpbmdcblxuXG4gIGlmICggaXNPdmVycmlkZShhbm5vdGF0aW9uKSAmJiAhaGFzUHJvcChwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdLCBrZXkpKSB7XG4gICAgdmFyIGZpZWxkTmFtZSA9IHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lICsgXCIucHJvdG90eXBlLlwiICsga2V5LnRvU3RyaW5nKCk7XG4gICAgZGllKFwiJ1wiICsgZmllbGROYW1lICsgXCInIGlzIGRlY29yYXRlZCB3aXRoICdvdmVycmlkZScsIFwiICsgXCJidXQgbm8gc3VjaCBkZWNvcmF0ZWQgbWVtYmVyIHdhcyBmb3VuZCBvbiBwcm90b3R5cGUuXCIpO1xuICB9IC8vIENhbm5vdCByZS1kZWNvcmF0ZVxuXG5cbiAgYXNzZXJ0Tm90RGVjb3JhdGVkKHByb3RvdHlwZSwgYW5ub3RhdGlvbiwga2V5KTsgLy8gSWdub3JlIG92ZXJyaWRlXG5cbiAgaWYgKCFpc092ZXJyaWRlKGFubm90YXRpb24pKSB7XG4gICAgcHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXVtrZXldID0gYW5ub3RhdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnROb3REZWNvcmF0ZWQocHJvdG90eXBlLCBhbm5vdGF0aW9uLCBrZXkpIHtcbiAgaWYgKCAhaXNPdmVycmlkZShhbm5vdGF0aW9uKSAmJiBoYXNQcm9wKHByb3RvdHlwZVtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0sIGtleSkpIHtcbiAgICB2YXIgZmllbGROYW1lID0gcHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWUgKyBcIi5wcm90b3R5cGUuXCIgKyBrZXkudG9TdHJpbmcoKTtcbiAgICB2YXIgY3VycmVudEFubm90YXRpb25UeXBlID0gcHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXVtrZXldLmFubm90YXRpb25UeXBlXztcbiAgICB2YXIgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgPSBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlXztcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ0BcIiArIHJlcXVlc3RlZEFubm90YXRpb25UeXBlICsgXCInIHRvICdcIiArIGZpZWxkTmFtZSArIFwiJzpcIiArIChcIlxcblRoZSBmaWVsZCBpcyBhbHJlYWR5IGRlY29yYXRlZCB3aXRoICdAXCIgKyBjdXJyZW50QW5ub3RhdGlvblR5cGUgKyBcIicuXCIpICsgXCJcXG5SZS1kZWNvcmF0aW5nIGZpZWxkcyBpcyBub3QgYWxsb3dlZC5cIiArIFwiXFxuVXNlICdAb3ZlcnJpZGUnIGRlY29yYXRvciBmb3IgbWV0aG9kcyBvdmVycmlkZW4gYnkgc3ViY2xhc3MuXCIpO1xuICB9XG59XG4vKipcclxuICogQ29sbGVjdHMgYW5ub3RhdGlvbnMgZnJvbSBwcm90b3R5cGVzIGFuZCBzdG9yZXMgdGhlbSBvbiB0YXJnZXQgKGluc3RhbmNlKVxyXG4gKi9cblxuXG5mdW5jdGlvbiBjb2xsZWN0U3RvcmVkQW5ub3RhdGlvbnModGFyZ2V0KSB7XG4gIGlmICghaGFzUHJvcCh0YXJnZXQsIHN0b3JlZEFubm90YXRpb25zU3ltYm9sKSkge1xuICAgIGlmICggIXRhcmdldFtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pIHtcbiAgICAgIGRpZShcIk5vIGFubm90YXRpb25zIHdlcmUgcGFzc2VkIHRvIG1ha2VPYnNlcnZhYmxlLCBidXQgbm8gZGVjb3JhdGVkIG1lbWJlcnMgaGF2ZSBiZWVuIGZvdW5kIGVpdGhlclwiKTtcbiAgICB9IC8vIFdlIG5lZWQgYSBjb3B5IGFzIHdlIHdpbGwgcmVtb3ZlIGFubm90YXRpb24gZnJvbSB0aGUgbGlzdCBvbmNlIGl0J3MgYXBwbGllZC5cblxuXG4gICAgYWRkSGlkZGVuUHJvcCh0YXJnZXQsIHN0b3JlZEFubm90YXRpb25zU3ltYm9sLCBfZXh0ZW5kcyh7fSwgdGFyZ2V0W3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldFtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF07XG59XG5cbnZhciAkbW9ieCA9IC8qI19fUFVSRV9fKi9TeW1ib2woXCJtb2J4IGFkbWluaXN0cmF0aW9uXCIpO1xudmFyIEF0b20gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBmb3IgZWZmZWN0aXZlIHVub2JzZXJ2aW5nLiBCYXNlQXRvbSBoYXMgdHJ1ZSwgZm9yIGV4dHJhIG9wdGltaXphdGlvbiwgc28gaXRzIG9uQmVjb21lVW5vYnNlcnZlZCBuZXZlciBnZXRzIGNhbGxlZCwgYmVjYXVzZSBpdCdzIG5vdCBuZWVkZWRcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgYXRvbS4gRm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBpdCBpcyByZWNvbW1lbmRlZCB0byBnaXZlIGl0IGEgbmFtZS5cclxuICAgKiBUaGUgb25CZWNvbWVPYnNlcnZlZCBhbmQgb25CZWNvbWVVbm9ic2VydmVkIGNhbGxiYWNrcyBjYW4gYmUgdXNlZCBmb3IgcmVzb3VyY2UgbWFuYWdlbWVudC5cclxuICAgKi9cbiAgZnVuY3Rpb24gQXRvbShuYW1lXykge1xuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9ICBcIkF0b21AXCIgKyBnZXROZXh0SWQoKSA7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb25fID0gZmFsc2U7XG4gICAgdGhpcy5pc0JlaW5nT2JzZXJ2ZWRfID0gZmFsc2U7XG4gICAgdGhpcy5vYnNlcnZlcnNfID0gbmV3IFNldCgpO1xuICAgIHRoaXMuZGlmZlZhbHVlXyA9IDA7XG4gICAgdGhpcy5sYXN0QWNjZXNzZWRCeV8gPSAwO1xuICAgIHRoaXMubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfO1xuICAgIHRoaXMub25CT0wgPSB2b2lkIDA7XG4gICAgdGhpcy5vbkJVT0wgPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuICB9IC8vIG9uQmVjb21lT2JzZXJ2ZWRMaXN0ZW5lcnNcblxuXG4gIHZhciBfcHJvdG8gPSBBdG9tLnByb3RvdHlwZTtcblxuICBfcHJvdG8ub25CTyA9IGZ1bmN0aW9uIG9uQk8oKSB7XG4gICAgaWYgKHRoaXMub25CT0wpIHtcbiAgICAgIHRoaXMub25CT0wuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uQlVPID0gZnVuY3Rpb24gb25CVU8oKSB7XG4gICAgaWYgKHRoaXMub25CVU9MKSB7XG4gICAgICB0aGlzLm9uQlVPTC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBJbnZva2UgdGhpcyBtZXRob2QgdG8gbm90aWZ5IG1vYnggdGhhdCB5b3VyIGF0b20gaGFzIGJlZW4gdXNlZCBzb21laG93LlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBjdXJyZW50bHkgYSByZWFjdGl2ZSBjb250ZXh0LlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlcG9ydE9ic2VydmVkID0gZnVuY3Rpb24gcmVwb3J0T2JzZXJ2ZWQkMSgpIHtcbiAgICByZXR1cm4gcmVwb3J0T2JzZXJ2ZWQodGhpcyk7XG4gIH1cbiAgLyoqXHJcbiAgICogSW52b2tlIHRoaXMgbWV0aG9kIF9hZnRlcl8gdGhpcyBtZXRob2QgaGFzIGNoYW5nZWQgdG8gc2lnbmFsIG1vYnggdGhhdCBhbGwgaXRzIG9ic2VydmVycyBzaG91bGQgaW52YWxpZGF0ZS5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBvcnRDaGFuZ2VkID0gZnVuY3Rpb24gcmVwb3J0Q2hhbmdlZCgpIHtcbiAgICBzdGFydEJhdGNoKCk7XG4gICAgcHJvcGFnYXRlQ2hhbmdlZCh0aGlzKTtcbiAgICBlbmRCYXRjaCgpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVfO1xuICB9O1xuXG4gIHJldHVybiBBdG9tO1xufSgpO1xudmFyIGlzQXRvbSA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiQXRvbVwiLCBBdG9tKTtcbmZ1bmN0aW9uIGNyZWF0ZUF0b20obmFtZSwgb25CZWNvbWVPYnNlcnZlZEhhbmRsZXIsIG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIpIHtcbiAgaWYgKG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyID09PSB2b2lkIDApIHtcbiAgICBvbkJlY29tZU9ic2VydmVkSGFuZGxlciA9IG5vb3A7XG4gIH1cblxuICBpZiAob25CZWNvbWVVbm9ic2VydmVkSGFuZGxlciA9PT0gdm9pZCAwKSB7XG4gICAgb25CZWNvbWVVbm9ic2VydmVkSGFuZGxlciA9IG5vb3A7XG4gIH1cblxuICB2YXIgYXRvbSA9IG5ldyBBdG9tKG5hbWUpOyAvLyBkZWZhdWx0IGBub29wYCBsaXN0ZW5lciB3aWxsIG5vdCBpbml0aWFsaXplIHRoZSBob29rIFNldFxuXG4gIGlmIChvbkJlY29tZU9ic2VydmVkSGFuZGxlciAhPT0gbm9vcCkge1xuICAgIG9uQmVjb21lT2JzZXJ2ZWQoYXRvbSwgb25CZWNvbWVPYnNlcnZlZEhhbmRsZXIpO1xuICB9XG5cbiAgaWYgKG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIgIT09IG5vb3ApIHtcbiAgICBvbkJlY29tZVVub2JzZXJ2ZWQoYXRvbSwgb25CZWNvbWVVbm9ic2VydmVkSGFuZGxlcik7XG4gIH1cblxuICByZXR1cm4gYXRvbTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHlDb21wYXJlcihhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuXG5mdW5jdGlvbiBzdHJ1Y3R1cmFsQ29tcGFyZXIoYSwgYikge1xuICByZXR1cm4gZGVlcEVxdWFsKGEsIGIpO1xufVxuXG5mdW5jdGlvbiBzaGFsbG93Q29tcGFyZXIoYSwgYikge1xuICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIDEpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZXIoYSwgYikge1xuICBpZiAoT2JqZWN0LmlzKSByZXR1cm4gT2JqZWN0LmlzKGEsIGIpO1xuICByZXR1cm4gYSA9PT0gYiA/IGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiIDogYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuXG52YXIgY29tcGFyZXIgPSB7XG4gIGlkZW50aXR5OiBpZGVudGl0eUNvbXBhcmVyLFxuICBzdHJ1Y3R1cmFsOiBzdHJ1Y3R1cmFsQ29tcGFyZXIsXG4gIFwiZGVmYXVsdFwiOiBkZWZhdWx0Q29tcGFyZXIsXG4gIHNoYWxsb3c6IHNoYWxsb3dDb21wYXJlclxufTtcblxuZnVuY3Rpb24gZGVlcEVuaGFuY2VyKHYsIF8sIG5hbWUpIHtcbiAgLy8gaXQgaXMgYW4gb2JzZXJ2YWJsZSBhbHJlYWR5LCBkb25lXG4gIGlmIChpc09ic2VydmFibGUodikpIHJldHVybiB2OyAvLyBzb21ldGhpbmcgdGhhdCBjYW4gYmUgY29udmVydGVkIGFuZCBtdXRhdGVkP1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5hcnJheSh2LCB7XG4gICAgbmFtZTogbmFtZVxuICB9KTtcbiAgaWYgKGlzUGxhaW5PYmplY3QodikpIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCB1bmRlZmluZWQsIHtcbiAgICBuYW1lOiBuYW1lXG4gIH0pO1xuICBpZiAoaXNFUzZNYXAodikpIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCB7XG4gICAgbmFtZTogbmFtZVxuICB9KTtcbiAgaWYgKGlzRVM2U2V0KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5zZXQodiwge1xuICAgIG5hbWU6IG5hbWVcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIgJiYgIWlzQWN0aW9uKHYpICYmICFpc0Zsb3codikpIHtcbiAgICBpZiAoaXNHZW5lcmF0b3IodikpIHtcbiAgICAgIHJldHVybiBmbG93KHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXV0b0FjdGlvbihuYW1lLCB2KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dFbmhhbmNlcih2LCBfLCBuYW1lKSB7XG4gIGlmICh2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCkgcmV0dXJuIHY7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3QodikgfHwgaXNPYnNlcnZhYmxlQXJyYXkodikgfHwgaXNPYnNlcnZhYmxlTWFwKHYpIHx8IGlzT2JzZXJ2YWJsZVNldCh2KSkgcmV0dXJuIHY7XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5hcnJheSh2LCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBkZWVwOiBmYWxzZVxuICB9KTtcbiAgaWYgKGlzUGxhaW5PYmplY3QodikpIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCB1bmRlZmluZWQsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGRlZXA6IGZhbHNlXG4gIH0pO1xuICBpZiAoaXNFUzZNYXAodikpIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBkZWVwOiBmYWxzZVxuICB9KTtcbiAgaWYgKGlzRVM2U2V0KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5zZXQodiwge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgZGVlcDogZmFsc2VcbiAgfSk7XG4gIGRpZShcIlRoZSBzaGFsbG93IG1vZGlmaWVyIC8gZGVjb3JhdG9yIGNhbiBvbmx5IHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBhcnJheXMsIG9iamVjdHMsIG1hcHMgYW5kIHNldHNcIik7XG59XG5mdW5jdGlvbiByZWZlcmVuY2VFbmhhbmNlcihuZXdWYWx1ZSkge1xuICAvLyBuZXZlciB0dXJuIGludG8gYW4gb2JzZXJ2YWJsZVxuICByZXR1cm4gbmV3VmFsdWU7XG59XG5mdW5jdGlvbiByZWZTdHJ1Y3RFbmhhbmNlcih2LCBvbGRWYWx1ZSkge1xuICBpZiAoIGlzT2JzZXJ2YWJsZSh2KSkgZGllKFwib2JzZXJ2YWJsZS5zdHJ1Y3Qgc2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggb2JzZXJ2YWJsZSB2YWx1ZXNcIik7XG4gIGlmIChkZWVwRXF1YWwodiwgb2xkVmFsdWUpKSByZXR1cm4gb2xkVmFsdWU7XG4gIHJldHVybiB2O1xufVxuXG52YXIgT1ZFUlJJREUgPSBcIm92ZXJyaWRlXCI7XG52YXIgb3ZlcnJpZGUgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbih7XG4gIGFubm90YXRpb25UeXBlXzogT1ZFUlJJREUsXG4gIG1ha2VfOiBtYWtlXyxcbiAgZXh0ZW5kXzogZXh0ZW5kX1xufSk7XG5mdW5jdGlvbiBpc092ZXJyaWRlKGFubm90YXRpb24pIHtcbiAgcmV0dXJuIGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfID09PSBPVkVSUklERTtcbn1cblxuZnVuY3Rpb24gbWFrZV8oYWRtLCBrZXkpIHtcbiAgLy8gTXVzdCBub3QgYmUgcGxhaW4gb2JqZWN0XG4gIGlmICggYWRtLmlzUGxhaW5PYmplY3RfKSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyB0aGlzLmFubm90YXRpb25UeXBlXyArIFwiJyBjYW5ub3QgYmUgdXNlZCBvbiBwbGFpbiBvYmplY3RzLlwiKSk7XG4gIH0gLy8gTXVzdCBvdmVycmlkZSBzb21ldGhpbmdcblxuXG4gIGlmICggIWhhc1Byb3AoYWRtLmFwcGxpZWRBbm5vdGF0aW9uc18sIGtleSkpIHtcbiAgICBkaWUoXCInXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInIGlzIGFubm90YXRlZCB3aXRoICdcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInLCBcIiArIFwiYnV0IG5vIHN1Y2ggYW5ub3RhdGVkIG1lbWJlciB3YXMgZm91bmQgb24gcHJvdG90eXBlLlwiKTtcbiAgfVxuXG4gIHJldHVybiAwXG4gIC8qIENhbmNlbCAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICBkaWUoXCInXCIgKyB0aGlzLmFubm90YXRpb25UeXBlXyArIFwiJyBjYW4gb25seSBiZSB1c2VkIHdpdGggJ21ha2VPYnNlcnZhYmxlJ1wiKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGlvblR5cGVfOiBuYW1lLFxuICAgIG9wdGlvbnNfOiBvcHRpb25zLFxuICAgIG1ha2VfOiBtYWtlXyQxLFxuICAgIGV4dGVuZF86IGV4dGVuZF8kMVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlXyQxKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfO1xuXG4gIC8vIGJvdW5kXG4gIGlmICgoX3RoaXMkb3B0aW9uc18gPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc18uYm91bmQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwgPyAwXG4gICAgLyogQ2FuY2VsICovXG4gICAgOiAxXG4gICAgLyogQnJlYWsgKi9cbiAgICA7XG4gIH0gLy8gb3duXG5cblxuICBpZiAoc291cmNlID09PSBhZG0udGFyZ2V0Xykge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCA/IDBcbiAgICAvKiBDYW5jZWwgKi9cbiAgICA6IDJcbiAgICAvKiBDb250aW51ZSAqL1xuICAgIDtcbiAgfSAvLyBwcm90b3R5cGVcblxuXG4gIGlmIChpc0FjdGlvbihkZXNjcmlwdG9yLnZhbHVlKSkge1xuICAgIC8vIEEgcHJvdG90eXBlIGNvdWxkIGhhdmUgYmVlbiBhbm5vdGF0ZWQgYWxyZWFkeSBieSBvdGhlciBjb25zdHJ1Y3RvcixcbiAgICAvLyByZXN0IG9mIHRoZSBwcm90byBjaGFpbiBtdXN0IGJlIGFubm90YXRlZCBhbHJlYWR5XG4gICAgcmV0dXJuIDFcbiAgICAvKiBCcmVhayAqL1xuICAgIDtcbiAgfVxuXG4gIHZhciBhY3Rpb25EZXNjcmlwdG9yID0gY3JlYXRlQWN0aW9uRGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpO1xuICBkZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwgYWN0aW9uRGVzY3JpcHRvcik7XG4gIHJldHVybiAyXG4gIC8qIENvbnRpbnVlICovXG4gIDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyQxKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIGFjdGlvbkRlc2NyaXB0b3IgPSBjcmVhdGVBY3Rpb25EZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCBhY3Rpb25EZXNjcmlwdG9yLCBwcm94eVRyYXApO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBY3Rpb25EZXNjcmlwdG9yKGFkbSwgX3JlZiwga2V5LCBfcmVmMikge1xuICB2YXIgYW5ub3RhdGlvblR5cGVfID0gX3JlZi5hbm5vdGF0aW9uVHlwZV87XG4gIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuXG4gIGlmICggIWlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyB0byAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOlwiICsgKFwiXFxuJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbiBvbmx5IGJlIHVzZWQgb24gcHJvcGVydGllcyB3aXRoIGEgZnVuY3Rpb24gdmFsdWUuXCIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25EZXNjcmlwdG9yKGFkbSwgYW5ub3RhdGlvbiwga2V5LCBkZXNjcmlwdG9yLCAvLyBwcm92aWRlcyBhYmlsaXR5IHRvIGRpc2FibGUgc2FmZURlc2NyaXB0b3JzIGZvciBwcm90b3R5cGVzXG5zYWZlRGVzY3JpcHRvcnMpIHtcbiAgdmFyIF9hbm5vdGF0aW9uJG9wdGlvbnNfLCBfYW5ub3RhdGlvbiRvcHRpb25zXyQsIF9hbm5vdGF0aW9uJG9wdGlvbnNfMiwgX2Fubm90YXRpb24kb3B0aW9uc18kMiwgX2Fubm90YXRpb24kb3B0aW9uc18zO1xuXG4gIGlmIChzYWZlRGVzY3JpcHRvcnMgPT09IHZvaWQgMCkge1xuICAgIHNhZmVEZXNjcmlwdG9ycyA9IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycztcbiAgfVxuXG4gIGFzc2VydEFjdGlvbkRlc2NyaXB0b3IoYWRtLCBhbm5vdGF0aW9uLCBrZXksIGRlc2NyaXB0b3IpO1xuICB2YXIgdmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlO1xuXG4gIGlmICgoX2Fubm90YXRpb24kb3B0aW9uc18gPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX2Fubm90YXRpb24kb3B0aW9uc18uYm91bmQpIHtcbiAgICB2YXIgX2FkbSRwcm94eV87XG5cbiAgICB2YWx1ZSA9IHZhbHVlLmJpbmQoKF9hZG0kcHJveHlfID0gYWRtLnByb3h5XykgIT0gbnVsbCA/IF9hZG0kcHJveHlfIDogYWRtLnRhcmdldF8pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogY3JlYXRlQWN0aW9uKChfYW5ub3RhdGlvbiRvcHRpb25zXyQgPSAoX2Fubm90YXRpb24kb3B0aW9uc18yID0gYW5ub3RhdGlvbi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9uJG9wdGlvbnNfMi5uYW1lKSAhPSBudWxsID8gX2Fubm90YXRpb24kb3B0aW9uc18kIDoga2V5LnRvU3RyaW5nKCksIHZhbHVlLCAoX2Fubm90YXRpb24kb3B0aW9uc18kMiA9IChfYW5ub3RhdGlvbiRvcHRpb25zXzMgPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX2Fubm90YXRpb24kb3B0aW9uc18zLmF1dG9BY3Rpb24pICE9IG51bGwgPyBfYW5ub3RhdGlvbiRvcHRpb25zXyQyIDogZmFsc2UpLFxuICAgIC8vIE5vbi1jb25maWd1cmFibGUgZm9yIGNsYXNzZXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsIGZpZWxkIHJlZGVmaW5pdGlvbiBpbiBzdWJjbGFzc1xuICAgIGNvbmZpZ3VyYWJsZTogc2FmZURlc2NyaXB0b3JzID8gYWRtLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvcHVsbC8yNjQxI2lzc3VlY29tbWVudC03MzcyOTIwNThcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAvLyBOb24tb2JzZXZhYmxlLCB0aGVyZWZvcmUgbm9uLXdyaXRhYmxlXG4gICAgLy8gQWxzbyBwcmV2ZW50cyByZXdyaXRpbmcgaW4gc3ViY2xhc3MgY29uc3RydWN0b3JcbiAgICB3cml0YWJsZTogc2FmZURlc2NyaXB0b3JzID8gZmFsc2UgOiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZsb3dBbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDIsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQyXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VfJDIoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSkge1xuICB2YXIgX3RoaXMkb3B0aW9uc187XG5cbiAgLy8gb3duXG4gIGlmIChzb3VyY2UgPT09IGFkbS50YXJnZXRfKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMFxuICAgIC8qIENhbmNlbCAqL1xuICAgIDogMlxuICAgIC8qIENvbnRpbnVlICovXG4gICAgO1xuICB9IC8vIHByb3RvdHlwZVxuICAvLyBib3VuZCAtIG11c3QgYW5ub3RhdGUgcHJvdG9zIHRvIHN1cHBvcnQgc3VwZXIuZmxvdygpXG5cblxuICBpZiAoKChfdGhpcyRvcHRpb25zXyA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXy5ib3VuZCkgJiYgIWlzRmxvdyhhZG0udGFyZ2V0X1trZXldKSkge1xuICAgIGlmICh0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCkgcmV0dXJuIDBcbiAgICAvKiBDYW5jZWwgKi9cbiAgICA7XG4gIH1cblxuICBpZiAoaXNGbG93KGRlc2NyaXB0b3IudmFsdWUpKSB7XG4gICAgLy8gQSBwcm90b3R5cGUgY291bGQgaGF2ZSBiZWVuIGFubm90YXRlZCBhbHJlYWR5IGJ5IG90aGVyIGNvbnN0cnVjdG9yLFxuICAgIC8vIHJlc3Qgb2YgdGhlIHByb3RvIGNoYWluIG11c3QgYmUgYW5ub3RhdGVkIGFscmVhZHlcbiAgICByZXR1cm4gMVxuICAgIC8qIEJyZWFrICovXG4gICAgO1xuICB9XG5cbiAgdmFyIGZsb3dEZXNjcmlwdG9yID0gY3JlYXRlRmxvd0Rlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlLCBmYWxzZSk7XG4gIGRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCBmbG93RGVzY3JpcHRvcik7XG4gIHJldHVybiAyXG4gIC8qIENvbnRpbnVlICovXG4gIDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyQyKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfMjtcblxuICB2YXIgZmxvd0Rlc2NyaXB0b3IgPSBjcmVhdGVGbG93RGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvciwgKF90aGlzJG9wdGlvbnNfMiA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzIuYm91bmQpO1xuICByZXR1cm4gYWRtLmRlZmluZVByb3BlcnR5XyhrZXksIGZsb3dEZXNjcmlwdG9yLCBwcm94eVRyYXApO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGbG93RGVzY3JpcHRvcihhZG0sIF9yZWYsIGtleSwgX3JlZjIpIHtcbiAgdmFyIGFubm90YXRpb25UeXBlXyA9IF9yZWYuYW5ub3RhdGlvblR5cGVfO1xuICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZTtcblxuICBpZiAoICFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzpcIiArIChcIlxcbidcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyBjYW4gb25seSBiZSB1c2VkIG9uIHByb3BlcnRpZXMgd2l0aCBhIGdlbmVyYXRvciBmdW5jdGlvbiB2YWx1ZS5cIikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZsb3dEZXNjcmlwdG9yKGFkbSwgYW5ub3RhdGlvbiwga2V5LCBkZXNjcmlwdG9yLCBib3VuZCwgLy8gcHJvdmlkZXMgYWJpbGl0eSB0byBkaXNhYmxlIHNhZmVEZXNjcmlwdG9ycyBmb3IgcHJvdG90eXBlc1xuc2FmZURlc2NyaXB0b3JzKSB7XG4gIGlmIChzYWZlRGVzY3JpcHRvcnMgPT09IHZvaWQgMCkge1xuICAgIHNhZmVEZXNjcmlwdG9ycyA9IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycztcbiAgfVxuXG4gIGFzc2VydEZsb3dEZXNjcmlwdG9yKGFkbSwgYW5ub3RhdGlvbiwga2V5LCBkZXNjcmlwdG9yKTtcbiAgdmFyIHZhbHVlID0gZGVzY3JpcHRvci52YWx1ZTtcblxuICBpZiAoYm91bmQpIHtcbiAgICB2YXIgX2FkbSRwcm94eV87XG5cbiAgICB2YWx1ZSA9IHZhbHVlLmJpbmQoKF9hZG0kcHJveHlfID0gYWRtLnByb3h5XykgIT0gbnVsbCA/IF9hZG0kcHJveHlfIDogYWRtLnRhcmdldF8pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogZmxvdyh2YWx1ZSksXG4gICAgLy8gTm9uLWNvbmZpZ3VyYWJsZSBmb3IgY2xhc3Nlc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWwgZmllbGQgcmVkZWZpbml0aW9uIGluIHN1YmNsYXNzXG4gICAgY29uZmlndXJhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBhZG0uaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9wdWxsLzI2NDEjaXNzdWVjb21tZW50LTczNzI5MjA1OFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIC8vIE5vbi1vYnNldmFibGUsIHRoZXJlZm9yZSBub24td3JpdGFibGVcbiAgICAvLyBBbHNvIHByZXZlbnRzIHJld3JpdGluZyBpbiBzdWJjbGFzcyBjb25zdHJ1Y3RvclxuICAgIHdyaXRhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBmYWxzZSA6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDMsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQzXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VfJDMoYWRtLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMFxuICAvKiBDYW5jZWwgKi9cbiAgOiAxXG4gIC8qIEJyZWFrICovXG4gIDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyQzKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgYXNzZXJ0Q29tcHV0ZWREZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVDb21wdXRlZFByb3BlcnR5XyhrZXksIF9leHRlbmRzKHt9LCB0aGlzLm9wdGlvbnNfLCB7XG4gICAgZ2V0OiBkZXNjcmlwdG9yLmdldCxcbiAgICBzZXQ6IGRlc2NyaXB0b3Iuc2V0XG4gIH0pLCBwcm94eVRyYXApO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDb21wdXRlZERlc2NyaXB0b3IoYWRtLCBfcmVmLCBrZXksIF9yZWYyKSB7XG4gIHZhciBhbm5vdGF0aW9uVHlwZV8gPSBfcmVmLmFubm90YXRpb25UeXBlXztcbiAgdmFyIGdldCA9IF9yZWYyLmdldDtcblxuICBpZiAoICFnZXQpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCBvbiBnZXR0ZXIoK3NldHRlcikgcHJvcGVydGllcy5cIikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGVBbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDQsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQ0XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VfJDQoYWRtLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMFxuICAvKiBDYW5jZWwgKi9cbiAgOiAxXG4gIC8qIEJyZWFrICovXG4gIDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyQ0KGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfJGVuaGFuYywgX3RoaXMkb3B0aW9uc187XG5cbiAgYXNzZXJ0T2JzZXJ2YWJsZURlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IpO1xuICByZXR1cm4gYWRtLmRlZmluZU9ic2VydmFibGVQcm9wZXJ0eV8oa2V5LCBkZXNjcmlwdG9yLnZhbHVlLCAoX3RoaXMkb3B0aW9uc18kZW5oYW5jID0gKF90aGlzJG9wdGlvbnNfID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfLmVuaGFuY2VyKSAhPSBudWxsID8gX3RoaXMkb3B0aW9uc18kZW5oYW5jIDogZGVlcEVuaGFuY2VyLCBwcm94eVRyYXApO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPYnNlcnZhYmxlRGVzY3JpcHRvcihhZG0sIF9yZWYsIGtleSwgZGVzY3JpcHRvcikge1xuICB2YXIgYW5ub3RhdGlvblR5cGVfID0gX3JlZi5hbm5vdGF0aW9uVHlwZV87XG5cbiAgaWYgKCAhKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSkge1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzpcIiArIChcIlxcbidcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyBjYW5ub3QgYmUgdXNlZCBvbiBnZXR0ZXIvc2V0dGVyIHByb3BlcnRpZXNcIikpO1xuICB9XG59XG5cbnZhciBBVVRPID0gXCJ0cnVlXCI7XG52YXIgYXV0b0Fubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQXV0b0Fubm90YXRpb24oKTtcbmZ1bmN0aW9uIGNyZWF0ZUF1dG9Bbm5vdGF0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IEFVVE8sXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDUsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQ1XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VfJDUoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSkge1xuICB2YXIgX3RoaXMkb3B0aW9uc18zLCBfdGhpcyRvcHRpb25zXzQ7XG5cbiAgLy8gZ2V0dGVyIC0+IGNvbXB1dGVkXG4gIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgIHJldHVybiBjb21wdXRlZC5tYWtlXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbiAgfSAvLyBsb25lIHNldHRlciAtPiBhY3Rpb24gc2V0dGVyXG5cblxuICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcbiAgICAvLyBUT0RPIG1ha2UgYWN0aW9uIGFwcGxpY2FibGUgdG8gc2V0dGVyIGFuZCBkZWxlZ2F0ZSB0byBhY3Rpb24ubWFrZV9cbiAgICB2YXIgc2V0ID0gY3JlYXRlQWN0aW9uKGtleS50b1N0cmluZygpLCBkZXNjcmlwdG9yLnNldCk7IC8vIG93blxuXG4gICAgaWYgKHNvdXJjZSA9PT0gYWRtLnRhcmdldF8pIHtcbiAgICAgIHJldHVybiBhZG0uZGVmaW5lUHJvcGVydHlfKGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycyA/IGFkbS5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgICAgIHNldDogc2V0XG4gICAgICB9KSA9PT0gbnVsbCA/IDBcbiAgICAgIC8qIENhbmNlbCAqL1xuICAgICAgOiAyXG4gICAgICAvKiBDb250aW51ZSAqL1xuICAgICAgO1xuICAgIH0gLy8gcHJvdG9cblxuXG4gICAgZGVmaW5lUHJvcGVydHkoc291cmNlLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogc2V0XG4gICAgfSk7XG4gICAgcmV0dXJuIDJcbiAgICAvKiBDb250aW51ZSAqL1xuICAgIDtcbiAgfSAvLyBmdW5jdGlvbiBvbiBwcm90byAtPiBhdXRvQWN0aW9uL2Zsb3dcblxuXG4gIGlmIChzb3VyY2UgIT09IGFkbS50YXJnZXRfICYmIHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgX3RoaXMkb3B0aW9uc18yO1xuXG4gICAgaWYgKGlzR2VuZXJhdG9yKGRlc2NyaXB0b3IudmFsdWUpKSB7XG4gICAgICB2YXIgX3RoaXMkb3B0aW9uc187XG5cbiAgICAgIHZhciBmbG93QW5ub3RhdGlvbiA9ICgoX3RoaXMkb3B0aW9uc18gPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc18uYXV0b0JpbmQpID8gZmxvdy5ib3VuZCA6IGZsb3c7XG4gICAgICByZXR1cm4gZmxvd0Fubm90YXRpb24ubWFrZV8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIGFjdGlvbkFubm90YXRpb24gPSAoKF90aGlzJG9wdGlvbnNfMiA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzIuYXV0b0JpbmQpID8gYXV0b0FjdGlvbi5ib3VuZCA6IGF1dG9BY3Rpb247XG4gICAgcmV0dXJuIGFjdGlvbkFubm90YXRpb24ubWFrZV8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG4gIH0gLy8gb3RoZXIgLT4gb2JzZXJ2YWJsZVxuICAvLyBDb3B5IHByb3BzIGZyb20gcHJvdG8gYXMgd2VsbCwgc2VlIHRlc3Q6XG4gIC8vIFwiZGVjb3JhdGUgc2hvdWxkIHdvcmsgd2l0aCBPYmplY3QuY3JlYXRlXCJcblxuXG4gIHZhciBvYnNlcnZhYmxlQW5ub3RhdGlvbiA9ICgoX3RoaXMkb3B0aW9uc18zID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfMy5kZWVwKSA9PT0gZmFsc2UgPyBvYnNlcnZhYmxlLnJlZiA6IG9ic2VydmFibGU7IC8vIGlmIGZ1bmN0aW9uIHJlc3BlY3QgYXV0b0JpbmQgb3B0aW9uXG5cbiAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgKChfdGhpcyRvcHRpb25zXzQgPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc180LmF1dG9CaW5kKSkge1xuICAgIHZhciBfYWRtJHByb3h5XztcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlLmJpbmQoKF9hZG0kcHJveHlfID0gYWRtLnByb3h5XykgIT0gbnVsbCA/IF9hZG0kcHJveHlfIDogYWRtLnRhcmdldF8pO1xuICB9XG5cbiAgcmV0dXJuIG9ic2VydmFibGVBbm5vdGF0aW9uLm1ha2VfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBleHRlbmRfJDUoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICB2YXIgX3RoaXMkb3B0aW9uc181LCBfdGhpcyRvcHRpb25zXzY7XG5cbiAgLy8gZ2V0dGVyIC0+IGNvbXB1dGVkXG4gIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgIHJldHVybiBjb21wdXRlZC5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApO1xuICB9IC8vIGxvbmUgc2V0dGVyIC0+IGFjdGlvbiBzZXR0ZXJcblxuXG4gIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgIC8vIFRPRE8gbWFrZSBhY3Rpb24gYXBwbGljYWJsZSB0byBzZXR0ZXIgYW5kIGRlbGVnYXRlIHRvIGFjdGlvbi5leHRlbmRfXG4gICAgcmV0dXJuIGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycyA/IGFkbS5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgICBzZXQ6IGNyZWF0ZUFjdGlvbihrZXkudG9TdHJpbmcoKSwgZGVzY3JpcHRvci5zZXQpXG4gICAgfSwgcHJveHlUcmFwKTtcbiAgfSAvLyBvdGhlciAtPiBvYnNlcnZhYmxlXG4gIC8vIGlmIGZ1bmN0aW9uIHJlc3BlY3QgYXV0b0JpbmQgb3B0aW9uXG5cblxuICBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiAoKF90aGlzJG9wdGlvbnNfNSA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzUuYXV0b0JpbmQpKSB7XG4gICAgdmFyIF9hZG0kcHJveHlfMjtcblxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlLmJpbmQoKF9hZG0kcHJveHlfMiA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XzIgOiBhZG0udGFyZ2V0Xyk7XG4gIH1cblxuICB2YXIgb2JzZXJ2YWJsZUFubm90YXRpb24gPSAoKF90aGlzJG9wdGlvbnNfNiA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzYuZGVlcCkgPT09IGZhbHNlID8gb2JzZXJ2YWJsZS5yZWYgOiBvYnNlcnZhYmxlO1xuICByZXR1cm4gb2JzZXJ2YWJsZUFubm90YXRpb24uZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbn1cblxudmFyIE9CU0VSVkFCTEUgPSBcIm9ic2VydmFibGVcIjtcbnZhciBPQlNFUlZBQkxFX1JFRiA9IFwib2JzZXJ2YWJsZS5yZWZcIjtcbnZhciBPQlNFUlZBQkxFX1NIQUxMT1cgPSBcIm9ic2VydmFibGUuc2hhbGxvd1wiO1xudmFyIE9CU0VSVkFCTEVfU1RSVUNUID0gXCJvYnNlcnZhYmxlLnN0cnVjdFwiOyAvLyBQcmVkZWZpbmVkIGJhZ3Mgb2YgY3JlYXRlIG9ic2VydmFibGUgb3B0aW9ucywgdG8gYXZvaWQgYWxsb2NhdGluZyB0ZW1wb3JhcmlseSBvcHRpb24gb2JqZWN0c1xuLy8gaW4gdGhlIG1ham9yaXR5IG9mIGNhc2VzXG5cbnZhciBkZWZhdWx0Q3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMgPSB7XG4gIGRlZXA6IHRydWUsXG4gIG5hbWU6IHVuZGVmaW5lZCxcbiAgZGVmYXVsdERlY29yYXRvcjogdW5kZWZpbmVkLFxuICBwcm94eTogdHJ1ZVxufTtcbk9iamVjdC5mcmVlemUoZGVmYXVsdENyZWF0ZU9ic2VydmFibGVPcHRpb25zKTtcbmZ1bmN0aW9uIGFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnModGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nIHx8IGRlZmF1bHRDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucztcbn1cbnZhciBvYnNlcnZhYmxlQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihPQlNFUlZBQkxFKTtcbnZhciBvYnNlcnZhYmxlUmVmQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihPQlNFUlZBQkxFX1JFRiwge1xuICBlbmhhbmNlcjogcmVmZXJlbmNlRW5oYW5jZXJcbn0pO1xudmFyIG9ic2VydmFibGVTaGFsbG93QW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihPQlNFUlZBQkxFX1NIQUxMT1csIHtcbiAgZW5oYW5jZXI6IHNoYWxsb3dFbmhhbmNlclxufSk7XG52YXIgb2JzZXJ2YWJsZVN0cnVjdEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oT0JTRVJWQUJMRV9TVFJVQ1QsIHtcbiAgZW5oYW5jZXI6IHJlZlN0cnVjdEVuaGFuY2VyXG59KTtcbnZhciBvYnNlcnZhYmxlRGVjb3JhdG9yQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKG9ic2VydmFibGVBbm5vdGF0aW9uKTtcbmZ1bmN0aW9uIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5kZWVwID09PSB0cnVlID8gZGVlcEVuaGFuY2VyIDogb3B0aW9ucy5kZWVwID09PSBmYWxzZSA/IHJlZmVyZW5jZUVuaGFuY2VyIDogZ2V0RW5oYW5jZXJGcm9tQW5ub3RhdGlvbihvcHRpb25zLmRlZmF1bHREZWNvcmF0b3IpO1xufVxuZnVuY3Rpb24gZ2V0QW5ub3RhdGlvbkZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGRlZmF1bHREZWNvcjtcblxuICByZXR1cm4gb3B0aW9ucyA/IChfb3B0aW9ucyRkZWZhdWx0RGVjb3IgPSBvcHRpb25zLmRlZmF1bHREZWNvcmF0b3IpICE9IG51bGwgPyBfb3B0aW9ucyRkZWZhdWx0RGVjb3IgOiBjcmVhdGVBdXRvQW5ub3RhdGlvbihvcHRpb25zKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEVuaGFuY2VyRnJvbUFubm90YXRpb24oYW5ub3RhdGlvbikge1xuICB2YXIgX2Fubm90YXRpb24kb3B0aW9uc18kLCBfYW5ub3RhdGlvbiRvcHRpb25zXztcblxuICByZXR1cm4gIWFubm90YXRpb24gPyBkZWVwRW5oYW5jZXIgOiAoX2Fubm90YXRpb24kb3B0aW9uc18kID0gKF9hbm5vdGF0aW9uJG9wdGlvbnNfID0gYW5ub3RhdGlvbi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9uJG9wdGlvbnNfLmVuaGFuY2VyKSAhPSBudWxsID8gX2Fubm90YXRpb24kb3B0aW9uc18kIDogZGVlcEVuaGFuY2VyO1xufVxuLyoqXHJcbiAqIFR1cm5zIGFuIG9iamVjdCwgYXJyYXkgb3IgZnVuY3Rpb24gaW50byBhIHJlYWN0aXZlIHN0cnVjdHVyZS5cclxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHdoaWNoIHNob3VsZCBiZWNvbWUgb2JzZXJ2YWJsZS5cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGUodiwgYXJnMiwgYXJnMykge1xuICAvLyBAb2JzZXJ2YWJsZSBzb21lUHJvcDtcbiAgaWYgKGlzU3RyaW5naXNoKGFyZzIpKSB7XG4gICAgc3RvcmVBbm5vdGF0aW9uKHYsIGFyZzIsIG9ic2VydmFibGVBbm5vdGF0aW9uKTtcbiAgICByZXR1cm47XG4gIH0gLy8gYWxyZWFkeSBvYnNlcnZhYmxlIC0gaWdub3JlXG5cblxuICBpZiAoaXNPYnNlcnZhYmxlKHYpKSByZXR1cm4gdjsgLy8gcGxhaW4gb2JqZWN0XG5cbiAgaWYgKGlzUGxhaW5PYmplY3QodikpIHJldHVybiBvYnNlcnZhYmxlLm9iamVjdCh2LCBhcmcyLCBhcmczKTsgLy8gQXJyYXlcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkgcmV0dXJuIG9ic2VydmFibGUuYXJyYXkodiwgYXJnMik7IC8vIE1hcFxuXG4gIGlmIChpc0VTNk1hcCh2KSkgcmV0dXJuIG9ic2VydmFibGUubWFwKHYsIGFyZzIpOyAvLyBTZXRcblxuICBpZiAoaXNFUzZTZXQodikpIHJldHVybiBvYnNlcnZhYmxlLnNldCh2LCBhcmcyKTsgLy8gb3RoZXIgb2JqZWN0IC0gaWdub3JlXG5cbiAgaWYgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT09IG51bGwpIHJldHVybiB2OyAvLyBhbnl0aGluZyBlbHNlXG5cbiAgcmV0dXJuIG9ic2VydmFibGUuYm94KHYsIGFyZzIpO1xufVxuXG5PYmplY3QuYXNzaWduKGNyZWF0ZU9ic2VydmFibGUsIG9ic2VydmFibGVEZWNvcmF0b3JBbm5vdGF0aW9uKTtcbnZhciBvYnNlcnZhYmxlRmFjdG9yaWVzID0ge1xuICBib3g6IGZ1bmN0aW9uIGJveCh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lLCB0cnVlLCBvLmVxdWFscyk7XG4gIH0sXG4gIGFycmF5OiBmdW5jdGlvbiBhcnJheShpbml0aWFsVmFsdWVzLCBvcHRpb25zKSB7XG4gICAgdmFyIG8gPSBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiAoZ2xvYmFsU3RhdGUudXNlUHJveGllcyA9PT0gZmFsc2UgfHwgby5wcm94eSA9PT0gZmFsc2UgPyBjcmVhdGVMZWdhY3lBcnJheSA6IGNyZWF0ZU9ic2VydmFibGVBcnJheSkoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgbWFwOiBmdW5jdGlvbiBtYXAoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVNYXAoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTZXQoaW5pdGlhbFZhbHVlcywgZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvKSwgby5uYW1lKTtcbiAgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3QocHJvcHMsIGRlY29yYXRvcnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZXh0ZW5kT2JzZXJ2YWJsZShnbG9iYWxTdGF0ZS51c2VQcm94aWVzID09PSBmYWxzZSB8fCAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wcm94eSkgPT09IGZhbHNlID8gYXNPYnNlcnZhYmxlT2JqZWN0KHt9LCBvcHRpb25zKSA6IGFzRHluYW1pY09ic2VydmFibGVPYmplY3Qoe30sIG9wdGlvbnMpLCBwcm9wcywgZGVjb3JhdG9ycyk7XG4gIH0sXG4gIHJlZjogLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24ob2JzZXJ2YWJsZVJlZkFubm90YXRpb24pLFxuICBzaGFsbG93OiAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlU2hhbGxvd0Fubm90YXRpb24pLFxuICBkZWVwOiBvYnNlcnZhYmxlRGVjb3JhdG9yQW5ub3RhdGlvbixcbiAgc3RydWN0OiAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlU3RydWN0QW5ub3RhdGlvbilcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG52YXIgb2JzZXJ2YWJsZSA9IC8qI19fUFVSRV9fKi9hc3NpZ24oY3JlYXRlT2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZUZhY3Rvcmllcyk7XG5cbnZhciBDT01QVVRFRCA9IFwiY29tcHV0ZWRcIjtcbnZhciBDT01QVVRFRF9TVFJVQ1QgPSBcImNvbXB1dGVkLnN0cnVjdFwiO1xudmFyIGNvbXB1dGVkQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb21wdXRlZEFubm90YXRpb24oQ09NUFVURUQpO1xudmFyIGNvbXB1dGVkU3RydWN0QW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb21wdXRlZEFubm90YXRpb24oQ09NUFVURURfU1RSVUNULCB7XG4gIGVxdWFsczogY29tcGFyZXIuc3RydWN0dXJhbFxufSk7XG4vKipcclxuICogRGVjb3JhdG9yIGZvciBjbGFzcyBwcm9wZXJ0aWVzOiBAY29tcHV0ZWQgZ2V0IHZhbHVlKCkgeyByZXR1cm4gZXhwcjsgfS5cclxuICogRm9yIGxlZ2FjeSBwdXJwb3NlcyBhbHNvIGludm9rYWJsZSBhcyBFUzUgb2JzZXJ2YWJsZSBjcmVhdGVkOiBgY29tcHV0ZWQoKCkgPT4gZXhwcilgO1xyXG4gKi9cblxudmFyIGNvbXB1dGVkID0gZnVuY3Rpb24gY29tcHV0ZWQoYXJnMSwgYXJnMikge1xuICBpZiAoaXNTdHJpbmdpc2goYXJnMikpIHtcbiAgICAvLyBAY29tcHV0ZWRcbiAgICByZXR1cm4gc3RvcmVBbm5vdGF0aW9uKGFyZzEsIGFyZzIsIGNvbXB1dGVkQW5ub3RhdGlvbik7XG4gIH1cblxuICBpZiAoaXNQbGFpbk9iamVjdChhcmcxKSkge1xuICAgIC8vIEBjb21wdXRlZCh7IG9wdGlvbnMgfSlcbiAgICByZXR1cm4gY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihjcmVhdGVDb21wdXRlZEFubm90YXRpb24oQ09NUFVURUQsIGFyZzEpKTtcbiAgfSAvLyBjb21wdXRlZChleHByLCBvcHRpb25zPylcblxuXG4gIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oYXJnMSkpIGRpZShcIkZpcnN0IGFyZ3VtZW50IHRvIGBjb21wdXRlZGAgc2hvdWxkIGJlIGFuIGV4cHJlc3Npb24uXCIpO1xuICAgIGlmIChpc0Z1bmN0aW9uKGFyZzIpKSBkaWUoXCJBIHNldHRlciBhcyBzZWNvbmQgYXJndW1lbnQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCwgdXNlIGB7IHNldDogZm4gfWAgb3B0aW9uIGluc3RlYWRcIik7XG4gIH1cblxuICB2YXIgb3B0cyA9IGlzUGxhaW5PYmplY3QoYXJnMikgPyBhcmcyIDoge307XG4gIG9wdHMuZ2V0ID0gYXJnMTtcbiAgb3B0cy5uYW1lIHx8IChvcHRzLm5hbWUgPSBhcmcxLm5hbWUgfHwgXCJcIik7XG4gIC8qIGZvciBnZW5lcmF0ZWQgbmFtZSAqL1xuXG4gIHJldHVybiBuZXcgQ29tcHV0ZWRWYWx1ZShvcHRzKTtcbn07XG5PYmplY3QuYXNzaWduKGNvbXB1dGVkLCBjb21wdXRlZEFubm90YXRpb24pO1xuY29tcHV0ZWQuc3RydWN0ID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oY29tcHV0ZWRTdHJ1Y3RBbm5vdGF0aW9uKTtcblxudmFyIF9nZXREZXNjcmlwdG9yJGNvbmZpZywgX2dldERlc2NyaXB0b3I7XG4vLyBtb2J4IHZlcnNpb25zXG5cbnZhciBjdXJyZW50QWN0aW9uSWQgPSAwO1xudmFyIG5leHRBY3Rpb25JZCA9IDE7XG52YXIgaXNGdW5jdGlvbk5hbWVDb25maWd1cmFibGUgPSAoX2dldERlc2NyaXB0b3IkY29uZmlnID0gKF9nZXREZXNjcmlwdG9yID0gLyojX19QVVJFX18qL2dldERlc2NyaXB0b3IoZnVuY3Rpb24gKCkge30sIFwibmFtZVwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXREZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkgIT0gbnVsbCA/IF9nZXREZXNjcmlwdG9yJGNvbmZpZyA6IGZhbHNlOyAvLyB3ZSBjYW4gc2FmZWx5IHJlY3ljbGUgdGhpcyBvYmplY3RcblxudmFyIHRtcE5hbWVEZXNjcmlwdG9yID0ge1xuICB2YWx1ZTogXCJhY3Rpb25cIixcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlXG59O1xuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKGFjdGlvbk5hbWUsIGZuLCBhdXRvQWN0aW9uLCByZWYpIHtcbiAgaWYgKGF1dG9BY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIGF1dG9BY3Rpb24gPSBmYWxzZTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oZm4pKSBkaWUoXCJgYWN0aW9uYCBjYW4gb25seSBiZSBpbnZva2VkIG9uIGZ1bmN0aW9uc1wiKTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbk5hbWUgIT09IFwic3RyaW5nXCIgfHwgIWFjdGlvbk5hbWUpIGRpZShcImFjdGlvbnMgc2hvdWxkIGhhdmUgdmFsaWQgbmFtZXMsIGdvdDogJ1wiICsgYWN0aW9uTmFtZSArIFwiJ1wiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcygpIHtcbiAgICByZXR1cm4gZXhlY3V0ZUFjdGlvbihhY3Rpb25OYW1lLCBhdXRvQWN0aW9uLCBmbiwgcmVmIHx8IHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXMuaXNNb2J4QWN0aW9uID0gdHJ1ZTtcblxuICBpZiAoaXNGdW5jdGlvbk5hbWVDb25maWd1cmFibGUpIHtcbiAgICB0bXBOYW1lRGVzY3JpcHRvci52YWx1ZSA9IGFjdGlvbk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcywgXCJuYW1lXCIsIHRtcE5hbWVEZXNjcmlwdG9yKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBleGVjdXRlQWN0aW9uKGFjdGlvbk5hbWUsIGNhblJ1bkFzRGVyaXZhdGlvbiwgZm4sIHNjb3BlLCBhcmdzKSB7XG4gIHZhciBydW5JbmZvID0gX3N0YXJ0QWN0aW9uKGFjdGlvbk5hbWUsIGNhblJ1bkFzRGVyaXZhdGlvbiwgc2NvcGUsIGFyZ3MpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHNjb3BlLCBhcmdzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcnVuSW5mby5lcnJvcl8gPSBlcnI7XG4gICAgdGhyb3cgZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIF9lbmRBY3Rpb24ocnVuSW5mbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9zdGFydEFjdGlvbihhY3Rpb25OYW1lLCBjYW5SdW5Bc0Rlcml2YXRpb24sIC8vIHRydWUgZm9yIGF1dG9BY3Rpb25cbnNjb3BlLCBhcmdzKSB7XG4gIHZhciBub3RpZnlTcHlfID0gIGlzU3B5RW5hYmxlZCgpICYmICEhYWN0aW9uTmFtZTtcbiAgdmFyIHN0YXJ0VGltZV8gPSAwO1xuXG4gIGlmICggbm90aWZ5U3B5Xykge1xuICAgIHN0YXJ0VGltZV8gPSBEYXRlLm5vdygpO1xuICAgIHZhciBmbGF0dGVuZWRBcmdzID0gYXJncyA/IEFycmF5LmZyb20oYXJncykgOiBFTVBUWV9BUlJBWTtcbiAgICBzcHlSZXBvcnRTdGFydCh7XG4gICAgICB0eXBlOiBBQ1RJT04sXG4gICAgICBuYW1lOiBhY3Rpb25OYW1lLFxuICAgICAgb2JqZWN0OiBzY29wZSxcbiAgICAgIGFyZ3VtZW50czogZmxhdHRlbmVkQXJnc1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHByZXZEZXJpdmF0aW9uXyA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgdmFyIHJ1bkFzQWN0aW9uID0gIWNhblJ1bkFzRGVyaXZhdGlvbiB8fCAhcHJldkRlcml2YXRpb25fO1xuICBzdGFydEJhdGNoKCk7XG4gIHZhciBwcmV2QWxsb3dTdGF0ZUNoYW5nZXNfID0gZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXM7IC8vIGJ5IGRlZmF1bHQgcHJlc2VydmUgcHJldmlvdXMgYWxsb3dcblxuICBpZiAocnVuQXNBY3Rpb24pIHtcbiAgICB1bnRyYWNrZWRTdGFydCgpO1xuICAgIHByZXZBbGxvd1N0YXRlQ2hhbmdlc18gPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KHRydWUpO1xuICB9XG5cbiAgdmFyIHByZXZBbGxvd1N0YXRlUmVhZHNfID0gYWxsb3dTdGF0ZVJlYWRzU3RhcnQodHJ1ZSk7XG4gIHZhciBydW5JbmZvID0ge1xuICAgIHJ1bkFzQWN0aW9uXzogcnVuQXNBY3Rpb24sXG4gICAgcHJldkRlcml2YXRpb25fOiBwcmV2RGVyaXZhdGlvbl8sXG4gICAgcHJldkFsbG93U3RhdGVDaGFuZ2VzXzogcHJldkFsbG93U3RhdGVDaGFuZ2VzXyxcbiAgICBwcmV2QWxsb3dTdGF0ZVJlYWRzXzogcHJldkFsbG93U3RhdGVSZWFkc18sXG4gICAgbm90aWZ5U3B5Xzogbm90aWZ5U3B5XyxcbiAgICBzdGFydFRpbWVfOiBzdGFydFRpbWVfLFxuICAgIGFjdGlvbklkXzogbmV4dEFjdGlvbklkKyssXG4gICAgcGFyZW50QWN0aW9uSWRfOiBjdXJyZW50QWN0aW9uSWRcbiAgfTtcbiAgY3VycmVudEFjdGlvbklkID0gcnVuSW5mby5hY3Rpb25JZF87XG4gIHJldHVybiBydW5JbmZvO1xufVxuZnVuY3Rpb24gX2VuZEFjdGlvbihydW5JbmZvKSB7XG4gIGlmIChjdXJyZW50QWN0aW9uSWQgIT09IHJ1bkluZm8uYWN0aW9uSWRfKSB7XG4gICAgZGllKDMwKTtcbiAgfVxuXG4gIGN1cnJlbnRBY3Rpb25JZCA9IHJ1bkluZm8ucGFyZW50QWN0aW9uSWRfO1xuXG4gIGlmIChydW5JbmZvLmVycm9yXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2xvYmFsU3RhdGUuc3VwcHJlc3NSZWFjdGlvbkVycm9ycyA9IHRydWU7XG4gIH1cblxuICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChydW5JbmZvLnByZXZBbGxvd1N0YXRlQ2hhbmdlc18pO1xuICBhbGxvd1N0YXRlUmVhZHNFbmQocnVuSW5mby5wcmV2QWxsb3dTdGF0ZVJlYWRzXyk7XG4gIGVuZEJhdGNoKCk7XG4gIGlmIChydW5JbmZvLnJ1bkFzQWN0aW9uXykgdW50cmFja2VkRW5kKHJ1bkluZm8ucHJldkRlcml2YXRpb25fKTtcblxuICBpZiAoIHJ1bkluZm8ubm90aWZ5U3B5Xykge1xuICAgIHNweVJlcG9ydEVuZCh7XG4gICAgICB0aW1lOiBEYXRlLm5vdygpIC0gcnVuSW5mby5zdGFydFRpbWVfXG4gICAgfSk7XG4gIH1cblxuICBnbG9iYWxTdGF0ZS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzID0gZmFsc2U7XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlQ2hhbmdlcyhhbGxvd1N0YXRlQ2hhbmdlcywgZnVuYykge1xuICB2YXIgcHJldiA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQoYWxsb3dTdGF0ZUNoYW5nZXMpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZ1bmMoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KTtcbiAgfVxufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydChhbGxvd1N0YXRlQ2hhbmdlcykge1xuICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzO1xuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyA9IGFsbG93U3RhdGVDaGFuZ2VzO1xuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHByZXYpIHtcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSBwcmV2O1xufVxuXG52YXIgX1N5bWJvbCR0b1ByaW1pdGl2ZTtcbnZhciBDUkVBVEUgPSBcImNyZWF0ZVwiO1xuX1N5bWJvbCR0b1ByaW1pdGl2ZSA9IFN5bWJvbC50b1ByaW1pdGl2ZTtcbnZhciBPYnNlcnZhYmxlVmFsdWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BdG9tKSB7XG4gIF9pbmhlcml0c0xvb3NlKE9ic2VydmFibGVWYWx1ZSwgX0F0b20pO1xuXG4gIGZ1bmN0aW9uIE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZW5oYW5jZXIsIG5hbWVfLCBub3RpZnlTcHksIGVxdWFscykge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9ICBcIk9ic2VydmFibGVWYWx1ZUBcIiArIGdldE5leHRJZCgpIDtcbiAgICB9XG5cbiAgICBpZiAobm90aWZ5U3B5ID09PSB2b2lkIDApIHtcbiAgICAgIG5vdGlmeVNweSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGVxdWFscyA9PT0gdm9pZCAwKSB7XG4gICAgICBlcXVhbHMgPSBjb21wYXJlcltcImRlZmF1bHRcIl07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQXRvbS5jYWxsKHRoaXMsIG5hbWVfKSB8fCB0aGlzO1xuICAgIF90aGlzLmVuaGFuY2VyID0gdm9pZCAwO1xuICAgIF90aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIF90aGlzLmVxdWFscyA9IHZvaWQgMDtcbiAgICBfdGhpcy5oYXNVbnJlcG9ydGVkQ2hhbmdlXyA9IGZhbHNlO1xuICAgIF90aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgX3RoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICBfdGhpcy52YWx1ZV8gPSB2b2lkIDA7XG4gICAgX3RoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMuZW5oYW5jZXIgPSBlbmhhbmNlcjtcbiAgICBfdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIF90aGlzLmVxdWFscyA9IGVxdWFscztcbiAgICBfdGhpcy52YWx1ZV8gPSBlbmhhbmNlcih2YWx1ZSwgdW5kZWZpbmVkLCBuYW1lXyk7XG5cbiAgICBpZiAoIG5vdGlmeVNweSAmJiBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgLy8gb25seSBub3RpZnkgc3B5IGlmIHRoaXMgaXMgYSBzdGFuZC1hbG9uZSBvYnNlcnZhYmxlXG4gICAgICBzcHlSZXBvcnQoe1xuICAgICAgICB0eXBlOiBDUkVBVEUsXG4gICAgICAgIG9iamVjdDogX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInZhbHVlXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogX3RoaXMubmFtZV8sXG4gICAgICAgIG5ld1ZhbHVlOiBcIlwiICsgX3RoaXMudmFsdWVfXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZVZhbHVlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVoYW5jZVZhbHVlID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgbmV3VmFsdWUgPSB0aGlzLnByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpO1xuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcblxuICAgICAgaWYgKCBub3RpZnlTcHkpIHtcbiAgICAgICAgc3B5UmVwb3J0U3RhcnQoe1xuICAgICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwidmFsdWVcIixcbiAgICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucHJlcGFyZU5ld1ZhbHVlXyA9IGZ1bmN0aW9uIHByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpIHtcbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzKTtcblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEO1xuICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgfSAvLyBhcHBseSBtb2RpZmllclxuXG5cbiAgICBuZXdWYWx1ZSA9IHRoaXMuZW5oYW5jZXIobmV3VmFsdWUsIHRoaXMudmFsdWVfLCB0aGlzLm5hbWVfKTtcbiAgICByZXR1cm4gdGhpcy5lcXVhbHModGhpcy52YWx1ZV8sIG5ld1ZhbHVlKSA/IGdsb2JhbFN0YXRlLlVOQ0hBTkdFRCA6IG5ld1ZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5zZXROZXdWYWx1ZV8gPSBmdW5jdGlvbiBzZXROZXdWYWx1ZV8obmV3VmFsdWUpIHtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICB0aGlzLnZhbHVlXyA9IG5ld1ZhbHVlO1xuICAgIHRoaXMucmVwb3J0Q2hhbmdlZCgpO1xuXG4gICAgaWYgKGhhc0xpc3RlbmVycyh0aGlzKSkge1xuICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIHtcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB0aGlzLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlKHRoaXMudmFsdWVfKTtcbiAgfTtcblxuICBfcHJvdG8uaW50ZXJjZXB0XyA9IGZ1bmN0aW9uIGludGVyY2VwdF8oaGFuZGxlcikge1xuICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICB9O1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICBpZiAoZmlyZUltbWVkaWF0ZWx5KSBsaXN0ZW5lcih7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJ2YWx1ZVwiLFxuICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgbmV3VmFsdWU6IHRoaXMudmFsdWVfLFxuICAgICAgb2xkVmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcblxuICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KCkge1xuICAgIC8vIHVzZWQgYnkgTVNUIG90IGdldCB1bmRlaGFuY2VkIHZhbHVlXG4gICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICB9O1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV8gKyBcIltcIiArIHRoaXMudmFsdWVfICsgXCJdXCI7XG4gIH07XG5cbiAgX3Byb3RvLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0b1ByaW1pdGl2ZSh0aGlzLmdldCgpKTtcbiAgfTtcblxuICBfcHJvdG9bX1N5bWJvbCR0b1ByaW1pdGl2ZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuICB9O1xuXG4gIHJldHVybiBPYnNlcnZhYmxlVmFsdWU7XG59KEF0b20pO1xudmFyIGlzT2JzZXJ2YWJsZVZhbHVlID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlVmFsdWVcIiwgT2JzZXJ2YWJsZVZhbHVlKTtcblxudmFyIF9TeW1ib2wkdG9QcmltaXRpdmUkMTtcbi8qKlxyXG4gKiBBIG5vZGUgaW4gdGhlIHN0YXRlIGRlcGVuZGVuY3kgcm9vdCB0aGF0IG9ic2VydmVzIG90aGVyIG5vZGVzLCBhbmQgY2FuIGJlIG9ic2VydmVkIGl0c2VsZi5cclxuICpcclxuICogQ29tcHV0ZWRWYWx1ZSB3aWxsIHJlbWVtYmVyIHRoZSByZXN1bHQgb2YgdGhlIGNvbXB1dGF0aW9uIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGJhdGNoLCBvclxyXG4gKiB3aGlsZSBiZWluZyBvYnNlcnZlZC5cclxuICpcclxuICogRHVyaW5nIHRoaXMgdGltZSBpdCB3aWxsIHJlY29tcHV0ZSBvbmx5IHdoZW4gb25lIG9mIGl0cyBkaXJlY3QgZGVwZW5kZW5jaWVzIGNoYW5nZWQsXHJcbiAqIGJ1dCBvbmx5IHdoZW4gaXQgaXMgYmVpbmcgYWNjZXNzZWQgd2l0aCBgQ29tcHV0ZWRWYWx1ZS5nZXQoKWAuXHJcbiAqXHJcbiAqIEltcGxlbWVudGF0aW9uIGRlc2NyaXB0aW9uOlxyXG4gKiAxLiBGaXJzdCB0aW1lIGl0J3MgYmVpbmcgYWNjZXNzZWQgaXQgd2lsbCBjb21wdXRlIGFuZCByZW1lbWJlciByZXN1bHRcclxuICogICAgZ2l2ZSBiYWNrIHJlbWVtYmVyZWQgcmVzdWx0IHVudGlsIDIuIGhhcHBlbnNcclxuICogMi4gRmlyc3QgdGltZSBhbnkgZGVlcCBkZXBlbmRlbmN5IGNoYW5nZSwgcHJvcGFnYXRlIFBPU1NJQkxZX1NUQUxFIHRvIGFsbCBvYnNlcnZlcnMsIHdhaXQgZm9yIDMuXHJcbiAqIDMuIFdoZW4gaXQncyBiZWluZyBhY2Nlc3NlZCwgcmVjb21wdXRlIGlmIGFueSBzaGFsbG93IGRlcGVuZGVuY3kgY2hhbmdlZC5cclxuICogICAgaWYgcmVzdWx0IGNoYW5nZWQ6IHByb3BhZ2F0ZSBTVEFMRSB0byBhbGwgb2JzZXJ2ZXJzLCB0aGF0IHdlcmUgUE9TU0lCTFlfU1RBTEUgZnJvbSB0aGUgbGFzdCBzdGVwLlxyXG4gKiAgICBnbyB0byBzdGVwIDIuIGVpdGhlciB3YXlcclxuICpcclxuICogSWYgYXQgYW55IHBvaW50IGl0J3Mgb3V0c2lkZSBiYXRjaCBhbmQgaXQgaXNuJ3Qgb2JzZXJ2ZWQ6IHJlc2V0IGV2ZXJ5dGhpbmcgYW5kIGdvIHRvIDEuXHJcbiAqL1xuXG5fU3ltYm9sJHRvUHJpbWl0aXZlJDEgPSBTeW1ib2wudG9QcmltaXRpdmU7XG52YXIgQ29tcHV0ZWRWYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIG5vZGVzIHdlIGFyZSBsb29raW5nIGF0LiBPdXIgdmFsdWUgZGVwZW5kcyBvbiB0aGVzZSBub2Rlc1xuICAvLyBkdXJpbmcgdHJhY2tpbmcgaXQncyBhbiBhcnJheSB3aXRoIG5ldyBvYnNlcnZlZCBvYnNlcnZlcnNcbiAgLy8gdG8gY2hlY2sgZm9yIGN5Y2xlc1xuICAvLyBOLkI6IHVubWluaWZpZWQgYXMgaXQgaXMgdXNlZCBieSBNU1RcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgY29tcHV0ZWQgdmFsdWUgYmFzZWQgb24gYSBmdW5jdGlvbiBleHByZXNzaW9uLlxyXG4gICAqXHJcbiAgICogVGhlIGBuYW1lYCBwcm9wZXJ0eSBpcyBmb3IgZGVidWcgcHVycG9zZXMgb25seS5cclxuICAgKlxyXG4gICAqIFRoZSBgZXF1YWxzYCBwcm9wZXJ0eSBzcGVjaWZpZXMgdGhlIGNvbXBhcmVyIGZ1bmN0aW9uIHRvIHVzZSB0byBkZXRlcm1pbmUgaWYgYSBuZXdseSBwcm9kdWNlZFxyXG4gICAqIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgcHJldmlvdXMgdmFsdWUuIFR3byBjb21wYXJlcnMgYXJlIHByb3ZpZGVkIGluIHRoZSBsaWJyYXJ5OyBgZGVmYXVsdENvbXBhcmVyYFxyXG4gICAqIGNvbXBhcmVzIGJhc2VkIG9uIGlkZW50aXR5IGNvbXBhcmlzb24gKD09PSksIGFuZCBgc3RydWN0dXJhbENvbXBhcmVyYCBkZWVwbHkgY29tcGFyZXMgdGhlIHN0cnVjdHVyZS5cclxuICAgKiBTdHJ1Y3R1cmFsIGNvbXBhcmlzb24gY2FuIGJlIGNvbnZlbmllbnQgaWYgeW91IGFsd2F5cyBwcm9kdWNlIGEgbmV3IGFnZ3JlZ2F0ZWQgb2JqZWN0IGFuZFxyXG4gICAqIGRvbid0IHdhbnQgdG8gbm90aWZ5IG9ic2VydmVycyBpZiBpdCBpcyBzdHJ1Y3R1cmFsbHkgdGhlIHNhbWUuXHJcbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIHdvcmtpbmcgd2l0aCB2ZWN0b3JzLCBtb3VzZSBjb29yZGluYXRlcyBldGMuXHJcbiAgICovXG4gIGZ1bmN0aW9uIENvbXB1dGVkVmFsdWUob3B0aW9ucykge1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB0aGlzLm9ic2VydmluZ18gPSBbXTtcbiAgICB0aGlzLm5ld09ic2VydmluZ18gPSBudWxsO1xuICAgIHRoaXMuaXNCZWluZ09ic2VydmVkXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbl8gPSBmYWxzZTtcbiAgICB0aGlzLm9ic2VydmVyc18gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5kaWZmVmFsdWVfID0gMDtcbiAgICB0aGlzLnJ1bklkXyA9IDA7XG4gICAgdGhpcy5sYXN0QWNjZXNzZWRCeV8gPSAwO1xuICAgIHRoaXMubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXztcbiAgICB0aGlzLnVuYm91bmREZXBzQ291bnRfID0gMDtcbiAgICB0aGlzLnZhbHVlXyA9IG5ldyBDYXVnaHRFeGNlcHRpb24obnVsbCk7XG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRyaWdnZXJlZEJ5XyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ29tcHV0aW5nXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNSdW5uaW5nU2V0dGVyXyA9IGZhbHNlO1xuICAgIHRoaXMuZGVyaXZhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLnNldHRlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc1RyYWNpbmdfID0gVHJhY2VNb2RlLk5PTkU7XG4gICAgdGhpcy5zY29wZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5lcXVhbHNfID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWlyZXNSZWFjdGlvbl8gPSB2b2lkIDA7XG4gICAgdGhpcy5rZWVwQWxpdmVfID0gdm9pZCAwO1xuICAgIHRoaXMub25CT0wgPSB2b2lkIDA7XG4gICAgdGhpcy5vbkJVT0wgPSB2b2lkIDA7XG4gICAgaWYgKCFvcHRpb25zLmdldCkgZGllKDMxKTtcbiAgICB0aGlzLmRlcml2YXRpb24gPSBvcHRpb25zLmdldDtcbiAgICB0aGlzLm5hbWVfID0gb3B0aW9ucy5uYW1lIHx8ICggXCJDb21wdXRlZFZhbHVlQFwiICsgZ2V0TmV4dElkKCkgKTtcblxuICAgIGlmIChvcHRpb25zLnNldCkge1xuICAgICAgdGhpcy5zZXR0ZXJfID0gY3JlYXRlQWN0aW9uKCB0aGlzLm5hbWVfICsgXCItc2V0dGVyXCIgLCBvcHRpb25zLnNldCk7XG4gICAgfVxuXG4gICAgdGhpcy5lcXVhbHNfID0gb3B0aW9ucy5lcXVhbHMgfHwgKG9wdGlvbnMuY29tcGFyZVN0cnVjdHVyYWwgfHwgb3B0aW9ucy5zdHJ1Y3QgPyBjb21wYXJlci5zdHJ1Y3R1cmFsIDogY29tcGFyZXJbXCJkZWZhdWx0XCJdKTtcbiAgICB0aGlzLnNjb3BlXyA9IG9wdGlvbnMuY29udGV4dDtcbiAgICB0aGlzLnJlcXVpcmVzUmVhY3Rpb25fID0gISFvcHRpb25zLnJlcXVpcmVzUmVhY3Rpb247XG4gICAgdGhpcy5rZWVwQWxpdmVfID0gISFvcHRpb25zLmtlZXBBbGl2ZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDb21wdXRlZFZhbHVlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ub25CZWNvbWVTdGFsZV8gPSBmdW5jdGlvbiBvbkJlY29tZVN0YWxlXygpIHtcbiAgICBwcm9wYWdhdGVNYXliZUNoYW5nZWQodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLm9uQk8gPSBmdW5jdGlvbiBvbkJPKCkge1xuICAgIGlmICh0aGlzLm9uQk9MKSB7XG4gICAgICB0aGlzLm9uQk9MLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkJVTyA9IGZ1bmN0aW9uIG9uQlVPKCkge1xuICAgIGlmICh0aGlzLm9uQlVPTCkge1xuICAgICAgdGhpcy5vbkJVT0wuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGlzIGNvbXB1dGVkIHZhbHVlLlxyXG4gICAqIFdpbGwgZXZhbHVhdGUgaXRzIGNvbXB1dGF0aW9uIGZpcnN0IGlmIG5lZWRlZC5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuaXNDb21wdXRpbmdfKSBkaWUoMzIsIHRoaXMubmFtZV8sIHRoaXMuZGVyaXZhdGlvbik7XG5cbiAgICBpZiAoZ2xvYmFsU3RhdGUuaW5CYXRjaCA9PT0gMCAmJiAvLyAhZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0cGlvbiAmJlxuICAgIHRoaXMub2JzZXJ2ZXJzXy5zaXplID09PSAwICYmICF0aGlzLmtlZXBBbGl2ZV8pIHtcbiAgICAgIGlmIChzaG91bGRDb21wdXRlKHRoaXMpKSB7XG4gICAgICAgIHRoaXMud2FybkFib3V0VW50cmFja2VkUmVhZF8oKTtcbiAgICAgICAgc3RhcnRCYXRjaCgpOyAvLyBTZWUgcGVyZiB0ZXN0ICdjb21wdXRlZCBtZW1vaXphdGlvbidcblxuICAgICAgICB0aGlzLnZhbHVlXyA9IHRoaXMuY29tcHV0ZVZhbHVlXyhmYWxzZSk7XG4gICAgICAgIGVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcG9ydE9ic2VydmVkKHRoaXMpO1xuXG4gICAgICBpZiAoc2hvdWxkQ29tcHV0ZSh0aGlzKSkge1xuICAgICAgICB2YXIgcHJldlRyYWNraW5nQ29udGV4dCA9IGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dDtcbiAgICAgICAgaWYgKHRoaXMua2VlcEFsaXZlXyAmJiAhcHJldlRyYWNraW5nQ29udGV4dCkgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMudHJhY2tBbmRDb21wdXRlKCkpIHByb3BhZ2F0ZUNoYW5nZUNvbmZpcm1lZCh0aGlzKTtcbiAgICAgICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gcHJldlRyYWNraW5nQ29udGV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy52YWx1ZV87XG4gICAgaWYgKGlzQ2F1Z2h0RXhjZXB0aW9uKHJlc3VsdCkpIHRocm93IHJlc3VsdC5jYXVzZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zZXR0ZXJfKSB7XG4gICAgICBpZiAodGhpcy5pc1J1bm5pbmdTZXR0ZXJfKSBkaWUoMzMsIHRoaXMubmFtZV8pO1xuICAgICAgdGhpcy5pc1J1bm5pbmdTZXR0ZXJfID0gdHJ1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZXR0ZXJfLmNhbGwodGhpcy5zY29wZV8sIHZhbHVlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nU2V0dGVyXyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBkaWUoMzQsIHRoaXMubmFtZV8pO1xuICB9O1xuXG4gIF9wcm90by50cmFja0FuZENvbXB1dGUgPSBmdW5jdGlvbiB0cmFja0FuZENvbXB1dGUoKSB7XG4gICAgLy8gTi5COiB1bm1pbmlmaWVkIGFzIGl0IGlzIHVzZWQgYnkgTVNUXG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgdmFyIHdhc1N1c3BlbmRlZCA9XG4gICAgLyogc2VlICMxMjA4ICovXG4gICAgdGhpcy5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG4gICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5jb21wdXRlVmFsdWVfKHRydWUpO1xuXG4gICAgaWYgKCBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwiY29tcHV0ZWRcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICBvYmplY3Q6IHRoaXMuc2NvcGVfLFxuICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxuICAgICAgICBvbGRWYWx1ZTogdGhpcy52YWx1ZV8sXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZWQgPSB3YXNTdXNwZW5kZWQgfHwgaXNDYXVnaHRFeGNlcHRpb24ob2xkVmFsdWUpIHx8IGlzQ2F1Z2h0RXhjZXB0aW9uKG5ld1ZhbHVlKSB8fCAhdGhpcy5lcXVhbHNfKG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG5cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy52YWx1ZV8gPSBuZXdWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfTtcblxuICBfcHJvdG8uY29tcHV0ZVZhbHVlXyA9IGZ1bmN0aW9uIGNvbXB1dGVWYWx1ZV8odHJhY2spIHtcbiAgICB0aGlzLmlzQ29tcHV0aW5nXyA9IHRydWU7IC8vIGRvbid0IGFsbG93IHN0YXRlIGNoYW5nZXMgZHVyaW5nIGNvbXB1dGF0aW9uXG5cbiAgICB2YXIgcHJldiA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQoZmFsc2UpO1xuICAgIHZhciByZXM7XG5cbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJlcyA9IHRyYWNrRGVyaXZlZEZ1bmN0aW9uKHRoaXMsIHRoaXMuZGVyaXZhdGlvbiwgdGhpcy5zY29wZV8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9PT0gdHJ1ZSkge1xuICAgICAgICByZXMgPSB0aGlzLmRlcml2YXRpb24uY2FsbCh0aGlzLnNjb3BlXyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuZGVyaXZhdGlvbi5jYWxsKHRoaXMuc2NvcGVfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlcyA9IG5ldyBDYXVnaHRFeGNlcHRpb24oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KTtcbiAgICB0aGlzLmlzQ29tcHV0aW5nXyA9IGZhbHNlO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgX3Byb3RvLnN1c3BlbmRfID0gZnVuY3Rpb24gc3VzcGVuZF8oKSB7XG4gICAgaWYgKCF0aGlzLmtlZXBBbGl2ZV8pIHtcbiAgICAgIGNsZWFyT2JzZXJ2aW5nKHRoaXMpO1xuICAgICAgdGhpcy52YWx1ZV8gPSB1bmRlZmluZWQ7IC8vIGRvbid0IGhvbGQgb24gdG8gY29tcHV0ZWQgdmFsdWUhXG5cbiAgICAgIGlmICggdGhpcy5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSBDb21wdXRlZCB2YWx1ZSAnXCIgKyB0aGlzLm5hbWVfICsgXCInIHdhcyBzdXNwZW5kZWQgYW5kIGl0IHdpbGwgcmVjb21wdXRlIG9uIHRoZSBuZXh0IGFjY2Vzcy5cIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG4gICAgdmFyIHByZXZWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gYXV0b3J1bihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUT0RPOiB3aHkgaXMgdGhpcyBpbiBhIGRpZmZlcmVudCBwbGFjZSB0aGFuIHRoZSBzcHlSZXBvcnQoKSBmdW5jdGlvbj8gaW4gYWxsIG90aGVyIG9ic2VydmFibGVzIGl0J3MgY2FsbGVkIGluIHRoZSBzYW1lIHBsYWNlXG4gICAgICB2YXIgbmV3VmFsdWUgPSBfdGhpcy5nZXQoKTtcblxuICAgICAgaWYgKCFmaXJzdFRpbWUgfHwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHZhciBwcmV2VSA9IHVudHJhY2tlZFN0YXJ0KCk7XG4gICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJjb21wdXRlZFwiLFxuICAgICAgICAgIGRlYnVnT2JqZWN0TmFtZTogX3RoaXMubmFtZV8sXG4gICAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICAgIG9iamVjdDogX3RoaXMsXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgIG9sZFZhbHVlOiBwcmV2VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHVudHJhY2tlZEVuZChwcmV2VSk7XG4gICAgICB9XG5cbiAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgcHJldlZhbHVlID0gbmV3VmFsdWU7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLndhcm5BYm91dFVudHJhY2tlZFJlYWRfID0gZnVuY3Rpb24gd2FybkFib3V0VW50cmFja2VkUmVhZF8oKSB7XG5cbiAgICBpZiAodGhpcy5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgY29uc29sZS5sb2coXCJbbW9ieC50cmFjZV0gQ29tcHV0ZWQgdmFsdWUgJ1wiICsgdGhpcy5uYW1lXyArIFwiJyBpcyBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0LiBEb2luZyBhIGZ1bGwgcmVjb21wdXRlLlwiKTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYmFsU3RhdGUuY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uIHx8IHRoaXMucmVxdWlyZXNSZWFjdGlvbl8pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlttb2J4XSBDb21wdXRlZCB2YWx1ZSAnXCIgKyB0aGlzLm5hbWVfICsgXCInIGlzIGJlaW5nIHJlYWQgb3V0c2lkZSBhIHJlYWN0aXZlIGNvbnRleHQuIERvaW5nIGEgZnVsbCByZWNvbXB1dGUuXCIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXyArIFwiW1wiICsgdGhpcy5kZXJpdmF0aW9uLnRvU3RyaW5nKCkgKyBcIl1cIjtcbiAgfTtcblxuICBfcHJvdG8udmFsdWVPZiA9IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRvUHJpbWl0aXZlKHRoaXMuZ2V0KCkpO1xuICB9O1xuXG4gIF9wcm90b1tfU3ltYm9sJHRvUHJpbWl0aXZlJDFdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcbiAgfTtcblxuICByZXR1cm4gQ29tcHV0ZWRWYWx1ZTtcbn0oKTtcbnZhciBpc0NvbXB1dGVkVmFsdWUgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIkNvbXB1dGVkVmFsdWVcIiwgQ29tcHV0ZWRWYWx1ZSk7XG5cbnZhciBJRGVyaXZhdGlvblN0YXRlXztcblxuKGZ1bmN0aW9uIChJRGVyaXZhdGlvblN0YXRlXykge1xuICAvLyBiZWZvcmUgYmVpbmcgcnVuIG9yIChvdXRzaWRlIGJhdGNoIGFuZCBub3QgYmVpbmcgb2JzZXJ2ZWQpXG4gIC8vIGF0IHRoaXMgcG9pbnQgZGVyaXZhdGlvbiBpcyBub3QgaG9sZGluZyBhbnkgZGF0YSBhYm91dCBkZXBlbmRlbmN5IHRyZWVcbiAgSURlcml2YXRpb25TdGF0ZV9bSURlcml2YXRpb25TdGF0ZV9bXCJOT1RfVFJBQ0tJTkdfXCJdID0gLTFdID0gXCJOT1RfVFJBQ0tJTkdfXCI7IC8vIG5vIHNoYWxsb3cgZGVwZW5kZW5jeSBjaGFuZ2VkIHNpbmNlIGxhc3QgY29tcHV0YXRpb25cbiAgLy8gd29uJ3QgcmVjYWxjdWxhdGUgZGVyaXZhdGlvblxuICAvLyB0aGlzIGlzIHdoYXQgbWFrZXMgbW9ieCBmYXN0XG5cbiAgSURlcml2YXRpb25TdGF0ZV9bSURlcml2YXRpb25TdGF0ZV9bXCJVUF9UT19EQVRFX1wiXSA9IDBdID0gXCJVUF9UT19EQVRFX1wiOyAvLyBzb21lIGRlZXAgZGVwZW5kZW5jeSBjaGFuZ2VkLCBidXQgZG9uJ3Qga25vdyBpZiBzaGFsbG93IGRlcGVuZGVuY3kgY2hhbmdlZFxuICAvLyB3aWxsIHJlcXVpcmUgdG8gY2hlY2sgZmlyc3QgaWYgVVBfVE9fREFURSBvciBQT1NTSUJMWV9TVEFMRVxuICAvLyBjdXJyZW50bHkgb25seSBDb21wdXRlZFZhbHVlIHdpbGwgcHJvcGFnYXRlIFBPU1NJQkxZX1NUQUxFXG4gIC8vXG4gIC8vIGhhdmluZyB0aGlzIHN0YXRlIGlzIHNlY29uZCBiaWcgb3B0aW1pemF0aW9uOlxuICAvLyBkb24ndCBoYXZlIHRvIHJlY29tcHV0ZSBvbiBldmVyeSBkZXBlbmRlbmN5IGNoYW5nZSwgYnV0IG9ubHkgd2hlbiBpdCdzIG5lZWRlZFxuXG4gIElEZXJpdmF0aW9uU3RhdGVfW0lEZXJpdmF0aW9uU3RhdGVfW1wiUE9TU0lCTFlfU1RBTEVfXCJdID0gMV0gPSBcIlBPU1NJQkxZX1NUQUxFX1wiOyAvLyBBIHNoYWxsb3cgZGVwZW5kZW5jeSBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IGNvbXB1dGF0aW9uIGFuZCB0aGUgZGVyaXZhdGlvblxuICAvLyB3aWxsIG5lZWQgdG8gcmVjb21wdXRlIHdoZW4gaXQncyBuZWVkZWQgbmV4dC5cblxuICBJRGVyaXZhdGlvblN0YXRlX1tJRGVyaXZhdGlvblN0YXRlX1tcIlNUQUxFX1wiXSA9IDJdID0gXCJTVEFMRV9cIjtcbn0pKElEZXJpdmF0aW9uU3RhdGVfIHx8IChJRGVyaXZhdGlvblN0YXRlXyA9IHt9KSk7XG5cbnZhciBUcmFjZU1vZGU7XG5cbihmdW5jdGlvbiAoVHJhY2VNb2RlKSB7XG4gIFRyYWNlTW9kZVtUcmFjZU1vZGVbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgVHJhY2VNb2RlW1RyYWNlTW9kZVtcIkxPR1wiXSA9IDFdID0gXCJMT0dcIjtcbiAgVHJhY2VNb2RlW1RyYWNlTW9kZVtcIkJSRUFLXCJdID0gMl0gPSBcIkJSRUFLXCI7XG59KShUcmFjZU1vZGUgfHwgKFRyYWNlTW9kZSA9IHt9KSk7XG5cbnZhciBDYXVnaHRFeGNlcHRpb24gPSBmdW5jdGlvbiBDYXVnaHRFeGNlcHRpb24oY2F1c2UpIHtcbiAgdGhpcy5jYXVzZSA9IHZvaWQgMDtcbiAgdGhpcy5jYXVzZSA9IGNhdXNlOyAvLyBFbXB0eVxufTtcbmZ1bmN0aW9uIGlzQ2F1Z2h0RXhjZXB0aW9uKGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBDYXVnaHRFeGNlcHRpb247XG59XG4vKipcclxuICogRmluZHMgb3V0IHdoZXRoZXIgYW55IGRlcGVuZGVuY3kgb2YgdGhlIGRlcml2YXRpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXHJcbiAqIElmIGRlcGVuZGVuY2llc1N0YXRlIGlzIDEgdGhlbiBpdCB3aWxsIHJlY2FsY3VsYXRlIGRlcGVuZGVuY2llcyxcclxuICogaWYgYW55IGRlcGVuZGVuY3kgY2hhbmdlZCBpdCB3aWxsIHByb3BhZ2F0ZSBpdCBieSBjaGFuZ2luZyBkZXBlbmRlbmNpZXNTdGF0ZSB0byAyLlxyXG4gKlxyXG4gKiBCeSBpdGVyYXRpbmcgb3ZlciB0aGUgZGVwZW5kZW5jaWVzIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSB3ZXJlIHJlcG9ydGVkIGFuZFxyXG4gKiBzdG9wcGluZyBvbiB0aGUgZmlyc3QgY2hhbmdlLCBhbGwgdGhlIHJlY2FsY3VsYXRpb25zIGFyZSBvbmx5IGNhbGxlZCBmb3IgQ29tcHV0ZWRWYWx1ZXNcclxuICogdGhhdCB3aWxsIGJlIHRyYWNrZWQgYnkgZGVyaXZhdGlvbi4gVGhhdCBpcyBiZWNhdXNlIHdlIGFzc3VtZSB0aGF0IGlmIHRoZSBmaXJzdCB4XHJcbiAqIGRlcGVuZGVuY2llcyBvZiB0aGUgZGVyaXZhdGlvbiBkb2Vzbid0IGNoYW5nZSB0aGVuIHRoZSBkZXJpdmF0aW9uIHNob3VsZCBydW4gdGhlIHNhbWUgd2F5XHJcbiAqIHVwIHVudGlsIGFjY2Vzc2luZyB4LXRoIGRlcGVuZGVuY3kuXHJcbiAqL1xuXG5mdW5jdGlvbiBzaG91bGRDb21wdXRlKGRlcml2YXRpb24pIHtcbiAgc3dpdGNoIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXykge1xuICAgIGNhc2UgSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV86XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR186XG4gICAgY2FzZSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV86XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgSURlcml2YXRpb25TdGF0ZV8uUE9TU0lCTFlfU1RBTEVfOlxuICAgICAge1xuICAgICAgICAvLyBzdGF0ZSBwcm9wYWdhdGlvbiBjYW4gb2NjdXIgb3V0c2lkZSBvZiBhY3Rpb24vcmVhY3RpdmUgY29udGV4dCAjMjE5NVxuICAgICAgICB2YXIgcHJldkFsbG93U3RhdGVSZWFkcyA9IGFsbG93U3RhdGVSZWFkc1N0YXJ0KHRydWUpO1xuICAgICAgICB2YXIgcHJldlVudHJhY2tlZCA9IHVudHJhY2tlZFN0YXJ0KCk7IC8vIG5vIG5lZWQgZm9yIHRob3NlIGNvbXB1dGVkcyB0byBiZSByZXBvcnRlZCwgdGhleSB3aWxsIGJlIHBpY2tlZCB1cCBpbiB0cmFja0Rlcml2ZWRGdW5jdGlvbi5cblxuICAgICAgICB2YXIgb2JzID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfLFxuICAgICAgICAgICAgbCA9IG9icy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgb2JqID0gb2JzW2ldO1xuXG4gICAgICAgICAgaWYgKGlzQ29tcHV0ZWRWYWx1ZShvYmopKSB7XG4gICAgICAgICAgICBpZiAoZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcykge1xuICAgICAgICAgICAgICBvYmouZ2V0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9iai5nZXQoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgaW50ZXJlc3RlZCBpbiB0aGUgdmFsdWUgKm9yKiBleGNlcHRpb24gYXQgdGhpcyBtb21lbnQsIGJ1dCBpZiB0aGVyZSBpcyBvbmUsIG5vdGlmeSBhbGxcbiAgICAgICAgICAgICAgICB1bnRyYWNrZWRFbmQocHJldlVudHJhY2tlZCk7XG4gICAgICAgICAgICAgICAgYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXZBbGxvd1N0YXRlUmVhZHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGlmIENvbXB1dGVkVmFsdWUgYG9iamAgYWN0dWFsbHkgY2hhbmdlZCBpdCB3aWxsIGJlIGNvbXB1dGVkIGFuZCBwcm9wYWdhdGVkIHRvIGl0cyBvYnNlcnZlcnMuXG4gICAgICAgICAgICAvLyBhbmQgYGRlcml2YXRpb25gIGlzIGFuIG9ic2VydmVyIG9mIGBvYmpgXG4gICAgICAgICAgICAvLyBpbnZhcmlhbnRTaG91bGRDb21wdXRlKGRlcml2YXRpb24pXG5cblxuICAgICAgICAgICAgaWYgKGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV8pIHtcbiAgICAgICAgICAgICAgdW50cmFja2VkRW5kKHByZXZVbnRyYWNrZWQpO1xuICAgICAgICAgICAgICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5nZURlcGVuZGVuY2llc1N0YXRlVG8wKGRlcml2YXRpb24pO1xuICAgICAgICB1bnRyYWNrZWRFbmQocHJldlVudHJhY2tlZCk7XG4gICAgICAgIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2QWxsb3dTdGF0ZVJlYWRzKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0NvbXB1dGluZ0Rlcml2YXRpb24oKSB7XG4gIHJldHVybiBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gIT09IG51bGw7IC8vIGZpbHRlciBvdXQgYWN0aW9ucyBpbnNpZGUgY29tcHV0YXRpb25zXG59XG5mdW5jdGlvbiBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZChhdG9tKSB7XG5cbiAgdmFyIGhhc09ic2VydmVycyA9IGF0b20ub2JzZXJ2ZXJzXy5zaXplID4gMDsgLy8gU2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBjaGFuZ2Ugb2JzZXJ2ZWQgc3RhdGUgb3V0c2lkZSBzdHJpY3QgbW9kZSwgZXhjZXB0IGR1cmluZyBpbml0aWFsaXphdGlvbiwgc2VlICM1NjNcblxuICBpZiAoIWdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzICYmIChoYXNPYnNlcnZlcnMgfHwgZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnMgPT09IFwiYWx3YXlzXCIpKSBjb25zb2xlLndhcm4oXCJbTW9iWF0gXCIgKyAoZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnMgPyBcIlNpbmNlIHN0cmljdC1tb2RlIGlzIGVuYWJsZWQsIGNoYW5naW5nIChvYnNlcnZlZCkgb2JzZXJ2YWJsZSB2YWx1ZXMgd2l0aG91dCB1c2luZyBhbiBhY3Rpb24gaXMgbm90IGFsbG93ZWQuIFRyaWVkIHRvIG1vZGlmeTogXCIgOiBcIlNpZGUgZWZmZWN0cyBsaWtlIGNoYW5naW5nIHN0YXRlIGFyZSBub3QgYWxsb3dlZCBhdCB0aGlzIHBvaW50LiBBcmUgeW91IHRyeWluZyB0byBtb2RpZnkgc3RhdGUgZnJvbSwgZm9yIGV4YW1wbGUsIGEgY29tcHV0ZWQgdmFsdWUgb3IgdGhlIHJlbmRlciBmdW5jdGlvbiBvZiBhIFJlYWN0IGNvbXBvbmVudD8gWW91IGNhbiB3cmFwIHNpZGUgZWZmZWN0cyBpbiAncnVuSW5BY3Rpb24nIChvciBkZWNvcmF0ZSBmdW5jdGlvbnMgd2l0aCAnYWN0aW9uJykgaWYgbmVlZGVkLiBUcmllZCB0byBtb2RpZnk6IFwiKSArIGF0b20ubmFtZV8pO1xufVxuZnVuY3Rpb24gY2hlY2tJZlN0YXRlUmVhZHNBcmVBbGxvd2VkKG9ic2VydmFibGUpIHtcbiAgaWYgKCAhZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzICYmIGdsb2JhbFN0YXRlLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKFwiW21vYnhdIE9ic2VydmFibGUgJ1wiICsgb2JzZXJ2YWJsZS5uYW1lXyArIFwiJyBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0LlwiKTtcbiAgfVxufVxuLyoqXHJcbiAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBgZmAgYW5kIHRyYWNrcyB3aGljaCBvYnNlcnZhYmxlcyBhcmUgYmVpbmcgYWNjZXNzZWQuXHJcbiAqIFRoZSB0cmFja2luZyBpbmZvcm1hdGlvbiBpcyBzdG9yZWQgb24gdGhlIGBkZXJpdmF0aW9uYCBvYmplY3QgYW5kIHRoZSBkZXJpdmF0aW9uIGlzIHJlZ2lzdGVyZWRcclxuICogYXMgb2JzZXJ2ZXIgb2YgYW55IG9mIHRoZSBhY2Nlc3NlZCBvYnNlcnZhYmxlcy5cclxuICovXG5cbmZ1bmN0aW9uIHRyYWNrRGVyaXZlZEZ1bmN0aW9uKGRlcml2YXRpb24sIGYsIGNvbnRleHQpIHtcbiAgdmFyIHByZXZBbGxvd1N0YXRlUmVhZHMgPSBhbGxvd1N0YXRlUmVhZHNTdGFydCh0cnVlKTsgLy8gcHJlIGFsbG9jYXRlIGFycmF5IGFsbG9jYXRpb24gKyByb29tIGZvciB2YXJpYXRpb24gaW4gZGVwc1xuICAvLyBhcnJheSB3aWxsIGJlIHRyaW1tZWQgYnkgYmluZERlcGVuZGVuY2llc1xuXG4gIGNoYW5nZURlcGVuZGVuY2llc1N0YXRlVG8wKGRlcml2YXRpb24pO1xuICBkZXJpdmF0aW9uLm5ld09ic2VydmluZ18gPSBuZXcgQXJyYXkoZGVyaXZhdGlvbi5vYnNlcnZpbmdfLmxlbmd0aCArIDEwMCk7XG4gIGRlcml2YXRpb24udW5ib3VuZERlcHNDb3VudF8gPSAwO1xuICBkZXJpdmF0aW9uLnJ1bklkXyA9ICsrZ2xvYmFsU3RhdGUucnVuSWQ7XG4gIHZhciBwcmV2VHJhY2tpbmcgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IGRlcml2YXRpb247XG4gIGdsb2JhbFN0YXRlLmluQmF0Y2grKztcbiAgdmFyIHJlc3VsdDtcblxuICBpZiAoZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9PT0gdHJ1ZSkge1xuICAgIHJlc3VsdCA9IGYuY2FsbChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZi5jYWxsKGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBDYXVnaHRFeGNlcHRpb24oZSk7XG4gICAgfVxuICB9XG5cbiAgZ2xvYmFsU3RhdGUuaW5CYXRjaC0tO1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBwcmV2VHJhY2tpbmc7XG4gIGJpbmREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbik7XG4gIHdhcm5BYm91dERlcml2YXRpb25XaXRob3V0RGVwZW5kZW5jaWVzKGRlcml2YXRpb24pO1xuICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5BYm91dERlcml2YXRpb25XaXRob3V0RGVwZW5kZW5jaWVzKGRlcml2YXRpb24pIHtcbiAgaWYgKGRlcml2YXRpb24ub2JzZXJ2aW5nXy5sZW5ndGggIT09IDApIHJldHVybjtcblxuICBpZiAoZ2xvYmFsU3RhdGUucmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGUgfHwgZGVyaXZhdGlvbi5yZXF1aXJlc09ic2VydmFibGVfKSB7XG4gICAgY29uc29sZS53YXJuKFwiW21vYnhdIERlcml2YXRpb24gJ1wiICsgZGVyaXZhdGlvbi5uYW1lXyArIFwiJyBpcyBjcmVhdGVkL3VwZGF0ZWQgd2l0aG91dCByZWFkaW5nIGFueSBvYnNlcnZhYmxlIHZhbHVlLlwiKTtcbiAgfVxufVxuLyoqXHJcbiAqIGRpZmZzIG5ld09ic2VydmluZyB3aXRoIG9ic2VydmluZy5cclxuICogdXBkYXRlIG9ic2VydmluZyB0byBiZSBuZXdPYnNlcnZpbmcgd2l0aCB1bmlxdWUgb2JzZXJ2YWJsZXNcclxuICogbm90aWZ5IG9ic2VydmVycyB0aGF0IGJlY29tZSBvYnNlcnZlZC91bm9ic2VydmVkXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGJpbmREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbikge1xuICAvLyBpbnZhcmlhbnQoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZSAhPT0gSURlcml2YXRpb25TdGF0ZS5OT1RfVFJBQ0tJTkcsIFwiSU5URVJOQUwgRVJST1IgYmluZERlcGVuZGVuY2llcyBleHBlY3RzIGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGUgIT09IC0xXCIpO1xuICB2YXIgcHJldk9ic2VydmluZyA9IGRlcml2YXRpb24ub2JzZXJ2aW5nXztcbiAgdmFyIG9ic2VydmluZyA9IGRlcml2YXRpb24ub2JzZXJ2aW5nXyA9IGRlcml2YXRpb24ubmV3T2JzZXJ2aW5nXztcbiAgdmFyIGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfOyAvLyBHbyB0aHJvdWdoIGFsbCBuZXcgb2JzZXJ2YWJsZXMgYW5kIGNoZWNrIGRpZmZWYWx1ZTogKHRoaXMgbGlzdCBjYW4gY29udGFpbiBkdXBsaWNhdGVzKTpcbiAgLy8gICAwOiBmaXJzdCBvY2N1cnJlbmNlLCBjaGFuZ2UgdG8gMSBhbmQga2VlcCBpdFxuICAvLyAgIDE6IGV4dHJhIG9jY3VycmVuY2UsIGRyb3AgaXRcblxuICB2YXIgaTAgPSAwLFxuICAgICAgbCA9IGRlcml2YXRpb24udW5ib3VuZERlcHNDb3VudF87XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgZGVwID0gb2JzZXJ2aW5nW2ldO1xuXG4gICAgaWYgKGRlcC5kaWZmVmFsdWVfID09PSAwKSB7XG4gICAgICBkZXAuZGlmZlZhbHVlXyA9IDE7XG4gICAgICBpZiAoaTAgIT09IGkpIG9ic2VydmluZ1tpMF0gPSBkZXA7XG4gICAgICBpMCsrO1xuICAgIH0gLy8gVXBjYXN0IGlzICdzYWZlJyBoZXJlLCBiZWNhdXNlIGlmIGRlcCBpcyBJT2JzZXJ2YWJsZSwgYGRlcGVuZGVuY2llc1N0YXRlYCB3aWxsIGJlIHVuZGVmaW5lZCxcbiAgICAvLyBub3QgaGl0dGluZyB0aGUgY29uZGl0aW9uXG5cblxuICAgIGlmIChkZXAuZGVwZW5kZW5jaWVzU3RhdGVfID4gbG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlKSB7XG4gICAgICBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUgPSBkZXAuZGVwZW5kZW5jaWVzU3RhdGVfO1xuICAgIH1cbiAgfVxuXG4gIG9ic2VydmluZy5sZW5ndGggPSBpMDtcbiAgZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmdfID0gbnVsbDsgLy8gbmV3T2JzZXJ2aW5nIHNob3VsZG4ndCBiZSBuZWVkZWQgb3V0c2lkZSB0cmFja2luZyAoc3RhdGVtZW50IG1vdmVkIGRvd24gdG8gd29yayBhcm91bmQgRkYgYnVnLCBzZWUgIzYxNClcbiAgLy8gR28gdGhyb3VnaCBhbGwgb2xkIG9ic2VydmFibGVzIGFuZCBjaGVjayBkaWZmVmFsdWU6IChpdCBpcyB1bmlxdWUgYWZ0ZXIgbGFzdCBiaW5kRGVwZW5kZW5jaWVzKVxuICAvLyAgIDA6IGl0J3Mgbm90IGluIG5ldyBvYnNlcnZhYmxlcywgdW5vYnNlcnZlIGl0XG4gIC8vICAgMTogaXQga2VlcHMgYmVpbmcgb2JzZXJ2ZWQsIGRvbid0IHdhbnQgdG8gbm90aWZ5IGl0LiBjaGFuZ2UgdG8gMFxuXG4gIGwgPSBwcmV2T2JzZXJ2aW5nLmxlbmd0aDtcblxuICB3aGlsZSAobC0tKSB7XG4gICAgdmFyIF9kZXAgPSBwcmV2T2JzZXJ2aW5nW2xdO1xuXG4gICAgaWYgKF9kZXAuZGlmZlZhbHVlXyA9PT0gMCkge1xuICAgICAgcmVtb3ZlT2JzZXJ2ZXIoX2RlcCwgZGVyaXZhdGlvbik7XG4gICAgfVxuXG4gICAgX2RlcC5kaWZmVmFsdWVfID0gMDtcbiAgfSAvLyBHbyB0aHJvdWdoIGFsbCBuZXcgb2JzZXJ2YWJsZXMgYW5kIGNoZWNrIGRpZmZWYWx1ZTogKG5vdyBpdCBzaG91bGQgYmUgdW5pcXVlKVxuICAvLyAgIDA6IGl0IHdhcyBzZXQgdG8gMCBpbiBsYXN0IGxvb3AuIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gIC8vICAgMTogaXQgd2Fzbid0IG9ic2VydmVkLCBsZXQncyBvYnNlcnZlIGl0LiBzZXQgYmFjayB0byAwXG5cblxuICB3aGlsZSAoaTAtLSkge1xuICAgIHZhciBfZGVwMiA9IG9ic2VydmluZ1tpMF07XG5cbiAgICBpZiAoX2RlcDIuZGlmZlZhbHVlXyA9PT0gMSkge1xuICAgICAgX2RlcDIuZGlmZlZhbHVlXyA9IDA7XG4gICAgICBhZGRPYnNlcnZlcihfZGVwMiwgZGVyaXZhdGlvbik7XG4gICAgfVxuICB9IC8vIFNvbWUgbmV3IG9ic2VydmVkIGRlcml2YXRpb25zIG1heSBiZWNvbWUgc3RhbGUgZHVyaW5nIHRoaXMgZGVyaXZhdGlvbiBjb21wdXRhdGlvblxuICAvLyBzbyB0aGV5IGhhdmUgaGFkIG5vIGNoYW5jZSB0byBwcm9wYWdhdGUgc3RhbGVuZXNzICgjOTE2KVxuXG5cbiAgaWYgKGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSAhPT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9IGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZTtcbiAgICBkZXJpdmF0aW9uLm9uQmVjb21lU3RhbGVfKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYXJPYnNlcnZpbmcoZGVyaXZhdGlvbikge1xuICAvLyBpbnZhcmlhbnQoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAsIFwiSU5URVJOQUwgRVJST1IgY2xlYXJPYnNlcnZpbmcgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IGluc2lkZSBiYXRjaFwiKTtcbiAgdmFyIG9icyA9IGRlcml2YXRpb24ub2JzZXJ2aW5nXztcbiAgZGVyaXZhdGlvbi5vYnNlcnZpbmdfID0gW107XG4gIHZhciBpID0gb2JzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgcmVtb3ZlT2JzZXJ2ZXIob2JzW2ldLCBkZXJpdmF0aW9uKTtcbiAgfVxuXG4gIGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbn1cbmZ1bmN0aW9uIHVudHJhY2tlZChhY3Rpb24pIHtcbiAgdmFyIHByZXYgPSB1bnRyYWNrZWRTdGFydCgpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGFjdGlvbigpO1xuICB9IGZpbmFsbHkge1xuICAgIHVudHJhY2tlZEVuZChwcmV2KTtcbiAgfVxufVxuZnVuY3Rpb24gdW50cmFja2VkU3RhcnQoKSB7XG4gIHZhciBwcmV2ID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBudWxsO1xuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIHVudHJhY2tlZEVuZChwcmV2KSB7XG4gIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IHByZXY7XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlUmVhZHNTdGFydChhbGxvd1N0YXRlUmVhZHMpIHtcbiAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHM7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyA9IGFsbG93U3RhdGVSZWFkcztcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlUmVhZHNFbmQocHJldikge1xuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHMgPSBwcmV2O1xufVxuLyoqXHJcbiAqIG5lZWRlZCB0byBrZWVwIGBsb3dlc3RPYnNlcnZlclN0YXRlYCBjb3JyZWN0LiB3aGVuIGNoYW5naW5nIGZyb20gKDIgb3IgMSkgdG8gMFxyXG4gKlxyXG4gKi9cblxuZnVuY3Rpb24gY2hhbmdlRGVwZW5kZW5jaWVzU3RhdGVUbzAoZGVyaXZhdGlvbikge1xuICBpZiAoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSByZXR1cm47XG4gIGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gIHZhciBvYnMgPSBkZXJpdmF0aW9uLm9ic2VydmluZ187XG4gIHZhciBpID0gb2JzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgb2JzW2ldLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gIH1cbn1cblxuLyoqXHJcbiAqIFRoZXNlIHZhbHVlcyB3aWxsIHBlcnNpc3QgaWYgZ2xvYmFsIHN0YXRlIGlzIHJlc2V0XHJcbiAqL1xuXG52YXIgcGVyc2lzdGVudEtleXMgPSBbXCJtb2J4R3VpZFwiLCBcInNweUxpc3RlbmVyc1wiLCBcImVuZm9yY2VBY3Rpb25zXCIsIFwiY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uXCIsIFwicmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGVcIiwgXCJvYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvblwiLCBcImFsbG93U3RhdGVSZWFkc1wiLCBcImRpc2FibGVFcnJvckJvdW5kYXJpZXNcIiwgXCJydW5JZFwiLCBcIlVOQ0hBTkdFRFwiLCBcInVzZVByb3hpZXNcIl07XG52YXIgTW9iWEdsb2JhbHMgPSBmdW5jdGlvbiBNb2JYR2xvYmFscygpIHtcbiAgdGhpcy52ZXJzaW9uID0gNjtcbiAgdGhpcy5VTkNIQU5HRUQgPSB7fTtcbiAgdGhpcy50cmFja2luZ0Rlcml2YXRpb24gPSBudWxsO1xuICB0aGlzLnRyYWNraW5nQ29udGV4dCA9IG51bGw7XG4gIHRoaXMucnVuSWQgPSAwO1xuICB0aGlzLm1vYnhHdWlkID0gMDtcbiAgdGhpcy5pbkJhdGNoID0gMDtcbiAgdGhpcy5wZW5kaW5nVW5vYnNlcnZhdGlvbnMgPSBbXTtcbiAgdGhpcy5wZW5kaW5nUmVhY3Rpb25zID0gW107XG4gIHRoaXMuaXNSdW5uaW5nUmVhY3Rpb25zID0gZmFsc2U7XG4gIHRoaXMuYWxsb3dTdGF0ZUNoYW5nZXMgPSBmYWxzZTtcbiAgdGhpcy5hbGxvd1N0YXRlUmVhZHMgPSB0cnVlO1xuICB0aGlzLmVuZm9yY2VBY3Rpb25zID0gdHJ1ZTtcbiAgdGhpcy5zcHlMaXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMgPSBbXTtcbiAgdGhpcy5jb21wdXRlZFJlcXVpcmVzUmVhY3Rpb24gPSBmYWxzZTtcbiAgdGhpcy5yZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZSA9IGZhbHNlO1xuICB0aGlzLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uID0gZmFsc2U7XG4gIHRoaXMuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9IGZhbHNlO1xuICB0aGlzLnN1cHByZXNzUmVhY3Rpb25FcnJvcnMgPSBmYWxzZTtcbiAgdGhpcy51c2VQcm94aWVzID0gdHJ1ZTtcbiAgdGhpcy52ZXJpZnlQcm94aWVzID0gZmFsc2U7XG4gIHRoaXMuc2FmZURlc2NyaXB0b3JzID0gdHJ1ZTtcbn07XG52YXIgY2FuTWVyZ2VHbG9iYWxTdGF0ZSA9IHRydWU7XG52YXIgaXNvbGF0ZUNhbGxlZCA9IGZhbHNlO1xudmFyIGdsb2JhbFN0YXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgdmFyIGdsb2JhbCA9IC8qI19fUFVSRV9fKi9nZXRHbG9iYWwoKTtcbiAgaWYgKGdsb2JhbC5fX21vYnhJbnN0YW5jZUNvdW50ID4gMCAmJiAhZ2xvYmFsLl9fbW9ieEdsb2JhbHMpIGNhbk1lcmdlR2xvYmFsU3RhdGUgPSBmYWxzZTtcbiAgaWYgKGdsb2JhbC5fX21vYnhHbG9iYWxzICYmIGdsb2JhbC5fX21vYnhHbG9iYWxzLnZlcnNpb24gIT09IG5ldyBNb2JYR2xvYmFscygpLnZlcnNpb24pIGNhbk1lcmdlR2xvYmFsU3RhdGUgPSBmYWxzZTtcblxuICBpZiAoIWNhbk1lcmdlR2xvYmFsU3RhdGUpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghaXNvbGF0ZUNhbGxlZCkge1xuICAgICAgICBkaWUoMzUpO1xuICAgICAgfVxuICAgIH0sIDEpO1xuICAgIHJldHVybiBuZXcgTW9iWEdsb2JhbHMoKTtcbiAgfSBlbHNlIGlmIChnbG9iYWwuX19tb2J4R2xvYmFscykge1xuICAgIGdsb2JhbC5fX21vYnhJbnN0YW5jZUNvdW50ICs9IDE7XG4gICAgaWYgKCFnbG9iYWwuX19tb2J4R2xvYmFscy5VTkNIQU5HRUQpIGdsb2JhbC5fX21vYnhHbG9iYWxzLlVOQ0hBTkdFRCA9IHt9OyAvLyBtYWtlIG1lcmdlIGJhY2t3YXJkIGNvbXBhdGlibGVcblxuICAgIHJldHVybiBnbG9iYWwuX19tb2J4R2xvYmFscztcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCA9IDE7XG4gICAgcmV0dXJuIGdsb2JhbC5fX21vYnhHbG9iYWxzID0gLyojX19QVVJFX18qL25ldyBNb2JYR2xvYmFscygpO1xuICB9XG59KCk7XG5mdW5jdGlvbiBpc29sYXRlR2xvYmFsU3RhdGUoKSB7XG4gIGlmIChnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zLmxlbmd0aCB8fCBnbG9iYWxTdGF0ZS5pbkJhdGNoIHx8IGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucykgZGllKDM2KTtcbiAgaXNvbGF0ZUNhbGxlZCA9IHRydWU7XG5cbiAgaWYgKGNhbk1lcmdlR2xvYmFsU3RhdGUpIHtcbiAgICB2YXIgZ2xvYmFsID0gZ2V0R2xvYmFsKCk7XG4gICAgaWYgKC0tZ2xvYmFsLl9fbW9ieEluc3RhbmNlQ291bnQgPT09IDApIGdsb2JhbC5fX21vYnhHbG9iYWxzID0gdW5kZWZpbmVkO1xuICAgIGdsb2JhbFN0YXRlID0gbmV3IE1vYlhHbG9iYWxzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEdsb2JhbFN0YXRlKCkge1xuICByZXR1cm4gZ2xvYmFsU3RhdGU7XG59XG4vKipcclxuICogRm9yIHRlc3RpbmcgcHVycG9zZXMgb25seTsgdGhpcyB3aWxsIGJyZWFrIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBleGlzdGluZyBvYnNlcnZhYmxlcyxcclxuICogYnV0IGNhbiBiZSB1c2VkIHRvIGdldCBiYWNrIGF0IGEgc3RhYmxlIHN0YXRlIGFmdGVyIHRocm93aW5nIGVycm9yc1xyXG4gKi9cblxuZnVuY3Rpb24gcmVzZXRHbG9iYWxTdGF0ZSgpIHtcbiAgdmFyIGRlZmF1bHRHbG9iYWxzID0gbmV3IE1vYlhHbG9iYWxzKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRHbG9iYWxzKSB7XG4gICAgaWYgKHBlcnNpc3RlbnRLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIGdsb2JhbFN0YXRlW2tleV0gPSBkZWZhdWx0R2xvYmFsc1trZXldO1xuICB9XG5cbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSAhZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGhhc09ic2VydmVycyhvYnNlcnZhYmxlKSB7XG4gIHJldHVybiBvYnNlcnZhYmxlLm9ic2VydmVyc18gJiYgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLnNpemUgPiAwO1xufVxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJzKG9ic2VydmFibGUpIHtcbiAgcmV0dXJuIG9ic2VydmFibGUub2JzZXJ2ZXJzXztcbn0gLy8gZnVuY3Rpb24gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGU6IElPYnNlcnZhYmxlKSB7XG4vLyAgICAgY29uc3QgbGlzdCA9IG9ic2VydmFibGUub2JzZXJ2ZXJzXG4vLyAgICAgY29uc3QgbWFwID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnNJbmRleGVzXG4vLyAgICAgY29uc3QgbCA9IGxpc3QubGVuZ3RoXG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbi8vICAgICAgICAgY29uc3QgaWQgPSBsaXN0W2ldLl9fbWFwaWRcbi8vICAgICAgICAgaWYgKGkpIHtcbi8vICAgICAgICAgICAgIGludmFyaWFudChtYXBbaWRdID09PSBpLCBcIklOVEVSTkFMIEVSUk9SIG1hcHMgZGVyaXZhdGlvbi5fX21hcGlkIHRvIGluZGV4IGluIGxpc3RcIikgLy8gZm9yIHBlcmZvcm1hbmNlXG4vLyAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgICBpbnZhcmlhbnQoIShpZCBpbiBtYXApLCBcIklOVEVSTkFMIEVSUk9SIG9ic2VydmVyIG9uIGluZGV4IDAgc2hvdWxkbid0IGJlIGhlbGQgaW4gbWFwLlwiKSAvLyBmb3IgcGVyZm9ybWFuY2Vcbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vICAgICBpbnZhcmlhbnQoXG4vLyAgICAgICAgIGxpc3QubGVuZ3RoID09PSAwIHx8IE9iamVjdC5rZXlzKG1hcCkubGVuZ3RoID09PSBsaXN0Lmxlbmd0aCAtIDEsXG4vLyAgICAgICAgIFwiSU5URVJOQUwgRVJST1IgdGhlcmUgaXMgbm8ganVuayBpbiBtYXBcIlxuLy8gICAgIClcbi8vIH1cblxuZnVuY3Rpb24gYWRkT2JzZXJ2ZXIob2JzZXJ2YWJsZSwgbm9kZSkge1xuICAvLyBpbnZhcmlhbnQobm9kZS5kZXBlbmRlbmNpZXNTdGF0ZSAhPT0gLTEsIFwiSU5URVJOQUwgRVJST1IsIGNhbiBhZGQgb25seSBkZXBlbmRlbmNpZXNTdGF0ZSAhPT0gLTFcIik7XG4gIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSA9PT0gLTEsIFwiSU5URVJOQUwgRVJST1IgYWRkIGFscmVhZHkgYWRkZWQgbm9kZVwiKTtcbiAgLy8gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGUpO1xuICBvYnNlcnZhYmxlLm9ic2VydmVyc18uYWRkKG5vZGUpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA+IG5vZGUuZGVwZW5kZW5jaWVzU3RhdGVfKSBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gbm9kZS5kZXBlbmRlbmNpZXNTdGF0ZV87IC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpICE9PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiBkaWRuJ3QgYWRkIG5vZGVcIik7XG59XG5mdW5jdGlvbiByZW1vdmVPYnNlcnZlcihvYnNlcnZhYmxlLCBub2RlKSB7XG4gIC8vIGludmFyaWFudChnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCwgXCJJTlRFUk5BTCBFUlJPUiwgcmVtb3ZlIHNob3VsZCBiZSBjYWxsZWQgb25seSBpbnNpZGUgYmF0Y2hcIik7XG4gIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSAhPT0gLTEsIFwiSU5URVJOQUwgRVJST1IgcmVtb3ZlIGFscmVhZHkgcmVtb3ZlZCBub2RlXCIpO1xuICAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzX1tcImRlbGV0ZVwiXShub2RlKTtcblxuICBpZiAob2JzZXJ2YWJsZS5vYnNlcnZlcnNfLnNpemUgPT09IDApIHtcbiAgICAvLyBkZWxldGluZyBsYXN0IG9ic2VydmVyXG4gICAgcXVldWVGb3JVbm9ic2VydmF0aW9uKG9ic2VydmFibGUpO1xuICB9IC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpID09PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiByZW1vdmUgYWxyZWFkeSByZW1vdmVkIG5vZGUyXCIpO1xuXG59XG5mdW5jdGlvbiBxdWV1ZUZvclVub2JzZXJ2YXRpb24ob2JzZXJ2YWJsZSkge1xuICBpZiAob2JzZXJ2YWJsZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uXyA9PT0gZmFsc2UpIHtcbiAgICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCwgXCJJTlRFUk5BTCBFUlJPUiwgc2hvdWxkIG9ubHkgcXVldWUgZm9yIHVub2JzZXJ2YXRpb24gdW5vYnNlcnZlZCBvYnNlcnZhYmxlc1wiKTtcbiAgICBvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb25fID0gdHJ1ZTtcbiAgICBnbG9iYWxTdGF0ZS5wZW5kaW5nVW5vYnNlcnZhdGlvbnMucHVzaChvYnNlcnZhYmxlKTtcbiAgfVxufVxuLyoqXHJcbiAqIEJhdGNoIHN0YXJ0cyBhIHRyYW5zYWN0aW9uLCBhdCBsZWFzdCBmb3IgcHVycG9zZXMgb2YgbWVtb2l6aW5nIENvbXB1dGVkVmFsdWVzIHdoZW4gbm90aGluZyBlbHNlIGRvZXMuXHJcbiAqIER1cmluZyBhIGJhdGNoIGBvbkJlY29tZVVub2JzZXJ2ZWRgIHdpbGwgYmUgY2FsbGVkIGF0IG1vc3Qgb25jZSBwZXIgb2JzZXJ2YWJsZS5cclxuICogQXZvaWRzIHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25zLlxyXG4gKi9cblxuZnVuY3Rpb24gc3RhcnRCYXRjaCgpIHtcbiAgZ2xvYmFsU3RhdGUuaW5CYXRjaCsrO1xufVxuZnVuY3Rpb24gZW5kQmF0Y2goKSB7XG4gIGlmICgtLWdsb2JhbFN0YXRlLmluQmF0Y2ggPT09IDApIHtcbiAgICBydW5SZWFjdGlvbnMoKTsgLy8gdGhlIGJhdGNoIGlzIGFjdHVhbGx5IGFib3V0IHRvIGZpbmlzaCwgYWxsIHVub2JzZXJ2aW5nIHNob3VsZCBoYXBwZW4gaGVyZS5cblxuICAgIHZhciBsaXN0ID0gZ2xvYmFsU3RhdGUucGVuZGluZ1Vub2JzZXJ2YXRpb25zO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IGxpc3RbaV07XG4gICAgICBvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb25fID0gZmFsc2U7XG5cbiAgICAgIGlmIChvYnNlcnZhYmxlLm9ic2VydmVyc18uc2l6ZSA9PT0gMCkge1xuICAgICAgICBpZiAob2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWRfKSB7XG4gICAgICAgICAgLy8gaWYgdGhpcyBvYnNlcnZhYmxlIGhhZCByZWFjdGl2ZSBvYnNlcnZlcnMsIHRyaWdnZXIgdGhlIGhvb2tzXG4gICAgICAgICAgb2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWRfID0gZmFsc2U7XG4gICAgICAgICAgb2JzZXJ2YWJsZS5vbkJVTygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9ic2VydmFibGUgaW5zdGFuY2VvZiBDb21wdXRlZFZhbHVlKSB7XG4gICAgICAgICAgLy8gY29tcHV0ZWQgdmFsdWVzIGFyZSBhdXRvbWF0aWNhbGx5IHRlYXJlZCBkb3duIHdoZW4gdGhlIGxhc3Qgb2JzZXJ2ZXIgbGVhdmVzXG4gICAgICAgICAgLy8gdGhpcyBwcm9jZXNzIGhhcHBlbnMgcmVjdXJzaXZlbHksIHRoaXMgY29tcHV0ZWQgbWlnaHQgYmUgdGhlIGxhc3Qgb2JzZXJ2YWJlIG9mIGFub3RoZXIsIGV0Yy4uXG4gICAgICAgICAgb2JzZXJ2YWJsZS5zdXNwZW5kXygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2xvYmFsU3RhdGUucGVuZGluZ1Vub2JzZXJ2YXRpb25zID0gW107XG4gIH1cbn1cbmZ1bmN0aW9uIHJlcG9ydE9ic2VydmVkKG9ic2VydmFibGUpIHtcbiAgY2hlY2tJZlN0YXRlUmVhZHNBcmVBbGxvd2VkKG9ic2VydmFibGUpO1xuICB2YXIgZGVyaXZhdGlvbiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcblxuICBpZiAoZGVyaXZhdGlvbiAhPT0gbnVsbCkge1xuICAgIC8qKlxyXG4gICAgICogU2ltcGxlIG9wdGltaXphdGlvbiwgZ2l2ZSBlYWNoIGRlcml2YXRpb24gcnVuIGFuIHVuaXF1ZSBpZCAocnVuSWQpXHJcbiAgICAgKiBDaGVjayBpZiBsYXN0IHRpbWUgdGhpcyBvYnNlcnZhYmxlIHdhcyBhY2Nlc3NlZCB0aGUgc2FtZSBydW5JZCBpcyB1c2VkXHJcbiAgICAgKiBpZiB0aGlzIGlzIHRoZSBjYXNlLCB0aGUgcmVsYXRpb24gaXMgYWxyZWFkeSBrbm93blxyXG4gICAgICovXG4gICAgaWYgKGRlcml2YXRpb24ucnVuSWRfICE9PSBvYnNlcnZhYmxlLmxhc3RBY2Nlc3NlZEJ5Xykge1xuICAgICAgb2JzZXJ2YWJsZS5sYXN0QWNjZXNzZWRCeV8gPSBkZXJpdmF0aW9uLnJ1bklkXzsgLy8gVHJpZWQgc3RvcmluZyBuZXdPYnNlcnZpbmcsIG9yIG9ic2VydmluZywgb3IgYm90aCBhcyBTZXQsIGJ1dCBwZXJmb3JtYW5jZSBkaWRuJ3QgY29tZSBjbG9zZS4uLlxuXG4gICAgICBkZXJpdmF0aW9uLm5ld09ic2VydmluZ19bZGVyaXZhdGlvbi51bmJvdW5kRGVwc0NvdW50XysrXSA9IG9ic2VydmFibGU7XG5cbiAgICAgIGlmICghb2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWRfICYmIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCkge1xuICAgICAgICBvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZF8gPSB0cnVlO1xuICAgICAgICBvYnNlcnZhYmxlLm9uQk8oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChvYnNlcnZhYmxlLm9ic2VydmVyc18uc2l6ZSA9PT0gMCAmJiBnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCkge1xuICAgIHF1ZXVlRm9yVW5vYnNlcnZhdGlvbihvYnNlcnZhYmxlKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0gLy8gZnVuY3Rpb24gaW52YXJpYW50TE9TKG9ic2VydmFibGU6IElPYnNlcnZhYmxlLCBtc2c6IHN0cmluZykge1xuLy8gICAgIC8vIGl0J3MgZXhwZW5zaXZlIHNvIGJldHRlciBub3QgcnVuIGl0IGluIHByb2R1Y2l0b24uIGJ1dCB0ZW1wb3JhcmlseSBoZWxwZnVsIGZvciB0ZXN0aW5nXG4vLyAgICAgY29uc3QgbWluID0gZ2V0T2JzZXJ2ZXJzKG9ic2VydmFibGUpLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5taW4oYSwgYi5kZXBlbmRlbmNpZXNTdGF0ZSksIDIpXG4vLyAgICAgaWYgKG1pbiA+PSBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGUpIHJldHVybiAvLyA8LSB0aGUgb25seSBhc3N1bXB0aW9uIGFib3V0IGBsb3dlc3RPYnNlcnZlclN0YXRlYFxuLy8gICAgIHRocm93IG5ldyBFcnJvcihcbi8vICAgICAgICAgXCJsb3dlc3RPYnNlcnZlclN0YXRlIGlzIHdyb25nIGZvciBcIiArXG4vLyAgICAgICAgICAgICBtc2cgK1xuLy8gICAgICAgICAgICAgXCIgYmVjYXVzZSBcIiArXG4vLyAgICAgICAgICAgICBtaW4gK1xuLy8gICAgICAgICAgICAgXCIgPCBcIiArXG4vLyAgICAgICAgICAgICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVcbi8vICAgICApXG4vLyB9XG5cbi8qKlxyXG4gKiBOT1RFOiBjdXJyZW50IHByb3BhZ2F0aW9uIG1lY2hhbmlzbSB3aWxsIGluIGNhc2Ugb2Ygc2VsZiByZXJ1bmluZyBhdXRvcnVucyBiZWhhdmUgdW5leHBlY3RlZGx5XHJcbiAqIEl0IHdpbGwgcHJvcGFnYXRlIGNoYW5nZXMgdG8gb2JzZXJ2ZXJzIGZyb20gcHJldmlvdXMgcnVuXHJcbiAqIEl0J3MgaGFyZCBvciBtYXliZSBpbXBvc3NpYmxlICh3aXRoIHJlYXNvbmFibGUgcGVyZikgdG8gZ2V0IGl0IHJpZ2h0IHdpdGggY3VycmVudCBhcHByb2FjaFxyXG4gKiBIb3BlZnVsbHkgc2VsZiByZXJ1bmluZyBhdXRvcnVucyBhcmVuJ3QgYSBmZWF0dXJlIHBlb3BsZSBzaG91bGQgZGVwZW5kIG9uXHJcbiAqIEFsc28gbW9zdCBiYXNpYyB1c2UgY2FzZXMgc2hvdWxkIGJlIG9rXHJcbiAqL1xuLy8gQ2FsbGVkIGJ5IEF0b20gd2hlbiBpdHMgdmFsdWUgY2hhbmdlc1xuXG5mdW5jdGlvbiBwcm9wYWdhdGVDaGFuZ2VkKG9ic2VydmFibGUpIHtcbiAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY2hhbmdlZCBzdGFydFwiKTtcbiAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXykgcmV0dXJuO1xuICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfOyAvLyBJZGVhbGx5IHdlIHVzZSBmb3IuLm9mIGhlcmUsIGJ1dCB0aGUgZG93bmNvbXBpbGVkIHZlcnNpb24gaXMgcmVhbGx5IHNsb3cuLi5cblxuICBvYnNlcnZhYmxlLm9ic2VydmVyc18uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICAgIGlmICggZC5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBsb2dUcmFjZUluZm8oZCwgb2JzZXJ2YWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGQub25CZWNvbWVTdGFsZV8oKTtcbiAgICB9XG5cbiAgICBkLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXztcbiAgfSk7IC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNoYW5nZWQgZW5kXCIpO1xufSAvLyBDYWxsZWQgYnkgQ29tcHV0ZWRWYWx1ZSB3aGVuIGl0IHJlY2FsY3VsYXRlIGFuZCBpdHMgdmFsdWUgY2hhbmdlZFxuXG5mdW5jdGlvbiBwcm9wYWdhdGVDaGFuZ2VDb25maXJtZWQob2JzZXJ2YWJsZSkge1xuICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJjb25maXJtZWQgc3RhcnRcIik7XG4gIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV8pIHJldHVybjtcbiAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXztcbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXykge1xuICAgICAgZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV87XG5cbiAgICAgIGlmICggZC5pc1RyYWNpbmdfICE9PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgICAgICBsb2dUcmFjZUluZm8oZCwgb2JzZXJ2YWJsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8gLy8gdGhpcyBoYXBwZW5zIGR1cmluZyBjb21wdXRpbmcgb2YgYGRgLCBqdXN0IGtlZXAgbG93ZXN0T2JzZXJ2ZXJTdGF0ZSB1cCB0byBkYXRlLlxuICAgICkge1xuICAgICAgICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gICAgICB9XG4gIH0pOyAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJjb25maXJtZWQgZW5kXCIpO1xufSAvLyBVc2VkIGJ5IGNvbXB1dGVkIHdoZW4gaXRzIGRlcGVuZGVuY3kgY2hhbmdlZCwgYnV0IHdlIGRvbid0IHdhbid0IHRvIGltbWVkaWF0ZWx5IHJlY29tcHV0ZS5cblxuZnVuY3Rpb24gcHJvcGFnYXRlTWF5YmVDaGFuZ2VkKG9ic2VydmFibGUpIHtcbiAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwibWF5YmUgc3RhcnRcIik7XG4gIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfICE9PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXykgcmV0dXJuO1xuICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uUE9TU0lCTFlfU1RBTEVfO1xuICBvYnNlcnZhYmxlLm9ic2VydmVyc18uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHtcbiAgICAgIGQuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uUE9TU0lCTFlfU1RBTEVfO1xuICAgICAgZC5vbkJlY29tZVN0YWxlXygpO1xuICAgIH1cbiAgfSk7IC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcIm1heWJlIGVuZFwiKTtcbn1cblxuZnVuY3Rpb24gbG9nVHJhY2VJbmZvKGRlcml2YXRpb24sIG9ic2VydmFibGUpIHtcbiAgY29uc29sZS5sb2coXCJbbW9ieC50cmFjZV0gJ1wiICsgZGVyaXZhdGlvbi5uYW1lXyArIFwiJyBpcyBpbnZhbGlkYXRlZCBkdWUgdG8gYSBjaGFuZ2UgaW46ICdcIiArIG9ic2VydmFibGUubmFtZV8gKyBcIidcIik7XG5cbiAgaWYgKGRlcml2YXRpb24uaXNUcmFjaW5nXyA9PT0gVHJhY2VNb2RlLkJSRUFLKSB7XG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgcHJpbnREZXBUcmVlKGdldERlcGVuZGVuY3lUcmVlKGRlcml2YXRpb24pLCBsaW5lcywgMSk7IC8vIHByZXR0aWVyLWlnbm9yZVxuXG4gICAgbmV3IEZ1bmN0aW9uKFwiZGVidWdnZXI7XFxuLypcXG5UcmFjaW5nICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIidcXG5cXG5Zb3UgYXJlIGVudGVyaW5nIHRoaXMgYnJlYWsgcG9pbnQgYmVjYXVzZSBkZXJpdmF0aW9uICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIicgaXMgYmVpbmcgdHJhY2VkIGFuZCAnXCIgKyBvYnNlcnZhYmxlLm5hbWVfICsgXCInIGlzIG5vdyBmb3JjaW5nIGl0IHRvIHVwZGF0ZS5cXG5KdXN0IGZvbGxvdyB0aGUgc3RhY2t0cmFjZSB5b3Ugc2hvdWxkIG5vdyBzZWUgaW4gdGhlIGRldnRvb2xzIHRvIHNlZSBwcmVjaXNlbHkgd2hhdCBwaWVjZSBvZiB5b3VyIGNvZGUgaXMgY2F1c2luZyB0aGlzIHVwZGF0ZVxcblRoZSBzdGFja2ZyYW1lIHlvdSBhcmUgbG9va2luZyBmb3IgaXMgYXQgbGVhc3QgfjYtOCBzdGFjay1mcmFtZXMgdXAuXFxuXFxuXCIgKyAoZGVyaXZhdGlvbiBpbnN0YW5jZW9mIENvbXB1dGVkVmFsdWUgPyBkZXJpdmF0aW9uLmRlcml2YXRpb24udG9TdHJpbmcoKS5yZXBsYWNlKC9bKl1cXC8vZywgXCIvXCIpIDogXCJcIikgKyBcIlxcblxcblRoZSBkZXBlbmRlbmNpZXMgZm9yIHRoaXMgZGVyaXZhdGlvbiBhcmU6XFxuXFxuXCIgKyBsaW5lcy5qb2luKFwiXFxuXCIpICsgXCJcXG4qL1xcbiAgICBcIikoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludERlcFRyZWUodHJlZSwgbGluZXMsIGRlcHRoKSB7XG4gIGlmIChsaW5lcy5sZW5ndGggPj0gMTAwMCkge1xuICAgIGxpbmVzLnB1c2goXCIoYW5kIG1hbnkgbW9yZSlcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGluZXMucHVzaChcIlwiICsgbmV3IEFycmF5KGRlcHRoKS5qb2luKFwiXFx0XCIpICsgdHJlZS5uYW1lKTsgLy8gTVdFOiBub3QgdGhlIGZhc3Rlc3QsIGJ1dCB0aGUgZWFzaWVzdCB3YXkgOilcblxuICBpZiAodHJlZS5kZXBlbmRlbmNpZXMpIHRyZWUuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIHByaW50RGVwVHJlZShjaGlsZCwgbGluZXMsIGRlcHRoICsgMSk7XG4gIH0pO1xufVxuXG52YXIgUmVhY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBub2RlcyB3ZSBhcmUgbG9va2luZyBhdC4gT3VyIHZhbHVlIGRlcGVuZHMgb24gdGhlc2Ugbm9kZXNcbiAgZnVuY3Rpb24gUmVhY3Rpb24obmFtZV8sIG9uSW52YWxpZGF0ZV8sIGVycm9ySGFuZGxlcl8sIHJlcXVpcmVzT2JzZXJ2YWJsZV8pIHtcbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSAgXCJSZWFjdGlvbkBcIiArIGdldE5leHRJZCgpIDtcbiAgICB9XG5cbiAgICBpZiAocmVxdWlyZXNPYnNlcnZhYmxlXyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXF1aXJlc09ic2VydmFibGVfID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzLm9uSW52YWxpZGF0ZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvckhhbmRsZXJfID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWlyZXNPYnNlcnZhYmxlXyA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmluZ18gPSBbXTtcbiAgICB0aGlzLm5ld09ic2VydmluZ18gPSBbXTtcbiAgICB0aGlzLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG4gICAgdGhpcy5kaWZmVmFsdWVfID0gMDtcbiAgICB0aGlzLnJ1bklkXyA9IDA7XG4gICAgdGhpcy51bmJvdW5kRGVwc0NvdW50XyA9IDA7XG4gICAgdGhpcy5pc0Rpc3Bvc2VkXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNTY2hlZHVsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5pc1RyYWNrUGVuZGluZ18gPSBmYWxzZTtcbiAgICB0aGlzLmlzUnVubmluZ18gPSBmYWxzZTtcbiAgICB0aGlzLmlzVHJhY2luZ18gPSBUcmFjZU1vZGUuTk9ORTtcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG4gICAgdGhpcy5vbkludmFsaWRhdGVfID0gb25JbnZhbGlkYXRlXztcbiAgICB0aGlzLmVycm9ySGFuZGxlcl8gPSBlcnJvckhhbmRsZXJfO1xuICAgIHRoaXMucmVxdWlyZXNPYnNlcnZhYmxlXyA9IHJlcXVpcmVzT2JzZXJ2YWJsZV87XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVhY3Rpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5vbkJlY29tZVN0YWxlXyA9IGZ1bmN0aW9uIG9uQmVjb21lU3RhbGVfKCkge1xuICAgIHRoaXMuc2NoZWR1bGVfKCk7XG4gIH07XG5cbiAgX3Byb3RvLnNjaGVkdWxlXyA9IGZ1bmN0aW9uIHNjaGVkdWxlXygpIHtcbiAgICBpZiAoIXRoaXMuaXNTY2hlZHVsZWRfKSB7XG4gICAgICB0aGlzLmlzU2NoZWR1bGVkXyA9IHRydWU7XG4gICAgICBnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zLnB1c2godGhpcyk7XG4gICAgICBydW5SZWFjdGlvbnMoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmlzU2NoZWR1bGVkID0gZnVuY3Rpb24gaXNTY2hlZHVsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTY2hlZHVsZWRfO1xuICB9XG4gIC8qKlxyXG4gICAqIGludGVybmFsLCB1c2Ugc2NoZWR1bGUoKSBpZiB5b3UgaW50ZW5kIHRvIGtpY2sgb2ZmIGEgcmVhY3Rpb25cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5ydW5SZWFjdGlvbl8gPSBmdW5jdGlvbiBydW5SZWFjdGlvbl8oKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWRfKSB7XG4gICAgICBzdGFydEJhdGNoKCk7XG4gICAgICB0aGlzLmlzU2NoZWR1bGVkXyA9IGZhbHNlO1xuICAgICAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQ7XG4gICAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSB0aGlzO1xuXG4gICAgICBpZiAoc2hvdWxkQ29tcHV0ZSh0aGlzKSkge1xuICAgICAgICB0aGlzLmlzVHJhY2tQZW5kaW5nXyA9IHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLm9uSW52YWxpZGF0ZV8oKTtcblxuICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMuaXNUcmFja1BlbmRpbmdfICYmIGlzU3B5RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAvLyBvbkludmFsaWRhdGUgZGlkbid0IHRyaWdnZXIgdHJhY2sgcmlnaHQgYXdheS4uXG4gICAgICAgICAgICBzcHlSZXBvcnQoe1xuICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICAgICAgICB0eXBlOiBcInNjaGVkdWxlZC1yZWFjdGlvblwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLnJlcG9ydEV4Y2VwdGlvbkluRGVyaXZhdGlvbl8oZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gcHJldjtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by50cmFjayA9IGZ1bmN0aW9uIHRyYWNrKGZuKSB7XG4gICAgaWYgKHRoaXMuaXNEaXNwb3NlZF8pIHtcbiAgICAgIHJldHVybjsgLy8gY29uc29sZS53YXJuKFwiUmVhY3Rpb24gYWxyZWFkeSBkaXNwb3NlZFwiKSAvLyBOb3RlOiBOb3QgYSB3YXJuaW5nIC8gZXJyb3IgaW4gbW9ieCA0IGVpdGhlclxuICAgIH1cblxuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICB2YXIgbm90aWZ5ID0gaXNTcHlFbmFibGVkKCk7XG4gICAgdmFyIHN0YXJ0VGltZTtcblxuICAgIGlmICggbm90aWZ5KSB7XG4gICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgc3B5UmVwb3J0U3RhcnQoe1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICB0eXBlOiBcInJlYWN0aW9uXCJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuaXNSdW5uaW5nXyA9IHRydWU7XG4gICAgdmFyIHByZXZSZWFjdGlvbiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dDsgLy8gcmVhY3Rpb25zIGNvdWxkIGNyZWF0ZSByZWFjdGlvbnMuLi5cblxuICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHRoaXM7XG4gICAgdmFyIHJlc3VsdCA9IHRyYWNrRGVyaXZlZEZ1bmN0aW9uKHRoaXMsIGZuLCB1bmRlZmluZWQpO1xuICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHByZXZSZWFjdGlvbjtcbiAgICB0aGlzLmlzUnVubmluZ18gPSBmYWxzZTtcbiAgICB0aGlzLmlzVHJhY2tQZW5kaW5nXyA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuaXNEaXNwb3NlZF8pIHtcbiAgICAgIC8vIGRpc3Bvc2VkIGR1cmluZyBsYXN0IHJ1bi4gQ2xlYW4gdXAgZXZlcnl0aGluZyB0aGF0IHdhcyBib3VuZCBhZnRlciB0aGUgZGlzcG9zZSBjYWxsLlxuICAgICAgY2xlYXJPYnNlcnZpbmcodGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ2F1Z2h0RXhjZXB0aW9uKHJlc3VsdCkpIHRoaXMucmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uXyhyZXN1bHQuY2F1c2UpO1xuXG4gICAgaWYgKCBub3RpZnkpIHtcbiAgICAgIHNweVJlcG9ydEVuZCh7XG4gICAgICAgIHRpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGVuZEJhdGNoKCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlcG9ydEV4Y2VwdGlvbkluRGVyaXZhdGlvbl8gPSBmdW5jdGlvbiByZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fKGVycm9yKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLmVycm9ySGFuZGxlcl8pIHtcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyXyhlcnJvciwgdGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMpIHRocm93IGVycm9yO1xuICAgIHZhciBtZXNzYWdlID0gIFwiW21vYnhdIEVuY291bnRlcmVkIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbiB0aGF0IHdhcyB0aHJvd24gYnkgYSByZWFjdGlvbiBvciBvYnNlcnZlciBjb21wb25lbnQsIGluOiAnXCIgKyB0aGlzICsgXCInXCIgO1xuXG4gICAgaWYgKCFnbG9iYWxTdGF0ZS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGVycm9yKTtcbiAgICAgIC8qKiBJZiBkZWJ1Z2dpbmcgYnJvdWdodCB5b3UgaGVyZSwgcGxlYXNlLCByZWFkIHRoZSBhYm92ZSBtZXNzYWdlIDotKS4gVG54ISAqL1xuICAgIH0gZWxzZSBjb25zb2xlLndhcm4oXCJbbW9ieF0gKGVycm9yIGluIHJlYWN0aW9uICdcIiArIHRoaXMubmFtZV8gKyBcIicgc3VwcHJlc3NlZCwgZml4IGVycm9yIG9mIGNhdXNpbmcgYWN0aW9uIGJlbG93KVwiKTsgLy8gcHJldHRpZXItaWdub3JlXG5cblxuICAgIGlmICggaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgIHNweVJlcG9ydCh7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgZXJyb3I6IFwiXCIgKyBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBmKGVycm9yLCBfdGhpcyk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkXykge1xuICAgICAgdGhpcy5pc0Rpc3Bvc2VkXyA9IHRydWU7XG5cbiAgICAgIGlmICghdGhpcy5pc1J1bm5pbmdfKSB7XG4gICAgICAgIC8vIGlmIGRpc3Bvc2VkIHdoaWxlIHJ1bm5pbmcsIGNsZWFuIHVwIGxhdGVyLiBNYXliZSBub3Qgb3B0aW1hbCwgYnV0IHJhcmUgY2FzZVxuICAgICAgICBzdGFydEJhdGNoKCk7XG4gICAgICAgIGNsZWFyT2JzZXJ2aW5nKHRoaXMpO1xuICAgICAgICBlbmRCYXRjaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZ2V0RGlzcG9zZXJfID0gZnVuY3Rpb24gZ2V0RGlzcG9zZXJfKCkge1xuICAgIHZhciByID0gdGhpcy5kaXNwb3NlLmJpbmQodGhpcyk7XG4gICAgclskbW9ieF0gPSB0aGlzO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIlJlYWN0aW9uW1wiICsgdGhpcy5uYW1lXyArIFwiXVwiO1xuICB9O1xuXG4gIF9wcm90by50cmFjZSA9IGZ1bmN0aW9uIHRyYWNlJDEoZW50ZXJCcmVha1BvaW50KSB7XG4gICAgaWYgKGVudGVyQnJlYWtQb2ludCA9PT0gdm9pZCAwKSB7XG4gICAgICBlbnRlckJyZWFrUG9pbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0cmFjZSh0aGlzLCBlbnRlckJyZWFrUG9pbnQpO1xuICB9O1xuXG4gIHJldHVybiBSZWFjdGlvbjtcbn0oKTtcbmZ1bmN0aW9uIG9uUmVhY3Rpb25FcnJvcihoYW5kbGVyKSB7XG4gIGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaWR4ID49IDApIGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgfTtcbn1cbi8qKlxyXG4gKiBNYWdpYyBudW1iZXIgYWxlcnQhXHJcbiAqIERlZmluZXMgd2l0aGluIGhvdyBtYW55IHRpbWVzIGEgcmVhY3Rpb24gaXMgYWxsb3dlZCB0byByZS10cmlnZ2VyIGl0c2VsZlxyXG4gKiB1bnRpbCBpdCBpcyBhc3N1bWVkIHRoYXQgdGhpcyBpcyBnb25uYSBiZSBhIG5ldmVyIGVuZGluZyBsb29wLi4uXHJcbiAqL1xuXG52YXIgTUFYX1JFQUNUSU9OX0lURVJBVElPTlMgPSAxMDA7XG5cbnZhciByZWFjdGlvblNjaGVkdWxlciA9IGZ1bmN0aW9uIHJlYWN0aW9uU2NoZWR1bGVyKGYpIHtcbiAgcmV0dXJuIGYoKTtcbn07XG5cbmZ1bmN0aW9uIHJ1blJlYWN0aW9ucygpIHtcbiAgLy8gVHJhbXBvbGluaW5nLCBpZiBydW5SZWFjdGlvbnMgYXJlIGFscmVhZHkgcnVubmluZywgbmV3IHJlYWN0aW9ucyB3aWxsIGJlIHBpY2tlZCB1cFxuICBpZiAoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAgfHwgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zKSByZXR1cm47XG4gIHJlYWN0aW9uU2NoZWR1bGVyKHJ1blJlYWN0aW9uc0hlbHBlcik7XG59XG5cbmZ1bmN0aW9uIHJ1blJlYWN0aW9uc0hlbHBlcigpIHtcbiAgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zID0gdHJ1ZTtcbiAgdmFyIGFsbFJlYWN0aW9ucyA9IGdsb2JhbFN0YXRlLnBlbmRpbmdSZWFjdGlvbnM7XG4gIHZhciBpdGVyYXRpb25zID0gMDsgLy8gV2hpbGUgcnVubmluZyByZWFjdGlvbnMsIG5ldyByZWFjdGlvbnMgbWlnaHQgYmUgdHJpZ2dlcmVkLlxuICAvLyBIZW5jZSB3ZSB3b3JrIHdpdGggdHdvIHZhcmlhYmxlcyBhbmQgY2hlY2sgd2hldGhlclxuICAvLyB3ZSBjb252ZXJnZSB0byBubyByZW1haW5pbmcgcmVhY3Rpb25zIGFmdGVyIGEgd2hpbGUuXG5cbiAgd2hpbGUgKGFsbFJlYWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKCsraXRlcmF0aW9ucyA9PT0gTUFYX1JFQUNUSU9OX0lURVJBVElPTlMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoIFwiUmVhY3Rpb24gZG9lc24ndCBjb252ZXJnZSB0byBhIHN0YWJsZSBzdGF0ZSBhZnRlciBcIiArIE1BWF9SRUFDVElPTl9JVEVSQVRJT05TICsgXCIgaXRlcmF0aW9ucy5cIiArIChcIiBQcm9iYWJseSB0aGVyZSBpcyBhIGN5Y2xlIGluIHRoZSByZWFjdGl2ZSBmdW5jdGlvbjogXCIgKyBhbGxSZWFjdGlvbnNbMF0pICk7XG4gICAgICBhbGxSZWFjdGlvbnMuc3BsaWNlKDApOyAvLyBjbGVhciByZWFjdGlvbnNcbiAgICB9XG5cbiAgICB2YXIgcmVtYWluaW5nUmVhY3Rpb25zID0gYWxsUmVhY3Rpb25zLnNwbGljZSgwKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gcmVtYWluaW5nUmVhY3Rpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVtYWluaW5nUmVhY3Rpb25zW2ldLnJ1blJlYWN0aW9uXygpO1xuICAgIH1cbiAgfVxuXG4gIGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucyA9IGZhbHNlO1xufVxuXG52YXIgaXNSZWFjdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiUmVhY3Rpb25cIiwgUmVhY3Rpb24pO1xuZnVuY3Rpb24gc2V0UmVhY3Rpb25TY2hlZHVsZXIoZm4pIHtcbiAgdmFyIGJhc2VTY2hlZHVsZXIgPSByZWFjdGlvblNjaGVkdWxlcjtcblxuICByZWFjdGlvblNjaGVkdWxlciA9IGZ1bmN0aW9uIHJlYWN0aW9uU2NoZWR1bGVyKGYpIHtcbiAgICByZXR1cm4gZm4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJhc2VTY2hlZHVsZXIoZik7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU3B5RW5hYmxlZCgpIHtcbiAgcmV0dXJuICAhIWdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5sZW5ndGg7XG59XG5mdW5jdGlvbiBzcHlSZXBvcnQoZXZlbnQpIHtcblxuICBpZiAoIWdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGxpc3RlbmVycyA9IGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0oZXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBzcHlSZXBvcnRTdGFydChldmVudCkge1xuXG4gIHZhciBjaGFuZ2UgPSBfZXh0ZW5kcyh7fSwgZXZlbnQsIHtcbiAgICBzcHlSZXBvcnRTdGFydDogdHJ1ZVxuICB9KTtcblxuICBzcHlSZXBvcnQoY2hhbmdlKTtcbn1cbnZhciBFTkRfRVZFTlQgPSB7XG4gIHR5cGU6IFwicmVwb3J0LWVuZFwiLFxuICBzcHlSZXBvcnRFbmQ6IHRydWVcbn07XG5mdW5jdGlvbiBzcHlSZXBvcnRFbmQoY2hhbmdlKSB7XG4gIGlmIChjaGFuZ2UpIHNweVJlcG9ydChfZXh0ZW5kcyh7fSwgY2hhbmdlLCB7XG4gICAgdHlwZTogXCJyZXBvcnQtZW5kXCIsXG4gICAgc3B5UmVwb3J0RW5kOiB0cnVlXG4gIH0pKTtlbHNlIHNweVJlcG9ydChFTkRfRVZFTlQpO1xufVxuZnVuY3Rpb24gc3B5KGxpc3RlbmVyKSB7XG4gIHtcbiAgICBnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIG9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzID0gZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobCkge1xuICAgICAgICByZXR1cm4gbCAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgQUNUSU9OID0gXCJhY3Rpb25cIjtcbnZhciBBQ1RJT05fQk9VTkQgPSBcImFjdGlvbi5ib3VuZFwiO1xudmFyIEFVVE9BQ1RJT04gPSBcImF1dG9BY3Rpb25cIjtcbnZhciBBVVRPQUNUSU9OX0JPVU5EID0gXCJhdXRvQWN0aW9uLmJvdW5kXCI7XG52YXIgREVGQVVMVF9BQ1RJT05fTkFNRSA9IFwiPHVubmFtZWQgYWN0aW9uPlwiO1xudmFyIGFjdGlvbkFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihBQ1RJT04pO1xudmFyIGFjdGlvbkJvdW5kQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKEFDVElPTl9CT1VORCwge1xuICBib3VuZDogdHJ1ZVxufSk7XG52YXIgYXV0b0FjdGlvbkFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihBVVRPQUNUSU9OLCB7XG4gIGF1dG9BY3Rpb246IHRydWVcbn0pO1xudmFyIGF1dG9BY3Rpb25Cb3VuZEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihBVVRPQUNUSU9OX0JPVU5ELCB7XG4gIGF1dG9BY3Rpb246IHRydWUsXG4gIGJvdW5kOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uRmFjdG9yeShhdXRvQWN0aW9uKSB7XG4gIHZhciByZXMgPSBmdW5jdGlvbiBhY3Rpb24oYXJnMSwgYXJnMikge1xuICAgIC8vIGFjdGlvbihmbigpIHt9KVxuICAgIGlmIChpc0Z1bmN0aW9uKGFyZzEpKSByZXR1cm4gY3JlYXRlQWN0aW9uKGFyZzEubmFtZSB8fCBERUZBVUxUX0FDVElPTl9OQU1FLCBhcmcxLCBhdXRvQWN0aW9uKTsgLy8gYWN0aW9uKFwibmFtZVwiLCBmbigpIHt9KVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oYXJnMikpIHJldHVybiBjcmVhdGVBY3Rpb24oYXJnMSwgYXJnMiwgYXV0b0FjdGlvbik7IC8vIEBhY3Rpb25cblxuICAgIGlmIChpc1N0cmluZ2lzaChhcmcyKSkge1xuICAgICAgcmV0dXJuIHN0b3JlQW5ub3RhdGlvbihhcmcxLCBhcmcyLCBhdXRvQWN0aW9uID8gYXV0b0FjdGlvbkFubm90YXRpb24gOiBhY3Rpb25Bbm5vdGF0aW9uKTtcbiAgICB9IC8vIGFjdGlvbihcIm5hbWVcIikgJiBAYWN0aW9uKFwibmFtZVwiKVxuXG5cbiAgICBpZiAoaXNTdHJpbmdpc2goYXJnMSkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGNyZWF0ZUFjdGlvbkFubm90YXRpb24oYXV0b0FjdGlvbiA/IEFVVE9BQ1RJT04gOiBBQ1RJT04sIHtcbiAgICAgICAgbmFtZTogYXJnMSxcbiAgICAgICAgYXV0b0FjdGlvbjogYXV0b0FjdGlvblxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGRpZShcIkludmFsaWQgYXJndW1lbnRzIGZvciBgYWN0aW9uYFwiKTtcbiAgfTtcblxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgYWN0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkZhY3RvcnkoZmFsc2UpO1xuT2JqZWN0LmFzc2lnbihhY3Rpb24sIGFjdGlvbkFubm90YXRpb24pO1xudmFyIGF1dG9BY3Rpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uRmFjdG9yeSh0cnVlKTtcbk9iamVjdC5hc3NpZ24oYXV0b0FjdGlvbiwgYXV0b0FjdGlvbkFubm90YXRpb24pO1xuYWN0aW9uLmJvdW5kID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oYWN0aW9uQm91bmRBbm5vdGF0aW9uKTtcbmF1dG9BY3Rpb24uYm91bmQgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihhdXRvQWN0aW9uQm91bmRBbm5vdGF0aW9uKTtcbmZ1bmN0aW9uIHJ1bkluQWN0aW9uKGZuKSB7XG4gIHJldHVybiBleGVjdXRlQWN0aW9uKGZuLm5hbWUgfHwgREVGQVVMVF9BQ1RJT05fTkFNRSwgZmFsc2UsIGZuLCB0aGlzLCB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gaXNBY3Rpb24odGhpbmcpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odGhpbmcpICYmIHRoaW5nLmlzTW9ieEFjdGlvbiA9PT0gdHJ1ZTtcbn1cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuYW1lZCByZWFjdGl2ZSB2aWV3IGFuZCBrZWVwcyBpdCBhbGl2ZSwgc28gdGhhdCB0aGUgdmlldyBpcyBhbHdheXNcclxuICogdXBkYXRlZCBpZiBvbmUgb2YgdGhlIGRlcGVuZGVuY2llcyBjaGFuZ2VzLCBldmVuIHdoZW4gdGhlIHZpZXcgaXMgbm90IGZ1cnRoZXIgdXNlZCBieSBzb21ldGhpbmcgZWxzZS5cclxuICogQHBhcmFtIHZpZXcgVGhlIHJlYWN0aXZlIHZpZXdcclxuICogQHJldHVybnMgZGlzcG9zZXIgZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHN0b3AgdGhlIHZpZXcgZnJvbSBiZWluZyB1cGRhdGVkIGluIHRoZSBmdXR1cmUuXHJcbiAqL1xuXG5mdW5jdGlvbiBhdXRvcnVuKHZpZXcsIG9wdHMpIHtcbiAgdmFyIF9vcHRzJG5hbWUsIF9vcHRzO1xuXG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0gRU1QVFlfT0JKRUNUO1xuICB9XG5cbiAge1xuICAgIGlmICghaXNGdW5jdGlvbih2aWV3KSkgZGllKFwiQXV0b3J1biBleHBlY3RzIGEgZnVuY3Rpb24gYXMgZmlyc3QgYXJndW1lbnRcIik7XG4gICAgaWYgKGlzQWN0aW9uKHZpZXcpKSBkaWUoXCJBdXRvcnVuIGRvZXMgbm90IGFjY2VwdCBhY3Rpb25zIHNpbmNlIGFjdGlvbnMgYXJlIHVudHJhY2thYmxlXCIpO1xuICB9XG5cbiAgdmFyIG5hbWUgPSAoX29wdHMkbmFtZSA9IChfb3B0cyA9IG9wdHMpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0cy5uYW1lKSAhPSBudWxsID8gX29wdHMkbmFtZSA6ICB2aWV3Lm5hbWUgfHwgXCJBdXRvcnVuQFwiICsgZ2V0TmV4dElkKCkgO1xuICB2YXIgcnVuU3luYyA9ICFvcHRzLnNjaGVkdWxlciAmJiAhb3B0cy5kZWxheTtcbiAgdmFyIHJlYWN0aW9uO1xuXG4gIGlmIChydW5TeW5jKSB7XG4gICAgLy8gbm9ybWFsIGF1dG9ydW5cbiAgICByZWFjdGlvbiA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyYWNrKHJlYWN0aW9uUnVubmVyKTtcbiAgICB9LCBvcHRzLm9uRXJyb3IsIG9wdHMucmVxdWlyZXNPYnNlcnZhYmxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyID0gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cyk7IC8vIGRlYm91bmNlZCBhdXRvcnVuXG5cbiAgICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICByZWFjdGlvbiA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgc2NoZWR1bGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmICghcmVhY3Rpb24uaXNEaXNwb3NlZF8pIHJlYWN0aW9uLnRyYWNrKHJlYWN0aW9uUnVubmVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgb3B0cy5vbkVycm9yLCBvcHRzLnJlcXVpcmVzT2JzZXJ2YWJsZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGlvblJ1bm5lcigpIHtcbiAgICB2aWV3KHJlYWN0aW9uKTtcbiAgfVxuXG4gIHJlYWN0aW9uLnNjaGVkdWxlXygpO1xuICByZXR1cm4gcmVhY3Rpb24uZ2V0RGlzcG9zZXJfKCk7XG59XG5cbnZhciBydW4gPSBmdW5jdGlvbiBydW4oZikge1xuICByZXR1cm4gZigpO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cykge1xuICByZXR1cm4gb3B0cy5zY2hlZHVsZXIgPyBvcHRzLnNjaGVkdWxlciA6IG9wdHMuZGVsYXkgPyBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGYsIG9wdHMuZGVsYXkpO1xuICB9IDogcnVuO1xufVxuXG5mdW5jdGlvbiByZWFjdGlvbihleHByZXNzaW9uLCBlZmZlY3QsIG9wdHMpIHtcbiAgdmFyIF9vcHRzJG5hbWUyO1xuXG4gIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICBvcHRzID0gRU1QVFlfT0JKRUNUO1xuICB9XG5cbiAge1xuICAgIGlmICghaXNGdW5jdGlvbihleHByZXNzaW9uKSB8fCAhaXNGdW5jdGlvbihlZmZlY3QpKSBkaWUoXCJGaXJzdCBhbmQgc2Vjb25kIGFyZ3VtZW50IHRvIHJlYWN0aW9uIHNob3VsZCBiZSBmdW5jdGlvbnNcIik7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KG9wdHMpKSBkaWUoXCJUaGlyZCBhcmd1bWVudCBvZiByZWFjdGlvbnMgc2hvdWxkIGJlIGFuIG9iamVjdFwiKTtcbiAgfVxuXG4gIHZhciBuYW1lID0gKF9vcHRzJG5hbWUyID0gb3B0cy5uYW1lKSAhPSBudWxsID8gX29wdHMkbmFtZTIgOiAgXCJSZWFjdGlvbkBcIiArIGdldE5leHRJZCgpIDtcbiAgdmFyIGVmZmVjdEFjdGlvbiA9IGFjdGlvbihuYW1lLCBvcHRzLm9uRXJyb3IgPyB3cmFwRXJyb3JIYW5kbGVyKG9wdHMub25FcnJvciwgZWZmZWN0KSA6IGVmZmVjdCk7XG4gIHZhciBydW5TeW5jID0gIW9wdHMuc2NoZWR1bGVyICYmICFvcHRzLmRlbGF5O1xuICB2YXIgc2NoZWR1bGVyID0gY3JlYXRlU2NoZWR1bGVyRnJvbU9wdGlvbnMob3B0cyk7XG4gIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuICB2YXIgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgb2xkVmFsdWUgPSB1bmRlZmluZWQ7IC8vIG9ubHkgYW4gaXNzdWUgd2l0aCBmaXJlSW1tZWRpYXRlbHlcblxuICB2YXIgZXF1YWxzID0gb3B0cy5jb21wYXJlU3RydWN0dXJhbCA/IGNvbXBhcmVyLnN0cnVjdHVyYWwgOiBvcHRzLmVxdWFscyB8fCBjb21wYXJlcltcImRlZmF1bHRcIl07XG4gIHZhciByID0gbmV3IFJlYWN0aW9uKG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZmlyc3RUaW1lIHx8IHJ1blN5bmMpIHtcbiAgICAgIHJlYWN0aW9uUnVubmVyKCk7XG4gICAgfSBlbHNlIGlmICghaXNTY2hlZHVsZWQpIHtcbiAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNjaGVkdWxlcihyZWFjdGlvblJ1bm5lcik7XG4gICAgfVxuICB9LCBvcHRzLm9uRXJyb3IsIG9wdHMucmVxdWlyZXNPYnNlcnZhYmxlKTtcblxuICBmdW5jdGlvbiByZWFjdGlvblJ1bm5lcigpIHtcbiAgICBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGlmIChyLmlzRGlzcG9zZWRfKSByZXR1cm47XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICByLnRyYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuZXh0VmFsdWUgPSBhbGxvd1N0YXRlQ2hhbmdlcyhmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbihyKTtcbiAgICAgIH0pO1xuICAgICAgY2hhbmdlZCA9IGZpcnN0VGltZSB8fCAhZXF1YWxzKHZhbHVlLCBuZXh0VmFsdWUpO1xuICAgICAgb2xkVmFsdWUgPSB2YWx1ZTtcbiAgICAgIHZhbHVlID0gbmV4dFZhbHVlO1xuICAgIH0pO1xuICAgIGlmIChmaXJzdFRpbWUgJiYgb3B0cy5maXJlSW1tZWRpYXRlbHkpIGVmZmVjdEFjdGlvbih2YWx1ZSwgb2xkVmFsdWUsIHIpO2Vsc2UgaWYgKCFmaXJzdFRpbWUgJiYgY2hhbmdlZCkgZWZmZWN0QWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSwgcik7XG4gICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gIH1cblxuICByLnNjaGVkdWxlXygpO1xuICByZXR1cm4gci5nZXREaXNwb3Nlcl8oKTtcbn1cblxuZnVuY3Rpb24gd3JhcEVycm9ySGFuZGxlcihlcnJvckhhbmRsZXIsIGJhc2VGbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYmFzZUZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JIYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgT05fQkVDT01FX09CU0VSVkVEID0gXCJvbkJPXCI7XG52YXIgT05fQkVDT01FX1VOT0JTRVJWRUQgPSBcIm9uQlVPXCI7XG5mdW5jdGlvbiBvbkJlY29tZU9ic2VydmVkKHRoaW5nLCBhcmcyLCBhcmczKSB7XG4gIHJldHVybiBpbnRlcmNlcHRIb29rKE9OX0JFQ09NRV9PQlNFUlZFRCwgdGhpbmcsIGFyZzIsIGFyZzMpO1xufVxuZnVuY3Rpb24gb25CZWNvbWVVbm9ic2VydmVkKHRoaW5nLCBhcmcyLCBhcmczKSB7XG4gIHJldHVybiBpbnRlcmNlcHRIb29rKE9OX0JFQ09NRV9VTk9CU0VSVkVELCB0aGluZywgYXJnMiwgYXJnMyk7XG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdEhvb2soaG9vaywgdGhpbmcsIGFyZzIsIGFyZzMpIHtcbiAgdmFyIGF0b20gPSB0eXBlb2YgYXJnMyA9PT0gXCJmdW5jdGlvblwiID8gZ2V0QXRvbSh0aGluZywgYXJnMikgOiBnZXRBdG9tKHRoaW5nKTtcbiAgdmFyIGNiID0gaXNGdW5jdGlvbihhcmczKSA/IGFyZzMgOiBhcmcyO1xuICB2YXIgbGlzdGVuZXJzS2V5ID0gaG9vayArIFwiTFwiO1xuXG4gIGlmIChhdG9tW2xpc3RlbmVyc0tleV0pIHtcbiAgICBhdG9tW2xpc3RlbmVyc0tleV0uYWRkKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBhdG9tW2xpc3RlbmVyc0tleV0gPSBuZXcgU2V0KFtjYl0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9va0xpc3RlbmVycyA9IGF0b21bbGlzdGVuZXJzS2V5XTtcblxuICAgIGlmIChob29rTGlzdGVuZXJzKSB7XG4gICAgICBob29rTGlzdGVuZXJzW1wiZGVsZXRlXCJdKGNiKTtcblxuICAgICAgaWYgKGhvb2tMaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgYXRvbVtsaXN0ZW5lcnNLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIE5FVkVSID0gXCJuZXZlclwiO1xudmFyIEFMV0FZUyA9IFwiYWx3YXlzXCI7XG52YXIgT0JTRVJWRUQgPSBcIm9ic2VydmVkXCI7IC8vIGNvbnN0IElGX0FWQUlMQUJMRSA9IFwiaWZhdmFpbGFibGVcIlxuXG5mdW5jdGlvbiBjb25maWd1cmUob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5pc29sYXRlR2xvYmFsU3RhdGUgPT09IHRydWUpIHtcbiAgICBpc29sYXRlR2xvYmFsU3RhdGUoKTtcbiAgfVxuXG4gIHZhciB1c2VQcm94aWVzID0gb3B0aW9ucy51c2VQcm94aWVzLFxuICAgICAgZW5mb3JjZUFjdGlvbnMgPSBvcHRpb25zLmVuZm9yY2VBY3Rpb25zO1xuXG4gIGlmICh1c2VQcm94aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbG9iYWxTdGF0ZS51c2VQcm94aWVzID0gdXNlUHJveGllcyA9PT0gQUxXQVlTID8gdHJ1ZSA6IHVzZVByb3hpZXMgPT09IE5FVkVSID8gZmFsc2UgOiB0eXBlb2YgUHJveHkgIT09IFwidW5kZWZpbmVkXCI7XG4gIH1cblxuICBpZiAodXNlUHJveGllcyA9PT0gXCJpZmF2YWlsYWJsZVwiKSBnbG9iYWxTdGF0ZS52ZXJpZnlQcm94aWVzID0gdHJ1ZTtcblxuICBpZiAoZW5mb3JjZUFjdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBlYSA9IGVuZm9yY2VBY3Rpb25zID09PSBBTFdBWVMgPyBBTFdBWVMgOiBlbmZvcmNlQWN0aW9ucyA9PT0gT0JTRVJWRUQ7XG4gICAgZ2xvYmFsU3RhdGUuZW5mb3JjZUFjdGlvbnMgPSBlYTtcbiAgICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyA9IGVhID09PSB0cnVlIHx8IGVhID09PSBBTFdBWVMgPyBmYWxzZSA6IHRydWU7XG4gIH1cbiAgW1wiY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uXCIsIFwicmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGVcIiwgXCJvYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvblwiLCBcImRpc2FibGVFcnJvckJvdW5kYXJpZXNcIiwgXCJzYWZlRGVzY3JpcHRvcnNcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGtleSBpbiBvcHRpb25zKSBnbG9iYWxTdGF0ZVtrZXldID0gISFvcHRpb25zW2tleV07XG4gIH0pO1xuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHMgPSAhZ2xvYmFsU3RhdGUub2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb247XG5cbiAgaWYgKCBnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID09PSB0cnVlKSB7XG4gICAgY29uc29sZS53YXJuKFwiV0FSTklORzogRGVidWcgZmVhdHVyZSBvbmx5LiBNb2JYIHdpbGwgTk9UIHJlY292ZXIgZnJvbSBlcnJvcnMgd2hlbiBgZGlzYWJsZUVycm9yQm91bmRhcmllc2AgaXMgZW5hYmxlZC5cIik7XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZWFjdGlvblNjaGVkdWxlcikge1xuICAgIHNldFJlYWN0aW9uU2NoZWR1bGVyKG9wdGlvbnMucmVhY3Rpb25TY2hlZHVsZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dGVuZE9ic2VydmFibGUodGFyZ2V0LCBwcm9wZXJ0aWVzLCBhbm5vdGF0aW9ucywgb3B0aW9ucykge1xuICB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiA0KSBkaWUoXCInZXh0ZW5kT2JzZXJ2YWJsZScgZXhwZWN0ZWQgMi00IGFyZ3VtZW50c1wiKTtcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIikgZGllKFwiJ2V4dGVuZE9ic2VydmFibGUnIGV4cGVjdHMgYW4gb2JqZWN0IGFzIGZpcnN0IGFyZ3VtZW50XCIpO1xuICAgIGlmIChpc09ic2VydmFibGVNYXAodGFyZ2V0KSkgZGllKFwiJ2V4dGVuZE9ic2VydmFibGUnIHNob3VsZCBub3QgYmUgdXNlZCBvbiBtYXBzLCB1c2UgbWFwLm1lcmdlIGluc3RlYWRcIik7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHByb3BlcnRpZXMpKSBkaWUoXCInZXh0ZW5kT2JzZXJ2YWJlJyBvbmx5IGFjY2VwdHMgcGxhaW4gb2JqZWN0cyBhcyBzZWNvbmQgYXJndW1lbnRcIik7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZShwcm9wZXJ0aWVzKSB8fCBpc09ic2VydmFibGUoYW5ub3RhdGlvbnMpKSBkaWUoXCJFeHRlbmRpbmcgYW4gb2JqZWN0IHdpdGggYW5vdGhlciBvYnNlcnZhYmxlIChvYmplY3QpIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gIH0gLy8gUHVsbCBkZXNjcmlwdG9ycyBmaXJzdCwgc28gd2UgZG9uJ3QgaGF2ZSB0byBkZWFsIHdpdGggcHJvcHMgYWRkZWQgYnkgYWRtaW5pc3RyYXRpb24gKCRtb2J4KVxuXG5cbiAgdmFyIGRlc2NyaXB0b3JzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhwcm9wZXJ0aWVzKTtcbiAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpWyRtb2J4XTtcbiAgc3RhcnRCYXRjaCgpO1xuXG4gIHRyeSB7XG4gICAgb3duS2V5cyhkZXNjcmlwdG9ycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBhZG0uZXh0ZW5kXyhrZXksIGRlc2NyaXB0b3JzW2tleV0sIC8vIG11c3QgcGFzcyBcInVuZGVmaW5lZFwiIGZvciB7IGtleTogdW5kZWZpbmVkIH1cbiAgICAgICFhbm5vdGF0aW9ucyA/IHRydWUgOiBrZXkgaW4gYW5ub3RhdGlvbnMgPyBhbm5vdGF0aW9uc1trZXldIDogdHJ1ZSk7XG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgZW5kQmF0Y2goKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGdldERlcGVuZGVuY3lUcmVlKHRoaW5nLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gbm9kZVRvRGVwZW5kZW5jeVRyZWUoZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpKTtcbn1cblxuZnVuY3Rpb24gbm9kZVRvRGVwZW5kZW5jeVRyZWUobm9kZSkge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIG5hbWU6IG5vZGUubmFtZV9cbiAgfTtcbiAgaWYgKG5vZGUub2JzZXJ2aW5nXyAmJiBub2RlLm9ic2VydmluZ18ubGVuZ3RoID4gMCkgcmVzdWx0LmRlcGVuZGVuY2llcyA9IHVuaXF1ZShub2RlLm9ic2VydmluZ18pLm1hcChub2RlVG9EZXBlbmRlbmN5VHJlZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldE9ic2VydmVyVHJlZSh0aGluZywgcHJvcGVydHkpIHtcbiAgcmV0dXJuIG5vZGVUb09ic2VydmVyVHJlZShnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkpO1xufVxuXG5mdW5jdGlvbiBub2RlVG9PYnNlcnZlclRyZWUobm9kZSkge1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIG5hbWU6IG5vZGUubmFtZV9cbiAgfTtcbiAgaWYgKGhhc09ic2VydmVycyhub2RlKSkgcmVzdWx0Lm9ic2VydmVycyA9IEFycmF5LmZyb20oZ2V0T2JzZXJ2ZXJzKG5vZGUpKS5tYXAobm9kZVRvT2JzZXJ2ZXJUcmVlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdW5pcXVlKGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChsaXN0KSk7XG59XG5cbnZhciBnZW5lcmF0b3JJZCA9IDA7XG5mdW5jdGlvbiBGbG93Q2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gIHRoaXMubWVzc2FnZSA9IFwiRkxPV19DQU5DRUxMRURcIjtcbn1cbkZsb3dDYW5jZWxsYXRpb25FcnJvci5wcm90b3R5cGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuZnVuY3Rpb24gaXNGbG93Q2FuY2VsbGF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRmxvd0NhbmNlbGxhdGlvbkVycm9yO1xufVxudmFyIGZsb3dBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUZsb3dBbm5vdGF0aW9uKFwiZmxvd1wiKTtcbnZhciBmbG93Qm91bmRBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUZsb3dBbm5vdGF0aW9uKFwiZmxvdy5ib3VuZFwiLCB7XG4gIGJvdW5kOiB0cnVlXG59KTtcbnZhciBmbG93ID0gLyojX19QVVJFX18qL09iamVjdC5hc3NpZ24oZnVuY3Rpb24gZmxvdyhhcmcxLCBhcmcyKSB7XG4gIC8vIEBmbG93XG4gIGlmIChpc1N0cmluZ2lzaChhcmcyKSkge1xuICAgIHJldHVybiBzdG9yZUFubm90YXRpb24oYXJnMSwgYXJnMiwgZmxvd0Fubm90YXRpb24pO1xuICB9IC8vIGZsb3coZm4pXG5cblxuICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIGRpZShcIkZsb3cgZXhwZWN0cyBzaW5nbGUgYXJndW1lbnQgd2l0aCBnZW5lcmF0b3IgZnVuY3Rpb25cIik7XG4gIHZhciBnZW5lcmF0b3IgPSBhcmcxO1xuICB2YXIgbmFtZSA9IGdlbmVyYXRvci5uYW1lIHx8IFwiPHVubmFtZWQgZmxvdz5cIjsgLy8gSW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3RqL2NvL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5cbiAgdmFyIHJlcyA9IGZ1bmN0aW9uIHJlcygpIHtcbiAgICB2YXIgY3R4ID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcnVuSWQgPSArK2dlbmVyYXRvcklkO1xuICAgIHZhciBnZW4gPSBhY3Rpb24obmFtZSArIFwiIC0gcnVuaWQ6IFwiICsgcnVuSWQgKyBcIiAtIGluaXRcIiwgZ2VuZXJhdG9yKS5hcHBseShjdHgsIGFyZ3MpO1xuICAgIHZhciByZWplY3RvcjtcbiAgICB2YXIgcGVuZGluZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgc3RlcElkID0gMDtcbiAgICAgIHJlamVjdG9yID0gcmVqZWN0O1xuXG4gICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxlZChyZXMpIHtcbiAgICAgICAgcGVuZGluZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBhY3Rpb24obmFtZSArIFwiIC0gcnVuaWQ6IFwiICsgcnVuSWQgKyBcIiAtIHlpZWxkIFwiICsgc3RlcElkKyssIGdlbi5uZXh0KS5jYWxsKGdlbiwgcmVzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KHJldCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0ZWQoZXJyKSB7XG4gICAgICAgIHBlbmRpbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0ID0gYWN0aW9uKG5hbWUgKyBcIiAtIHJ1bmlkOiBcIiArIHJ1bklkICsgXCIgLSB5aWVsZCBcIiArIHN0ZXBJZCsrLCBnZW5bXCJ0aHJvd1wiXSkuY2FsbChnZW4sIGVycik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChyZXQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZXh0KHJldCkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXQgPT0gbnVsbCA/IHZvaWQgMCA6IHJldC50aGVuKSkge1xuICAgICAgICAgIC8vIGFuIGFzeW5jIGl0ZXJhdG9yXG4gICAgICAgICAgcmV0LnRoZW4obmV4dCwgcmVqZWN0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0LmRvbmUpIHJldHVybiByZXNvbHZlKHJldC52YWx1ZSk7XG4gICAgICAgIHBlbmRpbmdQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHJldC52YWx1ZSk7XG4gICAgICAgIHJldHVybiBwZW5kaW5nUHJvbWlzZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgb25GdWxmaWxsZWQodW5kZWZpbmVkKTsgLy8ga2ljayBvZmYgdGhlIHByb2Nlc3NcbiAgICB9KTtcbiAgICBwcm9taXNlLmNhbmNlbCA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0gY2FuY2VsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwZW5kaW5nUHJvbWlzZSkgY2FuY2VsUHJvbWlzZShwZW5kaW5nUHJvbWlzZSk7IC8vIEZpbmFsbHkgYmxvY2sgY2FuIHJldHVybiAob3IgeWllbGQpIHN0dWZmLi5cblxuICAgICAgICB2YXIgX3JlcyA9IGdlbltcInJldHVyblwiXSh1bmRlZmluZWQpOyAvLyBlYXQgYW55dGhpbmcgdGhhdCBwcm9taXNlIHdvdWxkIGRvLCBpdCdzIGNhbmNlbGxlZCFcblxuXG4gICAgICAgIHZhciB5aWVsZGVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShfcmVzLnZhbHVlKTtcbiAgICAgICAgeWllbGRlZFByb21pc2UudGhlbihub29wLCBub29wKTtcbiAgICAgICAgY2FuY2VsUHJvbWlzZSh5aWVsZGVkUHJvbWlzZSk7IC8vIG1heWJlIGl0IGNhbiBiZSBjYW5jZWxsZWQgOilcbiAgICAgICAgLy8gcmVqZWN0IG91ciBvcmlnaW5hbCBwcm9taXNlXG5cbiAgICAgICAgcmVqZWN0b3IobmV3IEZsb3dDYW5jZWxsYXRpb25FcnJvcigpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0b3IoZSk7IC8vIHRoZXJlIGNvdWxkIGJlIGEgdGhyb3dpbmcgZmluYWxseSBibG9ja1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJlcy5pc01vYlhGbG93ID0gdHJ1ZTtcbiAgcmV0dXJuIHJlcztcbn0sIGZsb3dBbm5vdGF0aW9uKTtcbmZsb3cuYm91bmQgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihmbG93Qm91bmRBbm5vdGF0aW9uKTtcblxuZnVuY3Rpb24gY2FuY2VsUHJvbWlzZShwcm9taXNlKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHByb21pc2UuY2FuY2VsKSkgcHJvbWlzZS5jYW5jZWwoKTtcbn1cblxuZnVuY3Rpb24gZmxvd1Jlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdDsgLy8ganVzdCB0cmlja2luZyBUeXBlU2NyaXB0IDopXG59XG5mdW5jdGlvbiBpc0Zsb3coZm4pIHtcbiAgcmV0dXJuIChmbiA9PSBudWxsID8gdm9pZCAwIDogZm4uaXNNb2JYRmxvdykgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdFJlYWRzKHRoaW5nLCBwcm9wT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gIHZhciB0YXJnZXQ7XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0aGluZykgfHwgaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZVZhbHVlKHRoaW5nKSkge1xuICAgIHRhcmdldCA9IGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVPYmplY3QodGhpbmcpKSB7XG4gICAgaWYgKCAhaXNTdHJpbmdpc2gocHJvcE9ySGFuZGxlcikpIHJldHVybiBkaWUoXCJJbnRlcmNlcHRSZWFkcyBjYW4gb25seSBiZSB1c2VkIHdpdGggYSBzcGVjaWZpYyBwcm9wZXJ0eSwgbm90IHdpdGggYW4gb2JqZWN0IGluIGdlbmVyYWxcIik7XG4gICAgdGFyZ2V0ID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BPckhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkaWUoXCJFeHBlY3RlZCBvYnNlcnZhYmxlIG1hcCwgb2JqZWN0IG9yIGFycmF5IGFzIGZpcnN0IGFycmF5XCIpO1xuICB9XG5cbiAgaWYgKCB0YXJnZXQuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGRpZShcIkFuIGludGVyY2VwdCByZWFkZXIgd2FzIGFscmVhZHkgZXN0YWJsaXNoZWRcIik7XG4gIHRhcmdldC5kZWhhbmNlciA9IHR5cGVvZiBwcm9wT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIgPyBwcm9wT3JIYW5kbGVyIDogaGFuZGxlcjtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0YXJnZXQuZGVoYW5jZXIgPSB1bmRlZmluZWQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdCh0aGluZywgcHJvcE9ySGFuZGxlciwgaGFuZGxlcikge1xuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkgcmV0dXJuIGludGVyY2VwdFByb3BlcnR5KHRoaW5nLCBwcm9wT3JIYW5kbGVyLCBoYW5kbGVyKTtlbHNlIHJldHVybiBpbnRlcmNlcHRJbnRlcmNlcHRhYmxlKHRoaW5nLCBwcm9wT3JIYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0SW50ZXJjZXB0YWJsZSh0aGluZywgaGFuZGxlcikge1xuICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpLmludGVyY2VwdF8oaGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdFByb3BlcnR5KHRoaW5nLCBwcm9wZXJ0eSwgaGFuZGxlcikge1xuICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BlcnR5KS5pbnRlcmNlcHRfKGhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBfaXNDb21wdXRlZCh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXZhbHVlWyRtb2J4XS52YWx1ZXNfLmhhcyhwcm9wZXJ0eSkpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgYXRvbSA9IGdldEF0b20odmFsdWUsIHByb3BlcnR5KTtcbiAgICByZXR1cm4gaXNDb21wdXRlZFZhbHVlKGF0b20pO1xuICB9XG5cbiAgcmV0dXJuIGlzQ29tcHV0ZWRWYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0NvbXB1dGVkKHZhbHVlKSB7XG4gIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBkaWUoXCJpc0NvbXB1dGVkIGV4cGVjdHMgb25seSAxIGFyZ3VtZW50LiBVc2UgaXNDb21wdXRlZFByb3AgdG8gaW5zcGVjdCB0aGUgb2JzZXJ2YWJpbGl0eSBvZiBhIHByb3BlcnR5XCIpO1xuICByZXR1cm4gX2lzQ29tcHV0ZWQodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNDb21wdXRlZFByb3AodmFsdWUsIHByb3BOYW1lKSB7XG4gIGlmICggIWlzU3RyaW5naXNoKHByb3BOYW1lKSkgcmV0dXJuIGRpZShcImlzQ29tcHV0ZWQgZXhwZWN0ZWQgYSBwcm9wZXJ0eSBuYW1lIGFzIHNlY29uZCBhcmd1bWVudFwiKTtcbiAgcmV0dXJuIF9pc0NvbXB1dGVkKHZhbHVlLCBwcm9wTmFtZSk7XG59XG5cbmZ1bmN0aW9uIF9pc09ic2VydmFibGUodmFsdWUsIHByb3BlcnR5KSB7XG4gIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcblxuICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICggKGlzT2JzZXJ2YWJsZU1hcCh2YWx1ZSkgfHwgaXNPYnNlcnZhYmxlQXJyYXkodmFsdWUpKSkgcmV0dXJuIGRpZShcImlzT2JzZXJ2YWJsZShvYmplY3QsIHByb3BlcnR5TmFtZSkgaXMgbm90IHN1cHBvcnRlZCBmb3IgYXJyYXlzIGFuZCBtYXBzLiBVc2UgbWFwLmhhcyBvciBhcnJheS5sZW5ndGggaW5zdGVhZC5cIik7XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlWyRtb2J4XS52YWx1ZXNfLmhhcyhwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIEZvciBmaXJzdCBjaGVjaywgc2VlICM3MDFcblxuXG4gIHJldHVybiBpc09ic2VydmFibGVPYmplY3QodmFsdWUpIHx8ICEhdmFsdWVbJG1vYnhdIHx8IGlzQXRvbSh2YWx1ZSkgfHwgaXNSZWFjdGlvbih2YWx1ZSkgfHwgaXNDb21wdXRlZFZhbHVlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlKHZhbHVlKSB7XG4gIGlmICggYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkgZGllKFwiaXNPYnNlcnZhYmxlIGV4cGVjdHMgb25seSAxIGFyZ3VtZW50LiBVc2UgaXNPYnNlcnZhYmxlUHJvcCB0byBpbnNwZWN0IHRoZSBvYnNlcnZhYmlsaXR5IG9mIGEgcHJvcGVydHlcIik7XG4gIHJldHVybiBfaXNPYnNlcnZhYmxlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZVByb3AodmFsdWUsIHByb3BOYW1lKSB7XG4gIGlmICggIWlzU3RyaW5naXNoKHByb3BOYW1lKSkgcmV0dXJuIGRpZShcImV4cGVjdGVkIGEgcHJvcGVydHkgbmFtZSBhcyBzZWNvbmQgYXJndW1lbnRcIik7XG4gIHJldHVybiBfaXNPYnNlcnZhYmxlKHZhbHVlLCBwcm9wTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGtleXMob2JqKSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmpbJG1vYnhdLmtleXNfKCk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikgfHwgaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShvYmoua2V5cygpKTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSk7XG4gIH1cblxuICBkaWUoNSk7XG59XG5mdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBvYmouZ2V0KGtleSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShvYmoudmFsdWVzKCkpO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH1cblxuICBkaWUoNik7XG59XG5mdW5jdGlvbiBlbnRyaWVzKG9iaikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqW2tleV1dO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgcmV0dXJuIGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9iai5nZXQoa2V5KV07XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShvYmouZW50cmllcygpKTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBbaW5kZXgsIGtleV07XG4gICAgfSk7XG4gIH1cblxuICBkaWUoNyk7XG59XG5mdW5jdGlvbiBzZXQob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICFpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICB2YXIgX3ZhbHVlcyA9IGtleTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfa2V5IGluIF92YWx1ZXMpIHtcbiAgICAgICAgc2V0KG9iaiwgX2tleSwgX3ZhbHVlc1tfa2V5XSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgb2JqWyRtb2J4XS5zZXRfKGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgb2JqLnNldChrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIG9iai5hZGQoa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09IFwibnVtYmVyXCIpIGtleSA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgIGlmIChrZXkgPCAwKSBkaWUoXCJJbnZhbGlkIGluZGV4OiAnXCIgKyBrZXkgKyBcIidcIik7XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIGlmIChrZXkgPj0gb2JqLmxlbmd0aCkgb2JqLmxlbmd0aCA9IGtleSArIDE7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICBlbmRCYXRjaCgpO1xuICB9IGVsc2UgZGllKDgpO1xufVxuZnVuY3Rpb24gcmVtb3ZlKG9iaiwga2V5KSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIG9ialskbW9ieF0uZGVsZXRlXyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgb2JqW1wiZGVsZXRlXCJdKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICBvYmpbXCJkZWxldGVcIl0oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09IFwibnVtYmVyXCIpIGtleSA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgIG9iai5zcGxpY2Uoa2V5LCAxKTtcbiAgfSBlbHNlIHtcbiAgICBkaWUoOSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5oYXNfKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmhhcyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIG9iai5oYXMoa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIGtleSA+PSAwICYmIGtleSA8IG9iai5sZW5ndGg7XG4gIH1cblxuICBkaWUoMTApO1xufVxuZnVuY3Rpb24gZ2V0KG9iaiwga2V5KSB7XG4gIGlmICghaGFzKG9iaiwga2V5KSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5nZXRfKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmdldChrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cblxuICBkaWUoMTEpO1xufVxuZnVuY3Rpb24gYXBpRGVmaW5lUHJvcGVydHkob2JqLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0uZGVmaW5lUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvcik7XG4gIH1cblxuICBkaWUoMzkpO1xufVxuZnVuY3Rpb24gYXBpT3duS2V5cyhvYmopIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0ub3duS2V5c18oKTtcbiAgfVxuXG4gIGRpZSgzOCk7XG59XG5cbmZ1bmN0aW9uIG9ic2VydmUodGhpbmcsIHByb3BPckNiLCBjYk9yRmlyZSwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gIGlmIChpc0Z1bmN0aW9uKGNiT3JGaXJlKSkgcmV0dXJuIG9ic2VydmVPYnNlcnZhYmxlUHJvcGVydHkodGhpbmcsIHByb3BPckNiLCBjYk9yRmlyZSwgZmlyZUltbWVkaWF0ZWx5KTtlbHNlIHJldHVybiBvYnNlcnZlT2JzZXJ2YWJsZSh0aGluZywgcHJvcE9yQ2IsIGNiT3JGaXJlKTtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZU9ic2VydmFibGUodGhpbmcsIGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKS5vYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KTtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZU9ic2VydmFibGVQcm9wZXJ0eSh0aGluZywgcHJvcGVydHksIGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wZXJ0eSkub2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSk7XG59XG5cbmZ1bmN0aW9uIGNhY2hlKG1hcCwga2V5LCB2YWx1ZSkge1xuICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRvSlNIZWxwZXIoc291cmNlLCBfX2FscmVhZHlTZWVuKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCB8fCB0eXBlb2Ygc291cmNlICE9PSBcIm9iamVjdFwiIHx8IHNvdXJjZSBpbnN0YW5jZW9mIERhdGUgfHwgIWlzT2JzZXJ2YWJsZShzb3VyY2UpKSByZXR1cm4gc291cmNlO1xuICBpZiAoaXNPYnNlcnZhYmxlVmFsdWUoc291cmNlKSB8fCBpc0NvbXB1dGVkVmFsdWUoc291cmNlKSkgcmV0dXJuIHRvSlNIZWxwZXIoc291cmNlLmdldCgpLCBfX2FscmVhZHlTZWVuKTtcblxuICBpZiAoX19hbHJlYWR5U2Vlbi5oYXMoc291cmNlKSkge1xuICAgIHJldHVybiBfX2FscmVhZHlTZWVuLmdldChzb3VyY2UpO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KHNvdXJjZSkpIHtcbiAgICB2YXIgcmVzID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkpO1xuICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICByZXNbaWR4XSA9IHRvSlNIZWxwZXIodmFsdWUsIF9fYWxyZWFkeVNlZW4pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlU2V0KHNvdXJjZSkpIHtcbiAgICB2YXIgX3JlcyA9IGNhY2hlKF9fYWxyZWFkeVNlZW4sIHNvdXJjZSwgbmV3IFNldCgpKTtcblxuICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgX3Jlcy5hZGQodG9KU0hlbHBlcih2YWx1ZSwgX19hbHJlYWR5U2VlbikpO1xuICAgIH0pO1xuICAgIHJldHVybiBfcmVzO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChzb3VyY2UpKSB7XG4gICAgdmFyIF9yZXMyID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBuZXcgTWFwKCkpO1xuXG4gICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIF9yZXMyLnNldChrZXksIHRvSlNIZWxwZXIodmFsdWUsIF9fYWxyZWFkeVNlZW4pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3JlczI7XG4gIH0gZWxzZSB7XG4gICAgLy8gbXVzdCBiZSBvYnNlcnZhYmxlIG9iamVjdFxuICAgIHZhciBfcmVzMyA9IGNhY2hlKF9fYWxyZWFkeVNlZW4sIHNvdXJjZSwge30pO1xuXG4gICAgYXBpT3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKG9iamVjdFByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICBfcmVzM1trZXldID0gdG9KU0hlbHBlcihzb3VyY2Vba2V5XSwgX19hbHJlYWR5U2Vlbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9yZXMzO1xuICB9XG59XG4vKipcclxuICogQmFzaWNhbGx5LCBhIGRlZXAgY2xvbmUsIHNvIHRoYXQgbm8gcmVhY3RpdmUgcHJvcGVydHkgd2lsbCBleGlzdCBhbnltb3JlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiB0b0pTKHNvdXJjZSwgb3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMpIGRpZShcInRvSlMgbm8gbG9uZ2VyIHN1cHBvcnRzIG9wdGlvbnNcIik7XG4gIHJldHVybiB0b0pTSGVscGVyKHNvdXJjZSwgbmV3IE1hcCgpKTtcbn1cblxuZnVuY3Rpb24gdHJhY2UoKSB7XG4gIHZhciBlbnRlckJyZWFrUG9pbnQgPSBmYWxzZTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwiYm9vbGVhblwiKSBlbnRlckJyZWFrUG9pbnQgPSBhcmdzLnBvcCgpO1xuICB2YXIgZGVyaXZhdGlvbiA9IGdldEF0b21Gcm9tQXJncyhhcmdzKTtcblxuICBpZiAoIWRlcml2YXRpb24pIHtcbiAgICByZXR1cm4gZGllKFwiJ3RyYWNlKGJyZWFrPyknIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgdHJhY2tlZCBjb21wdXRlZCB2YWx1ZSBvciBhIFJlYWN0aW9uLiBDb25zaWRlciBwYXNzaW5nIGluIHRoZSBjb21wdXRlZCB2YWx1ZSBvciByZWFjdGlvbiBleHBsaWNpdGx5XCIpO1xuICB9XG5cbiAgaWYgKGRlcml2YXRpb24uaXNUcmFjaW5nXyA9PT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIHRyYWNpbmcgZW5hYmxlZFwiKTtcbiAgfVxuXG4gIGRlcml2YXRpb24uaXNUcmFjaW5nXyA9IGVudGVyQnJlYWtQb2ludCA/IFRyYWNlTW9kZS5CUkVBSyA6IFRyYWNlTW9kZS5MT0c7XG59XG5cbmZ1bmN0aW9uIGdldEF0b21Gcm9tQXJncyhhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGdldEF0b20oYXJnc1swXSk7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZ2V0QXRvbShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfVxufVxuXG4vKipcclxuICogRHVyaW5nIGEgdHJhbnNhY3Rpb24gbm8gdmlld3MgYXJlIHVwZGF0ZWQgdW50aWwgdGhlIGVuZCBvZiB0aGUgdHJhbnNhY3Rpb24uXHJcbiAqIFRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJ1biBzeW5jaHJvbm91c2x5IG5vbmV0aGVsZXNzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIGEgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIHNvbWUgcmVhY3RpdmUgc3RhdGVcclxuICogQHJldHVybnMgYW55IHZhbHVlIHRoYXQgd2FzIHJldHVybmVkIGJ5IHRoZSAnYWN0aW9uJyBwYXJhbWV0ZXIuXHJcbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2FjdGlvbihhY3Rpb24sIHRoaXNBcmcpIHtcbiAgaWYgKHRoaXNBcmcgPT09IHZvaWQgMCkge1xuICAgIHRoaXNBcmcgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBzdGFydEJhdGNoKCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYWN0aW9uLmFwcGx5KHRoaXNBcmcpO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2hlbihwcmVkaWNhdGUsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgYXJnMSAmJiB0eXBlb2YgYXJnMSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIHdoZW5Qcm9taXNlKHByZWRpY2F0ZSwgYXJnMSk7XG4gIHJldHVybiBfd2hlbihwcmVkaWNhdGUsIGFyZzEsIGFyZzIgfHwge30pO1xufVxuXG5mdW5jdGlvbiBfd2hlbihwcmVkaWNhdGUsIGVmZmVjdCwgb3B0cykge1xuICB2YXIgdGltZW91dEhhbmRsZTtcblxuICBpZiAodHlwZW9mIG9wdHMudGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIldIRU5fVElNRU9VVFwiKTtcbiAgICB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWRpc3Bvc2VyWyRtb2J4XS5pc0Rpc3Bvc2VkXykge1xuICAgICAgICBkaXNwb3NlcigpO1xuICAgICAgICBpZiAob3B0cy5vbkVycm9yKSBvcHRzLm9uRXJyb3IoZXJyb3IpO2Vsc2UgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSwgb3B0cy50aW1lb3V0KTtcbiAgfVxuXG4gIG9wdHMubmFtZSA9ICBvcHRzLm5hbWUgfHwgXCJXaGVuQFwiICsgZ2V0TmV4dElkKCkgO1xuICB2YXIgZWZmZWN0QWN0aW9uID0gY3JlYXRlQWN0aW9uKCBvcHRzLm5hbWUgKyBcIi1lZmZlY3RcIiAsIGVmZmVjdCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG4gIHZhciBkaXNwb3NlciA9IGF1dG9ydW4oZnVuY3Rpb24gKHIpIHtcbiAgICAvLyBwcmVkaWNhdGUgc2hvdWxkIG5vdCBjaGFuZ2Ugc3RhdGVcbiAgICB2YXIgY29uZCA9IGFsbG93U3RhdGVDaGFuZ2VzKGZhbHNlLCBwcmVkaWNhdGUpO1xuXG4gICAgaWYgKGNvbmQpIHtcbiAgICAgIHIuZGlzcG9zZSgpO1xuICAgICAgaWYgKHRpbWVvdXRIYW5kbGUpIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgIGVmZmVjdEFjdGlvbigpO1xuICAgIH1cbiAgfSwgb3B0cyk7XG4gIHJldHVybiBkaXNwb3Nlcjtcbn1cblxuZnVuY3Rpb24gd2hlblByb21pc2UocHJlZGljYXRlLCBvcHRzKSB7XG4gIGlmICggb3B0cyAmJiBvcHRzLm9uRXJyb3IpIHJldHVybiBkaWUoXCJ0aGUgb3B0aW9ucyAnb25FcnJvcicgYW5kICdwcm9taXNlJyBjYW5ub3QgYmUgY29tYmluZWRcIik7XG4gIHZhciBjYW5jZWw7XG4gIHZhciByZXMgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGRpc3Bvc2VyID0gX3doZW4ocHJlZGljYXRlLCByZXNvbHZlLCBfZXh0ZW5kcyh7fSwgb3B0cywge1xuICAgICAgb25FcnJvcjogcmVqZWN0XG4gICAgfSkpO1xuXG4gICAgY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgZGlzcG9zZXIoKTtcbiAgICAgIHJlamVjdChcIldIRU5fQ0FOQ0VMTEVEXCIpO1xuICAgIH07XG4gIH0pO1xuICByZXMuY2FuY2VsID0gY2FuY2VsO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBnZXRBZG0odGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRbJG1vYnhdO1xufSAvLyBPcHRpbWl6YXRpb246IHdlIGRvbid0IG5lZWQgdGhlIGludGVybWVkaWF0ZSBvYmplY3RzIGFuZCBjb3VsZCBoYXZlIGEgY29tcGxldGVseSBjdXN0b20gYWRtaW5pc3RyYXRpb24gZm9yIER5bmFtaWNPYmplY3RzLFxuLy8gYW5kIHNraXAgZWl0aGVyIHRoZSBpbnRlcm5hbCB2YWx1ZXMgbWFwLCBvciB0aGUgYmFzZSBvYmplY3Qgd2l0aCBpdHMgcHJvcGVydHkgZGVzY3JpcHRvcnMhXG5cblxudmFyIG9iamVjdFByb3h5VHJhcHMgPSB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgbmFtZSkge1xuICAgIGlmICggZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiZGV0ZWN0IG5ldyBwcm9wZXJ0aWVzIHVzaW5nIHRoZSAnaW4nIG9wZXJhdG9yLiBVc2UgJ2hhcycgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIGdldEFkbSh0YXJnZXQpLmhhc18obmFtZSk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gZ2V0KHRhcmdldCwgbmFtZSkge1xuICAgIHJldHVybiBnZXRBZG0odGFyZ2V0KS5nZXRfKG5hbWUpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIF9nZXRBZG0kc2V0XztcblxuICAgIGlmICghaXNTdHJpbmdpc2gobmFtZSkpIHJldHVybiBmYWxzZTtcblxuICAgIGlmICggIWdldEFkbSh0YXJnZXQpLnZhbHVlc18uaGFzKG5hbWUpKSB7XG4gICAgICB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiYWRkIGEgbmV3IG9ic2VydmFibGUgcHJvcGVydHkgdGhyb3VnaCBkaXJlY3QgYXNzaWdubWVudC4gVXNlICdzZXQnIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIH0gLy8gbnVsbCAoaW50ZXJjZXB0ZWQpIC0+IHRydWUgKHN1Y2Nlc3MpXG5cblxuICAgIHJldHVybiAoX2dldEFkbSRzZXRfID0gZ2V0QWRtKHRhcmdldCkuc2V0XyhuYW1lLCB2YWx1ZSwgdHJ1ZSkpICE9IG51bGwgPyBfZ2V0QWRtJHNldF8gOiB0cnVlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBuYW1lKSB7XG4gICAgdmFyIF9nZXRBZG0kZGVsZXRlXztcblxuICAgIHtcbiAgICAgIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJkZWxldGUgcHJvcGVydGllcyBmcm9tIGFuIG9ic2VydmFibGUgb2JqZWN0LiBVc2UgJ3JlbW92ZScgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgfVxuXG4gICAgaWYgKCFpc1N0cmluZ2lzaChuYW1lKSkgcmV0dXJuIGZhbHNlOyAvLyBudWxsIChpbnRlcmNlcHRlZCkgLT4gdHJ1ZSAoc3VjY2VzcylcblxuICAgIHJldHVybiAoX2dldEFkbSRkZWxldGVfID0gZ2V0QWRtKHRhcmdldCkuZGVsZXRlXyhuYW1lLCB0cnVlKSkgIT0gbnVsbCA/IF9nZXRBZG0kZGVsZXRlXyA6IHRydWU7XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICB2YXIgX2dldEFkbSRkZWZpbmVQcm9wZXJ0O1xuXG4gICAge1xuICAgICAgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcImRlZmluZSBwcm9wZXJ0eSBvbiBhbiBvYnNlcnZhYmxlIG9iamVjdC4gVXNlICdkZWZpbmVQcm9wZXJ0eScgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgfSAvLyBudWxsIChpbnRlcmNlcHRlZCkgLT4gdHJ1ZSAoc3VjY2VzcylcblxuXG4gICAgcmV0dXJuIChfZ2V0QWRtJGRlZmluZVByb3BlcnQgPSBnZXRBZG0odGFyZ2V0KS5kZWZpbmVQcm9wZXJ0eV8obmFtZSwgZGVzY3JpcHRvcikpICE9IG51bGwgPyBfZ2V0QWRtJGRlZmluZVByb3BlcnQgOiB0cnVlO1xuICB9LFxuICBvd25LZXlzOiBmdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xuICAgIGlmICggZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiaXRlcmF0ZSBrZXlzIHRvIGRldGVjdCBhZGRlZCAvIHJlbW92ZWQgcHJvcGVydGllcy4gVXNlICdrZXlzJyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gZ2V0QWRtKHRhcmdldCkub3duS2V5c18oKTtcbiAgfSxcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCkge1xuICAgIGRpZSgxMyk7XG4gIH1cbn07XG5mdW5jdGlvbiBhc0R5bmFtaWNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucykge1xuICB2YXIgX3RhcmdldCQkbW9ieCwgX3RhcmdldCQkbW9ieCRwcm94eV87XG5cbiAgYXNzZXJ0UHJveGllcygpO1xuICB0YXJnZXQgPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKTtcbiAgcmV0dXJuIChfdGFyZ2V0JCRtb2J4JHByb3h5XyA9IChfdGFyZ2V0JCRtb2J4ID0gdGFyZ2V0WyRtb2J4XSkucHJveHlfKSAhPSBudWxsID8gX3RhcmdldCQkbW9ieCRwcm94eV8gOiBfdGFyZ2V0JCRtb2J4LnByb3h5XyA9IG5ldyBQcm94eSh0YXJnZXQsIG9iamVjdFByb3h5VHJhcHMpO1xufVxuXG5mdW5jdGlvbiBoYXNJbnRlcmNlcHRvcnMoaW50ZXJjZXB0YWJsZSkge1xuICByZXR1cm4gaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfICE9PSB1bmRlZmluZWQgJiYgaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiByZWdpc3RlckludGVyY2VwdG9yKGludGVyY2VwdGFibGUsIGhhbmRsZXIpIHtcbiAgdmFyIGludGVyY2VwdG9ycyA9IGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyB8fCAoaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfID0gW10pO1xuICBpbnRlcmNlcHRvcnMucHVzaChoYW5kbGVyKTtcbiAgcmV0dXJuIG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSBpbnRlcmNlcHRvcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkgaW50ZXJjZXB0b3JzLnNwbGljZShpZHgsIDEpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGludGVyY2VwdENoYW5nZShpbnRlcmNlcHRhYmxlLCBjaGFuZ2UpIHtcbiAgdmFyIHByZXZVID0gdW50cmFja2VkU3RhcnQoKTtcblxuICB0cnkge1xuICAgIC8vIEludGVyY2VwdG9yIGNhbiBtb2RpZnkgdGhlIGFycmF5LCBjb3B5IGl0IHRvIGF2b2lkIGNvbmN1cnJlbnQgbW9kaWZpY2F0aW9uLCBzZWUgIzE5NTBcbiAgICB2YXIgaW50ZXJjZXB0b3JzID0gW10uY29uY2F0KGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyB8fCBbXSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGludGVyY2VwdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNoYW5nZSA9IGludGVyY2VwdG9yc1tpXShjaGFuZ2UpO1xuICAgICAgaWYgKGNoYW5nZSAmJiAhY2hhbmdlLnR5cGUpIGRpZSgxNCk7XG4gICAgICBpZiAoIWNoYW5nZSkgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1bnRyYWNrZWRFbmQocHJldlUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0xpc3RlbmVycyhsaXN0ZW5hYmxlKSB7XG4gIHJldHVybiBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18ubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXIobGlzdGVuYWJsZSwgaGFuZGxlcikge1xuICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfIHx8IChsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18gPSBbXSk7XG4gIGxpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xuICByZXR1cm4gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IGxpc3RlbmVycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgIGlmIChpZHggIT09IC0xKSBsaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKGxpc3RlbmFibGUsIGNoYW5nZSkge1xuICB2YXIgcHJldlUgPSB1bnRyYWNrZWRTdGFydCgpO1xuICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfO1xuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuO1xuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0oY2hhbmdlKTtcbiAgfVxuXG4gIHVudHJhY2tlZEVuZChwcmV2VSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VPYnNlcnZhYmxlKHRhcmdldCwgYW5ub3RhdGlvbnMsIG9wdGlvbnMpIHtcbiAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpWyRtb2J4XTtcbiAgc3RhcnRCYXRjaCgpO1xuXG4gIHRyeSB7XG4gICAgdmFyIF9hbm5vdGF0aW9ucztcblxuICAgIC8vIERlZmF1bHQgdG8gZGVjb3JhdG9yc1xuICAgIChfYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucykgIT0gbnVsbCA/IF9hbm5vdGF0aW9ucyA6IGFubm90YXRpb25zID0gY29sbGVjdFN0b3JlZEFubm90YXRpb25zKHRhcmdldCk7IC8vIEFubm90YXRlXG5cbiAgICBvd25LZXlzKGFubm90YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBhZG0ubWFrZV8oa2V5LCBhbm5vdGF0aW9uc1trZXldKTtcbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBlbmRCYXRjaCgpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0gLy8gcHJvdG9ba2V5c1N5bWJvbF0gPSBuZXcgU2V0PFByb3BlcnR5S2V5PigpXG5cbnZhciBrZXlzU3ltYm9sID0gLyojX19QVVJFX18qL1N5bWJvbChcIm1vYngta2V5c1wiKTtcbmZ1bmN0aW9uIG1ha2VBdXRvT2JzZXJ2YWJsZSh0YXJnZXQsIG92ZXJyaWRlcywgb3B0aW9ucykge1xuICB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgIWlzUGxhaW5PYmplY3QoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkpKSBkaWUoXCInbWFrZUF1dG9PYnNlcnZhYmxlJyBjYW4gb25seSBiZSB1c2VkIGZvciBjbGFzc2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIHN1cGVyY2xhc3NcIik7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQpKSBkaWUoXCJtYWtlQXV0b09ic2VydmFibGUgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYmplY3RzIG5vdCBhbHJlYWR5IG1hZGUgb2JzZXJ2YWJsZVwiKTtcbiAgfSAvLyBPcHRpbWl6YXRpb246IGF2b2lkIHZpc2l0aW5nIHByb3Rvc1xuICAvLyBBc3N1bWVzIHRoYXQgYW5ub3RhdGlvbi5tYWtlXy8uZXh0ZW5kXyB3b3JrcyB0aGUgc2FtZSBmb3IgcGxhaW4gb2JqZWN0c1xuXG5cbiAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiBleHRlbmRPYnNlcnZhYmxlKHRhcmdldCwgdGFyZ2V0LCBvdmVycmlkZXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIGFkbSA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpWyRtb2J4XTsgLy8gT3B0aW1pemF0aW9uOiBjYWNoZSBrZXlzIG9uIHByb3RvXG4gIC8vIEFzc3VtZXMgbWFrZUF1dG9PYnNlcnZhYmxlIGNhbiBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBvYmplY3QgYW5kIGNhbid0IGJlIHVzZWQgaW4gc3ViY2xhc3NcblxuICBpZiAoIXRhcmdldFtrZXlzU3ltYm9sXSkge1xuICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICAgIHZhciBrZXlzID0gbmV3IFNldChbXS5jb25jYXQob3duS2V5cyh0YXJnZXQpLCBvd25LZXlzKHByb3RvKSkpO1xuICAgIGtleXNbXCJkZWxldGVcIl0oXCJjb25zdHJ1Y3RvclwiKTtcbiAgICBrZXlzW1wiZGVsZXRlXCJdKCRtb2J4KTtcbiAgICBhZGRIaWRkZW5Qcm9wKHByb3RvLCBrZXlzU3ltYm9sLCBrZXlzKTtcbiAgfVxuXG4gIHN0YXJ0QmF0Y2goKTtcblxuICB0cnkge1xuICAgIHRhcmdldFtrZXlzU3ltYm9sXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBhZG0ubWFrZV8oa2V5LCAvLyBtdXN0IHBhc3MgXCJ1bmRlZmluZWRcIiBmb3IgeyBrZXk6IHVuZGVmaW5lZCB9XG4gICAgICAhb3ZlcnJpZGVzID8gdHJ1ZSA6IGtleSBpbiBvdmVycmlkZXMgPyBvdmVycmlkZXNba2V5XSA6IHRydWUpO1xuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgU1BMSUNFID0gXCJzcGxpY2VcIjtcbnZhciBVUERBVEUgPSBcInVwZGF0ZVwiO1xudmFyIE1BWF9TUExJQ0VfU0laRSA9IDEwMDAwOyAvLyBTZWUgZS5nLiBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvaXNzdWVzLzg1OVxuXG52YXIgYXJyYXlUcmFwcyA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBuYW1lKSB7XG4gICAgdmFyIGFkbSA9IHRhcmdldFskbW9ieF07XG4gICAgaWYgKG5hbWUgPT09ICRtb2J4KSByZXR1cm4gYWRtO1xuICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSByZXR1cm4gYWRtLmdldEFycmF5TGVuZ3RoXygpO1xuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmICFpc05hTihuYW1lKSkge1xuICAgICAgcmV0dXJuIGFkbS5nZXRfKHBhcnNlSW50KG5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUHJvcChhcnJheUV4dGVuc2lvbnMsIG5hbWUpKSB7XG4gICAgICByZXR1cm4gYXJyYXlFeHRlbnNpb25zW25hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRbbmFtZV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYWRtID0gdGFyZ2V0WyRtb2J4XTtcblxuICAgIGlmIChuYW1lID09PSBcImxlbmd0aFwiKSB7XG4gICAgICBhZG0uc2V0QXJyYXlMZW5ndGhfKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIgfHwgaXNOYU4obmFtZSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBudW1lcmljIHN0cmluZ1xuICAgICAgYWRtLnNldF8ocGFyc2VJbnQobmFtZSksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKCkge1xuICAgIGRpZSgxNSk7XG4gIH1cbn07XG52YXIgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyB0aGlzIGlzIHRoZSBwcm9wIHRoYXQgZ2V0cyBwcm94aWVkLCBzbyBjYW4ndCByZXBsYWNlIGl0IVxuICBmdW5jdGlvbiBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbihuYW1lLCBlbmhhbmNlciwgb3duZWRfLCBsZWdhY3lNb2RlXykge1xuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWUgPSAgXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKSA7XG4gICAgfVxuXG4gICAgdGhpcy5vd25lZF8gPSB2b2lkIDA7XG4gICAgdGhpcy5sZWdhY3lNb2RlXyA9IHZvaWQgMDtcbiAgICB0aGlzLmF0b21fID0gdm9pZCAwO1xuICAgIHRoaXMudmFsdWVzXyA9IFtdO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgdGhpcy5lbmhhbmNlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3h5XyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RLbm93bkxlbmd0aF8gPSAwO1xuICAgIHRoaXMub3duZWRfID0gb3duZWRfO1xuICAgIHRoaXMubGVnYWN5TW9kZV8gPSBsZWdhY3lNb2RlXztcbiAgICB0aGlzLmF0b21fID0gbmV3IEF0b20obmFtZSk7XG5cbiAgICB0aGlzLmVuaGFuY2VyXyA9IGZ1bmN0aW9uIChuZXdWLCBvbGRWKSB7XG4gICAgICByZXR1cm4gZW5oYW5jZXIobmV3Viwgb2xkViwgIG5hbWUgKyBcIlsuLl1cIiApO1xuICAgIH07XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZWhhbmNlVmFsdWVfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlXyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZXNfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlc18odmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZXMubGVuZ3RoID4gMCkgcmV0dXJuIHZhbHVlcy5tYXAodGhpcy5kZWhhbmNlcik7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICBfcHJvdG8uaW50ZXJjZXB0XyA9IGZ1bmN0aW9uIGludGVyY2VwdF8oaGFuZGxlcikge1xuICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICB9O1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICBpZiAoZmlyZUltbWVkaWF0ZWx5ID09PSB2b2lkIDApIHtcbiAgICAgIGZpcmVJbW1lZGlhdGVseSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwiYXJyYXlcIixcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLmF0b21fLm5hbWVfLFxuICAgICAgICB0eXBlOiBcInNwbGljZVwiLFxuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgYWRkZWQ6IHRoaXMudmFsdWVzXy5zbGljZSgpLFxuICAgICAgICBhZGRlZENvdW50OiB0aGlzLnZhbHVlc18ubGVuZ3RoLFxuICAgICAgICByZW1vdmVkOiBbXSxcbiAgICAgICAgcmVtb3ZlZENvdW50OiAwXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XG4gIH07XG5cbiAgX3Byb3RvLmdldEFycmF5TGVuZ3RoXyA9IGZ1bmN0aW9uIGdldEFycmF5TGVuZ3RoXygpIHtcbiAgICB0aGlzLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXy5sZW5ndGg7XG4gIH07XG5cbiAgX3Byb3RvLnNldEFycmF5TGVuZ3RoXyA9IGZ1bmN0aW9uIHNldEFycmF5TGVuZ3RoXyhuZXdMZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIG5ld0xlbmd0aCAhPT0gXCJudW1iZXJcIiB8fCBuZXdMZW5ndGggPCAwKSBkaWUoXCJPdXQgb2YgcmFuZ2U6IFwiICsgbmV3TGVuZ3RoKTtcbiAgICB2YXIgY3VycmVudExlbmd0aCA9IHRoaXMudmFsdWVzXy5sZW5ndGg7XG4gICAgaWYgKG5ld0xlbmd0aCA9PT0gY3VycmVudExlbmd0aCkgcmV0dXJuO2Vsc2UgaWYgKG5ld0xlbmd0aCA+IGN1cnJlbnRMZW5ndGgpIHtcbiAgICAgIHZhciBuZXdJdGVtcyA9IG5ldyBBcnJheShuZXdMZW5ndGggLSBjdXJyZW50TGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdMZW5ndGggLSBjdXJyZW50TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3SXRlbXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICB9IC8vIE5vIEFycmF5LmZpbGwgZXZlcnl3aGVyZS4uLlxuXG5cbiAgICAgIHRoaXMuc3BsaWNlV2l0aEFycmF5XyhjdXJyZW50TGVuZ3RoLCAwLCBuZXdJdGVtcyk7XG4gICAgfSBlbHNlIHRoaXMuc3BsaWNlV2l0aEFycmF5XyhuZXdMZW5ndGgsIGN1cnJlbnRMZW5ndGggLSBuZXdMZW5ndGgpO1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVBcnJheUxlbmd0aF8gPSBmdW5jdGlvbiB1cGRhdGVBcnJheUxlbmd0aF8ob2xkTGVuZ3RoLCBkZWx0YSkge1xuICAgIGlmIChvbGRMZW5ndGggIT09IHRoaXMubGFzdEtub3duTGVuZ3RoXykgZGllKDE2KTtcbiAgICB0aGlzLmxhc3RLbm93bkxlbmd0aF8gKz0gZGVsdGE7XG4gICAgaWYgKHRoaXMubGVnYWN5TW9kZV8gJiYgZGVsdGEgPiAwKSByZXNlcnZlQXJyYXlCdWZmZXIob2xkTGVuZ3RoICsgZGVsdGEgKyAxKTtcbiAgfTtcblxuICBfcHJvdG8uc3BsaWNlV2l0aEFycmF5XyA9IGZ1bmN0aW9uIHNwbGljZVdpdGhBcnJheV8oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmF0b21fKTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy52YWx1ZXNfLmxlbmd0aDtcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgaW5kZXggPSAwO2Vsc2UgaWYgKGluZGV4ID4gbGVuZ3RoKSBpbmRleCA9IGxlbmd0aDtlbHNlIGlmIChpbmRleCA8IDApIGluZGV4ID0gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaW5kZXgpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSBkZWxldGVDb3VudCA9IGxlbmd0aCAtIGluZGV4O2Vsc2UgaWYgKGRlbGV0ZUNvdW50ID09PSB1bmRlZmluZWQgfHwgZGVsZXRlQ291bnQgPT09IG51bGwpIGRlbGV0ZUNvdW50ID0gMDtlbHNlIGRlbGV0ZUNvdW50ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGVsZXRlQ291bnQsIGxlbmd0aCAtIGluZGV4KSk7XG4gICAgaWYgKG5ld0l0ZW1zID09PSB1bmRlZmluZWQpIG5ld0l0ZW1zID0gRU1QVFlfQVJSQVk7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgdHlwZTogU1BMSUNFLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHJlbW92ZWRDb3VudDogZGVsZXRlQ291bnQsXG4gICAgICAgIGFkZGVkOiBuZXdJdGVtc1xuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIEVNUFRZX0FSUkFZO1xuICAgICAgZGVsZXRlQ291bnQgPSBjaGFuZ2UucmVtb3ZlZENvdW50O1xuICAgICAgbmV3SXRlbXMgPSBjaGFuZ2UuYWRkZWQ7XG4gICAgfVxuXG4gICAgbmV3SXRlbXMgPSBuZXdJdGVtcy5sZW5ndGggPT09IDAgPyBuZXdJdGVtcyA6IG5ld0l0ZW1zLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIF90aGlzLmVuaGFuY2VyXyh2LCB1bmRlZmluZWQpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMubGVnYWN5TW9kZV8gfHwgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgdmFyIGxlbmd0aERlbHRhID0gbmV3SXRlbXMubGVuZ3RoIC0gZGVsZXRlQ291bnQ7XG4gICAgICB0aGlzLnVwZGF0ZUFycmF5TGVuZ3RoXyhsZW5ndGgsIGxlbmd0aERlbHRhKTsgLy8gY2hlY2tzIGlmIGludGVybmFsIGFycmF5IHdhc24ndCBtb2RpZmllZFxuICAgIH1cblxuICAgIHZhciByZXMgPSB0aGlzLnNwbGljZUl0ZW1zSW50b1ZhbHVlc18oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcyk7XG4gICAgaWYgKGRlbGV0ZUNvdW50ICE9PSAwIHx8IG5ld0l0ZW1zLmxlbmd0aCAhPT0gMCkgdGhpcy5ub3RpZnlBcnJheVNwbGljZV8oaW5kZXgsIG5ld0l0ZW1zLCByZXMpO1xuICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZXNfKHJlcyk7XG4gIH07XG5cbiAgX3Byb3RvLnNwbGljZUl0ZW1zSW50b1ZhbHVlc18gPSBmdW5jdGlvbiBzcGxpY2VJdGVtc0ludG9WYWx1ZXNfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpIHtcbiAgICBpZiAobmV3SXRlbXMubGVuZ3RoIDwgTUFYX1NQTElDRV9TSVpFKSB7XG4gICAgICB2YXIgX3RoaXMkdmFsdWVzXztcblxuICAgICAgcmV0dXJuIChfdGhpcyR2YWx1ZXNfID0gdGhpcy52YWx1ZXNfKS5zcGxpY2UuYXBwbHkoX3RoaXMkdmFsdWVzXywgW2luZGV4LCBkZWxldGVDb3VudF0uY29uY2F0KG5ld0l0ZW1zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXMgPSB0aGlzLnZhbHVlc18uc2xpY2UoaW5kZXgsIGluZGV4ICsgZGVsZXRlQ291bnQpO1xuICAgICAgdmFyIG9sZEl0ZW1zID0gdGhpcy52YWx1ZXNfLnNsaWNlKGluZGV4ICsgZGVsZXRlQ291bnQpO1xuICAgICAgdGhpcy52YWx1ZXNfLmxlbmd0aCA9IGluZGV4ICsgbmV3SXRlbXMubGVuZ3RoIC0gZGVsZXRlQ291bnQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3SXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy52YWx1ZXNfW2luZGV4ICsgaV0gPSBuZXdJdGVtc1tpXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9sZEl0ZW1zLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0aGlzLnZhbHVlc19baW5kZXggKyBuZXdJdGVtcy5sZW5ndGggKyBfaV0gPSBvbGRJdGVtc1tfaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5ub3RpZnlBcnJheUNoaWxkVXBkYXRlXyA9IGZ1bmN0aW9uIG5vdGlmeUFycmF5Q2hpbGRVcGRhdGVfKGluZGV4LCBuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICB2YXIgbm90aWZ5U3B5ID0gIXRoaXMub3duZWRfICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJhcnJheVwiLFxuICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5hdG9tXy5uYW1lXyxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgIH0gOiBudWxsOyAvLyBUaGUgcmVhc29uIHdoeSB0aGlzIGlzIG9uIHJpZ2h0IGhhbmQgc2lkZSBoZXJlIChhbmQgbm90IGFib3ZlKSwgaXMgdGhpcyB3YXkgdGhlIHVnbGlmaWVyIHdpbGwgZHJvcCBpdCwgYnV0IGl0IHdvbid0XG4gICAgLy8gY2F1c2UgYW55IHJ1bnRpbWUgb3ZlcmhlYWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSB3aXRob3V0IE5PREVfRU5WIHNldCwgdW5sZXNzIHNweWluZyBpcyBlbmFibGVkXG5cbiAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICB0aGlzLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gIH07XG5cbiAgX3Byb3RvLm5vdGlmeUFycmF5U3BsaWNlXyA9IGZ1bmN0aW9uIG5vdGlmeUFycmF5U3BsaWNlXyhpbmRleCwgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICB2YXIgbm90aWZ5U3B5ID0gIXRoaXMub3duZWRfICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJhcnJheVwiLFxuICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5hdG9tXy5uYW1lXyxcbiAgICAgIHR5cGU6IFNQTElDRSxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICBhZGRlZDogYWRkZWQsXG4gICAgICByZW1vdmVkQ291bnQ6IHJlbW92ZWQubGVuZ3RoLFxuICAgICAgYWRkZWRDb3VudDogYWRkZWQubGVuZ3RoXG4gICAgfSA6IG51bGw7XG4gICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRDaGFuZ2VkKCk7IC8vIGNvbmZvcm06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L29ic2VydmVcblxuICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRFbmQoKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0XyA9IGZ1bmN0aW9uIGdldF8oaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCB0aGlzLnZhbHVlc18ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVfKHRoaXMudmFsdWVzX1tpbmRleF0pO1xuICAgIH1cblxuICAgIGNvbnNvbGUud2FybiggXCJbbW9ieF0gT3V0IG9mIGJvdW5kcyByZWFkOiBcIiArIGluZGV4ICk7XG4gIH07XG5cbiAgX3Byb3RvLnNldF8gPSBmdW5jdGlvbiBzZXRfKGluZGV4LCBuZXdWYWx1ZSkge1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlc187XG5cbiAgICBpZiAoaW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAvLyB1cGRhdGUgYXQgaW5kZXggaW4gcmFuZ2VcbiAgICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMuYXRvbV8pO1xuICAgICAgdmFyIG9sZFZhbHVlID0gdmFsdWVzW2luZGV4XTtcblxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyxcbiAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuO1xuICAgICAgICBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgbmV3VmFsdWUgPSB0aGlzLmVuaGFuY2VyXyhuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgdmFyIGNoYW5nZWQgPSBuZXdWYWx1ZSAhPT0gb2xkVmFsdWU7XG5cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5ub3RpZnlBcnJheUNoaWxkVXBkYXRlXyhpbmRleCwgbmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAvLyBhZGQgYSBuZXcgaXRlbVxuICAgICAgdGhpcy5zcGxpY2VXaXRoQXJyYXlfKGluZGV4LCAwLCBbbmV3VmFsdWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3V0IG9mIGJvdW5kc1xuICAgICAgZGllKDE3LCBpbmRleCwgdmFsdWVzLmxlbmd0aCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbjtcbn0oKTtcbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmFibGVBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSwgb3duZWQpIHtcbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIG5hbWUgPSAgXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKSA7XG4gIH1cblxuICBpZiAob3duZWQgPT09IHZvaWQgMCkge1xuICAgIG93bmVkID0gZmFsc2U7XG4gIH1cblxuICBhc3NlcnRQcm94aWVzKCk7XG4gIHZhciBhZG0gPSBuZXcgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24obmFtZSwgZW5oYW5jZXIsIG93bmVkLCBmYWxzZSk7XG4gIGFkZEhpZGRlbkZpbmFsUHJvcChhZG0udmFsdWVzXywgJG1vYngsIGFkbSk7XG4gIHZhciBwcm94eSA9IG5ldyBQcm94eShhZG0udmFsdWVzXywgYXJyYXlUcmFwcyk7XG4gIGFkbS5wcm94eV8gPSBwcm94eTtcblxuICBpZiAoaW5pdGlhbFZhbHVlcyAmJiBpbml0aWFsVmFsdWVzLmxlbmd0aCkge1xuICAgIHZhciBwcmV2ID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydCh0cnVlKTtcbiAgICBhZG0uc3BsaWNlV2l0aEFycmF5XygwLCAwLCBpbml0aWFsVmFsdWVzKTtcbiAgICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KTtcbiAgfVxuXG4gIHJldHVybiBwcm94eTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbnZhciBhcnJheUV4dGVuc2lvbnMgPSB7XG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoMCk7XG4gIH0sXG4gIHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2UobmV3SXRlbXMpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgcmV0dXJuIGFkbS5zcGxpY2VXaXRoQXJyYXlfKDAsIGFkbS52YWx1ZXNfLmxlbmd0aCwgbmV3SXRlbXMpO1xuICB9LFxuICAvLyBVc2VkIGJ5IEpTT04uc3RyaW5naWZ5XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKCk7XG4gIH0sXG5cbiAgLypcclxuICAgKiBmdW5jdGlvbnMgdGhhdCBkbyBhbHRlciB0aGUgaW50ZXJuYWwgc3RydWN0dXJlIG9mIHRoZSBhcnJheSwgKGJhc2VkIG9uIGxpYi5lczYuZC50cylcclxuICAgKiBzaW5jZSB0aGVzZSBmdW5jdGlvbnMgYWx0ZXIgdGhlIGlubmVyIHN0cnVjdHVyZSBvZiB0aGUgYXJyYXksIHRoZSBoYXZlIHNpZGUgZWZmZWN0cy5cclxuICAgKiBCZWNhdXNlIHRoZSBoYXZlIHNpZGUgZWZmZWN0cywgdGhleSBzaG91bGQgbm90IGJlIHVzZWQgaW4gY29tcHV0ZWQgZnVuY3Rpb24sXHJcbiAgICogYW5kIGZvciB0aGF0IHJlYXNvbiB0aGUgZG8gbm90IGNhbGwgZGVwZW5kZW5jeVN0YXRlLm5vdGlmeU9ic2VydmVkXHJcbiAgICovXG4gIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKGluZGV4LCBkZWxldGVDb3VudCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBuZXdJdGVtcyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBuZXdJdGVtc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuXG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbXTtcblxuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gYWRtLnNwbGljZVdpdGhBcnJheV8oaW5kZXgpO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBhZG0uc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgZGVsZXRlQ291bnQpO1xuICAgIH1cblxuICAgIHJldHVybiBhZG0uc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKTtcbiAgfSxcbiAgc3BsaWNlV2l0aEFycmF5OiBmdW5jdGlvbiBzcGxpY2VXaXRoQXJyYXkoaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcykge1xuICAgIHJldHVybiB0aGlzWyRtb2J4XS5zcGxpY2VXaXRoQXJyYXlfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpO1xuICB9LFxuICBwdXNoOiBmdW5jdGlvbiBwdXNoKCkge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGl0ZW1zW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgYWRtLnNwbGljZVdpdGhBcnJheV8oYWRtLnZhbHVlc18ubGVuZ3RoLCAwLCBpdGVtcyk7XG4gICAgcmV0dXJuIGFkbS52YWx1ZXNfLmxlbmd0aDtcbiAgfSxcbiAgcG9wOiBmdW5jdGlvbiBwb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKE1hdGgubWF4KHRoaXNbJG1vYnhdLnZhbHVlc18ubGVuZ3RoIC0gMSwgMCksIDEpWzBdO1xuICB9LFxuICBzaGlmdDogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKDAsIDEpWzBdO1xuICB9LFxuICB1bnNoaWZ0OiBmdW5jdGlvbiB1bnNoaWZ0KCkge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcblxuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGl0ZW1zW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuXG4gICAgYWRtLnNwbGljZVdpdGhBcnJheV8oMCwgMCwgaXRlbXMpO1xuICAgIHJldHVybiBhZG0udmFsdWVzXy5sZW5ndGg7XG4gIH0sXG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgLy8gcmV2ZXJzZSBieSBkZWZhdWx0IG11dGF0ZXMgaW4gcGxhY2UgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0XG4gICAgLy8gd2hpY2ggbWFrZXMgaXQgYm90aCBhICdkZXJpdmF0aW9uJyBhbmQgYSAnbXV0YXRpb24nLlxuICAgIGlmIChnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIGRpZSgzNywgXCJyZXZlcnNlXCIpO1xuICAgIH1cblxuICAgIHRoaXMucmVwbGFjZSh0aGlzLnNsaWNlKCkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc29ydDogZnVuY3Rpb24gc29ydCgpIHtcbiAgICAvLyBzb3J0IGJ5IGRlZmF1bHQgbXV0YXRlcyBpbiBwbGFjZSBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHRcbiAgICAvLyB3aGljaCBnb2VzIGFnYWluc3QgYWxsIGdvb2QgcHJhY3RpY2VzLiBMZXQncyBub3QgY2hhbmdlIHRoZSBhcnJheSBpbiBwbGFjZSFcbiAgICBpZiAoZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB7XG4gICAgICBkaWUoMzcsIFwic29ydFwiKTtcbiAgICB9XG5cbiAgICB2YXIgY29weSA9IHRoaXMuc2xpY2UoKTtcbiAgICBjb3B5LnNvcnQuYXBwbHkoY29weSwgYXJndW1lbnRzKTtcbiAgICB0aGlzLnJlcGxhY2UoY29weSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKHZhbHVlKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIHZhciBpZHggPSBhZG0uZGVoYW5jZVZhbHVlc18oYWRtLnZhbHVlc18pLmluZGV4T2YodmFsdWUpO1xuXG4gICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICB0aGlzLnNwbGljZShpZHgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuLyoqXHJcbiAqIFdyYXAgZnVuY3Rpb24gZnJvbSBwcm90b3R5cGVcclxuICogV2l0aG91dCB0aGlzLCBldmVyeXRoaW5nIHdvcmtzIGFzIHdlbGwsIGJ1dCB0aGlzIHdvcmtzXHJcbiAqIGZhc3RlciBhcyBldmVyeXRoaW5nIHdvcmtzIG9uIHVucHJveGllZCB2YWx1ZXNcclxuICovXG5cbmFkZEFycmF5RXh0ZW5zaW9uKFwiY29uY2F0XCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmbGF0XCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJpbmNsdWRlc1wiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiaW5kZXhPZlwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiam9pblwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwibGFzdEluZGV4T2ZcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInNsaWNlXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJ0b1N0cmluZ1wiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwidG9Mb2NhbGVTdHJpbmdcIiwgc2ltcGxlRnVuYyk7IC8vIG1hcFxuXG5hZGRBcnJheUV4dGVuc2lvbihcImV2ZXJ5XCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmlsdGVyXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmluZFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZpbmRJbmRleFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZsYXRNYXBcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmb3JFYWNoXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwibWFwXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwic29tZVwiLCBtYXBMaWtlRnVuYyk7IC8vIHJlZHVjZVxuXG5hZGRBcnJheUV4dGVuc2lvbihcInJlZHVjZVwiLCByZWR1Y2VMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInJlZHVjZVJpZ2h0XCIsIHJlZHVjZUxpa2VGdW5jKTtcblxuZnVuY3Rpb24gYWRkQXJyYXlFeHRlbnNpb24oZnVuY05hbWUsIGZ1bmNGYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlW2Z1bmNOYW1lXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgYXJyYXlFeHRlbnNpb25zW2Z1bmNOYW1lXSA9IGZ1bmNGYWN0b3J5KGZ1bmNOYW1lKTtcbiAgfVxufSAvLyBSZXBvcnQgYW5kIGRlbGVnYXRlIHRvIGRlaGFuY2VkIGFycmF5XG5cblxuZnVuY3Rpb24gc2ltcGxlRnVuYyhmdW5jTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICBhZG0uYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICB2YXIgZGVoYW5jZWRWYWx1ZXMgPSBhZG0uZGVoYW5jZVZhbHVlc18oYWRtLnZhbHVlc18pO1xuICAgIHJldHVybiBkZWhhbmNlZFZhbHVlc1tmdW5jTmFtZV0uYXBwbHkoZGVoYW5jZWRWYWx1ZXMsIGFyZ3VtZW50cyk7XG4gIH07XG59IC8vIE1ha2Ugc3VyZSBjYWxsYmFja3MgcmVjaWV2ZSBjb3JyZWN0IGFycmF5IGFyZyAjMjMyNlxuXG5cbmZ1bmN0aW9uIG1hcExpa2VGdW5jKGZ1bmNOYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICBhZG0uYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICB2YXIgZGVoYW5jZWRWYWx1ZXMgPSBhZG0uZGVoYW5jZVZhbHVlc18oYWRtLnZhbHVlc18pO1xuICAgIHJldHVybiBkZWhhbmNlZFZhbHVlc1tmdW5jTmFtZV0oZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBlbGVtZW50LCBpbmRleCwgX3RoaXMyKTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gTWFrZSBzdXJlIGNhbGxiYWNrcyByZWNpZXZlIGNvcnJlY3QgYXJyYXkgYXJnICMyMzI2XG5cblxuZnVuY3Rpb24gcmVkdWNlTGlrZUZ1bmMoZnVuY05hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICBhZG0uYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICB2YXIgZGVoYW5jZWRWYWx1ZXMgPSBhZG0uZGVoYW5jZVZhbHVlc18oYWRtLnZhbHVlc18pOyAvLyAjMjQzMiAtIHJlZHVjZSBiZWhhdmlvciBkZXBlbmRzIG9uIGFyZ3VtZW50cy5sZW5ndGhcblxuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcblxuICAgIGFyZ3VtZW50c1swXSA9IGZ1bmN0aW9uIChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUsIGluZGV4LCBfdGhpczMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVoYW5jZWRWYWx1ZXNbZnVuY05hbWVdLmFwcGx5KGRlaGFuY2VkVmFsdWVzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgaXNPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb25cIiwgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24pO1xuZnVuY3Rpb24gaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHRoaW5nKSAmJiBpc09ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKHRoaW5nWyRtb2J4XSk7XG59XG5cbnZhciBfU3ltYm9sJGl0ZXJhdG9yLCBfU3ltYm9sJHRvU3RyaW5nVGFnO1xudmFyIE9ic2VydmFibGVNYXBNYXJrZXIgPSB7fTtcbnZhciBBREQgPSBcImFkZFwiO1xudmFyIERFTEVURSA9IFwiZGVsZXRlXCI7IC8vIGp1c3QgZXh0ZW5kIE1hcD8gU2VlIGFsc28gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbmVzdGhhcnVzLzEzYjRkNzRmMmVmNGEyZjQzNTdkYmQzZmMyM2MxZTU0XG4vLyBCdXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvMTU1NlxuXG5fU3ltYm9sJGl0ZXJhdG9yID0gU3ltYm9sLml0ZXJhdG9yO1xuX1N5bWJvbCR0b1N0cmluZ1RhZyA9IFN5bWJvbC50b1N0cmluZ1RhZztcbnZhciBPYnNlcnZhYmxlTWFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gaGFzTWFwLCBub3QgaGFzaE1hcCA+LSkuXG4gIGZ1bmN0aW9uIE9ic2VydmFibGVNYXAoaW5pdGlhbERhdGEsIGVuaGFuY2VyXywgbmFtZV8pIHtcbiAgICBpZiAoZW5oYW5jZXJfID09PSB2b2lkIDApIHtcbiAgICAgIGVuaGFuY2VyXyA9IGRlZXBFbmhhbmNlcjtcbiAgICB9XG5cbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSAgXCJPYnNlcnZhYmxlTWFwQFwiICsgZ2V0TmV4dElkKCkgO1xuICAgIH1cblxuICAgIHRoaXMuZW5oYW5jZXJfID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpc1skbW9ieF0gPSBPYnNlcnZhYmxlTWFwTWFya2VyO1xuICAgIHRoaXMuZGF0YV8gPSB2b2lkIDA7XG4gICAgdGhpcy5oYXNNYXBfID0gdm9pZCAwO1xuICAgIHRoaXMua2V5c0F0b21fID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICB0aGlzLmVuaGFuY2VyXyA9IGVuaGFuY2VyXztcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24oTWFwKSkge1xuICAgICAgZGllKDE4KTtcbiAgICB9XG5cbiAgICB0aGlzLmtleXNBdG9tXyA9IGNyZWF0ZUF0b20oIHRoaXMubmFtZV8gKyBcIi5rZXlzKClcIiApO1xuICAgIHRoaXMuZGF0YV8gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5oYXNNYXBfID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubWVyZ2UoaW5pdGlhbERhdGEpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVNYXAucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYXNfID0gZnVuY3Rpb24gaGFzXyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhXy5oYXMoa2V5KTtcbiAgfTtcblxuICBfcHJvdG8uaGFzID0gZnVuY3Rpb24gaGFzKGtleSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIWdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikgcmV0dXJuIHRoaXMuaGFzXyhrZXkpO1xuICAgIHZhciBlbnRyeSA9IHRoaXMuaGFzTWFwXy5nZXQoa2V5KTtcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHZhciBuZXdFbnRyeSA9IGVudHJ5ID0gbmV3IE9ic2VydmFibGVWYWx1ZSh0aGlzLmhhc18oa2V5KSwgcmVmZXJlbmNlRW5oYW5jZXIsICB0aGlzLm5hbWVfICsgXCIuXCIgKyBzdHJpbmdpZnlLZXkoa2V5KSArIFwiP1wiICwgZmFsc2UpO1xuICAgICAgdGhpcy5oYXNNYXBfLnNldChrZXksIG5ld0VudHJ5KTtcbiAgICAgIG9uQmVjb21lVW5vYnNlcnZlZChuZXdFbnRyeSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuaGFzTWFwX1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5LmdldCgpO1xuICB9O1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBoYXNLZXkgPSB0aGlzLmhhc18oa2V5KTtcblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBoYXNLZXkgPyBVUERBVEUgOiBBREQsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgbmV3VmFsdWU6IHZhbHVlLFxuICAgICAgICBuYW1lOiBrZXlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiB0aGlzO1xuICAgICAgdmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGhhc0tleSkge1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkVmFsdWVfKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90b1tcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmtleXNBdG9tXyk7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogREVMRVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5hbWU6IGtleVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc18oa2V5KSkge1xuICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcblxuICAgICAgdmFyIF9jaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJtYXBcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICB0eXBlOiBERUxFVEUsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgb2xkVmFsdWU6IHRoaXMuZGF0YV8uZ2V0KGtleSkudmFsdWVfLFxuICAgICAgICBuYW1lOiBrZXlcbiAgICAgIH0gOiBudWxsO1xuXG4gICAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZSk7XG4gICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuXG4gICAgICAgIF90aGlzMi51cGRhdGVIYXNNYXBFbnRyeV8oa2V5LCBmYWxzZSk7XG5cbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBfdGhpczIuZGF0YV8uZ2V0KGtleSk7XG5cbiAgICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8odW5kZWZpbmVkKTtcblxuICAgICAgICBfdGhpczIuZGF0YV9bXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UpO1xuICAgICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVIYXNNYXBFbnRyeV8gPSBmdW5jdGlvbiB1cGRhdGVIYXNNYXBFbnRyeV8oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuaGFzTWFwXy5nZXQoa2V5KTtcblxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkuc2V0TmV3VmFsdWVfKHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZVZhbHVlXyA9IGZ1bmN0aW9uIHVwZGF0ZVZhbHVlXyhrZXksIG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLmRhdGFfLmdldChrZXkpO1xuICAgIG5ld1ZhbHVlID0gb2JzZXJ2YWJsZS5wcmVwYXJlTmV3VmFsdWVfKG5ld1ZhbHVlKTtcblxuICAgIGlmIChuZXdWYWx1ZSAhPT0gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEKSB7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gaXNTcHlFbmFibGVkKCk7XG4gICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm1hcFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogb2JzZXJ2YWJsZS52YWx1ZV8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9IDogbnVsbDtcbiAgICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hZGRWYWx1ZV8gPSBmdW5jdGlvbiBhZGRWYWx1ZV8oa2V5LCBuZXdWYWx1ZSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5rZXlzQXRvbV8pO1xuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVWYWx1ZShuZXdWYWx1ZSwgX3RoaXMzLmVuaGFuY2VyXywgIF90aGlzMy5uYW1lXyArIFwiLlwiICsgc3RyaW5naWZ5S2V5KGtleSkgLCBmYWxzZSk7XG5cbiAgICAgIF90aGlzMy5kYXRhXy5zZXQoa2V5LCBvYnNlcnZhYmxlKTtcblxuICAgICAgbmV3VmFsdWUgPSBvYnNlcnZhYmxlLnZhbHVlXzsgLy8gdmFsdWUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWRcblxuICAgICAgX3RoaXMzLnVwZGF0ZUhhc01hcEVudHJ5XyhrZXksIHRydWUpO1xuXG4gICAgICBfdGhpczMua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICB9KTtcbiAgICB2YXIgbm90aWZ5U3B5ID0gaXNTcHlFbmFibGVkKCk7XG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgIG9ic2VydmFibGVLaW5kOiBcIm1hcFwiLFxuICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgdHlwZTogQURELFxuICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgbmFtZToga2V5LFxuICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgfSA6IG51bGw7XG4gICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKHRoaXMuaGFzKGtleSkpIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZV8odGhpcy5kYXRhXy5nZXQoa2V5KS5nZXQoKSk7XG4gICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlXyh1bmRlZmluZWQpO1xuICB9O1xuXG4gIF9wcm90by5kZWhhbmNlVmFsdWVfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlXyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmtleXMgPSBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YV8ua2V5cygpO1xuICB9O1xuXG4gIF9wcm90by52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBrZXlzID0gdGhpcy5rZXlzKCk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgX2tleXMkbmV4dCA9IGtleXMubmV4dCgpLFxuICAgICAgICAgICAgZG9uZSA9IF9rZXlzJG5leHQuZG9uZSxcbiAgICAgICAgICAgIHZhbHVlID0gX2tleXMkbmV4dC52YWx1ZTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGRvbmUsXG4gICAgICAgICAgdmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiBzZWxmLmdldCh2YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBrZXlzID0gdGhpcy5rZXlzKCk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgX2tleXMkbmV4dDIgPSBrZXlzLm5leHQoKSxcbiAgICAgICAgICAgIGRvbmUgPSBfa2V5cyRuZXh0Mi5kb25lLFxuICAgICAgICAgICAgdmFsdWUgPSBfa2V5cyRuZXh0Mi52YWx1ZTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGRvbmUsXG4gICAgICAgICAgdmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiBbdmFsdWUsIHNlbGYuZ2V0KHZhbHVlKV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG9bX1N5bWJvbCRpdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICB9O1xuXG4gIF9wcm90by5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodGhpcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc3RlcC52YWx1ZSxcbiAgICAgICAgICBrZXkgPSBfc3RlcCR2YWx1ZVswXSxcbiAgICAgICAgICB2YWx1ZSA9IF9zdGVwJHZhbHVlWzFdO1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwga2V5LCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqIE1lcmdlIGFub3RoZXIgb2JqZWN0IGludG8gdGhpcyBvYmplY3QsIHJldHVybnMgdGhpcy4gKi9cbiAgO1xuXG4gIF9wcm90by5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlKG90aGVyKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKG90aGVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgTWFwKG90aGVyKTtcbiAgICB9XG5cbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChvdGhlcikpIGdldFBsYWluT2JqZWN0S2V5cyhvdGhlcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuc2V0KGtleSwgb3RoZXJba2V5XSk7XG4gICAgICB9KTtlbHNlIGlmIChBcnJheS5pc0FycmF5KG90aGVyKSkgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIga2V5ID0gX3JlZlswXSxcbiAgICAgICAgICAgIHZhbHVlID0gX3JlZlsxXTtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtlbHNlIGlmIChpc0VTNk1hcChvdGhlcikpIHtcbiAgICAgICAgaWYgKG90aGVyLmNvbnN0cnVjdG9yICE9PSBNYXApIGRpZSgxOSwgb3RoZXIpO1xuICAgICAgICBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvdGhlciAhPT0gbnVsbCAmJiBvdGhlciAhPT0gdW5kZWZpbmVkKSBkaWUoMjAsIG90aGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKF90aGlzNS5rZXlzKCkpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICBfdGhpczVbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHZhbHVlcykge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgLy8gSW1wbGVtZW50YXRpb24gcmVxdWlyZW1lbnRzOlxuICAgIC8vIC0gcmVzcGVjdCBvcmRlcmluZyBvZiByZXBsYWNlbWVudCBtYXBcbiAgICAvLyAtIGFsbG93IGludGVyY2VwdG9ycyB0byBydW4gYW5kIHBvdGVudGlhbGx5IHByZXZlbnQgaW5kaXZpZHVhbCBvcGVyYXRpb25zXG4gICAgLy8gLSBkb24ndCByZWNyZWF0ZSBvYnNlcnZhYmxlcyB0aGF0IGFscmVhZHkgZXhpc3QgaW4gb3JpZ2luYWwgbWFwIChzbyB3ZSBkb24ndCBkZXN0cm95IGV4aXN0aW5nIHN1YnNjcmlwdGlvbnMpXG4gICAgLy8gLSBkb24ndCBfa2V5c0F0b20ucmVwb3J0Q2hhbmdlZCBpZiB0aGUga2V5cyBvZiByZXN1bHRpbmcgbWFwIGFyZSBpbmRlbnRpY2FsIChvcmRlciBtYXR0ZXJzISlcbiAgICAvLyAtIG5vdGUgdGhhdCByZXN1bHQgbWFwIG1heSBkaWZmZXIgZnJvbSByZXBsYWNlbWVudCBtYXAgZHVlIHRvIHRoZSBpbnRlcmNlcHRvcnNcbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDb252ZXJ0IHRvIG1hcCBzbyB3ZSBjYW4gZG8gcXVpY2sga2V5IGxvb2t1cHNcbiAgICAgIHZhciByZXBsYWNlbWVudE1hcCA9IGNvbnZlcnRUb01hcCh2YWx1ZXMpO1xuICAgICAgdmFyIG9yZGVyZWREYXRhID0gbmV3IE1hcCgpOyAvLyBVc2VkIGZvciBvcHRpbWl6YXRpb25cblxuICAgICAgdmFyIGtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkID0gZmFsc2U7IC8vIERlbGV0ZSBrZXlzIHRoYXQgZG9uJ3QgZXhpc3QgaW4gcmVwbGFjZW1lbnQgbWFwXG4gICAgICAvLyBpZiB0aGUga2V5IGRlbGV0aW9uIGlzIHByZXZlbnRlZCBieSBpbnRlcmNlcHRvclxuICAgICAgLy8gYWRkIGVudHJ5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlc3VsdCBtYXBcblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoX3RoaXM2LmRhdGFfLmtleXMoKSksIF9zdGVwMzsgIShfc3RlcDMgPSBfaXRlcmF0b3IzKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBrZXkgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgLy8gQ29uY3VycmVudGx5IGl0ZXJhdGluZy9kZWxldGluZyBrZXlzXG4gICAgICAgIC8vIGl0ZXJhdG9yIHNob3VsZCBoYW5kbGUgdGhpcyBjb3JyZWN0bHlcbiAgICAgICAgaWYgKCFyZXBsYWNlbWVudE1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgIHZhciBkZWxldGVkID0gX3RoaXM2W1wiZGVsZXRlXCJdKGtleSk7IC8vIFdhcyB0aGUga2V5IHJlbW92ZWQ/XG5cblxuICAgICAgICAgIGlmIChkZWxldGVkKSB7XG4gICAgICAgICAgICAvLyBfa2V5c0F0b20ucmVwb3J0Q2hhbmdlZCgpIHdhcyBhbHJlYWR5IGNhbGxlZFxuICAgICAgICAgICAga2V5c1JlcG9ydENoYW5nZWRDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWxldGUgcHJldmVudGVkIGJ5IGludGVyY2VwdG9yXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpczYuZGF0YV8uZ2V0KGtleSk7XG5cbiAgICAgICAgICAgIG9yZGVyZWREYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gTWVyZ2UgZW50cmllc1xuXG5cbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHJlcGxhY2VtZW50TWFwLmVudHJpZXMoKSksIF9zdGVwNDsgIShfc3RlcDQgPSBfaXRlcmF0b3I0KCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDQkdmFsdWUgPSBfc3RlcDQudmFsdWUsXG4gICAgICAgICAgICBfa2V5ID0gX3N0ZXA0JHZhbHVlWzBdLFxuICAgICAgICAgICAgX3ZhbHVlID0gX3N0ZXA0JHZhbHVlWzFdO1xuXG4gICAgICAgIC8vIFdlIHdpbGwgd2FudCB0byBrbm93IHdoZXRoZXIgYSBuZXcga2V5IGlzIGFkZGVkXG4gICAgICAgIHZhciBrZXlFeGlzdGVkID0gX3RoaXM2LmRhdGFfLmhhcyhfa2V5KTsgLy8gQWRkIG9yIHVwZGF0ZSB2YWx1ZVxuXG5cbiAgICAgICAgX3RoaXM2LnNldChfa2V5LCBfdmFsdWUpOyAvLyBUaGUgYWRkaXRpb24gY291bGQgaGF2ZSBiZWVuIHByZXZlbnQgYnkgaW50ZXJjZXB0b3JcblxuXG4gICAgICAgIGlmIChfdGhpczYuZGF0YV8uaGFzKF9rZXkpKSB7XG4gICAgICAgICAgLy8gVGhlIHVwZGF0ZSBjb3VsZCBoYXZlIGJlZW4gcHJldmVudGVkIGJ5IGludGVyY2VwdG9yXG4gICAgICAgICAgLy8gYW5kIGFsc28gd2Ugd2FudCB0byBwcmVzZXJ2ZSBleGlzdGluZyB2YWx1ZXNcbiAgICAgICAgICAvLyBzbyB1c2UgdmFsdWUgZnJvbSBfZGF0YSBtYXAgKGluc3RlYWQgb2YgcmVwbGFjZW1lbnQgbWFwKVxuICAgICAgICAgIHZhciBfdmFsdWUyID0gX3RoaXM2LmRhdGFfLmdldChfa2V5KTtcblxuICAgICAgICAgIG9yZGVyZWREYXRhLnNldChfa2V5LCBfdmFsdWUyKTsgLy8gV2FzIGEgbmV3IGtleSBhZGRlZD9cblxuICAgICAgICAgIGlmICgha2V5RXhpc3RlZCkge1xuICAgICAgICAgICAgLy8gX2tleXNBdG9tLnJlcG9ydENoYW5nZWQoKSB3YXMgYWxyZWFkeSBjYWxsZWRcbiAgICAgICAgICAgIGtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ2hlY2sgZm9yIHBvc3NpYmxlIGtleSBvcmRlciBjaGFuZ2VcblxuXG4gICAgICBpZiAoIWtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkKSB7XG4gICAgICAgIGlmIChfdGhpczYuZGF0YV8uc2l6ZSAhPT0gb3JkZXJlZERhdGEuc2l6ZSkge1xuICAgICAgICAgIC8vIElmIHNpemUgZGlmZmVycywga2V5cyBhcmUgZGVmaW5pdGVseSBtb2RpZmllZFxuICAgICAgICAgIF90aGlzNi5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpdGVyMSA9IF90aGlzNi5kYXRhXy5rZXlzKCk7XG5cbiAgICAgICAgICB2YXIgaXRlcjIgPSBvcmRlcmVkRGF0YS5rZXlzKCk7XG4gICAgICAgICAgdmFyIG5leHQxID0gaXRlcjEubmV4dCgpO1xuICAgICAgICAgIHZhciBuZXh0MiA9IGl0ZXIyLm5leHQoKTtcblxuICAgICAgICAgIHdoaWxlICghbmV4dDEuZG9uZSkge1xuICAgICAgICAgICAgaWYgKG5leHQxLnZhbHVlICE9PSBuZXh0Mi52YWx1ZSkge1xuICAgICAgICAgICAgICBfdGhpczYua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV4dDEgPSBpdGVyMS5uZXh0KCk7XG4gICAgICAgICAgICBuZXh0MiA9IGl0ZXIyLm5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVXNlIGNvcnJlY3RseSBvcmRlcmVkIG1hcFxuXG5cbiAgICAgIF90aGlzNi5kYXRhXyA9IG9yZGVyZWREYXRhO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgT2JzZXJ2YWJsZU1hcF1cIjtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxyXG4gICAqIE9ic2VydmVzIHRoaXMgb2JqZWN0LiBUcmlnZ2VycyBmb3IgdGhlIGV2ZW50cyAnYWRkJywgJ3VwZGF0ZScgYW5kICdkZWxldGUnLlxyXG4gICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L29ic2VydmVcclxuICAgKiBmb3IgY2FsbGJhY2sgZGV0YWlsc1xyXG4gICAqL1xuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgaWYgKCBmaXJlSW1tZWRpYXRlbHkgPT09IHRydWUpIGRpZShcImBvYnNlcnZlYCBkb2Vzbid0IHN1cHBvcnQgZmlyZUltbWVkaWF0ZWx5PXRydWUgaW4gY29tYmluYXRpb24gd2l0aCBtYXBzLlwiKTtcbiAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XG4gIH07XG5cbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoT2JzZXJ2YWJsZU1hcCwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFwiTWFwXCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9ic2VydmFibGVNYXA7XG59KCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG52YXIgaXNPYnNlcnZhYmxlTWFwID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlTWFwXCIsIE9ic2VydmFibGVNYXApO1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9NYXAoZGF0YVN0cnVjdHVyZSkge1xuICBpZiAoaXNFUzZNYXAoZGF0YVN0cnVjdHVyZSkgfHwgaXNPYnNlcnZhYmxlTWFwKGRhdGFTdHJ1Y3R1cmUpKSB7XG4gICAgcmV0dXJuIGRhdGFTdHJ1Y3R1cmU7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhU3RydWN0dXJlKSkge1xuICAgIHJldHVybiBuZXcgTWFwKGRhdGFTdHJ1Y3R1cmUpO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoZGF0YVN0cnVjdHVyZSkpIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGRhdGFTdHJ1Y3R1cmUpIHtcbiAgICAgIG1hcC5zZXQoa2V5LCBkYXRhU3RydWN0dXJlW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpZSgyMSwgZGF0YVN0cnVjdHVyZSk7XG4gIH1cbn1cblxudmFyIF9TeW1ib2wkaXRlcmF0b3IkMSwgX1N5bWJvbCR0b1N0cmluZ1RhZyQxO1xudmFyIE9ic2VydmFibGVTZXRNYXJrZXIgPSB7fTtcbl9TeW1ib2wkaXRlcmF0b3IkMSA9IFN5bWJvbC5pdGVyYXRvcjtcbl9TeW1ib2wkdG9TdHJpbmdUYWckMSA9IFN5bWJvbC50b1N0cmluZ1RhZztcbnZhciBPYnNlcnZhYmxlU2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZVNldChpbml0aWFsRGF0YSwgZW5oYW5jZXIsIG5hbWVfKSB7XG4gICAgaWYgKGVuaGFuY2VyID09PSB2b2lkIDApIHtcbiAgICAgIGVuaGFuY2VyID0gZGVlcEVuaGFuY2VyO1xuICAgIH1cblxuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9ICBcIk9ic2VydmFibGVTZXRAXCIgKyBnZXROZXh0SWQoKSA7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzWyRtb2J4XSA9IE9ic2VydmFibGVTZXRNYXJrZXI7XG4gICAgdGhpcy5kYXRhXyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmF0b21fID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICB0aGlzLmVuaGFuY2VyXyA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24oU2V0KSkge1xuICAgICAgZGllKDIyKTtcbiAgICB9XG5cbiAgICB0aGlzLmF0b21fID0gY3JlYXRlQXRvbSh0aGlzLm5hbWVfKTtcblxuICAgIHRoaXMuZW5oYW5jZXJfID0gZnVuY3Rpb24gKG5ld1YsIG9sZFYpIHtcbiAgICAgIHJldHVybiBlbmhhbmNlcihuZXdWLCBvbGRWLCBuYW1lXyk7XG4gICAgfTtcblxuICAgIGlmIChpbml0aWFsRGF0YSkge1xuICAgICAgdGhpcy5yZXBsYWNlKGluaXRpYWxEYXRhKTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZVNldC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZV8gPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWVfKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgdW50cmFja2VkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShfdGhpcy5kYXRhXy52YWx1ZXMoKSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBfdGhpc1tcImRlbGV0ZVwiXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja0ZuLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodGhpcyksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgdmFsdWUgPSBfc3RlcDIudmFsdWU7XG4gICAgICBjYWxsYmFja0ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5hdG9tXyk7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogQURELFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIHRoaXM7IC8vIGlkZWFsbHksIHZhbHVlID0gY2hhbmdlLnZhbHVlIHdvdWxkIGJlIGRvbmUgaGVyZSwgc28gdGhhdCB2YWx1ZXMgY2FuIGJlXG4gICAgICAvLyBjaGFuZ2VkIGJ5IGludGVyY2VwdG9yLiBTYW1lIGFwcGxpZXMgZm9yIG90aGVyIFNldCBhbmQgTWFwIGFwaSdzLlxuICAgIH1cblxuICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5kYXRhXy5hZGQoX3RoaXMyLmVuaGFuY2VyXyh2YWx1ZSwgdW5kZWZpbmVkKSk7XG5cbiAgICAgICAgX3RoaXMyLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG5vdGlmeVNweSA9ICBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG5cbiAgICAgIHZhciBfY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwic2V0XCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogQURELFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgfSA6IG51bGw7XG5cbiAgICAgIGlmIChub3RpZnlTcHkgJiYgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIikgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZSk7XG4gICAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZSk7XG4gICAgICBpZiAobm90aWZ5U3B5ICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIpIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90b1tcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIF9kZWxldGUodmFsdWUpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBERUxFVEUsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgb2xkVmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgdmFyIG5vdGlmeVNweSA9ICBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG5cbiAgICAgIHZhciBfY2hhbmdlMiA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInNldFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogdmFsdWVcbiAgICAgIH0gOiBudWxsO1xuXG4gICAgICBpZiAobm90aWZ5U3B5ICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIpIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UyKTtcbiAgICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLmF0b21fLnJlcG9ydENoYW5nZWQoKTtcblxuICAgICAgICBfdGhpczMuZGF0YV9bXCJkZWxldGVcIl0odmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZTIpO1xuICAgICAgaWYgKG5vdGlmeVNweSAmJiBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiKSBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaGFzID0gZnVuY3Rpb24gaGFzKHZhbHVlKSB7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiB0aGlzLmRhdGFfLmhhcyh0aGlzLmRlaGFuY2VWYWx1ZV8odmFsdWUpKTtcbiAgfTtcblxuICBfcHJvdG8uZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgdmFyIGtleXMgPSBBcnJheS5mcm9tKHRoaXMua2V5cygpKTtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkuZnJvbSh0aGlzLnZhbHVlcygpKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgbmV4dEluZGV4ICs9IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA8IHZhbHVlcy5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IFtrZXlzW2luZGV4XSwgdmFsdWVzW2luZGV4XV0sXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmtleXMgPSBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICB9O1xuXG4gIF9wcm90by52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICB2YXIgb2JzZXJ2YWJsZVZhbHVlcyA9IEFycmF5LmZyb20odGhpcy5kYXRhXy52YWx1ZXMoKSk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICByZXR1cm4gbmV4dEluZGV4IDwgb2JzZXJ2YWJsZVZhbHVlcy5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IHNlbGYuZGVoYW5jZVZhbHVlXyhvYnNlcnZhYmxlVmFsdWVzW25leHRJbmRleCsrXSksXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKG90aGVyKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlU2V0KG90aGVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2V0KG90aGVyKTtcbiAgICB9XG5cbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvdGhlcikpIHtcbiAgICAgICAgX3RoaXM0LmNsZWFyKCk7XG5cbiAgICAgICAgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc0VTNlNldChvdGhlcikpIHtcbiAgICAgICAgX3RoaXM0LmNsZWFyKCk7XG5cbiAgICAgICAgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvdGhlciAhPT0gbnVsbCAmJiBvdGhlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpZShcIkNhbm5vdCBpbml0aWFsaXplIHNldCBmcm9tIFwiICsgb3RoZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAvLyAuLi4gJ2ZpcmVJbW1lZGlhdGVseScgY291bGQgYWxzbyBiZSB0cnVlP1xuICAgIGlmICggZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IGZpcmVJbW1lZGlhdGVseT10cnVlIGluIGNvbWJpbmF0aW9uIHdpdGggc2V0cy5cIik7XG4gICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xuICB9O1xuXG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IE9ic2VydmFibGVTZXRdXCI7XG4gIH07XG5cbiAgX3Byb3RvW19TeW1ib2wkaXRlcmF0b3IkMV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGVTZXQsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnJDEsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJTZXRcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2JzZXJ2YWJsZVNldDtcbn0oKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbnZhciBpc09ic2VydmFibGVTZXQgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVTZXRcIiwgT2JzZXJ2YWJsZVNldCk7XG5cbnZhciBkZXNjcmlwdG9yQ2FjaGUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBSRU1PVkUgPSBcInJlbW92ZVwiO1xudmFyIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbih0YXJnZXRfLCB2YWx1ZXNfLCBuYW1lXywgLy8gVXNlZCBhbnl0aW1lIGFubm90YXRpb24gaXMgbm90IGV4cGxpY2l0ZWx5IHByb3ZpZGVkXG4gIGRlZmF1bHRBbm5vdGF0aW9uXykge1xuICAgIGlmICh2YWx1ZXNfID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlc18gPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRBbm5vdGF0aW9uXyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWZhdWx0QW5ub3RhdGlvbl8gPSBhdXRvQW5ub3RhdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLnRhcmdldF8gPSB2b2lkIDA7XG4gICAgdGhpcy52YWx1ZXNfID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0QW5ub3RhdGlvbl8gPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlzQXRvbV8gPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3h5XyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzUGxhaW5PYmplY3RfID0gdm9pZCAwO1xuICAgIHRoaXMuYXBwbGllZEFubm90YXRpb25zXyA9IHZvaWQgMDtcbiAgICB0aGlzLnBlbmRpbmdLZXlzXyA9IHZvaWQgMDtcbiAgICB0aGlzLnRhcmdldF8gPSB0YXJnZXRfO1xuICAgIHRoaXMudmFsdWVzXyA9IHZhbHVlc187XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIHRoaXMuZGVmYXVsdEFubm90YXRpb25fID0gZGVmYXVsdEFubm90YXRpb25fO1xuICAgIHRoaXMua2V5c0F0b21fID0gbmV3IEF0b20oIHRoaXMubmFtZV8gKyBcIi5rZXlzXCIgKTsgLy8gT3B0aW1pemF0aW9uOiB3ZSB1c2UgdGhpcyBmcmVxdWVudGx5XG5cbiAgICB0aGlzLmlzUGxhaW5PYmplY3RfID0gaXNQbGFpbk9iamVjdCh0aGlzLnRhcmdldF8pO1xuXG4gICAgaWYgKCAhaXNBbm5vdGF0aW9uKHRoaXMuZGVmYXVsdEFubm90YXRpb25fKSkge1xuICAgICAgZGllKFwiZGVmYXVsdEFubm90YXRpb24gbXVzdCBiZSB2YWxpZCBhbm5vdGF0aW9uXCIpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIC8vIFByZXBhcmUgc3RydWN0dXJlIGZvciB0cmFja2luZyB3aGljaCBmaWVsZHMgd2VyZSBhbHJlYWR5IGFubm90YXRlZFxuICAgICAgdGhpcy5hcHBsaWVkQW5ub3RhdGlvbnNfID0ge307XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldE9ic2VydmFibGVQcm9wVmFsdWVfID0gZnVuY3Rpb24gZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzXy5nZXQoa2V5KS5nZXQoKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8gPSBmdW5jdGlvbiBzZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXksIG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLnZhbHVlc18uZ2V0KGtleSk7XG5cbiAgICBpZiAob2JzZXJ2YWJsZSBpbnN0YW5jZW9mIENvbXB1dGVkVmFsdWUpIHtcbiAgICAgIG9ic2VydmFibGUuc2V0KG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gaW50ZXJjZXB0XG5cblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIG51bGw7XG4gICAgICBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICB9XG5cbiAgICBuZXdWYWx1ZSA9IG9ic2VydmFibGUucHJlcGFyZU5ld1ZhbHVlXyhuZXdWYWx1ZSk7IC8vIG5vdGlmeSBzcHkgJiBvYnNlcnZlcnNcblxuICAgIGlmIChuZXdWYWx1ZSAhPT0gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEKSB7XG4gICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgdmFyIG5vdGlmeVNweSA9ICBpc1NweUVuYWJsZWQoKTtcblxuICAgICAgdmFyIF9jaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm9iamVjdFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBvbGRWYWx1ZTogb2JzZXJ2YWJsZS52YWx1ZV8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9IDogbnVsbDtcblxuICAgICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UpO1xuICAgICAgb2JzZXJ2YWJsZS5zZXROZXdWYWx1ZV8obmV3VmFsdWUpO1xuICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UpO1xuICAgICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5nZXRfID0gZnVuY3Rpb24gZ2V0XyhrZXkpIHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uICYmICFoYXNQcm9wKHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgLy8gS2V5IGRvZXNuJ3QgZXhpc3QgeWV0LCBzdWJzY3JpYmUgZm9yIGl0IGluIGNhc2UgaXQncyBhZGRlZCBsYXRlclxuICAgICAgdGhpcy5oYXNfKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0X1trZXldO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxyXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxyXG4gICAqIEBwYXJhbSB7QW5ub3RhdGlvbnxib29sZWFufSBhbm5vdGF0aW9uIHRydWUgLSB1c2UgZGVmYXVsdCBhbm5vdGF0aW9uLCBmYWxzZSAtIGNvcHkgYXMgaXNcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zZXRfID0gZnVuY3Rpb24gc2V0XyhrZXksIHZhbHVlLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIERvbid0IHVzZSAuaGFzKGtleSkgLSB3ZSBjYXJlIGFib3V0IG93blxuICAgIGlmIChoYXNQcm9wKHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgLy8gRXhpc3RpbmcgcHJvcFxuICAgICAgaWYgKHRoaXMudmFsdWVzXy5oYXMoa2V5KSkge1xuICAgICAgICAvLyBPYnNlcnZhYmxlIChjYW4gYmUgaW50ZXJjZXB0ZWQpXG4gICAgICAgIHJldHVybiB0aGlzLnNldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgLy8gTm9uLW9ic2VydmFibGUgLSBwcm94eVxuICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGhpcy50YXJnZXRfLCBrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vbi1vYnNlcnZhYmxlXG4gICAgICAgIHRoaXMudGFyZ2V0X1trZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZXcgcHJvcFxuICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9LCB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXywgcHJveHlUcmFwKTtcbiAgICB9XG4gIH0gLy8gVHJhcCBmb3IgXCJpblwiXG4gIDtcblxuICBfcHJvdG8uaGFzXyA9IGZ1bmN0aW9uIGhhc18oa2V5KSB7XG4gICAgaWYgKCFnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIC8vIFNraXAga2V5IHN1YnNjcmlwdGlvbiBvdXRzaWRlIGRlcml2YXRpb25cbiAgICAgIHJldHVybiBrZXkgaW4gdGhpcy50YXJnZXRfO1xuICAgIH1cblxuICAgIHRoaXMucGVuZGluZ0tleXNfIHx8ICh0aGlzLnBlbmRpbmdLZXlzXyA9IG5ldyBNYXAoKSk7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5wZW5kaW5nS2V5c18uZ2V0KGtleSk7XG5cbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICBlbnRyeSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUoa2V5IGluIHRoaXMudGFyZ2V0XywgcmVmZXJlbmNlRW5oYW5jZXIsICB0aGlzLm5hbWVfICsgXCIuXCIgKyBzdHJpbmdpZnlLZXkoa2V5KSArIFwiP1wiICwgZmFsc2UpO1xuICAgICAgdGhpcy5wZW5kaW5nS2V5c18uc2V0KGtleSwgZW50cnkpO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRyeS5nZXQoKTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcclxuICAgKiBAcGFyYW0ge0Fubm90YXRpb258Ym9vbGVhbn0gYW5ub3RhdGlvbiB0cnVlIC0gdXNlIGRlZmF1bHQgYW5ub3RhdGlvbiwgZmFsc2UgLSBpZ25vcmUgcHJvcFxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm1ha2VfID0gZnVuY3Rpb24gbWFrZV8oa2V5LCBhbm5vdGF0aW9uKSB7XG4gICAgaWYgKGFubm90YXRpb24gPT09IHRydWUpIHtcbiAgICAgIGFubm90YXRpb24gPSB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXztcbiAgICB9XG5cbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhc3NlcnRBbm5vdGFibGUodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcblxuICAgIGlmICghKGtleSBpbiB0aGlzLnRhcmdldF8pKSB7XG4gICAgICB2YXIgX3RoaXMkdGFyZ2V0XyRzdG9yZWRBO1xuXG4gICAgICAvLyBUaHJvdyBvbiBtaXNzaW5nIGtleSwgZXhjZXB0IGZvciBkZWNvcmF0b3JzOlxuICAgICAgLy8gRGVjb3JhdG9yIGFubm90YXRpb25zIGFyZSBjb2xsZWN0ZWQgZnJvbSB3aG9sZSBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAvLyBXaGVuIGNhbGxlZCBmcm9tIHN1cGVyKCkgc29tZSBwcm9wcyBtYXkgbm90IGV4aXN0IHlldC5cbiAgICAgIC8vIEhvd2V2ZXIgd2UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBtaXNzaW5nIHByb3AsXG4gICAgICAvLyBiZWNhdXNlIHRoZSBkZWNvcmF0b3IgbXVzdCBoYXZlIGJlZW4gYXBwbGllZCB0byBzb21ldGhpbmcuXG4gICAgICBpZiAoKF90aGlzJHRhcmdldF8kc3RvcmVkQSA9IHRoaXMudGFyZ2V0X1tzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0YXJnZXRfJHN0b3JlZEFba2V5XSkge1xuICAgICAgICByZXR1cm47IC8vIHdpbGwgYmUgYW5ub3RhdGVkIGJ5IHN1YmNsYXNzIGNvbnN0cnVjdG9yXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWUoMSwgYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV8sIHRoaXMubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlID0gdGhpcy50YXJnZXRfO1xuXG4gICAgd2hpbGUgKHNvdXJjZSAmJiBzb3VyY2UgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXREZXNjcmlwdG9yKHNvdXJjZSwga2V5KTtcblxuICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgdmFyIG91dGNvbWUgPSBhbm5vdGF0aW9uLm1ha2VfKHRoaXMsIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbiAgICAgICAgaWYgKG91dGNvbWUgPT09IDBcbiAgICAgICAgLyogQ2FuY2VsICovXG4gICAgICAgICkgcmV0dXJuO1xuICAgICAgICBpZiAob3V0Y29tZSA9PT0gMVxuICAgICAgICAvKiBCcmVhayAqL1xuICAgICAgICApIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKTtcbiAgICB9XG5cbiAgICByZWNvcmRBbm5vdGF0aW9uQXBwbGllZCh0aGlzLCBhbm5vdGF0aW9uLCBrZXkpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlEZXNjcmlwdG9yfSBkZXNjcmlwdG9yXHJcbiAgICogQHBhcmFtIHtBbm5vdGF0aW9ufGJvb2xlYW59IGFubm90YXRpb24gdHJ1ZSAtIHVzZSBkZWZhdWx0IGFubm90YXRpb24sIGZhbHNlIC0gY29weSBhcyBpc1xyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJveHlUcmFwIHdoZXRoZXIgaXQncyBjYWxsZWQgZnJvbSBwcm94eSB0cmFwXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbH0gdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlIChwcm94eVRyYXAgKyBub24tY29uZmlndXJhYmxlKSwgbnVsbCB3aGVuIGNhbmNlbGxlZCBieSBpbnRlcmNlcHRvclxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmV4dGVuZF8gPSBmdW5jdGlvbiBleHRlbmRfKGtleSwgZGVzY3JpcHRvciwgYW5ub3RhdGlvbiwgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgYW5ub3RhdGlvbiA9IHRoaXMuZGVmYXVsdEFubm90YXRpb25fO1xuICAgIH1cblxuICAgIGlmIChhbm5vdGF0aW9uID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmaW5lUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbiAgICB9XG5cbiAgICBhc3NlcnRBbm5vdGFibGUodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcbiAgICB2YXIgb3V0Y29tZSA9IGFubm90YXRpb24uZXh0ZW5kXyh0aGlzLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG5cbiAgICBpZiAob3V0Y29tZSkge1xuICAgICAgcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Y29tZTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5RGVzY3JpcHRvcn0gZGVzY3JpcHRvclxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJveHlUcmFwIHdoZXRoZXIgaXQncyBjYWxsZWQgZnJvbSBwcm94eSB0cmFwXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbH0gdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlIChwcm94eVRyYXAgKyBub24tY29uZmlndXJhYmxlKSwgbnVsbCB3aGVuIGNhbmNlbGxlZCBieSBpbnRlcmNlcHRvclxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlZmluZVByb3BlcnR5XyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5XyhrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0QmF0Y2goKTsgLy8gRGVsZXRlXG5cbiAgICAgIHZhciBkZWxldGVPdXRjb21lID0gdGhpcy5kZWxldGVfKGtleSk7XG5cbiAgICAgIGlmICghZGVsZXRlT3V0Y29tZSkge1xuICAgICAgICAvLyBGYWlsdXJlIG9yIGludGVyY2VwdGVkXG4gICAgICAgIHJldHVybiBkZWxldGVPdXRjb21lO1xuICAgICAgfSAvLyBBREQgaW50ZXJjZXB0b3JcblxuXG4gICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgICAgbmV3VmFsdWU6IGRlc2NyaXB0b3IudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuXG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgIGRlc2NyaXB0b3IgPSBfZXh0ZW5kcyh7fSwgZGVzY3JpcHRvciwge1xuICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRGVmaW5lXG5cblxuICAgICAgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICBpZiAoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9IC8vIE5vdGlmeVxuXG5cbiAgICAgIHRoaXMubm90aWZ5UHJvcGVydHlBZGRpdGlvbl8oa2V5LCBkZXNjcmlwdG9yLnZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiBvcmlnaW5hbCBkZXNjcmlwdG9yIGJlY29tZXMgcmVsZXZhbnQsIG1vdmUgdGhpcyB0byBhbm5vdGF0aW9uIGRpcmVjdGx5XG4gIDtcblxuICBfcHJvdG8uZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5XyA9IGZ1bmN0aW9uIGRlZmluZU9ic2VydmFibGVQcm9wZXJ0eV8oa2V5LCB2YWx1ZSwgZW5oYW5jZXIsIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0QmF0Y2goKTsgLy8gRGVsZXRlXG5cbiAgICAgIHZhciBkZWxldGVPdXRjb21lID0gdGhpcy5kZWxldGVfKGtleSk7XG5cbiAgICAgIGlmICghZGVsZXRlT3V0Y29tZSkge1xuICAgICAgICAvLyBGYWlsdXJlIG9yIGludGVyY2VwdGVkXG4gICAgICAgIHJldHVybiBkZWxldGVPdXRjb21lO1xuICAgICAgfSAvLyBBREQgaW50ZXJjZXB0b3JcblxuXG4gICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgICAgbmV3VmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FjaGVkRGVzY3JpcHRvciA9IGdldENhY2hlZE9ic2VydmFibGVQcm9wRGVzY3JpcHRvcihrZXkpO1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzID8gdGhpcy5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogY2FjaGVkRGVzY3JpcHRvci5nZXQsXG4gICAgICAgIHNldDogY2FjaGVkRGVzY3JpcHRvci5zZXRcbiAgICAgIH07IC8vIERlZmluZVxuXG4gICAgICBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIGlmICghUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKHZhbHVlLCBlbmhhbmNlciwgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpIDogXCJPYnNlcnZhYmxlT2JqZWN0LmtleVwiLCBmYWxzZSk7XG4gICAgICB0aGlzLnZhbHVlc18uc2V0KGtleSwgb2JzZXJ2YWJsZSk7IC8vIE5vdGlmeSAodmFsdWUgcG9zc2libHkgY2hhbmdlZCBieSBPYnNlcnZhYmxlVmFsdWUpXG5cbiAgICAgIHRoaXMubm90aWZ5UHJvcGVydHlBZGRpdGlvbl8oa2V5LCBvYnNlcnZhYmxlLnZhbHVlXyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSWYgb3JpZ2luYWwgZGVzY3JpcHRvciBiZWNvbWVzIHJlbGV2YW50LCBtb3ZlIHRoaXMgdG8gYW5ub3RhdGlvbiBkaXJlY3RseVxuICA7XG5cbiAgX3Byb3RvLmRlZmluZUNvbXB1dGVkUHJvcGVydHlfID0gZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eV8oa2V5LCBvcHRpb25zLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzdGFydEJhdGNoKCk7IC8vIERlbGV0ZVxuXG4gICAgICB2YXIgZGVsZXRlT3V0Y29tZSA9IHRoaXMuZGVsZXRlXyhrZXkpO1xuXG4gICAgICBpZiAoIWRlbGV0ZU91dGNvbWUpIHtcbiAgICAgICAgLy8gRmFpbHVyZSBvciBpbnRlcmNlcHRlZFxuICAgICAgICByZXR1cm4gZGVsZXRlT3V0Y29tZTtcbiAgICAgIH0gLy8gQUREIGludGVyY2VwdG9yXG5cblxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgdHlwZTogQURELFxuICAgICAgICAgIG5ld1ZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5uYW1lIHx8IChvcHRpb25zLm5hbWUgPSBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgOiBcIk9ic2VydmFibGVPYmplY3Qua2V5XCIpO1xuICAgICAgb3B0aW9ucy5jb250ZXh0ID0gdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfO1xuICAgICAgdmFyIGNhY2hlZERlc2NyaXB0b3IgPSBnZXRDYWNoZWRPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3Ioa2V5KTtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycyA/IHRoaXMuaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBjYWNoZWREZXNjcmlwdG9yLmdldCxcbiAgICAgICAgc2V0OiBjYWNoZWREZXNjcmlwdG9yLnNldFxuICAgICAgfTsgLy8gRGVmaW5lXG5cbiAgICAgIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgaWYgKCFSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZhbHVlc18uc2V0KGtleSwgbmV3IENvbXB1dGVkVmFsdWUob3B0aW9ucykpOyAvLyBOb3RpZnlcblxuICAgICAgdGhpcy5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyhrZXksIHVuZGVmaW5lZCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eURlc2NyaXB0b3J9IGRlc2NyaXB0b3JcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZWxldGVfID0gZnVuY3Rpb24gZGVsZXRlXyhrZXksIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTm8gc3VjaCBwcm9wXG4gICAgaWYgKCFoYXNQcm9wKHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBJbnRlcmNlcHRcblxuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIHR5cGU6IFJFTU9WRVxuICAgICAgfSk7IC8vIENhbmNlbGxlZFxuXG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBEZWxldGVcblxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdGhpcyRwZW5kaW5nS2V5c18sIF90aGlzJHBlbmRpbmdLZXlzXyRnZTtcblxuICAgICAgc3RhcnRCYXRjaCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLnZhbHVlc18uZ2V0KGtleSk7IC8vIFZhbHVlIG5lZWRlZCBmb3Igc3BpZXMvbGlzdGVuZXJzXG5cbiAgICAgIHZhciB2YWx1ZSA9IHVuZGVmaW5lZDsgLy8gT3B0aW1pemF0aW9uOiBkb24ndCBwdWxsIHRoZSB2YWx1ZSB1bmxlc3Mgd2Ugd2lsbCBuZWVkIGl0XG5cbiAgICAgIGlmICghb2JzZXJ2YWJsZSAmJiAobm90aWZ5IHx8IG5vdGlmeVNweSkpIHtcbiAgICAgICAgdmFyIF9nZXREZXNjcmlwdG9yO1xuXG4gICAgICAgIHZhbHVlID0gKF9nZXREZXNjcmlwdG9yID0gZ2V0RGVzY3JpcHRvcih0aGlzLnRhcmdldF8sIGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0RGVzY3JpcHRvci52YWx1ZTtcbiAgICAgIH0gLy8gZGVsZXRlIHByb3AgKGRvIGZpcnN0LCBtYXkgZmFpbClcblxuXG4gICAgICBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIGlmICghUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRhcmdldF9ba2V5XTtcbiAgICAgIH0gLy8gQWxsb3cgcmUtYW5ub3RhdGluZyB0aGlzIGZpZWxkXG5cblxuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXBwbGllZEFubm90YXRpb25zX1trZXldO1xuICAgICAgfSAvLyBDbGVhciBvYnNlcnZhYmxlXG5cblxuICAgICAgaWYgKG9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNfW1wiZGVsZXRlXCJdKGtleSk7IC8vIGZvciBjb21wdXRlZCwgdmFsdWUgaXMgdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKG9ic2VydmFibGUgaW5zdGFuY2VvZiBPYnNlcnZhYmxlVmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9ic2VydmFibGUudmFsdWVfO1xuICAgICAgICB9IC8vIE5vdGlmeTogYXV0b3J1bigoKSA9PiBvYmpba2V5XSksIHNlZSAjMTc5NlxuXG5cbiAgICAgICAgcHJvcGFnYXRlQ2hhbmdlZChvYnNlcnZhYmxlKTtcbiAgICAgIH0gLy8gTm90aWZ5IFwia2V5cy9lbnRyaWVzL3ZhbHVlc1wiIG9ic2VydmVyc1xuXG5cbiAgICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTsgLy8gTm90aWZ5IFwiaGFzXCIgb2JzZXJ2ZXJzXG4gICAgICAvLyBcImluXCIgYXMgaXQgbWF5IHN0aWxsIGV4aXN0IGluIHByb3RvXG5cbiAgICAgIChfdGhpcyRwZW5kaW5nS2V5c18gPSB0aGlzLnBlbmRpbmdLZXlzXykgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRwZW5kaW5nS2V5c18kZ2UgPSBfdGhpcyRwZW5kaW5nS2V5c18uZ2V0KGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwZW5kaW5nS2V5c18kZ2Uuc2V0KGtleSBpbiB0aGlzLnRhcmdldF8pOyAvLyBOb3RpZnkgc3BpZXMvbGlzdGVuZXJzXG5cbiAgICAgIGlmIChub3RpZnkgfHwgbm90aWZ5U3B5KSB7XG4gICAgICAgIHZhciBfY2hhbmdlMiA9IHtcbiAgICAgICAgICB0eXBlOiBSRU1PVkUsXG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICAgIG9sZFZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBuYW1lOiBrZXlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSBzcHlSZXBvcnRTdGFydChfY2hhbmdlMik7XG4gICAgICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlMik7XG4gICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXHJcbiAgICogT2JzZXJ2ZXMgdGhpcyBvYmplY3QuIFRyaWdnZXJzIGZvciB0aGUgZXZlbnRzICdhZGQnLCAndXBkYXRlJyBhbmQgJ2RlbGV0ZScuXHJcbiAgICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qvb2JzZXJ2ZVxyXG4gICAqIGZvciBjYWxsYmFjayBkZXRhaWxzXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhjYWxsYmFjaywgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgaWYgKCBmaXJlSW1tZWRpYXRlbHkgPT09IHRydWUpIGRpZShcImBvYnNlcnZlYCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZpcmUgaW1tZWRpYXRlbHkgcHJvcGVydHkgZm9yIG9ic2VydmFibGUgb2JqZWN0cy5cIik7XG4gICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgY2FsbGJhY2spO1xuICB9O1xuXG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG5cbiAgX3Byb3RvLm5vdGlmeVByb3BlcnR5QWRkaXRpb25fID0gZnVuY3Rpb24gbm90aWZ5UHJvcGVydHlBZGRpdGlvbl8oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBfdGhpcyRwZW5kaW5nS2V5c18yLCBfdGhpcyRwZW5kaW5nS2V5c18yJGc7XG5cbiAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgIHZhciBub3RpZnlTcHkgPSAgaXNTcHlFbmFibGVkKCk7XG5cbiAgICBpZiAobm90aWZ5IHx8IG5vdGlmeVNweSkge1xuICAgICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwib2JqZWN0XCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IHZhbHVlXG4gICAgICB9IDogbnVsbDtcbiAgICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gICAgfVxuXG4gICAgKF90aGlzJHBlbmRpbmdLZXlzXzIgPSB0aGlzLnBlbmRpbmdLZXlzXykgPT0gbnVsbCA/IHZvaWQgMCA6IChfdGhpcyRwZW5kaW5nS2V5c18yJGcgPSBfdGhpcyRwZW5kaW5nS2V5c18yLmdldChrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcGVuZGluZ0tleXNfMiRnLnNldCh0cnVlKTsgLy8gTm90aWZ5IFwia2V5cy9lbnRyaWVzL3ZhbHVlc1wiIG9ic2VydmVyc1xuXG4gICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICB9O1xuXG4gIF9wcm90by5vd25LZXlzXyA9IGZ1bmN0aW9uIG93bktleXNfKCkge1xuICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIG93bktleXModGhpcy50YXJnZXRfKTtcbiAgfTtcblxuICBfcHJvdG8ua2V5c18gPSBmdW5jdGlvbiBrZXlzXygpIHtcbiAgICAvLyBSZXR1cm5zIGVudW1lcmFibGUgJiYgb3duLCBidXQgdW5mb3J0dW5hdGVseSBrZXlzQXRvbSB3aWxsIHJlcG9ydCBvbiBBTlkga2V5IGNoYW5nZS5cbiAgICAvLyBUaGVyZSBpcyBubyB3YXkgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBPYmplY3Qua2V5cyhvYmplY3QpIGFuZCBSZWZsZWN0Lm93bktleXMob2JqZWN0KSAtIGJvdGggYXJlIGhhbmRsZWQgYnkgb3duS2V5cyB0cmFwLlxuICAgIC8vIFdlIGNhbiBlaXRoZXIgb3Zlci1yZXBvcnQgaW4gT2JqZWN0LmtleXMob2JqZWN0KSBvciB1bmRlci1yZXBvcnQgaW4gUmVmbGVjdC5vd25LZXlzKG9iamVjdClcbiAgICAvLyBXZSBjaG9vc2UgdG8gb3Zlci1yZXBvcnQgaW4gT2JqZWN0LmtleXMob2JqZWN0KSwgYmVjYXVzZTpcbiAgICAvLyAtIHR5cGljYWxseSBpdCdzIHVzZWQgd2l0aCBzaW1wbGUgZGF0YSBvYmplY3RzXG4gICAgLy8gLSB3aGVuIHN5bWJvbGljL25vbi1lbnVtZXJhYmxlIGtleXMgYXJlIHJlbGV2YW50IFJlZmxlY3Qub3duS2V5cyB3b3JrcyBhcyBleHBlY3RlZFxuICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudGFyZ2V0Xyk7XG4gIH07XG5cbiAgcmV0dXJuIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbjtcbn0oKTtcbmZ1bmN0aW9uIGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJG5hbWU7XG5cbiAgaWYgKCBvcHRpb25zICYmIGlzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQpKSB7XG4gICAgZGllKFwiT3B0aW9ucyBjYW4ndCBiZSBwcm92aWRlZCBmb3IgYWxyZWFkeSBvYnNlcnZhYmxlIG9iamVjdHMuXCIpO1xuICB9XG5cbiAgaWYgKGhhc1Byb3AodGFyZ2V0LCAkbW9ieCkpIHtcbiAgICBpZiAoICEoZ2V0QWRtaW5pc3RyYXRpb24odGFyZ2V0KSBpbnN0YW5jZW9mIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbikpIHtcbiAgICAgIGRpZShcIkNhbm5vdCBjb252ZXJ0ICdcIiArIGdldERlYnVnTmFtZSh0YXJnZXQpICsgXCInIGludG8gb2JzZXJ2YWJsZSBvYmplY3Q6XCIgKyBcIlxcblRoZSB0YXJnZXQgaXMgYWxyZWFkeSBvYnNlcnZhYmxlIG9mIGRpZmZlcmVudCB0eXBlLlwiICsgXCJcXG5FeHRlbmRpbmcgYnVpbHRpbnMgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGlmICggIU9iamVjdC5pc0V4dGVuc2libGUodGFyZ2V0KSkgZGllKFwiQ2Fubm90IG1ha2UgdGhlIGRlc2lnbmF0ZWQgb2JqZWN0IG9ic2VydmFibGU7IGl0IGlzIG5vdCBleHRlbnNpYmxlXCIpO1xuICB2YXIgbmFtZSA9IChfb3B0aW9ucyRuYW1lID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lKSAhPSBudWxsID8gX29wdGlvbnMkbmFtZSA6ICAoaXNQbGFpbk9iamVjdCh0YXJnZXQpID8gXCJPYnNlcnZhYmxlT2JqZWN0XCIgOiB0YXJnZXQuY29uc3RydWN0b3IubmFtZSkgKyBcIkBcIiArIGdldE5leHRJZCgpIDtcbiAgdmFyIGFkbSA9IG5ldyBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24odGFyZ2V0LCBuZXcgTWFwKCksIFN0cmluZyhuYW1lKSwgZ2V0QW5ub3RhdGlvbkZyb21PcHRpb25zKG9wdGlvbnMpKTtcbiAgYWRkSGlkZGVuUHJvcCh0YXJnZXQsICRtb2J4LCBhZG0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxudmFyIGlzT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb25cIiwgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKTtcblxuZnVuY3Rpb24gZ2V0Q2FjaGVkT2JzZXJ2YWJsZVByb3BEZXNjcmlwdG9yKGtleSkge1xuICByZXR1cm4gZGVzY3JpcHRvckNhY2hlW2tleV0gfHwgKGRlc2NyaXB0b3JDYWNoZVtrZXldID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLmdldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLnNldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykge1xuICBpZiAoaXNPYmplY3QodGhpbmcpKSB7XG4gICAgcmV0dXJuIGlzT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKHRoaW5nWyRtb2J4XSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZWNvcmRBbm5vdGF0aW9uQXBwbGllZChhZG0sIGFubm90YXRpb24sIGtleSkge1xuICB2YXIgX2FkbSR0YXJnZXRfJHN0b3JlZEFuO1xuXG4gIHtcbiAgICBhZG0uYXBwbGllZEFubm90YXRpb25zX1trZXldID0gYW5ub3RhdGlvbjtcbiAgfSAvLyBSZW1vdmUgYXBwbGllZCBkZWNvcmF0b3IgYW5ub3RhdGlvbiBzbyB3ZSBkb24ndCB0cnkgdG8gYXBwbHkgaXQgYWdhaW4gaW4gc3ViY2xhc3MgY29uc3RydWN0b3JcblxuXG4gIChfYWRtJHRhcmdldF8kc3RvcmVkQW4gPSBhZG0udGFyZ2V0X1tzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pID09IG51bGwgPyB0cnVlIDogZGVsZXRlIF9hZG0kdGFyZ2V0XyRzdG9yZWRBbltrZXldO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBbm5vdGFibGUoYWRtLCBhbm5vdGF0aW9uLCBrZXkpIHtcbiAgLy8gVmFsaWQgYW5ub3RhdGlvblxuICBpZiAoICFpc0Fubm90YXRpb24oYW5ub3RhdGlvbikpIHtcbiAgICBkaWUoXCJDYW5ub3QgYW5ub3RhdGUgJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzogSW52YWxpZCBhbm5vdGF0aW9uLlwiKTtcbiAgfVxuICAvKlxyXG4gIC8vIENvbmZpZ3VyYWJsZSwgbm90IHNlYWxlZCwgbm90IGZyb3plblxyXG4gIC8vIFBvc3NpYmx5IG5vdCBuZWVkZWQsIGp1c3QgYSBsaXR0bGUgYmV0dGVyIGVycm9yIHRoZW4gdGhlIG9uZSB0aHJvd24gYnkgZW5naW5lLlxyXG4gIC8vIENhc2VzIHdoZXJlIHRoaXMgd291bGQgYmUgdXNlZnVsIHRoZSBtb3N0IChzdWJjbGFzcyBmaWVsZCBpbml0aWFsaXplcikgYXJlIG5vdCBpbnRlcmNlcHRhYmxlIGJ5IHRoaXMuXHJcbiAgaWYgKF9fREVWX18pIHtcclxuICAgICAgY29uc3QgY29uZmlndXJhYmxlID0gZ2V0RGVzY3JpcHRvcihhZG0udGFyZ2V0Xywga2V5KT8uY29uZmlndXJhYmxlXHJcbiAgICAgIGNvbnN0IGZyb3plbiA9IE9iamVjdC5pc0Zyb3plbihhZG0udGFyZ2V0XylcclxuICAgICAgY29uc3Qgc2VhbGVkID0gT2JqZWN0LmlzU2VhbGVkKGFkbS50YXJnZXRfKVxyXG4gICAgICBpZiAoIWNvbmZpZ3VyYWJsZSB8fCBmcm96ZW4gfHwgc2VhbGVkKSB7XHJcbiAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBgJHthZG0ubmFtZV99LiR7a2V5LnRvU3RyaW5nKCl9YFxyXG4gICAgICAgICAgY29uc3QgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgPSBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlX1xyXG4gICAgICAgICAgbGV0IGVycm9yID0gYENhbm5vdCBhcHBseSAnJHtyZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZX0nIHRvICcke2ZpZWxkTmFtZX0nOmBcclxuICAgICAgICAgIGlmIChmcm96ZW4pIHtcclxuICAgICAgICAgICAgICBlcnJvciArPSBgXFxuT2JqZWN0IGlzIGZyb3plbi5gXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7XHJcbiAgICAgICAgICAgICAgZXJyb3IgKz0gYFxcbk9iamVjdCBpcyBzZWFsZWQuYFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFjb25maWd1cmFibGUpIHtcclxuICAgICAgICAgICAgICBlcnJvciArPSBgXFxucHJvcGVydHkgaXMgbm90IGNvbmZpZ3VyYWJsZS5gXHJcbiAgICAgICAgICAgICAgLy8gTWVudGlvbiBvbmx5IGlmIGNhdXNlZCBieSB1cyB0byBhdm9pZCBjb25mdXNpb25cclxuICAgICAgICAgICAgICBpZiAoaGFzUHJvcChhZG0uYXBwbGllZEFubm90YXRpb25zISwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICBlcnJvciArPSBgXFxuVG8gcHJldmVudCBhY2NpZGVudGFsIHJlLWRlZmluaXRpb24gb2YgYSBmaWVsZCBieSBhIHN1YmNsYXNzLCBgXHJcbiAgICAgICAgICAgICAgICAgIGVycm9yICs9IGBhbGwgYW5ub3RhdGVkIGZpZWxkcyBvZiBub24tcGxhaW4gb2JqZWN0cyAoY2xhc3NlcykgYXJlIG5vdCBjb25maWd1cmFibGUuYFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRpZShlcnJvcilcclxuICAgICAgfVxyXG4gIH1cclxuICAqL1xuICAvLyBOb3QgYW5ub3RhdGVkXG5cblxuICBpZiAoICFpc092ZXJyaWRlKGFubm90YXRpb24pICYmIGhhc1Byb3AoYWRtLmFwcGxpZWRBbm5vdGF0aW9uc18sIGtleSkpIHtcbiAgICB2YXIgZmllbGROYW1lID0gYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKTtcbiAgICB2YXIgY3VycmVudEFubm90YXRpb25UeXBlID0gYWRtLmFwcGxpZWRBbm5vdGF0aW9uc19ba2V5XS5hbm5vdGF0aW9uVHlwZV87XG4gICAgdmFyIHJlcXVlc3RlZEFubm90YXRpb25UeXBlID0gYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV87XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIHJlcXVlc3RlZEFubm90YXRpb25UeXBlICsgXCInIHRvICdcIiArIGZpZWxkTmFtZSArIFwiJzpcIiArIChcIlxcblRoZSBmaWVsZCBpcyBhbHJlYWR5IGFubm90YXRlZCB3aXRoICdcIiArIGN1cnJlbnRBbm5vdGF0aW9uVHlwZSArIFwiJy5cIikgKyBcIlxcblJlLWFubm90YXRpbmcgZmllbGRzIGlzIG5vdCBhbGxvd2VkLlwiICsgXCJcXG5Vc2UgJ292ZXJyaWRlJyBhbm5vdGF0aW9uIGZvciBtZXRob2RzIG92ZXJyaWRlbiBieSBzdWJjbGFzcy5cIik7XG4gIH1cbn1cblxuLyoqXHJcbiAqIFRoaXMgYXJyYXkgYnVmZmVyIGNvbnRhaW5zIHR3byBsaXN0cyBvZiBwcm9wZXJ0aWVzLCBzbyB0aGF0IGFsbCBhcnJheXNcclxuICogY2FuIHJlY3ljbGUgdGhlaXIgcHJvcGVydHkgZGVmaW5pdGlvbnMsIHdoaWNoIHNpZ25pZmljYW50bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2Ugb2YgY3JlYXRpbmdcclxuICogcHJvcGVydGllcyBvbiB0aGUgZmx5LlxyXG4gKi9cblxudmFyIE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUgPSAwOyAvLyBUeXBlc2NyaXB0IHdvcmthcm91bmQgdG8gbWFrZSBzdXJlIE9ic2VydmFibGVBcnJheSBleHRlbmRzIEFycmF5XG5cbnZhciBTdHViQXJyYXkgPSBmdW5jdGlvbiBTdHViQXJyYXkoKSB7fTtcblxuZnVuY3Rpb24gaW5oZXJpdChjdG9yLCBwcm90bykge1xuICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGN0b3IucHJvdG90eXBlLCBwcm90byk7XG4gIH0gZWxzZSBpZiAoY3Rvci5wcm90b3R5cGUuX19wcm90b19fICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdG9yLnByb3RvdHlwZS5fX3Byb3RvX18gPSBwcm90bztcbiAgfSBlbHNlIHtcbiAgICBjdG9yLnByb3RvdHlwZSA9IHByb3RvO1xuICB9XG59XG5cbmluaGVyaXQoU3R1YkFycmF5LCBBcnJheS5wcm90b3R5cGUpOyAvLyBXZWV4IHByb3RvIGZyZWV6ZSBwcm90ZWN0aW9uIHdhcyBoZXJlLFxuLy8gYnV0IGl0IGlzIHVuY2xlYXIgd2h5IHRoZSBoYWNrIGlzIG5lZWQgYXMgTW9iWCBuZXZlciBjaGFuZ2VkIHRoZSBwcm90b3R5cGVcbi8vIGFueXdheSwgc28gcmVtb3ZlZCBpdCBpbiBWNlxuXG52YXIgTGVnYWN5T2JzZXJ2YWJsZUFycmF5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3R1YkFycmF5KSB7XG4gIF9pbmhlcml0c0xvb3NlKExlZ2FjeU9ic2VydmFibGVBcnJheSwgX1N0dWJBcnJheSk7XG5cbiAgZnVuY3Rpb24gTGVnYWN5T2JzZXJ2YWJsZUFycmF5KGluaXRpYWxWYWx1ZXMsIGVuaGFuY2VyLCBuYW1lLCBvd25lZCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWUgPSAgXCJPYnNlcnZhYmxlQXJyYXlAXCIgKyBnZXROZXh0SWQoKSA7XG4gICAgfVxuXG4gICAgaWYgKG93bmVkID09PSB2b2lkIDApIHtcbiAgICAgIG93bmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfU3R1YkFycmF5LmNhbGwodGhpcykgfHwgdGhpcztcbiAgICB2YXIgYWRtID0gbmV3IE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKG5hbWUsIGVuaGFuY2VyLCBvd25lZCwgdHJ1ZSk7XG4gICAgYWRtLnByb3h5XyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpO1xuICAgIGFkZEhpZGRlbkZpbmFsUHJvcChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgJG1vYngsIGFkbSk7XG5cbiAgICBpZiAoaW5pdGlhbFZhbHVlcyAmJiBpbml0aWFsVmFsdWVzLmxlbmd0aCkge1xuICAgICAgdmFyIHByZXYgPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KHRydWUpOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgIF90aGlzLnNwbGljZVdpdGhBcnJheSgwLCAwLCBpbml0aWFsVmFsdWVzKTtcblxuICAgICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExlZ2FjeU9ic2VydmFibGVBcnJheS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB0aGlzWyRtb2J4XS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFycmF5cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFycmF5c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLnNsaWNlKCksIC8vQHRzLWlnbm9yZVxuICAgIGFycmF5cy5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBpc09ic2VydmFibGVBcnJheShhKSA/IGEuc2xpY2UoKSA6IGE7XG4gICAgfSkpO1xuICB9O1xuXG4gIF9wcm90b1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIG5leHRJbmRleCA8IHNlbGYubGVuZ3RoID8ge1xuICAgICAgICAgIHZhbHVlOiBzZWxmW25leHRJbmRleCsrXSxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9IDoge1xuICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhMZWdhY3lPYnNlcnZhYmxlQXJyYXksIFt7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLmdldEFycmF5TGVuZ3RoXygpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGVuZ3RoKSB7XG4gICAgICB0aGlzWyRtb2J4XS5zZXRBcnJheUxlbmd0aF8obmV3TGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcIkFycmF5XCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExlZ2FjeU9ic2VydmFibGVBcnJheTtcbn0oU3R1YkFycmF5KTtcblxuT2JqZWN0LmVudHJpZXMoYXJyYXlFeHRlbnNpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBwcm9wID0gX3JlZlswXSxcbiAgICAgIGZuID0gX3JlZlsxXTtcbiAgaWYgKHByb3AgIT09IFwiY29uY2F0XCIpIGFkZEhpZGRlblByb3AoTGVnYWN5T2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZSwgcHJvcCwgZm4pO1xufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKGluZGV4KSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJG1vYnhdLmdldF8oaW5kZXgpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXNbJG1vYnhdLnNldF8oaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5QnVmZmVySXRlbShpbmRleCkge1xuICBkZWZpbmVQcm9wZXJ0eShMZWdhY3lPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLCBcIlwiICsgaW5kZXgsIGNyZWF0ZUFycmF5RW50cnlEZXNjcmlwdG9yKGluZGV4KSk7XG59XG5cbmZ1bmN0aW9uIHJlc2VydmVBcnJheUJ1ZmZlcihtYXgpIHtcbiAgaWYgKG1heCA+IE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkU7IGluZGV4IDwgbWF4ICsgMTAwOyBpbmRleCsrKSB7XG4gICAgICBjcmVhdGVBcnJheUJ1ZmZlckl0ZW0oaW5kZXgpO1xuICAgIH1cblxuICAgIE9CU0VSVkFCTEVfQVJSQVlfQlVGRkVSX1NJWkUgPSBtYXg7XG4gIH1cbn1cbnJlc2VydmVBcnJheUJ1ZmZlcigxMDAwKTtcbmZ1bmN0aW9uIGNyZWF0ZUxlZ2FjeUFycmF5KGluaXRpYWxWYWx1ZXMsIGVuaGFuY2VyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgTGVnYWN5T2JzZXJ2YWJsZUFycmF5KGluaXRpYWxWYWx1ZXMsIGVuaGFuY2VyLCBuYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpIHtcbiAgaWYgKHR5cGVvZiB0aGluZyA9PT0gXCJvYmplY3RcIiAmJiB0aGluZyAhPT0gbnVsbCkge1xuICAgIGlmIChpc09ic2VydmFibGVBcnJheSh0aGluZykpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSBkaWUoMjMpO1xuICAgICAgcmV0dXJuIHRoaW5nWyRtb2J4XS5hdG9tXztcbiAgICB9XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlU2V0KHRoaW5nKSkge1xuICAgICAgcmV0dXJuIHRoaW5nWyRtb2J4XTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSkge1xuICAgICAgaWYgKHByb3BlcnR5ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGluZy5rZXlzQXRvbV87XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaW5nLmRhdGFfLmdldChwcm9wZXJ0eSkgfHwgdGhpbmcuaGFzTWFwXy5nZXQocHJvcGVydHkpO1xuICAgICAgaWYgKCFvYnNlcnZhYmxlKSBkaWUoMjUsIHByb3BlcnR5LCBnZXREZWJ1Z05hbWUodGhpbmcpKTtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH1cblxuICAgIGlmIChpc09ic2VydmFibGVPYmplY3QodGhpbmcpKSB7XG4gICAgICBpZiAoIXByb3BlcnR5KSByZXR1cm4gZGllKDI2KTtcblxuICAgICAgdmFyIF9vYnNlcnZhYmxlID0gdGhpbmdbJG1vYnhdLnZhbHVlc18uZ2V0KHByb3BlcnR5KTtcblxuICAgICAgaWYgKCFfb2JzZXJ2YWJsZSkgZGllKDI3LCBwcm9wZXJ0eSwgZ2V0RGVidWdOYW1lKHRoaW5nKSk7XG4gICAgICByZXR1cm4gX29ic2VydmFibGU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXRvbSh0aGluZykgfHwgaXNDb21wdXRlZFZhbHVlKHRoaW5nKSB8fCBpc1JlYWN0aW9uKHRoaW5nKSkge1xuICAgICAgcmV0dXJuIHRoaW5nO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaW5nKSkge1xuICAgIGlmIChpc1JlYWN0aW9uKHRoaW5nWyRtb2J4XSkpIHtcbiAgICAgIC8vIGRpc3Bvc2VyIGZ1bmN0aW9uXG4gICAgICByZXR1cm4gdGhpbmdbJG1vYnhdO1xuICAgIH1cbiAgfVxuXG4gIGRpZSgyOCk7XG59XG5mdW5jdGlvbiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcGVydHkpIHtcbiAgaWYgKCF0aGluZykgZGllKDI5KTtcbiAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbihnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkpO1xuICBpZiAoaXNBdG9tKHRoaW5nKSB8fCBpc0NvbXB1dGVkVmFsdWUodGhpbmcpIHx8IGlzUmVhY3Rpb24odGhpbmcpKSByZXR1cm4gdGhpbmc7XG4gIGlmIChpc09ic2VydmFibGVNYXAodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZVNldCh0aGluZykpIHJldHVybiB0aGluZztcbiAgaWYgKHRoaW5nWyRtb2J4XSkgcmV0dXJuIHRoaW5nWyRtb2J4XTtcbiAgZGllKDI0LCB0aGluZyk7XG59XG5mdW5jdGlvbiBnZXREZWJ1Z05hbWUodGhpbmcsIHByb3BlcnR5KSB7XG4gIHZhciBuYW1lZDtcblxuICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgIG5hbWVkID0gZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpO1xuICB9IGVsc2UgaWYgKGlzQWN0aW9uKHRoaW5nKSkge1xuICAgIHJldHVybiB0aGluZy5uYW1lO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykgfHwgaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSB8fCBpc09ic2VydmFibGVTZXQodGhpbmcpKSB7XG4gICAgbmFtZWQgPSBnZXRBZG1pbmlzdHJhdGlvbih0aGluZyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdmFsaWQgZm9yIGFycmF5cyBhcyB3ZWxsXG4gICAgbmFtZWQgPSBnZXRBdG9tKHRoaW5nKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lZC5uYW1lXztcbn1cblxudmFyIHRvU3RyaW5nID0gb2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIsIGRlcHRoKSB7XG4gIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgZGVwdGggPSAtMTtcbiAgfVxuXG4gIHJldHVybiBlcShhLCBiLCBkZXB0aCk7XG59IC8vIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9ibG9iLzVjMjM3YTdjNjgyZmI2OGZkNTM3ODIwM2YwYmYyMmRjZTE2MjQ4NTQvdW5kZXJzY29yZS5qcyNMMTE4Ni1MMTI4OVxuLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cblxuZnVuY3Rpb24gZXEoYSwgYiwgZGVwdGgsIGFTdGFjaywgYlN0YWNrKSB7XG4gIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7IC8vIGBudWxsYCBvciBgdW5kZWZpbmVkYCBvbmx5IGVxdWFsIHRvIGl0c2VsZiAoc3RyaWN0IGNvbXBhcmlzb24pLlxuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7IC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG5cbiAgaWYgKGEgIT09IGEpIHJldHVybiBiICE9PSBiOyAvLyBFeGhhdXN0IHByaW1pdGl2ZSBjaGVja3NcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBhO1xuICBpZiAoIWlzRnVuY3Rpb24odHlwZSkgJiYgdHlwZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiAhPSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7IC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG5cbiAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgIGNhc2UgXCJbb2JqZWN0IFJlZ0V4cF1cIjogLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcblxuICAgIGNhc2UgXCJbb2JqZWN0IFN0cmluZ11cIjpcbiAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICByZXR1cm4gXCJcIiArIGEgPT09IFwiXCIgKyBiO1xuXG4gICAgY2FzZSBcIltvYmplY3QgTnVtYmVyXVwiOlxuICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOLlxuICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjsgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cblxuICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcblxuICAgIGNhc2UgXCJbb2JqZWN0IERhdGVdXCI6XG4gICAgY2FzZSBcIltvYmplY3QgQm9vbGVhbl1cIjpcbiAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgIHJldHVybiArYSA9PT0gK2I7XG5cbiAgICBjYXNlIFwiW29iamVjdCBTeW1ib2xdXCI6XG4gICAgICByZXR1cm4gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wudmFsdWVPZi5jYWxsKGEpID09PSBTeW1ib2wudmFsdWVPZi5jYWxsKGIpO1xuXG4gICAgY2FzZSBcIltvYmplY3QgTWFwXVwiOlxuICAgIGNhc2UgXCJbb2JqZWN0IFNldF1cIjpcbiAgICAgIC8vIE1hcHMgYW5kIFNldHMgYXJlIHVud3JhcHBlZCB0byBhcnJheXMgb2YgZW50cnktcGFpcnMsIGFkZGluZyBhbiBpbmNpZGVudGFsIGxldmVsLlxuICAgICAgLy8gSGlkZSB0aGlzIGV4dHJhIGxldmVsIGJ5IGluY3JlYXNpbmcgdGhlIGRlcHRoLlxuICAgICAgaWYgKGRlcHRoID49IDApIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gIH0gLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG5cblxuICBhID0gdW53cmFwKGEpO1xuICBiID0gdW53cmFwKGIpO1xuICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSBcIltvYmplY3QgQXJyYXldXCI7XG5cbiAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICBpZiAodHlwZW9mIGEgIT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7IC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG5cbiAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLFxuICAgICAgICBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG5cbiAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJiBpc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gYSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXB0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChkZXB0aCA8IDApIHtcbiAgICBkZXB0aCA9IC0xO1xuICB9IC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuXG5cbiAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgfSAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG5cblxuICBhU3RhY2sucHVzaChhKTtcbiAgYlN0YWNrLnB1c2goYik7IC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuXG4gIGlmIChhcmVBcnJheXMpIHtcbiAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlOyAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBkZXB0aCAtIDEsIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBrZXk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cblxuICAgIGlmIChPYmplY3Qua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgIGlmICghKGhhc1Byb3AoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgZGVwdGggLSAxLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuXG5cbiAgYVN0YWNrLnBvcCgpO1xuICBiU3RhY2sucG9wKCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB1bndyYXAoYSkge1xuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkoYSkpIHJldHVybiBhLnNsaWNlKCk7XG4gIGlmIChpc0VTNk1hcChhKSB8fCBpc09ic2VydmFibGVNYXAoYSkpIHJldHVybiBBcnJheS5mcm9tKGEuZW50cmllcygpKTtcbiAgaWYgKGlzRVM2U2V0KGEpIHx8IGlzT2JzZXJ2YWJsZVNldChhKSkgcmV0dXJuIEFycmF5LmZyb20oYS5lbnRyaWVzKCkpO1xuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gbWFrZUl0ZXJhYmxlKGl0ZXJhdG9yKSB7XG4gIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBnZXRTZWxmO1xuICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGYoKSB7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBpc0Fubm90YXRpb24odGhpbmcpIHtcbiAgcmV0dXJuICgvLyBDYW4gYmUgZnVuY3Rpb25cbiAgICB0aGluZyBpbnN0YW5jZW9mIE9iamVjdCAmJiB0eXBlb2YgdGhpbmcuYW5ub3RhdGlvblR5cGVfID09PSBcInN0cmluZ1wiICYmIGlzRnVuY3Rpb24odGhpbmcubWFrZV8pICYmIGlzRnVuY3Rpb24odGhpbmcuZXh0ZW5kXylcbiAgKTtcbn1cblxuLyoqXHJcbiAqIChjKSBNaWNoZWwgV2VzdHN0cmF0ZSAyMDE1IC0gMjAyMFxyXG4gKiBNSVQgTGljZW5zZWRcclxuICpcclxuICogV2VsY29tZSB0byB0aGUgbW9ieCBzb3VyY2VzISBUbyBnZXQgYW4gZ2xvYmFsIG92ZXJ2aWV3IG9mIGhvdyBNb2JYIGludGVybmFsbHkgd29ya3MsXHJcbiAqIHRoaXMgaXMgYSBnb29kIHBsYWNlIHRvIHN0YXJ0OlxyXG4gKiBodHRwczovL21lZGl1bS5jb20vQG13ZXN0c3RyYXRlL2JlY29taW5nLWZ1bGx5LXJlYWN0aXZlLWFuLWluLWRlcHRoLWV4cGxhbmF0aW9uLW9mLW1vYnNlcnZhYmxlLTU1OTk1MjYyYTI1NCMueHZiaDZxZDc0XHJcbiAqXHJcbiAqIFNvdXJjZSBmb2xkZXJzOlxyXG4gKiA9PT09PT09PT09PT09PT1cclxuICpcclxuICogLSBhcGkvICAgICBNb3N0IG9mIHRoZSBwdWJsaWMgc3RhdGljIG1ldGhvZHMgZXhwb3NlZCBieSB0aGUgbW9kdWxlIGNhbiBiZSBmb3VuZCBoZXJlLlxyXG4gKiAtIGNvcmUvICAgIEltcGxlbWVudGF0aW9uIG9mIHRoZSBNb2JYIGFsZ29yaXRobTsgYXRvbXMsIGRlcml2YXRpb25zLCByZWFjdGlvbnMsIGRlcGVuZGVuY3kgdHJlZXMsIG9wdGltaXphdGlvbnMuIENvb2wgc3R1ZmYgY2FuIGJlIGZvdW5kIGhlcmUuXHJcbiAqIC0gdHlwZXMvICAgQWxsIHRoZSBtYWdpYyB0aGF0IGlzIG5lZWQgdG8gaGF2ZSBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgdmFsdWVzIGlzIGluIHRoaXMgZm9sZGVyLiBJbmNsdWRpbmcgdGhlIG1vZGlmaWVycyBsaWtlIGBhc0ZsYXRgLlxyXG4gKiAtIHV0aWxzLyAgIFV0aWxpdHkgc3R1ZmYuXHJcbiAqXHJcbiAqL1xuW1wiU3ltYm9sXCIsIFwiTWFwXCIsIFwiU2V0XCJdLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgdmFyIGcgPSBnZXRHbG9iYWwoKTtcblxuICBpZiAodHlwZW9mIGdbbV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkaWUoXCJNb2JYIHJlcXVpcmVzIGdsb2JhbCAnXCIgKyBtICsgXCInIHRvIGJlIGF2YWlsYWJsZSBvciBwb2x5ZmlsbGVkXCIpO1xuICB9XG59KTtcblxuaWYgKHR5cGVvZiBfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gXCJvYmplY3RcIikge1xuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmR5a29nL21vYngtZGV2dG9vbHMvXG4gIF9fTU9CWF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdE1vYngoe1xuICAgIHNweTogc3B5LFxuICAgIGV4dHJhczoge1xuICAgICAgZ2V0RGVidWdOYW1lOiBnZXREZWJ1Z05hbWVcbiAgICB9LFxuICAgICRtb2J4OiAkbW9ieFxuICB9KTtcbn1cblxuZXhwb3J0cy4kbW9ieCA9ICRtb2J4O1xuZXhwb3J0cy5GbG93Q2FuY2VsbGF0aW9uRXJyb3IgPSBGbG93Q2FuY2VsbGF0aW9uRXJyb3I7XG5leHBvcnRzLk9ic2VydmFibGVNYXAgPSBPYnNlcnZhYmxlTWFwO1xuZXhwb3J0cy5PYnNlcnZhYmxlU2V0ID0gT2JzZXJ2YWJsZVNldDtcbmV4cG9ydHMuUmVhY3Rpb24gPSBSZWFjdGlvbjtcbmV4cG9ydHMuX2FsbG93U3RhdGVDaGFuZ2VzID0gYWxsb3dTdGF0ZUNoYW5nZXM7XG5leHBvcnRzLl9hbGxvd1N0YXRlQ2hhbmdlc0luc2lkZUNvbXB1dGVkID0gcnVuSW5BY3Rpb247XG5leHBvcnRzLl9hbGxvd1N0YXRlUmVhZHNFbmQgPSBhbGxvd1N0YXRlUmVhZHNFbmQ7XG5leHBvcnRzLl9hbGxvd1N0YXRlUmVhZHNTdGFydCA9IGFsbG93U3RhdGVSZWFkc1N0YXJ0O1xuZXhwb3J0cy5fYXV0b0FjdGlvbiA9IGF1dG9BY3Rpb247XG5leHBvcnRzLl9lbmRBY3Rpb24gPSBfZW5kQWN0aW9uO1xuZXhwb3J0cy5fZ2V0QWRtaW5pc3RyYXRpb24gPSBnZXRBZG1pbmlzdHJhdGlvbjtcbmV4cG9ydHMuX2dldEdsb2JhbFN0YXRlID0gZ2V0R2xvYmFsU3RhdGU7XG5leHBvcnRzLl9pbnRlcmNlcHRSZWFkcyA9IGludGVyY2VwdFJlYWRzO1xuZXhwb3J0cy5faXNDb21wdXRpbmdEZXJpdmF0aW9uID0gaXNDb21wdXRpbmdEZXJpdmF0aW9uO1xuZXhwb3J0cy5fcmVzZXRHbG9iYWxTdGF0ZSA9IHJlc2V0R2xvYmFsU3RhdGU7XG5leHBvcnRzLl9zdGFydEFjdGlvbiA9IF9zdGFydEFjdGlvbjtcbmV4cG9ydHMuYWN0aW9uID0gYWN0aW9uO1xuZXhwb3J0cy5hdXRvcnVuID0gYXV0b3J1bjtcbmV4cG9ydHMuY29tcGFyZXIgPSBjb21wYXJlcjtcbmV4cG9ydHMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbmV4cG9ydHMuY29uZmlndXJlID0gY29uZmlndXJlO1xuZXhwb3J0cy5jcmVhdGVBdG9tID0gY3JlYXRlQXRvbTtcbmV4cG9ydHMuZGVmaW5lUHJvcGVydHkgPSBhcGlEZWZpbmVQcm9wZXJ0eTtcbmV4cG9ydHMuZW50cmllcyA9IGVudHJpZXM7XG5leHBvcnRzLmV4dGVuZE9ic2VydmFibGUgPSBleHRlbmRPYnNlcnZhYmxlO1xuZXhwb3J0cy5mbG93ID0gZmxvdztcbmV4cG9ydHMuZmxvd1Jlc3VsdCA9IGZsb3dSZXN1bHQ7XG5leHBvcnRzLmdldCA9IGdldDtcbmV4cG9ydHMuZ2V0QXRvbSA9IGdldEF0b207XG5leHBvcnRzLmdldERlYnVnTmFtZSA9IGdldERlYnVnTmFtZTtcbmV4cG9ydHMuZ2V0RGVwZW5kZW5jeVRyZWUgPSBnZXREZXBlbmRlbmN5VHJlZTtcbmV4cG9ydHMuZ2V0T2JzZXJ2ZXJUcmVlID0gZ2V0T2JzZXJ2ZXJUcmVlO1xuZXhwb3J0cy5oYXMgPSBoYXM7XG5leHBvcnRzLmludGVyY2VwdCA9IGludGVyY2VwdDtcbmV4cG9ydHMuaXNBY3Rpb24gPSBpc0FjdGlvbjtcbmV4cG9ydHMuaXNCb3hlZE9ic2VydmFibGUgPSBpc09ic2VydmFibGVWYWx1ZTtcbmV4cG9ydHMuaXNDb21wdXRlZCA9IGlzQ29tcHV0ZWQ7XG5leHBvcnRzLmlzQ29tcHV0ZWRQcm9wID0gaXNDb21wdXRlZFByb3A7XG5leHBvcnRzLmlzRmxvdyA9IGlzRmxvdztcbmV4cG9ydHMuaXNGbG93Q2FuY2VsbGF0aW9uRXJyb3IgPSBpc0Zsb3dDYW5jZWxsYXRpb25FcnJvcjtcbmV4cG9ydHMuaXNPYnNlcnZhYmxlID0gaXNPYnNlcnZhYmxlO1xuZXhwb3J0cy5pc09ic2VydmFibGVBcnJheSA9IGlzT2JzZXJ2YWJsZUFycmF5O1xuZXhwb3J0cy5pc09ic2VydmFibGVNYXAgPSBpc09ic2VydmFibGVNYXA7XG5leHBvcnRzLmlzT2JzZXJ2YWJsZU9iamVjdCA9IGlzT2JzZXJ2YWJsZU9iamVjdDtcbmV4cG9ydHMuaXNPYnNlcnZhYmxlUHJvcCA9IGlzT2JzZXJ2YWJsZVByb3A7XG5leHBvcnRzLmlzT2JzZXJ2YWJsZVNldCA9IGlzT2JzZXJ2YWJsZVNldDtcbmV4cG9ydHMua2V5cyA9IGtleXM7XG5leHBvcnRzLm1ha2VBdXRvT2JzZXJ2YWJsZSA9IG1ha2VBdXRvT2JzZXJ2YWJsZTtcbmV4cG9ydHMubWFrZU9ic2VydmFibGUgPSBtYWtlT2JzZXJ2YWJsZTtcbmV4cG9ydHMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG5leHBvcnRzLm9ic2VydmUgPSBvYnNlcnZlO1xuZXhwb3J0cy5vbkJlY29tZU9ic2VydmVkID0gb25CZWNvbWVPYnNlcnZlZDtcbmV4cG9ydHMub25CZWNvbWVVbm9ic2VydmVkID0gb25CZWNvbWVVbm9ic2VydmVkO1xuZXhwb3J0cy5vblJlYWN0aW9uRXJyb3IgPSBvblJlYWN0aW9uRXJyb3I7XG5leHBvcnRzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG5leHBvcnRzLm93bktleXMgPSBhcGlPd25LZXlzO1xuZXhwb3J0cy5yZWFjdGlvbiA9IHJlYWN0aW9uO1xuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG5leHBvcnRzLnJ1bkluQWN0aW9uID0gcnVuSW5BY3Rpb247XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuc3B5ID0gc3B5O1xuZXhwb3J0cy50b0pTID0gdG9KUztcbmV4cG9ydHMudHJhY2UgPSB0cmFjZTtcbmV4cG9ydHMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbmV4cG9ydHMudW50cmFja2VkID0gdW50cmFja2VkO1xuZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5leHBvcnRzLndoZW4gPSB3aGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9ieC5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iLCJmdW5jdGlvbiB0KHQpe2Zvcih2YXIgbj1hcmd1bWVudHMubGVuZ3RoLGk9bmV3IEFycmF5KG4+MT9uLTE6MCkscj0xO3I8bjtyKyspaVtyLTFdPWFyZ3VtZW50c1tyXTt0aHJvdyBuZXcgRXJyb3IoXCJudW1iZXJcIj09dHlwZW9mIHQ/XCJbTW9iWF0gbWluaWZpZWQgZXJyb3IgbnI6IFwiK3QrKGkubGVuZ3RoP1wiIFwiK2kubWFwKFN0cmluZykuam9pbihcIixcIik6XCJcIikrXCIuIEZpbmQgdGhlIGZ1bGwgZXJyb3IgYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9ibG9iL21haW4vcGFja2FnZXMvbW9ieC9zcmMvZXJyb3JzLnRzXCI6XCJbTW9iWF0gXCIrdCl9ZnVuY3Rpb24gbigpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp4bn1mdW5jdGlvbiBpKCl7Vm58fHQoXCJQcm94eSBub3QgYXZhaWxhYmxlXCIpfWZ1bmN0aW9uIHIodCl7dmFyIG49ITE7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoIW4pcmV0dXJuIG49ITAsdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIGUodCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdH1mdW5jdGlvbiBvKHQpe3N3aXRjaCh0eXBlb2YgdCl7Y2FzZVwic3RyaW5nXCI6Y2FzZVwic3ltYm9sXCI6Y2FzZVwibnVtYmVyXCI6cmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gdSh0KXtyZXR1cm4gbnVsbCE9PXQmJlwib2JqZWN0XCI9PXR5cGVvZiB0fWZ1bmN0aW9uIHModCl7dmFyIG47aWYoIXUodCkpcmV0dXJuITE7dmFyIGk9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO3JldHVybiBudWxsPT1pfHwobnVsbD09KG49aS5jb25zdHJ1Y3Rvcik/dm9pZCAwOm4udG9TdHJpbmcoKSk9PT1Obn1mdW5jdGlvbiBmKHQpe3ZhciBuPW51bGw9PXQ/dm9pZCAwOnQuY29uc3RydWN0b3I7cmV0dXJuISFuJiYoXCJHZW5lcmF0b3JGdW5jdGlvblwiPT09bi5uYW1lfHxcIkdlbmVyYXRvckZ1bmN0aW9uXCI9PT1uLmRpc3BsYXlOYW1lKX1mdW5jdGlvbiBhKHQsbixpKXtnbih0LG4se2VudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwLHZhbHVlOml9KX1mdW5jdGlvbiBjKHQsbixpKXtnbih0LG4se2VudW1lcmFibGU6ITEsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwLHZhbHVlOml9KX1mdW5jdGlvbiBoKHQsbil7dmFyIGk9XCJpc01vYlhcIit0O3JldHVybiBuLnByb3RvdHlwZVtpXT0hMCxmdW5jdGlvbih0KXtyZXR1cm4gdSh0KSYmITA9PT10W2ldfX1mdW5jdGlvbiB2KHQpe3JldHVybiB0IGluc3RhbmNlb2YgTWFwfWZ1bmN0aW9uIGwodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBTZXR9ZnVuY3Rpb24gZCh0KXtyZXR1cm4gbnVsbD09PXQ/bnVsbDpcIm9iamVjdFwiPT10eXBlb2YgdD9cIlwiK3Q6dH1mdW5jdGlvbiBiKHQsbil7cmV0dXJuIF9uLmhhc093blByb3BlcnR5LmNhbGwodCxuKX1mdW5jdGlvbiBwKHQsbil7Zm9yKHZhciBpPTA7aTxuLmxlbmd0aDtpKyspe3ZhciByPW5baV07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1mdW5jdGlvbiB5KHQsbixpKXtyZXR1cm4gbiYmcCh0LnByb3RvdHlwZSxuKSxpJiZwKHQsaSksdH1mdW5jdGlvbiBtKCl7cmV0dXJuKG09T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl7dmFyIGk9YXJndW1lbnRzW25dO2Zvcih2YXIgciBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLHIpJiYodFtyXT1pW3JdKX1yZXR1cm4gdH0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiB3KHQsbil7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShuLnByb3RvdHlwZSksdC5wcm90b3R5cGUuY29uc3RydWN0b3I9dCx0Ll9fcHJvdG9fXz1ufWZ1bmN0aW9uIGoodCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9ZnVuY3Rpb24geCh0LG4peyhudWxsPT1ufHxuPnQubGVuZ3RoKSYmKG49dC5sZW5ndGgpO2Zvcih2YXIgaT0wLHI9bmV3IEFycmF5KG4pO2k8bjtpKyspcltpXT10W2ldO3JldHVybiByfWZ1bmN0aW9uIE8odCxuKXt2YXIgaTtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU3ltYm9sfHxudWxsPT10W1N5bWJvbC5pdGVyYXRvcl0pe2lmKEFycmF5LmlzQXJyYXkodCl8fChpPWZ1bmN0aW9uKHQpe2lmKHQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXJldHVybiB4KHQsdm9pZCAwKTt2YXIgbj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkuc2xpY2UoOCwtMSk7cmV0dXJuXCJPYmplY3RcIj09PW4mJnQuY29uc3RydWN0b3ImJihuPXQuY29uc3RydWN0b3IubmFtZSksXCJNYXBcIj09PW58fFwiU2V0XCI9PT1uP0FycmF5LmZyb20odCk6XCJBcmd1bWVudHNcIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pP3godCx2b2lkIDApOnZvaWQgMH19KHQpKXx8biYmdCYmXCJudW1iZXJcIj09dHlwZW9mIHQubGVuZ3RoKXtpJiYodD1pKTt2YXIgcj0wO3JldHVybiBmdW5jdGlvbigpe3JldHVybiByPj10Lmxlbmd0aD97ZG9uZTohMH06e2RvbmU6ITEsdmFsdWU6dFtyKytdfX19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXJldHVybihpPXRbU3ltYm9sLml0ZXJhdG9yXSgpKS5uZXh0LmJpbmQoaSl9ZnVuY3Rpb24gQSh0KXtyZXR1cm4gT2JqZWN0LmFzc2lnbigoZnVuY3Rpb24obixpKXtnKG4saSx0KX0pLHQpfWZ1bmN0aW9uIGcodCxuLGkpe2IodCxDbil8fGEodCxDbixtKHt9LHRbQ25dKSksZnVuY3Rpb24odCl7cmV0dXJuXCJvdmVycmlkZVwiPT09dC50fShpKXx8KHRbQ25dW25dPWkpfWZ1bmN0aW9uIF8odCxuLGkpe3ZvaWQgMD09PW4mJihuPVJuKSx2b2lkIDA9PT1pJiYoaT1Sbik7dmFyIHI9bmV3IExuKHQpO3JldHVybiBuIT09Um4mJlN0KHIsbiksaSE9PVJuJiZNdChyLGkpLHJ9ZnVuY3Rpb24gUyh0LG4saSl7cmV0dXJuIEl0KHQpP3Q6QXJyYXkuaXNBcnJheSh0KT8kbi5hcnJheSh0LHtuYW1lOml9KTpzKHQpPyRuLm9iamVjdCh0LHZvaWQgMCx7bmFtZTppfSk6dih0KT8kbi5tYXAodCx7bmFtZTppfSk6bCh0KT8kbi5zZXQodCx7bmFtZTppfSk6XCJmdW5jdGlvblwiIT10eXBlb2YgdHx8QXQodCl8fEN0KHQpP3Q6Zih0KT9SaSh0KTpfaShpLHQpfWZ1bmN0aW9uIE0odCl7cmV0dXJuIHR9ZnVuY3Rpb24gVih0LG4pe3JldHVybnt0OnQsaTpuLG86Tix1OlJ9fWZ1bmN0aW9uIE4odCxuLGkscil7dmFyIGU7aWYobnVsbD09KGU9dGhpcy5pKT92b2lkIDA6ZS5ib3VuZClyZXR1cm4gbnVsbD09PXRoaXMudSh0LG4saSwhMSk/MDoxO2lmKHI9PT10LnMpcmV0dXJuIG51bGw9PT10aGlzLnUodCxuLGksITEpPzA6MjtpZihBdChpLnZhbHVlKSlyZXR1cm4gMTt2YXIgbz1rKHQsdGhpcyxuLGksITEpO3JldHVybiBnbihyLG4sbyksMn1mdW5jdGlvbiBSKHQsbixpLHIpe3ZhciBlPWsodCx0aGlzLG4saSk7cmV0dXJuIHQuaChuLGUscil9ZnVuY3Rpb24gayh0LG4saSxyLGUpe3ZhciBvLHUscyxmLGE7dm9pZCAwPT09ZSYmKGU9cGkuc2FmZURlc2NyaXB0b3JzKTt2YXIgYyxoPXIudmFsdWU7cmV0dXJuKG51bGw9PShvPW4uaSk/dm9pZCAwOm8uYm91bmQpJiYoaD1oLmJpbmQobnVsbCE9KGM9dC52KT9jOnQucykpLHt2YWx1ZTp6KG51bGwhPSh1PW51bGw9PShzPW4uaSk/dm9pZCAwOnMubmFtZSk/dTppLnRvU3RyaW5nKCksaCxudWxsIT0oZj1udWxsPT0oYT1uLmkpP3ZvaWQgMDphLmF1dG9BY3Rpb24pJiZmKSxjb25maWd1cmFibGU6IWV8fHQubCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiFlfX1mdW5jdGlvbiBFKHQsbil7cmV0dXJue3Q6dCxpOm4sbzpULHU6Q319ZnVuY3Rpb24gVCh0LG4saSxyKXt2YXIgZTtpZihyPT09dC5zKXJldHVybiBudWxsPT09dGhpcy51KHQsbixpLCExKT8wOjI7aWYoKG51bGw9PShlPXRoaXMuaSk/dm9pZCAwOmUuYm91bmQpJiYhQ3QodC5zW25dKSYmbnVsbD09PXRoaXMudSh0LG4saSwhMSkpcmV0dXJuIDA7aWYoQ3QoaS52YWx1ZSkpcmV0dXJuIDE7dmFyIG89Syh0LDAsMCxpLCExLCExKTtyZXR1cm4gZ24ocixuLG8pLDJ9ZnVuY3Rpb24gQyh0LG4saSxyKXt2YXIgZSxvPUsodCwwLDAsaSxudWxsPT0oZT10aGlzLmkpP3ZvaWQgMDplLmJvdW5kKTtyZXR1cm4gdC5oKG4sbyxyKX1mdW5jdGlvbiBLKHQsbixpLHIsZSxvKXt2b2lkIDA9PT1vJiYobz1waS5zYWZlRGVzY3JpcHRvcnMpO3ZhciB1LHM9ci52YWx1ZTtyZXR1cm4gZSYmKHM9cy5iaW5kKG51bGwhPSh1PXQudik/dTp0LnMpKSx7dmFsdWU6UmkocyksY29uZmlndXJhYmxlOiFvfHx0LmwsZW51bWVyYWJsZTohMSx3cml0YWJsZTohb319ZnVuY3Rpb24gTCh0LG4pe3JldHVybnt0OnQsaTpuLG86SSx1OlB9fWZ1bmN0aW9uIEkodCxuLGkpe3JldHVybiBudWxsPT09dGhpcy51KHQsbixpLCExKT8wOjF9ZnVuY3Rpb24gUCh0LG4saSxyKXtyZXR1cm4gdC5wKG4sbSh7fSx0aGlzLmkse2dldDppLmdldCxzZXQ6aS5zZXR9KSxyKX1mdW5jdGlvbiBEKHQsbil7cmV0dXJue3Q6dCxpOm4sbzpCLHU6cX19ZnVuY3Rpb24gQih0LG4saSl7cmV0dXJuIG51bGw9PT10aGlzLnUodCxuLGksITEpPzA6MX1mdW5jdGlvbiBxKHQsbixpLHIpe3ZhciBlLG87cmV0dXJuIHQubShuLGkudmFsdWUsbnVsbCE9KGU9bnVsbD09KG89dGhpcy5pKT92b2lkIDA6by5lbmhhbmNlcik/ZTpTLHIpfWZ1bmN0aW9uIEcodCl7cmV0dXJue3Q6XCJ0cnVlXCIsaTp0LG86WCx1Old9fWZ1bmN0aW9uIFgodCxuLGkscil7dmFyIGUsbyx1LHM7aWYoaS5nZXQpcmV0dXJuIFFuLm8odCxuLGkscik7aWYoaS5zZXQpe3ZhciBhPXoobi50b1N0cmluZygpLGkuc2V0KTtyZXR1cm4gcj09PXQucz9udWxsPT09dC5oKG4se2NvbmZpZ3VyYWJsZTohcGkuc2FmZURlc2NyaXB0b3JzfHx0Lmwsc2V0OmF9KT8wOjI6KGduKHIsbix7Y29uZmlndXJhYmxlOiEwLHNldDphfSksMil9aWYociE9PXQucyYmXCJmdW5jdGlvblwiPT10eXBlb2YgaS52YWx1ZSlyZXR1cm4gZihpLnZhbHVlKT8oKG51bGw9PShzPXRoaXMuaSk/dm9pZCAwOnMuYXV0b0JpbmQpP1JpLmJvdW5kOlJpKS5vKHQsbixpLHIpOigobnVsbD09KHU9dGhpcy5pKT92b2lkIDA6dS5hdXRvQmluZCk/X2kuYm91bmQ6X2kpLm8odCxuLGkscik7dmFyIGMsaD0hMT09PShudWxsPT0oZT10aGlzLmkpP3ZvaWQgMDplLmRlZXApPyRuLnJlZjokbjtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBpLnZhbHVlJiYobnVsbD09KG89dGhpcy5pKT92b2lkIDA6by5hdXRvQmluZCkmJihpLnZhbHVlPWkudmFsdWUuYmluZChudWxsIT0oYz10LnYpP2M6dC5zKSksaC5vKHQsbixpLHIpfWZ1bmN0aW9uIFcodCxuLGkscil7dmFyIGUsbyx1O3JldHVybiBpLmdldD9Rbi51KHQsbixpLHIpOmkuc2V0P3QuaChuLHtjb25maWd1cmFibGU6IXBpLnNhZmVEZXNjcmlwdG9yc3x8dC5sLHNldDp6KG4udG9TdHJpbmcoKSxpLnNldCl9LHIpOihcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLnZhbHVlJiYobnVsbD09KGU9dGhpcy5pKT92b2lkIDA6ZS5hdXRvQmluZCkmJihpLnZhbHVlPWkudmFsdWUuYmluZChudWxsIT0odT10LnYpP3U6dC5zKSksKCExPT09KG51bGw9PShvPXRoaXMuaSk/dm9pZCAwOm8uZGVlcCk/JG4ucmVmOiRuKS51KHQsbixpLHIpKX1mdW5jdGlvbiBIKHQpe3JldHVybiB0fHxxbn1mdW5jdGlvbiBVKHQpe3JldHVybiEwPT09dC5kZWVwP1M6ITE9PT10LmRlZXA/TToobj10LmRlZmF1bHREZWNvcmF0b3IpJiZudWxsIT0oaT1udWxsPT0ocj1uLmkpP3ZvaWQgMDpyLmVuaGFuY2VyKT9pOlM7dmFyIG4saSxyfWZ1bmN0aW9uIEYodCxuLGkpe2lmKCFvKG4pKXJldHVybiBJdCh0KT90OnModCk/JG4ub2JqZWN0KHQsbixpKTpBcnJheS5pc0FycmF5KHQpPyRuLmFycmF5KHQsbik6dih0KT8kbi5tYXAodCxuKTpsKHQpPyRuLnNldCh0LG4pOlwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT09dD90OiRuLmJveCh0LG4pO2codCxuLEduKX1mdW5jdGlvbiB6KHQsbixpLHIpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gJCgwLGksbixyfHx0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIHZvaWQgMD09PWkmJihpPSExKSxlLmlzTW9ieEFjdGlvbj0hMCxpaSYmKHJpLnZhbHVlPXQsT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJuYW1lXCIscmkpKSxlfWZ1bmN0aW9uICQodCxuLGkscixlKXt2YXIgbz1KKDAsbik7dHJ5e3JldHVybiBpLmFwcGx5KHIsZSl9Y2F0Y2godCl7dGhyb3cgby5qPXQsdH1maW5hbGx5e1kobyl9fWZ1bmN0aW9uIEoodCxuKXt2YXIgaT1waS50cmFja2luZ0Rlcml2YXRpb24scj0hbnx8IWk7ZHQoKTt2YXIgZT1waS5hbGxvd1N0YXRlQ2hhbmdlcztyJiYodXQoKSxlPVooITApKTt2YXIgbz17TzpyLEE6aSxnOmUsXzpmdCghMCksUzohMSxNOjAsVjpuaSsrLE46dGl9O3JldHVybiB0aT1vLlYsb31mdW5jdGlvbiBZKG4pe3RpIT09bi5WJiZ0KDMwKSx0aT1uLk4sdm9pZCAwIT09bi5qJiYocGkuc3VwcHJlc3NSZWFjdGlvbkVycm9ycz0hMCksdHQobi5nKSxhdChuLl8pLGJ0KCksbi5PJiZzdChuLkEpLHBpLnN1cHByZXNzUmVhY3Rpb25FcnJvcnM9ITF9ZnVuY3Rpb24gUSh0LG4pe3ZhciBpPVoodCk7dHJ5e3JldHVybiBuKCl9ZmluYWxseXt0dChpKX19ZnVuY3Rpb24gWih0KXt2YXIgbj1waS5hbGxvd1N0YXRlQ2hhbmdlcztyZXR1cm4gcGkuYWxsb3dTdGF0ZUNoYW5nZXM9dCxufWZ1bmN0aW9uIHR0KHQpe3BpLmFsbG93U3RhdGVDaGFuZ2VzPXR9ZnVuY3Rpb24gbnQodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBoaX1mdW5jdGlvbiBpdCh0KXtzd2l0Y2godC5SKXtjYXNlIHNpLms6cmV0dXJuITE7Y2FzZSBzaS5UOmNhc2Ugc2kuQzpyZXR1cm4hMDtjYXNlIHNpLks6Zm9yKHZhciBuPWZ0KCEwKSxpPXV0KCkscj10LkwsZT1yLmxlbmd0aCxvPTA7bzxlO28rKyl7dmFyIHU9cltvXTtpZihjaSh1KSl7aWYocGkuZGlzYWJsZUVycm9yQm91bmRhcmllcyl1LmdldCgpO2Vsc2UgdHJ5e3UuZ2V0KCl9Y2F0Y2godCl7cmV0dXJuIHN0KGkpLGF0KG4pLCEwfWlmKHQuUj09PXNpLkMpcmV0dXJuIHN0KGkpLGF0KG4pLCEwfX1yZXR1cm4gY3QodCksc3QoaSksYXQobiksITF9fWZ1bmN0aW9uIHJ0KHQsbixpKXt2YXIgcj1mdCghMCk7Y3QodCksdC5JPW5ldyBBcnJheSh0LkwubGVuZ3RoKzEwMCksdC5QPTAsdC5EPSsrcGkucnVuSWQ7dmFyIGUsbz1waS50cmFja2luZ0Rlcml2YXRpb247aWYocGkudHJhY2tpbmdEZXJpdmF0aW9uPXQscGkuaW5CYXRjaCsrLCEwPT09cGkuZGlzYWJsZUVycm9yQm91bmRhcmllcyllPW4uY2FsbChpKTtlbHNlIHRyeXtlPW4uY2FsbChpKX1jYXRjaCh0KXtlPW5ldyBoaSh0KX1yZXR1cm4gcGkuaW5CYXRjaC0tLHBpLnRyYWNraW5nRGVyaXZhdGlvbj1vLGZ1bmN0aW9uKHQpe2Zvcih2YXIgbj10LkwsaT10Lkw9dC5JLHI9c2kuayxlPTAsbz10LlAsdT0wO3U8bzt1Kyspe3ZhciBzPWlbdV07MD09PXMuQiYmKHMuQj0xLGUhPT11JiYoaVtlXT1zKSxlKyspLHMuUj5yJiYocj1zLlIpfWZvcihpLmxlbmd0aD1lLHQuST1udWxsLG89bi5sZW5ndGg7by0tOyl7dmFyIGY9bltvXTswPT09Zi5CJiZ2dChmLHQpLGYuQj0wfWZvcig7ZS0tOyl7dmFyIGE9aVtlXTsxPT09YS5CJiYoYS5CPTAsaHQoYSx0KSl9ciE9PXNpLmsmJih0LlI9cix0LnEoKSl9KHQpLGF0KHIpLGV9ZnVuY3Rpb24gZXQodCl7dmFyIG49dC5MO3QuTD1bXTtmb3IodmFyIGk9bi5sZW5ndGg7aS0tOyl2dChuW2ldLHQpO3QuUj1zaS5UfWZ1bmN0aW9uIG90KHQpe3ZhciBuPXV0KCk7dHJ5e3JldHVybiB0KCl9ZmluYWxseXtzdChuKX19ZnVuY3Rpb24gdXQoKXt2YXIgdD1waS50cmFja2luZ0Rlcml2YXRpb247cmV0dXJuIHBpLnRyYWNraW5nRGVyaXZhdGlvbj1udWxsLHR9ZnVuY3Rpb24gc3QodCl7cGkudHJhY2tpbmdEZXJpdmF0aW9uPXR9ZnVuY3Rpb24gZnQodCl7dmFyIG49cGkuYWxsb3dTdGF0ZVJlYWRzO3JldHVybiBwaS5hbGxvd1N0YXRlUmVhZHM9dCxufWZ1bmN0aW9uIGF0KHQpe3BpLmFsbG93U3RhdGVSZWFkcz10fWZ1bmN0aW9uIGN0KHQpe2lmKHQuUiE9PXNpLmspe3QuUj1zaS5rO2Zvcih2YXIgbj10LkwsaT1uLmxlbmd0aDtpLS07KW5baV0uRz1zaS5rfX1mdW5jdGlvbiBodCh0LG4pe3QuWC5hZGQobiksdC5HPm4uUiYmKHQuRz1uLlIpfWZ1bmN0aW9uIHZ0KHQsbil7dC5YLmRlbGV0ZShuKSwwPT09dC5YLnNpemUmJmx0KHQpfWZ1bmN0aW9uIGx0KHQpeyExPT09dC5XJiYodC5XPSEwLHBpLnBlbmRpbmdVbm9ic2VydmF0aW9ucy5wdXNoKHQpKX1mdW5jdGlvbiBkdCgpe3BpLmluQmF0Y2grK31mdW5jdGlvbiBidCgpe2lmKDA9PS0tcGkuaW5CYXRjaCl7bXQoKTtmb3IodmFyIHQ9cGkucGVuZGluZ1Vub2JzZXJ2YXRpb25zLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIGk9dFtuXTtpLlc9ITEsMD09PWkuWC5zaXplJiYoaS5IJiYoaS5IPSExLGkub25CVU8oKSksaSBpbnN0YW5jZW9mIGFpJiZpLlUoKSl9cGkucGVuZGluZ1Vub2JzZXJ2YXRpb25zPVtdfX1mdW5jdGlvbiBwdCh0KXt2YXIgbj1waS50cmFja2luZ0Rlcml2YXRpb247cmV0dXJuIG51bGwhPT1uPyhuLkQhPT10LkYmJih0LkY9bi5ELG4uSVtuLlArK109dCwhdC5IJiZwaS50cmFja2luZ0NvbnRleHQmJih0Lkg9ITAsdC5vbkJPKCkpKSwhMCk6KDA9PT10Llguc2l6ZSYmcGkuaW5CYXRjaD4wJiZsdCh0KSwhMSl9ZnVuY3Rpb24geXQodCl7dC5HIT09c2kuQyYmKHQuRz1zaS5DLHQuWC5mb3JFYWNoKChmdW5jdGlvbih0KXt0LlI9PT1zaS5rJiZ0LnEoKSx0LlI9c2kuQ30pKSl9ZnVuY3Rpb24gbXQoKXtwaS5pbkJhdGNoPjB8fHBpLmlzUnVubmluZ1JlYWN0aW9uc3x8bWkod3QpfWZ1bmN0aW9uIHd0KCl7cGkuaXNSdW5uaW5nUmVhY3Rpb25zPSEwO2Zvcih2YXIgdD1waS5wZW5kaW5nUmVhY3Rpb25zLG49MDt0Lmxlbmd0aD4wOyl7MTAwPT0rK24mJihjb25zb2xlLmVycm9yKFwiW21vYnhdIGN5Y2xlIGluIHJlYWN0aW9uOiBcIit0WzBdKSx0LnNwbGljZSgwKSk7Zm9yKHZhciBpPXQuc3BsaWNlKDApLHI9MCxlPWkubGVuZ3RoO3I8ZTtyKyspaVtyXS4kKCl9cGkuaXNSdW5uaW5nUmVhY3Rpb25zPSExfWZ1bmN0aW9uIGp0KCl7cmV0dXJuIGNvbnNvbGUud2FybihcIlttb2J4LnNweV0gSXMgYSBuby1vcCBpbiBwcm9kdWN0aW9uIGJ1aWxkc1wiKSxmdW5jdGlvbigpe319ZnVuY3Rpb24geHQodCl7cmV0dXJuIGZ1bmN0aW9uKG4saSl7cmV0dXJuIGUobik/eihuLm5hbWV8fFwiPHVubmFtZWQgYWN0aW9uPlwiLG4sdCk6ZShpKT96KG4saSx0KTpvKGkpP2cobixpLHQ/T2k6amkpOm8obik/QShWKHQ/XCJhdXRvQWN0aW9uXCI6XCJhY3Rpb25cIix7bmFtZTpuLGF1dG9BY3Rpb246dH0pKTp2b2lkIDB9fWZ1bmN0aW9uIE90KHQpe3JldHVybiAkKDAsITEsdCx0aGlzLHZvaWQgMCl9ZnVuY3Rpb24gQXQodCl7cmV0dXJuIGUodCkmJiEwPT09dC5pc01vYnhBY3Rpb259ZnVuY3Rpb24gZ3QodCxuKXtmdW5jdGlvbiBpKCl7dChvKX12YXIgcixlO3ZvaWQgMD09PW4mJihuPU1uKTt2YXIgbyx1PW51bGwhPShyPW51bGw9PShlPW4pP3ZvaWQgMDplLm5hbWUpP3I6XCJBdXRvcnVuXCI7aWYobi5zY2hlZHVsZXJ8fG4uZGVsYXkpe3ZhciBzPV90KG4pLGY9ITE7bz1uZXcgeWkodSwoZnVuY3Rpb24oKXtmfHwoZj0hMCxzKChmdW5jdGlvbigpe2Y9ITEsby5KfHxvLnRyYWNrKGkpfSkpKX0pLG4ub25FcnJvcixuLnJlcXVpcmVzT2JzZXJ2YWJsZSl9ZWxzZSBvPW5ldyB5aSh1LChmdW5jdGlvbigpe3RoaXMudHJhY2soaSl9KSxuLm9uRXJyb3Isbi5yZXF1aXJlc09ic2VydmFibGUpO3JldHVybiBvLlkoKSxvLlooKX1mdW5jdGlvbiBfdCh0KXtyZXR1cm4gdC5zY2hlZHVsZXI/dC5zY2hlZHVsZXI6dC5kZWxheT9mdW5jdGlvbihuKXtyZXR1cm4gc2V0VGltZW91dChuLHQuZGVsYXkpfTpTaX1mdW5jdGlvbiBTdCh0LG4saSl7cmV0dXJuIFZ0KFwib25CT1wiLHQsbixpKX1mdW5jdGlvbiBNdCh0LG4saSl7cmV0dXJuIFZ0KFwib25CVU9cIix0LG4saSl9ZnVuY3Rpb24gVnQodCxuLGkscil7dmFyIG89XCJmdW5jdGlvblwiPT10eXBlb2Ygcj9kbihuLGkpOmRuKG4pLHU9ZShyKT9yOmkscz10K1wiTFwiO3JldHVybiBvW3NdP29bc10uYWRkKHUpOm9bc109bmV3IFNldChbdV0pLGZ1bmN0aW9uKCl7dmFyIHQ9b1tzXTt0JiYodC5kZWxldGUodSksMD09PXQuc2l6ZSYmZGVsZXRlIG9bc10pfX1mdW5jdGlvbiBOdCh0LG4saSxyKXt2YXIgZT1UbihuKSxvPXNuKHQscilbS25dO2R0KCk7dHJ5e0VuKGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe28udSh0LGVbdF0sIWl8fCEodCBpbiBpKXx8aVt0XSl9KSl9ZmluYWxseXtidCgpfXJldHVybiB0fWZ1bmN0aW9uIFJ0KHQpe3ZhciBuLGk9e25hbWU6dC50dH07cmV0dXJuIHQuTCYmdC5MLmxlbmd0aD4wJiYoaS5kZXBlbmRlbmNpZXM9KG49dC5MLEFycmF5LmZyb20obmV3IFNldChuKSkpLm1hcChSdCkpLGl9ZnVuY3Rpb24ga3QodCl7dmFyIG49e25hbWU6dC50dH07cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiB0LlgmJnQuWC5zaXplPjB9KHQpJiYobi5vYnNlcnZlcnM9QXJyYXkuZnJvbShmdW5jdGlvbih0KXtyZXR1cm4gdC5YfSh0KSkubWFwKGt0KSksbn1mdW5jdGlvbiBFdCgpe3RoaXMubWVzc2FnZT1cIkZMT1dfQ0FOQ0VMTEVEXCJ9ZnVuY3Rpb24gVHQodCl7ZSh0LmNhbmNlbCkmJnQuY2FuY2VsKCl9ZnVuY3Rpb24gQ3QodCl7cmV0dXJuITA9PT0obnVsbD09dD92b2lkIDA6dC5pc01vYlhGbG93KX1mdW5jdGlvbiBLdCh0LG4pe2lmKHZvaWQgMCE9PW4pe2lmKCExPT09YW4odCkpcmV0dXJuITE7aWYoIXRbS25dLm50LmhhcyhuKSlyZXR1cm4hMTt2YXIgaT1kbih0LG4pO3JldHVybiBjaShpKX1yZXR1cm4gY2kodCl9ZnVuY3Rpb24gTHQodCxuKXtyZXR1cm4hIXQmJih2b2lkIDAhPT1uPyEhYW4odCkmJnRbS25dLm50LmhhcyhuKTphbih0KXx8ISF0W0tuXXx8SW4odCl8fHdpKHQpfHxjaSh0KSl9ZnVuY3Rpb24gSXQodCl7cmV0dXJuIEx0KHQpfWZ1bmN0aW9uIFB0KG4pe3JldHVybiBhbihuKT9uW0tuXS5pdCgpOkhpKG4pfHxKaShuKT9BcnJheS5mcm9tKG4ua2V5cygpKTp1bihuKT9uLm1hcCgoZnVuY3Rpb24odCxuKXtyZXR1cm4gbn0pKTp2b2lkIHQoNSl9ZnVuY3Rpb24gRHQobixpKXtyZXR1cm4gYW4obik/bltLbl0ucnQoaSk6SGkobil8fEppKG4pP24uaGFzKGkpOnVuKG4pP2k+PTAmJmk8bi5sZW5ndGg6dm9pZCB0KDEwKX1mdW5jdGlvbiBCdChuKXtpZihhbihuKSlyZXR1cm4gbltLbl0uZXQoKTt0KDM4KX1mdW5jdGlvbiBxdCh0LG4saSl7cmV0dXJuIHQuc2V0KG4saSksaX1mdW5jdGlvbiBHdCgpe3QoXCJ0cmFjZSgpIGlzIG5vdCBhdmFpbGFibGUgaW4gcHJvZHVjdGlvbiBidWlsZHNcIik7Zm9yKHZhciBuPSExLGk9YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheShpKSxlPTA7ZTxpO2UrKylyW2VdPWFyZ3VtZW50c1tlXTtcImJvb2xlYW5cIj09dHlwZW9mIHJbci5sZW5ndGgtMV0mJihuPXIucG9wKCkpO3ZhciBvPVh0KHIpO2lmKCFvKXJldHVybiB0KFwiJ3RyYWNlKGJyZWFrPyknIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgdHJhY2tlZCBjb21wdXRlZCB2YWx1ZSBvciBhIFJlYWN0aW9uLiBDb25zaWRlciBwYXNzaW5nIGluIHRoZSBjb21wdXRlZCB2YWx1ZSBvciByZWFjdGlvbiBleHBsaWNpdGx5XCIpO28ub3Q9PT1maS5OT05FJiZjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSAnXCIrby50dCtcIicgdHJhY2luZyBlbmFibGVkXCIpLG8ub3Q9bj9maS5CUkVBSzpmaS5MT0d9ZnVuY3Rpb24gWHQodCl7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHBpLnRyYWNraW5nRGVyaXZhdGlvbjtjYXNlIDE6cmV0dXJuIGRuKHRbMF0pO2Nhc2UgMjpyZXR1cm4gZG4odFswXSx0WzFdKX19ZnVuY3Rpb24gV3QodCxuKXt2b2lkIDA9PT1uJiYobj12b2lkIDApLGR0KCk7dHJ5e3JldHVybiB0LmFwcGx5KG4pfWZpbmFsbHl7YnQoKX19ZnVuY3Rpb24gSHQodCxuLGkpe3ZhciByO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBpLnRpbWVvdXQpe3ZhciBlPW5ldyBFcnJvcihcIldIRU5fVElNRU9VVFwiKTtyPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7aWYoIXVbS25dLkope2lmKHUoKSwhaS5vbkVycm9yKXRocm93IGU7aS5vbkVycm9yKGUpfX0pLGkudGltZW91dCl9aS5uYW1lPVwiV2hlblwiO3ZhciBvPXooXCJXaGVuLWVmZmVjdFwiLG4pLHU9Z3QoKGZ1bmN0aW9uKG4pe1EoITEsdCkmJihuLmRpc3Bvc2UoKSxyJiZjbGVhclRpbWVvdXQociksbygpKX0pLGkpO3JldHVybiB1fWZ1bmN0aW9uIFV0KHQsbil7dmFyIGkscj1uZXcgUHJvbWlzZSgoZnVuY3Rpb24ocixlKXt2YXIgbz1IdCh0LHIsbSh7fSxuLHtvbkVycm9yOmV9KSk7aT1mdW5jdGlvbigpe28oKSxlKFwiV0hFTl9DQU5DRUxMRURcIil9fSkpO3JldHVybiByLmNhbmNlbD1pLHJ9ZnVuY3Rpb24gRnQodCl7cmV0dXJuIHRbS25dfWZ1bmN0aW9uIHp0KHQpe3JldHVybiB2b2lkIDAhPT10LnV0JiZ0LnV0Lmxlbmd0aD4wfWZ1bmN0aW9uICR0KHQsbil7dmFyIGk9dC51dHx8KHQudXQ9W10pO3JldHVybiBpLnB1c2gobikscigoZnVuY3Rpb24oKXt2YXIgdD1pLmluZGV4T2Yobik7LTEhPT10JiZpLnNwbGljZSh0LDEpfSkpfWZ1bmN0aW9uIEp0KG4saSl7dmFyIHI9dXQoKTt0cnl7Zm9yKHZhciBlPVtdLmNvbmNhdChuLnV0fHxbXSksbz0wLHU9ZS5sZW5ndGg7bzx1JiYoKGk9ZVtvXShpKSkmJiFpLnR5cGUmJnQoMTQpLGkpO28rKyk7cmV0dXJuIGl9ZmluYWxseXtzdChyKX19ZnVuY3Rpb24gWXQodCl7cmV0dXJuIHZvaWQgMCE9PXQuc3QmJnQuc3QubGVuZ3RoPjB9ZnVuY3Rpb24gUXQodCxuKXt2YXIgaT10LnN0fHwodC5zdD1bXSk7cmV0dXJuIGkucHVzaChuKSxyKChmdW5jdGlvbigpe3ZhciB0PWkuaW5kZXhPZihuKTstMSE9PXQmJmkuc3BsaWNlKHQsMSl9KSl9ZnVuY3Rpb24gWnQodCxuKXt2YXIgaT11dCgpLHI9dC5zdDtpZihyKXtmb3IodmFyIGU9MCxvPShyPXIuc2xpY2UoKSkubGVuZ3RoO2U8bztlKyspcltlXShuKTtzdChpKX19ZnVuY3Rpb24gdG4odCxuLHIsZSl7dm9pZCAwPT09ciYmKHI9XCJPYnNlcnZhYmxlQXJyYXlcIiksdm9pZCAwPT09ZSYmKGU9ITEpLGkoKTt2YXIgbz1uZXcgS2kocixuLGUsITEpO2Moby5udCxLbixvKTt2YXIgdT1uZXcgUHJveHkoby5udCxDaSk7aWYoby52PXUsdCYmdC5sZW5ndGgpe3ZhciBzPVooITApO28uZnQoMCwwLHQpLHR0KHMpfXJldHVybiB1fWZ1bmN0aW9uIG5uKHQsbil7XCJmdW5jdGlvblwiPT10eXBlb2YgQXJyYXkucHJvdG90eXBlW3RdJiYoTGlbdF09bih0KSl9ZnVuY3Rpb24gcm4odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dGhpc1tLbl07bi5hdC5yZXBvcnRPYnNlcnZlZCgpO3ZhciBpPW4uY3Qobi5udCk7cmV0dXJuIGlbdF0uYXBwbHkoaSxhcmd1bWVudHMpfX1mdW5jdGlvbiBlbih0KXtyZXR1cm4gZnVuY3Rpb24obixpKXt2YXIgcj10aGlzLGU9dGhpc1tLbl07cmV0dXJuIGUuYXQucmVwb3J0T2JzZXJ2ZWQoKSxlLmN0KGUubnQpW3RdKChmdW5jdGlvbih0LGUpe3JldHVybiBuLmNhbGwoaSx0LGUscil9KSl9fWZ1bmN0aW9uIG9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXMsaT10aGlzW0tuXTtpLmF0LnJlcG9ydE9ic2VydmVkKCk7dmFyIHI9aS5jdChpLm50KSxlPWFyZ3VtZW50c1swXTtyZXR1cm4gYXJndW1lbnRzWzBdPWZ1bmN0aW9uKHQsaSxyKXtyZXR1cm4gZSh0LGkscixuKX0sclt0XS5hcHBseShyLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIHVuKHQpe3JldHVybiB1KHQpJiZEaSh0W0tuXSl9ZnVuY3Rpb24gc24odCxuKXt2YXIgaTtpZihiKHQsS24pKXJldHVybiB0O3ZhciByPW51bGwhPShpPW51bGw9PW4/dm9pZCAwOm4ubmFtZSk/aTpcIk9ic2VydmFibGVPYmplY3RcIixlPW5ldyBRaSh0LG5ldyBNYXAsU3RyaW5nKHIpLGZ1bmN0aW9uKHQpe3ZhciBuO3JldHVybiB0P251bGwhPShuPXQuZGVmYXVsdERlY29yYXRvcik/bjpHKHQpOnZvaWQgMH0obikpO3JldHVybiBhKHQsS24sZSksdH1mdW5jdGlvbiBmbih0KXtyZXR1cm4gWWlbdF18fChZaVt0XT17Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbS25dLmh0KHQpfSxzZXQ6ZnVuY3Rpb24obil7cmV0dXJuIHRoaXNbS25dLnZ0KHQsbil9fSl9ZnVuY3Rpb24gYW4odCl7cmV0dXJuISF1KHQpJiZaaSh0W0tuXSl9ZnVuY3Rpb24gY24odCxuLGkpe3ZhciByO251bGw9PShyPXQuc1tDbl0pfHxkZWxldGUgcltpXX1mdW5jdGlvbiBobih0KXtnbihpci5wcm90b3R5cGUsXCJcIit0LGZ1bmN0aW9uKHQpe3JldHVybntlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tLbl0ubHQodCl9LHNldDpmdW5jdGlvbihuKXt0aGlzW0tuXS5kdCh0LG4pfX19KHQpKX1mdW5jdGlvbiB2bih0KXtpZih0PnRyKXtmb3IodmFyIG49dHI7bjx0KzEwMDtuKyspaG4obik7dHI9dH19ZnVuY3Rpb24gbG4odCxuLGkpe3JldHVybiBuZXcgaXIodCxuLGkpfWZ1bmN0aW9uIGRuKG4saSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIG4mJm51bGwhPT1uKXtpZih1bihuKSlyZXR1cm4gdm9pZCAwIT09aSYmdCgyMyksbltLbl0uYXQ7aWYoSmkobikpcmV0dXJuIG5bS25dO2lmKEhpKG4pKXtpZih2b2lkIDA9PT1pKXJldHVybiBuLmJ0O3ZhciByPW4ucHQuZ2V0KGkpfHxuLnl0LmdldChpKTtyZXR1cm4gcnx8dCgyNSxpLHBuKG4pKSxyfWlmKGFuKG4pKXtpZighaSlyZXR1cm4gdCgyNik7dmFyIG89bltLbl0ubnQuZ2V0KGkpO3JldHVybiBvfHx0KDI3LGkscG4obikpLG99aWYoSW4obil8fGNpKG4pfHx3aShuKSlyZXR1cm4gbn1lbHNlIGlmKGUobikmJndpKG5bS25dKSlyZXR1cm4gbltLbl07dCgyOCl9ZnVuY3Rpb24gYm4obixpKXtyZXR1cm4gbnx8dCgyOSksdm9pZCAwIT09aT9ibihkbihuLGkpKTpJbihuKXx8Y2kobil8fHdpKG4pfHxIaShuKXx8Smkobik/bjpuW0tuXT9uW0tuXTp2b2lkIHQoMjQsbil9ZnVuY3Rpb24gcG4odCxuKXt2YXIgaTtpZih2b2lkIDAhPT1uKWk9ZG4odCxuKTtlbHNle2lmKEF0KHQpKXJldHVybiB0Lm5hbWU7aT1hbih0KXx8SGkodCl8fEppKHQpP2JuKHQpOmRuKHQpfXJldHVybiBpLnR0fWZ1bmN0aW9uIHluKHQsbixpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9LTEpLGZ1bmN0aW9uIHQobixpLHIsbyx1KXtpZihuPT09aSlyZXR1cm4gMCE9PW58fDEvbj09MS9pO2lmKG51bGw9PW58fG51bGw9PWkpcmV0dXJuITE7aWYobiE9bilyZXR1cm4gaSE9aTt2YXIgcz10eXBlb2YgbjtpZighZShzKSYmXCJvYmplY3RcIiE9PXMmJlwib2JqZWN0XCIhPXR5cGVvZiBpKXJldHVybiExO3ZhciBmPXJyLmNhbGwobik7aWYoZiE9PXJyLmNhbGwoaSkpcmV0dXJuITE7c3dpdGNoKGYpe2Nhc2VcIltvYmplY3QgUmVnRXhwXVwiOmNhc2VcIltvYmplY3QgU3RyaW5nXVwiOnJldHVyblwiXCIrbj09XCJcIitpO2Nhc2VcIltvYmplY3QgTnVtYmVyXVwiOnJldHVybituIT0rbj8raSE9K2k6MD09K24/MS8rbj09MS9pOituPT0raTtjYXNlXCJbb2JqZWN0IERhdGVdXCI6Y2FzZVwiW29iamVjdCBCb29sZWFuXVwiOnJldHVybituPT0raTtjYXNlXCJbb2JqZWN0IFN5bWJvbF1cIjpyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudmFsdWVPZi5jYWxsKG4pPT09U3ltYm9sLnZhbHVlT2YuY2FsbChpKTtjYXNlXCJbb2JqZWN0IE1hcF1cIjpjYXNlXCJbb2JqZWN0IFNldF1cIjpyPj0wJiZyKyt9bj1tbihuKSxpPW1uKGkpO3ZhciBhPVwiW29iamVjdCBBcnJheV1cIj09PWY7aWYoIWEpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBufHxcIm9iamVjdFwiIT10eXBlb2YgaSlyZXR1cm4hMTt2YXIgYz1uLmNvbnN0cnVjdG9yLGg9aS5jb25zdHJ1Y3RvcjtpZihjIT09aCYmIShlKGMpJiZjIGluc3RhbmNlb2YgYyYmZShoKSYmaCBpbnN0YW5jZW9mIGgpJiZcImNvbnN0cnVjdG9yXCJpbiBuJiZcImNvbnN0cnVjdG9yXCJpbiBpKXJldHVybiExfWlmKDA9PT1yKXJldHVybiExO3I8MCYmKHI9LTEpLHU9dXx8W107Zm9yKHZhciB2PShvPW98fFtdKS5sZW5ndGg7di0tOylpZihvW3ZdPT09bilyZXR1cm4gdVt2XT09PWk7aWYoby5wdXNoKG4pLHUucHVzaChpKSxhKXtpZigodj1uLmxlbmd0aCkhPT1pLmxlbmd0aClyZXR1cm4hMTtmb3IoO3YtLTspaWYoIXQoblt2XSxpW3ZdLHItMSxvLHUpKXJldHVybiExfWVsc2V7dmFyIGwsZD1PYmplY3Qua2V5cyhuKTtpZih2PWQubGVuZ3RoLE9iamVjdC5rZXlzKGkpLmxlbmd0aCE9PXYpcmV0dXJuITE7Zm9yKDt2LS07KWlmKCFiKGksbD1kW3ZdKXx8IXQobltsXSxpW2xdLHItMSxvLHUpKXJldHVybiExfXJldHVybiBvLnBvcCgpLHUucG9wKCksITB9KHQsbixpKX1mdW5jdGlvbiBtbih0KXtyZXR1cm4gdW4odCk/dC5zbGljZSgpOnYodCl8fEhpKHQpfHxsKHQpfHxKaSh0KT9BcnJheS5mcm9tKHQuZW50cmllcygpKTp0fWZ1bmN0aW9uIHduKHQpe3JldHVybiB0W1N5bWJvbC5pdGVyYXRvcl09am4sdH1mdW5jdGlvbiBqbigpe3JldHVybiB0aGlzfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB4bj17fSxPbj1PYmplY3QuYXNzaWduLEFuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsZ249T2JqZWN0LmRlZmluZVByb3BlcnR5LF9uPU9iamVjdC5wcm90b3R5cGUsU249W107T2JqZWN0LmZyZWV6ZShTbik7dmFyIE1uPXt9O09iamVjdC5mcmVlemUoTW4pO3ZhciBWbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgUHJveHksTm49T2JqZWN0LnRvU3RyaW5nKCksUm49ZnVuY3Rpb24oKXt9LGtuPXZvaWQgMCE9PU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsRW49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlZmxlY3QmJlJlZmxlY3Qub3duS2V5cz9SZWZsZWN0Lm93bktleXM6a24/ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpKX06T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsVG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnN8fGZ1bmN0aW9uKHQpe3ZhciBuPXt9O3JldHVybiBFbih0KS5mb3JFYWNoKChmdW5jdGlvbihpKXtuW2ldPUFuKHQsaSl9KSksbn0sQ249U3ltYm9sKFwibW9ieC1zdG9yZWQtYW5ub3RhdGlvbnNcIiksS249U3ltYm9sKFwibW9ieCBhZG1pbmlzdHJhdGlvblwiKSxMbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dm9pZCAwPT09dCYmKHQ9XCJBdG9tXCIpLHRoaXMudHQ9dm9pZCAwLHRoaXMuVz0hMSx0aGlzLkg9ITEsdGhpcy5YPW5ldyBTZXQsdGhpcy5CPTAsdGhpcy5GPTAsdGhpcy5HPXNpLlQsdGhpcy5vbkJPTD12b2lkIDAsdGhpcy5vbkJVT0w9dm9pZCAwLHRoaXMudHQ9dH12YXIgbj10LnByb3RvdHlwZTtyZXR1cm4gbi5vbkJPPWZ1bmN0aW9uKCl7dGhpcy5vbkJPTCYmdGhpcy5vbkJPTC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdCgpfSkpfSxuLm9uQlVPPWZ1bmN0aW9uKCl7dGhpcy5vbkJVT0wmJnRoaXMub25CVU9MLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiB0KCl9KSl9LG4ucmVwb3J0T2JzZXJ2ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gcHQodGhpcyl9LG4ucmVwb3J0Q2hhbmdlZD1mdW5jdGlvbigpe2R0KCkseXQodGhpcyksYnQoKX0sbi50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnR0fSx0fSgpLEluPWgoXCJBdG9tXCIsTG4pLFBuPXtpZGVudGl0eTpmdW5jdGlvbih0LG4pe3JldHVybiB0PT09bn0sc3RydWN0dXJhbDpmdW5jdGlvbih0LG4pe3JldHVybiB5bih0LG4pfSxkZWZhdWx0OmZ1bmN0aW9uKHQsbil7cmV0dXJuIE9iamVjdC5pcz9PYmplY3QuaXModCxuKTp0PT09bj8wIT09dHx8MS90PT0xL246dCE9dCYmbiE9bn0sc2hhbGxvdzpmdW5jdGlvbih0LG4pe3JldHVybiB5bih0LG4sMSl9fSxEbj1BKHt0Olwib3ZlcnJpZGVcIixvOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LHU6ZnVuY3Rpb24oKXt0KFwiJ1wiK3RoaXMudCtcIicgY2FuIG9ubHkgYmUgdXNlZCB3aXRoICdtYWtlT2JzZXJ2YWJsZSdcIil9fSksQm49RygpLHFuPXtkZWVwOiEwLG5hbWU6dm9pZCAwLGRlZmF1bHREZWNvcmF0b3I6dm9pZCAwLHByb3h5OiEwfTtPYmplY3QuZnJlZXplKHFuKTt2YXIgR249RChcIm9ic2VydmFibGVcIiksWG49RChcIm9ic2VydmFibGUucmVmXCIse2VuaGFuY2VyOk19KSxXbj1EKFwib2JzZXJ2YWJsZS5zaGFsbG93XCIse2VuaGFuY2VyOmZ1bmN0aW9uKHQsbixpKXtyZXR1cm4gbnVsbD09dHx8YW4odCl8fHVuKHQpfHxIaSh0KXx8SmkodCk/dDpBcnJheS5pc0FycmF5KHQpPyRuLmFycmF5KHQse25hbWU6aSxkZWVwOiExfSk6cyh0KT8kbi5vYmplY3QodCx2b2lkIDAse25hbWU6aSxkZWVwOiExfSk6dih0KT8kbi5tYXAodCx7bmFtZTppLGRlZXA6ITF9KTpsKHQpPyRuLnNldCh0LHtuYW1lOmksZGVlcDohMX0pOnZvaWQgMH19KSxIbj1EKFwib2JzZXJ2YWJsZS5zdHJ1Y3RcIix7ZW5oYW5jZXI6ZnVuY3Rpb24odCxuKXtyZXR1cm4geW4odCxuKT9uOnR9fSksVW49QShHbik7T2JqZWN0LmFzc2lnbihGLFVuKTt2YXIgRm4sem4sJG49T24oRix7Ym94OmZ1bmN0aW9uKHQsbil7dmFyIGk9SChuKTtyZXR1cm4gbmV3IG9pKHQsVShpKSxpLm5hbWUsITAsaS5lcXVhbHMpfSxhcnJheTpmdW5jdGlvbih0LG4pe3ZhciBpPUgobik7cmV0dXJuKCExPT09cGkudXNlUHJveGllc3x8ITE9PT1pLnByb3h5P2xuOnRuKSh0LFUoaSksaS5uYW1lKX0sbWFwOmZ1bmN0aW9uKHQsbil7dmFyIGk9SChuKTtyZXR1cm4gbmV3IFdpKHQsVShpKSxpLm5hbWUpfSxzZXQ6ZnVuY3Rpb24odCxuKXt2YXIgaT1IKG4pO3JldHVybiBuZXcgJGkodCxVKGkpLGkubmFtZSl9LG9iamVjdDpmdW5jdGlvbih0LG4scil7cmV0dXJuIE50KCExPT09cGkudXNlUHJveGllc3x8ITE9PT0obnVsbD09cj92b2lkIDA6ci5wcm94eSk/c24oe30scik6ZnVuY3Rpb24odCxuKXt2YXIgcixlO3JldHVybiBpKCksbnVsbCE9KGU9KHI9KHQ9c24odCxuKSlbS25dKS52KT9lOnIudj1uZXcgUHJveHkodCxraSl9KHt9LHIpLHQsbil9LHJlZjpBKFhuKSxzaGFsbG93OkEoV24pLGRlZXA6VW4sc3RydWN0OkEoSG4pfSksSm49TChcImNvbXB1dGVkXCIpLFluPUwoXCJjb21wdXRlZC5zdHJ1Y3RcIix7ZXF1YWxzOlBuLnN0cnVjdHVyYWx9KSxRbj1mdW5jdGlvbih0LG4pe2lmKG8obikpcmV0dXJuIGcodCxuLEpuKTtpZihzKHQpKXJldHVybiBBKEwoXCJjb21wdXRlZFwiLHQpKTt2YXIgaT1zKG4pP246e307cmV0dXJuIGkuZ2V0PXQsaS5uYW1lfHwoaS5uYW1lPXQubmFtZXx8XCJcIiksbmV3IGFpKGkpfTtPYmplY3QuYXNzaWduKFFuLEpuKSxRbi5zdHJ1Y3Q9QShZbik7dmFyIFpuLHRpPTAsbmk9MSxpaT1udWxsIT0oRm49bnVsbD09KHpuPUFuKChmdW5jdGlvbigpe30pLFwibmFtZVwiKSk/dm9pZCAwOnpuLmNvbmZpZ3VyYWJsZSkmJkZuLHJpPXt2YWx1ZTpcImFjdGlvblwiLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMSxlbnVtZXJhYmxlOiExfTtabj1TeW1ib2wudG9QcmltaXRpdmU7dmFyIGVpLG9pPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4obixpLHIsZSxvKXt2YXIgdTtyZXR1cm4gdm9pZCAwPT09ciYmKHI9XCJPYnNlcnZhYmxlVmFsdWVcIiksdm9pZCAwPT09byYmKG89UG4uZGVmYXVsdCksKHU9dC5jYWxsKHRoaXMscil8fHRoaXMpLmVuaGFuY2VyPXZvaWQgMCx1LnR0PXZvaWQgMCx1LmVxdWFscz12b2lkIDAsdS53dD0hMSx1LnV0PXZvaWQgMCx1LnN0PXZvaWQgMCx1Lmp0PXZvaWQgMCx1LmRlaGFuY2VyPXZvaWQgMCx1LmVuaGFuY2VyPWksdS50dD1yLHUuZXF1YWxzPW8sdS5qdD1pKG4sdm9pZCAwLHIpLHV9dyhuLHQpO3ZhciBpPW4ucHJvdG90eXBlO3JldHVybiBpLmRlaGFuY2VWYWx1ZT1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dGhpcy5kZWhhbmNlcj90aGlzLmRlaGFuY2VyKHQpOnR9LGkuc2V0PWZ1bmN0aW9uKHQpeyh0PXRoaXMueHQodCkpIT09cGkuVU5DSEFOR0VEJiZ0aGlzLk90KHQpfSxpLnh0PWZ1bmN0aW9uKHQpe2lmKHp0KHRoaXMpKXt2YXIgbj1KdCh0aGlzLHtvYmplY3Q6dGhpcyx0eXBlOlRpLG5ld1ZhbHVlOnR9KTtpZighbilyZXR1cm4gcGkuVU5DSEFOR0VEO3Q9bi5uZXdWYWx1ZX1yZXR1cm4gdD10aGlzLmVuaGFuY2VyKHQsdGhpcy5qdCx0aGlzLnR0KSx0aGlzLmVxdWFscyh0aGlzLmp0LHQpP3BpLlVOQ0hBTkdFRDp0fSxpLk90PWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMuanQ7dGhpcy5qdD10LHRoaXMucmVwb3J0Q2hhbmdlZCgpLFl0KHRoaXMpJiZadCh0aGlzLHt0eXBlOlRpLG9iamVjdDp0aGlzLG5ld1ZhbHVlOnQsb2xkVmFsdWU6bn0pfSxpLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlcG9ydE9ic2VydmVkKCksdGhpcy5kZWhhbmNlVmFsdWUodGhpcy5qdCl9LGkuQXQ9ZnVuY3Rpb24odCl7cmV0dXJuICR0KHRoaXMsdCl9LGkuZ3Q9ZnVuY3Rpb24odCxuKXtyZXR1cm4gbiYmdCh7b2JzZXJ2YWJsZUtpbmQ6XCJ2YWx1ZVwiLGRlYnVnT2JqZWN0TmFtZTp0aGlzLnR0LG9iamVjdDp0aGlzLHR5cGU6VGksbmV3VmFsdWU6dGhpcy5qdCxvbGRWYWx1ZTp2b2lkIDB9KSxRdCh0aGlzLHQpfSxpLnJhdz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmp0fSxpLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldCgpfSxpLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHQrXCJbXCIrdGhpcy5qdCtcIl1cIn0saS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIGQodGhpcy5nZXQoKSl9LGlbWm5dPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVPZigpfSxufShMbiksdWk9aChcIk9ic2VydmFibGVWYWx1ZVwiLG9pKTtlaT1TeW1ib2wudG9QcmltaXRpdmU7dmFyIHNpLGZpLGFpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuKXt0aGlzLlI9c2kuVCx0aGlzLkw9W10sdGhpcy5JPW51bGwsdGhpcy5IPSExLHRoaXMuVz0hMSx0aGlzLlg9bmV3IFNldCx0aGlzLkI9MCx0aGlzLkQ9MCx0aGlzLkY9MCx0aGlzLkc9c2kuayx0aGlzLlA9MCx0aGlzLmp0PW5ldyBoaShudWxsKSx0aGlzLnR0PXZvaWQgMCx0aGlzLl90PXZvaWQgMCx0aGlzLlN0PSExLHRoaXMuTXQ9ITEsdGhpcy5kZXJpdmF0aW9uPXZvaWQgMCx0aGlzLlZ0PXZvaWQgMCx0aGlzLm90PWZpLk5PTkUsdGhpcy5OdD12b2lkIDAsdGhpcy5SdD12b2lkIDAsdGhpcy5rdD12b2lkIDAsdGhpcy5FdD12b2lkIDAsdGhpcy5vbkJPTD12b2lkIDAsdGhpcy5vbkJVT0w9dm9pZCAwLG4uZ2V0fHx0KDMxKSx0aGlzLmRlcml2YXRpb249bi5nZXQsdGhpcy50dD1uLm5hbWV8fFwiQ29tcHV0ZWRWYWx1ZVwiLG4uc2V0JiYodGhpcy5WdD16KFwiQ29tcHV0ZWRWYWx1ZS1zZXR0ZXJcIixuLnNldCkpLHRoaXMuUnQ9bi5lcXVhbHN8fChuLmNvbXBhcmVTdHJ1Y3R1cmFsfHxuLnN0cnVjdD9Qbi5zdHJ1Y3R1cmFsOlBuLmRlZmF1bHQpLHRoaXMuTnQ9bi5jb250ZXh0LHRoaXMua3Q9ISFuLnJlcXVpcmVzUmVhY3Rpb24sdGhpcy5FdD0hIW4ua2VlcEFsaXZlfXZhciBpPW4ucHJvdG90eXBlO3JldHVybiBpLnE9ZnVuY3Rpb24oKXshZnVuY3Rpb24odCl7dC5HPT09c2kuayYmKHQuRz1zaS5LLHQuWC5mb3JFYWNoKChmdW5jdGlvbih0KXt0LlI9PT1zaS5rJiYodC5SPXNpLkssdC5xKCkpfSkpKX0odGhpcyl9LGkub25CTz1mdW5jdGlvbigpe3RoaXMub25CT0wmJnRoaXMub25CT0wuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQoKX0pKX0saS5vbkJVTz1mdW5jdGlvbigpe3RoaXMub25CVU9MJiZ0aGlzLm9uQlVPTC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdCgpfSkpfSxpLmdldD1mdW5jdGlvbigpe2lmKHRoaXMuU3QmJnQoMzIsdGhpcy50dCx0aGlzLmRlcml2YXRpb24pLDAhPT1waS5pbkJhdGNofHwwIT09dGhpcy5YLnNpemV8fHRoaXMuRXQpe2lmKHB0KHRoaXMpLGl0KHRoaXMpKXt2YXIgbj1waS50cmFja2luZ0NvbnRleHQ7dGhpcy5FdCYmIW4mJihwaS50cmFja2luZ0NvbnRleHQ9dGhpcyksdGhpcy50cmFja0FuZENvbXB1dGUoKSYmZnVuY3Rpb24odCl7dC5HIT09c2kuQyYmKHQuRz1zaS5DLHQuWC5mb3JFYWNoKChmdW5jdGlvbihuKXtuLlI9PT1zaS5LP24uUj1zaS5DOm4uUj09PXNpLmsmJih0Lkc9c2kuayl9KSkpfSh0aGlzKSxwaS50cmFja2luZ0NvbnRleHQ9bn19ZWxzZSBpdCh0aGlzKSYmKHRoaXMuVHQoKSxkdCgpLHRoaXMuanQ9dGhpcy5DdCghMSksYnQoKSk7dmFyIGk9dGhpcy5qdDtpZihudChpKSl0aHJvdyBpLmNhdXNlO3JldHVybiBpfSxpLnNldD1mdW5jdGlvbihuKXtpZih0aGlzLlZ0KXt0aGlzLk10JiZ0KDMzLHRoaXMudHQpLHRoaXMuTXQ9ITA7dHJ5e3RoaXMuVnQuY2FsbCh0aGlzLk50LG4pfWZpbmFsbHl7dGhpcy5NdD0hMX19ZWxzZSB0KDM0LHRoaXMudHQpfSxpLnRyYWNrQW5kQ29tcHV0ZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuanQsbj10aGlzLlI9PT1zaS5ULGk9dGhpcy5DdCghMCkscj1ufHxudCh0KXx8bnQoaSl8fCF0aGlzLlJ0KHQsaSk7cmV0dXJuIHImJih0aGlzLmp0PWkpLHJ9LGkuQ3Q9ZnVuY3Rpb24odCl7dGhpcy5TdD0hMDt2YXIgbixpPVooITEpO2lmKHQpbj1ydCh0aGlzLHRoaXMuZGVyaXZhdGlvbix0aGlzLk50KTtlbHNlIGlmKCEwPT09cGkuZGlzYWJsZUVycm9yQm91bmRhcmllcyluPXRoaXMuZGVyaXZhdGlvbi5jYWxsKHRoaXMuTnQpO2Vsc2UgdHJ5e249dGhpcy5kZXJpdmF0aW9uLmNhbGwodGhpcy5OdCl9Y2F0Y2godCl7bj1uZXcgaGkodCl9cmV0dXJuIHR0KGkpLHRoaXMuU3Q9ITEsbn0saS5VPWZ1bmN0aW9uKCl7dGhpcy5FdHx8KGV0KHRoaXMpLHRoaXMuanQ9dm9pZCAwKX0saS5ndD1mdW5jdGlvbih0LG4pe3ZhciBpPXRoaXMscj0hMCxlPXZvaWQgMDtyZXR1cm4gZ3QoKGZ1bmN0aW9uKCl7dmFyIG89aS5nZXQoKTtpZighcnx8bil7dmFyIHU9dXQoKTt0KHtvYnNlcnZhYmxlS2luZDpcImNvbXB1dGVkXCIsZGVidWdPYmplY3ROYW1lOmkudHQsdHlwZTpUaSxvYmplY3Q6aSxuZXdWYWx1ZTpvLG9sZFZhbHVlOmV9KSxzdCh1KX1yPSExLGU9b30pKX0saS5UdD1mdW5jdGlvbigpe30saS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnR0K1wiW1wiK3RoaXMuZGVyaXZhdGlvbi50b1N0cmluZygpK1wiXVwifSxpLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gZCh0aGlzLmdldCgpKX0saVtlaV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZU9mKCl9LG59KCksY2k9aChcIkNvbXB1dGVkVmFsdWVcIixhaSk7IWZ1bmN0aW9uKHQpe3RbdC5UPS0xXT1cIk5PVF9UUkFDS0lOR19cIix0W3Quaz0wXT1cIlVQX1RPX0RBVEVfXCIsdFt0Lks9MV09XCJQT1NTSUJMWV9TVEFMRV9cIix0W3QuQz0yXT1cIlNUQUxFX1wifShzaXx8KHNpPXt9KSksZnVuY3Rpb24odCl7dFt0Lk5PTkU9MF09XCJOT05FXCIsdFt0LkxPRz0xXT1cIkxPR1wiLHRbdC5CUkVBSz0yXT1cIkJSRUFLXCJ9KGZpfHwoZmk9e30pKTt2YXIgaGk9ZnVuY3Rpb24odCl7dGhpcy5jYXVzZT12b2lkIDAsdGhpcy5jYXVzZT10fSx2aT1bXCJtb2J4R3VpZFwiLFwic3B5TGlzdGVuZXJzXCIsXCJlbmZvcmNlQWN0aW9uc1wiLFwiY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uXCIsXCJyZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZVwiLFwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25cIixcImFsbG93U3RhdGVSZWFkc1wiLFwiZGlzYWJsZUVycm9yQm91bmRhcmllc1wiLFwicnVuSWRcIixcIlVOQ0hBTkdFRFwiLFwidXNlUHJveGllc1wiXSxsaT1mdW5jdGlvbigpe3RoaXMudmVyc2lvbj02LHRoaXMuVU5DSEFOR0VEPXt9LHRoaXMudHJhY2tpbmdEZXJpdmF0aW9uPW51bGwsdGhpcy50cmFja2luZ0NvbnRleHQ9bnVsbCx0aGlzLnJ1bklkPTAsdGhpcy5tb2J4R3VpZD0wLHRoaXMuaW5CYXRjaD0wLHRoaXMucGVuZGluZ1Vub2JzZXJ2YXRpb25zPVtdLHRoaXMucGVuZGluZ1JlYWN0aW9ucz1bXSx0aGlzLmlzUnVubmluZ1JlYWN0aW9ucz0hMSx0aGlzLmFsbG93U3RhdGVDaGFuZ2VzPSExLHRoaXMuYWxsb3dTdGF0ZVJlYWRzPSEwLHRoaXMuZW5mb3JjZUFjdGlvbnM9ITAsdGhpcy5zcHlMaXN0ZW5lcnM9W10sdGhpcy5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnM9W10sdGhpcy5jb21wdXRlZFJlcXVpcmVzUmVhY3Rpb249ITEsdGhpcy5yZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZT0hMSx0aGlzLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uPSExLHRoaXMuZGlzYWJsZUVycm9yQm91bmRhcmllcz0hMSx0aGlzLnN1cHByZXNzUmVhY3Rpb25FcnJvcnM9ITEsdGhpcy51c2VQcm94aWVzPSEwLHRoaXMudmVyaWZ5UHJveGllcz0hMSx0aGlzLnNhZmVEZXNjcmlwdG9ycz0hMH0sZGk9ITAsYmk9ITEscGk9ZnVuY3Rpb24oKXt2YXIgaT1uKCk7cmV0dXJuIGkuX19tb2J4SW5zdGFuY2VDb3VudD4wJiYhaS5fX21vYnhHbG9iYWxzJiYoZGk9ITEpLGkuX19tb2J4R2xvYmFscyYmaS5fX21vYnhHbG9iYWxzLnZlcnNpb24hPT0obmV3IGxpKS52ZXJzaW9uJiYoZGk9ITEpLGRpP2kuX19tb2J4R2xvYmFscz8oaS5fX21vYnhJbnN0YW5jZUNvdW50Kz0xLGkuX19tb2J4R2xvYmFscy5VTkNIQU5HRUR8fChpLl9fbW9ieEdsb2JhbHMuVU5DSEFOR0VEPXt9KSxpLl9fbW9ieEdsb2JhbHMpOihpLl9fbW9ieEluc3RhbmNlQ291bnQ9MSxpLl9fbW9ieEdsb2JhbHM9bmV3IGxpKTooc2V0VGltZW91dCgoZnVuY3Rpb24oKXtiaXx8dCgzNSl9KSwxKSxuZXcgbGkpfSgpLHlpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LG4saSxyKXt2b2lkIDA9PT10JiYodD1cIlJlYWN0aW9uXCIpLHZvaWQgMD09PXImJihyPSExKSx0aGlzLnR0PXZvaWQgMCx0aGlzLkt0PXZvaWQgMCx0aGlzLkx0PXZvaWQgMCx0aGlzLkl0PXZvaWQgMCx0aGlzLkw9W10sdGhpcy5JPVtdLHRoaXMuUj1zaS5ULHRoaXMuQj0wLHRoaXMuRD0wLHRoaXMuUD0wLHRoaXMuSj0hMSx0aGlzLlB0PSExLHRoaXMuRHQ9ITEsdGhpcy5CdD0hMSx0aGlzLm90PWZpLk5PTkUsdGhpcy50dD10LHRoaXMuS3Q9bix0aGlzLkx0PWksdGhpcy5JdD1yfXZhciBuPXQucHJvdG90eXBlO3JldHVybiBuLnE9ZnVuY3Rpb24oKXt0aGlzLlkoKX0sbi5ZPWZ1bmN0aW9uKCl7dGhpcy5QdHx8KHRoaXMuUHQ9ITAscGkucGVuZGluZ1JlYWN0aW9ucy5wdXNoKHRoaXMpLG10KCkpfSxuLmlzU2NoZWR1bGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuUHR9LG4uJD1mdW5jdGlvbigpe2lmKCF0aGlzLkope2R0KCksdGhpcy5QdD0hMTt2YXIgdD1waS50cmFja2luZ0NvbnRleHQ7aWYocGkudHJhY2tpbmdDb250ZXh0PXRoaXMsaXQodGhpcykpe3RoaXMuRHQ9ITA7dHJ5e3RoaXMuS3QoKX1jYXRjaCh0KXt0aGlzLnF0KHQpfX1waS50cmFja2luZ0NvbnRleHQ9dCxidCgpfX0sbi50cmFjaz1mdW5jdGlvbih0KXtpZighdGhpcy5KKXtkdCgpLHRoaXMuQnQ9ITA7dmFyIG49cGkudHJhY2tpbmdDb250ZXh0O3BpLnRyYWNraW5nQ29udGV4dD10aGlzO3ZhciBpPXJ0KHRoaXMsdCx2b2lkIDApO3BpLnRyYWNraW5nQ29udGV4dD1uLHRoaXMuQnQ9ITEsdGhpcy5EdD0hMSx0aGlzLkomJmV0KHRoaXMpLG50KGkpJiZ0aGlzLnF0KGkuY2F1c2UpLGJ0KCl9fSxuLnF0PWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7aWYodGhpcy5MdCl0aGlzLkx0KHQsdGhpcyk7ZWxzZXtpZihwaS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzKXRocm93IHQ7cGkuc3VwcHJlc3NSZWFjdGlvbkVycm9yc3x8Y29uc29sZS5lcnJvcihcIlttb2J4XSB1bmNhdWdodCBlcnJvciBpbiAnXCIrdGhpcytcIidcIix0KSxwaS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuZm9yRWFjaCgoZnVuY3Rpb24oaSl7cmV0dXJuIGkodCxuKX0pKX19LG4uZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuSnx8KHRoaXMuSj0hMCx0aGlzLkJ0fHwoZHQoKSxldCh0aGlzKSxidCgpKSl9LG4uWj1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZGlzcG9zZS5iaW5kKHRoaXMpO3JldHVybiB0W0tuXT10aGlzLHR9LG4udG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIlJlYWN0aW9uW1wiK3RoaXMudHQrXCJdXCJ9LG4udHJhY2U9ZnVuY3Rpb24odCl7dm9pZCAwPT09dCYmKHQ9ITEpLEd0KHRoaXMsdCl9LHR9KCksbWk9ZnVuY3Rpb24odCl7cmV0dXJuIHQoKX0sd2k9aChcIlJlYWN0aW9uXCIseWkpLGppPVYoXCJhY3Rpb25cIikseGk9VihcImFjdGlvbi5ib3VuZFwiLHtib3VuZDohMH0pLE9pPVYoXCJhdXRvQWN0aW9uXCIse2F1dG9BY3Rpb246ITB9KSxBaT1WKFwiYXV0b0FjdGlvbi5ib3VuZFwiLHthdXRvQWN0aW9uOiEwLGJvdW5kOiEwfSksZ2k9eHQoITEpO09iamVjdC5hc3NpZ24oZ2ksamkpO3ZhciBfaT14dCghMCk7T2JqZWN0LmFzc2lnbihfaSxPaSksZ2kuYm91bmQ9QSh4aSksX2kuYm91bmQ9QShBaSk7dmFyIFNpPWZ1bmN0aW9uKHQpe3JldHVybiB0KCl9LE1pPTA7RXQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTt2YXIgVmk9RShcImZsb3dcIiksTmk9RShcImZsb3cuYm91bmRcIix7Ym91bmQ6ITB9KSxSaT1PYmplY3QuYXNzaWduKChmdW5jdGlvbih0LG4pe2lmKG8obikpcmV0dXJuIGcodCxuLFZpKTt2YXIgaT10LHI9aS5uYW1lfHxcIjx1bm5hbWVkIGZsb3c+XCIsdT1mdW5jdGlvbigpe3ZhciB0LG49dGhpcyxvPWFyZ3VtZW50cyx1PSsrTWkscz1naShyK1wiIC0gcnVuaWQ6IFwiK3UrXCIgLSBpbml0XCIsaSkuYXBwbHkobixvKSxmPXZvaWQgMCxhPW5ldyBQcm9taXNlKChmdW5jdGlvbihuLGkpe2Z1bmN0aW9uIG8odCl7dmFyIG47Zj12b2lkIDA7dHJ5e249Z2kocitcIiAtIHJ1bmlkOiBcIit1K1wiIC0geWllbGQgXCIraCsrLHMubmV4dCkuY2FsbChzLHQpfWNhdGNoKHQpe3JldHVybiBpKHQpfWMobil9ZnVuY3Rpb24gYSh0KXt2YXIgbjtmPXZvaWQgMDt0cnl7bj1naShyK1wiIC0gcnVuaWQ6IFwiK3UrXCIgLSB5aWVsZCBcIitoKysscy50aHJvdykuY2FsbChzLHQpfWNhdGNoKHQpe3JldHVybiBpKHQpfWMobil9ZnVuY3Rpb24gYyh0KXtpZighZShudWxsPT10P3ZvaWQgMDp0LnRoZW4pKXJldHVybiB0LmRvbmU/bih0LnZhbHVlKTooZj1Qcm9taXNlLnJlc29sdmUodC52YWx1ZSkpLnRoZW4obyxhKTt0LnRoZW4oYyxpKX12YXIgaD0wO3Q9aSxvKHZvaWQgMCl9KSk7cmV0dXJuIGEuY2FuY2VsPWdpKHIrXCIgLSBydW5pZDogXCIrdStcIiAtIGNhbmNlbFwiLChmdW5jdGlvbigpe3RyeXtmJiZUdChmKTt2YXIgbj1zLnJldHVybih2b2lkIDApLGk9UHJvbWlzZS5yZXNvbHZlKG4udmFsdWUpO2kudGhlbihSbixSbiksVHQoaSksdChuZXcgRXQpfWNhdGNoKG4pe3Qobil9fSkpLGF9O3JldHVybiB1LmlzTW9iWEZsb3c9ITAsdX0pLFZpKTtSaS5ib3VuZD1BKE5pKTt2YXIga2k9e2hhczpmdW5jdGlvbih0LG4pe3JldHVybiBGdCh0KS5ydChuKX0sZ2V0OmZ1bmN0aW9uKHQsbil7cmV0dXJuIEZ0KHQpLmx0KG4pfSxzZXQ6ZnVuY3Rpb24odCxuLGkpe3ZhciByO3JldHVybiEhbyhuKSYmKG51bGw9PShyPUZ0KHQpLmR0KG4saSwhMCkpfHxyKX0sZGVsZXRlUHJvcGVydHk6ZnVuY3Rpb24odCxuKXt2YXIgaTtyZXR1cm4hIW8obikmJihudWxsPT0oaT1GdCh0KS5HdChuLCEwKSl8fGkpfSxkZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbih0LG4saSl7dmFyIHI7cmV0dXJuIG51bGw9PShyPUZ0KHQpLmgobixpKSl8fHJ9LG93bktleXM6ZnVuY3Rpb24odCl7cmV0dXJuIEZ0KHQpLmV0KCl9LHByZXZlbnRFeHRlbnNpb25zOmZ1bmN0aW9uKCl7dCgxMyl9fSxFaT1TeW1ib2woXCJtb2J4LWtleXNcIiksVGk9XCJ1cGRhdGVcIixDaT17Z2V0OmZ1bmN0aW9uKHQsbil7dmFyIGk9dFtLbl07cmV0dXJuIG49PT1Lbj9pOlwibGVuZ3RoXCI9PT1uP2kuWHQoKTpcInN0cmluZ1wiIT10eXBlb2Ygbnx8aXNOYU4obik/YihMaSxuKT9MaVtuXTp0W25dOmkubHQocGFyc2VJbnQobikpfSxzZXQ6ZnVuY3Rpb24odCxuLGkpe3ZhciByPXRbS25dO3JldHVyblwibGVuZ3RoXCI9PT1uJiZyLld0KGkpLFwic3ltYm9sXCI9PXR5cGVvZiBufHxpc05hTihuKT90W25dPWk6ci5kdChwYXJzZUludChuKSxpKSwhMH0scHJldmVudEV4dGVuc2lvbnM6ZnVuY3Rpb24oKXt0KDE1KX19LEtpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbih0LG4saSxyKXt2b2lkIDA9PT10JiYodD1cIk9ic2VydmFibGVBcnJheVwiKSx0aGlzLkh0PXZvaWQgMCx0aGlzLlV0PXZvaWQgMCx0aGlzLmF0PXZvaWQgMCx0aGlzLm50PVtdLHRoaXMudXQ9dm9pZCAwLHRoaXMuc3Q9dm9pZCAwLHRoaXMuRnQ9dm9pZCAwLHRoaXMuZGVoYW5jZXI9dm9pZCAwLHRoaXMudj12b2lkIDAsdGhpcy56dD0wLHRoaXMuSHQ9aSx0aGlzLlV0PXIsdGhpcy5hdD1uZXcgTG4odCksdGhpcy5GdD1mdW5jdGlvbih0LGkpe3JldHVybiBuKHQsaSxcIk9ic2VydmFibGVBcnJheVsuLl1cIil9fXZhciBpPW4ucHJvdG90eXBlO3JldHVybiBpLiR0PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10aGlzLmRlaGFuY2VyP3RoaXMuZGVoYW5jZXIodCk6dH0saS5jdD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dGhpcy5kZWhhbmNlciYmdC5sZW5ndGg+MD90Lm1hcCh0aGlzLmRlaGFuY2VyKTp0fSxpLkF0PWZ1bmN0aW9uKHQpe3JldHVybiAkdCh0aGlzLHQpfSxpLmd0PWZ1bmN0aW9uKHQsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPSExKSxuJiZ0KHtvYnNlcnZhYmxlS2luZDpcImFycmF5XCIsb2JqZWN0OnRoaXMudixkZWJ1Z09iamVjdE5hbWU6dGhpcy5hdC50dCx0eXBlOlwic3BsaWNlXCIsaW5kZXg6MCxhZGRlZDp0aGlzLm50LnNsaWNlKCksYWRkZWRDb3VudDp0aGlzLm50Lmxlbmd0aCxyZW1vdmVkOltdLHJlbW92ZWRDb3VudDowfSksUXQodGhpcyx0KX0saS5YdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmF0LnJlcG9ydE9ic2VydmVkKCksdGhpcy5udC5sZW5ndGh9LGkuV3Q9ZnVuY3Rpb24obil7KFwibnVtYmVyXCIhPXR5cGVvZiBufHxuPDApJiZ0KFwiT3V0IG9mIHJhbmdlOiBcIituKTt2YXIgaT10aGlzLm50Lmxlbmd0aDtpZihuIT09aSlpZihuPmkpe2Zvcih2YXIgcj1uZXcgQXJyYXkobi1pKSxlPTA7ZTxuLWk7ZSsrKXJbZV09dm9pZCAwO3RoaXMuZnQoaSwwLHIpfWVsc2UgdGhpcy5mdChuLGktbil9LGkuSnQ9ZnVuY3Rpb24obixpKXtuIT09dGhpcy56dCYmdCgxNiksdGhpcy56dCs9aSx0aGlzLlV0JiZpPjAmJnZuKG4raSsxKX0saS5mdD1mdW5jdGlvbih0LG4saSl7dmFyIHI9dGhpcyxlPXRoaXMubnQubGVuZ3RoO2lmKHZvaWQgMD09PXQ/dD0wOnQ+ZT90PWU6dDwwJiYodD1NYXRoLm1heCgwLGUrdCkpLG49MT09PWFyZ3VtZW50cy5sZW5ndGg/ZS10Om51bGw9PW4/MDpNYXRoLm1heCgwLE1hdGgubWluKG4sZS10KSksdm9pZCAwPT09aSYmKGk9U24pLHp0KHRoaXMpKXt2YXIgbz1KdCh0aGlzLHtvYmplY3Q6dGhpcy52LHR5cGU6XCJzcGxpY2VcIixpbmRleDp0LHJlbW92ZWRDb3VudDpuLGFkZGVkOml9KTtpZighbylyZXR1cm4gU247bj1vLnJlbW92ZWRDb3VudCxpPW8uYWRkZWR9aWYoaT0wPT09aS5sZW5ndGg/aTppLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHIuRnQodCx2b2lkIDApfSkpLHRoaXMuVXQpe3ZhciB1PWkubGVuZ3RoLW47dGhpcy5KdChlLHUpfXZhciBzPXRoaXMuWXQodCxuLGkpO3JldHVybiAwPT09biYmMD09PWkubGVuZ3RofHx0aGlzLlF0KHQsaSxzKSx0aGlzLmN0KHMpfSxpLll0PWZ1bmN0aW9uKHQsbixpKXt2YXIgcjtpZihpLmxlbmd0aDwxZTQpcmV0dXJuKHI9dGhpcy5udCkuc3BsaWNlLmFwcGx5KHIsW3Qsbl0uY29uY2F0KGkpKTt2YXIgZT10aGlzLm50LnNsaWNlKHQsdCtuKSxvPXRoaXMubnQuc2xpY2UodCtuKTt0aGlzLm50Lmxlbmd0aD10K2kubGVuZ3RoLW47Zm9yKHZhciB1PTA7dTxpLmxlbmd0aDt1KyspdGhpcy5udFt0K3VdPWlbdV07Zm9yKHZhciBzPTA7czxvLmxlbmd0aDtzKyspdGhpcy5udFt0K2kubGVuZ3RoK3NdPW9bc107cmV0dXJuIGV9LGkuWnQ9ZnVuY3Rpb24odCxuLGkpe3ZhciByPSF0aGlzLkh0JiYhMSxlPVl0KHRoaXMpLG89ZXx8cj97b2JzZXJ2YWJsZUtpbmQ6XCJhcnJheVwiLG9iamVjdDp0aGlzLnYsdHlwZTpUaSxkZWJ1Z09iamVjdE5hbWU6dGhpcy5hdC50dCxpbmRleDp0LG5ld1ZhbHVlOm4sb2xkVmFsdWU6aX06bnVsbDt0aGlzLmF0LnJlcG9ydENoYW5nZWQoKSxlJiZadCh0aGlzLG8pfSxpLlF0PWZ1bmN0aW9uKHQsbixpKXt2YXIgcj0hdGhpcy5IdCYmITEsZT1ZdCh0aGlzKSxvPWV8fHI/e29ic2VydmFibGVLaW5kOlwiYXJyYXlcIixvYmplY3Q6dGhpcy52LGRlYnVnT2JqZWN0TmFtZTp0aGlzLmF0LnR0LHR5cGU6XCJzcGxpY2VcIixpbmRleDp0LHJlbW92ZWQ6aSxhZGRlZDpuLHJlbW92ZWRDb3VudDppLmxlbmd0aCxhZGRlZENvdW50Om4ubGVuZ3RofTpudWxsO3RoaXMuYXQucmVwb3J0Q2hhbmdlZCgpLGUmJlp0KHRoaXMsbyl9LGkubHQ9ZnVuY3Rpb24odCl7aWYodDx0aGlzLm50Lmxlbmd0aClyZXR1cm4gdGhpcy5hdC5yZXBvcnRPYnNlcnZlZCgpLHRoaXMuJHQodGhpcy5udFt0XSk7Y29uc29sZS53YXJuKFwiW21vYnguYXJyYXldIEF0dGVtcHQgdG8gcmVhZCBhbiBhcnJheSBpbmRleCAoXCIrdCtcIikgdGhhdCBpcyBvdXQgb2YgYm91bmRzIChcIit0aGlzLm50Lmxlbmd0aCtcIikuIFBsZWFzZSBjaGVjayBsZW5ndGggZmlyc3QuIE91dCBvZiBib3VuZCBpbmRpY2VzIHdpbGwgbm90IGJlIHRyYWNrZWQgYnkgTW9iWFwiKX0saS5kdD1mdW5jdGlvbihuLGkpe3ZhciByPXRoaXMubnQ7aWYobjxyLmxlbmd0aCl7dmFyIGU9cltuXTtpZih6dCh0aGlzKSl7dmFyIG89SnQodGhpcyx7dHlwZTpUaSxvYmplY3Q6dGhpcy52LGluZGV4Om4sbmV3VmFsdWU6aX0pO2lmKCFvKXJldHVybjtpPW8ubmV3VmFsdWV9KGk9dGhpcy5GdChpLGUpKSE9PWUmJihyW25dPWksdGhpcy5adChuLGksZSkpfWVsc2Ugbj09PXIubGVuZ3RoP3RoaXMuZnQobiwwLFtpXSk6dCgxNyxuLHIubGVuZ3RoKX0sbn0oKSxMaT17Y2xlYXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zcGxpY2UoMCl9LHJlcGxhY2U6ZnVuY3Rpb24odCl7dmFyIG49dGhpc1tLbl07cmV0dXJuIG4uZnQoMCxuLm50Lmxlbmd0aCx0KX0sdG9KU09OOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2xpY2UoKX0sc3BsaWNlOmZ1bmN0aW9uKHQsbil7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgscj1uZXcgQXJyYXkoaT4yP2ktMjowKSxlPTI7ZTxpO2UrKylyW2UtMl09YXJndW1lbnRzW2VdO3ZhciBvPXRoaXNbS25dO3N3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuW107Y2FzZSAxOnJldHVybiBvLmZ0KHQpO2Nhc2UgMjpyZXR1cm4gby5mdCh0LG4pfXJldHVybiBvLmZ0KHQsbixyKX0sc3BsaWNlV2l0aEFycmF5OmZ1bmN0aW9uKHQsbixpKXtyZXR1cm4gdGhpc1tLbl0uZnQodCxuLGkpfSxwdXNoOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXNbS25dLG49YXJndW1lbnRzLmxlbmd0aCxpPW5ldyBBcnJheShuKSxyPTA7cjxuO3IrKylpW3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4gdC5mdCh0Lm50Lmxlbmd0aCwwLGkpLHQubnQubGVuZ3RofSxwb3A6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zcGxpY2UoTWF0aC5tYXgodGhpc1tLbl0ubnQubGVuZ3RoLTEsMCksMSlbMF19LHNoaWZ0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3BsaWNlKDAsMSlbMF19LHVuc2hpZnQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpc1tLbl0sbj1hcmd1bWVudHMubGVuZ3RoLGk9bmV3IEFycmF5KG4pLHI9MDtyPG47cisrKWlbcl09YXJndW1lbnRzW3JdO3JldHVybiB0LmZ0KDAsMCxpKSx0Lm50Lmxlbmd0aH0scmV2ZXJzZTpmdW5jdGlvbigpe3JldHVybiBwaS50cmFja2luZ0Rlcml2YXRpb24mJnQoMzcsXCJyZXZlcnNlXCIpLHRoaXMucmVwbGFjZSh0aGlzLnNsaWNlKCkucmV2ZXJzZSgpKSx0aGlzfSxzb3J0OmZ1bmN0aW9uKCl7cGkudHJhY2tpbmdEZXJpdmF0aW9uJiZ0KDM3LFwic29ydFwiKTt2YXIgbj10aGlzLnNsaWNlKCk7cmV0dXJuIG4uc29ydC5hcHBseShuLGFyZ3VtZW50cyksdGhpcy5yZXBsYWNlKG4pLHRoaXN9LHJlbW92ZTpmdW5jdGlvbih0KXt2YXIgbj10aGlzW0tuXSxpPW4uY3Qobi5udCkuaW5kZXhPZih0KTtyZXR1cm4gaT4tMSYmKHRoaXMuc3BsaWNlKGksMSksITApfX07bm4oXCJjb25jYXRcIixybiksbm4oXCJmbGF0XCIscm4pLG5uKFwiaW5jbHVkZXNcIixybiksbm4oXCJpbmRleE9mXCIscm4pLG5uKFwiam9pblwiLHJuKSxubihcImxhc3RJbmRleE9mXCIscm4pLG5uKFwic2xpY2VcIixybiksbm4oXCJ0b1N0cmluZ1wiLHJuKSxubihcInRvTG9jYWxlU3RyaW5nXCIscm4pLG5uKFwiZXZlcnlcIixlbiksbm4oXCJmaWx0ZXJcIixlbiksbm4oXCJmaW5kXCIsZW4pLG5uKFwiZmluZEluZGV4XCIsZW4pLG5uKFwiZmxhdE1hcFwiLGVuKSxubihcImZvckVhY2hcIixlbiksbm4oXCJtYXBcIixlbiksbm4oXCJzb21lXCIsZW4pLG5uKFwicmVkdWNlXCIsb24pLG5uKFwicmVkdWNlUmlnaHRcIixvbik7dmFyIElpLFBpLERpPWgoXCJPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvblwiLEtpKSxCaT17fSxxaT1cImFkZFwiO0lpPVN5bWJvbC5pdGVyYXRvcixQaT1TeW1ib2wudG9TdHJpbmdUYWc7dmFyIEdpLFhpLFdpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLGkscil7dm9pZCAwPT09aSYmKGk9Uyksdm9pZCAwPT09ciYmKHI9XCJPYnNlcnZhYmxlTWFwXCIpLHRoaXMuRnQ9dm9pZCAwLHRoaXMudHQ9dm9pZCAwLHRoaXNbS25dPUJpLHRoaXMucHQ9dm9pZCAwLHRoaXMueXQ9dm9pZCAwLHRoaXMuYnQ9dm9pZCAwLHRoaXMudXQ9dm9pZCAwLHRoaXMuc3Q9dm9pZCAwLHRoaXMuZGVoYW5jZXI9dm9pZCAwLHRoaXMuRnQ9aSx0aGlzLnR0PXIsZShNYXApfHx0KDE4KSx0aGlzLmJ0PV8oXCJPYnNlcnZhYmxlTWFwLmtleXMoKVwiKSx0aGlzLnB0PW5ldyBNYXAsdGhpcy55dD1uZXcgTWFwLHRoaXMubWVyZ2Uobil9dmFyIGk9bi5wcm90b3R5cGU7cmV0dXJuIGkucnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHQuaGFzKHQpfSxpLmhhcz1mdW5jdGlvbih0KXt2YXIgbj10aGlzO2lmKCFwaS50cmFja2luZ0Rlcml2YXRpb24pcmV0dXJuIHRoaXMucnQodCk7dmFyIGk9dGhpcy55dC5nZXQodCk7aWYoIWkpe3ZhciByPWk9bmV3IG9pKHRoaXMucnQodCksTSxcIk9ic2VydmFibGVNYXAua2V5P1wiLCExKTt0aGlzLnl0LnNldCh0LHIpLE10KHIsKGZ1bmN0aW9uKCl7cmV0dXJuIG4ueXQuZGVsZXRlKHQpfSkpfXJldHVybiBpLmdldCgpfSxpLnNldD1mdW5jdGlvbih0LG4pe3ZhciBpPXRoaXMucnQodCk7aWYoenQodGhpcykpe3ZhciByPUp0KHRoaXMse3R5cGU6aT9UaTpxaSxvYmplY3Q6dGhpcyxuZXdWYWx1ZTpuLG5hbWU6dH0pO2lmKCFyKXJldHVybiB0aGlzO249ci5uZXdWYWx1ZX1yZXR1cm4gaT90aGlzLnRuKHQsbik6dGhpcy5ubih0LG4pLHRoaXN9LGkuZGVsZXRlPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7aWYoenQodGhpcykmJiFKdCh0aGlzLHt0eXBlOlwiZGVsZXRlXCIsb2JqZWN0OnRoaXMsbmFtZTp0fSkpcmV0dXJuITE7aWYodGhpcy5ydCh0KSl7dmFyIGk9WXQodGhpcykscj1pP3tvYnNlcnZhYmxlS2luZDpcIm1hcFwiLGRlYnVnT2JqZWN0TmFtZTp0aGlzLnR0LHR5cGU6XCJkZWxldGVcIixvYmplY3Q6dGhpcyxvbGRWYWx1ZTp0aGlzLnB0LmdldCh0KS5qdCxuYW1lOnR9Om51bGw7cmV0dXJuIFd0KChmdW5jdGlvbigpe24uYnQucmVwb3J0Q2hhbmdlZCgpLG4uaW4odCwhMSksbi5wdC5nZXQodCkuT3Qodm9pZCAwKSxuLnB0LmRlbGV0ZSh0KX0pKSxpJiZadCh0aGlzLHIpLCEwfXJldHVybiExfSxpLmluPWZ1bmN0aW9uKHQsbil7dmFyIGk9dGhpcy55dC5nZXQodCk7aSYmaS5PdChuKX0saS50bj1mdW5jdGlvbih0LG4pe3ZhciBpPXRoaXMucHQuZ2V0KHQpO2lmKChuPWkueHQobikpIT09cGkuVU5DSEFOR0VEKXt2YXIgcj1ZdCh0aGlzKSxlPXI/e29ic2VydmFibGVLaW5kOlwibWFwXCIsZGVidWdPYmplY3ROYW1lOnRoaXMudHQsdHlwZTpUaSxvYmplY3Q6dGhpcyxvbGRWYWx1ZTppLmp0LG5hbWU6dCxuZXdWYWx1ZTpufTpudWxsO2kuT3QobiksciYmWnQodGhpcyxlKX19LGkubm49ZnVuY3Rpb24odCxuKXt2YXIgaT10aGlzO1d0KChmdW5jdGlvbigpe3ZhciByPW5ldyBvaShuLGkuRnQsXCJPYnNlcnZhYmxlTWFwLmtleVwiLCExKTtpLnB0LnNldCh0LHIpLG49ci5qdCxpLmluKHQsITApLGkuYnQucmVwb3J0Q2hhbmdlZCgpfSkpO3ZhciByPVl0KHRoaXMpO3ImJlp0KHRoaXMscj97b2JzZXJ2YWJsZUtpbmQ6XCJtYXBcIixkZWJ1Z09iamVjdE5hbWU6dGhpcy50dCx0eXBlOnFpLG9iamVjdDp0aGlzLG5hbWU6dCxuZXdWYWx1ZTpufTpudWxsKX0saS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGFzKHQpP3RoaXMuJHQodGhpcy5wdC5nZXQodCkuZ2V0KCkpOnRoaXMuJHQodm9pZCAwKX0saS4kdD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dGhpcy5kZWhhbmNlcj90aGlzLmRlaGFuY2VyKHQpOnR9LGkua2V5cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ0LnJlcG9ydE9ic2VydmVkKCksdGhpcy5wdC5rZXlzKCl9LGkudmFsdWVzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxuPXRoaXMua2V5cygpO3JldHVybiB3bih7bmV4dDpmdW5jdGlvbigpe3ZhciBpPW4ubmV4dCgpLHI9aS5kb25lO3JldHVybntkb25lOnIsdmFsdWU6cj92b2lkIDA6dC5nZXQoaS52YWx1ZSl9fX0pfSxpLmVudHJpZXM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLG49dGhpcy5rZXlzKCk7cmV0dXJuIHduKHtuZXh0OmZ1bmN0aW9uKCl7dmFyIGk9bi5uZXh0KCkscj1pLmRvbmUsZT1pLnZhbHVlO3JldHVybntkb25lOnIsdmFsdWU6cj92b2lkIDA6W2UsdC5nZXQoZSldfX19KX0saVtJaV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbnRyaWVzKCl9LGkuZm9yRWFjaD1mdW5jdGlvbih0LG4pe2Zvcih2YXIgaSxyPU8odGhpcyk7IShpPXIoKSkuZG9uZTspe3ZhciBlPWkudmFsdWU7dC5jYWxsKG4sZVsxXSxlWzBdLHRoaXMpfX0saS5tZXJnZT1mdW5jdGlvbihuKXt2YXIgaT10aGlzO3JldHVybiBIaShuKSYmKG49bmV3IE1hcChuKSksV3QoKGZ1bmN0aW9uKCl7cyhuKT9mdW5jdGlvbih0KXt2YXIgbj1PYmplY3Qua2V5cyh0KTtpZigha24pcmV0dXJuIG47dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0KTtyZXR1cm4gaS5sZW5ndGg/W10uY29uY2F0KG4saS5maWx0ZXIoKGZ1bmN0aW9uKG4pe3JldHVybiBfbi5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHQsbil9KSkpOm59KG4pLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBpLnNldCh0LG5bdF0pfSkpOkFycmF5LmlzQXJyYXkobik/bi5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gaS5zZXQodFswXSx0WzFdKX0pKTp2KG4pPyhuLmNvbnN0cnVjdG9yIT09TWFwJiZ0KDE5LG4pLG4uZm9yRWFjaCgoZnVuY3Rpb24odCxuKXtyZXR1cm4gaS5zZXQobix0KX0pKSk6bnVsbCE9biYmdCgyMCxuKX0pKSx0aGlzfSxpLmNsZWFyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztXdCgoZnVuY3Rpb24oKXtvdCgoZnVuY3Rpb24oKXtmb3IodmFyIG4saT1PKHQua2V5cygpKTshKG49aSgpKS5kb25lOyl0LmRlbGV0ZShuLnZhbHVlKX0pKX0pKX0saS5yZXBsYWNlPWZ1bmN0aW9uKG4pe3ZhciBpPXRoaXM7cmV0dXJuIFd0KChmdW5jdGlvbigpe2Zvcih2YXIgcixlPWZ1bmN0aW9uKG4pe2lmKHYobil8fEhpKG4pKXJldHVybiBuO2lmKEFycmF5LmlzQXJyYXkobikpcmV0dXJuIG5ldyBNYXAobik7aWYocyhuKSl7dmFyIGk9bmV3IE1hcDtmb3IodmFyIHIgaW4gbilpLnNldChyLG5bcl0pO3JldHVybiBpfXJldHVybiB0KDIxLG4pfShuKSxvPW5ldyBNYXAsdT0hMSxmPU8oaS5wdC5rZXlzKCkpOyEocj1mKCkpLmRvbmU7KXt2YXIgYT1yLnZhbHVlO2lmKCFlLmhhcyhhKSlpZihpLmRlbGV0ZShhKSl1PSEwO2Vsc2V7dmFyIGM9aS5wdC5nZXQoYSk7by5zZXQoYSxjKX19Zm9yKHZhciBoLGw9TyhlLmVudHJpZXMoKSk7IShoPWwoKSkuZG9uZTspe3ZhciBkPWgudmFsdWUsYj1kWzBdLHA9ZFsxXSx5PWkucHQuaGFzKGIpO2lmKGkuc2V0KGIscCksaS5wdC5oYXMoYikpe3ZhciBtPWkucHQuZ2V0KGIpO28uc2V0KGIsbSkseXx8KHU9ITApfX1pZighdSlpZihpLnB0LnNpemUhPT1vLnNpemUpaS5idC5yZXBvcnRDaGFuZ2VkKCk7ZWxzZSBmb3IodmFyIHc9aS5wdC5rZXlzKCksaj1vLmtleXMoKSx4PXcubmV4dCgpLEE9ai5uZXh0KCk7IXguZG9uZTspe2lmKHgudmFsdWUhPT1BLnZhbHVlKXtpLmJ0LnJlcG9ydENoYW5nZWQoKTticmVha314PXcubmV4dCgpLEE9ai5uZXh0KCl9aS5wdD1vfSkpLHRoaXN9LGkudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIltvYmplY3QgT2JzZXJ2YWJsZU1hcF1cIn0saS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkuZnJvbSh0aGlzKX0saS5ndD1mdW5jdGlvbih0KXtyZXR1cm4gUXQodGhpcyx0KX0saS5BdD1mdW5jdGlvbih0KXtyZXR1cm4gJHQodGhpcyx0KX0seShuLFt7a2V5Olwic2l6ZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJ0LnJlcG9ydE9ic2VydmVkKCksdGhpcy5wdC5zaXplfX0se2tleTpQaSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIk1hcFwifX1dKSxufSgpLEhpPWgoXCJPYnNlcnZhYmxlTWFwXCIsV2kpLFVpPXt9O0dpPVN5bWJvbC5pdGVyYXRvcixYaT1TeW1ib2wudG9TdHJpbmdUYWc7dmFyIEZpLHppLCRpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLGkscil7dm9pZCAwPT09aSYmKGk9Uyksdm9pZCAwPT09ciYmKHI9XCJPYnNlcnZhYmxlU2V0XCIpLHRoaXMudHQ9dm9pZCAwLHRoaXNbS25dPVVpLHRoaXMucHQ9bmV3IFNldCx0aGlzLmF0PXZvaWQgMCx0aGlzLnN0PXZvaWQgMCx0aGlzLnV0PXZvaWQgMCx0aGlzLmRlaGFuY2VyPXZvaWQgMCx0aGlzLkZ0PXZvaWQgMCx0aGlzLnR0PXIsZShTZXQpfHx0KDIyKSx0aGlzLmF0PV8odGhpcy50dCksdGhpcy5GdD1mdW5jdGlvbih0LG4pe3JldHVybiBpKHQsbixyKX0sbiYmdGhpcy5yZXBsYWNlKG4pfXZhciBpPW4ucHJvdG90eXBlO3JldHVybiBpLiR0PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10aGlzLmRlaGFuY2VyP3RoaXMuZGVoYW5jZXIodCk6dH0saS5jbGVhcj1mdW5jdGlvbigpe3ZhciB0PXRoaXM7V3QoKGZ1bmN0aW9uKCl7b3QoKGZ1bmN0aW9uKCl7Zm9yKHZhciBuLGk9Tyh0LnB0LnZhbHVlcygpKTshKG49aSgpKS5kb25lOyl0LmRlbGV0ZShuLnZhbHVlKX0pKX0pKX0saS5mb3JFYWNoPWZ1bmN0aW9uKHQsbil7Zm9yKHZhciBpLHI9Tyh0aGlzKTshKGk9cigpKS5kb25lOyl7dmFyIGU9aS52YWx1ZTt0LmNhbGwobixlLGUsdGhpcyl9fSxpLmFkZD1mdW5jdGlvbih0KXt2YXIgbj10aGlzO2lmKHp0KHRoaXMpJiYhSnQodGhpcyx7dHlwZTpxaSxvYmplY3Q6dGhpcyxuZXdWYWx1ZTp0fSkpcmV0dXJuIHRoaXM7aWYoIXRoaXMuaGFzKHQpKXtXdCgoZnVuY3Rpb24oKXtuLnB0LmFkZChuLkZ0KHQsdm9pZCAwKSksbi5hdC5yZXBvcnRDaGFuZ2VkKCl9KSk7dmFyIGk9WXQodGhpcyk7aSYmWnQodGhpcyxpP3tvYnNlcnZhYmxlS2luZDpcInNldFwiLGRlYnVnT2JqZWN0TmFtZTp0aGlzLnR0LHR5cGU6cWksb2JqZWN0OnRoaXMsbmV3VmFsdWU6dH06bnVsbCl9cmV0dXJuIHRoaXN9LGkuZGVsZXRlPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7aWYoenQodGhpcykmJiFKdCh0aGlzLHt0eXBlOlwiZGVsZXRlXCIsb2JqZWN0OnRoaXMsb2xkVmFsdWU6dH0pKXJldHVybiExO2lmKHRoaXMuaGFzKHQpKXt2YXIgaT1ZdCh0aGlzKSxyPWk/e29ic2VydmFibGVLaW5kOlwic2V0XCIsZGVidWdPYmplY3ROYW1lOnRoaXMudHQsdHlwZTpcImRlbGV0ZVwiLG9iamVjdDp0aGlzLG9sZFZhbHVlOnR9Om51bGw7cmV0dXJuIFd0KChmdW5jdGlvbigpe24uYXQucmVwb3J0Q2hhbmdlZCgpLG4ucHQuZGVsZXRlKHQpfSkpLGkmJlp0KHRoaXMsciksITB9cmV0dXJuITF9LGkuaGFzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmF0LnJlcG9ydE9ic2VydmVkKCksdGhpcy5wdC5oYXModGhpcy4kdCh0KSl9LGkuZW50cmllcz1mdW5jdGlvbigpe3ZhciB0PTAsbj1BcnJheS5mcm9tKHRoaXMua2V5cygpKSxpPUFycmF5LmZyb20odGhpcy52YWx1ZXMoKSk7cmV0dXJuIHduKHtuZXh0OmZ1bmN0aW9uKCl7dmFyIHI9dDtyZXR1cm4gdCs9MSxyPGkubGVuZ3RoP3t2YWx1ZTpbbltyXSxpW3JdXSxkb25lOiExfTp7ZG9uZTohMH19fSl9LGkua2V5cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlcygpfSxpLnZhbHVlcz1mdW5jdGlvbigpe3RoaXMuYXQucmVwb3J0T2JzZXJ2ZWQoKTt2YXIgdD10aGlzLG49MCxpPUFycmF5LmZyb20odGhpcy5wdC52YWx1ZXMoKSk7cmV0dXJuIHduKHtuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIG48aS5sZW5ndGg/e3ZhbHVlOnQuJHQoaVtuKytdKSxkb25lOiExfTp7ZG9uZTohMH19fSl9LGkucmVwbGFjZT1mdW5jdGlvbihuKXt2YXIgaT10aGlzO3JldHVybiBKaShuKSYmKG49bmV3IFNldChuKSksV3QoKGZ1bmN0aW9uKCl7QXJyYXkuaXNBcnJheShuKXx8bChuKT8oaS5jbGVhcigpLG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGkuYWRkKHQpfSkpKTpudWxsIT1uJiZ0KFwiQ2Fubm90IGluaXRpYWxpemUgc2V0IGZyb20gXCIrbil9KSksdGhpc30saS5ndD1mdW5jdGlvbih0KXtyZXR1cm4gUXQodGhpcyx0KX0saS5BdD1mdW5jdGlvbih0KXtyZXR1cm4gJHQodGhpcyx0KX0saS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkuZnJvbSh0aGlzKX0saS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBPYnNlcnZhYmxlU2V0XVwifSxpW0dpXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlcygpfSx5KG4sW3trZXk6XCJzaXplXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXQucmVwb3J0T2JzZXJ2ZWQoKSx0aGlzLnB0LnNpemV9fSx7a2V5OlhpLGdldDpmdW5jdGlvbigpe3JldHVyblwiU2V0XCJ9fV0pLG59KCksSmk9aChcIk9ic2VydmFibGVTZXRcIiwkaSksWWk9T2JqZWN0LmNyZWF0ZShudWxsKSxRaT1mdW5jdGlvbigpe2Z1bmN0aW9uIG4odCxuLGkscil7dm9pZCAwPT09biYmKG49bmV3IE1hcCksdm9pZCAwPT09ciYmKHI9Qm4pLHRoaXMucz12b2lkIDAsdGhpcy5udD12b2lkIDAsdGhpcy50dD12b2lkIDAsdGhpcy5ybj12b2lkIDAsdGhpcy5idD12b2lkIDAsdGhpcy5zdD12b2lkIDAsdGhpcy51dD12b2lkIDAsdGhpcy52PXZvaWQgMCx0aGlzLmw9dm9pZCAwLHRoaXMuZW49dm9pZCAwLHRoaXMub249dm9pZCAwLHRoaXMucz10LHRoaXMubnQ9bix0aGlzLnR0PWksdGhpcy5ybj1yLHRoaXMuYnQ9bmV3IExuKFwiT2JzZXJ2YWJsZU9iamVjdC5rZXlzXCIpLHRoaXMubD1zKHRoaXMucyl9dmFyIGk9bi5wcm90b3R5cGU7cmV0dXJuIGkuaHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubnQuZ2V0KHQpLmdldCgpfSxpLnZ0PWZ1bmN0aW9uKHQsbil7dmFyIGk9dGhpcy5udC5nZXQodCk7aWYoaSBpbnN0YW5jZW9mIGFpKXJldHVybiBpLnNldChuKSwhMDtpZih6dCh0aGlzKSl7dmFyIHI9SnQodGhpcyx7dHlwZTpUaSxvYmplY3Q6dGhpcy52fHx0aGlzLnMsbmFtZTp0LG5ld1ZhbHVlOm59KTtpZighcilyZXR1cm4gbnVsbDtuPXIubmV3VmFsdWV9aWYoKG49aS54dChuKSkhPT1waS5VTkNIQU5HRUQpe3ZhciBlPVl0KHRoaXMpLG89ZT97dHlwZTpUaSxvYnNlcnZhYmxlS2luZDpcIm9iamVjdFwiLGRlYnVnT2JqZWN0TmFtZTp0aGlzLnR0LG9iamVjdDp0aGlzLnZ8fHRoaXMucyxvbGRWYWx1ZTppLmp0LG5hbWU6dCxuZXdWYWx1ZTpufTpudWxsO2kuT3QobiksZSYmWnQodGhpcyxvKX1yZXR1cm4hMH0saS5sdD1mdW5jdGlvbih0KXtyZXR1cm4gcGkudHJhY2tpbmdEZXJpdmF0aW9uJiYhYih0aGlzLnMsdCkmJnRoaXMucnQodCksdGhpcy5zW3RdfSxpLmR0PWZ1bmN0aW9uKHQsbixpKXtyZXR1cm4gdm9pZCAwPT09aSYmKGk9ITEpLGIodGhpcy5zLHQpP3RoaXMubnQuaGFzKHQpP3RoaXMudnQodCxuKTppP1JlZmxlY3Quc2V0KHRoaXMucyx0LG4pOih0aGlzLnNbdF09biwhMCk6dGhpcy51KHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9LHRoaXMucm4saSl9LGkucnQ9ZnVuY3Rpb24odCl7aWYoIXBpLnRyYWNraW5nRGVyaXZhdGlvbilyZXR1cm4gdCBpbiB0aGlzLnM7dGhpcy5vbnx8KHRoaXMub249bmV3IE1hcCk7dmFyIG49dGhpcy5vbi5nZXQodCk7cmV0dXJuIG58fChuPW5ldyBvaSh0IGluIHRoaXMucyxNLFwiT2JzZXJ2YWJsZU9iamVjdC5rZXk/XCIsITEpLHRoaXMub24uc2V0KHQsbikpLG4uZ2V0KCl9LGkubz1mdW5jdGlvbihuLGkpe2lmKCEwPT09aSYmKGk9dGhpcy5ybiksITEhPT1pKXtpZighKG4gaW4gdGhpcy5zKSl7dmFyIHI7aWYobnVsbD09KHI9dGhpcy5zW0NuXSk/dm9pZCAwOnJbbl0pcmV0dXJuO3QoMSxpLnQsdGhpcy50dCtcIi5cIituLnRvU3RyaW5nKCkpfWZvcih2YXIgZT10aGlzLnM7ZSYmZSE9PV9uOyl7dmFyIG89QW4oZSxuKTtpZihvKXt2YXIgdT1pLm8odGhpcyxuLG8sZSk7aWYoMD09PXUpcmV0dXJuO2lmKDE9PT11KWJyZWFrfWU9T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfWNuKHRoaXMsMCxuKX19LGkudT1mdW5jdGlvbih0LG4saSxyKXtpZih2b2lkIDA9PT1yJiYocj0hMSksITA9PT1pJiYoaT10aGlzLnJuKSwhMT09PWkpcmV0dXJuIHRoaXMuaCh0LG4scik7dmFyIGU9aS51KHRoaXMsdCxuLHIpO3JldHVybiBlJiZjbih0aGlzLDAsdCksZX0saS5oPWZ1bmN0aW9uKHQsbixpKXt2b2lkIDA9PT1pJiYoaT0hMSk7dHJ5e2R0KCk7dmFyIHI9dGhpcy5HdCh0KTtpZighcilyZXR1cm4gcjtpZih6dCh0aGlzKSl7dmFyIGU9SnQodGhpcyx7b2JqZWN0OnRoaXMudnx8dGhpcy5zLG5hbWU6dCx0eXBlOnFpLG5ld1ZhbHVlOm4udmFsdWV9KTtpZighZSlyZXR1cm4gbnVsbDt2YXIgbz1lLm5ld1ZhbHVlO24udmFsdWUhPT1vJiYobj1tKHt9LG4se3ZhbHVlOm99KSl9aWYoaSl7aWYoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGhpcy5zLHQsbikpcmV0dXJuITF9ZWxzZSBnbih0aGlzLnMsdCxuKTt0aGlzLnVuKHQsbi52YWx1ZSl9ZmluYWxseXtidCgpfXJldHVybiEwfSxpLm09ZnVuY3Rpb24odCxuLGkscil7dm9pZCAwPT09ciYmKHI9ITEpO3RyeXtkdCgpO3ZhciBlPXRoaXMuR3QodCk7aWYoIWUpcmV0dXJuIGU7aWYoenQodGhpcykpe3ZhciBvPUp0KHRoaXMse29iamVjdDp0aGlzLnZ8fHRoaXMucyxuYW1lOnQsdHlwZTpxaSxuZXdWYWx1ZTpufSk7aWYoIW8pcmV0dXJuIG51bGw7bj1vLm5ld1ZhbHVlfXZhciB1PWZuKHQpLHM9e2NvbmZpZ3VyYWJsZTohcGkuc2FmZURlc2NyaXB0b3JzfHx0aGlzLmwsZW51bWVyYWJsZTohMCxnZXQ6dS5nZXQsc2V0OnUuc2V0fTtpZihyKXtpZighUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnMsdCxzKSlyZXR1cm4hMX1lbHNlIGduKHRoaXMucyx0LHMpO3ZhciBmPW5ldyBvaShuLGksXCJPYnNlcnZhYmxlT2JqZWN0LmtleVwiLCExKTt0aGlzLm50LnNldCh0LGYpLHRoaXMudW4odCxmLmp0KX1maW5hbGx5e2J0KCl9cmV0dXJuITB9LGkucD1mdW5jdGlvbih0LG4saSl7dm9pZCAwPT09aSYmKGk9ITEpO3RyeXtkdCgpO3ZhciByPXRoaXMuR3QodCk7aWYoIXIpcmV0dXJuIHI7aWYoenQodGhpcykmJiFKdCh0aGlzLHtvYmplY3Q6dGhpcy52fHx0aGlzLnMsbmFtZTp0LHR5cGU6cWksbmV3VmFsdWU6dm9pZCAwfSkpcmV0dXJuIG51bGw7bi5uYW1lfHwobi5uYW1lPVwiT2JzZXJ2YWJsZU9iamVjdC5rZXlcIiksbi5jb250ZXh0PXRoaXMudnx8dGhpcy5zO3ZhciBlPWZuKHQpLG89e2NvbmZpZ3VyYWJsZTohcGkuc2FmZURlc2NyaXB0b3JzfHx0aGlzLmwsZW51bWVyYWJsZTohMSxnZXQ6ZS5nZXQsc2V0OmUuc2V0fTtpZihpKXtpZighUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnMsdCxvKSlyZXR1cm4hMX1lbHNlIGduKHRoaXMucyx0LG8pO3RoaXMubnQuc2V0KHQsbmV3IGFpKG4pKSx0aGlzLnVuKHQsdm9pZCAwKX1maW5hbGx5e2J0KCl9cmV0dXJuITB9LGkuR3Q9ZnVuY3Rpb24odCxuKXtpZih2b2lkIDA9PT1uJiYobj0hMSksIWIodGhpcy5zLHQpKXJldHVybiEwO2lmKHp0KHRoaXMpJiYhSnQodGhpcyx7b2JqZWN0OnRoaXMudnx8dGhpcy5zLG5hbWU6dCx0eXBlOlwicmVtb3ZlXCJ9KSlyZXR1cm4gbnVsbDt0cnl7dmFyIGkscjtkdCgpO3ZhciBlLG89WXQodGhpcyksdT10aGlzLm50LmdldCh0KSxzPXZvaWQgMDtpZighdSYmbyYmKHM9bnVsbD09KGU9QW4odGhpcy5zLHQpKT92b2lkIDA6ZS52YWx1ZSksbil7aWYoIVJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGhpcy5zLHQpKXJldHVybiExfWVsc2UgZGVsZXRlIHRoaXMuc1t0XTt1JiYodGhpcy5udC5kZWxldGUodCksdSBpbnN0YW5jZW9mIG9pJiYocz11Lmp0KSx5dCh1KSksdGhpcy5idC5yZXBvcnRDaGFuZ2VkKCksbnVsbD09KGk9dGhpcy5vbil8fG51bGw9PShyPWkuZ2V0KHQpKXx8ci5zZXQodCBpbiB0aGlzLnMpLG8mJm8mJlp0KHRoaXMse3R5cGU6XCJyZW1vdmVcIixvYnNlcnZhYmxlS2luZDpcIm9iamVjdFwiLG9iamVjdDp0aGlzLnZ8fHRoaXMucyxkZWJ1Z09iamVjdE5hbWU6dGhpcy50dCxvbGRWYWx1ZTpzLG5hbWU6dH0pfWZpbmFsbHl7YnQoKX1yZXR1cm4hMH0saS5ndD1mdW5jdGlvbih0KXtyZXR1cm4gUXQodGhpcyx0KX0saS5BdD1mdW5jdGlvbih0KXtyZXR1cm4gJHQodGhpcyx0KX0saS51bj1mdW5jdGlvbih0LG4pe3ZhciBpLHIsZT1ZdCh0aGlzKTtlJiZlJiZadCh0aGlzLGU/e3R5cGU6cWksb2JzZXJ2YWJsZUtpbmQ6XCJvYmplY3RcIixkZWJ1Z09iamVjdE5hbWU6dGhpcy50dCxvYmplY3Q6dGhpcy52fHx0aGlzLnMsbmFtZTp0LG5ld1ZhbHVlOm59Om51bGwpLG51bGw9PShpPXRoaXMub24pfHxudWxsPT0ocj1pLmdldCh0KSl8fHIuc2V0KCEwKSx0aGlzLmJ0LnJlcG9ydENoYW5nZWQoKX0saS5ldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ0LnJlcG9ydE9ic2VydmVkKCksRW4odGhpcy5zKX0saS5pdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ0LnJlcG9ydE9ic2VydmVkKCksT2JqZWN0LmtleXModGhpcy5zKX0sbn0oKSxaaT1oKFwiT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uXCIsUWkpLHRyPTAsbnI9ZnVuY3Rpb24oKXt9O0ZpPW5yLHppPUFycmF5LnByb3RvdHlwZSxPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKEZpLnByb3RvdHlwZSx6aSk6dm9pZCAwIT09RmkucHJvdG90eXBlLl9fcHJvdG9fXz9GaS5wcm90b3R5cGUuX19wcm90b19fPXppOkZpLnByb3RvdHlwZT16aTt2YXIgaXI9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihuLGkscixlKXt2YXIgbzt2b2lkIDA9PT1yJiYocj1cIk9ic2VydmFibGVBcnJheVwiKSx2b2lkIDA9PT1lJiYoZT0hMSksbz10LmNhbGwodGhpcyl8fHRoaXM7dmFyIHU9bmV3IEtpKHIsaSxlLCEwKTtpZih1LnY9aihvKSxjKGoobyksS24sdSksbiYmbi5sZW5ndGgpe3ZhciBzPVooITApO28uc3BsaWNlV2l0aEFycmF5KDAsMCxuKSx0dChzKX1yZXR1cm4gb313KG4sdCk7dmFyIGk9bi5wcm90b3R5cGU7cmV0dXJuIGkuY29uY2F0PWZ1bmN0aW9uKCl7dGhpc1tLbl0uYXQucmVwb3J0T2JzZXJ2ZWQoKTtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPW5ldyBBcnJheSh0KSxpPTA7aTx0O2krKyluW2ldPWFyZ3VtZW50c1tpXTtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseSh0aGlzLnNsaWNlKCksbi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB1bih0KT90LnNsaWNlKCk6dH0pKSl9LGlbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3ZhciB0PXRoaXMsbj0wO3JldHVybiB3bih7bmV4dDpmdW5jdGlvbigpe3JldHVybiBuPHQubGVuZ3RoP3t2YWx1ZTp0W24rK10sZG9uZTohMX06e2RvbmU6ITAsdmFsdWU6dm9pZCAwfX19KX0seShuLFt7a2V5OlwibGVuZ3RoXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbS25dLlh0KCl9LHNldDpmdW5jdGlvbih0KXt0aGlzW0tuXS5XdCh0KX19LHtrZXk6U3ltYm9sLnRvU3RyaW5nVGFnLGdldDpmdW5jdGlvbigpe3JldHVyblwiQXJyYXlcIn19XSksbn0obnIpO09iamVjdC5lbnRyaWVzKExpKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbj10WzBdO1wiY29uY2F0XCIhPT1uJiZhKGlyLnByb3RvdHlwZSxuLHRbMV0pfSkpLHZuKDFlMyk7dmFyIHJyPV9uLnRvU3RyaW5nO1tcIlN5bWJvbFwiLFwiTWFwXCIsXCJTZXRcIl0uZm9yRWFjaCgoZnVuY3Rpb24oaSl7dm9pZCAwPT09bigpW2ldJiZ0KFwiTW9iWCByZXF1aXJlcyBnbG9iYWwgJ1wiK2krXCInIHRvIGJlIGF2YWlsYWJsZSBvciBwb2x5ZmlsbGVkXCIpfSkpLFwib2JqZWN0XCI9PXR5cGVvZiBfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyYmX19NT0JYX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0TW9ieCh7c3B5Omp0LGV4dHJhczp7Z2V0RGVidWdOYW1lOnBufSwkbW9ieDpLbn0pLGV4cG9ydHMuJG1vYng9S24sZXhwb3J0cy5GbG93Q2FuY2VsbGF0aW9uRXJyb3I9RXQsZXhwb3J0cy5PYnNlcnZhYmxlTWFwPVdpLGV4cG9ydHMuT2JzZXJ2YWJsZVNldD0kaSxleHBvcnRzLlJlYWN0aW9uPXlpLGV4cG9ydHMuX2FsbG93U3RhdGVDaGFuZ2VzPVEsZXhwb3J0cy5fYWxsb3dTdGF0ZUNoYW5nZXNJbnNpZGVDb21wdXRlZD1PdCxleHBvcnRzLl9hbGxvd1N0YXRlUmVhZHNFbmQ9YXQsZXhwb3J0cy5fYWxsb3dTdGF0ZVJlYWRzU3RhcnQ9ZnQsZXhwb3J0cy5fYXV0b0FjdGlvbj1faSxleHBvcnRzLl9lbmRBY3Rpb249WSxleHBvcnRzLl9nZXRBZG1pbmlzdHJhdGlvbj1ibixleHBvcnRzLl9nZXRHbG9iYWxTdGF0ZT1mdW5jdGlvbigpe3JldHVybiBwaX0sZXhwb3J0cy5faW50ZXJjZXB0UmVhZHM9ZnVuY3Rpb24odCxuLGkpe3ZhciByO3JldHVybiBIaSh0KXx8dW4odCl8fHVpKHQpP3I9Ym4odCk6YW4odCkmJihyPWJuKHQsbikpLHIuZGVoYW5jZXI9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOmksZnVuY3Rpb24oKXtyLmRlaGFuY2VyPXZvaWQgMH19LGV4cG9ydHMuX2lzQ29tcHV0aW5nRGVyaXZhdGlvbj1mdW5jdGlvbigpe3JldHVybiBudWxsIT09cGkudHJhY2tpbmdEZXJpdmF0aW9ufSxleHBvcnRzLl9yZXNldEdsb2JhbFN0YXRlPWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGxpO2Zvcih2YXIgbiBpbiB0KS0xPT09dmkuaW5kZXhPZihuKSYmKHBpW25dPXRbbl0pO3BpLmFsbG93U3RhdGVDaGFuZ2VzPSFwaS5lbmZvcmNlQWN0aW9uc30sZXhwb3J0cy5fc3RhcnRBY3Rpb249SixleHBvcnRzLmFjdGlvbj1naSxleHBvcnRzLmF1dG9ydW49Z3QsZXhwb3J0cy5jb21wYXJlcj1QbixleHBvcnRzLmNvbXB1dGVkPVFuLGV4cG9ydHMuY29uZmlndXJlPWZ1bmN0aW9uKGkpeyEwPT09aS5pc29sYXRlR2xvYmFsU3RhdGUmJmZ1bmN0aW9uKCl7aWYoKHBpLnBlbmRpbmdSZWFjdGlvbnMubGVuZ3RofHxwaS5pbkJhdGNofHxwaS5pc1J1bm5pbmdSZWFjdGlvbnMpJiZ0KDM2KSxiaT0hMCxkaSl7dmFyIGk9bigpOzA9PS0taS5fX21vYnhJbnN0YW5jZUNvdW50JiYoaS5fX21vYnhHbG9iYWxzPXZvaWQgMCkscGk9bmV3IGxpfX0oKTt2YXIgcixlLG89aS51c2VQcm94aWVzLHU9aS5lbmZvcmNlQWN0aW9ucztpZih2b2lkIDAhPT1vJiYocGkudXNlUHJveGllcz1cImFsd2F5c1wiPT09b3x8XCJuZXZlclwiIT09byYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb3h5KSxcImlmYXZhaWxhYmxlXCI9PT1vJiYocGkudmVyaWZ5UHJveGllcz0hMCksdm9pZCAwIT09dSl7dmFyIHM9XCJhbHdheXNcIj09PXU/XCJhbHdheXNcIjpcIm9ic2VydmVkXCI9PT11O3BpLmVuZm9yY2VBY3Rpb25zPXMscGkuYWxsb3dTdGF0ZUNoYW5nZXM9ITAhPT1zJiZcImFsd2F5c1wiIT09c31bXCJjb21wdXRlZFJlcXVpcmVzUmVhY3Rpb25cIixcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsXCJvYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvblwiLFwiZGlzYWJsZUVycm9yQm91bmRhcmllc1wiLFwic2FmZURlc2NyaXB0b3JzXCJdLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QgaW4gaSYmKHBpW3RdPSEhaVt0XSl9KSkscGkuYWxsb3dTdGF0ZVJlYWRzPSFwaS5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbixpLnJlYWN0aW9uU2NoZWR1bGVyJiYocj1pLnJlYWN0aW9uU2NoZWR1bGVyLGU9bWksbWk9ZnVuY3Rpb24odCl7cmV0dXJuIHIoKGZ1bmN0aW9uKCl7cmV0dXJuIGUodCl9KSl9KX0sZXhwb3J0cy5jcmVhdGVBdG9tPV8sZXhwb3J0cy5kZWZpbmVQcm9wZXJ0eT1mdW5jdGlvbihuLGkscil7aWYoYW4obikpcmV0dXJuIG5bS25dLmgoaSxyKTt0KDM5KX0sZXhwb3J0cy5lbnRyaWVzPWZ1bmN0aW9uKG4pe3JldHVybiBhbihuKT9QdChuKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblt0LG5bdF1dfSkpOkhpKG4pP1B0KG4pLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuW3Qsbi5nZXQodCldfSkpOkppKG4pP0FycmF5LmZyb20obi5lbnRyaWVzKCkpOnVuKG4pP24ubWFwKChmdW5jdGlvbih0LG4pe3JldHVybltuLHRdfSkpOnZvaWQgdCg3KX0sZXhwb3J0cy5leHRlbmRPYnNlcnZhYmxlPU50LGV4cG9ydHMuZmxvdz1SaSxleHBvcnRzLmZsb3dSZXN1bHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGV4cG9ydHMuZ2V0PWZ1bmN0aW9uKG4saSl7aWYoRHQobixpKSlyZXR1cm4gYW4obik/bltLbl0ubHQoaSk6SGkobik/bi5nZXQoaSk6dW4obik/bltpXTp2b2lkIHQoMTEpfSxleHBvcnRzLmdldEF0b209ZG4sZXhwb3J0cy5nZXREZWJ1Z05hbWU9cG4sZXhwb3J0cy5nZXREZXBlbmRlbmN5VHJlZT1mdW5jdGlvbih0LG4pe3JldHVybiBSdChkbih0LG4pKX0sZXhwb3J0cy5nZXRPYnNlcnZlclRyZWU9ZnVuY3Rpb24odCxuKXtyZXR1cm4ga3QoZG4odCxuKSl9LGV4cG9ydHMuaGFzPUR0LGV4cG9ydHMuaW50ZXJjZXB0PWZ1bmN0aW9uKHQsbixpKXtyZXR1cm4gZShpKT9mdW5jdGlvbih0LG4saSl7cmV0dXJuIGJuKHQsbikuQXQoaSl9KHQsbixpKTpmdW5jdGlvbih0LG4pe3JldHVybiBibih0KS5BdChuKX0odCxuKX0sZXhwb3J0cy5pc0FjdGlvbj1BdCxleHBvcnRzLmlzQm94ZWRPYnNlcnZhYmxlPXVpLGV4cG9ydHMuaXNDb21wdXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gS3QodCl9LGV4cG9ydHMuaXNDb21wdXRlZFByb3A9ZnVuY3Rpb24odCxuKXtyZXR1cm4gS3QodCxuKX0sZXhwb3J0cy5pc0Zsb3c9Q3QsZXhwb3J0cy5pc0Zsb3dDYW5jZWxsYXRpb25FcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEV0fSxleHBvcnRzLmlzT2JzZXJ2YWJsZT1JdCxleHBvcnRzLmlzT2JzZXJ2YWJsZUFycmF5PXVuLGV4cG9ydHMuaXNPYnNlcnZhYmxlTWFwPUhpLGV4cG9ydHMuaXNPYnNlcnZhYmxlT2JqZWN0PWFuLGV4cG9ydHMuaXNPYnNlcnZhYmxlUHJvcD1mdW5jdGlvbih0LG4pe3JldHVybiBMdCh0LG4pfSxleHBvcnRzLmlzT2JzZXJ2YWJsZVNldD1KaSxleHBvcnRzLmtleXM9UHQsZXhwb3J0cy5tYWtlQXV0b09ic2VydmFibGU9ZnVuY3Rpb24odCxuLGkpe2lmKHModCkpcmV0dXJuIE50KHQsdCxuLGkpO3ZhciByPXNuKHQsaSlbS25dO2lmKCF0W0VpXSl7dmFyIGU9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpLG89bmV3IFNldChbXS5jb25jYXQoRW4odCksRW4oZSkpKTtvLmRlbGV0ZShcImNvbnN0cnVjdG9yXCIpLG8uZGVsZXRlKEtuKSxhKGUsRWksbyl9ZHQoKTt0cnl7dFtFaV0uZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHIubyh0LCFufHwhKHQgaW4gbil8fG5bdF0pfSkpfWZpbmFsbHl7YnQoKX1yZXR1cm4gdH0sZXhwb3J0cy5tYWtlT2JzZXJ2YWJsZT1mdW5jdGlvbih0LG4saSl7dmFyIHI9c24odCxpKVtLbl07ZHQoKTt0cnl7bnVsbCE9bnx8KG49ZnVuY3Rpb24odCl7cmV0dXJuIGIodCxDbil8fGEodCxDbixtKHt9LHRbQ25dKSksdFtDbl19KHQpKSxFbihuKS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gci5vKHQsblt0XSl9KSl9ZmluYWxseXtidCgpfXJldHVybiB0fSxleHBvcnRzLm9ic2VydmFibGU9JG4sZXhwb3J0cy5vYnNlcnZlPWZ1bmN0aW9uKHQsbixpLHIpe3JldHVybiBlKGkpP2Z1bmN0aW9uKHQsbixpLHIpe3JldHVybiBibih0LG4pLmd0KGkscil9KHQsbixpLHIpOmZ1bmN0aW9uKHQsbixpKXtyZXR1cm4gYm4odCkuZ3QobixpKX0odCxuLGkpfSxleHBvcnRzLm9uQmVjb21lT2JzZXJ2ZWQ9U3QsZXhwb3J0cy5vbkJlY29tZVVub2JzZXJ2ZWQ9TXQsZXhwb3J0cy5vblJlYWN0aW9uRXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHBpLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5wdXNoKHQpLGZ1bmN0aW9uKCl7dmFyIG49cGkuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLmluZGV4T2YodCk7bj49MCYmcGkuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLnNwbGljZShuLDEpfX0sZXhwb3J0cy5vdmVycmlkZT1EbixleHBvcnRzLm93bktleXM9QnQsZXhwb3J0cy5yZWFjdGlvbj1mdW5jdGlvbih0LG4saSl7ZnVuY3Rpb24gcigpe2lmKGw9ITEsIXAuSil7dmFyIG49ITE7cC50cmFjaygoZnVuY3Rpb24oKXt2YXIgaT1RKCExLChmdW5jdGlvbigpe3JldHVybiB0KHApfSkpO249dnx8IWIocyxpKSxkPXMscz1pfSkpLCh2JiZpLmZpcmVJbW1lZGlhdGVseXx8IXYmJm4pJiZhKHMsZCxwKSx2PSExfX12YXIgZTt2b2lkIDA9PT1pJiYoaT1Nbik7dmFyIG8sdSxzLGY9bnVsbCE9KGU9aS5uYW1lKT9lOlwiUmVhY3Rpb25cIixhPWdpKGYsaS5vbkVycm9yPyhvPWkub25FcnJvcix1PW4sZnVuY3Rpb24oKXt0cnl7cmV0dXJuIHUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWNhdGNoKHQpe28uY2FsbCh0aGlzLHQpfX0pOm4pLGM9IWkuc2NoZWR1bGVyJiYhaS5kZWxheSxoPV90KGkpLHY9ITAsbD0hMSxkPXZvaWQgMCxiPWkuY29tcGFyZVN0cnVjdHVyYWw/UG4uc3RydWN0dXJhbDppLmVxdWFsc3x8UG4uZGVmYXVsdCxwPW5ldyB5aShmLChmdW5jdGlvbigpe3Z8fGM/cigpOmx8fChsPSEwLGgocikpfSksaS5vbkVycm9yLGkucmVxdWlyZXNPYnNlcnZhYmxlKTtyZXR1cm4gcC5ZKCkscC5aKCl9LGV4cG9ydHMucmVtb3ZlPWZ1bmN0aW9uKG4saSl7YW4obik/bltLbl0uR3QoaSk6SGkobil8fEppKG4pP24uZGVsZXRlKGkpOnVuKG4pPyhcIm51bWJlclwiIT10eXBlb2YgaSYmKGk9cGFyc2VJbnQoaSwxMCkpLG4uc3BsaWNlKGksMSkpOnQoOSl9LGV4cG9ydHMucnVuSW5BY3Rpb249T3QsZXhwb3J0cy5zZXQ9ZnVuY3Rpb24gbihpLHIsZSl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGh8fEppKGkpKWFuKGkpP2lbS25dLmR0KHIsZSk6SGkoaSk/aS5zZXQocixlKTpKaShpKT9pLmFkZChyKTp1bihpKT8oXCJudW1iZXJcIiE9dHlwZW9mIHImJihyPXBhcnNlSW50KHIsMTApKSxyPDAmJnQoXCJJbnZhbGlkIGluZGV4OiAnXCIrcitcIidcIiksZHQoKSxyPj1pLmxlbmd0aCYmKGkubGVuZ3RoPXIrMSksaVtyXT1lLGJ0KCkpOnQoOCk7ZWxzZXtkdCgpO3ZhciBvPXI7dHJ5e2Zvcih2YXIgdSBpbiBvKW4oaSx1LG9bdV0pfWZpbmFsbHl7YnQoKX19fSxleHBvcnRzLnNweT1qdCxleHBvcnRzLnRvSlM9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uIHQobixpKXtpZihudWxsPT1ufHxcIm9iamVjdFwiIT10eXBlb2Ygbnx8biBpbnN0YW5jZW9mIERhdGV8fCFJdChuKSlyZXR1cm4gbjtpZih1aShuKXx8Y2kobikpcmV0dXJuIHQobi5nZXQoKSxpKTtpZihpLmhhcyhuKSlyZXR1cm4gaS5nZXQobik7aWYodW4obikpe3ZhciByPXF0KGksbixuZXcgQXJyYXkobi5sZW5ndGgpKTtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbihuLGUpe3JbZV09dChuLGkpfSkpLHJ9aWYoSmkobikpe3ZhciBlPXF0KGksbixuZXcgU2V0KTtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbihuKXtlLmFkZCh0KG4saSkpfSkpLGV9aWYoSGkobikpe3ZhciBvPXF0KGksbixuZXcgTWFwKTtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbihuLHIpe28uc2V0KHIsdChuLGkpKX0pKSxvfXZhciB1PXF0KGksbix7fSk7cmV0dXJuIEJ0KG4pLmZvckVhY2goKGZ1bmN0aW9uKHIpe19uLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwobixyKSYmKHVbcl09dChuW3JdLGkpKX0pKSx1fSh0LG5ldyBNYXApfSxleHBvcnRzLnRyYWNlPUd0LGV4cG9ydHMudHJhbnNhY3Rpb249V3QsZXhwb3J0cy51bnRyYWNrZWQ9b3QsZXhwb3J0cy52YWx1ZXM9ZnVuY3Rpb24obil7cmV0dXJuIGFuKG4pP1B0KG4pLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG5bdF19KSk6SGkobik/UHQobikubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gbi5nZXQodCl9KSk6Smkobik/QXJyYXkuZnJvbShuLnZhbHVlcygpKTp1bihuKT9uLnNsaWNlKCk6dm9pZCB0KDYpfSxleHBvcnRzLndoZW49ZnVuY3Rpb24odCxuLGkpe3JldHVybiAxPT09YXJndW1lbnRzLmxlbmd0aHx8biYmXCJvYmplY3RcIj09dHlwZW9mIG4/VXQodCxuKTpIdCh0LG4saXx8e30pfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vYnguY2pzLnByb2R1Y3Rpb24ubWluLmpzLm1hcFxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCIhZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy50YWJsZT1uZXcgVWludDE2QXJyYXkoMTYpLHRoaXMudD1uZXcgVWludDE2QXJyYXkoMjg4KX1mdW5jdGlvbiBmKGYsdil7dGhpcy5zb3VyY2U9Zix0aGlzLnNvdXJjZUluZGV4PTAsdGhpcy50YWc9MCx0aGlzLnY9MCx0aGlzLk09dix0aGlzLko9MCx0aGlzLm89bmV3IHQsdGhpcy51PW5ldyB0fXZhciB2PW5ldyB0LGI9bmV3IHQsTT1uZXcgVWludDhBcnJheSgzMCksSj1uZXcgVWludDE2QXJyYXkoMzApLHI9bmV3IFVpbnQ4QXJyYXkoMzApLGU9bmV3IFVpbnQxNkFycmF5KDMwKSxhPW5ldyBVaW50OEFycmF5KFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSksbj1uZXcgdCxpPW5ldyBVaW50OEFycmF5KDMyMCk7ZnVuY3Rpb24gbyh0LGYsdixiKXt2YXIgTSxKO2ZvcihNPTA7TTx2OysrTSl0W01dPTA7Zm9yKE09MDtNPDMwLXY7KytNKXRbTSt2XT1NL3Z8MDtmb3IoSj1iLE09MDtNPDMwOysrTSlmW01dPUosSis9MTw8dFtNXX12YXIgcz1uZXcgVWludDE2QXJyYXkoMTYpO2Z1bmN0aW9uIHUodCxmLHYsYil7dmFyIE0sSjtmb3IoTT0wO008MTY7KytNKXQudGFibGVbTV09MDtmb3IoTT0wO008YjsrK00pdC50YWJsZVtmW3YrTV1dKys7Zm9yKHQudGFibGVbMF09MCxKPTAsTT0wO008MTY7KytNKXNbTV09SixKKz10LnRhYmxlW01dO2ZvcihNPTA7TTxiOysrTSlmW3YrTV0mJih0LnRbc1tmW3YrTV1dKytdPU0pfWZ1bmN0aW9uIGModCl7dC52LS18fCh0LnRhZz10LnNvdXJjZVt0LnNvdXJjZUluZGV4KytdLHQudj03KTt2YXIgZj0xJnQudGFnO3JldHVybiB0LnRhZz4+Pj0xLGZ9ZnVuY3Rpb24gaCh0LGYsdil7aWYoIWYpcmV0dXJuIHY7Zm9yKDt0LnY8MjQ7KXQudGFnfD10LnNvdXJjZVt0LnNvdXJjZUluZGV4KytdPDx0LnYsdC52Kz04O3ZhciBiPXQudGFnJjY1NTM1Pj4+MTYtZjtyZXR1cm4gdC50YWc+Pj49Zix0LnYtPWYsYit2fWZ1bmN0aW9uIGQodCxmKXtmb3IoO3QudjwyNDspdC50YWd8PXQuc291cmNlW3Quc291cmNlSW5kZXgrK108PHQudix0LnYrPTg7dmFyIHY9MCxiPTAsTT0wLEo9dC50YWc7ZG97Yj0yKmIrKDEmSiksSj4+Pj0xLCsrTSx2Kz1mLnRhYmxlW01dLGItPWYudGFibGVbTV19d2hpbGUoYj49MCk7cmV0dXJuIHQudGFnPUosdC52LT1NLGYudFt2K2JdfWZ1bmN0aW9uIHcodCxmLHYpe3ZhciBiLE0sSixyLGUsbztmb3IoYj1oKHQsNSwyNTcpLE09aCh0LDUsMSksSj1oKHQsNCw0KSxyPTA7cjwxOTsrK3IpaVtyXT0wO2ZvcihyPTA7cjxKOysrcil7dmFyIHM9aCh0LDMsMCk7aVthW3JdXT1zfWZvcih1KG4saSwwLDE5KSxlPTA7ZTxiK007KXt2YXIgYz1kKHQsbik7c3dpdGNoKGMpe2Nhc2UgMTY6dmFyIHc9aVtlLTFdO2ZvcihvPWgodCwyLDMpO287LS1vKWlbZSsrXT13O2JyZWFrO2Nhc2UgMTc6Zm9yKG89aCh0LDMsMyk7bzstLW8paVtlKytdPTA7YnJlYWs7Y2FzZSAxODpmb3Iobz1oKHQsNywxMSk7bzstLW8paVtlKytdPTA7YnJlYWs7ZGVmYXVsdDppW2UrK109Y319dShmLGksMCxiKSx1KHYsaSxiLE0pfWZ1bmN0aW9uIGwodCxmLHYpe2Zvcig7Oyl7dmFyIGIsYSxuLGksbz1kKHQsZik7aWYoMjU2PT09bylyZXR1cm4gMDtpZihvPDI1Nil0Lk1bdC5KKytdPW87ZWxzZSBmb3IoYj1oKHQsTVtvLT0yNTddLEpbb10pLGE9ZCh0LHYpLGk9bj10LkotaCh0LHJbYV0sZVthXSk7aTxuK2I7KytpKXQuTVt0LkorK109dC5NW2ldfX1mdW5jdGlvbiB5KHQpe2Zvcih2YXIgZix2O3Qudj44Oyl0LnNvdXJjZUluZGV4LS0sdC52LT04O2lmKChmPTI1NiooZj10LnNvdXJjZVt0LnNvdXJjZUluZGV4KzFdKSt0LnNvdXJjZVt0LnNvdXJjZUluZGV4XSkhPT0oNjU1MzUmfigyNTYqdC5zb3VyY2VbdC5zb3VyY2VJbmRleCszXSt0LnNvdXJjZVt0LnNvdXJjZUluZGV4KzJdKSkpcmV0dXJuLTM7Zm9yKHQuc291cmNlSW5kZXgrPTQsdj1mO3Y7LS12KXQuTVt0LkorK109dC5zb3VyY2VbdC5zb3VyY2VJbmRleCsrXTtyZXR1cm4gdC52PTAsMH0hZnVuY3Rpb24odCxmKXt2YXIgdjtmb3Iodj0wO3Y8NzsrK3YpdC50YWJsZVt2XT0wO2Zvcih0LnRhYmxlWzddPTI0LHQudGFibGVbOF09MTUyLHQudGFibGVbOV09MTEyLHY9MDt2PDI0Oysrdil0LnRbdl09MjU2K3Y7Zm9yKHY9MDt2PDE0NDsrK3YpdC50WzI0K3ZdPXY7Zm9yKHY9MDt2PDg7Kyt2KXQudFsxNjgrdl09MjgwK3Y7Zm9yKHY9MDt2PDExMjsrK3YpdC50WzE3Nit2XT0xNDQrdjtmb3Iodj0wO3Y8NTsrK3YpZi50YWJsZVt2XT0wO2ZvcihmLnRhYmxlWzVdPTMyLHY9MDt2PDMyOysrdilmLnRbdl09dn0odixiKSxvKE0sSiw0LDMpLG8ocixlLDIsMSksTVsyOF09MCxKWzI4XT0yNTg7dmFyIHAsUSxPPU87ZnVuY3Rpb24gZygpe31PPW1vZHVsZTtmb3IodmFyIEE9bmV3IFVpbnQ4QXJyYXkoMTIzKSxTPTI1O1M+PTA7LS1TKUFbNDgrU109NTIrUyxBWzY1K1NdPVMsQVs5NytTXT0yNitTO0FbNDNdPTYyLEFbNDddPTYzLE8ud2FzbT1mdW5jdGlvbih0LE0pe3ZhciBKLHIsZT1uZXcgZih0LG5ldyBVaW50OEFycmF5KDExNjIxMCkpO2Rve3N3aXRjaChKPWMoZSksaChlLDIsMCkpe2Nhc2UgMDpyPXkoZSk7YnJlYWs7Y2FzZSAxOnI9bChlLHYsYik7YnJlYWs7Y2FzZSAyOncoZSxlLm8sZS51KSxyPWwoZSxlLm8sZS51KTticmVhaztkZWZhdWx0OnI9LTN9aWYoMCE9PXIpdGhyb3cgRXJyb3IoXCJEYXRhIGVycm9yXCIpfXdoaWxlKCFKKTtyZXR1cm4gZS5KPGUuTS5sZW5ndGg/XCJmdW5jdGlvblwiPT10eXBlb2YgZS5NLnNsaWNlP2UuTS5zbGljZSgwLGUuSik6ZS5NLnN1YmFycmF5KDAsZS5KKTplLk19KCh0PT57Y29uc3QgZj1uZXcgVWludDhBcnJheSg3MjM3NCk7bGV0IHYsYj0hMSxNPTA7Zm9yKGxldCBKPTA7Sjw3MjM3NDtKKyspdj10LmNoYXJDb2RlQXQoSiksMTMhPT12JiYxMCE9PXYmJig2MSE9PXZ8fGI/KGImJihiPSExLHYtPTY0KSxmW00rK109djw0MiYmdj4wP3YrMjE0OnYtNDIpOmI9ITApO3JldHVybiBmLnN1YmFycmF5KDAsTSl9KShcIsOWw6c1wrpHXHUwMDAxwqNcdTAwMTHCocOlXHUwMDE5wqVcdTAwMTjDh8ODw4hRMF0tXFxmwp4tLsKxTjLCrExewq5cXFwiLETCpsKrSm/Ck3dcdTAwMWLCj8OZwpLCpMKBQFx1MDAwZsKlMcOeKzh6XFxiP8KrwqvDncOebcOxw7bCsHXDq1vClcKBP8OdfMOUwrzClMK1w5h8wpvCj8OZw5TDlsOuw5rDtcK/w6I8woPCjH50w6xcdTAwMDRcdTAwMDLDn8K2woFcdTAwMTXCksOHw7FcXFxcP8OPXHUwMDE2XHUwMDA3wr/DtyYoXFx0wqEkw7hHwrrDvsKYwo/DgVZ2IVx1MDAxN2jCuVx1MDAxOcOGXHUwMDFkw6fDucKhw6jDmCfDvlx1MDAxZMORwr3ChMOXw4DCpltXw4hzw6HDoMK8w5fCkVx1MDAxNMKFwqBzw6DClMO5XsOiXHUwMDBmwrx+wrnClcO5Xlx1MDAxZsKuwpXCp1x1MDAxNcOMSHzDjcKkw7DDmcOgXHUwMDA3XHUwMDEye8OVw6RzwohywojDmixBWMO+w4hcdTAwMTPDsCHCpHvCv8OPw4RcdTAwMWZ8wp/CpmvDp8KHwqbDkMKBwr/DpnrDp8Okw7J9wqTDp8Oyw5nDlMOHNcKkP8OlXFxcXMKKXHUwMDFlwpx+XcOsw6Nvw7EoXHUwMDE2LMKXXHUwMDEzwoPDlyB2wqnDljp5ZMO/w5fChMObWFx1MDAxNsOzb0nCjldcdTAwMDN0wqFhwrzDiXTCqMOUPUBcdTAwMTFcdTAwMTlcXHTDmsOpwqnDncOAXHUwMDFhIV3Dn3Anwq/DuVFzV8OXw5/CvHB8w4XClV7ClFx1MDAxNyNcdTAwMTBsw4TDjsK1XHUwMDFmwoRhw5PCn8K8wqTCl8OcXFxiw4LDgsOUw489fcOlwqTDvXXCk8O8wpYgw5xcdTAwMTBcdTAwMTjDg1x1MDAwZsK/TsOXX8O8woTDvHLCgWVfXHUwMDE4w4XDn8KQw41fwofDoSnChF3Dt8KAXFxcXMODw7/DvMKQw5l7w5VcdTAwMDFlw7c9QMOIw5PCs8Kkw5XDv1x1MDAxM17DvcKYV8OTXHUwMDE3w5fCr8KQTXdcdTAwMWPCmMO8wpJQacOBw45Tw6/CvXVcdTAwMTPDj8Oew7/CjyDDtMKhXFxiJsOnw55cdTAwMDHDqMOgw4UmXlx1MDAxN8Kpw6DCoHlcdTAwMWPCllx1MDAxN8KMXHUwMDFjw6NcdTAwMDTCr1x1MDAwZcKRwpRZTsKtXHUwMDA0XFx0dMKww5/DqcOHwpbDvlx1MDAwNDN1XFx0wpdRw59cXFxcXHUwMDEzT8OJw4lcXFwiw6vCiV5oKcKhRHPCp1XDjlx1MDAwZsOPw7BRRMOxbVdOS8O3w7xcdTAwMGZ6w4VcdTAwMThcdTAwMWJNR1x1MDAwZVx1MDAxZsO+w4howok9QMO5XHUwMDA2XHUwMDAxYsOYScKoQcKUwqNcdTAwMDR5wqTDvnZ4wpgpXFxmfGlIw7zCulx1MDAwNn7DlVx1MDAwN8KIw43CiMODNsKcw4RcdTAwMGV8w47DlGLDs8K5esKpwprDnD1AXHUwMDE1w7vCgMOnwqZcXHZ2w7tSw5nDvsKiOkRcdTAwMGZcdTAwMWJrw7s2UyFcXGLDsMKEwoTChXkrbMKhwrdcdTAwMWbDnlxcdsKhw4dcdTAwMWbDnj1NwqEnXHUwMDFmw55cdTAwMTnCoVx1MDAwM8Kkw4QjXHUwMDA3JsKkZFx1MDAxOcKhdVx1MDAxNVx1MDAxM8K8XFx0w5fDmMORw5XCqEE9QMO9PUrCoSVcdTAwMDHDvSfCqMOhw6DDiMOYI1x1MDAwN8OrXHUwMDFmXHUwMDFlw4pcXHRHwoh5OSVcdTAwMDfCu1x1MDAxZlx1MDAxZcKyXFx0R8KHecK5JFx1MDAwN8OHXHUwMDE1XHUwMDEzw4fCtlx1MDAxNlxcXCLCusK7K1lhbyQzwrfCslx1MDAwMcK3eXZQZcOKecO0wrDCkCo9SsOjU8O8wrFSw5HCs8OUw4HCtzHDocORwrfCicOtw4w7wpTCjcK5w5jDiHPDpXXCmMOZwpMow6J1wpnDmcOPwqjCgcOpw6fCgMOpw6TDgTTDhGQ3wqjDusKkw749TcK0ZsKKXHUwMDBmwpTDp3HCvcOwwoDDklt9L8KZw7hcdTAwMTF3XHUwMDA3wrHDpnvCmEM6XHUwMDFmw6bCj1fDlXByMF4/w4RFwq9XTMOSw7s0XHUwMDFmw4tQw4Ivw57DpTrClFx1MDAwM1x1MDAxZktcdTAwMTfDpzdvwpbDm8Oww7PCp8OWV2c1K8K8wovCk8KKw74mwrzCvsKUwq7DgMO9XHUwMDFiXHUwMDExbMOBJFxcXCItZFdcdTAwMDXCiMOaWyjChsOtXHUwMDE4XHUwMDFjw6ZcdTAwMGUhOlx1MDAwZSxcXFwiw4TCpFx1MDAxYsKjMULCi0EtRD52OT9cdTAwMWbDosKYX8KSwrPCicOKwrtYN8OEXHUwMDEzw65cdTAwMDFzXHUwMDAzST9cdTAwMDZnVDJIXHUwMDEzLMKMXHUwMDEzLMOQXHUwMDEzw7zDkcKaYMOUYGnDpMKFRFx1MDAwN8OXwoB3M1x1MDAxYV1cdTAwMGbDvFx1MDAwM8OMaC7CvsKKXHUwMDE3wrAkw6rCgVxcXCJuXHUwMDE3w6BkR1x1MDAxMmzDtcOkKsOBWFx1MDAxNGZ6wrLDgMKsXHUwMDE0XHUwMDE3P1x1MDAxOMKSw5/DqC11wovDo8KuVcOsw4Vkw4LCgF7DnsOUwr7Dl1s+J8KYw4BBw7lcdTAwMGXDhCFcdTAwMTAtwr7CjcKMw6p7w5LDksKKwpxVPFxcZkQ8N8OJwr8tU8OqbMOYL1XCicO9bixJwrdcdTAwMWRtXHUwMDFmwqNcdTAwMDI6wqjDsMOUw6Qww41yZMOfw5QqXHUwMDEzwo3CqFxcdjZcdTAwMWR3b8KLXHUwMDA0woPDjVxcYj5cdTAwMThsXcOqf8O+w7QhwpRJYcOaXHUwMDE1XHUwMDExw6svbVx1MDAxZMKcecOSZ8KFTsOtXHUwMDFkwo89TcKjVMOPw4XDrVx1MDAxYynDlDfCoihcXGJcXGLCuXk9QMKKblx1MDAwZl9rwpl9w6d3wqIlXFx0w5zDsMOfXHUwMDFjQlnCuGfDosO8VUrDh3fCqMOpXHUwMDFmOcO9wqvDncKywoQjYCFgOMKtX8OOMMKwalx1MDAxMMOYe8OoJ8KQw5TCqVx1MDAwMVx1MDAwMcKVUcKqKGHCqFx1MDAxM2/CkMOkXHUwMDAxw6V1woZ6woLDmcObwrU6Qlx1MDAwNSNMwqPDmnLCt1x1MDAwMVthwrPCmsKFMllcXFxcdcKwS8KHW8OWYcKGw6nCrcORwrbDncKIUMK5woLCk8KAw6HCplx1MDAxMWDDjcK+w7DDilx1MDAxNsKOw7fDjMKgccOMcMKUwpvDuiTCgz1AwqQmXHUwMDE3wqfDmcOzwpRcdTAwMTjDlcKrdW/Cp8OpSzXDon/CqGh5fcOiXHUwMDE3wrEpw7nCliZcdTAwMDTDocKUw63Dk8KzcMKnVMODdMORw5BcdTAwMDTDh8OEwoLClHzCqMKNXHUwMDE5wprDlMO/w4bDhFx1MDAxNHjDn0rDusOOJkDDqcO9XHUwMDE4w67DjkBCwoZcdTAwMTPCtUTDgsOVw6jDklx1MDAwNVx1MDAwMj45wpRRUSVEw6HDl8KWXHUwMDFjw5rCqMKSb1x1MDAxMSU9fWnDlMKAwpzCvHBxw59cdTAwMTbCscKUV1x1MDAxZsOlacOcPUDDmnZIw4TDhlx1MDAxYcOcJ8KoXHUwMDExXHUwMDE0w5zDm1x1MDAwNsKnwr3DnsOTPUDCi8O1w7bCv1xcdmBVwqR6wrdFwrxgXHUwMDEyP8OWQcKYXHUwMDEww5fCgsKKN8O2XFx2W8KMwq7DoTfDmsOTwqZcdTAwMTF0wpfDmsOLwonDh8Ocw6NjUsK5NsOcPUDDnFpzNS8pXHUwMDAzVlx1MDAwNMOLf8KIw7Qww5pewrTDrWpsw53CpsORw6BbQsK+wql+RVx1MDAwZTc9QMOkZ8KqSzQhLsOlwph4w5fCgsKpXFxmXHUwMDFkbMKCwoTCkjjDtHXDgVgnwpFZMsO9fsKLJcKBw7XCgsKYwrtueMKFXFxcXFx1MDAwZcONacKMw7I+XHUwMDAxKsK6WsOfwqhcdTAwMWRtdSvCuHfCq3RfXFxiwoHCtMKjw5/CocOVJyTCscOgKmTDlS/CjsKJw5fDiSjDssOvwqTCssOcw6B8w6suw78xYcOxw55CXHUwMDFiw7rChnlVa3tfTMOrw4A3alx1MDAxNMOeIcO1wrfDnsOjwr/CiF4nXFx2K0LCg8K0woYswrfDoUxTQFfDsjHDoFrCqsKrwr46wpdcdTAwMDPCo8KSXHUwMDBmaUbDpcOSw61YXFxcIsKRXHUwMDE2XFxmYcKIVFx1MDAwNMOJwq7DkMKDw6bCoMKSKVx1MDAxN8OMXHUwMDFmfFxcYnhZwrA9QMOBXFx2wo7DuHbCijlaOkVDRsKCwrbDj1pQw7Q6w51lwrXCsMO6w7xcdTAwMDPCi8OPwrZcdTAwMTLChMObw63DkGfDilxcYsKhf3nCtllUWMOwSMOTw5HDpcK4Yi/DlH/CksOJcsKIw7zChsK3XHUwMDFiw47CtVx1MDAxYcOOwokoZVxcZijDpibDr8KIw7toeyVbwppRw6jDuMKFw6fDuiRcdTAwMGXCp8Onw7DCm8Kww74kwoXCiUg0PUrDpCszwrw9QFXDssOvZmxcdTAwMTUuwoLCosOTXHUwMDFiUy5cdTAwMGXDicO+XHUwMDEyVjfDtyXDjcKUXHUwMDBmLcKTc8KlO8Ofw44hw53CrMKfTXfDtE87fzk5w5zDpcOew55WXHUwMDAyw7FRfcK6wrPCv28ww65cdTAwMTHCisKvw4hRZsKxJ3XDsMOpw5nCp0jDriA3JX/Dp0FEw6dcdTAwMTlxw6/CqiPDisOmw5B/TMKELMKEZMOwXHUwMDEww7rDgFx1MDAwNlx1MDAxZcO6wrBTw4vDkMKldDlcdTAwMWZkw7zCu1x1MDAxNMOQUcO/wq89Slx1MDAwNVx1MDAxNMKSwofDgsO2bzpcdTAwMDZhwrNcXFxcXHUwMDFjK8KEXHUwMDEyOsO2PUBcdTAwMDZdwpFcdTAwMWZdw5jCtHM3X1x1MDAxN8OdwqjDsMK/T8O7w4HCtMOMXHUwMDE2MsKhLsKzYsOjRMK0w5/Djlx1MDAxZj1Aa2HCv8OALsKAa1XCgMKTw5bCj1x1MDAwN8KPX8KXw4PCtsOZwoRFwplVfyFqZsKUwrTDiMKgXHUwMDE0wrbCisONwrrDrsOlQsKVXFxcXEBIw6vCjsOSXmDDsGx3dXtcXFwiXHUwMDE5w4VzMcOcw7xcdTAwMWVOwoPCucOzdsKWw5DDnMKgwrPCpMKZw5xsw45SYEJcdTAwMTM4bzLDpMKVw4FHwpvDqMK7wpxLw7bCrMOvP1fDu25hw54wwqPCscO0R8KBOWxcdTAwMDE/Nn4xXHUwMDFlw4trXHUwMDEywpIjUlx1MDAwM8KKw6rChsK2asKeX1xcdsO1XFxcIlx1MDAxMy4qwqfDgHpAPH1AwqpcdTAwMDTCvi8ze3fCrMK+wq9efGlNw5nDkmnCryTDvcKRwrXDkH3CqcKdbic+wp9cdTAwMTR5w4vCqMOnwq8kw4VNXHUwMDE0eUs/KMKzJMKFeFxcdMK/w5zDilx1MDAxM1xcXFzCj8OrXHUwMDEzw77DtsK0csORw5hEXHUwMDE3fkDChMOYVsKSw5rCm8K/wrDCqFHCjcKzwrtnLsObXHUwMDAyw7JcdTAwMTfDnGfCnH3DnMOCw6vDusKPwrhwwpTCvFx1MDAxM8KBXFxiw4lcdTAwMTTDocO1T27CuTBGw4UhU8OPw4DCgMKpwpHCqSnDqcKRw5hcdTAwMThdwoEpPUrDg8O9woXCkDjCrsKkKcO2XyjDp8KQw5g7wpF4LcKXwq7DkMK6w7jDsMOGXHUwMDFmTmfDhjHDnk/ChEbCqMKEwpVpw57CvF/Cilx1MDAxMcKDZU48TsKTXHUwMDE5w7/CoMO8Xz/Cl1PDiV9cdTAwMTPDgXnDtFxcYsKkWMOBaMOIXHUwMDA2XHUwMDE5di1Iw7zDuCjCkMODw7pcXFwiwpbCg2XCvyHCt8KVwp7Dv3HCvWlcdTAwMDZcdTAwMTVbw6nDnFxcXFxjwp3DicKoZiprbSZcdTAwMTPDs3PDkMOTwpUgwobDpHNcdTAwMDHDhMOfwpDCuMOYa8ODw7rCicOzw5HDosK7w7wqXHUwMDE3d8OEWmpDZsKxaMO6XHUwMDA1w7ZcdTAwMTDDk8Oyw41cdTAwMTjDuHE9fVx1MDAwZlx1MDAxZcODXHUwMDFjw5VxdzPDhlJFXHUwMDExXFxmZ8OXw4nDt1HDrH5cdTAwMTLCszdcdTAwMWbChlnCksKuw5PCncKjw73CisO3w6zDvsKQw7sxZMOqw4RXw6EuXHUwMDE1wpZoZ1x1MDAxNMOfScOEXHUwMDA1J8OvScKdTCfDo2rDj8KddsKwOmnDkSXDulx1MDAwNjY9fVx1MDAxNMOUwonDkMKRPUrDr8O9XHUwMDBmPUDDs8KmwrA1wq/DkW05w4zDuFx1MDAxY8Kow4LCsyDCksKJX8KdwqvDrMKGXHUwMDEwNypcdTAwMTPCk3jClMObwoXDimTCsVx1MDAxY2XDn0NEXHUwMDAzXFx0w4rCpXfCkiFcdTAwMTTDkcOww57Dq8KFw7fCjTVsw4nDssKgw73Dp1x1MDAxZV3DlnXDhMKNIMK6K10lwrogwoDDn1x1MDAxMsKFXHUwMDBmwozCpC3CnS9/wpfCpHooXHUwMDA2w4PCi8O7XHUwMDA3w5nCn8KUwrJ/d8OBw5/CsUtUcMKgw7xcXFwiwqTChzkrwqRNw4FwYsOTwoMzw71FwovCkErDv8OXwrVEOlBcdTAwMTdgQ1x1MDAwNsK6PUDCuMKswrknWsOTwpPDiFx1MDAxZcKTw4g4XSRfw43CiURewp3Di0t4w5VcdTAwMWRpYlTDiMOhw53DkUPDn8O/OsKBOScpKsKHwrRzwqrCi8K4wonDi8OfSVx1MDAxN8Kmw7jDkMOOU3d8UsOjwoPCjsOswrXCnW9Zw4XCkS/CpVx1MDAxMcKnL1x1MDAxMcOew5LDvGzDjELCl0RARVjClMOww4Vsw6RQcjHDiMKHW05dLkXDlcKNXHUwMDFkwpbDmMOGw6BzwpRJwqEkwrnCqSfDoVx1MDAxYzhcdTAwMTdcdTAwMWbCksKyXHUwMDFmw6vCuGzCoV/ChcOHw5vCrsO4wo83w7HDu15uO8K4wrfDncKDwphnSVDDuF7DrW7DmSFiwpbDsXfDgS5XWVPDqSnCpcKYQsONTcOkdsOzw71cdTAwMWPDr8KpUMKMw5d+XHUwMDFielx1MDAwNVLCiVx1MDAxY1F8w7HDj8KNw5XDjMKTwrPCgsKYwoxzwq1cXGJnw7tCwoVXwrzCkcO3KMKvw67CsVx1MDAxMcK7XHUwMDAzJ1x1MDAxZMOYXHUwMDFhw7nDjcOiwrXDp8KXTHvDv1x1MDAxY8K/acOTXHUwMDAzVMO/ScKuw404w7XDqXLCsMOnwqnCum7DiXBcXHTDmsODw4V2w5zChnhYXHUwMDE2wo7CgMOJW8OFw5PCqsKGQMO5wphow5JcXGbDu8O1O8K3wobDgjBHwpVsw4VCwpU2Z17DuMKsTlx1MDAxZsKcXHUwMDEww47Ck8KFR8K0TMKkw4VYwpjDry3DmztdXHUwMDFkwq5OXHUwMDExwoc/QcOaw7ZRw5A+wp3DgVx1MDAwMlx1MDAwNl/DuFx1MDAxZSh7wrw9SsKLw5ZWYyRewpVcdTAwMGXDrj1APX3DkC3Cl2cpcHLDiMKCa8Kvc8KpPU3DrsKlw7/CqcOfwok2w7N9w7zDnsOpwpbCmGN9XHUwMDE4XHUwMDE2w6nDl8KGdMOCXHUwMDE0w4fCrMO2wr09fcOfw5F0w6Nuw7xcXHbCmcKuXHUwMDBlw5vCv8OzXHUwMDFiwrxLwqc9TSw5w69cdTAwMTQqwoZOworDl8ODMFs9QMK9VsKkUD19UsKIwqrClXXCg1IpXHUwMDFjwoxcdTAwMTlcXHTDnsO9wrPDlyTDrz19woVRKCbDjGY+wrlAw5rDr8KTwoA3ccOCXHUwMDFiWMKTXHUwMDFlw6ZySD/CpcOpw6jCuDHCt8OlPX3ChcO+cFUtd1x1MDAxYcKMalx1MDAwNcOLw5NfayHCviPCsFx1MDAxM054w5g/XFxmw5B7XHUwMDE4Z3HCh1bDnEtGw5Y7XzfCqWHCicOeb8K8w6fCnFx1MDAwZk7DpMKRw5Emw48pL8Kjw4JcdTAwMTfCjGzCpMOLwp19wpdDM8OfXFxcXFJcdTAwMDTCpFx1MDAwM8OKRl/DgMKawoprM8OWwp19w7bCssKPwobCu3JvwqxYa1JWXHUwMDFkwq5/XsKJTm9cdTAwMDTDljvCgVx1MDAxNMKzMsKkw4TDtcKYXHUwMDEyw5bDv0DCtcOkNsKnXHUwMDEywo7Dp8Ogw5JxbDjDssKCSsO7woDDiSVwXHUwMDEyw5rDrMODacOvXHUwMDE5YknDpMOswrfDgMKVbFx1MDAxMMOVwoRGXHUwMDA3XHUwMDE3RFx1MDAwN1fCt1x1MDAxOMKgw53CiMOQwodbwpDDkEvDpVxcdD8xKFx1MDAxZcOdJcODTsKWw7TDlDM+wq/DuCPDlD/CqMKOJlx1MDAxYcKww45sXHUwMDFhwo1hXHUwMDE2w6HChm87VUFDw5ZcdTAwMTBydGbCgsOlwogtwrHDhcKiw4DCqsO5wpDDp09cXGZww69tMlx1MDAxMD19TcKWXHUwMDE2wpLClMOON8K1fcO+wodcdTAwMDXClnLCmsKnw6XCoGnCncKswqB6f8K7w5bDksK0w4zDl1x1MDAwNGZ4woLCkX/Cm8KTw5E3IVx1MDAxMcKMwqtcdTAwMDHDulbDqynCoCNcdTAwMTcpXFxmw6kkXHUwMDAxwrdcdTAwMTHDtcKJXFxcIsK5wohcdTAwMTY2w7nCvsOBw6IoJkN/wr3DqFVcdTAwMWPCvFxcYsKDXHUwMDEzw6VcdTAwMTnCsWrDp8KEWytcXFxcwpDCgj7DsMOdwq/CgGxGUmzClMKVNcK0XHUwMDE2w50mwp9WRcKBIHcxwqBcdTAwMWXDmm/CtsKew4rCn8K/KsOdwp/Cj8Ovw7fDocKPXHUwMDE1VMKleFx1MDAwZsKXw589TTZ0w7bDhMKNesKnwqp+Wis9QHRgw5vCkGnCssOFw7/DtcOXwrF3U1t8w5LDqcKbXFx2w6Akwotdw4tRS8Kew77Cs1x1MDAxZcK9wrbDj1xcdFx1MDAwMsOsI8Kqw6l/wo/ClHHDvMK9WVx1MDAxMlx1MDAxOcOtQTTCnsOFw5FqXHUwMDBmXnbCnMKpXFxmfEBcdTAwMWVcdTAwMTHDu8K/WSE9SmHDjGLDhjhcdTAwMWZcdTAwMTZowpNcdTAwMTNaYMOXw5hcdTAwMWLDlcODLlxcdMOHwps9fcObJMKXwqzDvMOGwopcXGLCrHBmwr10K3RbWndZw5jDicOwXHUwMDFiPX3DgcOKfMKFw6tawpdgw4E9SlPDkFpvwosqwrE7SMOnWVHDnFxcdFl+w6Z0wrDDhMKlb8O4w5NtV3BcdTAwMWXCtMOyPHN5XHUwMDEwXHUwMDE3w6QuwoXCrMOmwrPCjMOUw6NLwrdcdTAwMDFmVm8tXHUwMDFiwpzDuSnDvVxcXCJcdTAwMTLDm8O1Y8Kww512LMOEbcK7N1x1MDAxMzFAVMOkw5l0PMOTwoohNcOkXHUwMDA1XHUwMDEzfsKbwqVYdMOSXFxib1M5X1bCpE49TVnDrHtNwo3Cj8K2XHUwMDA1JlfDjkHCtD51ZcOjXHUwMDFhw4LCo2zDvEHDsMKIwojCunvDgMK2W8O3QVx1MDAwZjHCon7DlsK/wqTCjcO5WWJcXGLDjkHCpMKNdlx1MDAxY1HDjVx1MDAxMsKcI0vDuVx1MDAwNC1cdTAwMTDCvMKgwpPClz1Aw4PDnsKZbizDmXvCmMO7YMO3wo9SwqReOVjCt8Okwql1dmLDi8Kuw47CvcKJJMKDXHUwMDA1bsONw6LDln1vN8OUwrp+w73Dj0s/YsKEwqtcXFwiw4NOwoHDjVvDglpMXHUwMDFkXHUwMDE4w6zDkcOrwonDpsK4c8KeSUXCssKQR8Ogw5fDvcKWw7HDmSPDm8KJXHUwMDBmIX1GwpHDp1xcYsOpwoR2JcKFXHUwMDE3NcO4w7dRa1x1MDAxZHM7w7g8QT1NwrxEY8OWXHUwMDA1w65cdTAwMTjCvsKzwppcdTAwMWV0X8KvwqjClMKtw4RIXHUwMDFkwovCmFxcdsKjXHUwMDA1PMO+SkLDvMO7KT1Aw53DiVJQw5xNw4RcdTAwMDVcXGLChCRDJ8KjcMKpSsKUMMOfO8OQwrrCgMOFwq1tM0LDvDfChzDCmHTCn8KpOlx1MDAxNFF3wqLDkMORwoB2UHbCq08oYcOgXHUwMDAybVx1MDAwNV/Co0Zsw4lvw7pwwq9yw77CkHHCl8OtSsO0wq5cXFxcdlx1MDAwNMKjwoDDtj1AUlx1MDAxOXQ9fVc9fVx1MDAxZMKrXXBcdTAwMTPCmcK6w45cdTAwMDLDlcOiwrrDmsOpWVxcZsONXHUwMDExc1x1MDAxNsOhwpbCh8KKXU3Dklx1MDAxOSTDncKzwpPDoMKef8OvfHjDrlx1MDAxNzQ+wpFcdTAwMDRcXHbDj8KGZMKZXHUwMDEwNcOkYFxcYsO2wqFcdTAwMTNkw7l2wpxcdTAwMTPDhcOjwpdQwrRWM3rDvsKCXHUwMDFkbiM1woHClMOsw4c4wodfwovCnlx1MDAxMcKwwqPDscKXZ8Kew57DgEjDqsOoesOfwoVawqtdY2jDscKvwqVcdTAwMDIgZ8Kkw4N4wqDDr2VcdTAwMTXCkD9rOlHDkGFWwqTDoG/DkFxcdj1Nw75uwoLDtVx1MDAxY8OLN1NcdTAwMWXDrVxcXFxnwofDmjjDi8KdwpwvfURkLsOZw6PDjcKJZ8KeXHUwMDAxw6E+w7zDgFY9fTrCmMKBwpLCicKAOXVvwrxcdTAwMTdcdTAwMTDDh1x1MDAxMEogLcK1w7DDqcORw6fCvFrDm8OMN8OGwpxcdTAwMTPDvjRcdTAwMWF8PX3DoD19QH49fcOvKUZcdTAwMWbDglx1MDAxM8KdXHUwMDAydsKHw6Nkw6fCt8O4wqJTwpVJwoXCssOMbGMtw4pcdTAwMTTCrlx1MDAxYsKBw4c9SsK8d0hcdTAwMDJcdTAwMTjDk8OPw4hwWsKgXHUwMDEzwpDClMOlTcKOMTQsw71XPMONdkkowoxFwoXCkFx1MDAwNsKSaMKiwrdcXFxcwr1HU8OwenNELcO5ecKLwo7Cn8KDw7rDtMOcw4TCujvCkyDChMOzPsKXwpvCkz1NwpRjw7XDv8OWXHUwMDFkd1x1MDAwNizCjFx1MDAxNMO9wpvDhU/DicOwaMOEw5s/worCuMKBXHUwMDA2TsOUc8OlQMKQRMORw4nDtcKYw69SMFxcXCJmw4tcdTAwMTZWw7XCisOAfcKrXHUwMDEzwrZ7wotVf1x1MDAxZVx1MDAxN3BfXFxcIsOxTHfDslx1MDAxNMKSXHUwMDBmwofDgsKcwrV7w5/DvsKmcXjDh0jClkDCtsKKdDHCuErDn3l1OsKsV8OpTMKAwrVDKkRcdTAwMTLDs8KuO8KKw7s8w4XDn8Kcw77DjFx1MDAxN8KdYijDt8Kye8OdNT1AWsO3w7xcdTAwMTLDlcOmScOZPX3CvGFcdTAwMTkjw63CmWjCplx1MDAxNsO/wqbCu8K4WFx1MDAxNsKjXHUwMDBmw6rDvcOWwrDDpMOmwp5cXGbDvVVQwr5cdTAwMGZgKUvDvTNcdTAwMDTDizTCkjjDhsOKw49cXGZhwrBcdTAwMWFJP2jDgFlcdTAwMWXDrMOMXHUwMDA3wq/Cr8KJw6fDhlnDu8KhUSwuMkfCtzZuQ8OqwohOw4jCpcKsw49cdTAwMDLCpyNcdTAwMTlAwrXDqcOMfMOJXFxcIl5nV8Kob8KIwoHCm1x1MDAxYsOJw7FTw444w6U+NsOXYcK1w6/DmsKSw6zCkMKBXHUwMDAyR0BZw6k0wq89SsO2w7twXHUwMDE5bD1KPzleUn3Cu2RQwpl2wqfDmcKNwrDCkj19w6bDlcOjXHUwMDA2XHUwMDBmw65OVXQ3WVpcdTAwMTjCjEtWwobCqMK/YCPDhVnDglx1MDAwMsKyQMKCX8OsRsK/dsK/ey7Dt0TDncKTYyDClMObwo7Cl8OUwoEqwqR/w7rCh8O4QcKLfcK8w55Hw7TDiyPCk8OmfcKCw4xUwoFWw73DicO0YFxcdsK9IGpnQVXDgSvCqCNcdTAwMWPDvcOvw740V8OXXHUwMDFhwq1Fw75zwoDDh8OFeMOCScKJUMOFasO+wp3Dv8OhbMKiw5dkP8K8QsKwRsOhQyzDqcK2w6Vywq9cdTAwMWbDi1jCry/CscKee1x1MDAxZEA3cUHDvD1NwpLCscKiw4xve8Khwp7DnMKhdjXDsMKiwqRcXGLDhFx1MDAwM8KrXsOdw5w1w7c7OcOrw7PCtMOeZMKMwpPDuMKzMMO5wrUjwr7CpcO5w4XDjMOZV0rDtMOfw4p3w5vDr8O6wp9cdTAwMDbDo8Kcw6XCg8KxXHUwMDFiXHUwMDAzc2fDnTE9fS1cdTAwMTJ+w79VwqvCtj1Nw69EQF9mwrlcdTAwMWLCq2nDqsK+w6LDolx1MDAwZT19PUDCrmHDmlx1MDAwN8OSw4h4woJxwqRqwr3DoMO5wp1Uw7Ezwqw2XHUwMDE4wpQ+Q8KvdnfCu8K7wrI4wqfDlMKSwrfDoStcdTAwMDJcXFxcScOhK8K9QcKvwqllZMO8XcOVwo/Dp8KOeUXDscOaKi5cdTAwMWLDq1x1MDAxNsOxw7fCn8Off1syw712wprDtWYvQl0lw5/Dsy3DlcO6MCDDoMOJw49Rw5Asw7Vew7HDqVx1MDAxN8Kbwq/DnsKSP8Ofwr3CtkUnwoDDjmlcXGLDqcK2wosowrcwwpTDlsOAwqllwqrDvl3DlVx1MDAwZmrDmMO6wqXDmVx1MDAxMsOyNX49QMO3wqPDkMKXSD19w67Cs1x1MDAxMD9YwoDCmMOzw6lQw6bDgsKzwrfDqsO7wo7DvsKdXHUwMDA1UsOQbSE9TVXCo1BJSMOYwr42w5LCm8OSwq7Cgz9cdTAwMWTDujBcdTAwMDPDiTtdVELCkMOWO8KXXHUwMDFkXVx1MDAxNMOEw5LCs1x1MDAxN8KBw7Mhw5DCv8KQw5fDl8Oowr/CusOvTFx1MDAwMTXCqMKzwovDssOIWcOdw7dcXFxcZVx1MDAxMXhcdTAwMDTCl8OsL8ORw4/DhivCtSN8N1x1MDAwMsO2w6Eow4RcdTAwMGZcdTAwMTnChcORw6BcdTAwMTNMw7fDncKDa8K7woNJWsKhwp3CoFxcXFw2PX1cdTAwMDPDsHNbPX3Dl8OLw5jCt8KHXHUwMDE5woDDqlx1MDAwMVx1MDAwNMODSz1Awp7CvMOFw7rDi1xcdsOVcFx1MDAwZlx1MDAxN1xcdsOpwr3Cg8KOaj1NwqbClMOcwr9kMlx1MDAwN8KpRVx1MDAwNl3DrUg1wqvCmcKVMmxcXGbCtT5cdTAwMDQ9TcOKw6s6w7pcXFwiN8K0w5LCq8Ktw4pcdTAwMDfCuUHDtz/DvkR6wpUyw5JWOMOdwpgkYMK9wqJIXHUwMDExwqXDv8KFXHUwMDAxwrN/woDCqsOOXHUwMDE0w69dw57DmSPCp8KaL8OyT8KdwpXDjcOMw6AzMMOdwqvCjEFsw6FcXGbCscOfXHUwMDE0cFx1MDAwMsK1a8OewrfDp8Kyw4k0wqNcdTAwMTFrwojDo03DqjDCji7CpsOOwpVkw4DDtMO0w4XCrHfDvWNNej1Kwr5cdTAwMWLDp3N0c2UjwppcdTAwMDfCpz1KQMO1cy7DnmBne1x1MDAxZVx1MDAwNllKw4vDksKnZsOeY1x1MDAxMcKhXFxmw6TCoVx1MDAxMsO5wpltw5gpXHUwMDEzYSljw7jDlMKpJMORw6knw7nClsKRXHUwMDFhw7zDj1x1MDAxZcO2wrTCm8OoXHUwMDEyZlrCrcKNVi7DlCvCklx1MDAwNMKrw6TDpDHDnynDqD1AXHUwMDEww7nDp8Kjwp99wpTDqiZYLk5jI8Ogw53DjUTDlMODwr3Ch2w+w47DoMOlwpjDrcOJJ2o4w4FCPMKzPU17YWs4WSPDimzCjcOtTMKiwoDDm8Kke1x1MDAxMVZyw4shY2FGw57DscORw6vDjkhcdTAwMTdPXcKfU8O+w4nCj8Kve3Baw6TDnF/Do1xcdMKvf8K3wpbCg8KATyRpXHUwMDA0MsOYw5XDnTRVXFxcXMO9bMKLfMKfYT19wqNlw5TCusKOw7VcdTAwMWPDvSlcdTAwMTBcdTAwMTMkUcOhMizCvsK3wprCr8O4w67Dq8KbwoHDmMORWU9cdTAwMGZvTcKPwoMxw6/Dp1x1MDAwZnF4QWHDgVx1MDAxZsKdw69cdTAwMWbDq3Z8XTl4w6M4XkPCmFjDvcKdI8KfwoZcdTAwMWHCk1UkXHUwMDEyXFxiwpwhXHUwMDEzw5zDqMKrw47DrcKBwqjDvMKCwqxgO3HCqVxcdElJK3bCjFvCkMKoRnHCrGpcdTAwMGbDslx1MDAwM8O2w47DmUbCilx1MDAwNMKQWcOYw5s3W8KDQVx1MDAwM8KwXHUwMDFhJVx1MDAwZcKOw5BrcVx1MDAxZcOzw67Do8KZw7DCnsOtf1xcYjrCg8OEwo03bVRcdTAwMDbDlsKpUcKBXFxcXGbCvsKQam3DocKDwqk9QERvw5zCg04rwqtbVMOzNj1KwrA8w5PDr1x1MDAxMEjDg8KON1x1MDAxY8K5ajTDg1TDoFx1MDAxY3BJLVx1MDAxNcOEXHUwMDFjJcKXdktcdTAwMDPDtlx1MDAwNlx1MDAwZlx1MDAwMVx1MDAxZVx1MDAwM1x1MDAxMsOnwrhcXGbCvmzChcO3XFxcIilkw4rCmVx1MDAxMlvCp0bDs1x1MDAxYkA6wrzDgMKJwo3DjcOtN1rChcOow4xPworDvVx1MDAxZcKRwpMnwrLCucKYdC3DnMK3fVx1MDAxMD1Nw4RcdTAwMWPDuVx1MDAwNMOKQ3A9QMOJw59cdTAwMGbDg8OLw67Dp2LClcO+w59Iw75cdTAwMTfDry3CvXd3esKmPsOxwp1cdTAwMDdwKDtEw6fCucO4wqPCuMOuw5rDkCrDgMKLMsKKU1x1MDAxMMOdwpwsXFx0wrrCqVZcdTAwMDbDmsOJwpPCjsKiw7bDgiZcdTAwMGZcdTAwMDZcdTAwMTnDnFxcXFxyw68wwo3Ds8ObXHUwMDFiWjPDkVB7OVx1MDAxY8K5UsOww6tgwp3DvsOzw4LCksK8wotcdTAwMTPCvWfDs1ZSMsKtw7vCkcOVw7Vlw4XDqsKSXHUwMDA0XHUwMDAzXHUwMDE1wqcww4jCq8K/MsKCXHUwMDFmKm8swrRcdTAwMTnCiF3DnEc3w55cXGbDjlx1MDAxYcKmMSY9QMK0K1lfw7vCsEbDiz5UXFxmw41lw6PDnEvCqEPDi8K3w7/DlMOww5bCkMOXwpE9TWBlwoDChS7CnMK+w5xOw4TCgVx1MDAxN8KVwo7CoVx1MDAxNcKbwq3Dj1xcYlrCnGI3w63CscK/w4BcdTAwMTI7w4xcdTAwMGZNeMOGQMKyYsO5XHUwMDA3XFx2XHUwMDFjOcO7XHUwMDEzw4VcdTAwMGZcdTAwMTXCpWHDtFXCoT19wohcdTAwMWPDgXzCu1x1MDAxNTnDmFx1MDAwMsOHXFx2wrjDjMK7w47CosKOwq1cdTAwMDZ2w5DDtyZLwobChyNxK0w1YVx1MDAwZcOlasKJw63Cu8KmwplcdTAwMDLCv1xcdMOyJ8O1XHUwMDA2XFx0XHUwMDE4w5pcdTAwMTBPw54kdMKdwoLDhsKKPlE0w5bDjlx1MDAxZlx1MDAxZVx1MDAwZsKQwoJ7Plx1MDAwNMOPwpBcdTAwMDLClztgXHUwMDA0w4UswpfDusO3XHUwMDA2WsOEVsOpwrzCmS7DkMKqw6xcXHTDh8K3w4VIw6vDnsOgSHzCqMKkV8KnXHUwMDExLl3Cj8OlYsKJw7MxXHUwMDAzR8ObR0Bswrd6wpjDg2VVwoDCtClXXHUwMDE1wqfCiTnCiMOIw7/Dplx1MDAwNlxcdMO1SWDDrlx1MDAwZsOzwqHCkT9cdTAwMGYxwoXDksKkYT9cXFwiYVlcdTAwMTB9w6bDkcKEw7BcdTAwMDbDtmtcdTAwMTfCj8K0wo7CjcONOVx1MDAwM394OsO+SsO2wpbDgMKhw7TCpsKZw4DClcKow4Mxw7HDtXBoK8KQXHUwMDEybMK/w4DCgMKDw6EuZMK0XFx0JMOiwrpcdTAwMDc9fVx1MDAxNVx1MDAxM1x1MDAwZsKDLkZAw6xcdTAwMDXDnVx1MDAwZlx1MDAwMcOXZVx1MDAxOcOawol4w4bDrcOQXHUwMDE0N8ORw4Rzw41rQsOaXHUwMDBlUsK1OcOzXHUwMDFhQMOpw6A+wohcdTAwMWXCuFNcdTAwMTFcdTAwMWEnUjHCpcKPwp3CjWcnTMKXSHTCksKDUMOyJjBZYFx1MDAxY0x8U8KYw67DgcKRbcKJclxcXFzDn8OAw6hcXFxcRcOKbXrCksOUw6ZeYVJcXHTDqjEtw4LChcKENlx1MDAwNcOLwo3DhEIjwr/DpW/DucKCecKpwpNYwoFcXGbDgSjDolDDjsOAOcOawqZcdTAwMTnCsV/Dm8Orw6DCv8OsScORw4HDhENcdTAwMTLDjMKHw789Slx1MDAxMMO5wrMrw7vDt8K/XFx0wpDCj8KOw5/DlFx1MDAxNMKlXHUwMDFmXcKeXHUwMDFiXHUwMDA2wqQkZMOAV1x1MDAxN8KAOTTChmjCicO+w414Y8OrwqLCiCDDoSdcdTAwMWTCtsK4wpQnXHUwMDFkXFxiXHUwMDFjw5PDi8OhwqFcdTAwMTQmw4rCpsKfwozCmsOaMMOMwqZzwqtTXFxcIlx1MDAwNMKPXFxcXMOcwq7DoMKDw7M6w4/CjHXDmMOmwq7DkcK2XHUwMDBmKmA9QG9pwpdBYMOew6/CrMKDSGfDi3dhwofCuzDCiFx1MDAxOcOVVsO9woEqXFx2w67DlVx1MDAwMsKdwrHCmXVZwrlEwpN1wozDtsKCUcKIXHUwMDFlXHUwMDA3XHUwMDFiw4zCi8KReyrCk8Kkw5NcdTAwMDE7w4TCgFx1MDAxNF90wo89TcOPw4TCi8OwwrXChsOTwrTCplx1MDAxMydvZMObw5k5V8O8WMKFRcOuwo/DhMOlPUrCn8Ksw4Jpw4o+MlMuXFxcXMKvXHUwMDFiT8KVw5/Dn8KzwokrwqHDqVx1MDAxYTIvw6fCh3h1worDjcK7w7PCnsKuWMOQw7hcXFxcwrvDkcODRVx1MDAwNXfClsKMTMODeFxcdMOMwqJcdTAwMTLClsOqw6JcdTAwMTBhWsKawpczI8O3w71rw4LCq8K+w57DvMOKIVU9QMOXwqZFwpbCrcOmwqzDoj1AOMOMw43DjMO6wqvDn8OcXFx0w5nDt8KwTFxcZj1Nw4lGWCnDv8KLZ8OlZsKFYFx1MDAxOHHCj1bDmUZYKcO5w61iwrZ6V2XCjHHCmcO3w5xFSmYwe1x1MDAxMWvCvVx1MDAwMcKRw5Mgwr9nXHUwMDBmOcKYw4zDrlx1MDAxMVx1MDAxYsKrw5I9QMKkJMOwLMK5UVx1MDAwMlxcZsO9wrlZw7fDgFx1MDAxOVxcYmbDoEPDu1FIwqHDlHM9SsKnwrzCtD19XHUwMDFkdH1cdTAwMWTDqcKcf1nCsMOTwrpcdTAwMDLCpCR3wo5ZVsKlZycnw4o9QMKYw5nDp8OOw7jDqMOxwq1Bwp8twpQnwqvDmFl4w6plZcKcwo58w5fCglx1MDAwMcKiw5AsVVx1MDAxYVxcXFzDv8KFw4tGXHUwMDBlw49bU8O2woTCkcKRw5BLw61LUMOHXHUwMDE0w4/DgMORw7BvXHUwMDFjc8KLUMKww41OVDZcdTAwMTTCuXjDgsK9esO2TsOcXlFNYMOaXFx2R1EmJMOAw5jCiWNcXFxcPUrCmcOOwpDDoMKrw4dTwoRcdTAwMTVjK8K+w73ChDdCXHUwMDExwp7DgsKGwoHDlcKMZMOwfMOKXFx0wovCo1x1MDAwZlx1MDAxNTRKw6HDgyPDknE9TXFcdTAwMTDDksKaWcKNwrfDllx1MDAwNsK+w6NcXGJRX1x1MDAwM8K7wrvDl8KzwqfDsy83U8OmZ2VafcKmXFxcXMOkXFxcIsOoYWUywqXDtU7DnVx1MDAxN8K5wrTCsy3CtsKabcKiQVxcdMOnZcKFw7c2w51jUsOQXl3CsE/CokxIYMKjWltcdTAwMTR4RU5pwqrDscK/acOGwp9cXHTCu1x1MDAxZMOfwqHCkVc2bcOqcl07wr9ew7VJem7CkMK1w5DCnVnCl8ONLcKmXHUwMDFmwpDDg2TCtMOEwo9cdTAwMTIww5rDhSZcdTAwMTBbe1x1MDAxOVjDhsOxw7BqTcOWPU1OLsKbw7DCjVjDscKhPUpNXHUwMDAyw5jCk8Olw7PDrcOOKy3Cr8KmISnCtXEww7DDmsODYsO3w4wmw4LCnl3DnlPCrlx1MDAwMVx1MDAxZT8rwpTCrVx1MDAwN1t0woYuXHUwMDE0Qlx1MDAwMsKWS0xYdlx1MDAxYcKZwplqWGExXHUwMDAzwp1cdTAwMWPChVx1MDAwMVxcZsKtw4HCo8KaXHUwMDA0UH7Ct01Kw5HCrlg9TW16XHUwMDAzwo7Dg8K4wqRcdTAwMDPCsMOUWiBpwoY6XHUwMDA1XHUwMDBlXHUwMDEwwoVcdTAwMWJwTsOCN1VzwoTDgzlXTcKORcK/wprDssKBUnYkPETCisKTXFxcIlLDtsKpRVptRcKfwrcmwqgjwrLDpEDDj8K4PUrCvjFewpQrXHUwMDE4R8ORM0DCkk92SXRcXGJkw5vDiMOMPlx1MDAwMifCocOiwqk7R8KYL8KAw7vDvlDDmsO5YMKtw7zChsOaWVhcdTAwMDR7wpFcXHRdwqzDusKOw6nCm8KNTmvDkcKzKcONXHUwMDBlNMOnwqhcdTAwMWbCgMOYw4xcdTAwMDFhwp4tcMOmwqXDlcK5wpx8w7TCrsKTMMK9RXBPcDdFwrk+SUHDrmHCrEzDvVx1MDAwZsKVw50tXFx2OUrCk8Kow7TCnmpcdTAwMDNbJ8KWVGk7w5DDusKWw5bDisOALlx1MDAwN2s2wpdPdjPCh8KaMMK1I8Odw5vDqnBIO8ObN8K1eD7Cp8OLdGLDrVtEKVxcYjNXOcKLOSPCpMOPMMOKwpHCo3o1XHUwMDAyw7LCvcOzJcOsJMKDw7FcdTAwMTZ0wrXDqkbDn0/CiFvDhsOwXHUwMDFjWMOCXHUwMDAyw4HDhMKtJjvCjMKJw5fCg1x1MDAxM3h6w7rDnEzCl8KaXHUwMDAxwrhkVMO9w4jDoyM4cmHDrcK0w4LCujvDklx1MDAxYlx1MDAwZsKlw4zChnJUWlHDrEjCt1x1MDAxZsKHw6DDmVx1MDAxYVc9fcOnf1x1MDAxNn3Ciz1Awr00w5ZdTsKLUsOfOcOBLVJ/wqZsw6LDvsOXwrrDtETDt8Kwwp7DrSPDhWNUw6zCtlx1MDAwZiVcdTAwMTTDgMKJwodCPUrDlVx1MDAxM8OAWcOrXU50w7wlXHUwMDFkQ2NSf1x1MDAwZlx1MDAxY8KWW8KJL25fwoPDjMKIw4JjwpXDu2NeUyFLQcOTw75cdTAwMTZcdTAwMGZNw6jCgcKWZTHCtMO7fcKgwqEnw6cvREB1XFxmdcOgLHVSNsOgwrp+Q1LCgnnCtFxcZsO8wpDDo8Kew7ghQz5cdTAwMWNEwqlJwo0xwqxXwpvCr8ORWsOjR8OGw6fCtCZUXFx0dcO4w7pcdTAwMTJIwpNLKSF7wq5Gw4TDsWnDtsKyNFJcXHTDpXDCmcOZe1fDr8Okw43CpMKUw5nCuSo9Slx1MDAxY8OZw5jCq1FWXHUwMDE1wpdcdTAwMTfCtlx1MDAxYcKsw6UgI8KMwqM9fVx1MDAwMS7DucOQST1AMMOXwobDqsOLw597wqhcdTAwMTHDjC7DkSA4w4Bhw7UgY17DmCHDqcKDw4okcMKZwqpcdTAwMWHDmVxcdsKBRzlcdTAwMWPDhMOtwrpZwpjDu8Ouw5hLXHUwMDFlwrbDjcKyXHUwMDE1LlAoV8K4wpFWXVx1MDAxZMO1PlxcdjlcdTAwMDXDpXXCtMOMVMOpw7jCjMO3Wn1cdTAwMDPDkVbCtjLCsXhcdTAwMTl6w7zCilfDoj1Kw5XCncKIw7/CtnRracK0wqHCgSrDtjlEwpbCr8KDw5LCs8O3wozCqSPDkVxcXCLDolx1MDAxZSHClsOCXHUwMDAxw4A6wqlfw5dcdTAwMWQsw6ZZN8KLw7PCjMO/w4zCuMObe8KgejtcdTAwMTDDtcOpwrzDrMO6YcKvwqtqLsKFw5FcdTAwMGZrwpJcdTAwMTViLcKnw4ZsJcKSK8O5w6ZxQzNUXHUwMDA2dsKsdMKKfTlow5PDt8OlK8O0NcKBw6DChsOewqXDgcO9wp0vw4/CpsO3w7VcdTAwMDTDuVUzTW11w7tcdTAwMTfCk1PChMOgw5lcdTAwMDFcXGLDvlx1MDAxNDNSan8pXHUwMDA0TMK8wpDDlMKfXFxmXHUwMDE5w7PCvzLCskLDnMKhXHUwMDE5wobCucO4ID1NXHUwMDE5LkLDpFx1MDAwNcKZw6hZw57CmcKqMcK+L8OjXHUwMDFheFx1MDAxMMK1wrTCgjNHJMONXHUwMDE4w6ZYXHUwMDE3S8OlM1x1MDAxOMKGw4kzwrXDqMKdw5dcdTAwMDPDt8KBwpc9SsOvw5/DvsK4w6/DrcOfw6Q1w5XDhMOBS1nDgHh8wrJ1woLCh8OzwpvDtD1Nw45cdTAwMGXCkMKwZ8OQwpfCicOgw54nXlx1MDAxNsKBLcOVwotrZcOCwoRLVGzChFx1MDAwNMOUwoLDu0DCvMKSw4QqYcKoP3fCuz19w4RITUZjw5x6w7HClsOvPX3CozvDqknCm1x1MDAxMS9cdTAwMDTDp0LCgMKxVMKxdz19w7/ClDnDr8OgXHUwMDFmw5xjwr86TVx1MDAwNMKQRkjDiShPXFxiQcOjQMKqXHUwMDA3w7bClcOXw4Iqw7fCkcOmw6lxwopcXGbCrMKlwp/DssKaw4I9TcOMw689fcKEw4hDwpVcdTAwMDXCicKTOcOfWnvDrlAsw7J+w5bCnMOYVWlCwoDDvyVrXHUwMDA1w5vDj8Otwp1cdTAwMTRcdTAwMWbDtkrCicOMI8ODwprDl8OQaj1AKj19w7pYw4TCtlxcdFx1MDAxMMKswqlWw6HDo0xcXFwiw4tcdTAwMTE0woPDisKyaVx1MDAxOcKvwq1cdTAwMWVxXHUwMDA3w5DCgMKpX1x1MDAwZWE1MzBkdz19wqzDsEHCjlx1MDAwZlx1MDAxYsKtwp9AwqnCkHTDlMOjw5ovwq7CrcKrw57DoCZwUcOQJiXDvMKsw5DCtGJew6UufsOFQ1xcdmPDtGE1w493Z1xcdsOYw7nDh3RcdTAwMTI2w7nDuMKPPUBYw61CfFPDtMOoL8OHwoN9bGY1wo5Ewq3Cs3c8w5trw6vDv1x1MDAxZVfDlcOiwoxdeMKzWjptwqIlNTE9fUjCh15cdTAwMDVcdTAwMWJMw7d0w49cdTAwMTLCt8OEXFx0KzHDuH/CrcKNwq7CocOwwqJcdTAwMGbDp1x1MDAxYcO8wpfCkD/CqsKwXHUwMDA1wrrDni9zXFx0S8O7IMKSwq7CqsKjQW7Dk1x1MDAwMsOjwrbDocKCwolcdTAwMDXDqVBBw7rCv8KSXHUwMDAyJMKGwrDDgcOzwodjXFx2W1TDocKyXHUwMDAzwqfCk2AlMjliw7VcdTAwMTDCoFXCuSjCqsKKwoTCs8OzwphcdTAwMDPDosOnIMKXXHUwMDA1PFx1MDAxNUhcdTAwMGXCsHcqw6PDj8OnwoDCjk89TcOmwqzCjMKtXHUwMDFjVcOdw6DCskdQwpTCmMKKwpbCv8O3ZXfCgsKRcsKSwpLDg8OIwpE+aEU9TUvCulfDrFIlXHUwMDAzccOMwqZcdTAwMWJIwpI8R8KGw4bDgGDDp09cdTAwMTnCg8OHc2VcdTAwMTFcdTAwMDHCv0ojbn1cXHTCo8Ohw4hcdTAwMDdcXFxcw5TCk8Opw7owNDNpPX3DlUBcdTAwMDZcdTAwMTXCrSRcdTAwMTlANmzDtMOAXFx0XkBWTcO3XHUwMDBmXHUwMDEww7XDncOwwok6w5VQbcKLXHUwMDE1RFxcZmXDh1x1MDAxY8KVR8OQXHUwMDA1V8OTwoHDpFx1MDAwZj9WwoZTUEJzR2J0XHUwMDAzVTNbwoRTwrXCvGvDm3nDqMK8PX1qw7RcXGYqXHUwMDEyXHUwMDFlY8K7wrrDokTDllx1MDAxNMKGY8Olw4tcdTAwMDJFXHUwMDA1w47CisKAwpzCrEfDrFx1MDAxYzDDtTFrwrRNTcO7P3dKw4vCllx1MDAwNsOvwrI1wpBUcD19ZD/Du1x1MDAxYsOtwrN4woXCribCncOMNWRcdTAwMDcswoTCtMOFwqxQaMOXaMK2UsK0w6RcdTAwMGbChWDChsOTXHUwMDFiw5nDhXDClUx4ZcK/w65SwpZawpTDjlxcdMOKJsOEQVxcZsKrw74zwoXChsKTw706PsOFw5rCjCfCtnEvXHUwMDA0w4XCoU7DucOub1bCl0Mvw7YgXHUwMDEwVScnOVxcYj7DtFxcYlx1MDAwNWHClcO4XHUwMDA3wovCimrDgz19w4HDncKGw6DDkCbDhlx1MDAwMsK6PUDCk0pcdTAwMDRLfD7Cl1N7ViVcdTAwMWJLQsKFXFxcInjDnHHDoEZcdTAwMGXDq2vDv8KlwodifFPCvMOhXHUwMDFhw75aJFx1MDAxZlx1MDAwM8KMw6lcdTAwMTV3L8OkJcOgXFx0XHUwMDFjwoQ0wobDlUHCiX5cdTAwMTnDtnTCpsO4OMOGW8O2wplcdTAwMDEmw6HCoFx1MDAxMTfCkcKuRETDsMOhccKCXFxmPX1Te8OPSil0c8K9QlVcXHTDnDs8wrJ5WnfDoSbCuMKBw7vCjMKVw7XCgFx1MDAxZDQvwpI8IcOjwrpsw4osw6vDjzM+PijDiF9Gw5jDh8K+woPCq1bCr8KcXHUwMDAyUD9Iwr7DqSPDvMOhKMOCw5fCsyknw6kjXHUwMDExwonCj8KVLFx1MDAwZWbCs0vDuMKwwrLDjFx1MDAxMsOqM8OFwphJw5bDg0NgJsKmacO2P0paw5LCtXnCnMKoZcKVXHUwMDBlJcOGw5zDg8KSXcOVw4rCllPCuVx1MDAxZMKPPU3CjihcdTAwMDHDglx1MDAwNsKjPUpmQjgqwqcjw7ZDwqDCiMOPNsOXwrh7S8KNZMOqPMKTecKgQ8K0ZMOKS8O7XFxcIsKsw4bCpWvDpcOcd0o0wq1cdTAwMTHDiT8jw4Igw4DCqsK6XFxmZ8OaVyM9QGTDkcK1b3tuw5hJwppTw73Cr3ZVw61Pw51bSlLCkMOywppAw4tBwrlcdTAwMDYzw6LCiMKdUz19VMKrwpnDjsKHKMKvfkfCuCt0w7/Cq8OYelx1MDAxN05DXHUwMDBlw5TCnMKPwrtcdTAwMGbCrsKtw4hcdTAwMTHDi284wq7DgMOgwrQvQFx1MDAxYlpcdTAwMTDDj8Kswophw43DsTTCv8K/QMOtw7PCv8OIwrN9w4NcXFwiwrZ/bEtKw6t7woHDlTtcdTAwMDJcdTAwMDI+wojDjcObP8O2YD1NwotGXHUwMDExeHHDgcOLYsKgfcKPwpzCmMKcwr/Ds8OXwrbCpT1NwqbCpsOQwqTCmDbCtMOFUsKcw71FwotcdTAwMWLCt8K1USDDplx1MDAxZVx1MDAwZlx1MDAxY1x1MDAxMcOrw55cdTAwMTTCh1x1MDAxZVxcYnPCgcOfXFx2wq/Chlx1MDAxYmbCpcOeXFxiXHUwMDA0wrBcdTAwMWE7XFxmwq7Ci8O2wrbDmsOdZ8Osb0VcXHbDjMK3OmhaREtcdTAwMWbCsETCjsOVZsO2SsKTw7B+eVxcZi/DjsK0XHUwMDEwTcOMwpE/ISvDgsKwwqjClcO+fcKre23Dqy9AQFx1MDAwNzvCn1x1MDAxNSDDjCrDlMKiwrbCjcKHw4Njw4NZwrXCtFxcdsKiXHUwMDA3w4o9fcKww6g9TT1Nw5ZcdTAwMDPDuEvDllxcdlx1MDAxZsKbwrU9fTvDg8OGwqszwp3CpWpxQcO7w5LCm3BKNMKaX1xcdMK7wp7DosKGNMKhTjfCl2zDmFxcdkN8w5rCvcKbwrbCgnnDpMK/O1nDpMKGXFx0flXCm1ovwqMyTcO3w7YxWcO/w7vCicK1R8KpM8KYSEPCrMK7SG5cXFwiJT19XHUwMDFhXHUwMDA0OznCsmzCrsKcPUBRwr7DjcKKwo5sw70wbcOhw5bDqzcvw588woTDmVx1MDAxN8OzYsK3w6xfwpA0wp/CicKEKVx1MDAxNMKSYMKzw4hcdTAwMDfCmVx1MDAxYsK7XHUwMDAxOMK0b8O3U8OySFx1MDAxMX5cdTAwMTXDnsOKY8KXJcOGXHUwMDEwXHUwMDE5w4nDvcOaJMKqwqTCgcK9PUrCl2bCqFx1MDAxMMOqRcO1blx1MDAxOMO7PU3CisKydy9AwpJiw6FCXHUwMDE5w67CicKnKiXDqkLCnkY9SsOUWsKKQkDDnMK5wrEtwpDCq0h0woh0wqB8wodvwoLCnHPDnMOrwo8tXkV3LT5cXHQrXHUwMDE2w6A5w5rDhMOEXHUwMDFiwqvCrMKiNMOAPX02w5jCuVbCuMKwwpjCrT4qYHxJXHUwMDA0w6wnwo1two3Cm8KGXFxcXMKnwptAT8O+Qlx1MDAxNMKow6zDq8Omw6A4w6HCqzPCscK8OF/DosOeKsKwdS3CisOiw47DmsKNWMOfRsK2w5vCosOML1tcdTAwMWNcdTAwMDbCjX9WfMOvw5J9XFxcXMKfw7tTwpRcdTAwMDNcdTAwMTFlSMKxXHUwMDFkw6FnMljDqFx1MDAxOH/DmSfChsOow6fCmMKZw6nCuMOVw7/Dq8O5Y8KkV8KcwrfDmcKnwrLDpsO4w6DCicK1woPDr1x1MDAwMcO4w5Z2YsOqwpdBwrtbwprDnm/Dt8OyKGJ/LjXClyTCmcOQwpDDqcOKw75cdTAwMTLDm2luwoo1eMKIXWfCklXDuH3Dqn7DvsO0VsKcw6E6O1Ipw5tawqFSw6MwwofCrMO1wpTDiFx1MDAxNcOcw4ZcXHTDjsO1fMKow5VYwrUjwpfDpMO2XHUwMDExccKfw4PDtzlcdTAwMTPCvFx1MDAwZsKhXHUwMDEyXFxcXMK/XFx0w5N1acOpdcOBwrMmwpjCh2QjW8KHwoQjJ8OkXlx1MDAxYzHCnnNcdTAwMWTCvcOkw75cdTAwMWMxTWBow5TDuGk/IFNww5vDk8O1wqg9QMK0w7VrPUDCtMO1Oz1AwrTDtcOHwqDCsMOvwo3DqcOCw4gxYcOsw5Fewo1gazkkJlx1MDAwM0xIQVHCjC/CuUDCnVTCocK8wpPDhlx1MDAxZHxRw6d+ecK5ST1Kw5tewpdIaTpRw4nCl2LCvsKYXFxiXHUwMDA3w6knXHUwMDE4wqjCqcKRcsKow7bDjsKxZ2hgw5TDnMKQfFNcdTAwMDbDpydcdTAwMTjCmMKpwpFII8Olw6DDh1x1MDAxYsKhwrfDlC5bPU3CnVxcdsO4XHUwMDE3wqHCoSRlwo1cXGbCocKWXVx1MDAxYmVwf8OAw4bDq0lcdTAwMDTCqMKhw5LCjFx1MDAxYTXCosKbw4Ynw6xaw6HDrMONwo/CkEjCgcO/w4QhwoRxw6HClcOzwoNcXGZXwpRVwrfCocOhwpfDqcOlwpdcdTAwMWXDmFx1MDAxOVx1MDAxOcKYXHUwMDA3wqjCoVx1MDAxNVx1MDAxMkfCkVx1MDAxOFx1MDAxZlx1MDAxOMOQXHUwMDE3wqFhwrdcXGLCm8OkcFx1MDAxOVx1MDAxY1x1MDAxN8KhI1x1MDAxMsOHPj9cXGLCr1x1MDAxN8KhS8K4asOLw7TCvG1bWlx1MDAxYWJwwrh0w6bCocO2NMOowrE1csKRPMOLXFx2wppcdTAwMDZmw67DglhcdTAwMDI0bFxcZj1Ne8KmW1x1MDAwMl1Cw79cdTAwMWNobzvCmD19wprCgMO5MnXDnMKSQ2HCjMKPwoTDg8KDwo9Sw57DoitxI1tKwrTCglx1MDAwZcKMwrRcXGJcdTAwMDXCm8O5bzrDpyFcXGJcdTAwMTF3w4PCpDk5w7NTwp1tw7I7w7w9QMOTNMO6wp04XHUwMDA2XHUwMDA2c8KPJUpbbzbDm0rDkFpXdW43wrQtw5hewovDucOFPMK2w7QuTzROwr5rw6zDhSk6cXvDqXBCfVxcXCLCjlx1MDAwMkFcdTAwMTVHwrY7S1xcXCInwrTDnMOAZ8K0w5jCr2VcdTAwMWF0XHUwMDFhVUVHXHUwMDA3SjnDiWBtw7bDmsOcwpxzIMKSwo4gwr9cXGZ0XHUwMDE2wrrDhlnCh1vCnkPCoMOgPzFcdTAwMTTCj27CrEDCiFLChGs9fcKCw6nCpcK2w7TChMOYSMO5QcKlXHUwMDA2RcOzMHvDoSZww7omw4VcdTAwMWHDtsKowrhcdTAwMThcdTAwMTYjwqQkN8KdwovCp8KBaMOuW8Krwpd8w75uIMOyw7bCvcKdw7HCpldQwp0yYcOGUsOpw6VBw5VcdTAwMDEjw6jCvjfDplx1MDAxOMKQXHUwMDFkO8K8Pj/DiVx1MDAxY8K5XFxibcKRw7fDnjxcdTAwMDPCoyVbWsOFw7nChn5NwrE1KsKBwoTDk8Kkw7s4W8KYwqZcXHTCh8OtwrHClMOQwrFvKVPCkFZVYsKRwqHCtMKfPU08wqTCgmbCtFx1MDAxZMO/N8Klw4tlXHUwMDE2wpRBVmTDsVHCm8OyKnvCr8OfVcOTXHUwMDFkw6LDt8K3w5bDqVbDv1x1MDAwMsO1wq4zwrUvw4tCXHUwMDFiw5bDv8OzacKxw7FNwrZcdTAwMWY9TcKVw6t2bCvDjcKtwr09QFpcdTAwMTE1XHUwMDBmw6LCvsO6wrt0UMO1XHUwMDE4XHUwMDE5XHUwMDE5SVswXHUwMDA3w7XDpcOTXHUwMDAyw7/DmS/Dh1x1MDAxNMOqwqPCj8OGw48mw7DDicKHwr7DlsOYNFx1MDAxNMORwrpcdTAwMDHDrH3Dn8Ojw5FcXGbDoMKfw5rDrWLCuMO0Plx1MDAwMlxcXFzCmXRcdTAwMDXDsnxLcsOaw7bDtsK6wqdbST1KwpA7UmQjS8OmwqNXwrllXcOYw5NcXFxcfn1wIcOIwo3DvizCisOOwqrCssOse3l3w5HCi8KZw7nCisKlw5kgWlx1MDAwNMKNw6Emw4RLOcOdIzXCkmxRwo1Gw5rCk1x1MDAxYcKWUHnCkijDhFJcdTAwMThcdTAwMDQ7w5dGw4fCsMOVXsKSMMOawqhVwqbCn8OOwqB2w67Ct8O4XHUwMDAyI8Kjc31fe8Kbw4FSwprCj2HCgcO6wpc9SsOCUlx1MDAwM8OdcUfDtUjDsMKlXHUwMDAxw73Cs2DDg8KCwonDscKPW8K5wpTDosOnw4/DlFx1MDAwNnLDnMKxwo8yw7d1Y8Oew7LDusKbUS/ClcKxfcKMXFxmVMOVwpTCrMONwoPDi8KvwrTDo1x1MDAxM8OEwq5VVz1NVcOqXFx2d2dcdTAwMDZNwrxcdTAwMDNFXHUwMDA3OsOid25sacKqQlx1MDAxOMKaTcKVWMKgUcKJw4LClipBPUBiwrfDoMKvXHUwMDFmw4fCi8K5wq5cdTAwMWbDnFjDlcOSwoDChsOAXHUwMDFkwqfDpFZcdTAwMGYxwp7Cg27CusKdw4NxRz1KTMKHw4F1w4DCicOVw7U+KGRYJyZAwodQei3DosKeOiPChsKEwrLCplg3bmjDgT7Cu8O5w4/CsMOywqFUw6h1w4dNXHUwMDA2wofCgsKdXHUwMDAzOVk9TcKcejHCgk/DlsKLwrQ8PUB/VsOac8O+w41FXFx2XHUwMDE4wrt2wrdsw7IyPFx1MDAxZD5BXHUwMDE4eyF4dULDmzjCjcOsw7LCjsOVXHUwMDBlesK+w5d7OHtcdTAwMGbDmsO1wofDs8OLXFxcIljDtEvCoF/Chi5cdTAwMTMyw6/DoDLDjMO0RMO1wo3ChsKpXHUwMDFlWFx1MDAwNE/CrsKXw4Y1w6FcdTAwMWHDolx1MDAxOcK5wplDfzM0XHUwMDEzYkE4wpjDqWViUMOUw5lcdTAwMDdAwpBcdTAwMDHCuMOUbnvDp8OkJ8KYw588w79KXHUwMDFjSmnCjsKMJMOYdHZ9TcK0wpPCu8Knw5ZLw5QhPUDDjMOCwqjDiVx1MDAwMl5Zw6XDqWXDmidcdTAwMTjDqlx1MDAxMsKHPsO9JcOgXFx0XHUwMDE3RcOnwrXCjMKkwoslXHUwMDA3w6xcdTAwMTLChz7DvcO1XHUwMDA1XHUwMDE5woZcdTAwMTknwqFBw73CsVxcZsOcSH3CjcOna8Kbw7LCj1x1MDAxZsOLwrvDllx1MDAxOMKHT8OVOVx1MDAxM8ODw7XClMOCXHUwMDFjw5vCisKFVFBMNMKUw7U9fXwzwpdtw4/DjzfCsm/DpH3DrsOQw4/Cu8O6XFxiwpBtwoEzwpfDp3/CpyVVScOBJF7CicOVJ1x1MDAxZsO3wq9owrlRalx1MDAwZmDComZZwrHDsjjCg8KawrFcdTAwMDXDosKWXHUwMDExw4XCliDDmsKIMmDCpGBWwrjDmsOxIMOGTsOgw4nCvlx1MDAxMMKycE82w7fCjSA8VMKlw6HCpsODw6lvXHUwMDEywo5jIWk2w41nwpvCv8O+wpnCl8O6woRcdTAwMWE/SFx1MDAxMcOAeGXCg8KDw5t8woXCmMKZw6rDjsKqXHUwMDA2wqQ9QFIlw6w9fcKowq7Do2dmQVx1MDAxN8KGXHUwMDE4XHUwMDFiXFxiXHUwMDE1XsK5wqxcdTAwMDM9SsONwqTDrcOzSifCrsOXwoRnwoXClWBOV0Nswr3ClkVcdTAwMTDCmEpyXFxmT8KDXHUwMDFmZHHDrVvCo8KSwpXDoTXCjcOjw7FcdTAwMWJRw6vDmsKfMsKHwpF3eMKROVx1MDAwNcK0wp0mXHUwMDEww55lwrpcdTAwMDZcdTAwMWHDrThcdTAwMTZcdTAwMDU4w6TDmcOKwrPCoTZqwr09SsKQw7rCv2nDlkJcdTAwMWXCo8K9XHUwMDBmw7zCscKWwq/Csjl/XFxmwrpcdTAwMWJXwqZ9wp/CqHLCl8O7wrhTbcK/w7l5w4zDvXZbwrUnwqLDrsO5wp/DuFJcdTAwMWXDt03Cs8KhwpbDscKUXHUwMDExJE/CnSDClMODw7Bsw6lcdTAwMDLCk8KRPU1+XHUwMDExRMOgwo1cdTAwMDXClsKZw6XCk3hawpduPU3CkcOaw7vDkSFcdTAwMTXDrsODX8K+PX3DosO1wrBewp95w5ZdwqpcdTAwMTPDmlx1MDAxMGXDtcKVwrPCrFx1MDAwZXjCgsO4K8KhK8OxXHUwMDFjZMORacKHw6hcdTAwMWbCpVx1MDAxNsK3w55cdTAwMDHCvMKwVMOXS8O4wr3CuFx1MDAxOFx1MDAwNGDCgSo9TTc9SsOhwrolwqfDt8Kpw7JvbU7DjFxcXFzCgl95w53Ds8KYZSVvwonChVx1MDAxMMOiXHUwMDEwTsOEwrRUw4LCq1LDs1x1MDAxMnRMIFx1MDAxMsKQXHUwMDE3wrs3w5Vnw6h0MsOMPUo/wqTCsUBHXFx0w7NcdTAwMWVGw6dfw6nDjsOZwpjDqFEwwonDmnXDn0dcdTAwMDJgXHUwMDExwp3CjsOFMlx1MDAxNcOqVTFcdTAwMGVcXGLDnMKzwrrCiDVcdTAwMTXCrcKMwofDvlx1MDAwNFxcdsOeKFxcYsOcw6HCg8KIwqTDgcKPw4jCtUDCqsKgw4l6w6TDocKFw7vCpj/CvcOyw4PDqknDhsOhLsOKw5ozYjNDbVx1MDAwNcK9wo/DgSRpRsO/w5HCvcK0w6bDg8Ktwp/DjVx1MDAwN3PDjcKTJcK1w6nClFx1MDAxOcOCwqzDqDHCocKhwrY0wqvDkMOPPMOrY3bCrMOgw7rCuid4bcOdPkTCv8KiPUDCusKyXHUwMDAzw5pLXHUwMDFmQzw9fcOtwoAkRMKHwoHCrVx1MDAxNMK5MH/Dg1x1MDAxNUQswqVqw67DkFx1MDAwNTrClkHCvMO0XHUwMDE3wp0uUFx1MDAxMsKRXzLDrD5ewrLDuCBKJCzDgmtcdTAwMWXClzogwoFcdTAwMTFcXGbDsDArXHUwMDBlaC7Cklx1MDAxMcK4wq7CosOielx1MDAxMlvDksOcwo3DmU5seMOmwrh6woF9w5PDqkjDq1x1MDAwN8Ocw5d4w6s9TUcjw5jDvMK4OMO3w4RLIMOgV8O/fcOPXHUwMDE2w5nDhyR9UyXCpT9eTSbDqVx1MDAwNyxew6xEwq7CnlJcdTAwMWJ6eMOMwoVvwq5RNsK1VsK4wrRcdTAwMWHDqCXCnzDCkFx1MDAwNcOhXFxiw75cdTAwMThOwq5cdTAwMTZrScOrw4xlXHUwMDA0SMO6wqtuw5lsZCrDnTRcdTAwMTTDilYrRlxcdnBgwp9EwrTDu8Kzwog6w6PDmDNrfVBcXFxcwqrDpcK7TV1Aw4Fsw5bDmihLwrbCjMK+Pj19wo3ClVx1MDAwN8OUw6zCgjPDs8OMLFx1MDAwNsKLOj1Aw5xrP1x1MDAxYS/DisK2w7lcXGbDk8KYIT19XHUwMDE2w41cdTAwMWHCgWs9fcOnwoxhw5TClMKJJMObXHUwMDA1Sj1NXHUwMDFicVhXXHUwMDEyXHUwMDA2bcKNRjTDg8Klw5BcdTAwMTFCTUzDhHZQw4jDqsKeIUxcdTAwMWbCn8KjXHUwMDAyeV7DrsOYXFx2w53ClnfDsMOaUUzDksO8w51cdTAwMTTDgUPDkiQ/XHUwMDFlf8Opw4hcXGJuw6vCkMOawrliUMKZw7DCrMOsccOjdsOOXHUwMDE1wqVtcMKkw7fDlFfDrMKxw6DDscKKWlx1MDAxNj1AwozDssO7wqRpw7E2ZnRBwohrXHUwMDA0w5LDmcKew7Zhw7DDjUHCkWHCvlLCrcOCwo9vw5BSXHUwMDFjwoHDi8KabG7DnFx1MDAxNcK2wrE2wqXCqlxcYiU9Slx1MDAxZmLDjMKfLMKKwqTDi8O2w5E+wq1cdTAwMWV0PX3DoHfClX3DrMKxwoPCiMO1w7XDknpcdTAwMTY3w6EzYsOLwobCiEogXFxiLMOzY8O9KMOcXHUwMDBmMcObLsKqRcO/w5jCvsK4w61nw47Dt0lHw5vDisOKXHUwMDEzOsOlMMOGe00xw7jCqsONZjdcdTAwMWLCnsKgwo5XwrUvw4dHwrNcdTAwMWTCiMO4woIqwqHCn1x1MDAxNSvDvi9bwrlcdTAwMWQ0wqbChsKnwqB6PMOyworCq1xcXCJcdTAwMGbDqUoswqXDqijCqsOHw6jCj8ODwrLDi8O5w5FOw6rDoTLDuVx1MDAxMMOPw4rCgVx1MDAxN8Ocw4nCn8K0w4BcdTAwMDQpQcKuwr9Vw7hUYMOUWsOlJkgvJMOQQzHDksKqwrg8XHUwMDE0woYlI2XDtcOOXHUwMDE0wqcuw6zCmHzDicKcXHUwMDFlwqHCgcOiw5DCkcKbXHUwMDE0dsO8wo/Dh8OyXHUwMDAzP8KVwo9Uw7VJwr83w6pBwqDCg2DDm8O3fW/DsMObesK4wrjCglx1MDAxM17CmsKCdWvDim7Dl1x1MDAxNcO6w6vCtGwzXFxcIj9Xwo/Do15oMFx1MDAxYsKoTsOeXHUwMDE3w6LCgU5sXHUwMDAxwo9cdTAwMDQhP2/Dolx1MDAxOXbCm8KNwr/CkFPDsFx1MDAxOMOhwqDDsFx1MDAxOMOhPsOFwoA1w5HDjGnCij49TcKTw6tcdTAwMTd9N8KsZn3DjFx1MDAxZVHCg3ZYXcKGwqrCisO4OMKWwr41w67DmklgXHUwMDFkwp5gwrpcdTAwMTUhfMOMX8KxwoPCp1x1MDAxYsKFZMKFwpxTQ8KOPX0ow7xtXHUwMDEwwqlYw6jCqMO3wojDqcO1a17DrFx1MDAxY8KCM8O1SsKcwrnCnMKBRsOgJ8K1XFxmRMOWwoV9NGIrJ8OobTLDpjYhYlBGIHzCoMK2XHUwMDBmQ0QoJT1AWsOFPFx1MDAxNEFzw5LDnsKYOiBfXFx2ZCZbYVjClT/DtMOBw45mwqbCvMOsw6nDncOBwolcdTAwMTbCtMOVVsOVwqPDglx1MDAwNsO1w7Q9Sj19clfDlsKnwoTCmVx1MDAxNVxcXCJaw6xiL8Otw744wrtHdcOjfSbChcOlQ1ske8KRYMKWw70oRcKlXHUwMDEzwpJsXFx2XHUwMDEwPUBjwpF8wp5Mwq9dUzI1woUgXHUwMDE2cDFCf1xcXCLCuFx1MDAwZW9RwrRbwrw9SlLCi8O+d8KNcUrDhcKvXHUwMDE2I8Kbw4LCpSdyLsONZ2bCrMK6w57CqT19w7TCgsOrXHUwMDE3wrU9SsObJMOmXFxicMOVwrJvXHUwMDFkw51cdTAwMTbCnDLDl0lcdTAwMWE9QMOjwrY4SFx1MDAxNlx1MDAxY1x1MDAxZFpkwoLDk8OubMOlbsKpYXLDisOoXHUwMDEzXHUwMDExw7pcdTAwMTd+f3nDuTHDr1hcdTAwMTHDhMOEa8Okw7vCi8KywqgjXHUwMDE1MGrDmsKPPsKow6nDkk7DtsOSY29iXHUwMDE2W8KRw7/Cpk44w549QFxcYsKrw7gow5dVw45cdTAwMDPDvjTCg2PCjUdkwo7Cpydaw4hcXHbDu2vDqcKaw6cnw6LCkMOqU8OGXHUwMDE1I1x1MDAxMyM3w5xFOlpcdTAwMWJcdTAwMWXCusKCw4bDkFx1MDAxZsKkcsKuwqlkwpHCjlx1MDAwM1lcdTAwMThXwonDk8OJflx1MDAwNsOSUMOsw4zDi8KXw5nCpVx1MDAwMcKww5zDocKDwpJTccKxJcOeRsKdccKPZVx1MDAxMMOqXHUwMDFjwpXCtsO8woZeRzYqfMO0wofCtCzCuXhfwofCmTtNO0zCgMOrw5LDulx1MDAxY1rCkkpcdTAwMDHCg8KQS8OUcDrDscKAw67ChGxWwpB/XHUwMDE5KmBcXGIlw5JdXFxcIsOeeHLClEnCmsKmXFxcIsOIXHUwMDE1wqrCtsOKZVHDrzvClMO3PX3DpUNGwrY9TcO3wqXCmMKEw6JcXHYgw7XDqcKnXHUwMDE5w6kmXHUwMDAyw6kow5U9fcKxKFx1MDAxZVx1MDAwMsKpw4PDv1x1MDAxY8Oxwp5cdTAwMTbCmMOtXHUwMDFkw7I9QMOswo3DqcK/acKoP8Oow7rDjVx1MDAxYVx1MDAwZsKbdW7Cv1x1MDAxNsOuOcO+wrfCrjvCnMKnTXt4PsOvwpxcXGLCk3HCjzzDj8OCS8OZXHUwMDA1wqTCpMOZQsK7XHUwMDFjw6Jmw5k9fcKrXHUwMDA0PUAowr7Dhz1Kw5tnXHUwMDE4Zn1dRnvCvSPCusK7LMOFd1x1MDAwM8Kuwr1+wqjDhHkjZlbDi8KIw6rDm8Ojwo/Du8OHTsOCM0BcXHQ7fVHCg1xcZm9PwqnDkng5fT7DpMObw6ZcdTAwMDXDkcOCXHUwMDE3wohcdTAwMTlJw5HCk8K1w74gRlx1MDAxMXYzTcOWwpvCkHtcdTAwMTNcdTAwMWPCgGJcdTAwMWTDlC7DiEZCb8KEVHfCsUlcdTAwMTA9TTzDvlx1MDAxZMOAacO0WsOywr7Dq2AkXHUwMDAyWMKfVsO3T2E3wrzCi8O0U1x1MDAwZmtcXHQ0wqPDrsKEw58+P8O3wobCljTClsOtXFxcXD1KXHUwMDE2w4PCkVx1MDAxMSvDpMKgwp7Dm3vCn28jw5TDpjzDscOaXHUwMDEzc2k9SlrCoMK8XHUwMDA3fD1Nw7rCn8Opw7TCs23CmVNcdTAwMWTDksOtXHUwMDA0RsOoWlTCvMOnw7NmXHUwMDEyw7bDlVHDtkvDr1xcdFx1MDAwNcOTw4/DmsOAw4pLRcO6XHUwMDEwasKzdFfCo8KZdiNywpDClcO3wrTCnHRVw6dWw4pcdTAwMDUjeF3DmcK+wq9cdTAwMDfDhGLDi8KOfcKZVX1zw5chw6XDh8KefD19w5Fuwox2w5vDnDQ0wrVcdTAwMTJcdTAwMWXDkMOEw6DDvCd4wqvCjlx1MDAxNFEocsO5XHUwMDEyXHUwMDE2wpEmw6tOd1x1MDAwM8K5XHUwMDE1wpVXR8OVf8K8XFxmXHUwMDA0PiDDgFxcdMO3w4zCksKFXHUwMDFjXHUwMDA0c1xcXFxqwrsqQMOGwrdVw47CjcKyw6BswrjDpyVnXFx2woLDiT/CtnHDnMOywp/CkmNJw7LDkn3Dj3rDu8KSwrLChsOTPU0kw59cdTAwMGXDuMOAMHLDo33DlsOsw5TCj8OmXHUwMDFlwo7CjsOAwq3DtsObXHUwMDA1OcOTXFxmVsOgdlXDtMKcw5DDhsKQw4DDqcKCX1xcXCI/wolcdTAwMTTDgcOVf8OGXHUwMDBlfj1NJcOVfcOKf3RcdTAwMTTDn1x1MDAxZVfCuMK6wrLCqVVOdcKMw67Cs8O6XHUwMDFjw5vCusKmbcO0W8KDwpLCsMOMwqkhw5fDjlx1MDAwZXNtUVx1MDAxZFx1MDAxNmtcXGbCt8O0dcKYJsOOJsORVMKqw5RZWsOdc1x1MDAxY8KJw5XDgsOcwqHCpExBwq3CnSXDo8O8ZyVcdTAwMTXCo1x1MDAwZcKqw4fCoMO1w4DCliBGwq5cdTAwMTk8w5DDtMKbUMOJw7Z7wpzCl8Odw6fCtmFcdTAwMDLCs1x1MDAwNjbCiHhcXFxcNcO5flx1MDAxOcKrdS59U8KBVVx1MDAxNV/CjMKrXFxiN1xcYjRlTMOVwrrDtlfClVx1MDAwMXk9QC3CsjdBwrhPw4zCq8KIVsOdw5DCj1jDoMOGw650wpdcdTAwMGZTSmfDnVx1MDAwNnLDjCR7XHUwMDE4XHUwMDEyXj1KI8OPwrjDj8OPw5/CuirDu8KwU8KqXFxcIsO4w5Nmw7QkNlx1MDAwZsKtw6rDtlx1MDAwMcOOw7zCtMK7wrnCgsKCwrQgwpZjwrtKcDXDk3RNXHUwMDA2wpdPw5pOU8KDw59Ww4BFcsKDbEXCjVXDjMKGw4rCm29Ww6/DosKAXHUwMDBlPFxcYkhXw7PCpcKpSMOBwq7Co1FJw4BcdTAwMTBcdTAwMDfDnMKOXHUwMDAyXHUwMDEyRGVcdTAwMTFnw6DDisKYw67DnEXDgG9dwrTCj0/DncOcwrY/XHUwMDE4MMOcXHUwMDFlZsOIecO5fSjCkVx1MDAxNlx1MDAxYsKWXHUwMDAzc8KBwoUvYMO+Vi3CvzfDu8Ocwo5CwrhgMVHDoMK+w7Z9Y3fDjnHChnTCv8Krw77DvGnChFBQwolFXHUwMDExcjBSwrJ0wqxYw4VuwoDCgz19XSRcXFwiKnbDqkB7wpbCrcKww63DnsK8w5vDhcOkwpnChMOOw7hcdTAwMTdCwrDCplx1MDAxYcKkXHUwMDEzfsOZRlvDgUQ/LsK0dsOtw70sQSM9TcK+LcO5XHUwMDA1wpPDv1x1MDAxN8KCw5s3fHPCtmfDs8OkUcOowpnCpnrDmFx1MDAxZsOCcMOnw4fDjlx1MDAxN8KEw6VcXGLCisKVPUpxw5FcXGYowr7DkVxcZsK4woPDsjk5w7Rfw6/DhF/DjMKIw4w/PUrCgsOvXHUwMDA3wptLw45/XHUwMDAzwodJXHUwMDFmPUpewoQ9SsK5clx1MDAxZkc9fcKfw7XDiMKnwqnDjFx1MDAxOHtTw4XDjVx1MDAxNMKaU39WOcKjI8OlwqXCi3M9fcOOwr5cXGY+w47Dn8OscVk2f2hmXHUwMDA3YcK7w4xcdTAwMDQ1TyHDhFx1MDAwMl9cdTAwMTfDlsKncmhcdTAwMTlZw49zw7U8XFxiVSN5J8KDw6hpw7pYIcKEwrBTJcOWcVQsw5nCnVx1MDAxOMKAw6dDcHNcdTAwMTTCjFtNwrlyXHUwMDFkwo/DuD7ChsKgRTwtIC1cdTAwMGZ/w5hcdTAwMGZcdTAwMWTCvMOSw4DCuy3DhVx1MDAwM8KgwoNcdTAwMTQkwrorJX/CisOEwobDhVxcYnbClmvCv8OmwrgvXHUwMDBmw4BvwpJmwrXDmsOdPX1cdTAwMDHCtlxcdG3DsDdCwqLDpcKOw5cgR1bCisKfMUrDoMO/w549fcK6YMK3woTDisO4eGrDssKtdcKAOMKrw5s3LlxcZsK1XHUwMDFkMMKWbsOEWUZcdTAwMWXCoMO0wr7DscONIcO9XHUwMDA2U2FBUsOEwrrCh8KEw5XDisOWaVx1MDAxZl3DhcKEwqNHw4vDscKyYsOtaXXCicKFwqDDljYxPU3Dj8KlwppEw7B1woIvw4TDksKlwqxZwowsw6hcXHTDoDzDi8Ogw5Nsw6dcdTAwMTnDrlx1MDAwNsKWXHUwMDFhwpvCtcKCXHUwMDFkLsKXw6LChcKLXlvDpDx8w6BcdTAwMGVew7R/TMOHNMK7w7/DosOWw45Ow5jCpXXCrcOWXHUwMDE1wqE9TcOcT8KCfSRHwpfCkFx1MDAxOcKawp9VXHUwMDExw4VMwrrDtsO5wpHDqMKlXHUwMDFkworDim/DksK5w4JcXFxcw5TDksKjYcOeXHUwMDFiXHUwMDE5w77Ct8OcwpzCgkbDm1x1MDAwM2LCtE1cdTAwMTDDqj7Ck1x1MDAwNkg9QDtTTcKmXHUwMDFjRmfDkWbCoXTCmsKGwrN+YjTDozfCllx1MDAxZjHCkE3DrsOeMcOAwrfCi1x1MDAxZVBcdTAwMTBoXFxcIsKeXHUwMDE5wr3ChDpgPU3DssK1wo8yw5jCtj52XHUwMDE2XFx0JybCsMOcbMKLw6DDiVUpw7HDgsOFwr5LwojDpFx1MDAxZcOJJnVcdTAwMGXDmVx1MDAwNsONKCDDpmhZwqzCocO6YFRcdTAwMWXDjCHDgcK3w57DpcO/w6Q9Slx1MDAwM8Kyw7PCu0vDmMKMKGxpOcKtw7XDhcO6alxcdFxcXCLCv1x1MDAwZcO6TlxcZlx1MDAwN8K0w6PCqMKNwpJRUMOoYFxcXFzClzBPM8OfW1x1MDAwNFNcdTAwMTXDiMKYw5DDh8Knw7BHOTTClHQrQcOtbHPCj8KAwprDrsKCXHUwMDE1ZMO6SsKhw43DkVPDrWHDmMK3w6DCosOeRMOZw4nCjMOHXHUwMDE2ZsOFw6ZcdTAwMTZcdTAwMWM7ecOBwrfDnVx1MDAwNFx1MDAwN8OBK3DCrMK/w6LCo8OXScKdTlx1MDAwNMO8f8KjdVfDgl9ow4lcdTAwMWJfw60xccOGdsOyWMKNXFxcXMO3XFxcIsOcO0nDsMKrYlx1MDAxZMKcwoRcdTAwMWNHwrErwoNiw6DDi1x1MDAxM8KNw5puwp4swqFcdTAwMTbDtTNIw4R2w6rDnDhawoJcdTAwMTDChcKbwpzDtVrDjsOuWcOGwp1BYlx1MDAxNsKewpxkXHUwMDExMMOuw458V8K4K8OPwrHDtMKOw509fcKCw5zCsjJcXFxcT8OYwoPDosO2wojClMKuPiXCqlx1MDAwNC7CvWszwo3Dj0M2RcOTNGPCqCnCkl90RVk3PUrCmsKBw57DgsK4w4fCtsKZw7/DrGR4wq3DmcKGbi7DvMOawr/DinJVwpfDiW17w67DnXtucsKnw5xcdTAwMDVEw4rCq8O3woY9fUF1wqBMw4lcdTAwMWHDpCHClsOKVMOFXFxcXMOZw7/Dp2vDnMOHJsKHw5Rwwp/DsMOvwp1GwqjDg8O5aVx1MDAxYlx1MDAwN1YlYjByPUpzw4DCrcK4LMOuXHUwMDA2wqLCpMOSV8OBUsKtwoPCtcO9Skp5WsKlwp7CqmtGwotPXHUwMDE5wrV1wpwtWcOew7pcdTAwMTVcdTAwMTJNXFxiUsOkQMOdwrHDh8ONwrdPwpFRw5bDkG/Dg8OdXHUwMDAxwpFzw6vCvlx1MDAwM8KxwqdKdcKnw4tcdTAwMTE0XHUwMDA1w53Dg8K6wrxZw403w7ggacKDSFxcdsKBwo89TcOJXFxcIsO5wqHDgsKow6nCj3NcdTAwMGZQL8KOw558wqAqwop0QErDlMOHU10oTG3CtFxcdsKVw4g9SsOaw5rDlkTCrMOMNDDCkV/Dt8O0XHUwMDE5NCdcdTAwMGZcdTAwMDbDosKbwr5cXFxcL08kY1x1MDAwZlx1MDAxZlx1MDAwN1x1MDAxOThlYsOwwp3Cu8OBw4NEXHUwMDFmw7p0XHUwMDE5XHUwMDAxXHUwMDFiaX/Cg8Kxb1x1MDAxNDclOMKrwrzDo1LCr8Opwr7DhTjCu8KeJMO4wrtPSsKAwpB6wovCi8O+w5rDj8KJwqIwwotTa8OQPsKlOMOaw4JmwoIkXHUwMDEzwoTCjsKIXn7CiCRVw4fDv8KNwqNlOjnCkTDDuXVcdTAwMDdmw7XDiVx1MDAxMcKHwolEwpNnNMK1w5pub8OnwolcdTAwMTA2XHUwMDFlL0dxJcKdXFxmbnnCpSR/XHUwMDFkXHUwMDBmUsKRw5/DlmjDtVx1MDAxMlx1MDAxNGgww65OW3ZcdTAwMTDCjUrCi0jCpcKwWzrDr8OcXHUwMDA2wqo0XHUwMDE3w7UmezRLwqjCiCDChsKUXHUwMDE3WVI/wrtnWi7CtsKoXHUwMDE1wqRmw71cXGbCiz1KN3HDqikhwpFcdTAwMTTDiVx1MDAwMlx1MDAxNMKHcsKIwrLCkVx1MDAwMT4hwphcdTAwMTQmw5dcXHbChClgwrzCh8OOd1TCrcOMQ3NcdTAwMDHDssO0T1x1MDAwM8Kuw55iXHUwMDE4RSPDpFjCtFdcdTAwMWE+w5BFwo7DkFrCqMO0QWjDjsK7wrxxdz1AwonChcOPLFBGw4HCrXvCvcOCXHUwMDA3NsKlwq9cdTAwMDPCvcKLIMKoXHUwMDEwayXCnlx1MDAxYTjDj8OIw592w4HCkyPCmVZcdTAwMTXCvHzDscOcUcOuw7HCh8OqVEwuJlx1MDAxZFjDoVx1MDAwNFx1MDAxMcKHwr7Co0TDmcKPWFxcYsKyw5jCp240IcOxw444w4hcdTAwMGVDw6VpwqHDqsOawpBhM3nDpsK/RSjDq8OjwppGwrDDp8OwwoIvwq/Dj3PDhcKKw4Z1LcKXXFxcIsOaZcKLw7fChcOlw4BDXHUwMDEzwoTCpzfCq3pcdTAwMDPCsMOMwqlYR8OxfsOtw4diwqDCpMOrw7xQwoPCnMOoXFxcIl9fIyzDgsO5wqHCnFxcXCJtw5t1woTDgGZ1ZMK8w7JpJFx1MDAxMcOmVic9fcODSz1Nw6XCqlxcdmE+wrN4XHUwMDBlakxcdTAwMThJwr5cdTAwMWTCh1x1MDAxZFN0w74rNn7Cv8KHXHUwMDBmXHUwMDA1Y8O6wqvCsDBHwrx5w7pcdTAwMDPCiMO2w5hcdTAwMWNXwqDDhlx1MDAwMyrDp09IasK4OsKEaFfCssOsS8K2PMOwVTzCkEw9fWlcdTAwMTHCssOEUVx1MDAwMkvDksONXHUwMDAywofChFx1MDAxY0jDqEPDjFxcdHHDt3HCtT49fUnDulx1MDAwM8K1N8OHLcKNayvCjMOqw6PCl8ObwqzCjSbDo8KcVlx1MDAxNsKIw6spbT/DvFx1MDAxNDRcdTAwMTjDqMO7wovDrS7DhsKsw4pywp7DnE1NJlJ1wqRtVnE7J8KiwqLCjcOcVsOGfURcdTAwMTnChkrDhsKnwrDDh8K1Y21cdTAwMWNRw6zCtlxcXCLDscKNwolSSDnCucKxUWjDp1xcZmPCjsOhwrHDkTfCsVvCq08jw69pSko/wr/DslxcYn53wqHDg8KTeMKjw5HDmGXCqsOwwpjCk8K2M1x1MDAwNFx1MDAxMMKFwp3DrMO0w4PCq2MoVMKYZ8KkRVx1MDAxMMKww6ZQXHUwMDE4XlQyO8KOw49cdTAwMWHClFx1MDAxNsO2NsO/w5JcXFxcbcK7WcKfNsO8VsOAw4hdwoTDt8K4wpTCgcORZD1AXsKoSjBXwoDCpjDDuMKpXFxiwpt/XHUwMDE1wpTDg8KiXn3CsDnCsEZbY1x1MDAwM8KIwonCpsOWbsKGN2XDgMKIwrTDjD1Nw7JIcMKYU2prw6nCg8KddsKLw7xmw5XDl8K3NcKLYcOSw5U9TcOzW0HDlsOfwonCilx1MDAxNm/DoMKKwpNVV8K/w5dgwoHDlFx1MDAxYcOSc8KvwrrCqkt2w6PCkUDDnlx1MDAwMsKTwofDs8Oswpw9QMK9w7nDhcO6YsKgY8KIwoYsXHUwMDAywrbCiMKcXHUwMDA0wovDk8O6NybDl8OTWcObwo5cdTAwMWLDgsOdWFx1MDAxZMO9XHUwMDEzPX16woHCoVcnwojCh0MudCd/w55cdTAwMWXCvTnCrUIuw47DiihqMsKGwqfDpzTCrsOxaC4yPz1AwqVdLsOfP8O8w7JoVT1AwqltwqRcXFwiw4gxXHUwMDE0w4FeSMOmwr4wwr/CtELCknbDhcOeSMOEw45cdTAwMDNcdTAwMTDDhSEmXHUwMDE2wpYnw7jDtcKww6PCucKHw5jCvlx1MDAwZsObwo16bsKLwpRLwpPDqcK7J8OewpHDr8KmVsK8wrLDp8K0d8Kww7FcdTAwMTgjXHUwMDE2wpFpw5XCk1tcXFwiw7BRw7xiw6NtP8K0w7FmXcORw5HCn1x1MDAwZcOzw6tcXGbCm8KlbC/Dk8KvKCTDnFxcYlx1MDAxNllIw43DgsOoQ2EgwprDt0hcdTAwMTTChcKVwqpcdTAwMTXCuSNcdTAwMDchw47DhsK5I1x1MDAwZsKbP8O2XHUwMDFjSVx1MDAwMcOPw4kpwp/Ch2Qjw5HCn8KTXHUwMDBleVx1MDAxNXzDtcKpfMKzw6bDjUjDi8OPw5xDIzPCkFx1MDAwZcOxw63CvcOBw63CiTl5woc4w4k4ecKGOHldUVxcdlHCmzXCscOJwqJ/KTNcdTAwMTbDkVx1MDAxY1HDrT19I31cXHbDmybCs1x1MDAxYWLDvVxcXCI9fcKeQn/CtcOiwohsc1x1MDAwM8OYwr1cdTAwMGXCocK7wr9jwoPDqHbCosOJwpcvVX1cdTAwMDPDqFxcXCI3LVx1MDAwZmYkJGh9dVlcdTAwMTcgwopeJ39cdTAwMTgpw7R5XHUwMDE4wrzDmybDkMKjWsOMf8OzUWJLw7nDm8O8wr3CgcK/KFxcdHbCusOwwoDDl15cdTAwMWXDgcO6ciM5wrxcdTAwMTZzY8K5JsOIwpHCiVxcdGHDssKCd8K7w7hhIFx1MDAxM2Jpw5DDlyckw6QpXHUwMDA0wrt3PX3ClzI4woXDj1x1MDAwM8O6w6vCvMKMwoDDscKvw5BKXHUwMDA0XHUwMDAzK8OJeHzDjGHDh1x1MDAwZlx1MDAwNCPDgmZMwppcdTAwMTRnw4B+w4U5woLDpj1Aw7ZIQUQnw7jDmUNcdTAwMThww4LCqcO1wqdeNMOTwqLDl8Ozw5k0YEPCjT9uw4jDk8OafyhNwo9QwoPDsMKrwpTCrsOQfVx1MDAxOXxcXGJJw5XDti09TcOywokyw7RgNcKAaVx1MDAxYsKvwqXCmMOnXHUwMDFmPUDCjcOBw4k9QMO7JVE9SsO7bMOGXHUwMDE0woN+wo1cdTAwMDdcXHTCnsKPw4nDl0NFw6krw6BkM8OVWyltI0DDqEbCrDDCmsOPQiDDhVxcdsOxXFxiwolcXGJeXHUwMDFlXHUwMDE1wqsrQCjCqlxcdsOXw5nCs8KHfMOwwowlw5rDsMOgS8Kfw41cXGbCi8Oxwq42wpFcdTAwMWV+w6Jhw7Z7Q8OSXsO2wpnCkTnDv2jCtcKbwppSeMKywo7DjCZcdTAwMTMmwqrCiGHCscOufsOgLcK7w4PCnHDDi3TCvcOMwqdcdTAwMTnDmsO6ay1cXGZUwpHCssO7wrjDt1R6RHDCtMKwwrx1w7hcdTAwMDfDgz19w5zCl1x1MDAxY8Ouw4PDm8O+MjUresO4R8K9wpDCv1x1MDAxMsKQXHUwMDA1fMO0LSN7wohcXHTChVxcdsK8XVx1MDAxMlx1MDAxY1/DrcKSwq9SckrCv3VcdTAwMTLDu8OEwqpGwqLCs1xcZlPDgcKKYcOlw6xYXHUwMDBmXcK2XHUwMDE2cMOzw7vDlMOwXHUwMDAzI8OgXHUwMDA2XHUwMDE0OnTCrcOjwqlcXGbDiCkkw6DCiSRkwo4mwpArwpNnXFx2w4ZYIMOdZVDCrsKHfMKYZsKUXHUwMDFjwq/DjMKHw54ow71MUCXCg3bDgsKWOyvDp1x1MDAxNSbDqDTDknA9fVxcZj19L8KgXHUwMDBlXHUwMDEwwpTDpMKDwrTCjm3ClHo4JcKEOjhcdTAwMDMjwq/DusK0McOgw7ttJn3CgFx1MDAxM0PDtcK8PUBiwrXDmz4zNMOFwrxRw4fDnTRAXHUwMDFjUcOJw51RJ8Odw6/Cn8O/PX3CnMOUw5vCuSQ4XHUwMDEzOFx1MDAwZcKJQ8KORFx1MDAxM0hcXFwiXHUwMDBmN1x1MDAxM13DqMO1XHUwMDEwaWg9TcKcPUDCqcKmeGkgwq5cdTAwMTVcdTAwMTbDscKwwpHDg1x1MDAwMUPDsMOMRS3DuGw5XHUwMDFiw5k6wpc8dMOtaDZ8w4xOVnfDmGDDmF7CqsOxw5XDq8OFVnvCmsKywptcXFxcw73Dk8KLcj1NPX0qR8O8XHUwMDFiPU3DqFx1MDAxZMKzwr9vccO/YSzCg8KjdcOWw6hRRsOuwqVcdTAwMTVcdTAwMDbCh2fCgsKkw7TCjVrDpMK7w40rw5B0wqLCv2TDs8ONw7jDrSzDvMO7wr1mw6knwqfDucOJTkbCkMKGw5PDgsKfI8O5w7NcdTAwMTEnw4PCqU9veD1AwozDl8KbXHUwMDA2woMgwr1sw5TDscKSdsKMXHUwMDEyw7PDkcKBw6w9TcOpJCFqwrzChsOGbMOZL3xGw6I4QCXChHVcdTAwMDE8wpU9QMOLIcOMw6Usw5t1wpvDqsK6TlVSwrHCoUJcdTAwMTAyVj19ccOAw5HDlG9Rw45VwrNcdTAwMTLDrEtnwq0kU2LDqMOKw5jDtsOnVEDCjzbCvcOzw7prXFx0wqUxZTtXw4zDmcO5XSzCqsONXHUwMDEyIcOEw4w1woRDw4tTXHUwMDA2w6jDpcK3w57CkMOfwqvDt8Kdwo1cdTAwMTZKXcKGYMKKN8OBw7fDkG7DicK5wodcXFwiwrTCo0E/w7jDjcO9f2LDqXVcdTAwMGbCiMOoRFx1MDAxM2PCmcOewoVAwoXCkMORwrzCl8KtL03Dn8KscVxcYsKfwrstw4HCi8Kow61gY8O2wqNYwpFRwrBjOy3Co8Ohw6DCs8KLeMOuw5rChGc7W8O2wrNCw7LCrcOfdzbDokAwwrpxbzdcdTAwMDZrNMOvPX0qXFxcIjbCgmo9SsO9PX0sw79IwqnCsFx1MDAwZsOFw7pcXGbDimFcdTAwMWQoXcOmcW9bZsOfIcOJwo3CqyfDp0HDrsK/woFmb8Orw7l7wrrDnlxcXCJ5wrc0wpjCrsORw5TCrMKAwq3CrMKIw41tN8Kfw6drN34/XHUwMDE1JMKwR8OewrDCi1x1MDAxNDFswpYmw65yZMK7wod3wop0d1x1MDAxN1x1MDAxZMKYXHUwMDA3woZ3woo9fVx1MDAwNMOeMFx1MDAxYcKRw6Itw7FfLl3Cu8KTwqfDhVx1MDAwNsOUw59cdTAwMDVPw5vClzgrUcKzOcKKwoM/wo9wwqfDsMKWw4pfwrk5O8OUwrJAVUxCw5HDr8KbXHUwMDE2N8OQwoBcdTAwMDfCp2NmI8KTJVDDtcKowqApwr/Ckj7DuSTCvT1AXHUwMDE2w73CkGrCs1x1MDAwNMKOw6VcdTAwMTRDwoPDqsOTwo9cdTAwMDHCiSfCpWNJMlxcXFzDscK4OMO2w6JcdTAwMDMoLj1NXFxia8KqZHZGfVx1MDAwM0g9fXrCpMKEXFxcIjZDw6tcXHYxRD1NK8KXw4TCjcK5w6x9wqJcdTAwMTfCklx1MDAwZTPClVDCmMOnwpklwoXCtio7wpohdFxcYlRob8OzPsKawp5cdTAwMDclw5xww5bCsTlcdTAwMDVhMcOCXHUwMDE1XHUwMDE2wo08w4LDu1xcZlx1MDAxYsOWXFxmTFx1MDAxOD1NZMKgwpg6XHUwMDFiflxcdMKtW1x1MDAxNcK3wq4jMMOOOFXDr8O/XHUwMDFmMVDCujjChsKPw6FcdTAwMTfDnsKjwqDDhcO1XHUwMDBmMsOsXHUwMDEzw4fChsOWw712XHUwMDE5ZHvDhMOhw4TDp2wuQMOpI05Rw7IpXWbDv8Odw73DiHFCw5FsacKJwrpuwqBcXHTDtjssMVx1MDAxZcOHwpnDtcOnwpzDl8O4w5LChcKEXHUwMDE2XHUwMDE2wpE/wrHCn8ORT37DnsOyZsKmLkgwwpLCiMKIw4zDg8Oxw54hOFx1MDAwNsKXXlx1MDAxM3bDtMKNXFx2wrPDkcO3XFxcIlx1MDAwZcOyXHUwMDFmwoJcXGbCosKXMFx1MDAxNMKNXSQ9TcObwoNcdTAwMTLCnDTDtlTDmH3DuMK/woTCqMORw4lcdTAwMTHCkVnCm8KDw7F/wrJFw6VdaHnCnkDDtT1Nw6PDl8KvXHUwMDE1w5jClMKSwpLDqMOTXHUwMDE1Um/DksO7w6dbXFxcXMKxSlx1MDAwNSvDi8KCw4BKwrxiXFxcXMKmf2TCglxcYkwydiVqQ8OTaHJcdTAwMWPCtcOdwqDDglxcdFFcdTAwMTXCsjHDs2pcdTAwMWJjwoFcdTAwMTjDpFbCu109QMOrX8OtwppHwqPCu1JcdTAwMWZcXGZcdTAwMTfCj8OEX1x1MDAwZlxcdMO8aT7DkMOHwppcdTAwMTLDjT19Yi1mXHUwMDBmwq7Cj8KpTcOuw7RLw5I9fcOzwpBcXHTCqkQ/XFx0wo3Dr8OZw6vDllxcdMKPwqVqw5s1NMKEXHUwMDA1wqJDc8KWZMOFeSPDiMOIwqfCpMOuacOAw4deWFx1MDAwNn3CpcKXIVx1MDAwN0BcdTAwMTLDksKOKsOZKT19w71hw4vDp8KgI3/DqcOBbMKyOMKKw6gtw49cdTAwMTfDlMKZXFxmcSvCl1x1MDAxZTnCh1x1MDAxYUp/w6nCtcOdTFPCmcOqX1x1MDAxZT1AKcOWXHUwMDE5XHUwMDEzw4NLw4zCqsKwwqMvwrfDtMOvZcORPX3DniTDmMOfXHUwMDE4wpjCnl/CuMKrXHUwMDA3wpxcdTAwMWZcdTAwMTZdw4vDvcKgXHUwMDEwXHUwMDAyXUIrJMK3w6RNwq3DjVxcXFx2XHUwMDEyXHUwMDA2w4NcXGbDon/DiMOnL2PCtSDDkVo7acKhSlx1MDAwMcKOIWNcdTAwMGbDmVx1MDAxOcKUw5nCrMOZwptMQVx1MDAxZcOzw73CrsKdwqrDiC9yw6U8XHUwMDBlw7RUXFx0w4vCpmzDhsK8T8KsbsOld8OnQkJcdTAwMTRxXHUwMDA2w6JcdTAwMDLCs1xcXFxcdTAwMGbCvD1Kw4LDiyBKSFx1MDAxZXl+UilhMVx1MDAwM8Kxw4bCu1I4wqLCp8OmccKXKmdKUibDrXVGMXomwpnDhcKXWcOjw4LDtsOPw4rCriPCnCrCvX1sQ8Oyw5tfXHUwMDFhPX1mwq7DgsKRbsKiw4s6XHUwMDFjw7TCqHl2w5o4w7hcdTAwMDM4YMODwpFcdTAwMTbDmXzDvzxcdTAwMDPCkjFOOsKmw4jDoVx1MDAxNMO0aVxcdsOAwrnCjVx1MDAxNV1sw4jCrSbDtlx1MDAxYcKjwrxEXHUwMDAzwphNV0TDl8KDwrZnMnUgMCZKXHUwMDA0w7FQw4dPwqZOw7xHYCtFXHUwMDA3w5BwQTxhwpI3XHUwMDFhwobCkcKqXHUwMDAzXHUwMDE5KMOEw5zCtcONXHUwMDAzwqRcXGLCmE7DvD19w5nCtEhcdTAwMDfDjGhiXHUwMDE4wrfDrT5cXFxcwp3Du8KjNEtcdTAwMWRaPMOcXHUwMDAxR0rDiXFofDXCtE98wq3Cqi7DjjF7SF5zwpclUlgzM3nCm2p2aGMpw45cdTAwMWXDv8KuwodcXGbDsVFcXFwiJkDDh8K3c8O4OGjCm8KwJ8K3wocqw6nDkcOCwqbCrsOic8KucsKtwpnDolx1MDAwNsOMXHUwMDE3O8K4c8Ozw6DCiks9TcO4wodcdTAwMDJReV5cdTAwMTFcdTAwMWZcXFxcw7zCmmY5aFx1MDAxZcO4w6TDmcK5TcKNPU3CvlDCjVBGXHUwMDBlWsKzw4fCvcObw5JXXFx0wqNcdTAwMWNLcynDm1x1MDAwN1x1MDAwM2M7XFxmwr5gw63CiMOpwofCtsKIXFx0w7JcdTAwMWHCuSTClXV+w4nDq8O6WVx1MDAxN8O0wq1Uw4PDvERcdTAwMTJcdTAwMWTChCzDvMO8w45cdTAwMDXCmsOLSVxcdMOkw5tYPU3CkUrDjidcXHZzw45/ZcKnwpRcXHTDp0M1wopFwrHCosO/woLCslxcZsOHKT1NXHUwMDA1w7VQw4NIOVx1MDAxZWLDjMO5XHUwMDE2XHUwMDE0w6bDi0xcdTAwMTHDnsO6f35HwpvDmcOFwovDocObUMO8YcOZw4/DicKNw4DDosKubDFAwozDrCo4T3TCq8OcXHUwMDAyOzVVfT1Awp9FMsOLwr87Nmk9SlTCkcOHwrxcdTAwMDXCj1x1MDAxMcKwJMKcXHUwMDBmXHUwMDE4N2bCt2RJPX3DpTbCs3VjXHUwMDFjwpzDrcK3w4tcdTAwMDNjXHUwMDFlwp0qXHUwMDA1wrnDq8OiwonCs8K3XFxcXMO4XHUwMDA3Ulx1MDAwMcKJXHUwMDAyw48rw7bCu1x1MDAwNETCvlxcYsKvKlxcdsKAw4oywpTCr1x1MDAxZcO9XHUwMDAzw57DicKDR1x1MDAwN8K8w6LCuzlCU1V1Jlx1MDAxOMOiw6x6OVXDn8OHwpHDs8Odwq3CpsOaw5rCp8O0XHUwMDA2w61cdTAwMThowpVcdTAwMTLDiWBcdTAwMTlEw41cdTAwMTPCtMKZXHUwMDEyPU3DnEhTw45dZGRcdTAwMTI7XHUwMDA0w6Q9fXXDmldcdTAwMDVPwpduwrs9fTwww6VcdTAwMTDDusKEMlx1MDAxYsOEwq/DkFx1MDAxN8K9w7TCi2XDvsKKZcOEw5TCplfCrsK2wpTDjXXDpVx1MDAwZlx1MDAxMDdcdTAwMWHDv8Okwps2XHUwMDE3I1x1MDAxNCzDmcOQwoPDhFBXw49cdTAwMWPCg8KDwphcdTAwMWbCs1x1MDAxY8KBwphZXHUwMDA1w5bDiMO4wr3CkMODwq5jw4Z7JcKkTsKOworCsFDDrSzCt2hCwp54MFx1MDAwNigyJ8K2w7s8w4XDv8Kxw4N6aD19YlZodMKgwqrCucO0fMKQMlx1MDAwMcKcw6jCs8Ozw6jCgMKFwpnClcKGwprDtFxcdMO3w7FVXHUwMDA0w442cjTCvF3CsMKFwoZcdTAwMTPDjElcXHRNwr9NRz1Aw7lYw7PDnD1NX8Ksw5hcdTAwMWJaXHUwMDE1wodcXHRcdTAwMTY/YVJcdTAwMDTCg0gtXHUwMDBmw6R1w7UgU1xcdlx1MDAxOMKXUjfDoTdjI8OSX8KBXHUwMDEwRFx1MDAwM8O8SMKkw6nDlMKXdlx1MDAxNsKnXHUwMDBlwrDCoFx1MDAxOMOBw57Ch8ObVC7Dklx1MDAxNFRFKDbCn8OnXHUwMDE5T1vDtMKnZTDCnz19PU3DonPCrcO8w7E4XHUwMDAzwqdDQMK1ZFx1MDAwMcOKw6RcdTAwMGXDicO7XHUwMDE5w4rDmUowUsKpXFxiXHUwMDFjPU10bMKcwrxKdjd1OHdcdTAwMTdcXGLDsnNcXFwiWFx1MDAxZcOAXHUwMDAycU41w7PDq8KSXHUwMDA1wrDClDLDu1x1MDAxZlx1MDAwN0fDmlx1MDAwZXrCgsKOV2fDglBcdTAwMTBcdTAwMGZcdTAwMWQqMHgow4nCvVXDjFjCjsO9wqZewr7CjsOpR8OYwoHCnFx1MDAxYkRTwpE4c0XCjMObXHUwMDFhw67DmMKWUsKVcsOJOXBTwo3CscOoSGvCv1x1MDAwZSg/XHUwMDA1NsKKWVjCqMOlwoUqR1x1MDAxMMKiZ07CslpcdTAwMWXDrkLDhsKHw7rCsz9Pw7TCki5Fw7NcXFxcwrEzYznClMOqw4HCoMOKw6rCqmnDjlFxXHUwMDFjPX3DgCDClMO8w7DCm1JIXFxcXFx1MDAxY1nCvjNcXFwiw7zCqmnCjk7CvMKww43CrcKabFx1MDAxZMKZXHUwMDBlwpzDp8OoL8O6TMOaw6DDi1x1MDAxOVHCg8OKwqvDh8Kyw505w7p+w4nDi8OsXFxiw77DuDlcdTAwMWTCnGdiwphJwoxcXHbDhVx1MDAxY8K0w5pAwo7CtVxcdsKkw5nDq3NcXFxcc3B3wqHDucOJe8OIw6B5XHUwMDA0w6ttKn5cXGJIe01zwpdWZHJcXHTCgcKfw5XCjsKrXHUwMDFlWyDDk8Kyw799b8OUOVx1MDAxM1x1MDAwMsKtS8ORd8O8wr/CjC9Ew74xwq3Ds8KKw5IoQF49fcKxwp4owqnDksOlXHUwMDE1wqd4w7pVw5VjXHUwMDAzXHUwMDExwp3DrMKDbmhLVDXCpMOJwoA9QMOMecK/XHUwMDFiwrozY8KUPX3DnHl1OMORXHUwMDA0w6fDizJ7SsKQPUA9TcOmwoLDiMOOwq/CmsOmNCHCqsKTWkY5wqvCisKvw5fDhixLwoLDulx1MDAxZcKGwrnDoMOBX8K5w44tw71mw7BUaMK5RsOdw73DoiMxw6M8w6RCYUDDsXRcdTAwMTLDpcODw43DgkTDjsKraMK9wpBcdTAwMWLDtWDDv8KvXFxcXMOjXcKAeH7CnH7DlknCmFxcZsOiw5jCqVx1MDAxMsKuwr3CtD1Kw7A6w75cdTAwMDbDmMKZwonDmsKQwrTDk8KOXHUwMDFiKsKyw5M7w4BLwoXCnzrDksOPJsKSXHUwMDE2wqsgw4JRL8KCw7bDqkPDkcO7NlF2woHDgTBvXFxmwo7Cj1x1MDAwZmVcdTAwMGXCnj9iwqfDg8OZQsK9TsOXw5XDi8OPJnxcdTAwMTbDgnPDmTPCvcOOT8OWPDbDssKBM1x1MDAwZcKmNMOxMcOgS8O2w4kxwo5tw4NDbUPCl8OMXHUwMDFjwpbDu2lRTcK+w6s9SsODw7HCo8OLw5s8woY6ejNzwofCkMKJMTpnw7cuPGdTw4HDgzjDlFx1MDAxY8OjP8KPJUFtwqFVPsO4U8K+XFx2SsK8XHUwMDE4w7PDisOew6zDnDXCv8OCYGzClcOeXHUwMDE5YS3Cg0LDmiTDjMK3worDvlHCs8OfPUoow4NMwq3DmzvCi8K+P1x1MDAwZsOKZ2xlN8KDXHUwMDExw6hjbWBWw6s7woDCgHLChMKKw49Gwoolwowrw7bDuWhHXFxiOsKeTmM2VXxMMlx1MDAxOMO6w7tBcSdDwq3Cv0ZmUWk+woBuw7LCuFJjJT1AW2xcdTAwMDV4Q8OcwojCh2nCvsOtOMOhfsO2c1x1MDAxZFx1MDAxMMOZw6xXw4PDnidMKjUkw58yL1x1MDAwZsOWXHUwMDA1wrjDi8OESGjDscK0w5xcXGLDsDXCjMK0w7Byw7bCscKNJFLCqsO7UVx1MDAwN8KeLMKDw5PDo8KMwoBlw6jCjmdGPU0sLcOoOT7Ck1x1MDAwN8O4woZcdTAwMWJcdTAwMTnDvsK0w4otZcOdOMO7wp7ClMK0S8O3MmzCpzZFw5/CvHrDlMKYwp9YwqxiwrE7XHUwMDE5w4F+w6XDs1x1MDAxMMKfwoRcdTAwMWRcdTAwMTRcdTAwMWTDscOhXHUwMDA3aloswrbDjsKHw7osw4l+PX1bUsKswqvCo1x1MDAxYVx1MDAwZcOBw5VcXHZgeVx1MDAwNC7DhsK0w7FvKWEpZsKXwpvCllxcdMKMw7lfwqTDnMKnYCxAw6vDk8Ozw6TCsThcdTAwMWPCq0spXFxiwp9tw4vCoGFsXHUwMDA1MDjCsWPCgMO6woXDlsKpwpUswpPCl8Kuw61cdTAwMWbCiz7CpHzDgMKcw4Z2aMKuOVx1MDAxM8Oww6h3wr3DlCpBXHUwMDFmwpJcdTAwMTHCvcKWcF5cXFwiw59aw5fCu8KTw4cmwr3CiMOgfsKWIMKAdT/DnT1NWVx1MDAwM8K5M8OAw7TCv8KIwqp9w73DkDbDmHJcXHZcdTAwMTHCnWt0Z0tuXFxcXMKdTMOIXHUwMDFjQcKFXUk1VcKTwrPCg3HCmMK/e8ONwoxjXFxmwpzCh8O5fi/CocKaOcO4wrFfLXFcXFwiw5pgNlx1MDAwN8KRwq5cdTAwMTjDgMKaw7dcdTAwMDTDhXvCisOMXHUwMDBlw6BfwrXDlMKHwrnCoFxcdEzCnU8wXFxcXMO2woPCksOtwoBcXFxcK8Kiw4zCp8K1w4Y6w67DuChcdTAwMWVcXHZ0woHDkcOxw6TDrsKRO8O/clxcXCLCkSbDpiNcXFxcw55fw5fCmW9jXHUwMDFmwrPCvsK/wqPChFx1MDAwNDFcdTAwMDM9TcKAXHUwMDE3w6rCs8KOw6bDvMOVcMK/wq3DpMO8w6BcdTAwMDFmwoNcXFwiwrfDkMO8w4fDtFx1MDAxN8KSOMK1TFxcYnPCgMO2d1Jawr/Cv8OOw7xsPUpLwq7DqnRHXHUwMDFmwr3CuXxewoHDssKBw6TDi8OyWsK4wr7CrFlaVMO4wovDtVx1MDAwZcOPNMO8w4fDsk47XHUwMDExNlx1MDAxOCZawpnDtE0xw7FcdTAwMTbDm8OmXHUwMDA1LnPCmsOMwoFcdTAwMWTCtUHCuVx1MDAwND1Kw5nCoivDtFxcdsO2wp3CrkpAXTjDo8OPLMKCN8Kxw7jDk1x1MDAxODYpTcOYwoHDo8KBMMO8fENWw5/DvcKMwo/DpVxcdsONw4hjasKLwpHCtsKMPU3CiynDmMOKZ1xcXFzDp8K/Rjd/KF/DhVxcXFw2w497w5jCiVDDtUXDq8OTRGnDhFx1MDAxZntpP3nCg0dqNsK1dMOuw5FZWy3Do2svw4VcXHZCUltzw5xww69cdTAwMDXCkMKWXHUwMDFiN8K4YFx1MDAxMzvDusOiw5E/wpxcdTAwMTfCizjCl8K1w5NBeFx1MDAxYlx1MDAwNiHDo3zDt8OuXHUwMDA3XHUwMDA0a8OhXcOGWFxcXFw2PX1aZcOGXHUwMDE5wqw6wqDDklxcYsOwwplcXHTDqcKcXHUwMDEyRFx1MDAxNMOuacKvwqHDvF/DkcKbw711wokvYsOQfVDCij1AWCFswpYlSCZ1w6PCkkPCqMKgw6fCisOZNcOIwofCo1xcXCJBXHUwMDAyw4XDiSt0woBEXHUwMDE5wrrDjETDjVxcdsK1wrPCl8OFNsKgwq5cdTAwMTRcdTAwMDLDlcKmwoDCvsO3MsOVZFx1MDAwNsKmw71swqTCuFx1MDAxNMKZXHUwMDE3wqHCpsKpwp5mXHUwMDEywoTDsFx1MDAxOMKiZlx1MDAwNWTDpcKEwo3DuyzDvMO5Pj1AXFxcXFx1MDAwNMOFwoxcXFwiw6B7w4p5XFxcXFR6wopxPsO1wodGNsO3YcOyKDtXL1x1MDAxM8OgwqvCkWUsYsKAXHUwMDBlwr7CvcOUw6fDjnXDiV5LMcO7XHUwMDFhXHUwMDExw6w3bcOoXFxcIsOuPX3Cr8KQw6FcdTAwMWHDrFx1MDAwMsKrNWXCtUFcdTAwMWPDoFFOXHUwMDE5w4J/w5pcXHTDjMKqambDh0dFPjlzbFx1MDAwNk4qw4Nwwq03w4tZfMKwXsK0XHUwMDA1woB6wrc/woRObE/CscKGZD7Cm1x1MDAwNsOOMsK2wpvDgj1AXHUwMDFlw6/DiMOVdFPDpFxcXFxWfsOJJVx1MDAxMMOKb1FcdTAwMDbDl8KtOSB1XFxiw5XClVx1MDAxNsO1XHUwMDFhT8ORw5I/wq7CjSA8PUDDvjtvNFx1MDAxNcOVwoIuclMmw6zCtEk9QFYjwqHDuTjDskfDsVnDr8KqRsO9U3TDusOFw5/CgXYne8K6wo3CicKvPsKVwrZcXHbDoMK/JsKLw77CjT7Cl09Fw5ZpOsKEwpFcdTAwMWTCuVx1MDAwNcO7w5EmO1x1MDAxY3JcdTAwMWEmUsOFw5bDvcK0w67Dv1x1MDAxMcKLd8OlXHUwMDA1bsOaw5g3WmTCim5PaXNQeHXDj8KAwr49SsOQJj19w4pcdTAwMTFcdTAwMDQqT17Cj8OEXHUwMDFjRcOCeMKTemLDq1dJLcObw43Dr8OGbMOgVlvDrVRDw5NeO1x1MDAxOFF8wrxMZ8O9PX03XHUwMDBlPkMpw5xcXGbCrsKPMcOewrnCuEsvwo7CvsKdTH/CisKCasOVw7jCo8O5wq8nw4I6Iy3DoHdmQThcXGbDun7DsMKfY8Kfw5/DsSxDJ8Kpw5bDhzXCtsKIwpHCp1x1MDAxMFx1MDAxMcOlw7ZhXFx0w7Zhw4E9TVx1MDAxYsKiZiBcXFwiwpxcdTAwMTA6w6o4eMKWbDx2MnPCuXdHUStsMsKrfCzDt8OUwocvwqNGw4Biw5tvw7/DrsOIWDtuXHUwMDA1w5I3PU3Ds0DCn8KDwpRLw47DusOYwoXDg8OSwo/Cu8OgT0B1wpPDpUXDklx1MDAwNXB/wqDCi8OhXHUwMDEzbFXChMOUYFx1MDAwNcO1PHTDqiXCpcOIKcKlw7ghwrc9TUvDi8KUTMO5wqFYXHUwMDE5wqPDucKlXFxiXHUwMDE1KSfCicOIccKtXHUwMDEyMF5aXHUwMDE1wq9Lw4vCuk7DsjhcdTAwMTnCoMOuw4HCjz9cXHbCmXJcdTAwMDfDlld6bMOCXHUwMDEyw7Mow5TCv39qw6jDjSRxw4JhU8KPwoVcXGZcdTAwMTZXbMO4wr8pwrXCoVx1MDAxZlx1MDAxNEomw6hvwpjCtDTDvH1cdTAwMTk7MEjCp8ORU8K+XHUwMDFhVlx1MDAxMcKxJ1xcXCJcdTAwMWbCtMK1w51KdSfCo8ONw7jCn3DDpVx1MDAxOV7Ch8Krw4PCmFtmwqfCjMO0wrhjd8OTbGvDuVx1MDAxZXHDgUZcdTAwMTBcdTAwMTfDoE1qwoDCv1bDtMKgTsKewqTCuGnDosKiVTs9QERzwqJKw7hcdTAwMGbDgcK8fsK0XHUwMDExwqYnd8Ovw7ZmN8OcaFxcdMKlwqrDn1x1MDAxMsKuLMKNd8KNwrFKw67CgMOsXcONOMOewqVnw4LDqUNha1dBw49cdTAwMTZBw5N/Vj/CpCtcdTAwMTTCmcKcXHUwMDAzZ3U8NXk0w73CucO/w5PDk8ODw5DDj3zDrMKnOVdcdTAwMTbCgHB8RMOiYFM3woVlOcKpwrHCssKqwqE+w6vCmFjCscKBwoXCgXrDh8O9wpjDrH9cdTAwMTbCqsK+UsObXHUwMDE2w6vCgMKjXHUwMDAzw6Erw4xVwqDDncKlw5rCjFx1MDAxMzJZXHUwMDAzN3bChWTDkXVcdTAwMWR3Yj19fMKuw65cdTAwMTDDqGV2NULCrMKQf01Nck9+w7cyK8OxwpnDvGt9PUpic1x1MDAxMsOGwr0owpTCp8Kowod6wpfDn8KdXHUwMDFmwoE3wplUK3tSw75cdTAwMWPCoG/DhztcdTAwMDTDqz8jP8OEUcKRwpLDlMOowrHCuMKQblx1MDAwZcOSK8Kvw4nDrMODw57Dh3nCjWHCm3zDlFx1MDAxM8Kzwrliw4rCoMOHwp86a8Omw7fDp0dbwr1cdTAwMWZNKsO7Llx1MDAxMlXDqlx1MDAxNsO4wrtcXGbCgF9bwqxbw51ywq7CvsKNXHUwMDE4XT1Aw58qwoHDrsKUXFxcIsK9cMKCwoBcdTAwMTbDt8KYLT1KK8OZUmzCjVx1MDAwN349SlTDtcOZQG3CvsKIw4bCskzChMK1wo9hb8O0w4zDsEDDrnHCnyA4w4fDt8Kqw7zDrnlQw7bCmMKPITTDqcO8SHrDhsK1XHUwMDA3Q8K/w5Mkw6kww79cdTAwMWLCpWp/RsOka1x1MDAxY8OuXHUwMDA1XHUwMDAzb8KiOlx1MDAxNcO3w6Jfw4dHw6TCs0vDrjB4w4I8RsKyJVx1MDAxZlx1MDAxNyBnwpvCnlx1MDAxOcKXw5Qgw6HCu1x1MDAxM1x1MDAxOMKmPUBfVMK9w4g4XHUwMDAzPUpcdTAwMDPDpD5cdTAwMGXDq8OERMOcw5VcdTAwMWXCs8KaIcObwp5LbsKha8OLXHUwMDBlN8Kmw74/wozCgzjDtcO+w48jw5dcdTAwMDPDjsOCLcOGL1x1MDAxNMKZw6VjXFxcXMKfw59BScKhJVxcXCLCsEBiw7jDgsKlw64pXHUwMDEyw5JUw54kwr/Ch1TDh8Oew4fDjMKzwozCgThcdTAwMDFVwq9XwrRcdTAwMTNeXHUwMDE4XHUwMDAzwr/CpjLCmcK+wqHChFx1MDAxYsKFT3dVw41cdTAwMDfDtk3Dn8OHw6jDlXFcdTAwMGZcdTAwMTLCjsOsw7nDkm/CqMOww5PDh37Dg8OdwrXDr8KYcVHDtcKPf3/DjynCkXbCuzdIw4PCoMKyw5VTw5zCp1tcdTAwMTLDpHHDtlx1MDAxNcKha8KXw7bCkMK9XHUwMDA2fEHCmiDDpVfCtcOhwq3DpkQ9SsKZXHUwMDE3w4fDr8KFw5dXwrnDv8KHYsKKXHUwMDFiwplgw4lkw4R3XFxcXMOmLMOfwoXCucO5woZOayfDvFTCmWrCgcOawpRkXHUwMDE5w4RCw4U1wpbDilh8WMOcwqHCscOPK8K6wos2wr3DhcOGaFrDrsOeXHUwMDEzI17DiUA6KcOaLnTCqcKxw5h5woXDllx1MDAwN8KLVsKnwpHCnC89TcObwoM3wrHCusKXwpjCgcOpwrLDl8KiUlx1MDAxOMOFwr5VwqZPwpJTwr5cdTAwMWbCrMOHwrlcdTAwMWTCoXzCpMOKdmvDp8K3XFx2wqRvw4LCt8KhXHUwMDExXHUwMDFjIVx1MDAxZMOWwqp1w7Viwqgxw549TVx1MDAxN8O1JsOrwo/Ci29cdTAwMDHDpMO1UinCtcKhXHUwMDE3wqlcdTAwMDXCt8KFw5nCo8K5wpDCgMKjRVxcdlx1MDAxOUBcdTAwMTFcdTAwMDQxw5PDocO1w6dcXFxcw4the2TDkMK6XFxcIiTCocKnXHUwMDFle0HDh8OtXHUwMDA1Y8KmwoFcdTAwMGbCnV9VK8KDw4fDiMOBesO+Q8K0dMK5wotiP1x1MDAxNMOcw6/DpcOtw7pkw5XCoVxcdsOMXHUwMDEwPX1UwqlKwr7CsMOHNFx1MDAxMMKvSFx1MDAwMsOjw5jDuzTCvMOOXFxcXHA9fcKdPsKYwrQgSsKCJ1x1MDAxMsKiwqppwrTDgcORTMO4w79cdTAwMTRcdTAwMTjCk8OUQlx1MDAwMVx1MDAxYcKPdcKoNsKcwrU9fcKIwoDDvn52w7DDln1cdTAwMDY9fSbDpCQrw4fCrGzDvW/DlHBIwpBSw7zCpMOLw7nCgk1cdTAwMWZcdTAwMTTDg8KZw7/CvcKtw6HCmMKLfH5cdTAwMGXCvsOkw4zDiD59JcKawr/DpMK9dzDDmC5cdTAwMWTDllx1MDAxZMKwRlx1MDAxMsOsw5PDgFx1MDAxZUHDh8KUXHUwMDE1YVxcXFzDs8KQwr1uwoxcdTAwMWbCglx1MDAxMD1AwpXDgztYwqI4wrnCqsK+w5TCiMKNXHUwMDFjw5B4IFx1MDAwZcKZw5/CkT/Cplx1MDAxYlx1MDAxNMOCwqXCu3XCmD1Kw4BcXGYyXFxcXMKlXHUwMDEyR1x1MDAwZT19w4vDuDNRUcKlJnRrwphcdTAwMWLDqcKVdsKiwqPDrk5cdTAwMDfDq2TCljxcdTAwMDVOw5FcXHbCi8OfWMOpNMK9VVx1MDAwMsO6XSTCvcK2wqhyXHUwMDE0w4XDnCE7bMO3Ti9Sw5dGN8Ogw7TDrsOtQGMuw6nDhMK1wofCglTDn1x1MDAxZWnCtCHCpFx1MDAxNSrCvEZcXGLCozE+w5s9fcOJwpPCk0Ehfmc/w4A1w5nDpFx1MDAwNMK8NcOZw67DsC5cdTAwMTjDtcORXFxcImkpXHUwMDFjwpFcdTAwMTPDhMOLw5bDncKGwo9PXHUwMDBmJVx1MDAxZFx1MDAxM8KNwohPaMOpZFx1MDAxMijDncObKlxcXFzDilrDhUnDoMO8c8KgUDPDrMKWU2pcXHbDrFx1MDAwMVx1MDAwNVLDj8OZw50zP2HDpCbDtMKOdkc4wrXDoFx1MDAwNsKowo1rfcOJMcOyw6fDicOmXFxcIsKbw5gnXFxcIsKlXHUwMDBmXHUwMDAzw5dcdTAwMGXCqMK6wpVcdTAwMTlcdTAwMWHDn8KhPUpcdTAwMDFKwqFMXHUwMDE4w6fCoWhAwrXCicOWwrUgwq5cdTAwMWEqXHUwMDE4fj1KUS0sVcKHwqhcdTAwMTHCkcO9clxcYikhXHUwMDE3XFx0w67DtVx1MDAxZcKgXHUwMDEzw55cdTAwMWVaw6DCnjAjw61cXFxcXHUwMDE4w7BIbVx1MDAwNcKIwrXCocODw5XCksKEJ29cdTAwMDRRMVhcXHZcXHbCk8K0K8ODTsO2IcObeMK0w4djwrViXHUwMDFla1vCsD/DpUbCqcOEw7DCisKuw7VcXHbDtFx1MDAxNz1KMyNcdTAwMTlcdTAwMTXChWTDlcOHw57Cr8KpLkPCmmLCviHCoXzChFx1MDAxOFx1MDAxM8O7w79cdTAwMTDDklPCnkFLSFx1MDAxNzzDnMKGKcOkw6s/Zlx1MDAxZirCtsOCJsOjw58tXHUwMDE5XHUwMDE5QltcdTAwMTDDosKBRD9cdTAwMTFPXHUwMDFlZMK3w5JYw7rCq0JLXFx0cjLCi1xcdFdrwptWw6nCmsOpZFx1MDAxZUXCgMOnwqhFw5RnZXM+wo7CqE3DpcOfXHUwMDAxworDr2DCpHTDgMKJw4VcdTAwMDfCv2Y+XHUwMDE3O8Kbw5fDllx1MDAwM0LDusOQwo5oM8Kywq9Kw77Dl8OZXFxcXMKKw57Ci07DocKkw61SwoY0w5fDjcK0XHUwMDAzwrpZw7prJyvCt8KLMcKqUibCo8K9wpjChsOFwonCt8Ktw7LDni3CssK+w7jCuMK+wrJcdTAwMTEsNMO6XHUwMDA3ScOvfW3CrsO8wqQ6wqlgZ8KfdyfChsKZXHUwMDFmUF50w5TCnFJjXHUwMDA3OVxcdMODw6fCpMOLPUAxwojDuMOtNMKew7jDmcOjw4TChkZcdTAwMDF0Y1x1MDAxY0nDv1x1MDAxMcOSKsOow4tVZm7ClFx1MDAwN1xcXCI7WlxcYsOMw4HDtcKMw68xP8OUw5bCsMKOwqfDgybCp1x1MDAwN1x1MDAxYlx1MDAwNDQ+XFx2SW3Cg1x1MDAxYz1Nw57Ck8KAw6dLw6VcXFxcw6PCg8O0XHUwMDFiak3Cj8OqR07CjDsuwoDDrEF2woFcdTAwMWFxw5nDtcOZwrbCoj7Dp8KvPU3CosKHwpxfw7M5w7JRJm1cdTAwMDHDjsKKR8Olw5TCtkvCncOpXHUwMDFkTC/CosKRf8Kuwq17LlfDkcKtwo/Dqlx1MDAwMWDCqcOxNcO1w4oowoXCqS3CpcKkw7VcdTAwMWTDvcKWZz19ZMKZfcOow5LCiMKYXHUwMDEywoJzXHUwMDE1XHUwMDFiw6TCq1g9QFx1MDAxMMK9JcKRwqxJw5TCncOwXHUwMDFmwo/ClVsnw7nDs8KQXFx2wqwsVG46w74xP8K3XHUwMDEzXlx1MDAwNMKIw61rXHUwMDA1XHUwMDE4K8OhSSHCjsOlJzZPw6FJTVHChjNaw7pcdTAwMTIvwo1SNsO7w4ZcdTAwMTjCnDbDmFx1MDAwMsOXb2/DkkbCmjzDjFx1MDAxNll5wrg9TcONw6fDrcKuwr1Tw6ZcdTAwMDPDuDUzwrZ1W1xcXFxbwpNUw7RvwpvCgStcdTAwMTnDmsO0wqtWwoxpLcOtYCPChMOXwqRYXHUwMDE0wotawpfDmSHDpcONw7dTWlpsw7TDrCDClFPDkcKNw6rCrVN8N1x1MDAxN8KWXHUwMDE3U8KQITtHwqApaEsyXFxcImnCrjh4w6jDhXjCmMOFw7k9QFx1MDAxOUXCpEFcdTAwMWRcdTAwMDRcdTAwMWTDscKNQcKxccOtw7/Dt2V6w59Ow4Q9fcOWXHUwMDE3KER1wpggwpotPX3DkcKswpHDvF58bcKVwpLCg310wocrcm0rXHUwMDBlXj/CqcOcw5fCksO/w71/woBgwodhw4gww7g5NFx1MDAxYsKAwrzCjHbDqsO1XHUwMDExUy1FeMOBVlLCkcOewrc/XHUwMDExw6bDpiZqYCrCimvCncKMbsKxwpQpTsOUXHUwMDE3w5p/woVDw4tNIMOUPUDCmsKVwoVLPsOBwrPCoMOsw4XDoy1lw6B+w4R/e8OcYVx1MDAxNGJcdTAwMDVYwr/Cj8OgV8KwwrrDkylwwoZDXFxcXFx1MDAxY1LCqsKUw5ZcdTAwMTbCjGDCkFx1MDAxNCdIw5hSXHUwMDA3NmlTwq3DmsK3wpzDmyZRP8KiXHUwMDBlw5zDi1h7wpXDmlx1MDAxOD1NXFx0fMOYwqFcXGbDtcKwcD/Dv8OlwqVyw6JcdTAwMDJNZcKww7BcdTAwMTPCv8Kqw7jDvMKgw4E3XFx2cTTCt8ODXHUwMDA2OMOcJcK4MnnCmifCqsOjwq5Rw5HCtcKWw5xjw75qw7zDulxcYlx1MDAwNUI9fVxcXCJcdTAwMDVSRMOLwqvDgXEjwofDp8K9IVx1MDAwNmbDqzFkw5pJXHUwMDE5w4NcdTAwMTBcdTAwMTVLNFx1MDAxYsKAw4fClMKywrDDlklIw6PDg1x1MDAxNElXXFx2wrM9TWNHVU3CjcKZwrdcdTAwMDdiw7lTw5nChjlcXGLCgkbDt8KyVXzCs8OiRU7CljQ7SMOrw6lcdTAwMWPDnMOLN0LCtsOrwpY9SnvDsMOww4VcdTAwMTFTw7zCkkzCvMK2P3NHw6pCS03DpjbDisKZw7tQe0/DvMK/w7vCv8OfXHUwMDExw6/Ck23CpFgmw47DjlxcXFzCjcKQM8OuQsK+w6vCtFx1MDAwMsOOXHUwMDA3wrbDgcOLwqjDgMKywprDtVx1MDAxOVx1MDAxNcKVw500wo5tXFx0XHUwMDE4woDDv1jCs8OKwo/CpMKUwpJIw4hpwqgtXHUwMDE3w5bDksO9w5RcdTAwMDEhJVxcXCIvR1xcYj1NwqvCiMKpXFxmwqDDl8Oxw7lJUcO9XHUwMDEyR8OSw4HCrMKmYcO4w57Cr1x1MDAxYsOKwrJVeVx1MDAwMcKHXFxcIsKwKlxcXCJaw5TCviTCuVx1MDAxMG7Cs8OvVMKGwpdcdTAwMWXCnMK5ZF5cdTAwMDPCrsOCwoBAw6VJw5DCim3DoXvDncOVXFxiUiDCucOrwpvDsGbCq1x1MDAwNj1Kw6hcdTAwMDTCnFHDn8K4wqtjwqpcdTAwMWE+U8KQw57CisK0wotfwox/LMOFMcOXw6zDp3JPUV7CvV/DnMKDwqc/ZzFCSE9cdTAwMWR7w4HCvktcXGJlw5vClMOkO8KCOEhww5dcXFwiw5TCmsOWXHUwMDFhYMO7woXCmMKQw5DDsMOMZMOdSnfCksKsw5BcdTAwMWRgw4nDpSo1fcK9XHUwMDFmwox1w6wlw7c9TVx1MDAxOWNwXHUwMDEywq3Cu8KnXHUwMDE5UcKzw5XDv0rDj8KwXHUwMDFjw7DDl8OMwr09fT1Kwq5LekbDi8ODSmdSXHUwMDAzw6Q7Q2pcXFwiw5pcdTAwMDHCvH7CuGXCr3w7w6BcXGYyw7NcXFwiwoTDuT1Nblx1MDAwMVx1MDAxNFZdYi/Dr1x1MDAxNMOnw7DCq8OoP0jCucKuIHDCsFxcXFxcXHTDkzZxXHUwMDAxwqlQwo/Dvlx1MDAxNVx1MDAwNzRqMmRhw5rCvsO4LXvCu8OmXFx0XHUwMDFmwqgjwqcqcMKVw6HDpcKLIG89SnVPw6HDn8KeXHUwMDA1wqhwXHUwMDFjwq7DrGvCtsOgbMOTTcOyw67CgFx1MDAxOWJjVMOBb8KEWGPDo18vw71EO8KiM2NwXHUwMDFkw6fDnsOAw4BcdTAwMTHCvSFIZWBcdTAwMGZqcMKnw7p/XHUwMDE3fi7DnGBcdTAwMTJsb8OSw5lJw5E+WcKmw6YhwprDkcO7P1x1MDAwZcOzwoPChnbDnlfCkcOhSsOFw758w6HCpm7DiMOPQ8KUVsOzJMO4w447cMKCckjDn8OPXHUwMDEyw4DCkVA8w7d0w6XCpsKwJy3DvW9cdTAwMWHDgzvDuMO+V0khd37DisKrYU/DksKIwpp5w5vCqm5zZ31FJE82U1x1MDAwNFxcdMOIw7xQbsKDXHUwMDEzw4w7KsOcw4XCn8KrX8K8w7LCoMKMXHUwMDE2YsKPw7XCjMKew5xERSpcdTAwMDfDq8K4XHUwMDEww4dULmYvS8K2w55+wpPCq1xcZlxcdsO6Klx1MDAxM8KVJljCmcOuwoPCiVx1MDAxZcOQwrpjwo89fcKzYcK2MD7DnCvCtMOPXFxmfFx1MDAxYsKawqHCs8O/woB4wpRiWlx1MDAwNMOyPX1CSW/DrmLCsVHCuyE0w6DDgEbDvsOAa8O1w4rCtMK7wqFRwo5BwpvDtcOhPX1OQVxcdn40f0dnTsORw6Y9QHfChFxcYi59TMKyV1fCmUZyw51gKsKKw77CrMOMXHUwMDFmwqTCjTDCuilcdTAwMTHDuS3DrXzDoH0lSyfCqCnDpmZcdTAwMDJcXFwiwqXDjcKGwpxcdTAwMDMhWCvCgcK3LsOWwqfCq03CosK5XFxiw6fDglx1MDAwN8KSw6tRw69cdTAwMWErI1x1MDAwZcKyXHUwMDExwp43w7DCpXVAw7tzMMO0woTDqU9kwoPDqW5wNcOVSFpTwr/DhEzCo8KqMcKQXHUwMDAyXFx0w4jDqcKIwqRcXFwiwq7CvSdcdTAwMTYjUW49TU3Dn8KmZcOfwqjDmSrCi3o1eDXDgifDmlxcYjjCnlx1MDAwM8K6w71+w4NcdTAwMTbDll41WsKxYsKKwoJ1w5TCgCDCkDPDtsOBw6g/ScKOwqdGw6DCqjLCi3nCp8OnwpQjNWnCjcKfwrFdTMK9UMKUXHUwMDFmw6fDnXdTwoHCqMOnXHUwMDAzwpRpw6rDtsKdw6nCvm1cdTAwMThcdTAwMWPDrGZcXFxcZsKPPU3Cm8KFXHUwMDA1w7TCmcKKXHUwMDEyOVE6w7DDrT1NwrnDtDfDuWBdLFBlJcOpZFx1MDAxZiVcdTAwMDHDmSbDgTZNc8KyXHUwMDA2w4fCvSd1wq7Dm8Olw4kyJzd3wqzDh1xcdlJcdTAwMTF7woZsw61cdTAwMTXCoHbChMKhXHUwMDE3bDd7bcOBw61BNcOxbsO3WcK4wpkqw7zCrmlbXFx0wrbCqcOgXHUwMDEyZnZcXHTDiVxcXCLClltcdTAwMWNawqwvw5jCg2FjPX1cdTAwMDQ+S8KGLMKzwqdZVcK5Rl/Dl8KWKcKSfcKIQMKIPMO7XHUwMDA0w4zDuEbDs8KIwpAxw4rDosKSflvCh0jDt8O6wpVcdTAwMTLDtcOjPUpxw6XCpF7Du8OQcFx1MDAxOVx1MDAxOcKHw5PCqiMuwqbDsVZ0wpIzwo1bK8OIwrvDusK6wq/Di8KwPUrClWZjXjhcdTAwMWZoXHUwMDAxwpI2RV4rwr5cdTAwMWU6w65cXFxcwpQ7J3/DlcKGw7pcdTAwMWXCs0HCj1x1MDAxZVvCjcO4M8OwT3cmK8OFclYsXHUwMDE0w71tYUViSyDDqWDDmsOTe8OCwqxAbcOXTVx1MDAxNsOIPX1Yw75YwprDiMOKKFbDpVx1MDAxMMKLwoohc8Khwos4wo3DpMKNXHUwMDFhw5/DrMOaS1x1MDAwMsK2wq47w5BcdTAwMDJ/w6jDgcOjw4RcdTAwMTEuIcKOKsOdw5DDpj1NwqXCicOEwpTCuMOHwpJFbT1NPFx1MDAwZWHCjcKLw4vDq8KBw5FRw45ywq/CrcOXworCmcKKw6lcXHZcdTAwMTQ9fSRBb8Ogw51cdTAwMTHChsK+XHUwMDE2ZjtyWMOxw5vDsMObOEZSwqRcdTAwMWHDocKMwr08XHUwMDFkw6A6woTDtDnCviHDjcOdPUo5XHUwMDAxLsKkw4V5XFxiVyp2b8OCXVxcdMOIf8KQwpFcdTAwMWLDuz1KXHUwMDAywpjCl8KKasK1w6TDo2Yhw6RKw63Dv8OlwrjDq8OacMOXScOpccKSwqzCnFPCt8OfPFx1MDAxOTBcdTAwMWJSw7hZYsKywopcdTAwMTcpwo1bw7YuZjAywr1iXHUwMDE2wqtcdTAwMTZcdTAwMDQpw6o9QHHCiCvDosKsXkjDv1x1MDAwM8KwwoLDvsKFXHUwMDEzw7bCkMKRN2VoT37DncOdXFxcXF4kwpJcdTAwMThORsKLw4rDlz1KKMOgOydcXGJcdTAwMDZcXFxcIcKQY0/DrV5Ow5XDh8K4YFx1MDAxY1x1MDAxN1x1MDAxNsOfw7h9IVx1MDAwZjhcdTAwMDRpXFx0wqotw7RxwptcXFxcw4PChUvCrcK3ScKfw5DDr8OwXHUwMDBmJ8Kpw6XCpsKcXFx2Z8KcXHUwMDEyXHUwMDExacKbwqjCl8KmWVHCtsOlUWZcXFwiXHUwMDFjw6NaXFxcXMO2fcOqY8K2OSPDsCfDrcO5wqdcdTAwMTfDpMK/XHUwMDBmYsKIXFxcIsO2wo9uSCVcdTAwMWHCicK5w4jCoy3DgUlnY8Kmw5vDkVx1MDAxMVx1MDAxZWDCqWsnw6bCuMO9XHUwMDFkZMOWw4jCiUjCosKmbcKkJsKOw5nDoSlNXFx0UzjDrsKGw5smXHUwMDFkw6/CsMOJw73Du1dcdTAwMTnDu2hcdTAwMWPDvcK8w5zCtj7DvsONwp3CuD1NwqllUznCpk7ChnVrLHc9fXLClytcdTAwMDFlwodGwqBadlx1MDAxOFx1MDAwZlx1MDAwZcO7KiFcdTAwMTRHWFxcXFzCscOVw7fCmnPDksOAwrB+wrrCtsK2wp9cdTAwMTBKMU7CozVpXcOmXFx2Llx1MDAwNsKMXHUwMDE5UcO0w7fCuMK+XHUwMDAzw7UrSHrChmpKP1x1MDAxM2zDiMKPKVTCo8KDw6DDtcK3cFnClDnDjEQzLcKTXHUwMDE0w5AzwqPChsOeXHUwMDBlw4zCrMOUb3VcdTAwMWHDosOuUMKAw7XCnCVbNcK1wr56XjVpw7VcdTAwMWVcXHTDnMK3Mlx1MDAxOVxcXFw2w59cdTAwMWXDusONwrzDlVx1MDAxMsOqwrRcdTAwMDXDgcOMwrAqw7PCo8K+w6lcXFxcKl5cXHRuS8K7UsKPN2vCvDHCo3PCncOfw5xvw4bCum7Du8K8YTBtPUpKw5stw6YudcOWwqPDh2tvXHUwMDBlwoY6XFxcXMODw6LDtFpcXFxcIFxcYsK5XHUwMDFhb8K7woB/w47Dh8OLX8OHI3fDtsOKXFxmSVx1MDAwMcOlwrwhTsOjdcOKb8KkwozDmsKQZTLChsK0R8OvXHUwMDA3XFxiLVx1MDAwNcKLwpDDm3HDo1x1MDAxNy5cdTAwMDU8bHB/w4rDkMKMQC85w7EhXHUwMDFlNcO+wp9cdTAwMDbCrMKHfUTCmVxcZmxcdTAwMTY4bsKHMcKSw5xHwoJ+LMKJwqvDh8Owwqt0wopzwotWXFxiw4vDmUDDjWs9TcOSK8O7XHUwMDBlwrZcdTAwMDViwrxcdTAwMDfDk1x1MDAwN0XClcOow5B6cUjCn3PCm1bCsjJVIcO5dMKMc3lSw6fCmms/w6jDj2pLw6gtwoXDvUtcdTAwMGbDtsORMsKuwr80TsOobMK3woF/RcOLQsO+wrzDhsOfPsKpw71UwqnCgMKnUsOsw4bCusOsM0xcdTAwMTTDlWfCm1rCucKCcUzCmcOzw5ZcXFxcZ27DisKGbMKna1x1MDAwMzhCw4o6wrRCw7FpXFx2w5PCnMKLVMKGMcODwrdcdTAwMTLDkEYvw5PCp8Ojw7g+XHUwMDE1M1x1MDAxN8OwUWPDvcK6N8KTw5Y2w7fCjUDCllx1MDAxYkbCkkPCvsO7esKbw6zDgsONNHPCvEVQfsKeXHUwMDFibFx1MDAxM8KtwrNbwqV5w5jDp8K1w7Yuw4M9SklTw6lkw5RqXHUwMDFkTFx1MDAxOMOLwqtFw4bCvH1XwpTCvSEgw6XCuMO0w6/DqMOPw69IwpV/XHUwMDEzf1x1MDAxMMKaZsKMXHUwMDFiwprCkkM/QlrCh8KYbsOgwo5cdTAwMTTDhFJew6zClzB7w4VcXFxcPU3CvlQxwo7Cl8Kbw57DjMOVXHUwMDE4XHUwMDBmwpvDmT1AbTbDvMO4L8K5XHUwMDE0XHUwMDEww5TDmHXDo0ZcdTAwMTRtUcO3XFxcXGbDpsKbVDJSacKxw7vDv8KYaDjCuW3ChDZqNsKeXFxiwoHDi8ONXFx0SsKRPsKjTHvDliTClFvDhcOWw4DDnSMwRV3CgWvDhMKGXHUwMDFlwpdEXHUwMDFhw6bCtlxcdsOlw45cXHY9TVx1MDAwNMKaw7cvbTLDtcKAcVx1MDAxOE4qw6dkMsOzXHUwMDE4wqc9QMKvwpXDgMO7QcOWeMOxXFx0ZMOTP1x1MDAxNcKgUEtcdTAwMTkqw6/Dl1x1MDAxME0hZcO5c8OXw4xpVcKzw5VcdTAwMGVvXHUwMDEwT8O3w4XDssK2w4t1WsOEwp3Ct2h1w6YpwqpYazLDicOnwpUqb8KMXHUwMDFhw6/CiHHCjMKNXHUwMDAyKMKvwphVLcOHamPDrcKuwoIrXFxmwoBMwo3DlcKhNcK5MGg+XHUwMDA1wrtcdTAwMDHCpMO5w5B2bFx1MDAwNsK1w6/CmiPDjcK5XHUwMDEww7fCv8KuKm/DrcKBw4DCkcKbwrHDvj1Kf8KjwrLDpMOnw7k5PU3DkFooalrDn8Klw5fDom3CusOWXHUwMDFmO8OZe1x1MDAxZsKFUDNcdTAwMTbCgW5Xw4JJwq/DgCd3RXrCumk/wpl8wqjDjWjDhVxcdlx1MDAxNsODJDZcdTAwMTnCkcKrwqNcdTAwMGbCh8O2wo7Dilx1MDAxNMOLwqxcdTAwMTHDiXPDqsOFRlx1MDAxZHnDnMKvXHUwMDE5S0jDp8KFXHUwMDFiOFxcYitcXFxcw4LDnk9Hw7vDlXDDlMKBN8OZworCtUfDk8KIw69cdTAwMDNww7jDvMOVYsK9aHE9SjHCrG9rXFxiXHUwMDBmw67Cq8O3O8KDw5HDg8OCT8OMaMOJbMKyScOmw5nCmMKrLkVfU8K3w4jDssKPLMKkN8KOw5/CjFx1MDAwN3NzwobDvFx1MDAxY0vCp8KwM1NrbsKOw7XCtsO9wp9VVcOMb8KDYMK4XHUwMDA1wrTDjHImVcOGWz84w7TDl1x1MDAxZVQ5NUBcdTAwMWRcdTAwMTM/w5lcdTAwMDTDvTDCsX1WwrXDq8KGw4BXNMOub8OWwrfCssKzwptbS8KwdsOzUsKtw7nDl8Oew4DChMKFVMK5w5FcdTAwMGU0wrJFwqbDnlx1MDAwNsOlwpdKclfCkcOJwo7Di0NTw6Zyw7h5wp9lUMKFVmhcdTAwMGXChHFmw5nCrXYwXFxcIlx1MDAxMmo9fVrDlVx1MDAxZVx1MDAxNcKew6LDmMOdXHUwMDE4L8KfRFx1MDAxMSzCqETDpsOZZ3HDkjrCtsOccFx1MDAwZivCmsOGIMOeeHt6wo1Kw7I7w55rw7dTKklOZsOAQMOlw6fDrlHCocKiwrNcdTAwMDbCs1BcXFwiXHUwMDFlU1PClTHCocKUw6dcXGLCmcOfbMKpwqrDmFPCr8OYWlx1MDAxNGJcXHTCjcKfLMK9XHUwMDE5wr40w6/CicKvOmnCtsKkw4wvwp7ClFxcZnbDoipiwp/CkMOSXHUwMDAzwpPCn2RcdTAwMTc4KV9cdTAwMWbDkcO9wpZhw6d+wq5cdTAwMTBxwoTCmmNST8OGXHUwMDFjwoAqw49cdTAwMTDDr1rCnMKtbD1KXFxcIlrDpsK7woTCsS7CvnLCnsK2wp8yw4TCsFx1MDAxZsOWZz1AL8KTwoQow7TCoMKVw482w4fClzfDpFDCuMKgw4A9TThLw592w5c0NFx1MDAxZsOkXFx0w7XCpFFcdTAwMDXCqzHDnsO7w5zDnm1VwqHDmz1KMmJCSsKiw4NcdTAwMTDChzrDt1owKnFDw5s1fmDCl8Kbw5/DicOxw6tcdTAwMWYxP8K2w4MnLlx1MDAxOTnDp8KMw5bDmVjCs8ORw7Mkw59cdTAwMDRCXFxcXMKnw5vDvsKjXFxcXCpcdTAwMDTCiMOZfn7CrsKIwqvCi1x1MDAxMTHDpsOsw5rCulx1MDAwNFx1MDAxMVx1MDAxOMObf0zDvsKWw63Dp8Khw7HDln7CqMKUa8O6w53CgMKjJ8KIWFx1MDAxNsK9T8KFw54tdsOBwosxbz1NesOjw5zCmjLCt1x1MDAwZcKtw7bDp8KRwr3CsFx1MDAxNj7CgSjDl8O4w4VoXHUwMDAxXHUwMDA1PUrCqUbCi3Epwo5cXGIlbsOVw4tXwoRcdTAwMDNlLsOTw57CoMK/wrDDk8OAwo1SRMOsIFxcZsOFLVx1MDAwNsOkXHUwMDA0PUDDj1dGw6LDmsOEw5F/UsKZw75cdTAwMTfCiFxcdMKMd3xcdTAwMTjCq8Ogw7Y9QMKwO1xcZsOyNcO3LnBQRcK4XHUwMDE5YMODwoxqw5PDnFTChH1qYcO+wrZcdTAwMTl4wrDCpcKUKlx1MDAxZcKTwoXClMOKwoxcdTAwMDTClXvChWtkw5fDsMKTw4czw59Rwp49SsOmw4/Ch8K6XFxiw5NcdTAwMTfCjMKjwqhyeT1NM8K4dMKLezXCgcOlTixcdTAwMWVYQMO2wo3Cj1x1MDAwNcKaXHUwMDFiIVfDgMKpTcK1eMKjwqglw4VPw6rDnsO1wpc+XFx2woJcdTAwMDPDvsKHLsOyXHUwMDFjwqHDn8OrWMOZXHUwMDExXHUwMDE2JEXDiz19b01MTSnDo8KJw78ow7w6w61cdTAwMGbDvUZcdTAwMDV7fl/DrMOhw6VCf8Ovwr55aXjCtMOxw6toSVx1MDAwNMOxVFx1MDAxZsKVScKoesOKw7TDsENew4TDn8K4XFxcIjLCgcOaO8KnbcKiw4/Cr2PCoW/DosKUXHUwMDBmw69cdTAwMDYlwqTDtVx1MDAwNVx1MDAxYVx1MDAxMl4+XFxmw7ZRw4xcdTAwMWTDvcKlw45cXFxcODomwoVcdTAwMTBRwrDDmFx1MDAwMcKoS8KZwpPClVxcYsO0Lk9cdTAwMDd9XHUwMDA0UsKDw43DrMO9woDCmV3CmMKcwrNsScK0LCfDsibCnsOMZiHDolx1MDAxZC9VXHUwMDA3N8OWwqFdXVx1MDAwNMKuVT7DucOUb2vClsO7w5tcdTAwMWHDgDdcdTAwMDPCh8Kow6rCoMKcXHUwMDA3wpzDsVx1MDAxY2HCg8KtSsOlwrxrw7gvwrHDp8OUXHUwMDE5XHUwMDAywp/CgE1EwptcdTAwMDHCicO5wrJswo3Cl2PDqi80Q8OLwqzDg8KBw7vChnXCj1DDqTp1OsKew4Vvw4XCp8OtwpfCpsOaZH3DiTrDksOWw7TCjcO+w7vDvlEyRcOWJG7CrWjDu8OicsOJSsKTXHUwMDFlwrPDsMOvJG7CrWjDq2lcdTAwMWYzXHUwMDFlwqXDgsKdXHUwMDE1aMOLZMKgw4nDusOmfMOBZ8OLwp0lVcKAXHUwMDFmwrPCgFx1MDAxZTPDmzzDumnCpcOBwrxawqVnw5cmXHUwMDEzwq9tKMKnRFx1MDAwNMOaXsOfc8OPwqfCmMKJwrbCpFx1MDAwMsKdwqjDp8O7Qn/CqcK6X3nCiG/Cs8ONw6rCpMO+XFx2w7o2wr/DuVJYwokkwpNOQ1PDhyjCq1x1MDAxZFvCqMOJXHUwMDBmYcKmantcdTAwMGXCjlx1MDAwNTRcdTAwMTPDh8OCw5kzW8OrwqLDtMOmwo3Dt8O0fSU9TcKHXHUwMDExIFx1MDAxMcOtVsKodsKEOH7CvGc6w7XCmMK0WTd3w5Frw7vDt8K/worCk1x1MDAwMlTCqSA1XFxcXHjDnsKwwpZwQlx1MDAxNCfCm0Vqw73Ci1x1MDAwM2TDucO6PMOwXHUwMDE1wqBcdTAwMDM3XHUwMDAyJ8Kew7XCpMO+woDCo3TChUYjwqzCsMKbw7wsXHUwMDAzw7g9QFxcYsKWwqdbw6RcdTAwMTnDrmXDr8Klw6FcdTAwMTnCrkY+cUldXHUwMDEwwp8jwrnDsS1cdTAwMDIkwoTDi8KSNVUqw4NwaWVcXGZxSsOsw6DCtsKqXHUwMDA1WU1swpfCrcKLw6PCqFx1MDAxM8K5w7xkwqBcdTAwMWXDuj1NXFxcXMK2RMKswqXDgsOEw63CrsOWXFxmwqdawpnCiFx1MDAwM8KWbcKXXHUwMDFha0HCgypcdTAwMDRcdTAwMDNcdTAwMWY0wrBdwrnDhjpcdTAwMWMhwrFcdTAwMDPDtcOkw6vCosObw6bDlX1lN1x1MDAxOcKWV8OfwrVcdTAwMTjDqD19w6HCtErConFcdTAwMWQjw4DClVx1MDAxZMKNXFxib33DtcK1XHUwMDAzw57Cl0Eww5bCssKQfMKTwqp/w4HDgMOfw4/DrMKodsKEw5HDsH/Dt8KVwovCsVx1MDAwZsOXXFxiwqR6w4dlw6N7XHUwMDFlLmV2wo1Jw5nDnHojXHUwMDA2w71cdTAwMTdkP1xcXCJcdTAwMDc4w5pRw6rCocOtwpBnw78/wpXDs8KKw5TDjMKnREXCnWh4RXrChcO3fsKaXHUwMDA0ScKsaHfDtcO+PMKmPlxcYsKYw4/DhVx1MDAxNMKdcsKuVsKsXHUwMDAzXHUwMDFlXHUwMDEwwqbCrsOYamPDvlx1MDAwNyTDolx1MDAxYUdcdTAwMDPCn2bCpcOSw5XDo1PDmHBRwrNyfmHCrMKiMXDCiVx1MDAwNcKMY8O9b2XDq0LDiyZ2YUrDtElcdTAwMTVgUMK9YsKtwqXCmFxcXFw9fX3DmEBfTcKVw54+wqLDvMKAT8OOf1Uxwo3CjMOlw73CssOXXHUwMDE3XHUwMDFjw4V3woLClS/ClcOTOMKyXHUwMDE5wrTDpsOAXHUwMDBmdMKMw6XCqsOlXHUwMDEwKFx1MDAwNMKuXHUwMDFmN0Z8fMKQXFx0XHUwMDA2XHUwMDE5ak1HKFx1MDAxZihcdTAwMDbDpmRqw7EmwoFZUMKOw5M/NcOJLsKew5/CrFx1MDAwZnLDjMO5X8KgaMKWwo/DnGbCmj19w4ZMXkLCnMOOwr7DlcKowq/DosOzeMKhw5smw6hcdTAwMWFDw6zClMKRwqY6Jy5PV1TCgC/DsMKfXHUwMDEzLVx1MDAxNlx1MDAwM8KOw5pHVXnDjsKvwq0+PUrCk3LCsHXCvC/CqDTCssKaXFxcXMKpw4rChMOSw5hIIMKcwrzCq8KAw4Vsw5bDlcKWwqhkw5xrw57Du1x1MDAxY2XCgsK4f8KZwoDCg8KWNz1Aw77DsMKGWEN0QCZ6wpDDtcOWXlbDt1x1MDAxYl9twpzCoVx1MDAxOGV4woNdUMK8OSfDi8KVcsKDwpZ9w5DCh1x1MDAxMCXDiEDDjWY2JXLDnH3CvVx1MDAwM8KFw5bCtMOrXHUwMDA1Zyskw5JcdTAwMTl1aFxcXFwmb8O5w5TCqDXDlMK2wpTDrsKAw6RBwqnDn0xcdTAwMTTChz9Hw57CmsKKwrwwbsOzwrg/Z1x1MDAwZVrCmsKCwoZ1w4jDpsK8QG45TyfDp8O2w40zw4xyXHUwMDAyPlx1MDAxYjZcdTAwMDTDh8K1Z33DtcKWwqxqWsK6wq3CsnZ7Z8OiwqLDg8O6w4zDp8OaXcKGw4hcXGJJwqDCoMOOJcOVw7/Cn8OSXFxiw5XDv8OFwpLCkcOQwp93w6NcdTAwMThvdlxcXFxcXFxcw6nDhcK/w7fDnVx1MDAxYVx1MDAxMThyPsK6wpHCsUAsw5BGKXJFQsO6w7HDu8K9d8K3wp8kasK2wrLCkEogXFxiO8Obw6pBwp7Cp1x1MDAxM1x1MDAxM1xcdlx1MDAwMcKjwo3CkkpcXHbCskLDvlJpXFxcInAgwrp5wpbChsOGwpZgXHUwMDFlQ03CpsKjw7/Dl0vCuMOcw65cdTAwMTRcdTAwMTPDnlx1MDAxYzPCuMKFwrbDkMORXHUwMDEywph3w6TCniPCncKJwpfCjknCvsKCwpc2S8KbSlx1MDAxM0N5OcOzwqtcXFwiwqzCkVx1MDAxYcOvJTnDlcOIa8Ksw7xdwovDpVxcdFx1MDAxOSo+w4PCm8Ofwrsyw4hswrPDp8KCKMKtw5Faw4DDjVkqJsOtWsO9woXDrCNAXHUwMDE4dD1Nw5ZcdTAwMWbCqMOfS8OlV8KDZ8Ohw4lcdTAwMWJBw63DpMKZbHg/PUpkw5xHwoTDnTLCncOJXHUwMDEyw5VcdTAwMTN7YcKyJsOdw4vCrMKMRcOBw7bCulx1MDAxMMKtY1x1MDAxNyZMQsOLwoPCucKkT8Ocwo5cdTAwMDI5w69cXGZPcMODPUDCuT1Aw6bCtsKTd8KWworDpcOtXHUwMDFlworDssKlRcOyXHUwMDAxw5/CscKyXcOjw4jDjMKEwol+NUDChMOSw7TDkWLDusKOwoNzQsKbw4bCmsO6w7jChGF+XHUwMDE4w7NcXGLDmsOjwqFZwoFZwo7DpFx1MDAxYsKBwodcdTAwMWXDjMOkw7vDvcO8wqFbwrdmw4/CiVx1MDAwNFx1MDAxMXPCqE/CmMKmW8OHw61ww419wqrDmy3CuMOxacO5wqIgw5B1w4nDrWYjZcOUXFx0w5JrQ1x1MDAxZMOtw6PCoXd8w4fCukXDvCBsXHUwMDEww4bDv8OmZFPDiVrDu8Kyw7DDkHRHwqhEXHUwMDExw4vDmcOTXHUwMDEywpfCjlx1MDAxNsKMwqk2w4TDhlxcZnEwwoYtXHUwMDEyMj19XHUwMDE4wpl6ak8kNn/Dgi/DnnRIw73ChMOMw7HCpVx1MDAwNFx1MDAwNcKRw6VDP8OJw47DrVx1MDAxNV0qwqzDulx1MDAwZT5WesOEw4FYRVxcXFzCuFx1MDAwZcODw5nCsF/Cu8KdQ8ORw7VdwonDmcO5wpfCl2ZcdTAwMWTDlyTChlx1MDAxNMOJXHUwMDFjw7ZcXHRRPUBSwpAzwp1uPUpjTmx7ZFx1MDAxN1x1MDAxZE0hRsO7XHUwMDFiW8Kaw6zDizNcdTAwMGY9QMObTXFcdTAwMTjCv8O8J8KCw7PDp1x1MDAxY8O2w7lvwo5cXFwiemPDhVjDhlx1MDAxZcKvwqXDo8O8c8KBaH7CicK7w4nCulxcYiHCh8OpXHUwMDE5wognwrFcdTAwMTh0JTZcdTAwMDXCkMObw4zDszZVw6t1w45gw4tGXHUwMDFkXHUwMDA2cHNcdTAwMWbCuMOjwo18dcO+XFx0w5FcXFxccDBwJ0ExcktcdTAwMDXDhcKyw4U4wqVOL8ODw6/Di1x1MDAxY8ODwpDClm/Dr8Ovw43CmMK3wqxZwqDCrkbCksK7wrNow6QuJcOAwqDCl8KCXHUwMDE1wo7Cij1Kwq7CuCrCrcOOM8OTVEJcdTAwMTnDkD1AXlLCmMO2wrJrwpl+w6nDpCvDkTnCs8KJwqBcdTAwMDY6wps9QH7CtHjDoTUxw45Dwr7ClsOcX17DvmpcdTAwMGXCk3hcdTAwMWbDtCXDh8OeXHUwMDE5w67Cm2fCqMKuwpxII8OMwrfDgkFcdTAwMWZcdTAwMDXCukzDlXzDpHLDlMObe0bCiVl9w69cXGZcdTAwMTbDkcOzLmdQw4jCpmtkwrcpcMO6wr0hw6diw5TCulx1MDAxMFxcdkHCnVx1MDAxN8KyYcKiw7d1woR+f8Kcw6Yrw6rCsVx1MDAxZTDDpsK6XHUwMDFmMFx1MDAxZcKow5VcXHTDuiVcdTAwMTZyw53CocOMV0NEPUrDtcKMLsKzw7FcXHTCvsOew4zDs8OVWEPDv8O3woV8wrhRwp1nS1x1MDAwNcOcXFxiwoUzXHUwMDE4w7xiQlx1MDAwZSbCoMOmXHUwMDFlXHUwMDFhwqDDl8KUMMKnK39MXcOMWU/ChsOhwr7Cm2JuwqZcXGZ5w7ktXHUwMDEwIMKFw4lpwrnCl0nDhcK8w7fCisKswqdcdTAwMTLDinHCgmZXXHUwMDE2XHUwMDAzPU0lXHUwMDFjwrFIwo1cdTAwMWZjw4d5RlxcdMOhXHUwMDE3w4vDscOewodHVylcdTAwMTB1R3BVw7xPwpTCkcKQwpNjwoDCssKiw5LCn1x1MDAxMlxcYsOlMsOHI8Ofwq92wpAvwqU4wrRcdTAwMTV6w7zDm8KgXHUwMDA0w5rCosOewovDgMOPw5RuSlx1MDAxNnHChm/DlErDk8Kra1x1MDAxY3zCjsOhwozDhTBcdTAwMTTDtMKgPMORSsKow6TCg2jDkWRvwr9ZVFx1MDAxZMKAwqPCh8Kjw4dcdTAwMGVCb1xcYkLDgG7Dp1TDu13Cv1x1MDAwMcKbXHUwMDBmw4I9SsKud8KBOFHCsV5Aw7JKSlhcdTAwMWFcXFxcw7bCjMO3JcKswoXDsXtcdTAwMDTDtzzDssKqXFxiwpN7wrnDs8KcTVN4w5hWw5PDpDRcdTAwMDXDg8OfwpLDi3g5wpA0WGTCtMOjwpvChMOfw55cdTAwMTdLXHUwMDEyw7ogX0jCpDbCjV07XHUwMDA3Yi7DinbCtsKBwoEvwrw3w4JcXHbCtMO/w4PDt8ORTHlcdTAwMTHDt8OJwqhkw4lsw57Cl8K0w47CocOlw6BMPX0lREnDvMOJwrlcdTAwMDbCiXbDojPDpVxcdllkXHUwMDFmOH7Cl8KSasOZwrXDh1x1MDAxZS/CmVx1MDAwZlx1MDAxZMKDLsKYwpxcdTAwMGY3w6jDn1PDrjPCvCXDlyBcdTAwMWJcdTAwMTjDqcK/JsOVwoEvX8KKIDvCkSHCu0HDpsKCW8OFKcKsWcOYwonDvsKlw6vDhVx1MDAwNMKCwqImUMKTw7VVXHUwMDE1w549QG83XHUwMDFmw7vDvTzDij7Ch8OLw4Jyw5/Cuic9TVx1MDAxNEjDp8OUaVx1MDAwNcOIP1x1MDAwM1x1MDAxNcOpw53CrMKDQntMwqHCl8K2XHUwMDA1w7HCp1x1MDAxOcKDJSXCp1x1MDAxMsKrwqcjcVx1MDAxNDjDmHN4wofCpmjCqmDCpGdtYlxcZsOSTkPDliHDlXfDosKORMOxX1xcdMKSw6lcdTAwMDVcdTAwMDFcdTAwMDEvwqDDpMK/wohcdTAwMDRcXHbCs8Orw7rCkGXCpMKFXHUwMDA0w75Fwqxew5A3XijCi1/CvmXCtMKxwo1cdTAwMTnDnlx1MDAxMsKzeUlcXHRhf3/CmFx1MDAxY8KuNMO4SMOlfjNFXHUwMDA0wpJhw7YowojCmsO7w7LDicO4w7FZXHUwMDFjNlx1MDAwNMOlwqLCjz1Kw5FcdTAwMTLCv8KEw5XDrcKlwqNcdTAwMDY5PU11T8O/eFxcYsOowpI4XFxcInHDm1x1MDAwMcK6wqXCuUzCs8KNw6PDmsKdw43Cv8KEwpLDpCfDh8K8XHUwMDBmw4/Ck8OBUGtcXGLDocOLb0TCj8OTwr/DhMOKw6FWwrjCuCsrwoBNw77DvC5VXFxcIsKHwoR5wq51w63CgEfClzhcXGZWNFfCizLDpFBBU8OSJ8KBwrlHwrvCgMOUXHUwMDFiw6tIacKyNW3DjGF+YnEjXFx2w6luXHUwMDE2YTsrwpRTwrbDunZBwoLCklfCl8KcKVN9wqXDkVx1MDAwM8KBN0J8TsKjw4bClGBww7pWXFxcXC/CojFoLFxcdFE3PsOSwo7Doj1AQ1x1MDAwZsOIXHUwMDFmwql7dEBswrl3wqTDribDtcKuWMK5wrx7R1xcXFw7U1x1MDAxNEJecFxcdFx1MDAxYsOTUsKRw6QnfcObNcK3XHUwMDFmecO/XHUwMDA2PU3Cm8K0eMOobcKVUMKcw7vCqn/DmznCuMOdwpFkwrXCscKSw5/DrsKhT3bCusKlw7/Cg3DCn8OQNi7CnMOKN8KjwpZ/w57DicOQScOyNcKPRsKJXHUwMDEww6/DnMOBwpB5wp1cdTAwMWLDtTXDtnzDn8KNw55cdTAwMGbCoMKQwrPChVjCg8KzTU5bwrDCgi/CjsKqXHUwMDA1aVx1MDAxOF7DsMKawrzDu8OAwrxPwoTChyZcdTAwMDXDojPDs8OSTlx1MDAxOMOOXHUwMDFhwr3DvEQtw67DgcKhPUDDlcKnwoJcdTAwMGXCt3PDpj1AZ8OvXHUwMDBlwo7DlcOPw5/ChljDmmLCiGTCqMKHWMO2w6JcdTAwMWLCn8OPXHUwMDE4w6PDicOzw4DCucOpwrHCo3dgSlx1MDAxNlx1MDAxNcKHdFx1MDAwZsK+w47CvMOvasOQw53CoMOgMWFpw4/Cl0UzeCXCksKjK8KMwp3DiiphwpvCtsKjd8OOwpDCnmxcdTAwMTfDqMOVw7FDw6PCpMOyXHUwMDFjLUw2XHUwMDFjLVx1MDAxZFx1MDAxY1x1MDAxZiE+wpY9TWbDs8KKw6jDpnbCqljDnDdcdTAwMTXCk8Ofw6JcdTAwMDYzUXdcdTAwMWPCpcKgw7JcdTAwMTbDh1IowpXDgWXDo8Kdwp5cdTAwMWbCm8KNwpzCqsOQYMK4wrVEwqZcXGJcdTAwMDbDhsKsw6ZcdTAwMGbDrVx1MDAwMsOoNcK7QEvDtX9lUFHDm8OuRmzDi8Ofwq1bw5fDgsKbw59UJnF/w4wgwolcdTAwMWPDs8KKwqTClT7Ch2XCp1x1MDAxNMO9b21Zw7nDqHt/wqvCpUjDvcKxXHUwMDA3dFx1MDAxYcKQecOJWcKiwobCp8OhfnDCnjp/w67CrsKDXHUwMDFmNMOdXHUwMDE2w67DlcKSYFx1MDAxNHfDlFBcdTAwMTLCqi7DkE9jw4ghXHUwMDA0fcK9w6XCqMOpwp5fwqJmw5tcdTAwMWLDq3I9TVxcZkvCkcOlfsOUesK/w7PCqDh2Y8KUw5DDv1x1MDAxYnnCpC3Co2/CgsKgw57DhcKNXFxiLyXDosKCYcOKw4Y9SsKvXHUwMDE0XHUwMDE4wrlcXFxcw63Dp1xcZlx1MDAwZcKjdcKmdnh1wpM1PUrDuUM5Zyt2wpfDqlx1MDAxN8Oyw79rdWUnw7nDtMOcRjnCpcO3w5ZgKD1NwrlnesOgwrPDrsKxwphhwq1+ZsOVw4zDr8OUwq1cdTAwMTTDrcO+wqJUdkHDvEPCr19cdTAwMWXDtVx1MDAxM1x1MDAxOXzCt8OLXHUwMDE0w5p4OsOEUHfCsMKUKcK+w6dww43CtcOhXHUwMDE0XHUwMDE1ZcKcw4bCjcOBwrnCgcO2w4JvZXHCiMOeXHUwMDFjNsKJYsKGZMKuXHUwMDAzXcO/JcO9QFx1MDAwNMOXwqtcdTAwMDfDvMK2RnM+L8KYXFxcIjbDm8OQwqRBwo3CnFxcXFzDsiPCjMK1w45cdTAwMTJgwovCuUQ9QMOrwr1rY8OQU3TCuMOcw4DDh8O0acOMTcKRwrpcdTAwMDNbw7dcdTAwMTPDgsKkwr9tw4XCm2rCpylcXHQnw43DkMOqwo3CtMKhYlx1MDAxND19OsOBXHUwMDBlbmI0ZsKRwoLCpMKTY3syNFvCvk4pXHUwMDEzXcOxw5NcdTAwMWTCosKAw7FAwojDi8KzRVhxw5XCg2/CnMO3wpt1YcO2VMOEecOowqVIZcKgXFxcIsK+wpTCkks8worCrnswwonDpMO0XHUwMDE5QMO4wrnCuFx1MDAxM8K9XFxmwpFcdTAwMTjCknNcdTAwMWMnwokjwqdcdTAwMDbCjnMqw6Ehe8OJwqrDhk0lZj1NwoPDi1F2wqrDk8KSeFx1MDAxYSlowp0sw6LDjMKifMOxWMOEwqvDuFx1MDAxNMOMwpNcdTAwMTBpeMO9cMO7Um/Ch17Cq8OlwrVcdTAwMWN3XFxcImPDjFx1MDAxOCx/dXdgw4/Cr8K/wqtTci1QL8KTwqzDrMOURsOdwozCksKcbkXCr8KMcVxcYsKzw5bCo1x1MDAxY3XDrsOLa8KYasKSwqfDnjFfwp/Cilx1MDAxOcOBXHUwMDAxYcOQwoJcdTAwMTXCisOew4tcdTAwMTPCgGrDgsO8XHUwMDE5w613wrrCp8KAXT1Nw7rCoVx1MDAwMsOMO0w/eC9yXHUwMDEydFxcXCJcdTAwMTNQXHUwMDFmwpTDt2hRwrleQcOQJMOmRDwgXHUwMDBmb1fCtmVcdTAwMWXCtlxcXCLCs1x1MDAxZcOhXHUwMDA2PF3Cg8OOLk9KwqHCmsO3w5lbfMKjw5zDjcKnd1x1MDAwN8KZPUrDl3zCh3/CsH99KFx1MDAwM1x1MDAxZMOMwodoecK3w5w4w5pcXHbDm8K5wrFcdTAwMGXCnnjCvC/CrkFGwoDCgk/CujHDmFx1MDAxYsOyTMKFwq/DgU1cdTAwMDXDjVrCnVAvw7DDjlxcXFxOXFx0fMO/bGNXbUzDq1x1MDAxYVx1MDAxYsKdcyrDksKTwpxtd0JYXHUwMDA0wpTCi8O5wpjDnsK4RGQ7w6l6wqUywrgrw4s9QFxcdFLDklXDksKewqTDjMOzPX1OwqLDssOzXHUwMDBlLFfDoT5Xw4dcXGLCoyPCpcOGw5hHXHUwMDEzw4p/XHUwMDExWT1Aw6TDn8O8wp9MR8K0YijDvMKBXHUwMDAxdFFcdTAwMDJ7fFx1MDAwNsOZaTRNwoRNXHUwMDAzwoJOw51Ew7YrJkF5YEjDs8KSSSM9QMOYw4PCllxcXFzCvMKLw4Rtw63Dn8Kgw5xWwrxcXHbDrsK2wpE9QFx1MDAwNMOzw5BNXHUwMDAzJVx1MDAxZVx1MDAxMcK8w5/CvcO3bsOcw4nDvEnDqmM9QHRgRcOzXHUwMDE4w55cdTAwMTfCp1x1MDAxN8KOwp3Cu1x1MDAxNjgnK8ODwpPDl8KOw4VNXHUwMDAzwrlcdTAwMTM5e8ODwpVPPX3Dv05TXFxiw5hpwqVcdTAwMDF4w6BXwrzDp3/CqcOYwodlQyDCpsOPwqLCvSgqwo3DnsKAw5xMwrxHw57ClH3CncK5wr3Dr8Kmw4HCvMKbwptcXFwiw4w8QsOzw7rCoFxcdsK7w5MzM8KrbcKswqw+XHUwMDE1dsOyw7BINlnDnV5ebMK1w5tcdTAwMTDDusKaR8OoXHUwMDEyw7LCmj/DqFxcXCLDqsKaP8OoXFxcIsOiwpo/w6hcXFwiw5rCmj/DqFxcXCLDmsKaP8OoXFxcIsOawqI9TXVFQMKQwrnCpFx1MDAxYsKLwptcdTAwMTd1RUDCpcKJXHUwMDA0w5rCqsKvXHUwMDE4w482wrVnwpPCgibDtcKgQGXCgsKwX1PCk8OJw5zDpMO1wq7CmsK6wpHCpC9cdTAwMWNcdTAwMTRcdTAwMWXCi27DrcKMTsK6wr5XVMO+J8KywqfCkcOpMcKrXHUwMDA0wqE+XHUwMDE5cj1AN1x1MDAxZkpxIcOew6NcdTAwMTl8cVxcXFwjeMKEwovDkMOoPU0uXHUwMDAyTlx1MDAwMXLDusKzLj1NwpVQXHUwMDEycMKswpbDty7CjcK7worCkMO3Lj1NwrvCisKYw7cuwr3Cu8KKw7XDhDPDtlx1MDAwNFlcdTAwMWEww5PDjnLDusK3LsOiKlXCqy/CpMKCwoswVMK6w7dMw4dcdTAwMWPCrFx1MDAwZUrCqMOQJsOEwrs9SnE9QHZqNsOVZVxcZsOEM2TCu8KKXHUwMDE5w4QzLibDisO4w6HCkMKsw5tyw5rCkcO3Lj1NwrvCilx1MDAwMcOEM1BNw6vCuF89fcOOwpTDpVx1MDAwZcKsaEfDv2BcdTAwMDLDkcKLZsOOeSVcdTAwMTnChMKnRFxcdGBcdTAwMGXDtcOqXHUwMDE2wpfDszNAX8KvK3TDtzlKQVx1MDAwN3TCvlpcdTAwMTJ1w6rCtcKFTcKVw6PCs1x1MDAxN8K2L1fDjU/CtE7CkcO/fVx1MDAxM0PDssOMwqTDicKVX8OwT8OKw4PCpz/Dq8O2dCdcdTAwMTdLw4HCn0Y5w7M+wrJaw509fcOWwpPCpcK5wpteQcO4woDDsFx1MDAxMsKQw4IzIWNcdTAwMGXDnTPCpTFcdTAwMDLCkcKHwrs+wpbDr1x1MDAxMcK1wrtcdTAwMTZAJcKAwrnCvlx1MDAxNTLDr8OSfsOjW0zDjTDCm1x1MDAxMm5cXGIvdjjDvsKqXFx2XHUwMDFjwrnDsH3CujQtwrx5wrxAwr04w47CksOnwp3Cm3FlwojDm8KWw4F5w79cdTAwMTHCkFx1MDAwN1gpw45oXHUwMDE5w4pfwo/CpcObQmMgw5nClT45aGFcdTAwMTBcdTAwMWRcdTAwMWVww7jDscKnXFxiwqnDuU7DnMKhw4VCwqtfw5DDjFx1MDAxZFx1MDAxMcOpwqnDqMOfw5RcdTAwMDfCrnvDrj5MwpXDnFx1MDAwNcK3V3FcdTAwMDRcdTAwMDbCgmc7w4nDncOdwpPCmV8gLmXDhW7DnsKwVcKpXHUwMDA3wqDDnsODRkAsdU3DiMOKw7QnLsKMw5rDicOqwrfCq8OARcOhw7tvwp/Dh1x1MDAwN8O8JcOtd8O3wpdcdTAwMTJcXHTDhitcdTAwMTjCm1x1MDAwZsOxQcOOaF3Cm1x1MDAxODlcdTAwMTNQQcOROT19ISbCmyrCh8OewpHClSrCtlx1MDAwNMKGXHUwMDAyPHLCsFx1MDAxOD19XHUwMDFiwqoow4hcXFxcNsOsKiVCw4hcdTAwMTPDqMOWUsOKwp7Cn2RIe2PDjsKUXHUwMDE2OsKUwrM8wrc1SVx1MDAxZC9cdTAwMDJhZXHCtcO3XFxibVx1MDAxNsOqw6PDucKPKMOlJjpAYlTCoMOSJsOVKFxcdilcdTAwMTNJKMO5wp5Sw5HCvVUvXHUwMDAyXHUwMDA2U8OZZ8Kuw51jelx1MDAxZXxkwp7DtMOnw6xZw6DCscOdXHUwMDAyw4c3XHUwMDBmw5XDqDnDki5cdTAwMDbCncKewqJFXHUwMDE5aGjCl1x1MDAwN8KNf3xcdTAwMTY3woB3wrhcdTAwMDLDsVvDmzDDnTHCjFx1MDAwN2R2USE9QMKNVlxcZl7DvVx1MDAxNMOcwohbwqrDk8KpwoJ9wrwqXHUwMDE1dmHDlMK6PX1cdTAwMWZCwqA1w7PDq3/CuXjDrsOWw5pcXGLCtTU+N3FjflrDhiHDk8KCw7XDonDDvVx1MDAwNsK5cMKIU8OVOMOQSsO7RFx1MDAxMnfDuH7Dm3E5RXYuw4PCtMOpw57DkcOqwqFTRMOcL8KXXHUwMDBlTDtQPX3DhznChVx1MDAwM3JcdTAwMDVcdTAwMDXDuFJcdTAwMDFSVz1AJlx1MDAwM8K1w4LDji/Dg2lcdTAwMDFkw67DrcOgPMKDcGnCvzwxXHUwMDE2bGQ1w68rw5RMwpNSw7fCosKLw67Clzxmw6LCisKCwprCvVxcYsOIw7fDrVx1MDAxYSjDr8KGXFxiwpXClMOZXHUwMDFhKCbDvsKeI8KpKcOTwr/Dp1x1MDAwNF1xw6rDjsKmwpRcdTAwMDRcdTAwMWHCqMOEwrxCV8K4Ul7Cg8OzwoIjM1x1MDAxNkbCjVx1MDAwZlEjw7UqZVrDmVx1MDAwN8OGZknDhsKnwoLDksOpw4JFTsO4w7srw7DDvVpicTQwV8O5XHUwMDBmVMK6w6hPwrtRfsOuwr3CuVZOUkxhTWHDqMOmwrNOwolcXGLCnsO9JsKLw7bCvTVFfSbCvTbCksK2RDHCq1x1MDAwN05qw4JiccKZw4LCuMOFwpzCnMK/O8OlwpnCrMK7wpHDiTddwp9cdTAwMWXDvcORXHUwMDFhwpjCnCthwoTCmULDn8KSwqw9Sn08w5dcXFwiwqdcXFxcWXHDlMKDwpBFwoV8ZsOQbVPDrsKlworCp8OcwqlcdTAwMTJBXHUwMDAzwpnDpMO4w4rDpMOqwqFcXFxcwqXCncKCwq1pw6DCqsOsMsKFwr3DusKUw4RcdTAwMDLDhMKuwrB+woXDgy7DrcOXw7dWw4kywqPDoMOowoBnQcK/asKEw4XChsKIw6/CqMKuwr9zwqhlw5/CvzNCT2bCjk/CisKxXHUwMDFlPX3DiUJsLFxcdMK9W8Opw7RcdTAwMTTDusOhWDtVw7k6ZMOwwpXDrMOkXsOMbMOzXFxiwovDpcK8QMKtwqbDrj1AT8OYL33CtMOWdVtcdTAwMTXDuy/DoMOFwpZPw7/DtMOSw6TDi1bCi8K+w5wkwo9bM1x1MDAwNcOCV8OnNmjCl1x1MDAxNMKXw73Chlx1MDAxMcOye1vCiMKDwqlAMHbCr0PCr1x1MDAwM3w7w7PClCfDgsK/ZzUyw6R+wq1cdTAwMDXDisKHwpzDkV4nwqYjdcKHMcK6w7XDuDw9TcOFXHUwMDBlw4FhSMOIWMOBWGPClsO4X1x1MDAxNVnDgl9Owo4kJ0V9bMOMOsOORUfDuMOhXHUwMDAzXHUwMDA1wqfDhybCo8O/XHUwMDFiWcKZZsOHXXVcdTAwMWElUcOjwr5Ew4Fhw4jDtMODw5dcXFwiJ8ONw4ZcdTAwMTPCtFxcdMKdIyxKwpBgw5ZPXHUwMDFlXHUwMDA2w7TCj8KywpnDgsOWd8OQwr1LwpBOOcO/w6LDpcOrPUBpXFx0XFxielx1MDAwNzhFwrLCmcO5XHUwMDFlwpnDuX7DocOtw7RcXHZcdTAwMDV2YsO/wpdcdTAwMTPDtcKmZVx1MDAxNVxcdD1Aw5bCvsKYwqXDmMKsbsOhJsO3wrHDqFx1MDAxY8OpesOHwqdcdTAwMTV1wqnCqMKww5LDnsOXXHUwMDBmcMO2XHUwMDFlXHUwMDE0Pis1w5TDkcKQJXnDtyRTd8OZw4xDOcO4woDCnlxcXFxMwpTDnMKyw73DocKPY8Oqw6RJw63Dl8KLw5XCkk9VQMKvODpVXHUwMDE2PUoqwrhrPU17wrLDhlx1MDAxYTVcdTAwMDQ9SnPDjmrDgj1KQsKTbGczwr7Dh8Kmw4R4wq1vwq/Cj8OXe8K5w5rCr8KXw5bDpz7CmMK0wptYWlx1MDAwZisqd0XDjMKSZSpcdTAwMDLDgsO3w7B6NcOMXHUwMDFlcEXCr8OAdVXCiMK7ccOZK3o9TVInwo/CncKUJS96w4BgfsODPU0sw7LCsMKCw4pcdTAwMTTClsOJwq/Dk8OywpDChcKcPMKFwp1cXGZvXFxcIlx1MDAwM3bCoT1KwpHCuFxcYsOqw7lWwqZ6JsO2KsOjw7fDucOeQFxcXFwuc8KkMMO2NMKFQkUmwoZMw5ZhXHUwMDFiwrDDjWY/XHUwMDA3wqxcdTAwMTPCjcOYw480w6HDgWfCncOQw7HCti0twrBcdTAwMTHDs8OrXHUwMDE4WkHDtsKcw5zDsVx1MDAxOcOPw7nDkGhbw6jDlHnCksKgWkrCpzzCgWHDkcOoSsKDXHUwMDAzIWBcdTAwMWZcdTAwMTnCl8OUXHUwMDE2IMOTJULCoMOMXFx0wqdORsKlw6x6XFx0M8KnwpPDv8Khw57Dq8O0w5FXwokjXHUwMDFjwp4nclhxwqvDjWx3w5nDnEXCt8KlQVx1MDAxOXnCpC7DmMKkXHUwMDA3woXCgcOhZMKxw4jDgC42wrlmZMKDwrh7Z8Kzb8KIw6DCoMKQw7c0wqjDuMKuw5/ClsKKUD19XHUwMDE1wojDv8KdJVx1MDAxOcKzZ1LCoytcdTAwMDfDvyHCl8KKw6DDnzZ3wpdcdTAwMDRcdTAwMTh3w5bCt1x1MDAxMMOjwprDnMKCJDtXM8OEw5BcdTAwMGVfw5dJPUAvwqPDvMOVw7VENMOww5XCr3ZcdTAwMTgjw453w6jCoFx1MDAxZFx1MDAxYsOew5PCo8KkXHUwMDFjwrLDmMKzScK2w7zCk8OWwqorwpVqXHUwMDExdMKuXHUwMDFhIVhaTV1KXHUwMDE0wrnCiMKywrcvw5hmM3xqwo9jwqkowpHDgsKSI8K+woRgwr9twrZqTFx1MDAwNFx1MDAxY8Oww44hXHUwMDBlw7QnesKLZGrCi8OAw53CrMOEIHtnR3HDgcKmPU1cdTAwMTVFOcOswpHDicKZw6fDpMOjw55aXHUwMDEyZEzCtsOkXHUwMDFhw7hcdTAwMWN6Nlx1MDAxY1x1MDAwZsK4azDCjW7DiMKPwqZaw77DucOMXHUwMDAzOSDCqXDDu8OBYcKycnPCrVx1MDAxYcK1w6PCrUjCtlx1MDAxMzTCuVs4d8KAIMKpwqbDpMKcOXd9w53Dr1bDrlF+XHUwMDEwXHUwMDFkw5RcdTAwMTPDnsOLwoFcdTAwMTLDqWtcdTAwMWXCk2bCo1xcYsOAPUo0wrLDiSpJwrcuwqJxwqdPw7dcdTAwMTjDhzvCncOcwrTCl0TDq0zDksO5wr1cdTAwMTF1Y1BcdTAwMTLDlMOMw5vDpVx1MDAxYsOoXHUwMDAxwo3Dg8OuXHUwMDE4w53DncKbw5HCr8O1OsOmXHUwMDE3wqPCrsKwXHUwMDAyw53CsTTCrMKywq3DjsK/w6zChcObXHUwMDExw6piwq1cdTAwMWZyXHUwMDFjwovDvsKOw6HDrMKTwqNkw7HDjcKHXznClkHCgm3Ct8OCw6jDiCZJXHUwMDFjw7/CvsO3c8Kgw4TDj8KZaMOTwrjDgmptXFxiw4nCkDzDkMOuaE/CpcOEMnPDjMKzOlx1MDAwM8KMw7Y9fVxcdj1KcW9mw6vCgcOowq3Dq3LDpcOTw7LCo1x1MDAxM8O1XFx0XFx2wqfDrsKXKMOqw7ZQwonDgsODwq9mfMOnXHUwMDFhZSTDlcKKwpY7w4zDv8OMw6fClibDgMKmccORwq3Dj1Ruw6bCulx1MDAxMFbCkcOzXFxcIibCulx1MDAxNUpfVsKlw4LCr0zDrnNrWVx1MDAxM3fCljdcdTAwMWPDjFxcYsOFbsKKw7LCmVx1MDAwNcOLw7tqXHUwMDAxP8K/NU3DqcOEwrNcXFwiwqxcdTAwMTBcdTAwMDfCvG1Uw4HCvsOqXHUwMDAzwpIxXHUwMDE2dz1Nw4LCqjJwOcOlXHUwMDEwXHUwMDEzNVx1MDAxMCbCocKINFx1MDAxY1x1MDAxMGhcdTAwMWFZYsKJXHUwMDA0wrVcdTAwMDFSRnHCrDvCq0bDksK2wo1cdTAwMWbCvcKCNVjConxcdTAwMTJHZlx1MDAwNsOTSXjDusO5wpbDuUdKbmxcdTAwMDXDicKlScKYYGU5worDosKZXHUwMDA1w41Mw73DsTt7w6zCiGNcXFwiwpk3wr1cdTAwMTRiw6Q+XsKyZTNcdTAwMWLDh8OkXHUwMDBlXFxiwo/DsXTCvcKDLSDCr1x1MDAwNcKXRjDCgcOJXHUwMDEzw4bCu09cXGbDo8K0wpx9wpzDuFx1MDAxYShRwqlcdTAwMTVcXHbCgcOXYsOdwozCom/CuMO3VcOkw69cdTAwMGXCr8ObwodcdTAwMTFNw4ZFO3LCqDbDmsKobsOqXHUwMDFjw47CgzfDrDTCl1x1MDAxOMOEW1fCg1x1MDAxYyvDisOlXHUwMDA1wqJRw5LClSzDkcKAP8KBw4XDgCRcdTAwMGXDjnrDk8OBw5gpw68oUcOuw7zCqMKvbcKFwonCpHZVS8OXXFx0w63Dg25cXHbDmnJVw7xXwqrCjMOWwpPCtcOJWMOdw4JawrdcdTAwMGbDrMOYwpJsUHknWsKewp87W3lzZsODwqJcXGLCgcOKw5XCjFx1MDAxMlx1MDAxZsO9LXLCocOjwpJtXHUwMDEyw5jDusOew6ZvwpJcXHbCnFtWw6jCoTbDlGRcdTAwMTdWQcOHw6p3w7BcXFwiecOiXHUwMDBmwpxbPFLDtcKywqbCrMKAwqBow5IhwoBcdTAwMTTChsK6w61zwoNcdTAwMTFMw5BAw4fDkMKGw65mw5LDvcOrwobDpMK7dcOhQkfDtm9cdTAwMTlFw7JPXFxcXMOXwp3Cs3Yxwp3Dq8KjwobDo8OKw5lEw7ZPXFxiwoBcdTAwMTE8w4M9QMOjbsOQw7hvSMOtXFxiw5dcdTAwMWLDjcKjwpNcdTAwMDfCt8Ocw5rCsXpQw63Cplx1MDAxOcKzOMOKTMKNOcKuwrHCtGDCt25CVkTCjsKXYsOGwo0nw63CgsK3w4hDJsOgLl5zXHUwMDBmdcKtw7PDjcKwXHUwMDFlOsK6w5NcdTAwMDfDkFx1MDAxZcO9b1x1MDAxY1xcdsORwrdcdTAwMGXDrcO5OlxcZsK+woLCg8OfwoVcdTAwMDFvbkhPw4NcdTAwMWZGaHxcdTAwMTJAIGw+wqRkXHUwMDAyw6JsNsKXW8OPw5k+wrzDsMOkwr/CpsKkw6PDgj1AwoE0wp/DhcO9XHUwMDFmw7XDr8KkwqdPwrvDjGTDt8OAwrV2wolTw4rCmFx1MDAwZjg4wrTCksKlNcO6aMK0wp/CuzXCksK6Iz7DkVPDgVx1MDAxZmxcXFwiXHUwMDBmXlx1MDAwZsKMXHUwMDE2wpN4fVjDssKbwpRaXHUwMDExw7xXwpAwwp1cdTAwMDPDmmTDgcOyw57DuE9cXFxcw4dFw7LCj0ZdWcOjwrZBasK3fsKJXsO3XHUwMDA1w5zDq8KGOiYkw6PDtsK7w5N4wodAcsKHbMOBw6s5XFx2XHUwMDFlwrZcXFxcwoDDq8OIwqtcdTAwMWHChcKcw7rCjMO+R8KbYsKWeWhmwq54wonCtDxDQEUnJsKdwpXCm8OWw4bCs8KhXHUwMDFjwq1NLT19wrlqXHUwMDE5w6tcdTAwMTHCtcKBQsK5w4bDkMO8OcKbw6QnwoHClsKGJzTDqcObKTTDqcObwqQvw7JbwqQvXFx2w7jCqC96Yi3Coy1+wphkXHUwMDA3U0zCqcK/XHUwMDE5MMOvLnnCncOMwoZhXHUwMDE0wo7Dp1x1MDAxYcO3JzR4XFxcXC8yNcOeL8OwWMKfw55cdTAwMTJcdTAwMTgqwp9cXHZcdTAwMTDDiihBXHUwMDExXHUwMDA3XHUwMDE0w6ZFXHUwMDExPU3DvyPDosO4UTFyw4ZDwpnCrUbDuMKsYMOaw7h3aMOSw4NcdTAwMDPDjsKBwo11Slx1MDAwZcO0UynDqHBxWMOnXHUwMDA0w6IwYMKCXFxiwqbDqT1AQWPCp8K0VU/Dl8KDwqxcdTAwMDPCnmrDlyvDpUZFPMKiw6dtIHpgXFx0wqojbVVcdTAwMGVXJsKiwpk6OnpcdTAwMTXDsm/CmirCmMOsw5N2aCMzw4hjw4t/w6EyJ8KZw5nCgnDCvHTDtcK7XFx0wqLDsVLCsm/DtsKdw6ZRwppcdTAwMTTDg8KBJVx1MDAxOCbDqcKCwq88JkpcXFwiw45sdcKXXHUwMDFjw4bCoCgswoUywrIrTzTCr1PCrMOEw6bDmcKFMcO3woJ3w4kuXFx0wr9Jwog3XHUwMDBlcsKkw49Sw6NWw4hjeMO8SnTCqHQoJcKiw6rCgcKDVkxJwonCl8Kqw6ZcdTAwMGViaUEkw47CmCzCiHzCkMKgw7rCgFx1MDAwN8O7eMK3RMKdw5MhXHUwMDExw78hwpZbeMKtTcKYb8O4wrxyTFx1MDAwMsOvdMObw7rCmsKWWcKCwpxcdTAwMDTDoMKVUcOtcVx1MDAwM8ONw6p3OMOCNcKrUzPDpsOzdMKudcK8w4zDtsOCesKEwposwqzDi8OJVMKOwoxcXFwiZEY+wprCs8OLw4dGOMOQUcKqwqTCt3pcdTAwMDJybMO7WXPCkcKFwrpjT1g9fcK1worDgUJcdTAwMTnDiFx1MDAwZsKXwotGPMKjPUDCqcOJwpctK8OcwrTDpkDDkMO3fEVqeU7CuMKFfDnCusO4wqPDs8KIwrvCkMKuw7nChcKhwq/DvcOZw6XCtsKGwqXDn8KFKlxcdG3CuzzClsO4XHUwMDBmw4fCnzl7LsKBYyhcXHQsw5NcdTAwMWJpwqRJw5BcdTAwMDRIcl4nS8OlQzpgKsOwwrZVO2dNwpLClj1NSGYuVcO1SXdcdTAwMWFyXHUwMDFjcVx1MDAxNWhUUGYnwrIsw55cdTAwMWNIw7BPw7vDp0FcXHRCwrnCmcONPUBcdTAwMWXCs8OcTcO+XFxcXFx1MDAxMzDCpMKhPUpcdTAwMDI4XTrDi8KywqE7XHUwMDBmwq98XHUwMDEzw6jDrkzCk8KLSVx1MDAwNl/Dsz5hdcO/wpDCuChAw4ZXZGxZwrTCvMKIw5zDgz7CvjvCq1jDtkBVYcKvScOMXHUwMDFiwrfDmcOpLjcxw7LDgFx1MDAxNUA7w6xXwrFlXHUwMDEyXHUwMDEyWMOGUlx1MDAxNXUswr5Tw6k0e8Kbw6whUsOJwqktw6JfXHUwMDEzbsOcMEjCsMOqNmBYdk3DtsOlwp7DpFx1MDAwMsKlesKIw4BcdTAwMTLDiFx1MDAwZsOAPUBmw6Z0XHUwMDFmw7ZkVcKiRXHCrC/CqcOEwp7ClUtQXHUwMDE0TD1NPUrCmmfCnTJcdTAwMDJaw7pFXHUwMDFmwr8/wrvDmlx1MDAwZlR/XFx0w4pBw6bCozpcdTAwMTXCs0xcXGbCvUzDhsKJWSlnw55cdTAwMGXCtsO2dMODwo8/w4DChVx1MDAwNH0two9cdTAwMTklwqZRwq7CtUkkwr9cdTAwMTR+wrRONcK9PX1ucsOneWDDki/CvUg7MVx1MDAxNVfCikgowojChVQ5WSPDt8OLclx1MDAwMcOeUlx1MDAwN2cnWcKreMKLwok1fMKOwpvCnlLCksO3RkdcdTAwMDJ5wqrDoMKhfsKZwrY7dsKBw7BcXGLDu37Di1nDnFx1MDAxYUY9fVxcZsOaOsONL8K3S1DDiivDlsK2wpp4wr1iw5Mlw6ddw73Dt8K3UcOgcjAsTnfCkMK3LsKiKsKywoRcdTAwMTbCgjrCnsOue8OXIHtaw4nCh8KwwprDt0TDmyzChmhcdTAwMWLCnGB2XHUwMDE0ZkZjw5fCl1x1MDAxOEbCgMOjTD1Kw7TDtsKaLGzDm1x1MDAxY0bDmMK/w5J4wpZ8XHUwMDEwXUTDoVxcXFzDhVx1MDAxZmzDhcO4w6w7wqHDjFpAw5bCmGlcdTAwMDcqwrfDi8KTccKmw4fCtkBRXHUwMDA1bcO3cHVcdTAwMTI8w7jCsMOgwrXCvG5cdTAwMDZxXFxcXMOrw4vCisO9wrLCr8ObXHUwMDFhfMKeWsOFwqpcXHbDsy/DkcOJwpkgOn5cdTAwMWVKw6DCqH/CoU7Ck0HDhcOmw77DoMK/TjvCunJOWcOgXHUwMDE0wpExw5bCgHc6UlxcZsKrd8O1M1x1MDAxMMKRw4jCrmXCtsK5wrLCsW7DtMKVfcOoXHUwMDBmwo7DpMOXw4FUw4nDlyPDplx1MDAwMcKeXHUwMDExR8OZw6nDnsOjMcKQwoXDqUzCrV/Dm8KzwrtRwo/Dql1cXFwiOGpUXHUwMDAxblTDk1xcYkFCbMO0ZMKcXHUwMDA2XHUwMDE2RktyfDDCnVRNXHUwMDEww4tyw7bCrcOBw4w3XHUwMDA1fj9swo/DrsOfwqs+wqJ0w45cXFxcwpjDsz1NPX3DiMOSw7RiesOcfsKEezXCtMKRw5bCrFx1MDAxY8K2w7N0w4jDgsKEIzFUwqbCjWjCocOJwpt5Plx1MDAxZlx1MDAwZsOnw5Y+SsKawovDm8KReUJcdTAwMWYrwoB/PiTDs8K0w4FXfSzCuMOkw5LDriPDg1VcdTAwMWPCj8OBLMKWOcOoVcOowr9cdTAwMTXCl8OUw4/Dj1TCssKQwoZww5czwoBnw4HDlMOUwog9SsOCeVx1MDAxY1x1MDAxN3fDtcOvPUB+X3rCi8OIw448w6BcdTAwMTEjw7NsScOMwo/DocOywonCoMK8w4HDjMOyZlx1MDAxM8KBwrPDiMKbdcOYw4TDu1x1MDAwN8KiU8KcZ1x1MDAwM8KZwp9RwpJcXHbCrcO4woHCmEbCqsOZYcKrwp7DrMOIb8Kfw5JKVndVXHUwMDFhZkJkXHUwMDE3aMOgKlx1MDAxNsKpw68lZcK7WMKqw7HDkTVEbMODXHUwMDEzw4xcdTAwMGV2wrFcdTAwMTHDqWwkP8O1dMKPwrcyw7zDsMOcwrtcdTAwMGVqwqLDtsOrwrxsU8OVwofDrVVvWcOOeVx1MDAwNcK/w6k8K3txwoXCn8OLwofClmvCjMKwwoB3wrHDgVlBwprDm1x1MDAxNMOIYsOEw7JFwo0gwqRcdTAwMDfComPCvMONWMKZw53ChsKCw7ZcdTAwMWRyO0xcdTAwMTHDtcKiw7HDnsKze1x1MDAwNMOvID/DnSx7XcKQXHUwMDAxXHUwMDAzblRcdTAwMDTCjMOrJmR9I1VcdTAwMTIzw6XCgMOKXVx1MDAwMsOcwpzDnFx1MDAwMsOkdsOHwpjDtcKhw5lqw59ow7ljw5/DhsOpwpbCr8KEXFxiw67Ds1x1MDAxMMKSamswVlx1MDAwZcOBw6Iww6VcdTAwMTTDlsOYwqdcdTAwMDJpXHUwMDFjw7XDvkzCmELDv8Kjw4XClcKOw5hAU8O+dMO7XHUwMDBlXcKUO2k1Nz43P8OsXcKAMFfDncOdXHUwMDA0PX09SsKVUlx1MDAwNVFcdTAwMWbClcKKwonDjsOZZMOQwoJcdTAwMWRcdTAwMWHDsMOeW8K5wrhUbsOWwqvCg2vDh141w5BcdTAwMDNcdTAwMDTCuzwnw5lCesO+UsO2XHUwMDFkXHUwMDE3wq/DgcO9XHUwMDBmXHUwMDA3wqzDg8Kow57CicOVw4TDtsK0wqcgw7LCmFhfUsOLw7FUbVvDlMKQXHUwMDA1UMO3wq4gJlx1MDAwNcOMw6/CtMK/w4ZcdTAwMTXCl8OUXHUwMDA0XHUwMDE3w49cdTAwMTRcdTAwMDRYXFx2SCF5XHUwMDA3MHnDsFx1MDAwN0FzwonDoWdAfiN7w7MrwpdcdTAwMTTDmcKhw5hKXHUwMDFhw5XDjEvCrcOKwp9cdTAwMTDDk1xcdMO3VcOMXHUwMDE4PU1uw5/CiMORPUBIwovCtXXCu07CtnfCqFx1MDAwMlx1MDAxZmPDl2DDjVx1MDAxY8KBwqLDgTRcdTAwMTY+w71YTcKhw6DDvTxbNzJ3woYhw70mYXRIdD19ZTrDn8KuwqzDk8KSM1x1MDAxZVx1MDAxZSTCpmFwwrpcdTAwMWbClMOgw6HCicKgwocnP3LCpn4pwpJ/J3rDgjd+acKSwoJ+w6nCunIqXHUwMDE2fldqT8OYw6TCqy/DucOnQ0E7wonDp17DmMOoVFrClMORw5XCkMOMO8O8aj19wo7Cq3fDvcO9wqskwrF8XFxiw5fDkDo1w5/DmGXDucKwbVxcXFxzXHUwMDEyLcO+wp1cdTAwMGVDw4bDssKmw6fCg8OxZkZFXHUwMDE0woHDvVx1MDAxND7ClMKwwqHDjiw2P8KBXHUwMDEwPX3DpFx1MDAxZjTCqsOFwp4kw7TCklxcXFw3w67Ch8OqZmzDv8KDT8OmVsOwXHUwMDA1XHUwMDBmw5LCicKewrR6woY3w6lcdTAwMDfDtcOaw4bDt1x1MDAxZcOpwpTDksKiwqPCtsOkwpfDsMOoRMK0w7PCulx1MDAxOD1Kw4tkTTbCsFTCi0jCrcOHOD1Nw4dcdTAwMTI9QMOUw61WwpVUwqfCt3rDjU7Ck1x1MDAxOMKLw47CiMOjw6zDqsO8wppcdTAwMDcseynCj1XCtmbCuX/DtzxcdTAwMDXCnVx1MDAxMMKuwpdcdTAwMWVIN8Olw5fCo8Oow4xcdTAwMDPCuj19wpDDuMKXPyVcdTAwMGU4ecK0w4RAWFx1MDAxZjpWwpxcXGLDmypcdTAwMTXDssO4JsK0P8OiwpjCiS1YwoHDi3tXwp5cdTAwMDRnwobDp27CgcOhXHUwMDEzXHUwMDE0ZjlcdTAwMTnDtMKhw73CsVx1MDAxZsKaw7bDoWbChnc1woVcdTAwMWPDgn9eV8Ouw45mw6stPlxcZsO8wqbDpcK1JcKUXFxcXFxcZkdlPU1HWzl2wprDgVx1MDAxNsKgw45sXHUwMDE5SzNZXHUwMDA2Q1nCtnPCjcOCwrjDl197XHUwMDA3w6nChMOhw73DjsK7wqRWWDHClMKhwqzDkVx1MDAwNjVcdTAwMWXCjcKHwonDqcOZwrR/ecKRXHUwMDE1PX1iScK8wrIsw7lOw6PDksKJw5ldwprCpFx1MDAxOV1cdTAwMTJlL2/ClcK3w4Ymw5JcdTAwMTfCjy7CnsOYwr4oPFx1MDAwNMO4KcOvwoFZw6HDhMOcUCPDnS7Dj8OzR8Kjw4DColNcdTAwMTdJwq3CjDXCh8KAXHUwMDE2w6QtLcOiwpfCr8OLw5pAwpUnTcKUbcOrfjnDsMOKUcKywo9Tw6xMwozDpnTDpSbCmmggwpJbXHUwMDE0w5/DtsOOQS7Dv8OOwrdcdTAwMWPDtzLDii3ChcKNTXDDlSbDvMKhXHUwMDE0w6U9fcOgXHUwMDEww6rDl8KMZsOgUmwwR8O3wqXCmzzDpT1Nw5RKw7PDuMKTw6PCtSnDg13CgMKSScOMwq1+NcOQaSMzK1x1MDAwZSHCpMOpw4pUwpVyw7LChjzClVbDuFF1w7JqbsOVMlx1MDAwZcOzw7zDmD1NwrRcdTAwMDXDr8OSV8O8c8KYXcO/w41sw43DlMKswrh0U8O7wptHXHUwMDFmw57Dg1lbVC/Du8ONXHUwMDE5c1YgXHUwMDA3XHUwMDAyXHUwMDEyOcOsT8ONXHUwMDEwwr9bXyDCpzDDvGbCvifCgsO+cV7CrsKeU1bDg1x1MDAwMlx1MDAxNj5XXHUwMDE4M1xcdGBcdTAwMTR6XFx2w4xewprCtVxcXCLCtkDDk8Oqw4IjwrbDrnHDgjpcdTAwMTjDunPCo8KwdCw+wr7Cs8O7wp48wr5nX1TDpsOHaMOeXFxcXMOWQlXCtVx1MDAwNMOCw7ZcdTAwMGbCumnDs8KYwrPDp8OZXHUwMDA2XHUwMDFjw4LCulx1MDAxOV3Dj8Kiw5/Cj8OEMsObJjzDpD19w4tmXHUwMDE2JMKqw5t7RMKOwp54O8OGw5HCg8OOYzLDij19wpZkw6xawotoYMK+wrPCnlx1MDAwMSB8wr3CnDhewrVcdTAwMTbCv8O8XHUwMDFlw63CocKzwoPDq8KqXHUwMDFiTFx1MDAxZsKcTsKsQjZ3wrxNbi3ClWTCrsOcXFx2XHUwMDFhRcKnwobCqjDCqy9Ow7Q+JVx1MDAwMcKHwrU4MzjDrlx1MDAxNj9cdTAwMTRMXHUwMDFmJMOlJGNrwpbDhMOIPUpvw4l1RcOGLcK4asOwMXA9fWJcdTAwMTEkw5E7PsOPwrzClcKsw4DCh1x1MDAxZsO1U8Kdw6F6WndcdTAwMTB2XHUwMDFlXFxiw4XDmSR6w6jDsVjCk8KLwrhbRcOnwrRwL8ORw4zDq01cdTAwMWR8aHPClcKEw4nDv8O3wqXDtcKywqLDpsKCXHUwMDE3NHtfw7TCv8OUwoLDiMKXw7rClsOmw5rCpsOAJ25gXHUwMDA3XHUwMDAxw6bDi8Kbw5ZcdTAwMDJcdTAwMGXCjG/DoXDDkGg1UsOuw6vCvGM5w6XCtsKVw51wN09cdTAwMTbCv8KoXHUwMDA3w6nDnjnDhsOLwoHDiMKVwqpSwpJcdTAwMTDChSjDs8O9wrPCgzV5ccO3wpXCo33Cmlx1MDAxNsK0Km7Dr8KLw4Y2wpd+f8KMdlHDrkZjw57CgMO6XFxcXER0bsO7wqLCgWdvPUA7Z8Ovw5jDv3BeKj9cdTAwMGZ1RX9Lwp5zTW7DhCNcdTAwMTYzwrtMPU1cdTAwMWXDk0pcdTAwMDTDhDxcdTAwMDNcXHRFXHUwMDAyw6dbccKVZExmw7LCvlTDvHF8VkvDkC3DjD19XFxiwox9w4pPVMKKwpdMScO/wr95w6DDhVx1MDAxNzFww4/Cs1x1MDAxMsKzw6xlw5pcdTAwMGZfVj5NVcKmwqN3V8Kmwr3CjjXDhGLCllYrw61Dw63DvMKYd8Kiw61yXHUwMDE3woErw6lcXFxcw5PConRcXGbCtVx1MDAwZTzDj8K6e8O3U8KLXHUwMDEwXHUwMDAzwqlcdTAwMTHDqHl4w5pUwp/CrVx1MDAxZH1cdTAwMGZxwqnDl3pQw4Niw5TDpU0nw6XDgnnCgMKiYcKXw57DjMKhOcOsw63DtMK0P3XDpD7DoitcdTAwMTjCjmdOwpfCrVx1MDAxNsK9w6FcdTAwMTnCgMKiwolSYjDDkDTCqX5Pw7zDssK+WXkqZTN8bsKnd1Avw48hMWsobcOHLsOiwrjCvsONU1xcXCIqw4XDnHE+clx1MDAxMsOsKMObXFx2wqY9Slx1MDAxZDBoKsOTwoZJwrpcdTAwMTBcdTAwMDV0JWzChUIjWsKTwotMwrx3wo9rw5BEw7LDslx1MDAxYsKBXHUwMDFlfUXClkxRZ8OjVGFrQ1x1MDAxNcOoNsKsw5ZRw7hfdlx1MDAwZsOVw7XDk8Oaw49cdTAwMTIgwpPDpm4jesOROcOawpHDtWvDosOMw7PCi3PDkVx1MDAwMSlxXjLDiMK1aUg4woR3ajbDjsKsesKaXHUwMDEyw5HChzTDk0bDjjfClMONXHUwMDAywoPCt1x1MDAwMSjCusOewrrCqsKAXsOEMMObw6HDtMKBQ8KPwpk1P8O3U1xcdsO2wqNcdTAwMTheXFxcXHRcdTAwMDbChsO2XFxiw5BcdTAwMDdcdTAwMWTCilx1MDAxY8KFwqnCilx1MDAxY8KFwrd5Y8K6woZcdTAwMGXCkcKVUcKpw5XCq8KXw5TDrsOgelx1MDAwMcOTWXJFXHUwMDEwwpXCt1x1MDAwMlx1MDAxYVxcdMKVNCVhw57Ct1x1MDAxZW1cXHQlwq07w4BUwoBcdTAwMTh9wrIhwrTCicOdwoBcdTAwMTFSwrA9TVx1MDAxY1x1MDAxNj9cXFwiwqjCj8OtwpBLwpNVwp5cdTAwMTYtSsKUasKMcFx1MDAwNcKVJjY9TWHCiVjDp0Qzw7Y0WMO3w4pcdTAwMTjCtMOiw7xRRCB7e8KfwpMtw5HDimTCrsOfwpbDgk/Cn0d0LXlcdTAwMWE7wowwd3Ajw7PCosK7wpnChMOHwo7CvlTDg8KdN2PDg1x1MDAxMsK4Z2FcdTAwMDE7wppcdTAwMTJcXFxcwqXColJMPU3Co8OMw7zCtVx1MDAwZVx1MDAxNj1KdzLDnUUvNsK/w4HDtsKow63DvEhKw6syUVx1MDAwNGopwoHCkVx1MDAxNsOiw47Cm8OqwoVMWDzCicOnw49mwp/Cv8OYw5VFLSHDjHUqw6XCicOzTyA1wp9UXHUwMDFhZsOYw7pPdlUmw6vDllx1MDAxOMOVPUohXHUwMDEzVMKAXHUwMDFmTcK0RXnCucO5w5DDscKvXHUwMDAyPUBTXHUwMDFiwqRcdTAwMWV/cntMMcKWZcOHwpxcXFxcwodcdTAwMTfDrn9DwrtcXFwifVx1MDAwZsOlV8K/c8OQSEzDuH3DqMKdf8OowqItwp90w6V/wpzDn8KFXHUwMDBmNVPCl8ORw4Z3woHDscOUwrzCi0ZEWFF9ODrCsm44KsKhwqB0MnDCp8Kfw6bDtCvDvD1NeMOjV8KHw4fDlsKcwrrCjsKNXHUwMDFhw5zCmsKHIMO5woYmwooxw785Sj1Awq3Cu8OjLU7DlMOCf8KtMDDDg2XDgFx1MDAxNsOkK8OPe8OUXFxmXHUwMDFkw59keHRcdTAwMWJSL8ObLsKUPUrCvMKgw5XCmVx1MDAwMsOfwobCnMOnwrs/w7zCkkFcdTAwMWXCgGnDvMOnw7bCplckLMOUw40uw6dnw7AwdVx1MDAxMsK8VFx1MDAwNErCncOVw73Dr8Klw6xqRmssw6Jsw7LCvXjDlMKEwq1ydMKSOFlFw4xJw4DDulxcXFx1U8K2wp/DlcKnw7ZcdTAwMDV6w7nDhivDosK8w4A/wpduw6E1XHUwMDFmfTHDh0XDq1x1MDAxMTkxNcOjcMKwwqJcdTAwMThbwofDnsO+w4Emwq5XwoLCni7Cp8ORY1x1MDAwMkBcdTAwMWRAwp9Kw7k3VcOjwrcpwoM7w5XDisOYwrzDkcO4PUrCvsORwqjCilx1MDAxMsKDw6LCocOCXHUwMDE5SFx1MDAxNS5ULWLDqyTDjsOLXHUwMDFjVUVKwr1cdTAwMTNcdTAwMTVcdTAwMGXDrXlcdTAwMWVFw71Uw549TcOjRVx1MDAwZlx1MDAxOcOiwrhcdTAwMTM9TSvDnSMlaC8vMjk7wqPCsFx1MDAwMiHDs8KAwrFsfsOYwoh7w6wjwrPDrsKRWcKBXFxmwpXCsMO4wpYyXcK6w6BNwp0hw7PCt1x1MDAxYcO+XHUwMDBmXHUwMDFic8OXJcKeXHUwMDAxwrPDicK3w7BOwogpw7bCsG3DpMOEw6bCgsKXwojCvsOPW3pDOcK/XHUwMDA2SMOyw6XCgMO1ZcKbwqxvUmnDkV7DpMKewqTCrcKKK8KtbmhJXHUwMDA0X1x1MDAxZcKPUsKMwpvCrVx1MDAxZMOGwoxcdTAwMThcdTAwMDNCU8K7XsK0YcKhXsKlwqVcdTAwMWbDksKHwoxcdTAwMWXCqEUybEQ8eMOFw4nCvGnCuMO3wq7Cu8KFXHUwMDAzw5/Cm3fCpWbDtCHDhmkxXHUwMDA3wpPDvsKFw4bClD1NwpNcdTAwMGXDrVJcdTAwMWJLw4E9fW/DsMOMw5XDnMKoTz5vXHUwMDEzZSjCqiV7NVx1MDAxNy3DsMOzXFxcIlx1MDAxOcO4wrHDs8OOXHUwMDExccK0XFx2w7VcXFwiTlx1MDAxNy3Dk1x1MDAxZE5cdTAwMGXCrsKew53DjSNfw5R4wrHCt1x1MDAxY8O+SMOBw7o2PsKAwog4w4EpwrfCtsKxwqFhw4hLw6pcXHZ6Y8K0XHUwMDE3wrZIP8OWwrFcdTAwMDbCu1x1MDAwZsOUwoZcdTAwMWNtw7Qyw5HDksOwW2U1wqNLw6xTwp9kw4TCtMOIcjHCnsKJwo7Dp8Kow6fCnEVYw4nCnsO/wr1cdTAwMTTDhn3Dg1x1MDAxNsOhZlx1MDAxMWDCpcKmw5TDmCE9SkdcdTAwMGXDpTzDl2vDgsKJwrA5wr/DqVxcdsOxfW1yw6TCo8KgVMKmw77CgF/DoMOJwr8mw7Ehw4lcdTAwMDVqTzXCnsKuISZLecOhLcKSw457wqhLJMOUdcOKwpTDvGh6w6JXw7gkwpRcdTAwMTRxwptbWFx1MDAwMsOJY8KPwp4xwotfIVxcXFzCp1x1MDAxM3ojVcOow5hDXFxmwo3Ci8O/w7zDnDvColDCuVxcXCLDgCzDiFx1MDAxOD1AcMK5wqwnwrY2cMOcwoxEw49hXHUwMDBlw6MpR8OTw6bCgFx1MDAxMybDucO9fSvDinxcdTAwMDdhRHQpWFXDhsO+wo40w71cdTAwMWHCqHHCilx1MDAxYcKOw5E4wrF7NMKvw41rwqrDvVxcYlxcdMOnwrrDkMKnIMKcZcKow7RqXFxcIsKhaD7CqsOdw4ZcdTAwMGXCm0Eow49cdTAwMDFiXHUwMDAyw4ggacOUwo3Co8Okw5hcdTAwMWTDpsO/YjzDuD1Nw6xbw7pQwoI9Si5cdTAwMWPDkl3CmcONW8KAwo7DiHnDm2Qzwo7ChWrCs3DCtCtic3/Cn8KGw4rDoHBcdTAwMDTDqyl1w77Cl2TCpsOOw7tcdTAwMTHCmcOlOsOcd2powotcdTAwMDPCgMKAYcOUwoVcdTAwMDHCsMKXw6nDi0PDgMKbwqpnwqM4MntzNsOlXFxmXHUwMDFmXFxcXMKySsKrw6p4wozDrcKaw6DDncKhZVxcXCJbwrjDnTQxwqVDwqDDv0pfw4jDgFx1MDAxMX4kXFxcIn1cdTAwMDVPJFI6aMOmXFxiMMK/Q21cdTAwMGbCmT1KOlx1MDAxMsKZwqJcdTAwMGU9fTQmXHUwMDE0JyVcdTAwMWLDsMKkXSBSXHUwMDA1w5lcdTAwMTdZfmtGZy3DnMONajFNTsKzwpTChsKkwpfCojnCnj1Awpctwr3DkWbCpU/DssOAPz1AwotqXHUwMDE3w7QvasOlM8OowqDCi1TDuy1Qwr59w6/CqjLCk0/DqsKFwovDvsKKXHUwMDAzQVhcdTAwMWMtw7LDiU1cdTAwMGbCmcOtwrLDg8KHwo3DgnjChsOLwpLCtMKcw71cdTAwMDdMaXs2LnjDmcKmU8KuTXNcdTAwMWXDiXbDilx1MDAxOV3DsMO3XHUwMDA2OnLDvC3CozXCsVx1MDAwZsKoXHUwMDBmRHbDhMObwrpqw61zw5fDk8OHXHUwMDAzXFxcXMODXFxcXMKJw6d4PsKwNMKka1xcYl3Dq8OQXHUwMDExNcKVw63CisOFTz19U8O9w5ZTKsOGwojCgMKuRcOuPlRQYcKQblNTXFxcIsKwXHUwMDE2V8KywpUgPUBuYcKNwoDDkFx1MDAxNsKKwpxewqrCjjPCuMOGNk3CusKywonChFx1MDAwZsOQw618TUnCkH3CrX5cdTAwMDbCn1NPwrlcXGbClMOsXmPCu8OZwr3CtX9RSkXChHpxM8ODwo3CukdDXFxcXDXDl8KVbMOWw4A9TTLCmcODw4HDhcOMNsO1w6rCp8O7PsO8wrNcdTAwMTLDhcOjU8K5RcKUXHUwMDBmMMOgak3CsEQ/wpQrw5BcdTAwMWTCn8Ocwr3DvHtGfVx1MDAwZcKXwpTCr8KRwpnClXg9TcKKw4gzw6PCr3A7WjdcdTAwMDXCl8K3wpc9QFx1MDAwMm/ChsKMw7s9Sj1KwpTCncKSwovDgHTCpUAqUmw9QF4vPX1cXGbDjsKIXFxiwrxIwq1Qw5rCvcOPRFx1MDAxYcK7PUBcdTAwMDcpw7BUasKzWcOyPX18wqFcdTAwMTLCt8ObwqFrXHUwMDA2w43DvsK1XHUwMDAzQMKwV8OJw7wwPG/CiE7CtsKhdsKdJFjCl8KoPsKSPMKlwotcdTAwMTDCusKtcFx1MDAxOcOUwoRkwqDCs8KcwoJDwr/CmHd4w4zClHQ0eTHDsVxcdD19w5IxQMKmXHUwMDBlwr1ZXU5cdTAwMTfDhSfCsVx1MDAwN1x1MDAxY8OGwqJEXcONUmddwp45KcK6w5xcdTAwMGbDvVx1MDAxNFx1MDAxZcOOXnFmKHQ+SUpKTsKMXHUwMDE3bMKvXHUwMDAzXHUwMDAxw6jCkcOIw7Iswp5AXHUwMDE2w7rDsMO0wpnDuy1Obylfw6nDncOew6l6wr3Cj8K+wqDDi8O0PU1MPUpKw5RQwoHCnsK0OsONOMKdwqvDh8OXwpLDimt5wqxcdTAwMTfDgVx1MDAwNFxcXCLDlcK7XHUwMDFjWcOLw6Y6wqh2VMOzw6ZcdTAwMDUhSHprIcK8wpY9TcO/w7dnwrNKUULDm15vwrDChsKrW3dcdTAwMWHCqVx1MDAwND19NFPDt8O8TMKbN1x1MDAxNcKXwrlgwozCocOpwqzCsX7DqyzDvTsmXkPComFgVFlrUXlQw4/Dq3jCsMKaan/ChcK0wpfDqHPDhFxcdsKRLTnDtsKra148bcORw5VQwr3Dj8OJXHUwMDEyb8K/MMOZPX10w649SsK1KMORaMOPw7PDksKTwrTCqcOdw6jDhcK5w7MtwrxnwrPDtMOMalLCncOzw7PCujjCosKYOHHDisOrXFxmMExcXGbDssO6wqrDu8K8XWp6XFxcXFx1MDAwZsKrwqAjdsKuw6Veb8ORYXIqXHUwMDFlwpoqI1NcXGLDusOYXFxiSiFjM8O+bG3Du3XDpMKkw7NUwrt7T1x1MDAwMXQ0w6xmw4t/XHUwMDFiPMOewoBcdTAwMTNPwoTCkMKpXHUwMDFhwoVcXGbCncOnXHUwMDFkwqXCk8KZwpNcdTAwMWVcXHTDrCDDpsKoNcO/aMOXW8K0YDF8eCV3e8OpcMKcPX3CoGvDksKvVlDCg1M9SizCmkLCvsO3XHUwMDEzw6/CrMKVwpx/XHUwMDAzw5d2wozCg8OgVcK6w7TCkj1AdMO7OsOMw4DCulx1MDAwNVXDilx1MDAwM0pDesKAXHUwMDBmwp3DsWvDjcKmeMO7wrfCmMObXFxiWMKlw7xywq/DtlxcZsOOwp/DqVxcZlxcdsK9w4o4M8OiwqfCqMOeezpcXGJcdTAwMDLCicOeXHUwMDBmTTHCo1dcXHbCpsKIdTo7b3VcdTAwMDZSKcOLXFxmWsKAJsKxw7rDgMOqP8K/XFx0Vlguw7JBYcOFdkJcdTAwMTE1wqTClXLDvMKiXFxmR8K7OsOrw5hBNn5Tw5bDr8O4elxcZj19T1x1MDAwMk7Cm8KRM8OBfjRBXFxmM8KyaGLDkFY8w7PClEE3QEJcdTAwMDRTw456w5fCqnrDj1x1MDAwMizCssOGK8KXw5RnPUDDk8KVXHUwMDE5woLDhFx1MDAxNjJUw5E8wqvCkjDDncOZYFx1MDAxN8OWw7LCs1x1MDAxMMOrw7XDo1x1MDAwNFx1MDAxNi/Dg1JIwotKPX3Cv2t+OMOLw6rDpFo9fTXCqMOow4vDo2TDpk5cdTAwMDd3bFxcZj1Aw4ByXHUwMDE0wqHDr31cdTAwMWFvw57Cq8OofMOYZsKmwo/DgTUow5gqXHUwMDAyw4BPwoh5XHUwMDE1VcKNWU3Dt8KlLlxcZsKfw5xNwrgkXWXDpnM3wqzDllx1MDAwNFrDnWJJw7DCmMOxZTImw5JcdTAwMDI3w44swoRsw5pOQWXDo27Dp1dKwpjCmcOew5pIdMK0dWdcdTAwMDTDq8OTw5jCtMK0WWtXw6cnUsKvw6bDsSxzesKkL8OAw57DgsK9w5Y8w51cXGJzZsK3f8KrTE5twopcdTAwMGbCkDU4wpDCo8OBdsKYwoonZMONwonDiMKBXHUwMDExJlx1MDAxOFx1MDAxYlxcYsOVw6xTXHUwMDE5w4rDrMKaXlnCgMOHYMOrw6FcXHZcXHbCjsKKbXrDuVx1MDAxMMKlw5lgZy7CvMODwopcXFwiX1x1MDAwNm7Dqlx1MDAwNlx1MDAwMlx1MDAxNkI1W8K6PX1gwo5GXHUwMDA3w6ZLwpQow7DCl8K1w6dZXsKbdzXDq8Ovwpopw6bCkzTCvcOBTlxcYsKZwqjDq8Oyw7teXHUwMDFhwqLChFvDt8KFw7NuR2nDlMOjw5HDr8OAw4rDgsOHwpl9wr9cdTAwMWNRXHUwMDFiwqtcdTAwMGXChzzDssKhwq86Nlx1MDAxYlx1MDAwZcKwbsOzwovCoMOHL0rCvcKzwrIswpFCK8Kbw6LCplx1MDAxYVx1MDAxNcKQwqnDilx1MDAxNWjCncKAw6Y4wrHDtcKxXFxmw7RaXHUwMDFlw6DCiT1Nw5PCuMOQworCjUbClcKmSMK6wqJiw55cdTAwMTnDu8OofkQsw5PCiFTCt8K9NcOxXHUwMDFhwqBcXHbDksOEw5kxY21Kw6bCuStKY8KGKF5mwotcdTAwMTRzUjDCvGZ4w58uXHUwMDFhw6g9fTnDgcORw6jDrMOWblx1MDAxNMOmQ8OcPU3DvsKVe8ObRUPCpcOBLlN9wpbCk8OPwpIhw6jDvcKUOElcdTAwMTnDjsKEwr7DiEDDkzBRwp15NMO+XFxiSCbCtcKxwpcmwqpAK1x1MDAxOMK5w5rCgXhcdTAwMDHDuFx1MDAxM3DDhm5cdTAwMWZ6wrZAw65VXHUwMDE2XcOew6XCu1xcZsOQeGl6wrZcdTAwMTlFw6RcdTAwMDdcdTAwMDLCnywgw7HDn8Khw6hCw7VYMcKxeVxcZsKAb1x1MDAxMFx1MDAwNsOjw7ctwpTCvHHDt1x1MDAwZk1PWsKONsK6P8KaLcOWw6XDoMKyJWLCrcK9SzvDrG3CusKqwrjCiDRjw5fCsMOow57CnTLChjlcdTAwMTI3NMOSXHUwMDFlwq7Dg8O/w7djw5pvblx1MDAxZMOgw6LDqcOEXHUwMDAzPUAjwq9zK1NcXFwiw4fCtlx1MDAxM8OiYcOow5lcdTAwMWLDmMKjwrfDmsOgwoLDny8nw5jCrFx1MDAwZcK9dsKPJcOowqfDhsOhw73Di8Odw70mw7TCicKNXFx0WcKnw6nCn8Opw5bCpMK8SMKZwq01woYrw6hcXFxcwrRjcmPCqMOKMsORZMK+Q8K3XFxcXFd8K1x1MDAxOSjDjMOgd1PDiMOhScKtXHUwMDA1ccOdOGYywqMlwqDDqMOJYVx1MDAxM8K0wrJFOsKMXHUwMDFkMztOSsKAXHUwMDE4wpZcdTAwMTfDssOaOMKTwprDoMOKwojDqsOaw6pHwr57w7Ruwq4xwqZcdTAwMWQqwpVpw5DDuDHCtMO7McKmfcK0wqVcdTAwMTJMdsO+N8Opwq7Drk4yUcKsXHUwMDFkwrHDgiFKJSPCh8KXRsKNXHUwMDE4wq9vw58gRzTDp8OAw5d9O8KCNMKFwq5kwrdFwoDCpMKEw6/CvcKTw6VcdTAwMTNcXFwiw5xpbV9VwpZcdTAwMTLDt1x1MDAxMsK2w57Cs8KDXHUwMDE1UGVoL8KVwoPCjlLCj8KsW8KjwodcdTAwMWVcdTAwMDVcdTAwMWM3I1x1MDAxYcOYw4tTJnDCt8O2wpdtwrLDjE1cdTAwMWU9QCpcdTAwMTjCtFx1MDAxOMKiXHUwMDAzesKAw6g0w69gw4JcdTAwMWLCgH9KwqbChcOGwrNTwobCkVx1MDAwZVFcXHbDnMKvRMOzWUgtw7haw6rCkWo2w55vw6XDl8OiXcOLKVxcdMKdw7LDhn7DhMOJw63DosObXHUwMDE0w6t7w5LCg8KWw75cdTAwMTDDrkVHQ3xcdTAwMWPCi3tiw5NVNkRcXGLCpMOnwrhyf8Kkw6fDt8OzZ2R1w6pcdTAwMTklPFxcXCJlwqnCqEzDu8OBwp3DvcO6XHUwMDE4XHUwMDBmw7HCi8OZwppcdTAwMDfDhFxcZn7DhVDDmX9cdTAwMDRcdTAwMDPCqXbDrkDDm1x1MDAwNcO+LsOFIMOgTMKpc8KLwqhmw7XDvC1qwq7CqMKtPUBcdTAwMGYtQjXDjjfCiTw9fcOLwr8qNlx1MDAxZsKxw6LDuVxcdsO/w7cxw5UtMMOVXHUwMDFlLcKkwqvDqCRcXHZPXHUwMDAzOMKiw5RXSsKXM8K7wpw9QDdcdTAwMDRKw4fCs08xw5/Cll1PfsKeXHUwMDAywrzCo1tEw6fDiVxcdFx1MDAwMsKEwqHDjMKdRjHCj8KpXHUwMDFhwo48YEbDj0PCjizCsMKewobCgkFdL0I+wqYow44+wojCoXJPw47Dnz1KwqXDslxcYjDDnMK2w7fCllM9SsO6esKLU1x1MDAxMHVGwrPCs3NKOzlcdTAwMTbCv2NGSsOeYcO0JDjCs8OzKCzDrsOrXHUwMDAydsOFMcK7wrJ9W8O9XFx2P0vDosKSfGYxw5nCtsOSccKPwo3CvsOAwofDiWrCljjCtkxcdTAwMTbCvMKjw6HDolx1MDAxMsO7L1x1MDAxNznCqj1Aw5Egw7XDgELDh8Orw4ZewoYlUyPDscO0w79vXmpMw59Tw5Asw6ZGw4jDhUw7w7/DijPCs8OAwqdowoJmw7bDn8Ksw7XDucO4PUAlwrR3fMKOw67CqMOKwo3Cj0V9MMOUUWBMI8OQwpYtw5PDkV/DvMKRXHUwMDFkw7BcdTAwMTPCjMK9w5hcdTAwMDdgKcOCw5bCssOQw47Cg8KMPUrDqMO5ScK/w4xcdTAwMTlcXGbCvcKsYTNcdTAwMDNtNUTCuj1AdcORJj9dw6bCpcOdw5pSw7XDj1xcdMOaTlvDsXh5TSQpw50hw4nCi3suw7VJWmRtXFxiwofCnMO4Y03CrMOKTlx1MDAwM8KTwrwuPz9remrCszxOMsK8T1ZSwqzDgsKdbFsxfsO2woPDg0DCnTA9fcKQw6/Dhj/DnUrDssOXw4jCh8O5YyklXFxiOSFcdTAwMTXCp8OIw7XChFx1MDAxOFx1MDAxNsKuw4hcdTAwMTjDlCTCn8KBwoHCocKfwp1Xw55LwrFPXFxcXC5rwoBfS0UzwrpCMTnDknDCi1x1MDAwM2tcdTAwMTJcXHZsw69cdTAwMWPDqcKVccKcwrPCjsK8V2Zqwr7DqSfDs8KsMMO6wo7CvTc7w6LCn3jDo8KmwrrDsn/DssOGVFx1MDAxM8Ojw6vCg8KMwpcqwpFVwovCkS9YJMKzwrbDscOsLUbDmXPCicKrVsKEw4PClsO0STLDnzVcdTAwMWHCsMKaMUDDnsKtXHUwMDE4dcOweMOSw5A9SsK6ZX/ClsOUdyDDosK7XHUwMDE2Jlx1MDAxYcKpwolqwrZTw5jCnXl8JVx1MDAxOUXCkljCh1rDpsOKXHUwMDFjXFxcIsOJXHUwMDA3IU/DqGVbJcKyXHUwMDE1woImw7fCt1RzwohvXHUwMDFjbFxcYiDDiVx1MDAwNnrCvMOWw6rCnVpcdTAwMDIyP8OpTl7CrsOicMOywrhswo52wrDDklHCnsO7woo5MMKYw5RCw6FcdTAwMWPCsz7DocO1Olx1MDAwMjXCjntSV8Kbw4bCjmYzfsOPY3jCvSsuwpFzw51yQFx1MDAxOFx1MDAwZmBKPFx1MDAxOWLDjllgwp9Udlx1MDAxZsOhw4TDrMKbQlx1MDAwMzHCgFx1MDAxNGnDncK0c2QuVsO8wozDoVJmUVx1MDAwM0dyasKgXHUwMDAyJMKhbMOmXHUwMDA1OsKDacOAbTrDg2F2wqo4wpxKXFx0w5pcdTAwMTnCt8K+w4nCslI8IcK/TcKAP8KbSDfDr8KFc8KaTcOfwo5cdTAwMDU5XHUwMDFjZMKbw6F/w6xLXHUwMDAzwqt8w4U+MsK1w6LChENgw5VKwoU9fcK1w4VcXHYpXHUwMDEwwrBdwqQpfXjCmEVZwptMwoY9SjbDsVvCh8O8I8OMKMKlwr3Dk0bCnsOXYsOXX1x1MDAwZcKAwqxBccOAPMKdwoHDpsK1w5QsXHUwMDEzXFxiwrrCq8KWL1x1MDAxOEPDj3PDusO+w4NcdTAwMTRxwrvDh8KUw6JcdTAwMWbCvsOyX1xcXFzCsnZcdTAwMDRjwpvDnMK8woXDsMOCVcOqwqxxwo7Cs37DgsKhwozDuFFcdTAwMTXDuMK8wofDnsOzXHUwMDE0w5JcdTAwMDbCmjVcdTAwMTHDiD1KYMOSwrpmT8O4wrZuw5vDr8Oqwp0tw4FDwrY1w5M8MMKsXHUwMDBmNVxcdk7CvMK2w4XCvcOnw4R2XHUwMDFmw61zw6kwRMKQw4zDsDzDgMOEwpTCnTYow6HDqTpDXHUwMDE5MVvCnFxcZj1Awq4zQMK6Ylx1MDAwMVEvw4DDk2R0wojDr29nwrR5IyZcdTAwMTHCvsOOXHUwMDE0w6VVwpc4JzrCjMORPG9cXGbClE3CsitcXGZgwr5Ow58+e8KXasOFw5RZwpFjw4U+wqrCj3XCoMObL2crw7k+XHUwMDExwp7CqkjCqkZcdTAwMTNwwpwhwrLCocKVwqxMwrNcXHQwVT1Nwp1Fw6DCssKBK1FINcOMwr3DmsKfSsKsw5TCvcKWIU7Du3zDs0NcdTAwMWIwfVRcdTAwMDZSMVx1MDAwM8OQwoHDjHcuP8OuXFx2w6tcdTAwMTPDlGLChU7DqsK0RcKJL8OGdFR2ZVx1MDAxMzjCk8KdR1h+O2bCv8O8SnrDkmVyw58yJsKsw79cXFwiT8KEw5g3wrR5XHUwMDEwXHUwMDAxPX3CucOjU8KhYcKbwrp1wqI4IMK4w5fDo1jDm8KKwp7Dt8KKwobDvMOCLcOjVsK2KcOrXHUwMDA0XHUwMDFlZFxcZsK3w6TCssKXL13DiWtDwopFVcKnwoxLXHUwMDAzw6zCpsKoXHUwMDAyXHUwMDFjdMO/NsKeRShcdTAwMTPCnF9Xw4bDul9cdTAwMDE9TVx1MDAxNlxcXFx9T8Ocw75DVlx1MDAxZMKNdj1AJFsww4nChMOPwptwPX3DvsOoXHUwMDBlwrzDk1xcYsKAwozCscKyf0vDg8KSaMKjOXMqVMKSwqN/w4JcdTAwMTPDrcK/PFx1MDAxZcK3woXDj1x1MDAxMMKpXFxcXMKVMVx1MDAxZMOicyhPXHUwMDA1UMK7wobCvMKHw6pcXHZcdTAwMTdcdTAwMWHCrcOmwodcdTAwMDF+w6gzw6RbTk/DmsOaw6NgNcOAw4lKZ3PCmFx1MDAxNVbCh1x1MDAxMlx1MDAwZcKaXHUwMDBmwqt6wpjDvMOHOnk2XFxiwpNwJsKLKcK5w51aw4t7IcKpwrbDqVxcXFzCrDh8wq1cdTAwMTlOYcOtw5/CnCvCi0VcdTAwMDNZwq09fTDDmnVBVsKHXFxmLlx1MDAwM8KTw5R1VsKVw7xMwqvDsMKdVil5TVFcdTAwMDPCmHXChlrDvHhcdTAwMTPCu0xcdTAwMTXCvVx1MDAxNlUyw7ZcdTAwMWbDomfDok5cdTAwMGbCrCA1w4DDtsK6w4J4wqt6Z8K9TMOEXHUwMDEzwrRHTsK8w6TDscOBdjZ7WlxcXCLDoXtcdTAwMWIpwrs+woPCgMKHPMO7w5R0wpYqXFxmT8Kvw5PCmCYpXFxiXHUwMDFhwrnDu1x1MDAwNsOQwolcXGbDusKBaVx1MDAwMsKAckVcdTAwMWHDlycpw7A5aMOzw47DjjZcdTAwMDZNwoZ4w4tQSsKVXHUwMDE0JsO1w45iwrB5w4xBwobClW/ClHF9JynCjMOCXFxcIlx1MDAxZsOrdMKvKC0ywrrDtVxcXFzCnj1KwotrwoLDuD19XHUwMDExVXfClFcrXHUwMDFlKmPCrcKIw6ZrQsKWf3LCgGlMXHUwMDE4aFx1MDAxOEhbXHUwMDAyTl9Tw7E0wp/DuFx1MDAwNFx1MDAxMFR6w7jCusKxw4NuwoxcXFwiwrtNw5LDkFxcdsKpw5tPTcKYw53DssKZw5rChT1KwqltXHUwMDFjSVvCrT1KXHUwMDE1KcOCa8KKw6TCm8KIwoNcXGZAwqtcdTAwMWbDqMOiwrpWw7zCmcKuw4gxwoPDrivClMKdfDXDrcOcJ8KOQWzDvFx1MDAwZSspw6JcdTAwMWROw6zCuMOFXHUwMDFjKsKPTTt4XHUwMDA2wpbCj0xWXHUwMDEzNsKJw6PCpsKMXHUwMDFmwrXCkUdEwrtTV1x1MDAwNkDDsFx1MDAxYcOtelx1MDAwNkrDssKRw4TDk8K7wox0eMKsw7zDrCx0wo7Dk0DCmEzDg8KiVGnDg8KhbsOQVVx1MDAxY8KmOcO+dcOMw7PCisODT23CklEhwrLCqcK9w4PDm8KGfsOzKcO4UMKsJ8O7c2ZEdlVawr7ClsK0ZsKvJlpMacOiwpPCoClAw7ZAw6FTXFxmW2NcdTAwMWLDllHCojpcdTAwMDZ0XHUwMDA2XHUwMDE3XHUwMDA2wrrCvWJNwoZcXFxcwoY2VMKhbkRcdTAwMWUpXHUwMDAzXHUwMDA0RGDDmU9cdTAwMTc2fsOUZ8KKw63CusOkfFxcXFzDiDfCkz19wqlew6HCsGZhw4vCtFx1MDAxNkdMwqgzw7ZcdTAwMTgkQcKSw6/Dt33Cq8KTPlx1MDAwZcOPwrzCik9cdTAwMWJMPMOKRiTChsOQPUrCm3PDglHCgyHCqsO1PU3CqUlRw4hDXFxmNCVcdTAwMTk9TU5cdTAwMTEpwrlRwopQw7spwqPCrMOFw4tcdTAwMWLDqXk2XHUwMDBmw7BwamnDr0hswqs9SsOdw4jCvsOjcsOFwpZcdTAwMDYsPUBgQVpcdTAwMWbDiVgww7bDs0zCp8OYwqnCu8OBwoYpwqzDliNKw6N2Jncpw6RQXHUwMDA2w47CgcOCw4NrJMO1XHUwMDA2woROKcKkRVx1MDAwNjTDtVx1MDAwZTLCvF0xw5lcXFxcw44rZ39fXFxmM049fUvCisOkw4BcdTAwMTnDs8Kdwo5cdTAwMDFHQsO4I1x1MDAxOcOmLlNcdTAwMThOXHUwMDE2XHUwMDAxw6pjw7BjMTrDosOvw67ChcKmw4VUwpzDpVx1MDAwZsK8XHUwMDEww67CrSbCrF8gw7bDl8OyVDdcdTAwMDZbw6HDtMOIw7/CgMO8w5XDkj5zw4jCqsKTwq5cdTAwMTDDhsOmwrLCvsOuwpXCjsKaPU3CmVxcZsKHP8OzXHUwMDE4woBcdTAwMDbDgkjCnsKxYsO5w47Ctlx1MDAxNDo6w5/CosKcw77DqcKHw43DrkfChjxcXFxcU8Kgw6HCuys1wrPDtS/CgMOCS8OXO8K+N2bDj8OuwroxwrkvcsOAfMK9McKtKzZYw7zChyvDoUFcdTAwMTNUPX1xUUPCs07DqcOKwod/fcKxw4FfwrdAw5lcXGbDuFx1MDAxZsKTw6vCiXEwwoXDqzUvw4VtwrtyfMKTwph9w5hKPMKSw67Clz19MsKww43CosOlWcOiLHXDn8K0LcKkw7I2aDxcdTAwMWQvVy1cdTAwMDIzwozDkUZhw5o5w59SU8OPXFxcInvCm1x1MDAxNmnDojDDhktILsKGwo5cXGbCp07Dl3JPw7jCj1x1MDAxOVhCV8O4XHUwMDA2PUDDj8KcworChDrDqsOCfH1ywrkkaTDDiVx1MDAwMnUuXHUwMDEzwrvCnSlcdTAwMTbCtSnCkcO4w7LCtnrDmsOcw6/Cg0vDtVx1MDAxZcOtwpBzKcKGwq/ChsK4wowpXcKxbcKmw63DqVx1MDAwN1x1MDAwNMOOw4o9TVXDj1Q5wr3DgMKrwo3DjsO5bcKQw5XCultdwpgjdsKYwrg+QcKzL8OHXHUwMDBlwqnCpSDCk8Kcw6pNwoBSUsO5LMKaSjVyw5TDhsKDw4sxw5/DpMOjQFx1MDAxM8K0wrpnZcOvXHUwMDE4LHLDgl1bL8OoXcOLSXDCoHpPwqhkw5xwNmFcdTAwMWLDtMOhPMO4RMOswoPDglTCjcKYbkDCmS7CuMKrXHUwMDA1O8OeXHUwMDAyQsO4wojCqsOdUCnDuMKsV1FcdTAwMGY9TVhcdTAwMDdzwpBcdTAwMDZtw79vTMKka35cdTAwMTBEbsKew45cdTAwMWTCl1HDh8KNXHUwMDEwcMOow4bDt1x1MDAwNsOjwq9cdTAwMTdyUcO6w7Z+NVBQbcOhwrfDksOOY1x1MDAxZcOyw67DpcOGwrNhwoZcXHbCrMOKw680U0jCjsKwwrPCrMOUa8KOXHUwMDEyfMOcw4Ytwr51P8KedWbDsDZcdTAwMTRPXHUwMDEzXFxmwq0owqzCnMKrXFxcXMODXHUwMDA1w6LCrcK5wrRgwq9ZOVLDmzdcdTAwMDJWwoxCwpotwoA9SlRcXGbCvFpeMX10w6tcdTAwMDbDq8O+wrBiwqbDisOvwptQwrvDjjphd8OAPU1KS8OHwo7DqFNDWy9RMXY1PUomwp5cdTAwMWPDkGBcdTAwMTDCoMKQw5o6Vn5+w6DCijPCvsOFwoU7OUd7QGLCqsKiwofCncKFXHUwMDFhw7nCmzc/wpLDgMODwr/CoiVWXFxmW8OdTVDCrcOXw4NNYcK1woHDtMO+OGRZPUDCqD/CjsOlflx1MDAxNcOXwrpZY0x7wpXDm0vCkcKPwpBXw6DCtU7DhcODwrx4w4pQJsOeXHUwMDEww4DDmFrCn8K+woLCosK6VC7DkcKCw4FdLmxcdTAwMDbDpz1Kw649fVx1MDAxOcOxU3FcdTAwMTDCvWpNMTAvXHUwMDAzw5HCvWV8T8Kkw7hHa1x1MDAwNTjDqMKEw7gsPU3CoHgvwrbCvUfCocOiI8Ouw67Ds1EtQ8OLw7XDtkZ3w5crSsKgw5Anw6rCsXZGY8KKw6DChcK1wofCpj1KXHUwMDAzPX1rUkU2w6/CtMOjc8Okw4XDoMKMXHUwMDAxw4g/w67DkirCq8KVw7l4w6YvNFxcdkXDoiDDrsKJw7rDqsO0wrU9fTtlw5nDok/Cu8OuYFfCjnnCnMKOdcOcw7FHw4M8w53Cv2XCrMKMwqpAcsKzIVx1MDAwNMOAXHUwMDAyK8OGdzI2Q1LDjzRcdTAwMTkve8K1T8KVwo9cdTAwMTRqw7Z6McKyXsOMw4vClMKqMlDCmFx1MDAxY8K+UMKmwoN4XFxcXMO9XHUwMDFiw43DtkbDr31nw7LDjnFcXFxcwoFrw6bDr8OWS3LDh8Oxw4NyXFxmwq85csKJSW7DjHPDpsKjOsORUcOIwog1w5diw4N6dcO6XHUwMDFkwpl3aVxcXFzDuMO4d1dQw63CmcO6NMKrwrMrw61Qw64mO1x1MDAxOcOnwpPDsj9+XHUwMDE2wqc9TcOEc1x1MDAxYsOQw6PDrsO8wqzDq8KJQsKtw7vCrsO0NcOATH5fXFxmw7AuKMOxw7pMXHUwMDA1wqXCnFx1MDAxNVx1MDAxY8Kaw6HCvEZtwqlqK8KMw449SjUsw5JqLidjwr3Cs8OCwoXDhnUsw4RzKkpcdTAwMGbCpWtUwq1cdTAwMTbChsO2XHUwMDEzPFx1MDAxYlx1MDAwN8K8f25cXHTDqnLCtcOCwofCjl9Kw4xCwop+asKZw5ByXFxmRUpIwolcdTAwMDLCuMK5bUzDoUfDnEteXHUwMDFlw65nbcOUSMOaw5PDrsKYwpt3XHUwMDFiQULDgjxZw4hGa8K6wr/Dk0bCuytawobCuFx1MDAwZcK8YsKPS8OBXHUwMDFhT8Ozw4/CoklCw5zCpy5bXHUwMDFkc8OhXHUwMDAxw4PChVx1MDAwMX/Dplx1MDAwNU5Ow4s1IcK6O0BVXXHDjMKDYHw/wqhMXFxmwplcXGbDhlkpw4hMXFxiXHUwMDA0wqjDunbCqlx1MDAxMMOrf8KFesKmw73CqMOaXFx2V1x1MDAxZSRrccOXw7XDq3VZfTjDi8KHJ8OqwrhcdTAwMDHCsULDk8KobkFrw79qSTDCrkXCvjNqwr8pw4/CjsKYa8OAwoLDv8KvXjJSa0TCoMOQw6BcdTAwMGbDmsKZwr/Dk8KXQ1x1MDAwNsKXb1x1MDAwNjJcdTAwMWFWw4bCrE7DrcOjwp9JwpZcXHbDpkbDhibCscKXXFxcXFpxXHUwMDEwbiY9fTg+d8OBXHUwMDFhRmrCl00ww583K1/CmsOfacKOOcOAwrRcdTAwMTJZwoAsw5LCtE4yw6FNb1FzwprCpVx1MDAwMyvCmsO3w5bDr1x1MDAxNcODdGYsw4ZwwrIxTjp7W0N8w4PCu8OzXHUwMDEyw4pcdTAwMTLDisOgw45gwq86ZHxPwrpywoHDmsOuX1xcdsO1w7jDvsKww5U3Tlx1MDAwNWbDrUXDlktqdsOBYlx1MDAwNlx1MDAwZSzDt1PDsjDDisO9OyZ6wqrCl1gzwoXDmHw9TcKELMOywrzDk8K3w4Mtw7vCgHJcdTAwMTJJYcKXw7HDsn7DgjhKwoLDgcO2w4fCmVxcXFxcdTAwMWQ9SsKaK33DjcOiwqzCrVhcdTAwMTTDhMOlJFx1MDAxZsO3XHUwMDE2wr9cdTAwMWXDjUxPNcOHw4PDpCTDq8KKesODw4PDkcKiwoE+QsOkS8KUXFx2b8KQN8KaM8K6wrdcdTAwMTRiZXvDhjjDicOOwo3CmVx1MDAxNHPDijXCmGt3fVx1MDAwMnsswrjCssKkN15cdTAwMWZUYVx1MDAxNTHCu8KMIMOQw5hcdTAwMGZcdTAwMTB4TMKdQcKbacKWSsKyw7LDvm/Cjlx1MDAwNMK5wrZvw4IgXcOdTMKIN8Kqw6HDncOTPX1cdTAwMDZcdTAwMTTCjlx1MDAxNHx7wpjCmDnCjS1cdTAwMWFcXFxcwqVpRE43XHUwMDAxw5Zye8OHaj1AwpDCrWpcdTAwMTggw5DCrcOwX8ODZCXDu1/Dv1x1MDAxYT5cdTAwMDZ+LSRsSEg+wph6OFvCs1xcZlx1MDAxMsKkwonDrsOrw7vCtGbCj3nDqMOQw4VjwrvDjsOyXHUwMDE1SjvCosKmJFI9SjzDo1jDtSfCmcKUeVx1MDAxZcOywpNkw5HCnsKaw6NAPClcXHTDjsOKXFxcXFx1MDAxZlrDn1TCsSxcdTAwMWVNw4NOwrTClHXDtMKXd8Oew7nDvsKkwrYrw74pLsKFwozCoTVbwrAowqHCr3HDjCc9QG7DkcKPJ25cdTAwMGUvbsK1w6M1QHrCiyhZXHUwMDEyw6/CmHTDgjxsw5pcdTAwMTkqwpwxwoc2XcOBW8KqOnB4TyQpw4lEKsOEVXo4w4LCtMKMTT1AdcO6LEV9McKaOcKaNGvDhWQmw5HCh03CvcOvKMOPN2wuwp1xwrhdwqHCvsOrwoHDjS1cdTAwMTDDjMOubVx1MDAxZFxcdMOoMcKTw7lcdTAwMGZ2R8KyXFxmLMOCalx1MDAxOWJ9wrVcdTAwMDV7w4ZFP003PX1hOcKtw55cdTAwMDPDusKJJlx1MDAxMcO6S8Ohw60wXHUwMDBmwobCnU/CgMKBXHUwMDFiw5zDvFxcZsOTwpPCjkPClcO4wqDDvMKqw6fChMO3wovDjcKAMsKqwr9cdTAwMDJZw7rCj0zCl0VGw4PDgkR1wrjDqsK5wpMxcMK0ZcKSwq0wVkJSW3h2XHUwMDFmw6JoVsKXXHUwMDE0eFYwXVx1MDAxMkDCrcKHw4w5WDFcdTAwMTJcXGZzVi7ChcKMT8OEw6TCu2hYwpFPPMK5XFxcXF7DoFx1MDAwNmhcdTAwMDIpNMO0XHUwMDAzSMOOwr/DkTF0L8OBwrspwrHDgcK1YcK4TVx1MDAxMDNDUcOYPsKrw4HCs1x1MDAwMsKFNcOOKcO9wq7Cm1x1MDAwN1tcXGZLPU1QWTp5PX3DosK5worDmXHDm3s4bTHCijDCvMKjwpxcdTAwMDbCk8KzXHUwMDFicTA9QMOjXHUwMDA3wpRjXFx0VENJPU1wwoTDv8KKwr5AXHUwMDE4XFx2UFprUW1mwp1ww7xcXHY9SkDCklx1MDAwZcKgVMKwwrDCt25lwpzChsKtR8OEacO2wr3DnMOLwqbDlT4ue1Q0XHUwMDFjXFxcXDojWcOPw67DgcK/PU1Tw70+eXjChHDCgMKrw4DCvGl8w5vDlMKOf3N0w7TCuzRcdTAwMDFmwrTCvMKtw4jDlTY6wpZcdTAwMTAzXHUwMDA1wqN0wrIlw40lXHUwMDEyaMOTw6l8wqnDj8KlXFx2RkbDrDlcdTAwMTPDqcOawpEofS/Dq2PChMK0w741PjdBTjkmIcKpXHUwMDFie8OJPsKGwqttwpzDhWJfXHUwMDFjw5nCucKwLil0XHUwMDFmdHMhIHIhw7LDsibCu1x1MDAxNyhNXHUwMDAxT1HDlVx1MDAxYVx1MDAxNcOpWVx1MDAxOMKtLVx1MDAxOMKYXHUwMDFjwqjCvC/Com40SFxcXCLCoS0hcMOyRsO2c0/Do0xDwr1cdTAwMTTCvSglQVx1MDAxY3BYwrLDnVx1MDAwNFEvwqMnJcKBcMOQwoHDoMOhccOYcXggwrlsIcOJWEhWaytTXHUwMDFhwo5cdTAwMGXCj1LCk2/Cozo9TUjDqMKKwrvDlCdcdTAwMThcdTAwMDVBwoUlwqZSX1TDk1nCq8KAJ8OlwrvDnMKbwpLCuMOmXHUwMDAxUXHDr3rCu8Knw7FSR8OUw5xcdTAwMTHDjlx1MDAxOFx1MDAwN8O6wrnCpzklfMOSw5fCp8KZJMKsXHUwMDEzwrpIL8OoP03DuHtcdTAwMTfCo1xcdm9Jw5TCvMOUXHUwMDEzw53Djlx1MDAwNsKSw5RhwoLDtMO/wpzDsjpvYsONeHdcdTAwMTNdw4/CkSHDl1x1MDAxN1t6V1x1MDAxZlxcXCLDsVx1MDAwM15Tw481aSXClsKKPUDDs8K3w6jDh8Knw6/DvjtcdTAwMTRcdTAwMTZcXHRcdTAwMTHDp1xcXFzDnFxcXFzChMO6d8Kuw6nCgcO2w6NdXFx0wqrCmcOEwr5oT3VnXHUwMDE3w6VcdTAwMDdcdTAwMDHDvVx1MDAxMXVvfVx1MDAxY8K6acKvw6jChcKnwot8eMKcLSNcdTAwMTE/KcOPIUx0IMOWXlx1MDAxZsOfXHUwMDE5bVxcdMOBaFN0wrnDnCxcdTAwMTRcdTAwMTZlXHUwMDA0w6HDnsKZwpnDiTXCj3N5w4DClMOBwoDCumdMJVx1MDAxOShPQ8OTwpHDvsOqPX3DjSpcdTAwMDYkXHUwMDAzIcOYXHUwMDE5woPCiTEmWTfDncOXwr3Dk8KXw75hdHLDgcO9d1x1MDAxZSMpwpJsXcOfw5dhwodUw5/DksKqdFx1MDAxMsOlXHUwMDFicUvCqUpcdTAwMWbCslx1MDAwNCBdacOlw5F5d1x1MDAxNFx1MDAwN1x1MDAwMcOBU8KXwqdpw49cdTAwMTDCnsKYSMOpw5HDmXjDpD1Kw53ChlxcXCLDhMOoVcO8w71ow5EuV1x1MDAxN2VZZ8Olw73CkFx1MDAxYcO0w6h0XHUwMDEzwq7DmcOlJMKZXHUwMDE4wr3Cv8KYJ2jDqybCksKJwrzDviTCiVXDnsKZXHUwMDFlX8O8XHUwMDE1w6U5MlLDvcOpUGl3XFxiw4NcdTAwMDZfY8KPw5zDt8KOw5Bzw4zCs8OBM1xcdFx1MDAwZcOYXHUwMDFiZD1NbsKNwp09TcKxcDXCtibCtmhDWF1cdTAwMWVcXFxcw6bClVrDr8KqwpnDmsKEXFx0wogpwqrDiMOBXFxiM8KHwplcdTAwMDdtZCfCnz1AwpPDlcKUwoHCksOnw7tGw4vDo3Ftf03ChSfCrMOEw5vChMOoXHUwMDE0Yz/Cl8K/wo5cdTAwMGbCh3TDqT/Cpz7DlS9BXFxcIsKmKHpcXGJWwq/CnVx1MDAxY3xcdTAwMWPCtsKGw5tcdTAwMTZow4PCocO8XHUwMDEww7zDu3zCtVx1MDAxMnV6bMOhw6hcdTAwMTbDqcKFwqRJIcKSIcK2XFxcIl3DnSV+XHUwMDAxXFx0XFx0wojDqTXCqUckI1x1MDAxZMKxw7HCucOcXHUwMDE5UcOpU8KmRSfCn1x1MDAxZsOBwqHDh8KIw4fCnWhpJVx1MDAwZVx1MDAxYsKTw7vDscO4OcONaFx1MDAxNsKlw5klwqhcdTAwMDTDpcO4w6FcdTAwMWLCmcKZw6ZDJFx1MDAxMMO2XHUwMDE1wqpcdTAwMDFcdTAwMTHCiDfCqcO/KFxcXFwjXHUwMDBmw7lBXHUwMDFkwohcdTAwMDLDqGIhwqbDvMKdXHUwMDFmXHUwMDExXHUwMDE2w53DhsKRw4DDuUhpwpfCokQpw74gXHUwMDEzw7nCuMKdRzdHw69Hwo1lw4I4XHUwMDA1OFx1MDAxNzjCqMKxfjHDv8ObacKzNFx1MDAxY8KaWj1AfE7CmsOOw7jCmcKIesOAP0k7TsKew59hw797e8OKw6hmw6fCoyhcXFwiXHUwMDE4d1VcdTAwMTF/w4F4c8K5SWVUXHUwMDAyw7HDvcOPw4nDn8ODwrvDmMOQw5RMecKAwrRkUnl7UcKrXHUwMDA0wqrDssOJwrbDhsOYZjJFfsKHw7vDunjDk1x1MDAxMcOBwrTDp8OIXFxcXCfDgcObJVx1MDAxZsO9NMKAcFx1MDAxOMOAXHUwMDFiwr0pw5fDlMKWXHUwMDA3wpUgecOodFx1MDAwNGBkwrTCp8OAaDBcdTAwMDfCh8KmwqExX8KyVsOOwpPDo0ltMSckXHUwMDE4aCbDpWzDmVx1MDAxZcKiwq1IwqfDhcOrw7zDqcOPw5J6K1x1MDAxOcOhwqDDqcKYwqPChcOIw6hew5l1wp3CjMOBwrZcdTAwMWXCmcKlwqdcdTAwMTTCtcKDwqrCvsO4wokhKMKpf8OOJcOeflx1MDAxN8OkN8KuYMOcaVx1MDAxNsOxw7TDusKpw6fCp1x1MDAwZsKkJCjCrsKiw7rDqV5QQifDjD7CvVx1MDAwZcKOPmjDkFx1MDAxZSkwXHUwMDFmwrzDnj5cdTAwMTnCp25cdTAwMWHDkUknw71cXGJTw5LChWVcdTAwMTV6w4fCq1xcdlx1MDAxOS/DnGk0w57CqcKhXHUwMDE1PsKmw4HDgChHwpFSXHUwMDFkfU/DviV1w4l2Q2LCisOXTcKewol1U1x1MDAwM1XDg8KSXHUwMDFmwqJcdTAwMWVcdTAwMTlcdTAwMTXDnUIjd8ONw7XCoVx1MDAxNsOZw5nDhFxcXFzCiy3DiMKVfMOtw45pw7UoXHUwMDE0QSXDhVx1MDAxOMO/SMKMw7xHwpEhwoc9QMOwwonDn8Kxw5DDpMK1XHUwMDA3ScKoXHUwMDE1YX9cdTAwMTB3w4LDlmrChMKIwrRcXGZcdTAwMWLDscKsXFxmfcO4asK/alx1MDAwZXnDu8OsZWbDncKkw7fCq8KVWX52XHUwMDA3bVHDgFlcXHTCp1x1MDAxYsOTwrDDp1xcdMOiU8KfRcK4wobCqcOPw5JcdTAwMTE8w4Z6w6bColx1MDAxMcKvUSQnwrBuecOTwofCpT1KXHUwMDE0fU9cdTAwMTdrw41Qd8KFwqc9Slx1MDAxNDU/w6fCqGjDu8KjXHUwMDFkw6DDh8Kjw5bDi8O1wrZ4WMKIw6LCt8KXXHUwMDAxYMKbQ8ODwoTDpsKmJVx1MDAwZlx1MDAxMcKEcMK4w6jCvcO0w4BcdTAwMTdiw73Ci2bCisKCbMOzw6bDt8Oxw5jDqcO+w7pFQmJowqkow4DCvTlcdTAwMWXDt8ODwoszwq81w6HDiMOkw5HCkVx1MDAxMDtCwr1lwqlcdTAwMWTDg1HChFx1MDAxMMOYw6szLzXCocOGwqPDlsKTXHUwMDBlXFxmScKHw5rCilx1MDAwNVx1MDAwM3FcdTAwMDRQw7jCqMKbL8K1PUpHw6TCkMOYw4sjXzcxWMKewpJDMHB3VMKFw6Qnw75nwqfDnWtoXFx2L1XDhMOYZl9aIcK3w7XDlsOUXFx0wp89TcOTw5DCqMKafFx1MDAxOFx1MDAxZX/CpVhmWsKhOsK4QmnDj8KoXHUwMDE5w7/DgWRwwpgzwo/DnWBcdTAwMTjDqSjDvFx1MDAwMlx1MDAwNMKNwobCi3/DrcOoNcOZw5/CtjDDilvCvVx1MDAxMcKXwpbCo8KWPUpGw4Rkw43CiynDg2XCmcK2w4bCsFDCv1dcXHTCnVx1MDAxOFxcdnFdwqVcXHZcdTAwMWFcdTAwMWJPXHUwMDFmw6XChMOJRDfCtMO0w4PDo8KUJcKzw6BcdTAwMTHDpMOwLU3DkFlcdTAwMDXCnFx1MDAxNlx1MDAxY3VVwpHDicKyw57DrMO/wqVZw6g0PX1cdTAwMWHCo1x1MDAwZVx1MDAxZMKDXFx2w50sw4lcdTAwMDHDjcOKLXHDqyx3wqheOcOrXHUwMDAzwpE0XFxmw7lMwq/DrWZ1XFxcIsKyXHUwMDE5T3HCslx1MDAxMcOswoXDisKiwrdZaCV2w4tzwovDl8OswpfDosKZX8KZZcKGwrXDgMKmOlk/w5hYwoFcdTAwMTQ+wrbCrlx1MDAxNVxcZsOew7LCpcKYVVx1MDAwNnpGw4xyXFxiwpzDiMKlwpw7wqYmPlJ/woPCv1AvwpnDqGHDiWZvw4g9QMKBw4LDjsOifTtcdTAwMWLDhD7DpMKiw73DomE/w6snwqbDj8KfdMKFXFxcIsK1PUrCp8OVS0HCssOhwoDCi8K6wqw1WcOJw5HDrcOnY8OJJcOWwrA9TcO9w7TCuMO0w73Conk9SsKyw6bDoTFcXGJtU0Z8wobDk8OiwrzCmVbDgjnCoSHDqsOjwpE0TT/DmlxcZjXDr0AoeSjCpsOyXHUwMDAxwpfCr1x1MDAxZMKawpDCusKsw5HCisOdSsKueVx1MDAxY1x1MDAxOcOswoUuXHUwMDExw7htKMKAVMOAVcKwXHUwMDFhXyPDuT7CkMOqXHUwMDE5UFxcXCLCtsKxJsKnfGYqIyfCgWB8wrhLwrRBPsKBXHUwMDFkwr49Slx1MDAwMUPCoiHCi8OyIzbCryd0YT4jw6ZjJlLDqMOCacOAw6bCuzTCm3TDl3TCuS/Dh8KsSMKvMCNQM8KhwrBVwoNVXHUwMDAzUsKyXFxcIsOILHzDjMKRNFx1MDAwNcKjScKiwqXCvlx1MDAwMVNfw7JRXHUwMDFkw60ueWLDmMOWwrDCplxcYjzChsKqITA1OFx1MDAxYVFrwqhpVUbCrUZ3woA4e8KoVcOpQVx1MDAxOMOGLcOjZsOtXHUwMDFiw43CgMKbwrbCvDVcdTAwMWFbwoI6VsOawq7DpsOGwoFSLCjCg1VDNUhcdTAwMWPCn8Kiwr3DomYlU1LCq1x1MDAwNsKlw4p+b2rCskEsw7nDuVxcdsKha1x1MDAwM8ORK1x1MDAxMcKZwp1Pw5/Crlx1MDAwNmLDq1x1MDAwM8OxwqzDh8K0aVxcdsOnXHUwMDA1S3fCknDCq2XDrVxcdkjCm0jDuFx1MDAxYVxcYlx1MDAxY1xcdMKsXHUwMDFlXsKrwpnDm8O0f8O0w7E+JMO1w7l6wpJcXHbCmVxcdlx1MDAxMVx1MDAxY8OZwq3CvlxcYlx1MDAxY8OxVMKYwqvCnsK3L1x1MDAwMcKrTcO7XHUwMDFhXHUwMDA2NsKvwoUlw4B+wo/DsMK5Q2dcXFxcfmJcdTAwMDLDvcOtwp/CqsOdw43Dp8OHw5fDn8OPw6MzfsOSwqbCk8OEXHUwMDE0JVx1MDAxYifDrVx1MDAwNcORIVjDncKlwqDDmcKJZMOdwqZ0dHbCgsK6IWoxNW13N8Kfb8KrVsOfwqk9QMOGT8O1w4HDmMKGw6hbXFx0wqlcdTAwMWU9Slx1MDAwMj1KXHUwMDBlwpvDm8OaXFxmw5rDqD1KX8OXdMKUwrFOaXV1wp11XHUwMDFhwpLDg8KxOcObRsKSw4jDiTxCOsOaUU9Kw6pcdTAwMDbCoXZqwq7CjyhcdTAwMDY/w53DocKBSWnCnMOhw5jDpMKVXHUwMDA1w7tcdTAwMDPCk1PDsysrJVx1MDAxOElnw6QnJVx1MDAwNz1Nw7HDocKpacKoJsOrw5bDviRNcVx1MDAxNVx1MDAxYzlcdTAwMDHDmcOCwoPCp1x1MDAxOcOywrtcdTAwMTfDhVx1MDAxOFx1MDAxN8OSw4knw6dcdTAwMWLDssO7XHUwMDE3w4VcdTAwMThow6Npw5XCpyjCsyVcdTAwMDXDqMO5w4fCg8OpwqdcdTAwMDXDlsKxOcKQwpnCpMKaXHUwMDEzwphcdTAwMDfDoMKNacK5w7jDuGkkPUpcdTAwMTLDllx1MDAwZVx1MDAwZcOEXHUwMDBlPlx1MDAxZMKqwqpcdTAwMGXCqsKXw4FJXHUwMDA3XFx0w6DCn8O/w7bDnsOqd2nCocO+w7fDmMOVw6kpworCoFxcdFxcdFxcYnnDtMO8worCk1x1MDAxZidcdTAwMTfDo8KZS2hcdTAwMTLCmEVWw61HJmY/w65RMWdJOMK5woA9SjhcXGJJwrLCgE0xw6llwqBOQsO1wrrCpWhew6/Cg8OzbVx1MDAxNlx1MDAwNHNtw6tRT1pcdTAwMTPDkMO1V1x1MDAwZcOkwqZJw7DDlcOuwp0xw5HDrFx1MDAxZsKsSMK7wq03S1x1MDAxMMKoRT1KJXBvwrLCrcKRPX1GwoZWOcKcIMOEMDHChcOcbWbDg8OeRcKnwqfCqXTCp1x1MDAwNy3CvMKhcjZowrRcdTAwMTQww418OMKywqbDqlxcYlxcZmjCgcOrw5Jaw49cXFwiwr7CkCnCjlx1MDAwNMODcXtjwqbCtFx1MDAxNC5tw7DCg8Kzw4xwK8KfLCNSfcO+LErCo0fClcOhS8KNwrxcdTAwMWTDkVlcXGLDmsOZw49cdTAwMTfDs8KRT2dlIUtcXHbCs2PDjMKjwpXCoEbDqSZcdTAwMWHCrTTDvsK/w6w7w5vCvVTCkMOYXHUwMDAywqRcdTAwMWVcdTAwMTTDvXjDqMOAw481REPDgcKHW8Khd31cdTAwMWTDv3FJw79ew5fChjHCuULDgXvChMOdwpbDvcK7w5VHw4fCpj99woEpw5pcXFwiw4bDlMKjN3fDt8KBSMKoesO6w5zCnFx1MDAxZkfDg8OCwoVbw5XCqFx1MDAwNSjCvVx1MDAwMVx1MDAxOVXDlMOCw6XDjTt7w4PCr8O9w4HClmfCpCPDqzF/N311wrnCu1vDg8KvXcKBXHUwMDE3YsKgXHUwMDBmXFx2ccKrw4vCrVx1MDAwMcO6wptcdTAwMTPDr8Ofw7VgSWLCnVx1MDAxZFx1MDAwM0Fjf8OdKFxcYsOtwoxddFx1MDAxNcKAYUhnXFx0KH7DisKLXHUwMDA2w7k9fcKYUsOTwofDu8KiXHUwMDE2w7wnwqHCtERwJ2fCrcOwUEHCgVlcdTAwMDPCplx1MDAxMiZcdTAwMDfDocKUZEAnZ2zCjVHCvz1AasKow5lmKMOSw5ZcdTAwMTBiMjdFw4HCu8KBw6fCpsOxwrPClcK5ZMOre8KRXHUwMDE1O15gw5/DksKYw7/CuFx1MDAxMMOVwrlpw5TClMKCZMKlOMK5dFnDlsKIw6BcdTAwMWZcdTAwMTLDjyVJPsO/wrZcdTAwMDbCrMOsUMOOf8O2wobDpFx1MDAxM8O6w69xSX82w4fDgsK7M8Kjf1x1MDAxZFx1MDAxNMOhR2LDvyBcdTAwMGXCvcKsw5zDm01dwozDrMKOw7smw5/DpXnDoGgjw5bCkGbCqkNDw4V7fsOnwppcdTAwMDdYIMO0w60hw7REw4DCuMOsXFx2W8ODT8OdwoBcdTAwMTfCrlx1MDAxZWlTw5TDhWLCpDnCucOzUsOHw5/ClMOxXHUwMDFiVcK5aFLDk8ODYjY0NnnDh1xcXFzCp1PCvilcXHZxX8KXNcKlw5k7PU3DncO1wpFcdTAwMDHCmWnCm8OXw419a8OvXHUwMDA2w69pZlPCmSRMwrrDsVx1MDAxZsK4w7l0w5TCoMKoS8K7wpvCvVVcdTAwMTXDgMKXZsKmXHUwMDE3XHUwMDEzQV9nw5XCq8KSwoLClnR7XHUwMDFmwqzCn8OlXHUwMDFiw5dcdTAwMDFEUC3CpsOtwr01wpBWwojDqVx1MDAxNVxcXCLCr1x1MDAwNcO5w6nDlMOFNjZCw4XChHpbwpVcdTAwMTPDsMOnTsKpw5RweMOsXFx2w7vCvcK0PUrCsGfCusKIw5HCtMOAwq/CtVpOXFxcXEvDpcOSwpRcdTAwMThcdTAwMTjCnSFpwrBSwpEzKGnCp0DDrVF1wopWwoLDisOSw47DokTDlMOoeMOrU1x1MDAxOG3DuMOJPMOWwrB0w7RCaMKFXFxcIsONfsKgw5PClkDDvlQ9QFRAw6xnw7AsQcKSMMOywp1cXGJ6wqdmXHUwMDBlwpEzeFLCv1XDiDzDglLCiMKwUSjDj3fDlGJcdTAwMWLDkcKvw7nClMOaRMKvwqxJdMOIw7pcdTAwMWVSU8K8wrTCkVbDpsK5fmZJwqJXesKnN8KBRcOOZMKxXFx0w6zCiTfCmU9cdTAwMTPCmEDChijDicKew6BcdTAwMWFXwr9ZbcKYcihmL2kjw4fCulxcdFx1MDAwMcKaw7ktw68xwrTDhS/DiT7CoTVcXFxcXsOBwpPCpj1KXHUwMDFiwr/DuMOrRcO0P8OfP8OHwr9gNXJcdTAwMGZYwqw0w7rCgsK6w7XDqcORXFx2w5BTw5lowobCl19Zdlx1MDAxYUTDtMK7w4pSXFxmwr1cdTAwMTRcdTAwMDTCgmrDmMO5XFx2w6VSMMKdw4ZcXFwiWcKBw67DhiPCoWZzw59AXFxiwo4swo9OXHUwMDBmw7PCrMOmwqI0wrxLwrlOw6lcdTAwMGbCtMOIwqxnw7TCpcK+wqFUw4TDqmdcdTAwMGXClFrDhlnCrsK+c1x1MDAwNFx1MDAwZSjCjsOoXFxcXFx1MDAxYcOZwoDCu8Kaw5c6XFxieXx+fE5cdTAwMTlAwqleI8OcVMOHVHB0UcK+w57DiztjL8O5w6TCqmYyXHUwMDExw43DijbDsHrCjC13wo3Ct8K/wrTDnFTDo3QzwrTCi8KsW3TDj3TDjnPDs8KvXFxcXMK6w5VXwqZPw7/DlcO0OcKqw5HCjMOYwpFrw7QxSsKHbE4xacOLJsOWw7DClcOrZ8OPw4fCtMKuKcK/esK8WsKSw5TDssKxXHUwMDBlw6zDhcKpwoVcdTAwMWbDoMKUacKSw7jClMKrwp3DuHTDvMK0w7xcdTAwMWF3XHUwMDBlRi/CmVx1MDAwMyxcdTAwMTPCoWzCk3Ndwp0qYkQwecK5wqrDuSw9SkzDu8OBw6/CmsOJwrjDhMOnNMKjYcKjRcOzw6HCglx1MDAxOFx1MDAwZcKFwqbCoF1mw4k2KcKZMDPDpMOqwr1Nw6JRwoHCncOJVnLCn8KwXHUwMDE0SsO/ecK0RHTCrlxcdMOrXHUwMDA2wqdOwolOwqFcdTAwMGVcdTAwMWTDgFxcdDMmTVx1MDAwNinDkTtcdTAwMGUpwqlcdTAwMDHCrMOLXHUwMDEzwr7CgcKpw4zDgMOKw4LDlW7Djj5QwqI2XHUwMDE5SmNPScOswq1jJmvDlHfDqsOLOlx1MDAwZlcmwrHCmsKpWiHCmMK8LMOjwq3DjnrDjiR2w5PCr8Klw4ViXHUwMDExKcKnwrViccKYw4TDiETDoT/DvMK+w5hUWcKBw7zCqsOwJMK9XFxmwpzDjzvDqsOtw7/DusKuw6HCqijDgVR3fsKgK8Kdw65ywrPCkkHDsy9rPsKjwoTDrikqw7cgwpDCok3Cu8OewoJMbsK9w69mRitkbVx1MDAxYcKAMyROLHhpLlx1MDAxM8ORU1x1MDAwN31cXFxcXFxmTm/ColVcdTAwMTBcXHTCj8OiTcK2bVx1MDAxMMKUYmDCq8KVXHUwMDBlVMOjTMO4XHUwMDEzUj/CuzTDu25Nw48vwqrCszHCusOlwoxcdTAwMGbChlrDtMKQwqpzw5DDs8KhXFxmacOnwpxcdTAwMWLDslxcdlx1MDAwNzfDlcKAPUBAXHUwMDBmXHUwMDBmwpDCkU9Pw7DCtzZCXHUwMDEyXFxmXHUwMDE2XHUwMDEyworClMKMw4rDuMOBw5AkKMOmwqnCn1x1MDAxNVxcZsODbcKFw6HClsKGaMOVVmVXwqTDrlx1MDAxYcOqS8OIwrhcdTAwMTDDpMKELGPCg0PCk8KUIcK8wp/CpSBfXHUwMDE3XHUwMDA0w57CoVx1MDAwMcODbVx1MDAxMXhINMKKJsOmwq01w7BuQcO4woZowplcdTAwMDfDpsKkw7Qhw5rDpz1Kw44+w4fDhizCl8Ojw4/CoybDkMK2wrDDjTHCuMO4eFx1MDAxYlx1MDAxYsKtw6DDiMOMd1x1MDAwNcKQw7nDr1XCuD1Aw5HDr1x1MDAxOXJcdTAwMDXCvMK8wrx8w7dcdTAwMWbCsH9/w5N7woNNXFxcXMK4w7h4w4dcdTAwMDLCoMKVXHUwMDE4XHUwMDE2w5DCv8OPw5PDgDzDmcKuw51cXFwiXHUwMDA1XsOKw6DDnsOSUsKfcsKMasKUwpvCi8KLdHrCjMO3w7ZfcTjDl8OGwofDvcOgXHUwMDE3IcOaXHUwMDEwI09Dw5Atw7I9SsOCw4TDvsK3IcOddcK5PUDDj1x1MDAwMU49QMOQR3Row6bDjVBjWkrDusO5w7nCpsOkw7nDgMK+KnXCksOPwpU9Slx1MDAwNVx1MDAwNlx1MDAwNsOZJD1Aw7nCsFx1MDAwM0NDe1PDsznDtMORPUA/w5DCgHnDk8OXdVxcdFvDs8OvwqZ9JVx1MDAwNiNxw4HDgcOOw4heQcOpw6lXwpVcdTAwMTJcdTAwMWLDhMOYw5/Cn1NcdTAwMDPDlTTDjVBAd8KuXHUwMDE4w4nDj8OPwonCqm8mw5DCvsKOw4LClMKLw6DCnz1Aw5jCvlx1MDAwZTJTw5NcdTAwMGXCtlxcZkzDtcOdw6TDulxcXCIhwqgxITrCkWXCnsKCwrU5KMKGIT5cdTAwMDU4XFx0eTlcXHY4KMOmYzxLw7nDh1x1MDAxM2ZAw5PDtkfCplxcYkHCjVZ1wrbCslx1MDAxMcKlwr1fPUo2wq5TMjjCrcOdw5DCmcOfw7ZUw7jCjsKiw4jDjDzDtUdcdTAwMDY4XHUwMDAxNyhqOMOAN2FtXHUwMDE3XHUwMDFhw7fDgMKuZMOiScKvwq1Jwp9rOMKtwpHCvXXDvSfChiZcXFxceMKrO8K7aVx1MDAwNsKneiNpwpE7L8K4MsKTXHUwMDFhw4TCtcKXMMKDdENowqbDgmJMN2dhSMOia8OOw5NCw7jCuHrDj3zDlsKhw7rCl8KKVcOewqvDkz1Aw5AzLMO8LMKFwqzCumDCnlx1MDAxOcKqXHUwMDA0wqrDssKJcXhpP3zDsMOpSXnCgDFcdTAwMTTDssKqW1x1MDAxZcOWwohSwqrCmsKuwr0nL1xcdFx1MDAxM1x1MDAxOElcdTAwMTlYMcOjXHUwMDAywoXChcOCw4NCQ0RcdTAwMTJcdTAwMTVcdTAwMTNcdTAwMTTCksKVwqvCl8OSw5DDlMOMw5bDjjLDh0UvwqPDjHpcdTAwMWHDolx1MDAwZVkgPMKlIcO6wr1/w7nCgMOpVChaXHUwMDFmJcK/w4jCq8O8X8Ksw4NEw7PCpFNwbXcnwpZgN1x1MDAxNCRcdTAwMWZcdTAwMWTDsSHCoWFYwofDpsKawqBcdTAwMDFcdTAwMTLDq0hcdTAwMTjCmCfDn3NcXFxcXHUwMDFjwr45wp/Co0PCn1x1MDAxMVx1MDAxZcOAXHUwMDFjXHUwMDE2w7tOw4dHZD7DnzXDksOCw5RcdTAwMWXDi1xcYl5cdTAwMWHDk8KBw77DoXFROWxcdTAwMTNlw4vCnsOzw75/wpnDtMODXFxcXFx1MDAwN1vCsGQzXHUwMDAxw5nDmHTCm8OPwphcdTAwMTnDkkY9TWrCn8OGwobCgUM5KCDCjsKFf8Kjw5rCmcOTXFxiXHUwMDE4XHUwMDE5wpnCmUfChGDDp2Jlwpt2w5ohKsKFfWc3P0/Dq8Kpw53Cp8ONXHUwMDE3XHUwMDA0XHUwMDBmXHUwMDFkV8Kxw6HDt3VFZMO6w7RqfcODWVFtwrRcdTAwMThWXFxcInBpw6PCosKiXHUwMDE1wrTCg8KPwr09fcOxwrg2wo5mwoYkXHUwMDAzwoLDgkJcdTAwMTLClMOTw5VUVVx1MDAxYz9cdTAwMGXDosKxeVx1MDAxNsOTw4l/wr49Slx1MDAxOcOKw7nDkWBBwrc8ZMKDaiw9SnLDtW9GVcO0wodcdTAwMWbDv38oOcK5w7jDj2XClClcXHRdw6FhXHUwMDBlwrE5wqBaw7/Cr0XCo8KaeMKEwrQkwqZmwqnDmsOLXHUwMDE0KVxcYsO9J1x1MDAxY27Cl8OOw5XDm8KwPMOmwoDCpsOQXHUwMDE1J1x1MDAxN8ONw5VVfcOtJzBcdTAwMDPDhVx1MDAxM8KVw5NTXHUwMDFiw5PDqcKHXHUwMDE5w5nCl1Q2XHUwMDE3wpnDisO0w4FBXFx0w71cdTAwMDFcdTAwMDVcdTAwMWYjS8KIwodew7DDvXRxwq9Vf8KJXHUwMDE5w4nDiUnDicKGXFxiw6nDjFbCm8OCw6XDl8K7w4A0e1x1MDAxZcKJOWF2XHUwMDFjw6FhfsKBXHUwMDBlwrtMa8OzwocuwpTCiVx1MDAwMsKnw797bVx1MDAxN8K+w5NRV8KVXHUwMDEwdlx1MDAxY8Oee1HDlcKrw6pUPU3Cv37DpWdcdTAwMWbDqHzCtSTCqE7CgmonwpjDmcOew4HDkcKoaVx1MDAwN2h0ecOAJFx1MDAxZFxcdsKGwq/DhcOkXsO/J1x1MDAxM1x1MDAxMFx1MDAwNMO7QFTDnH4hXHUwMDE1w7VcdTAwMDVUw7E4w7zCvcONwqRoXHUwMDA3Z8OkTl3DssKAwofCsFx1MDAxNCcgXHUwMDFlJsOAw7TCknk9fU/Ck1x1MDAxNFx1MDAxOcO5w6HDoThZw7g0XHUwMDEzw5HDrcKxw5bCn8KhaGMxwoHDpsO2flx1MDAwZjLDoMOow6nDqMKbwpp7IMOaKMKkwrQuecOnw6lpZ2TDncOTXFxcXD1AXHUwMDA1bMKHwqtcdTAwMWXCg8Kkw6XDqMOowpZlw5pSwqXDosOdwqtcXFxcO1xcXFzDllx1MDAxYyvDo8OVw4zChMKHw5I5f8OEw77CucONw6vCpsOUXHUwMDE1wqDCv8OnRsO/J8OWW8O0asKwJFx1MDAxZCDDvl5wfcKwXHUwMDE0KMO6w6RYw7NzN1x1MDAxNMOxw7jCpcKxw5DCsVx1MDAwMzMywpRcXHTCiMKGw4VLw75ORlx1MDAxNcKkwqXCl8Klwo/DjsK1OMOCJ8KnXHUwMDA3w4lcdTAwMThHwoXCvEPCksONeFx1MDAxY8O9XHUwMDFkXHUwMDE3XHUwMDAzL8Oyw4fCscObPFx1MDAxM0RcdTAwMWUmwqLCp8OHw6ZcdTAwMDdzeWrCqCAoKFxcXCI9SsO+w7DDtFx1MDAxYsK2wr8ww4HDpcOpXHUwMDA3wonDiMKHXHUwMDA3w6XCmlx1MDAxY3LCgcKNP2N8NcOWRcOuXHUwMDBmXHUwMDE4w5xFXHUwMDFmw5h0wrEkwptOwq55wp9cXHTDk8Ocwr3Dj8KkXFxiXm9cdTAwMTR0fcOnw4dBw5RmfsOOw5JcXGJcdTAwMTkhYHfDmlx1MDAxMMKtw4FcdTAwMWXDscOdXHUwMDEwXHUwMDE0Si3DsnBcdTAwMTnDuVx1MDAwMcOBXHUwMDAxw5DCpVx1MDAxMsK6dibCqMKpwqUpwrZbeETCrk3CqcOpZ2TDn8OgSsO6dMK7w5XCocKow6nClS1cdTAwMDfCoT1AXHUwMDEww6RcXFxcwqnDpWVJYFnDt1x1MDAxYcOhfk9ZwrHCtFx1MDAxNVx1MDAwNVx1MDAxZMK1wrrCocKhTU/Cg8KbwrcgXHUwMDFkXHUwMDA3wpfDrMKhMcKXaMOTw7HCisK/QsOyXHUwMDA3Xlx1MDAxNMKsQVx1MDAxZsKkw4RocsKgw6JMw7/Dv2jDtytcdTAwMGUgw5BTwrRcdTAwMGVcdTAwMTjDtVx1MDAwZlx1MDAxM0jDtHxKw5lxwoVRwoJSamfDu1x1MDAxZsOQwo/DhMOZOMOzw7DDicO5YWFOY8OUOlgmIyBcdTAwMGVcdTAwMDJcdTAwMWXDi8OawoA9fcOxw4rCgcOBRMO8Z8Kfw6MmXHUwMDFlKMKkXFx0w6jDqWTDjMOJwrDDosOcLmvDicKDw4Vdw67CvMKNN1x1MDAxMklcdTAwMWHCnMO5w7ZcdTAwMWJcdTAwMTgwLMKbX1x1MDAwNVx1MDAwNVx1MDAxZCPDu8OTwrDCrFxcdiBcdTAwMTTDhjwlaMKdQcOScsOzXHUwMDFjwr5fN1Ykw6MjwrBww5E/w7/CrMOiZy7CkVx1MDAxM8OpLSZtccK5eWRRelx1MDAwMV/Dm8KeXHUwMDE2XHUwMDE1XHUwMDE5YUzClGzChMOFw5zDgMOTZ8K2w7l3csO1w7TDs1UmZ8KSw7LDksObwptTKcOGIF5WwplOVyfCucOqw7XDl1xcZlx1MDAxNlx1MDAxNMK3eMOIw6jDvFx1MDAwNCPDl8KxYsO3w6Npw7hcdTAwMDU5wqnDrkV4w7hzRsKxKUMzSsKYcsKcw4jDosK2w7NnVMK8XHUwMDE1w67Ci3BcdTAwMThPw5jCkcKcw4lqXHUwMDFjNsO+w6pcdTAwMDYnw7rDjT1Nw4jCr8KIRiFGXHUwMDFlXHUwMDE4SjdcXHRcdTAwMTXDiMKsKsOJdW02wrAhwrfDiEDDp2nCm21wwqYrb8OXwotSw4kzNsKffMKww4tUacOswpvDh1x1MDAwMsOFwqjCnGJ+VsKBwq/Chlx1MDAxOMKSdHlxwrTDlFJVw7TCtMOcw709SsK7ZMKVw6fDgUpIwrA7TsOJw6nDrlx1MDAwNXknw4/CpMOPTlxcdFouw7rCgcKTLsKHcn3CtFx1MDAxNMKrwrBcdTAwMWLCqj/Colx1MDAwNUsye1x1MDAwMcKrw4zDuGpSdWlRwrTCpC0+NcOXXHUwMDFmYMOKOMO8wpQ5wqpcdTAwMTVqw4BqXFxmXHUwMDFiL1xcdF1RU8OrR8K1wqnCrUMpwqkkKcO9KVk8K1IrWitWK1ArVStQK8OdRMK6MDrDgnRaw6Zvw6vCqjtvQyorwqBSPX1cXFxcw4M/wrLCtm8rwqhSRUplSsOqOjMxw40qaS5dwr5Vw7pKSsKhSnnDisOrai7DocOuWlx1MDAxYS9Mw53CjMKxKi8rwq8qNy00L0QzPjA+OF4wUjTCkkZ6NsKDaklSOFLCq2JcXGLCqlAsw48sw48two8qwo8rdzDDtC/CrMO7dTRcdTAwMTQ7w5Qyw5Iuw5LCvsOCTWpMw4pUw4pcdTAwMTNqXcOyXHUwMDFhRnpHw7rClsOKw6NqXHUwMDFkwqtALFcwwoQ0w55GwpJPemfDukTDisOfalx1MDAxNcKrYCzClzBcdTAwMDQ0w75yw5Zfw4pQw4pcdTAwMDdqwqXCqyAtRy5kNsKePlx1MDAxMmJhfjDDlU0sw58qw4cwZHXCsMKdwqpYLMKHMMOkNMO+NMKeR1x1MDAxMlDDusKXw4plaiHCqkgqZyzCpCxcdTAwMWU+XHUwMDEyY8O6dcOKXHUwMDAxasKZwqtcXGItwqcuJDZcdTAwMWUvXHUwMDEyRcO6OUpCZcOPw6TCqigqXHUwMDFmwrwrfsOYRyojLWstcGs9fXVcdTAwMWLCqsOqOsKqwrNvSsKpSl9KN0pXSkdKZ0otSk1KPX1KXUp8K8KEK1x1MDAwMypcdTAwMDMrYypjLMOrVGzDvipKwoHDimtqw5rCqkJcdTAwMGYzLlx1MDAxNcOew6rDukvDsknDskHDsknCkjJ6Onoyw7paw4p6w4rCu2rCi2pcXHZqwo3CqsOMwqrDsCs7w4XCqGZ6RsOzw5FuUcKzXFxiO8OHTMKkbMKOeFx1MDAwZXDConhcXFwibsO0blxcYsOFL8OeQ1x1MDAxMlPDs2HDnmQ9fcKrw4TCqsOkwqpsKi7ClcKqwqgqwq9rdcOfQXI1ans4XHUwMDFlQMKSRsOewoDCgcKrwrAqcsKEwqrCpsOLwq9lNT40wqrDozHCvjhXwoJZw7p8KsO5KsKSXHUwMDFmw5gtw6vCrsKDw7QywoTDpsK1ak8qUHFcdTAwMTLCpcOmLsKEOcOKdHoxw4grw5poLEfCryhyRyrClmZcdTAwMWVrMCvDssO+wp5rwphqw6HDi8KKw7ckw4p9KsOiwr/CsMOKwr0qw6RDw7DDisOdKsOmVMKSw6LCkCpcXFwiXHUwMDEwbD1Nw588Klx1MDAwMjJcdTAwMDfDtcKQKlxcdsKXwpXCokDCqsOSMDZDwo45wpMsQlx1MDAxNUrDlFx1MDAxZVIqXHUwMDFjwo3CqcKiUV7CjjMqw7RcdTAwMWZYwrpBKsOQTSrDncOuN1x1MDAxYzI9Sl4swppAw6o0MVx1MDAwMSvDii3CqsODdcOLw4tcdTAwMTcvwrrDkC1yXHUwMDE5I2vCgy3DisO2Kn7CiSrClHVaXHUwMDFhwoxSXHUwMDFhLsOqZDjDqiTCoC5cdTAwMWHClD5cdTAwMWE2JFXCpSvDmsKLSsKyScK7w6rDvcObw6pcdTAwMDXCkj1KW8Kqw6AzamU7asKVMMOKwqfDhDLDnHIww4PCqmtcXGbDgzBcXFxcw4Quw5wsPUpILj1KWC49Slx1MDAxMMKsOsOxKsKawq8qwoZlKsOYSCrCgTPCqlU1w6rDjyvDosKKbHzDnCrChk8qw5hIKlx1MDAwMTjCqlUuPUrCuCs9Slx1MDAxMCzCmkHCrCxGLj1KaCw9Slx1MDAxY8KAw6plwoDDq8OlwoDDrWVFPUpcdTAwMDdcdTAwMTVKOSpcdTAwMDTCsypcdTAwMDRQKsKXQcKqYMKOUVx1MDAwZcKfQVx1MDAwZcKjOVx1MDAwZUcqw6VBwr5xXHUwMDE1MsK+XHUwMDEzQsK+XHUwMDE3LsK+O8OqwqQ/w6pkXHUwMDBlNsK+J0ZcdTAwMWEqwqrCpEDCqkTCpDfCosO9MGYswrogLHLDgVxcYi9cXGIrasOZwq1cXGY/wp4qeSvDhkErw4ZPwpnCqlx1MDAwMSrDtsOBKsO2XHUwMDFmw4dcXGbDpMK5w75nLsOdTy41w4rCrcOow4rCpcOfw4rCocO6d8OKJMKywrjCq2jDpzBnXHUwMDE0LFx1MDAwNzvCq8OIwqrDp3bDs8KtSFx1MDAxMsKrXHUwMDA2W8Oyw4Mww4PDqDBDw4DCqsOmw7IwS1fDrVxcdsKjPUrDo0hcdTAwMWHCgcK+M8OpwrVcXHZkXHUwMDFhw5E1XFxcIsO6w6ErXHUwMDE4wrHCnMOzbShcdTAwMWZcdTAwMDRcXHbCp3p7fmtPXHUwMDFhwoTDh8OQdCrDnjLCqlx1MDAxMkV3fcOfI8KKdVcqPU3CnVEmw6h2fcOZXFx0azE1JMOpw4wofH7Dv8KSU3TDqEJQOMOWwr/DjFx1MDAxYcKjWsOPw6h0e8OZwrfDjsOTwrzCi8O8PsOIVHfDn1x1MDAxNsK6w5DClEl1fcKkRFxcXFzCvlJuwrDClMOTwrzDi8KIScOBw4vDpMKoa2nCpMK6Vm9Bw7R8XHUwMDFjWsOlasOZccOAbMKowpx+w79WY1x1MDAxNFx1MDAxZldjw5TDrnbDiGxjWsOzLMKqf8OVw5NqXHUwMDEzd3zDiiTChD5SwoltSFx1MDAxZsOkw4Jxwp9cdTAwMDdcXHZ7THlof8OfwrB5w6vChj90WXVqXFx2w6UswrQ4fMOOwohJwoDDjnRGwr5Sw6bCiMKzwpTDu8KBw5DClMOBU33CpMO6w4M9fVd9wqtcXHTDlMO+XHUwMDE1XHUwMDFmw5R+w4HCrUTDv8KhbsK3w4xtw75TI8KxXHUwMDE0wr5cXGI+NzQzXsOTw5TDl8OEw75cdTAwMTVqV8OUXHUwMDBlw5dAwq9cdTAwMTDClX3DqEhkflx1MDAxNzVHdMKZM8KiZyxcdTAwMWbCisO8w6RIXHUwMDFmJMK6aMO/wr/CkWrCszBEfH/DqTdTI8K9cMK+XFxiwpbCjTTCuV3Di8KSXHUwMDAyTlx1MDAxM1/DtsKOWcKjwopwXFx2TVx1MDAxMH41KsObw6DDrMK8w7x1w5/DjG5cXHY9QH7CtcOpN1x1MDAxZlx1MDAwNFx1MDAwN8OAXHUwMDE0wpzDnMONJEZcdTAwMTZcXHbCqDF0XFxiw6NJw49cdTAwMTFcXHZyw4vCqih+f8KuPX1cdTAwMWZkw7fDg1TDk0Rqw4swQcO0QcOlw6wlMXzCpMO0wph+XFx0worCocO0YVx1MDAwNcKtwqTDp8Ozwr1cdTAwMTTCpFxcZm/Cs3bDpsOTw5ROS0/DqcK9w4tcdTAwMWXDpDrCr8KxJHxcdTAwMWXCpGlcdTAwMTRcdTAwMWZJwqnDlE7CkDLCr8KbSsO/woxFNlx1MDAwZjnDi1x1MDAxZcKiw61Se1x1MDAwZsKaw5TDj1HCvsKkwodowrxcdTAwMTTCvDjDjSRcdTAwMTDCt8OQwpLCvTJ0KMOqQnTCmW4+wq9owrjDj8OUQHB9w5nDp8KMw4smPU1Tw55QwrhcdTAwMWPCt3YqKFF7wqTCocK9w5PDqMKfU8K+XHUwMDE5XHUwMDBlXlx1MDAxNMOfXFx0TsOUw7VKwr08wp/CkcKbwp/Cn01cdTAwMTJTOVx1MDAxNG06OVx1MDAwZjVcdTAwMWZEOVx1MDAxNMOWcMOSwrXChMOKwpjCq8OTdcK+Rz1Kw4cxw4LDlyzDtn9rw63DsMKtcMOxwphKw4JcXHTCj17Dv8O8dH3Ct8O4WsOcw6g4NsKePX3DusOBXHUwMDA3w7w+WcKGwrDClFx1MDAwZcKtXHUwMDEzwqnCgcOAw5TClMOAw41cdTAwMTZ4w7J9w6bCoMOCwposXHUwMDA3wqJkc2pcdTAwMWJcdTAwMThVfMKgI8O0fsK/w5VUXHUwMDBmw5XDmXhfXHUwMDA0wpV8w6Z+wpfDlFx1MDAwZsOkWFx1MDAwZsOFwo9qXHUwMDFiw6bCt8OTcEldw5TDj1x1MDAwNsK8w4zCqVx1MDAwNHrCoGVHUlxcYnBRw5RcdTAwMTTCu1V/X8Orwq1cXGZcdTAwMDMzU2XDgidxwpk3w4zChFxcZm3Dk8Oww4bCmnLCnUZcdTAwMWVtPU0rw7HDkz5ZwpZcXFxcw79cdTAwMTLCgW4jw5g/e3/CvcKQfMKgXHUwMDA1QHzDplx1MDAwMsKkwrTDiMOfw4PDjFx1MDAwNyB6w6ZcdTAwMGU9TcK+w4dcdTAwMTjCo8OUVFx1MDAxY1BcdTAwMGbClcO7a194JXJcdTAwMWJ0KHpXwqZoXHUwMDE3XHUwMDE1w5dxXHUwMDFkw75cdTAwMTdcdTAwMTLDsC/DiMKew7XCs8OLXsKHSXVcdTAwMDVjecOQwqN/w71cdTAwMTLDlG/DtVx1MDAxMsOUXHUwMDFlR155w7psXHUwMDA1wr9cdTAwMDfDi1x1MDAxM33DiVx1MDAxMsOAw5HCnHzCt0dQfMOmXcOIfMOoNU3DjsKEbMKdw47CosKnwp3DjkTDocKZw4FcdTAwMWPCt8OmUn9PKcKAw7RcdTAwMTg2ecOEw6HDsmvDhFhES3fDgXbCu1x1MDAxMF9Ww4HDoCXDulbCh8K/KDwgbXvDgMKTXHUwMDBlwqXDslx1MDAxYTBRw7PDnlx1MDAxNsOJWT1NwoVcdTAwMDRWw63ChVx1MDAxYmvDkHvDv3LDoFx1MDAwZicywoNcdTAwMDTCo8OEw5ZcdTAwMDfCtW3DnGbCv8K5w5x/wrFXXHUwMDBmw5TCiMK2w4E9TcOXwoNLwpEhXHUwMDEww4BGwqd/wofDqMKPXHUwMDFlwpIjw7DDtMOvXHUwMDFjw6YzXHUwMDE3XHUwMDFjw6jCiVx1MDAxZj/ChCw8PsKiPU1FP0Qnw6hTXFxcIiBcXFxcw6bDlE/CncKiwqDDlDnCo8OmwoxxaMKnw5XCvHkhwpVcdTAwMTFcdTAwMWTCkGQ0XHUwMDE2ZMKVLn/Dg8O5LsOow5xowrTCt8ORPUBUXHUwMDFjw4TCksOPw4BVPX3Cv8KmXHUwMDE3w5lSXHUwMDFiw5g3fsKYZsOjwoBDw6ZcdTAwMWVUXHUwMDFlw6tcXFxcP8OlNcOJfsKiw4tzw5R/w61cdTAwMTnDlcKAw5/CsMOVXHUwMDFiw4jDnsOUXHUwMDAzf8K5esORWcOew5TDoVx1MDAxNjlcdTAwMDHCkkbCn8KJwq3DoVdzw70hXHUwMDFlwpHDt8OARz/ChMOmNn9cdTAwMTdwKMKQwpdcXHRPXFxiZH/ClMKhwp5cdTAwMTZcdTAwMTBcdTAwMGVcdTAwMTVcdTAwMWPCvsOfXHUwMDFlXHUwMDEyXHUwMDFmcVx1MDAxZVx1MDAxMsK7wpskZsKdw4jCq8OHXHUwMDBmS8Ktw5TDoj5tXFx0w7HCpHDCt1x1MDAwNVx1MDAwNcK2wqLDl8OdwrbChcOwLsOFXFxcIsKww6pcdTAwMTRcdTAwMWUxw5jDhGDDmMKFwpQ9QMOMw4HCinhcdTAwMDVlwoVcdTAwMDJnwr7DnFx1MDAwZTfDqMKRwoM/w6BcXHTClFvCk8OZa3F/w4rDuH7CrcKkXFxcXDA2csOPwqPCijFsXHUwMDA3XHUwMDE2MzBww7xVw4TChMOkwonCtFxcXFzCk8KrXHUwMDAzw7Rww5zDvsK4ZcKcw75NU1x1MDAxYUVcdTAwMThBekEpVH3DmMKnXHUwMDE0w77DtcKAR8O0wpPDqDtfworCrE9cdTAwMWZRw6hJw7/DrjjDjMOAw5khw4vDsMOjwrF8w7zCpcKNw5JrKMODPsOcQHvDqMO1w4B6w63CmFx1MDAxOMOOw7TDt1h6YEHCiXvCmcOfwqNcdTAwMWXDt0JRwqTDsMOxwptcdTAwMWVyXHUwMDE1ZGTClsKMXcKHw5kmwrU4w4dcdTAwMTdQwp9iw452w5TDjiPCrMO+w7BibVx1MDAxM1x1MDAwNcOlwrTDjj1Nw4ZIclHCji7Ds8OmKcKkbMOwUj1AwoVgw7Ipw4ZWwpnCgsK2wobDiMKLwrnDhn/ClMONJlx1MDAwZcORczTDo8OrJ8Kiwq09TcOPI0nDqcOnXHUwMDBmXFx0w6NcdTAwMDdLwoIjXHUwMDBlwrfDjCnCgVNcdTAwMGbCrMOJeFTDjMKxY8OUf8OVw7nDk8O3wqDCncO7wpJcXGLCoWpdw7/ClsOOw6DCh8Onwr7DmMKwwpnDhVxcYsKDXHUwMDE5w40wXHUwMDFkecOccDVcdTAwMGbDicODZkLCjcKTaCHCocK3XHUwMDBmw5lLLMOFw43ClSBcdTAwMDNnecOVXHUwMDEyw5HDj8OJPU3Dnj1Aw5vDuMKPw6dcdTAwMDdcdTAwMGZrODdcdTAwMTjDiD1Nw5dcdTAwMDTDpsKVwr3DgCPCrsOyw7kzXHUwMDAywqnCm8KJXHUwMDFhw67ClsOvw7pcdTAwMDfDkcKBwq9cdTAwMTdcdTAwMDc6QcKDJGNgw7DCm1x1MDAwZsK8wqLDh380UyHCqEfDtcOCwqjDpFMhw4pcXGJcdTAwMWRMwpZow6jDrDLClsK6wobDmi1AbEVcdTAwMDXClXd9PX0/w4/DksOhb8O8w77DtDfDnMO+SsOqw53CjcK4PFx1MDAxZlx1MDAxZcKvMMKPwqBcdTAwMDTCuiTColx1MDAwMsOAVMKCXHUwMDBla8K3NTjDj1x1MDAxNsOkfVPDlVxcdMKfwr5cdTAwMWEmK1TDtiRHw5/CgcONSSdcdTAwMTJwQ2c9TVx1MDAxNcKNJFxcZlx1MDAxMlt8cUfDiHXCk8KTw7jCuzh/wrLCusKTw7Nvw5zDqCfDrVx1MDAwZsOYWMKJTMOpwp44wrlcdTAwMTHCg8Kewq5JPMOfd3sgfMKxXHUwMDFjwqLCt3PClC3Clmxfw5lcdTAwMTnChcOWw73ClkfClsOaI8KOwqtzPU18woXDtcKlw5XDnVx1MDAxNsKoRkdcdTAwMTfCvsKfXFx2w7/Dilx1MDAxZsKFZsKvM8Oow5ttw4Q9QMOwwrliXFxcIsKTXHUwMDA2woLDp8Kjw5tzXHUwMDEzwrA/wr3CiXjDqcKHPUAxMGPDp8K3w5BcdTAwMTDCkXJ9wolEXHUwMDBlUsKOw4tyw58yw5/DkiPCsVbDkllnw4h+wonCgjZvwqHDucOQfjTDmH3Do1x1MDAwMsKvcMOVwrjDulc5w53Djn7ChD1Nw47CnVx1MDAxMV/Dslx1MDAxZcK/NFx1MDAwZlx1MDAxMm1cXHY0XHUwMDFkwoEhXHUwMDFhw6lOwrZ/cMKFXHUwMDExw5LDocKCw4fDv8ODacKbw4pcdTAwMWLDgVR3XHUwMDE1w6hpwoXDh1x1MDAxMsO/wojCrX88w7dtwpzClXjCuG3DncOQwo/Dn8K2wqfCiHfDrcKYwoE1w7fCosK+woRpN8O0IcK9P1x1MDAwZmVcXFxcwrLChFx1MDAxMsKJc8OTJ8KkbsO7wqvCo17Dp1LChHTCt2hMw6fCmsO6M8KDXFx0I8KFwovCvz1KwpXCtMKUJVx1MDAxNMO/QcOUw5bDvMORXHUwMDFmNcOXXHUwMDEyXFx2XHUwMDFjLUFgbi/Dk8OXXHUwMDAzQ1x1MDAxOcOlwo/Ci8K/b8OCYMKfQFx1MDAwNDzDh8ONQ8O+w7TDicKhw5PCtsOkwp/DnsO8w4PDqXxQXHUwMDFlUsKDw53CpXBmXHUwMDAxdsKRwr9cdTAwMDVFYFx1MDAxM8KYd3/DmsObXHUwMDE1VyFYZ1xcXCJkw7DDksOyw5LCmCFkw7HCtXdcdTAwMWR0w5PDpMKBwqTDnlx1MDAxMcOcM3xsXHUwMDE3w6VcXFxcMcK9wrTConnCl8O5w5PDg3M5Xlcyw4hcdTAwMTB7SD8/wrnCjcKgdX9cdTAwMDfDn8K7JX9na1x1MDAxM1x1MDAxN1xcdFAtw7tcdTAwMTYhwph/wrHCicOQXHUwMDEzcsOZwpjCk3tcdTAwMTZ9IMOGXsOtwoZcdTAwMTnDvcOswot/w684N8OYecKjO3XDq1DCncKxw6DDijnClldDw5rDk3zDi8ONXS5kXFxcXFdcdTAwMTnDrn1oVcOLXS7CkDRcdTAwMDHDqU5uw5dEUSBBw63CoMKRwq5kw6vCgE8nfVxcZnpMIcK7w6jDk1NcdTAwMDLDmMOUwqrCkUnDinTDmsK9w7LCn33DmsKNwqfDilx1MDAxZMOBLcKgw45XXHUwMDAywrtcdTAwMWJcdTAwMWHCpVDDnsKBwr/DusKrwrYxw4XDnsK9wp5MT8KYRVPCmMOIwqtWYsOKXHUwMDBlS8KHaGLDk8K+wovCrmrCvcO8w482wotcdTAwMWY/woXCmsOPwqV9TcOqw5VcdTAwMTjCpVx1MDAxYS9Pw6JrccK5RGAuwqM2w5pfYcO8flHCqFRcdTAwMThZZWNkwoxuwrrDmcOBw5XDjcK3w5PDqMOQwo7CsMKPwovCoFx1MDAxNFxcXCLDsnvDrSzCpzE5wpzDnF/Du3tLSFnDlMOMUlFXwpjChlxcXCLCssKKacKZYVFFfWdfb8OywoDCt8OSwqJ0wpRsw7ZCXHUwMDFiwoNlNU1Hf2jDp8OKwpjChMKDwpjDsMOuw6LDm8ONwrExJMKibMO0wpAkVFx1MDAxZcK0wq/DncOUdTVQw5FRw7BwwrhEXHUwMDE0WcKeST1KworDk3PCmcOSwolcXFxcwpnCsMOSTlldT2hkTF4yXFxiXHUwMDAxXFx0w4JcXGLDo8OjwovDrybDpFx1MDAxM1x1MDAwZsKvY8K9wrxRbsKvwrt2ZcKUwojCuibDh8KVY8KbwqLCicO9w6DCtzdVw4F+w49rXHUwMDE1IcK0PMOWwr/Cq1N0XHUwMDA2ccK/JcKSw6txQWQgwo4zPlx1MDAxYlxcdE7DrcOjSMONwrlFwqVTw45pXHUwMDFlw4QgW8KUwprCh8O8w6jDq8O8IMOcXFxiw7g5Z8OnOVpvXFxiwrBFRcOmw5nCqWdcdTAwMTUnw6FcdTAwMTDCtcKhJzh/w4vClsK9w6fDmiR+w4paJn/DnHrDl8KYw4TDmsKgXHUwMDE3woxcXHZcdTAwMGbCp8OFwq9cdTAwMDFcdTAwMDNNbFnCpm9Cw5slw5N6wp09QFnDi8Ocwr9mwp1cdTAwMTnDpWQ9fWHDqsKuc8OlPU3DqsO2wqRcdTAwMTjDq2LCuTjCjsOAw4JuWmJSwrvDg8KhWMKxXHUwMDAzw53ChsOuwrbCuMOTwo9cXGZ/XHUwMDEwXVXCiFjCjXRIXlpjw4nDoFrCoTfCoF3CqVxcZjldwpTDsVs9fcKSwp3Cq2PDpsOLwrdTw6DDqcOxVmMowr57NsKpw7FmKFxcXCLCv8K7w5Ulw63DmsOUfMOyTsKEOMKDw5hcdTAwMGbDjXvCucK/wrvCrcOgMFx1MDAxY0fDjMKtw5ZQQ8OKw6ZcdTAwMTNQXHUwMDEyXHUwMDA0wqY1XHUwMDFlwpTDmDfDtFnCnWpSXHUwMDA0M1x1MDAxM8KDw6XDjFx1MDAwMcK5XHUwMDA3w7rDtFx1MDAxM8KIw7J/wq1rwpFcdTAwMTFcXFwiw4zDjMO5K3JcdTAwMGU/wrbClsOcwrDDi8KVX03DusO1w4RaXHUwMDFlT10sw7dcdTAwMWTCsmxcdTAwMTPCmcOxw4tLw4zCgsO+XHUwMDA3XytcdTAwMGbCt3Vqw6VcdTAwMDFOw4vDgMKdPX17XHUwMDE1w5d+w47CoEtHXHUwMDA3woLDgcKrw5w9TcOcw7pSw4PDs1x1MDAxMiUmRlx1MDAxZXTClDTClEjDicKxdj1AXHUwMDExTcKmw58qb8OnUm7CpcKIQMOLXHUwMDBmYcK0w7tcdTAwMWRHT1LCmcO0fsKOwo19wrTCiMKJVG/ClVDCvsOLa8O5w7XDulx1MDAxNMKbXHUwMDBmw5IjfmPDlFvDk2rCucKdVMO6wrjDrT/Dklx1MDAxZsKlL8Ocw6A9fcOLw4RbTMOueD/Di8KPVW9cdTAwMTLDtGg7w7xmWWzCsMKhbsKSXHUwMDA0wp07wqRcdTAwMWVrwq44wqc9fcOLwoPDqW9cdTAwMTLDrEk7wpRcdTAwMTk/SyNoO1x1MDAwNDZcdTAwMWUww5JBwrLCqsOVLV7Dm8Kgw5DDrMKKXFxcXMOqUHXDry1WSmY+XHUwMDFlK8KAwqHCrTnCnirDmMOmw40uwpxcdTAwMTVMKmzCjcKLw74twqjChlx1MDAxZVx1MDAxMsKtwpFcdTAwMTErdyRVbMK1wqVKXHUwMDA3wpjCosOxecKiw7HCgTvCnCguXFx0wpk9SiFdYik6w5hcXHQ8w4vCtlVMXilew6ZcdTAwMTnDgjJfXHUwMDE5QMOLXHUwMDFkw4Vuw7IyXHUwMDFjwqbCnMK4Mlx1MDAxNzvCs8O6wrHChjtUdjzDi8KLO0zCvkdKbMK5wodvwpLCv8OjMsKXfj/Di1x1MDAxOFxcYjTDnlx1MDAxMMKHL8OEXHUwMDA1wojCq1jDoX7DisOyw4c/w5Ipw5w0PljDlGpcdTAwMTF8VXrDt8OyNMOew67DlyzCp2DDlmpVw45Uw7omXHUwMDAxXHUwMDBmXHUwMDEyXHUwMDEwXHUwMDBmwpzCvsOcw6VGL1hUcSMjXHUwMDBmXHUwMDEyw7XDgsKcwp7DrMOXRlx1MDAwNz1AWHFcXGJpw7XDulx1MDAwMcKFwo9cdTAwMTJcdTAwMTHDqFxcXFw+w5zDijbDp8O5Vm05wqzDtcK6wqvCj0PClCbChcK0wpRcdTAwMTnDgMOMLcKldcK7XHUwMDFkw5Z8w77CvXrCtMKeZnXDu17Cv3xOwqZjPy9Jw4XCtGDDtsOFwrRsPX1cXHbCosO6fsOebsKoVMKcw6jCgcKswrbDoMOBw4pcdTAwMTLDk09cdTAwMTLCl3Izw6TDisKFwqzDpMKIP8ONw7wtw6/Ckm5/W8O0NVdwXHUwMDE5wp7CtcO7w6hcdTAwMTFvXHUwMDEywpR9O1x1MDAxY1RUbMKHw5IyXHUwMDFiP8K0esKgwpVLw5zChMKAwrLDhsKMNcO7RsOdbFx1MDAwZSfDlCojwpZZasO1w500wrrDicKdK1x1MDAxYyfDhMK5w4BcdTAwMTbDuXHCrVx1MDAxZFx1MDAxZMK7JcOqwqZ+JVc5XHUwMDFmXHUwMDA1w4HCscOWwp1cdTAwMWN6w4vCjUjDvMKpYS/Ck8KYw4PCrMK8PX3DkErDqFxcdj5OXHUwMDA1w4jCtcOMXHUwMDEww63CisKFwppYXHUwMDE0XHUwMDE1w7Vrwo04XHUwMDExSsOTXHUwMDE2Rk7CkcODwq08XHUwMDE5d3DChFx1MDAxZFBNfcOpw7PDkiRxYGxcdTAwMDXDnHvCosKeYGRTw7JwX1HDnMO6XHUwMDEww7ZWwo7CjsOCwq9owonDtG4wT8ODwpLDp8KfUMOUw6bDg8KrwrjCtVxcXFzDulLCsTZcdTAwMGXDvWgzw7fDk8OGwq7Chlx1MDAxNlHDi2thw73Du1xcZsO8wp4+wpTCu8K4wrxZw4/Di8OlY8KTwpLDhcKgRMOkwqdmP8Ovw7HDkcOMworDg35ewqnClTTCnEfDhMKsXHUwMDA2aHZuw7VcdTAwMTF4bnsnUcOMw4zClcOzXHUwMDEyccKAXFxcXMOkw4/DgsK2w77CoU7Di8Onw6tzw4opwrNywp/ChEzDpMKYwr7CssOoR3Nqb1xcdjNSIMKNZlx1MDAwNH49fcK5cMOCw67DjcOCw63Cm1x1MDAxMlx1MDAxY8KyYsO+XHUwMDFhwpwsw6TCh2QrXHUwMDBmw5J3alx1MDAwM8KFw7DDjUXCiD1Nw7vDlMKVw5tcdTAwMTLChmxWRCFnMMKvw7/DrsOKwodkW8KSw7TDoMKSw57DsE1EXHUwMDFmw6laOFx1MDAwM27Ct23Dn1nDscOMwrvCo8KNwrvCskTCtcKeXHUwMDEwcEvCh8OnUl7Cl31OwrTCnsK0bsK1wrnCuGvCiCjCjcO6w5pVO1x1MDAxMsKmbi5cdTAwMDRcdTAwMWZaRsO7w7NcXHYyw6lFwrdcXGJcdTAwMTDCtnDDjMOJwovCksKEwpNCJFx1MDAwNGE0w594ScKvXHUwMDFlXHUwMDBmccOLRcKfTXvDocKKTsKEWsKhLsKEw4xmLFx1MDAxYlx1MDAxMMKxw4zCucO0w4vDssKhXFxiwppOw5VeRjfDiGc2Z39CwrDDpMKQNm/DvcOPwrBMe28yJMO+P8K2woRcdTAwMWTCrcK7XHUwMDBmXHUwMDExSlx1MDAxZVtXMlx1MDAwM2c1biHDjS07wp/CnTLDlElkLlx1MDAxN8KWM2pYSCvDssKTw4FpXHUwMDA0wopcXHbCuVx1MDAxMMOYXHUwMDFhbcOJPyfDusKvdMKJw44pXHUwMDA3McOndlx1MDAxYmvDoCE6wqRjPkvCrT19NsOkw7zCuWvDqcKANcO7RG9Lwox1w6d7XHUwMDE2w6XDq8OSwopcdTAwMTbCisOuaVx1MDAxMcKvwrbChsOnesO9woR5wp7Chj1KwrPCrMK0ZnpcdTAwMDJdwqHCnsKpw6JlwqTCqMOyN8KPw4LDpMOLJsOka8OSIcO1ak5JZzpXwpjCm29cdTAwMTXClsKHwrtcdTAwMWTCpkFcdTAwMGUhwo0qw6RFZyrCp8Orw7jCksOIw49dXHUwMDA0Z8O9M8K3I8O6SX/Ct1x1MDAxNsK5woYgY8OMwp53ccKOfVx1MDAwMjnCj1x1MDAwNsKbalx1MDAxOEg4wpIgNMKlwr4kXHUwMDA1OMKHwrPDnG3DsThcdTAwMDNMQVfChVx1MDAwZcOEwpHCrcKaw4VfwpTCocOecE/DncOWw7o9QMKBw4BSw6vDuTxfw5jDm2pcdTAwMGbDqcO3w7vCvcO7XHUwMDEww5LCn8ORQzTCv11tW8Kbw5BcdTAwMTIhwos9fcKOw4/ClMKsw4jDj0RNwpHClsKufsOfwrd6f8OQS8OUaMKPwqpcdTAwMWXCnzfCusKpw4Bow4x4XHUwMDEzw4tawpdnXHUwMDBlYHNBXHUwMDE3wpc9QGtXw5RkUl9zRcKXZsOSwq80XHUwMDBmw5/DusO9w5vDhFx1MDAxMm/DjTA8wp/DlcONJ23Dv3tcdTAwMGZUX1x1MDAxZSTDl1TCpD1Nw4vCtMOUwpV/w7pcdTAwMWJcdTAwMDXDtMKSw4jCr1xcXFwkw4XDjcKuXFxcIsOWTFx1MDAwNMO5woFuXHUwMDA3wrssXHUwMDFlwo4tSU/Cp1xcZsOLRHlINMOTwoBqZcOZw7PDjVx1MDAwN8OkXHUwMDFjUkx7OMO/XHUwMDE5wrpvw73DqcO1Sj/DizY8w7jCunBUwoHDj3rCt8OQPsKESW3DjcKuNz1KUcOiXFxiw7HClkcpw4F7wqhcdTAwMDXDrcOGw7Qlw63Dhlx1MDAxNVx1MDAxN8KMNsKUwqldV1TDqcOCwo3DtcKpWsKcUFxcdMODwpfDhcOpXFxcXDc4wonDgjnCpWhdNTHCp8KMQEYnw6rDplx1MDAxYsKow7nDlsOswpnDg3BcXHRhwrY9QFx1MDAxM8KBw7Y9fSnDgcK2w6zDg1x1MDAxMcO2bCnCkXZcdTAwMDPDkzhcdTAwMTDCrMO5PX3DkMOCwqfDrsO2QybCusK7ZcKcw4nCo1x1MDAwZsKkwrlcdTAwMTPDqSU4XHUwMDFkw67DmMOHXHUwMDEzXHUwMDA0wqLCtVNhw6TDs8KOWcOlw7jChnvCmMKNw4BcdTAwMDHChsKNwphcdTAwMWXCiMKLw7RcdTAwMWRZXVVcXHTCh8KOwpZcXGZZWsOgw6HDuVvClW3DuFxcXFzDncOEeV1Jw4Z5W1x1MDAxMWDDiMKOXHUwMDFlw55bXHUwMDFkw5TDoMODwptcdTAwMTZkw7jCpnNpw7DDolx1MDAwNmnDrMKmM2PDtmJHZ8OywqbDnGPDqmJXXHUwMDA1w7HCpsK/XFxiw7XColx1MDAxMFx1MDAxOMKQwo5IYVvCu23CoVxcXFx4wrHDoF01w7ZEw4PDk8Kdw6BcXFxcw4nCqcKYwpBow7HCmcKMw7RYwpfCisOAw6XDmMKRwqbCgMOZwo/DkMO0Xlorw4PDlcODXHUwMDFmYcKBWzXDp8KAXFxcXFx1MDAwNFx1MDAxNcOBXcO4XHUwMDFjw7XDgsORw4N1QsOlRcK1QsKrJWzDkMOgwqhow73DumHDgTN1w4TDrcKWYmHCtcKDwpLCgcOxw4LDuMOTwo9wwqfDhMOrw4LCucOUwpDDgFx1MDAxOcOHw7BcdTAwMTZ7w5nCjEjDqcOUwopEw6HDgFxcXFzDkX3CtUNRw4UsXHUwMDEww73DtcKGcMKQfWDCvcOBwrrDq8KiRcORW8KzIcK9w4NhdT19w4I9QHs9fULCp2s2wp1cdTAwMGZ2Plx1MDAxZMOUZsKsw7PCmjXCjcOwwqk0wo9cdTAwMWFcdTAwMTDDi8O2w4xcdTAwMDJKXHUwMDEww6jCpCrDnSbCrDnCncOXwobDsn7DpMKiW8OlwojDo1s9TcKBw6NcXFxcwp1tw4dDacO0wrtTXFx0wpHDsVxcXCJPwoVdNcOfVsOCXHUwMDE2wp1Qw7bCrWxtXHUwMDEww6jDn0jCvcO/w5jDr8OWw4LDi8O4w642fsKLwrhnPX1awrFBUlo7wrZWw51cdTAwMGVnw7fCnmQhNFx1MDAwZsKQJz5cdTAwMTBoJVbCnlx1MDAxZsKkVUbDo1x1MDAxYcODw5pcdTAwMWZcdTAwMWYtXFx2a1xcdsKXw4tcdTAwMWVcXGbClcOswr3DmcO5NcOpOMKYO8OYw4jCqXbCoiRcdTAwMDPCqMKLXHUwMDEww4pQwovCp1x1MDAxN0BcXHbDgsKlwpXCr8KVXHUwMDE3woE0VXRBM8KpwojDiFc+QsO4Oj1AXFxiUz19MEB4QMK4XHUwMDAxdj7DoFx1MDAxOcK3OkhHO05+wqdcdTAwMTlTwqbCg8O9eVx1MDAxMsKNwphMXHUwMDE2XHUwMDAxw5ZQXHUwMDA2QU9NZlxcXCImw43CocOmw7h3XHUwMDE5w6zDi3HDpi9cdTAwMGbClcOmwofCoHlcdTAwMWRcdTAwMTjCmENcdTAwMTMnXHUwMDAxfFxcdFx1MDAwNcKIXHUwMDBmXFxmPUrCv8KFMTlcdTAwMTjCiVxcYsKoXHUwMDFlcMKKXHUwMDE4XHUwMDFiR8K5w4lJXFx0XFxcXMOxXHUwMDEwbsK/XHUwMDA3XFxcIj19eT19XHUwMDE1eMOWwp1cXGLCnlxcZm1ZwqXCjCnDj8KlUWTDgMKnaVvCisOZwqZcdTAwMWTCjMKXw5dcdTAwMTBjw49cdTAwMTDDt0RHeMO3w7Arw6xcdTAwMTDDt8KFwrFgw5lcXHbCucKXKMOFY8Obw4PDp2DDjyPDh3jCj8Odw6vCr8OEXHUwMDEwwrlvwp3DhcKNwpfDgF5Rw5/DmcKUXHUwMDE4w5fCiFxcdMKWXHUwMDE3w6TDlyPCiMOxw5jCkMOfwqMxw4VZwqPDh8KSKCVcdTAwMTR+XHUwMDFkIG9Bw4VZMlx1MDAwNcOETVxcYsOeYTnCh1x1MDAxZcOSwqPDvT1KQcO3PU3CicOmwpXDiFxcXFxcdTAwMTF1XHUwMDFkTVx1MDAwMVxcdMO3w5VcdTAwMTgpwpdIwqd8wrRcdTAwMTd7w4HCjcKtUFx1MDAxY8KCw4HDrcK0XHUwMDE2Wy9/IMO7YjfCoMOvwqDClyDCh8OhSFx1MDAwNWDDvsKyN8KEwo/DtMK4wqLClcOraMKfw6HCi8OTRMKlwqDDtXdxIMOQXHUwMDEzKsKgwqQ9QGogPUp7wqHCoMOMXHUwMDE2worCoFx1MDAxYlLCsFx1MDAxZsOUIcKPw43CiTDDmsOHJ8KtXHUwMDAzw5jDjMKLwpYow7M7XHUwMDE2wqLCr8O7XHUwMDE2KMK7wo1cdTAwMDLDpsKPwo1cdTAwMDPDvznCjcKCwqVcdTAwMWRiPUBKX8K7w7dcdTAwMDRbwrtfI8OGw7Agwp3Ds8KOw4FcdTAwMGV5wpBNOHfCi1EnVMKKwpnDpMOBw5rCncK1w7RcdTAwMDLCj8KxbsKWw6vDvlTCoMKyXFxiwp4gXHUwMDEyXFx2wpTDoMKXdjdlXHUwMDFkwoVXJcKea0fCpVxcdMKbYMOFwp3CkzjDpVPCj0jDhVnDn8KqwqfDnMKQSyXDrMKNW8KFwp/CnTPCpVLClUPChU/DqcKswqfDoMKYT8Klw7HDncOIwrfDpcObw4RXw4PDvsOqwoRyw5fCjVHDlsKGw7nChGXCmcKOw7XDucKXwow9TcKNw6HDmlx1MDAwMcOowpbCj8O5w79ew5xrMGVcdTAwMDJ7w6XCocOcR8Kow6VcdTAwMDJJw6HCocOdXHUwMDFkw70gw5x3XHUwMDA3JVx1MDAwMsO6YzFcdTAwMDLClsONbcOWXHUwMDE0w5jDrcOWXcKdwr7Cl8OnwqTCtsKnQcKlwqzDhyDDqMODwod8wqzCgz19I0A9QMKMw7NTwqDDl1x1MDAxM0PCoFxcdsO4w51cdTAwMTbCmSFcdTAwMWRcdTAwMTbDt31BwoJcdTAwMWTDunVcdTAwMTbDnSDDtcOWcCZ/ID1Kw4XClVx1MDAxNlx1MDAwM8OGYD1AXHUwMDE5IcKfPUB7wp7CvcOHWMKlw4VcdTAwMWbDiVx1MDAwN8O4wpDDk1xcYsKPJcOAXHUwMDA2wo3DpcKeScOaPU3CgGnCjsK3dkjDncKrXHUwMDE1w4nDmmHDt8OJw5xXRcOJw5vDlMOAWcKCwqA9TXUgwrQjwpU9QMKNJ0XDgFxcXFzCo8OxwoTDmMKow7nCmMO6J8OyeMKHXHUwMDFjwrNcdTAwMDfDi8O8w7PDpMO4JMOsw5TDtcKmwo0tw7XDqcOdw5dpwqjDmlx1MDAwNcOdwqjDmyHCiCbCkMOxw7DCnsOdw6BcdTAwMDEpw5prwqvDp1x1MDAxNsOrwo3CqcKDXHUwMDFhwrtcXGY9TcKXPsKoe3E9TcKnwqh8XHUwMDAyXHUwMDE0wrk+SMOmwolEKcOGTsKtw63Dt8KPwptcXFwiZ8KDJsKNw6hGIDLCvsOxcGdcdTAwMWPCosOtwogvwqZowq/CsVx1MDAxMUJcdTAwMWHCm8KRVUnCqcOFWMOqwrVcdTAwMDc/XHUwMDFiXHUwMDFmwqHCtMKiXHUwMDExRE/ClmN0Q8KlcsOTPUphJX/DmsO1bn/DlsOVw5fCsMOBw4l9w63CpTTDv8KbwrzDnzBcXGLCn8KFLVnDlj1Aw650w5jChFx1MDAwMlx1MDAwZcOTQMOoWnlFVcKiXHUwMDE1PUpxwpnCnsKaXHUwMDFhfMKHRlx1MDAxNsOVwrFJwqjDusOtXFxcXFVcdTAwMWVcdTAwMWJzaS3Dllx1MDAxY8O7KsKhWF3DrnNocGJcdTAwMTfDlzsow6XDukLChcKjw4M9SsKxeXfDmm/Dh1NcdTAwMTjCoFxcXFzDrcKbXHUwMDE3wpDCosKew4Njw6jCj8KQwqvDicOJw53DqsOMNnXDpn/DrzTDsVx1MDAxOMOhw6zClUzDl8KbwoTDgV/DsFx1MDAxZmDCosOHw7pANcOIXHUwMDAyXFxmaMK7R1hhw5/DscO9eVx1MDAwNMKNw5/CojHClsO9XHUwMDExwqrDucOWXHUwMDEzwrFcXHQ2wqDDrsK1XHUwMDE4Y1xcZsO9wq8nwpvCs8KwPX1ow5pcdTAwMDUzXHUwMDExN8Kdw7DCscKJY8KNe8O/KsKmXHUwMDAzw6ovw5lmXHUwMDEywqxcXHTCt8Kaw6/Dt8OZwofDm8KkXHUwMDBmaiZwwpE6cMOlMcKLXHUwMDE3amHDhifDujc5w4NcXGbCuMKBw7XCpT1KXHUwMDA2w79IXFxcIsOWw51RwojCoMOwPX3DqcK0XHUwMDFjw6wlXFxiwqNcXHbDiMOcw6tcXFwiwr7DnGHDgMKIXHUwMDExwrfChcOGwq/DoiXDjjphwrfCjFx1MDAxYcKtUTbDiMOIwrdcdTAwMWFcdTAwMTBIwq7Cp8KQIz1KwppHwolcdTAwMDbDm8O7QcOpwppcdTAwMWPDrVx1MDAxYsOxJ8KawqLDimnCkFx1MDAwNSbCm23CniooI2Yqw4nDtEbCrMKPwqk2w6tRw7QsXHUwMDFiRVx1MDAxM0rChmFVMsOZezfDsMKAw7XCrMObw5NrMsOIw6FgLnnDoELCtMKFw6A2w69fwqDDrVx1MDAxYcKzR8OtwprCvD1Nwppmwp9cdTAwMDHCmlZcdTAwMGY+wrTDpcKhwq9cXGbDrihNw5rCkcO9MsKGXFx2WjzDpWDCuMOuwo3DlnFcXHbCgUVwXFx2QcOwwovCosO+w5RawpbDlV9EwpHDt0nCt8K3wqNcXHbColx1MDAxYcOewprCpsOkZUZJw4g8wqvDn1xcdG89SlFcdTAwMWLCjcOaJMOHW8Kiw7lcdTAwMWFywqbDok88XHUwMDA1w6JvwovClMKlPiBdRMK1acO2ScK1KcO8PU3CmsKbXFxiYmZcdTAwMTjDr2LDpktMRMKxw4fCs8OwU8OYW1xcXCJcdTAwMDMkQsKmwoRPQFx1MDAxZMO1wo1cdTAwMWJcXHbDocObXFxcIsOsw4JcdTAwMWLDgsKTQ8K5wp8ld8Oqe8O1UD1Kw5jDqDPDollXOMORwofCucOtw5jDiFx1MDAxYmLCm8KHZihQw4HCqsKJwpBQworDmUUzw6LDvVc7VcO+UVxcZsO0w6nCs8KiwoZsPMKIwp5kMyHDnXTDsMKAX8Ozw6JcXGZ/XFxcXMKgOcOGwrJxwpbDiMKyw7l0w5E9Sn8zU1xcXCJUw4XCrFFCw45cXGbDusOMfsOmXHUwMDE0cFQ4wpp2w63DrcKUw71cdTAwMWHDmMK4XmZcdTAwMDNdR8O5wojDgsK4wo9cXGLDkD1NwqXCkjxcdTAwMTBXw4XCrsOBw6bDicKudcKnXFxcXFx1MDAxYcKzT0PColx1MDAwNsOFNmbCnMKaUMKIYWE9fTnCpcK8wrNxZMKRXFx2w5DDtFZmw5tXNUHDgsKOPU1RwoNcdTAwMDPCoidcdTAwMWLClsKmwobCi1xcXFxcdTAwMThpwpBcXFxcKMOnwphcXFxcYFxcXCJaQ1nCn8O1w6vDk8K/Y8Kiw6vDr0bDlsOMw4jCtcKJwrfDtcOvRFx1MDAxNcKdXHUwMDFiXHUwMDFjXHUwMDAxw6NiXHUwMDAxwps0wohhwo80w6BoZi/DvcKpw5DCikFQOUnDk8O2w611eFx1MDAwZlxcdl3DvCNiTkpJw4XCgVx1MDAxMT1Ne8ORXHUwMDFkXHUwMDFiN8OkKsKZbS9cXFwicMKDK0jCn8OeKsOFJ1LDqm3DhjXCm1x1MDAxZMOObGbCnX1LXFxiXHUwMDFjw5I6wpXClUFcXHbCpcOLb1xcXCLCncKfO8K4ZMKIwq7Dv8OoPsKLTVx1MDAxNcKMZl/DpEJcdTAwMDXDuVXDsDhXw6/DoibChVtgw51Uw6tcdTAwMDTCu09iw6DDkC7CqWfCgsKsXHUwMDE5w6lSw6tcdTAwMTREfVx1MDAxYlTDicOTYlnClVTCiMOdwpxUPUBoZT9pI2Y/KT1AVcOvMyjDj8KCacOdPsOFWVPDr33CucOBwozDvcKRw4/CgnHDizbDsWTDgFxcdsO4w5pcXFxcwqbDncOKNsO1w5hWw61fw7HDtVx1MDAxYcOCccKPYlx1MDAxOcKZQ8KowozChsK4woFbXHUwMDBmwqI9TVxcXCLCnFx1MDAwNsKHwoTCuFx1MDAwMcOYVsOxwrU4wr89TcOFYcO0wptcXGbDkcKcwrbCoj9iXHUwMDA3w4wsaVx1MDAxZsOYw6rChcOxfj1Kwo3Cgz9cdTAwMDLCinAvw6jCgsKJwqvDuVx1MDAxNsOXw6p0XHUwMDExVVx1MDAxYcKwMT/CosOwXHUwMDExNMKmenTCrsKHw55uw6LDscKEwq5fZm7DolrCgsKuwpfDsMK0w5rCj8OUMsKRQcKyw5pcdTAwMTbCnjvCqF3CicKuXHUwMDFmwoDCtVx1MDAxYcO8w5dMRsOhecKuXHUwMDFkecKyXHUwMDFhw4fDnUxmPU3DhDLCgcOfwrVcdTAwMWHCr3FMZijCrzI1XFx0wrNcdTAwMWHDjsO5TCYmw4UyYSg8XFx2PU1cdTAwMDdcdTAwMWHChsOZMsOJIzXDscKnTFx1MDAwNjfCp8KJeVx1MDAxMiVgwqBrw4k/JMOmw7DDulxcdMOfwqJKbD1NWMK1esO1OzvCtFx1MDAwM1Jsw6DDnW/DslBxwq7DjHHCtTpISmzCjcK/b8OyXHUwMDE0N1x1MDAxZVx1MDAwNcKbL8K0wofChsKrWE7CgcOKwp5cdTAwMDE0XHUwMDBlXHUwMDA1woHCuHDCiFJxw7VcdTAwMTDCv03Dt8O7XHUwMDBmXHUwMDEyw5xkXHUwMDFlf1x1MDAwNcO0w7pcdTAwMTVcdTAwMDPCj1Jew4o2wqdcdTAwMThUb8KBwqHDgMOMw6HDm8OPw7LDicKJwrRIR8OCwrQ4w694b1x1MDAwMVx1MDAxM8OTw5Ipw5A8wp7Dt8OpLlx1MDAxN1x1MDAxNVJwOcORQMONXFx2XHUwMDE0w69ywpDClTvCvFx1MDAxYlbCrF41w7vCtcKybMKeXHUwMDE4wpsrJGPDmyo/w6bDtXErw4MjwpJcXGYlZsKeaV85wpfCpmQvw4dEZS/Co8KIw7dvZsK+wrUwXHUwMDE4w7Rrw7FcdTAwMWbCncO6w6RcdTAwMTTDs1x1MDAxMsOvJcKWXsKVfmDChMOmWTXDu1x1MDAxNMKDXHUwMDEywqDCoFB8w6XDgsKrOMOFwpDDisK1L8K9ejJcXFwiYGbCn8O9eyfDrl5ewqN5VGQgZS/Cv1tTXHUwMDEycsO/bl4jflxcXFxcdTAwMDRuT8ONwpJcdTAwMTlOw57Dmko7N1xcdMODwqpcdTAwMTDCn8Ouw43Cm1x1MDAxNFx1MDAxYsKSw4HCmUbChMOCZytzw5lGwrk+woTCjMO7w6TCgVvDksK/QcKtwoBcdTAwMDJxw41pw6s9TXrCmVx1MDAxY8KCw57DoEw0w6fChkTCs1x1MDAwNMOgwrlrc8O3O8KSJ8O/wppeXHUwMDExw6vCksKOXHUwMDFkZDY/wp7CuGxPw6lww4zCq2dNw7rCuMOpw4tcdTAwMTLDs1xcdFxcdlx1MDAxMsKAw7laXlx1MDAxMSF6w64pRMKscMOpN3A9fUkxw4vDilx1MDAxNcKrXHUwMDEyecO1On7Dp1Eqw6fChlx1MDAxN8K5dsKVJ8K6XHUwMDAxwo7CiV7CmsK2OcO8XHUwMDFhblx1MDAxMsOYaMKtwpDCoMKlTVx1MDAxNcOlwq3Du8KrJ8KIw7LCl8OYUVx1MDAwNMOHXHUwMDE2wqvDtsOnXHUwMDA2w7vCjE9hTiXCjkpUXHUwMDA1XHUwMDBmwrTDpHTCh8O6w57DiityecO3Q8OHw6RcdTAwMDVJwrNERnvCjsKMaT7Cllx1MDAxM8Kqw4zCiVx1MDAwMsOLL0XClsO7JTNgUsKBw7lEwoNcdTAwMDfDmm7DpmQ1wo7Dq8OCw43CrFnDkHLCkMONM8OkW1x1MDAwNELDp8OKwrbCusOaw7MqZ8K3w7xxYVNnw47DoXcxRzLDv3BcdTAwMDXDqcKSw4xcXGLDr0TCklxcdGrCn8KeXHUwMDBmw5BURMK/w5XCrCbCvsK+w7vDkMOXwrTDksO2ccKqw5hcXGJcXHbDi3/CgzRcdTAwMTJXV8K5w4TDgcOywqzCmXQwc0nCvGw/K15cXFxcXHUwMDA2XHUwMDAyw7HCjklcdTAwMTXCi8Okw5nCn1vDgWTCqFxcXFxZaMKpwo3DrMKkZEPCp8OjeXbCusO8wqXDkG1cdTAwMTc3XHUwMDFkez1NT33Djlx1MDAxYsK2w5N/wqfDrMKCNEhcXFxcwo3Dj1x1MDAxOVsgwofDocODd0nCmFrCgUnDn1xcXFzDpcOZwobCi3BJw6fDsj1KwrdcdTAwMTHDgsOpw515XcOkfXhcXFxcXHUwMDA0wrvDtzZcdTAwMGbCm8K2XHUwMDEzw7pjw7ZeKVx1MDAwMsO5w5bDqcOowrHCg8Okw43Cs1x1MDAwM1rCp2XDvWTCmFXCjcO9wqk9fcOdwrnChMO5wr7ChsKJw63DtsKCw6HCtMKjwrzDn8OGw4NcdTAwMTnDo8KuwoNRw6fCusO7w6lcXFxcw4HCu8KHZsK1w7NCwoXDtW5EwoBdwoFJwoFcXFxcwrF6U8ONwrRcdTAwMWTDgz1Nwq3DncODwrUxfcODesOxLsKQXHUwMDA2wrDCksOQeV3CrDPDhTvDtE7CpzXCjiw9TcKmQsOPwrXDiMO2T8KRwoHCkMOrw5zCqMO2wr7CmFXCkMKEw5Yzwp09TcKuWH3CksOKw7jCssK0LzbCp3XCsFvCtFx1MDAxNzt4eyRWw55lXHUwMDFifsOCwrzCoHVibCfDpnpcXHZcdTAwMDJ7XFx2wrvDosOHw6zClFx1MDAxM8Ofw6xvw4VBNFx1MDAwZi3DlcKvXHUwMDE0w4HDnMKufcKPw63CrzVDOVxcdsOQLE3Ci8O5wqBTXFx2w49cdTAwMTDCgFx1MDAxOXLCtX9cXGIzw7RLXFxiwpHDoUhJVsOGRMKjwrZBXFxcIlx1MDAwZsOiJMONw449fcONwpDCl2dcXHbClSNcdTAwMTLDrlx1MDAxZFx1MDAxYsOmwpA1woXDtVx1MDAxMMKPw4d2XHUwMDFkXHUwMDAxbT1Nw4RcXHR3w7fCmT1AwpnDksKXIFx1MDAxNcKHw7zCpkvCpG3CncO3w4tcdTAwMDfDt3vDlMO3w7dcdTAwMDTCk8OBw4RcdTAwMTXDhVx1MDAxOV7DicKAwqdcdTAwMDPDhsOIXHUwMDFhw5/Co1xcZlx1MDAxOMOoXHUwMDEww4tcdTAwMGbCnMKWw4TDgzxcdTAwMDXCp8KEwq0nw4LDlsO5IMOBW8KNwqHDmMOhwovDrcKvJ8KDw79lLVx1MDAwM0VcdTAwMDPCrVx1MDAwM0RDacKAwplvWsKFwoxhwrzCh8Kcwo42RWNOw4BcdTAwMDfDv8OEw7I9QG/Dj8OdXHUwMDE3OVHDncK/wpvCr8KWXHUwMDFiwr1cXFxcYMKMwoE/woVcdTAwMWbDqMOEXHUwMDFmw5rDg8OzeHPDgsO3woTDmMOEw7E4w6PDqMK6w6dUw6HCvlx1MDAwN1x1MDAxOcOfwqwnwr7Cg8O5XHUwMDEww5nCk8KKwq/CgT1Aw51owofDhVx1MDAwMmbDtcKXwpbClVx1MDAxMjhgw47CikHCpcKpw7/CiMOgw4Jnw6pEwp5GwpDCuVx1MDAxZkfCjcKxQ8ObXHUwMDE2wqPCuUA9QMKUXHUwMDFlQ2BQJ2bDhXrCm8Kzwp/CiMKiwr9nw5vDqMK3w48gXHUwMDA2wo7DqUbCmcKRwpXDuVxcYsKNS8KKwrfDl8OkOMOgXFxmw7fCkcKWPU3Dt8OBwpbCoVx1MDAwNUXDoCNcdTAwMWPCpSBcdTAwMDdcdTAwMTN5wpZcdTAwMWLDu1nClibDuFx1MDAxOVx1MDAxNsOUw7/DqcKCw63Cg1x1MDAwN1x1MDAxNsK9JsKIYMOVacKvw49cdTAwMDHDvVx1MDAwMnvCh0TDqcOUwrzDqydkwo/Cm8Khw5ZmSMKoaytFw6VcdTAwMWHCm1x1MDAxMFQrNsK5UlxcdsO2PsKPw5bCnXMvZSB9w61lXHUwMDExw5I9TS9cdTAwMTlfXHUwMDFhXHUwMDE3wopXwobDonNFXHUwMDExKMO/w6tRTVx1MDAxZsKawozCvWg4wr1cXFxcw67DncOwQsKLXFxiwoDCjcKmI8ORM8OoPMKKwrDCozXDt8KbXHUwMDAzLTXClsKTwpPCr8KlUcKDwo3Dk2dgXHUwMDAyI8OFV8OYSMKSwrnDpVx1MDAxZEZcdTAwMWEmw6cnWiRcdTAwMTLCslx1MDAwZsKXw4ZcdTAwMWFcdTAwMWQzw7jDosKXw7MqwqZcdTAwMTPCrDXDqD1AXHUwMDE3wrRcdTAwMTlcdTAwMDU5w6zCmcOww6RcXHbCicO/XHUwMDE4woLClMOhMcOAw6k9TcKzw4/CpcOnXHUwMDFhQX3CmVx1MDAwNlx1MDAxNFHDrsOVPENmw5w8XFx2w6FcdTAwMWZoYlx1MDAxN8OKWWjCocOvOcO9w7kmw5vDuMK5KlZXQcKyw7nCkjBcXHZyw53CisKmw7JLLmnCn0fCtMKZwqM4w63CncKvw61bOcKvXFxmKsKQLkA4SMKzZTHCt8Osw7snw63CmsKzXHUwMDBmwpJmfmFGwolcXGZvPUrCicOpTVx1MDAxYcOfw4HCjcKawpLChU7DuGM8wq9cdTAwMDdFw7BcXGbDv389TVx1MDAxYcOkw67CksO2XFxcIsOwPUosw43Cglx1MDAxNiVVQMKZw6JgSFlcdTAwMDNiK8KVQMOwwotcdTAwMWTDqsKiwqZ2TStcXHTCpcOGwqpvwoU9fcKbwo3CgDzCuEIqw6DDs1x1MDAwMcKOwpbDp8KhTDjDs3TDq1nDl31cdTAwMWJcdTAwMTlxw5PDosKce0RYN3LDscKZw6jDjz1Nw71cdTAwMTVQwovDr8KLQ1xcXCJcdTAwMGVcdTAwMDE2JsKiwqNQeCDDtMOsw41cdTAwMTjCkVxcdsKfb1x1MDAwM2LChsKnXFxcXHhcdTAwMDNoQ8KWwr5GXHUwMDA2wqJNMVxcdHjDtsOvW8OHw6NcdTAwMDLDlcKeNMO4wr/DuMOtw6ddXHUwMDFkXHUwMDFhwo1raMKAw4XCvcK5w4FcdTAwMWI0wppwwp8rw4hcXHR9wqrDk1PCilXDplLDrlx1MDAxMUzCtMOaXHUwMDE4w5NMw6bDmcKJW8KIw6bDjkJJXHUwMDE5VMOww6DDm09cXFwiXFxiXHUwMDFiPMKmf8KhVMOAw7TDhcK0dVh3w694UMOPXHUwMDAyXFxcXMOhPsK5Z8KDwrRZVMOAXFx2w6zDslxcXFxGw6HDkDZ5wqXChMKwZcO2w7XCm3tsYzjChH3CuHHDoMOBPU3Co8K0P8KCw7DDkSxcdTAwMTnDs8OTw6rCtURUwpo9TcOvNCY9TXUvWMO6O8KLZVk7woDCt0DCi8KxTDtYwohSw6zDqcOhwrNcdTAwMWEgwpA7w4hcXHRUw6zDhUnCtVx1MDAxYXHCksK5fcOowrXDmlx1MDAwNEliwrBgXFxcIkfDnsOpWcOrw5nDp1x1MDAwZsK/MmPCiD7Di8Ocwp9Mw55efcKudEZvw5JcXHRcdTAwMWQ0w57CocKYLzxiwoBKw758wrhwOVdxw6tBw7TCulx1MDAxNz1KXFxcXFx1MDAxZcKVbVPClFx1MDAxOMOFwrRUw63DqsKpw6XDjC5DXFx0VHBmXHUwMDAzwozDjlxcdnrCriwtNcO7w7jDsixeTGBJwqNuwqvCqV/CkjTDvMKaw7ZvwrA0Y8OSXFx2wphgXHUwMDA0XHUwMDA2wrrCr8Kmw4xde8KvSi3Cj1x1MDAxNnVxwqRNw73DusOcw5FTXHUwMDEywpUkbsOuw6ZzbMOdwo09fcO7w6XCnVx1MDAxYlLDtVA4woPCgcK2ccOgw4HCjcO6Nlx1MDAwZsKSPkhmQMKXVsK4bsOdXHUwMDAxcErDvVx1MDAxMMO7w5JcdTAwMWEkUsOeXHUwMDFiXFx2MsO+JsKiYsKkwprCkVLDvMOiOsK2w7TCoDHDjChcdTAwMWQswrrCmcOcScOkYMOqMcKnXFxcIlPCrsKgwpNaXHUwMDFjdVx1MDAxZG53w4RcdTAwMThyXHUwMDFmXHUwMDEyalx1MDAxYVx1MDAxZsOlSsOlwqF4csOVw7I7d1x1MDAxNsObccKtw5BcdTAwMDTDjFx1MDAxZsOHwoBcdTAwMTLChsOGL2TCo1xcYj5cdTAwMTfDnl9wwrfDvTbDusOXXHUwMDA1w6TCksOSw6Ngw5x5w71qwrXDocOUw4x3R3TDkn5twqpmwqc+esKZwrRWwqTCh1XCr0YtJcOCw4JcdTAwMDZYwpAjw6zCmcK2XHUwMDBmPUDCucO2wrrCp8OZQ1x1MDAxOSd5w4NcXHZcdTAwMDVJwqopXHUwMDE0YMKdw5vDnsK/wotNWVxcXFx5wpZ5XWPCiXlawrEhScKMKMKOXHUwMDE4wovDlMK2w6FdwrVYwpbCjlx1MDAxY1xcXFw9QFrDg1x1MDAxY8O1w4PDncOVQVpcdTAwMTFHwpBbcTl2wpHDuHnDiMO0w4LCj8KOW8KUw5tcdTAwMWLCtsOHwqliw73ClUTDssOCKFx1MDAxZcKKw5Z5ZVrDhcKQRF3CuGvClHZ+w4lewr3Dh1x1MDAxZXvCosOUI8KwXHUwMDFhw6hcdTAwMWM7XFx2PU3Dkl/DrGlVw5EzeVx1MDAxNkZTw4bCksOSWcKGw7PDqVx1MDAxMsKXw6nCn8OawqF1wpslW8OxwqpcdTAwMDY9fXvCocOIw4lCwojCj8O9w6Zuwo/CpsOdPUDDusOkXHUwMDEwwpLDo3fDt8KDw7FcdTAwMDPCkFx1MDAxZMOewqXDt00uXFx0w4XDicKxw7PDnXhVXlx1MDAwM8KJwqHDtlx1MDAwMsO3w5R4XHUwMDE2QMKJwplgwqN8MkVkVcK8w6fDpFjCs0fDv8K+w604XHUwMDAzwofDuFTCr8O5wopFWMO2wpDCv2ZAw5tcdTAwMTRcdTAwMTXCgcOaU8O8wpXCg2bCi13CpcKhXFx0OGDDp8KZWVx1MDAxNTrCmsKuw6fChcOzw5wgMcO5w5o5ZFjDm8OFw4/DmcOdbcK2XHUwMDE4w5ovwrjCuVx1MDAwMlnDmMO5XHUwMDAzbFx1MDAxMcOhXHUwMDE2c1x1MDAxZMO5XHUwMDE2woYoOcOgKMKfYcKlXcOAw6xIaMO8XFxcIsKrwrtGw5gpw4vCqsONw7k1XHUwMDFhw5lvw7RiwozDlkRIw4/DjcKzw5nDoMKUPU3Dh3/CpMOiw5fDiUs9QMOpwpjCtsOdw5zDt1x1MDAxYThDdcKmwqLDm1/DuGHDmsOtXHUwMDExXHUwMDE1R1x1MDAxYcKMw7coXFxcIlxcXCI2wpHClidcdTAwMDMvSUhfMsK5XHUwMDAzXHUwMDE4wrjDiSlcdTAwMWLDrm3CscKiPU1cdTAwMTZEMMOlwo1JZiVdXHUwMDFlPU3CnsKwPUosw6FKwqbCqcKiMsO4wrJIwrB/PU1sXHUwMDFiKFx1MDAxMsK7w4IzN8Otw5VcdTAwMDbDrFx1MDAxYsKoXHUwMDE3W8Kiw7TDsXLCpiBcdTAwMDLCgsOmw55MRMOhwqPDrlxcZsOuw6E9TcObw7HCrGJcdTAwMTY9TcOCwqp9eVBcXGbDv0vDs1xcXCJcdTAwMDTCr8KzXFxcIsOnWj9pXFx0w4DCsMOhXHUwMDFjUMKLw4VcXFwiNkbDm109fcOFwqbDtMOsfcOXUD1Nw5vDjcKdXHUwMDFhwrgmwobDhmTCkTRAw5fDtsOtw5lcdTAwMTVcdTAwMWRcdTAwMWLDvMOvL8Oiw4zDnDpZdVbCrGTDmkJlw7PCvz1KwrBcdTAwMWRPwoLDkcKMVMKIwozCgcK0wr9YwqvDl0nCgcKwwpnDqVfDrcOkXHUwMDEzXHUwMDBmw4LCo37CuMKnLFXDmlxcdsOQNMKmXHUwMDBmwpEvOMKPbsKiXHUwMDFmfjtow55twq7CgcKIQcKLKTlMwqYqWsOmL1x1MDAxYcOlLsOww5LCgMOZwqzCm1V1O1x1MDAxY8OCwoDCq8KkIcK/TcKew6I2XHUwMDAzw7lZb1xcdMOmw5DDjMKFw7HCtMK7w4R0OyRcdTAwMTPCiMKqwpg5w7RtNMOmwoZcdTAwMWXCj8KZYFx1MDAxNMKcw7huNcKUw7zCu8O9KD4+wqhiM39ZwrDCm8KsPUpcdTAwMWLCknIlYk7Dt25MwrHDtMO7wpJcXGbDhDvCksOsw5zDi1x1MDAxMnRwSsOEwo5cdTAwMTbCscOkwqAzwrvCucObUXzDtETCssKGwoBlw4tcdTAwMDTDhyBcdTAwMTLCp8KtP2wjw5BSw7XDuypPwoY9QGx0TX97XHUwMDA0e2jDtDrDssOMKMKdKFxcXFzCucKYwqfCj8OowqbCp8OvwrJcXGJcdTAwMDbCkcOgRsOow7DDtnZmw6/CtsKiwqnCusObwrnCksKOw6w9QMOYwpDCpMOZw7fCkcOcwoh4wo3DmMKHw7bCijxcdTAwMDHCsFvDuMONXHUwMDA2w4PDhUfCsMO2w4FbfHbCjMKEw5XDmsK2woRPw54mPX1WXlx1MDAwMsKeXHUwMDA2JcKFe1x1MDAwZVx1MDAxYsKOXFx2w4E9fcOxeVBfw5HCuFxcdFx1MDAwNMOWXHUwMDAzJsOawoMkwrksw4VRw5zCijHDqEDDnMOFRsOxw5w9QE3DkMOaXHUwMDE0XHUwMDEwX8KWw4dcdTAwMTbCjMKgwopcdTAwMTXChCDCoFx1MDAwM3g9QH9cdTAwMWJSw5XCicKkw4DCt2PCqcOHw6ckXHUwMDEzO2VcdTAwMTRcdTAwMWTChSAmw6NJXHUwMDE2wqzDjVohw5luOMKFw4RTXFxmw6PCpcO+wprCtMOfOGjCgMKPwrLCgcOew4LCi8OXw4E9QMKiXHUwMDEywqUxRsKjw71Dw7HDlkjCrsOROVx1MDAxYsOsw6fCgUNcdTAwMDZdw7pJw4lSM8OsXHUwMDBmXHUwMDFmw63Cmlx1MDAxZsO0wrtcdTAwMDJOWUbDmcOhwrPDrHPCscOMXHUwMDFiYz1NM1x1MDAwMmNoK8OVdnfDsMKhXXzDmybDinNcdTAwMDJcdTAwMGXCoFDCmEZgQ8Olw5nDssOvwrPDsVx1MDAxY1x1MDAxYcOvw6cvwoLDpcOMMileWMOrwpB1w5BsScOYPsK5XHUwMDE1WMOtXHUwMDA3XHUwMDE5w7TDm1x1MDAxY1x1MDAxODTDhklSw6xUwqVvXFxcIlx1MDAwNFE7KMO5w5RcdTAwMDQpQFx1MDAwMcOAJlx1MDAwM8Kbw4nDu1x1MDAxYVPDj2B7QcOSw7HCvlx1MDAxOcObwrfDnsKKL1fDqMKKMcORw7PCkT19wqZkU2jCl2pcdTAwMDUmXHUwMDExw7Qpw6fDjT7DmMK9OcOJXHUwMDEww70twpLCsDjDkHHDuynDmCZcXHRlZMKLIFsjWlx1MDAxYcKzw4w9TVx1MDAxMj5kwr0owqFcdTAwMGYpXFxiWyrDmMK9eUbCpsOQw7rDr8KeL2fDh8KWJMOmwrNARsK7w5vCvykpXHUwMDFjw7nCgG/DscO6w65cdTAwMDbDvFx1MDAwNMOww7hcXGLDi8OJwo3CqVHDkStYw5gtMcOjw6PDpcKlwqQ3IEBcXFxcMiMkIzE2MzY0w5zDv17DncKdSFx1MDAwZVNcdTAwMWVcdTAwMWJFPD5cXFxcwpZcXFwiwrJ7w43DsW7Ct8K1wrPDhzrDiWJbX2dNXWXCkXRre3PCk8KDb8OPw5fCuMK3w5XDocKpw7LDslx1MDAxYcOSw4IzM8OzU1x1MDAxM0PCvVx1MDAxZDR1w7RUw5TDkFx1MDAwMcO4w4jDocKaw7PDnMK/XHUwMDFmwpVhwpjCk1x1MDAwNsOjwpVcdTAwMTnCqDXDrSvDqE3DsE/Cj3ZTw5jDksOIY8KhXFx2w7zCv8KVYVx1MDAxOVx1MDAwMsKdPUrCklx1MDAxZMOzXHUwMDFkwoHCmVxcYsKnXFxcIlx1MDAxZVx1MDAwZsOFw7lpKMKSw4PCo8K3dsOyU8OZwoXDnMKQw7XDmG3Dt8ORWcOgXFxiwqUoKFx1MDAwNUlfNT5jw5PCniDCtMO3wqXCucOJw6c9QChcXFwiw7/DscKYZz19IcKLW1x1MDAxMy/Cv8OdQMOXwoTDqcKXXHUwMDAxwqvDjVx1MDAxNsKvw6BlwrnCicOoXHUwMDE5JsO7w5HClFx1MDAxM2VYw6XCnMOrXHUwMDA0w5DDjcKRwoRcdTAwMTlnwqUhw5/ChcKKYV7Dn8KcI3jCpidcdTAwMTPDgWjDiMOtw7JcdTAwMTbCg0XCucOfaCnDk8KSPX3Cvn7DpMKKw73Di8KdXHUwMDE3WcOoXHUwMDFlXHUwMDFjJMKvXHUwMDBmw7hcdTAwMDXCoMOcJ8Knw4kmwqrCksO7ZCZcdTAwMWHDgcOGwpXChsO3IMO1XHUwMDE5XHUwMDBlw4fDjHRcdTAwMTXCuVx1MDAwNiRSYVrDi8KYwoHChcORw5ZcdTAwMTHDjlx1MDAwZlHCicO1OMOIXHUwMDA2wppcdTAwMTPDhcOWwqVcdTAwMTRcXGY9TUfDnFxcYsOjXHUwMDE1w5knw4BcdTAwMWLDh8Okw6Vtw7DCicKeMlx1MDAxMMK1ckxeT8KpXHUwMDE1PUpcdTAwMTlcdTAwMTLDu8ONJSDCl8OVO8KEJ2VcdTAwMDMzwqnDl8OXw5dcdTAwMTHDuEfCiD1KwpF1XHUwMDE4wrpcdTAwMDbCn8Oew4/Dj1x1MDAwZlx1MDAxYVxcdsOHw53CpsOWw7NHwrzDpcKEw5nChsOjw7zDvMKcworDqMOJV8OjbcKcQSNNwqEkXHUwMDA0wrplTsKhwofDo8KiXHUwMDFiXFxmwrM9fcKlXHUwMDEwJFx1MDAwM3RcdTAwMTg9Sih4w4dkwp9cdTAwMGVyw73ClsKJRcKcwrFcdTAwMGXDmMK1XHUwMDExw7jDh2XCqMKmIUZpwoXDtMKhbU1XYsKUQXnDqzzDkl5cdTAwMDNDw43CvFx1MDAxNMOKwqZcdTAwMTLCn8OeOS89fcK6XHUwMDEzwqIkTsOXasOPKz7Cllx1MDAxM8ODw5p3XHUwMDA2dlx1MDAxNDc/Nn3CusKswovCk1cvZMK3w6gqw5XCtFx1MDAwZXrCl8K+XcOnKsKMwrBBwqrDmMK4w4whw7rDjcOSZ8K+VMOHbcOhw7vDpFpJXHUwMDEwWFx1MDAwZmvDmcOKZ8OSP8O+wpnClFbCp8KuSDV1wq5cdTAwMTPCrChcXGLDj8KPwooow7RDwoLDvMOVw4TDoMOOw5TDk0F+KsOnwrM4KsKWw7PDusOzXHUwMDFlQ8KEwrvDtMOOw5h6J1x1MDAxMmPCnmnClDhcdTAwMWbCq0R4XHUwMDE5w47CsX1lwotbw7J2JDTDl3NcdTAwMGZ9w6HDksKrXHUwMDFlPMKkSsOfwq4keG/DujFcdTAwMTIyXHUwMDE0KsOPc1x1MDAxMcO9w6HCkm3DlMK2wqRywqPDvcOVwpPCmcKUX8O/bcOvw7xRXHUwMDEywoJcdTAwMTQuwo8yfWZJbGJrLMOuXsOCw7t/WlnDoDTDjD19wqZcdTAwMTNcdTAwMWZaV8KeZ8OuQ07DuldeOVxcZl1YbMK2akfCisOlOMKMP2xcdTAwMTJwZC7CjFDCosKeZMKnwrvCgMKtw4MlXHUwMDAxK8K7NVx1MDAxMytawqkpNcO2J1xcdHXCsWsuwq9Ew4d1wonDkVx1MDAxZkrCoD1NSMO2PU3CiXPCpWw+cEFuLEbDj8Oxa2bCr0jCh2xcXHTDjcKPSyxcdTAwMGVWbkvDtsOKw5dKw4A9TU/Drj19wpbDkMKxan7CsFZnwrtodVVrZsOyf8Kyc8OCNX3DkFx1MDAxMWzClm5SVsKFQDRbRHTCnkDCp8K/PUDCrFx1MDAxMsK6XHUwMDA1OsOLw5rCvkguwptIaUo9QD1KSmcww4wxw55cdTAwMTIsJGDCly7Dm0zCuUrCiMKLN1fCrsOSwrnCiMKyZsKSw5DDsW0mwrA7VsKoIDIgfHTDjnjDq8K4wrvDvcKKf1x1MDAxZcKTw75dXHUwMDAywrjCli1WXFxcXMOnK2zDvDxcdTAwMTN9XsOJw4RuwofDjFx1MDAxNlx1MDAxM8KDw55nX8K1wqRxN8OPw6HDvW3Dk1x1MDAxN3rCoXfDjFnDu8OaXHUwMDEyRcKfwq3CnMOLQcO7WMO+TFx1MDAxNFVfw4RcXGJxwrnDkCB7XHUwMDE0ejFcdTAwMDfDilx1MDAxZsOTw5PDvsKnw7TCtcKIb8Kle8OVworCt8K+wpIkQkd3R8ONXHUwMDFlXHUwMDEzw5NcdTAwMWXCp8KEwrh0w4vDuHs9QMKeN8KXd8O/amLCmkrDp8KvOMOOw6B6wpx6w7XDh8ONwr/Dk8KWXHUwMDE0RMO/w4nDiHEhw5FcdTAwMTB7w4nDkjtcdTAwMWVYwqQuw5/CtXzDkMOdXHUwMDEzwpXDnmB/csOfw60swp7DtcKSYcKUQ1x1MDAxZsK9wrTDjjnDu8K7w75LdMOFWMOOXHUwMDA1wpPCjcOULFTCkcKwwpjDikPDlCvCjFx1MDAwZlDDulZnwqvCjFPCjcOSP0nDvcO8OsKXwp1ETGjDkMO9QDphXHUwMDFkRsKMYWDDvCg6K013UcO7w5HCkyvDrlxcYsKGwrBcXFwiwrlcdTAwMDPDni1uw7vDpsKxcsK4R1x1MDAxZVrCssKxO8O6Q1x1MDAxZcKPwoQtTMKbwphsXsOywoxcdTAwMDQ/wozClMOoa8KGw7HCqGRGw4zCjV5cdTAwMTJmJFDClypcdTAwMWYgLcKyN8OTw5ExbcKuw7dJwrJcdTAwMWNieMOxasOWwrYrwod0acOKXHUwMDBmS8OkXHUwMDExZm7DgsO+w7xgOsORXHUwMDFkRMKMb8Ogw7xrOsKbTXnDkcOsLMKeVDpcdTAwMTXDvTRcdTAwMWJQXHUwMDFkwpNRwrJcdTAwMDQjNsK7TcOlXHUwMDEzwrs6wqnDjWx5w5DChcKTR8KyJsOjLcO7UcO1wpPCocKyXFx2Iy/Cm07CsVx1MDAxM1LCssOww7vDi8K1XHUwMDEyZcOeM8OuK2fCq8KCwr7Dn17CrMKyw4howrJUw6vCnkbDrlx1MDAxMMOCw7pMJDPDg2twXHUwMDEww41/UMOrXkHChjrCo8KMIMKFO1xcZlx1MDAxMcOgw4lSw6NUbMOZw5nDg2Blwpc7S8OZM8K7w7fDpVx1MDAxZG5yPU1cdTAwMTXCtlx1MDAxMMOYa0zCjsOpwqXCh8OdJMOxNFx1MDAwZWRcdTAwMWLCosKdXHUwMDE5wrQ0TsONw7tcXGLCpsOsw50sXHUwMDBmR1x1MDAxOMKWSMO9woTCuMOgwpfCvcKPWcOtw77DiD1Nw4nDv8KDw5XCpcKPUj1AXHUwMDAzwr53N1dtacO8R1x1MDAwMz/CscOqLsOUIcKMwoPDt3zCnlx1MDAxNMKWOiVWwp9Uw6QkVMKsXHUwMDBmXHUwMDE3U2vDvShQw5pcXGJJwrV7w5JcXGbCjsOgXHUwMDA0w45Cw5fCgFPCjVxcdC9Aw4t5w73DlVx1MDAwM8OMw45sw67CnsO5woxcdTAwMDc0w6pcdTAwMDdhwpNLXHUwMDE1wobDgMK5wrBcXHTChMO4XHUwMDEwQFx1MDAxMcOLw5NcdTAwMTg3w5ZcdTAwMWXDjlNcdTAwMTJcdTAwMWFcXGZ3XHUwMDE2IXvDo1x1MDAxMsOuw4VcdTAwMTdcdTAwMTZyw7FGXHUwMDBlXHUwMDE1w6DDgV9cdTAwMTXDtXDCnlx1MDAwM8KLw6BcdTAwMWHChkDCrDDCrcOHWmc9fcKTwqdow7fDqEjCvsKrSEXChsKMwrdJw5HDjcK1w5LCt39ZdW3CtcOMXHUwMDA1XHUwMDAzwoVUw5NcdTAwMTLChcOwbWDCqVx1MDAwZm7DnmdcdTAwMTlDdVx1MDAxNU/DjVx1MDAwNlx1MDAwNmFcdTAwMTZcdTAwMDbCo8KzcsKoXFxmUT1Aw6BlSFx1MDAwM8K2XFxcIsO4w6jCtMKzbTUkwp/DncKhIMK5USbDrVR8w5vDsj1Kwq8+wohBQsK3wrR4w7NcXGbCsMOUw5tcdTAwMTJcdTAwMTFUL8KWw55pPD/CjzNcdTAwMWHCqjE7XHUwMDEyw6jDkVxcXFwoXHUwMDA2X0RcdTAwMTjCgcOtw4NUwotcdTAwMTI8PUDDqsO3ME3Cu8KYwrNgKMKXRsK0w5hkXHUwMDEyXFx2wqvCpMOtw7rDj2UwwqJQaS7Cp1Ndw7AmwpnCq8Oyw7zDqjbCicOpO8KqLCHCgz1KwonCtz1KXHUwMDE4XHUwMDFkw53DsMK1wrXCp8O6XHUwMDFkdcOgw6LDg8KLwrrDv8KawppDXHUwMDFlNnDDucO5ZMKMXHUwMDFkwqfDiMKyIMKaw7A1XFxmXHUwMDA2w7vDrjdYXFxcIsOFw7ZKLsKuXFx2QsOrYzZcdTAwMDE6XHUwMDA2wq1cXHbCiC7DucKKwqJAa0RCw7xswrpQwrDDnjvDpi3DrcOlOsOmPX3DrcOlO1x1MDAwZSttwog6XHUwMDBlM21cXGI6XHUwMDBlO23CiDtcdTAwMGVDbVxcYjvCvittwoM6wr4zw4xyw77DqsOXZURtwoM7wr5DbVx1MDAwMztcdTAwMWEqLVk6XHUwMDFhLi3CmTpcdTAwMWEyLcOZOlx1MDAxYcK2wq7Csks9SkswwohcXFxcw6p9NsOmwo/CqsOxQsKiw7cqw7lbXHUwMDFhw4grQ8KKwrovLVxcXFzDq0pFMMKOwq5rwoA2w7I2wq1cdTAwMTZCwrpLMMKDXFxcXEp9NsOcwo9qw7BCwo7Dt8Kqw7Zbw7LDiCtHw6rDijU2XHUwMDEyLjBcdTAwMDfCimpxw4rDpcOcwrMrw4fDq8OKZTZcdTAwMTI6MMKHwoxqw5FaXHUwMDEyQC1kwrBrXHUwMDAxQsO6YzbDpMOxwqo4wozDum8wwp48wq3CmFxcXFzDisONQsKewr8rw4fDr8OKw6U2XHUwMDEyWjDCh8KQasORW1x1MDAxMmAtZMK4a1x1MDAwMUPDusKjNsOkw7kqMFrCisKrK3bCisOqMC1Cw6vCqj9LwoowLcKgwq7Cqks2woI8LMOQWsKKdTJCw63Cql9Lwoo4LSDCrsKqazbCgj4sUFvCisO9RVrCtCvDlVxcYsKqwoN2Y8O5wq9cdTAwMDPCtsK/XHUwMDBlITNcdTAwMWPDhcKKw4HChlFcdTAwMDJPIT19XHUwMDE2wrxcdTAwMTEzwqBzwqQuw6VOwqfCrMKHXHUwMDFjaMKswodcdTAwMWPCqMKswofCvEnCrMKHwrxpwqzCh8K8wonCrMKHwrzCqcKswod8SMKswod8aMKswod8wojCrMKHfMKowqzCh8OsOcKswofDrEnCrMKHw6xZwqzCh8OsacKswofDrHnCrMKHw6zCicKswofDrMKZwqzCh8OswqnCrMKHTDnCrMKHTEnCrMKHTFnCrMKHTGnCrMKHTHnCrMKHTMKJwqzCh0zCmcKswodMwqnCrMKHw4w5LsOlbmkywqDCs8OoOlx1MDAxNjwnS1x1MDAwMk8kbsOadVx1MDAxZcK1worDgVx1MDAxMkXDq1jDu2nCrMKHw4zCuS7DpW5pM8KgY8KnL1x1MDAxNjwnT1x1MDAwMk8kdsOadVx1MDAxZcOFworDgVx1MDAxMmXDq1jDu8KpwqzCh8KsMcKswofCrDnCrMKHwqxBwqzCh8KsScKswofCrFHCrMKHwqxZwqzCh8KsYcKswoc4wqnCqsKHwqxxwqzCh8KsecKswofCrMKBwqzCh2xcdTAwMGXDgsOGTVx1MDAwMcOyZ1x1MDAwZcKIXHUwMDFjNsKjw4DDjmvDvEzCk8K8w57Ds2XDssOlw7Jlw7PDpXNIcsKIcsOIclxcYnJIc8KIc8OIc1xcYnNDcsKDcsODclx1MDAwM3JDc8KDc8ODc1x1MDAwMzM5MlkyeTLCmTLCuTLDmTLDuTJcdTAwMTkyOTNZM3kzwpkzwrkzw5kzw7kzXHUwMDE5wrM2wrJWwrJ2wrLClsKywrbCssOWwrLDtsKyXHUwMDE2wrI2wrNWwrN2wrPClsKzwrbCs8OWwrPDtsKzXHUwMDE2wrM4OsKHSmRrwp7CrVx1MDAxMjLDuz/DjF1uwqHCsjg7wodMZG/CnsK1XHUwMDEyQsO7X8OMwp1uIcKyODzCh05kc8Kewr1cdTAwMTJSw7t/w4zDnW7CocKzOD19wodQZHfCnsOFXHUwMDEyYsO7wp/DjFx1MDAxZG4hMzAyQDJQMmAycDLCgDLCkDLCoDLCsDLDgDLDkDLDoDLDsDI9QDJcdTAwMTAyIDIwM0AzUDNgM3AzwoAzwpAzwqDCi8O7w6HDt8K8XFx0RsOgM8OwTyHCnVx1MDAwMlHCn8KqTmfDmMKYSsKfwq5cdTAwMGXCp8KGXHUwMDA3a1x1MDAxNDpzwqjCrsK8JsKbwp83w5PCnU4jXHUwMDExXHUwMDE0THxRc8O0w7HDv3/DjsO4wrzCvsOJw5XDtXLDh1BcXHY5woFcdTAwMDHCu2R5w6xpw5hYTsKfw4zCrsOpwobCh3NcdTAwMTR2MynDo8Okwr7DvsOTPCPCmsKfV8OTwp1PXHUwMDFjPU1cdTAwMTTCjHxRdVx1MDAwZcO1w7/Dv8OOw7jDgMOyw4nDlcO1c8OHWMO7OcOYw5hRwp/DqG7CqcOiw6DCqsOeMzwnXFxmXHUwMDA0NMO8wpByXHUwMDFlwrnClXVyw4VMw7t5w5jDl0vCl8K4bsKpw6PDoMKyw55zPCdcdTAwMTBcdTAwMDRUw7zCkHNcdTAwMWXDicKVw7Vyw4VQw6sxXHUwMDAxPUDCu2B5wqxJw5hXTsKXw4wuwonChsKFc1x1MDAwNHYzKMOiw6DCvsOew5M8wqbCnMKXV8KTwp1PXFxcIlx1MDAwZlx1MDAwNMKMw7xQdVx1MDAxYcO3w5/Dv8OOw7fDgD1Kw4nClcO1c8OFWMOTScOiw6DDiMOeI8K8JMKtw50vwrJ3SsOTwoliwoXCq1x1MDAwMjbCvCTCscOdT8Kyd0vDk8OJYsKFwq1cdTAwMDJGwrwkwrXDnW/CsndMw5NcXHRiwoXCr1x1MDAwMlbCvCTCucOdwo/CsndNw5NJY8KFwrFcdTAwMDJmwrwkwr3DncKvwrJ3TsOTwoljwoXCs1x1MDAwMnbCvCTDgcOdw4/CsndPw5PDiWPChcK1XHUwMDAywobCvCTDhcOdw6/CsndQw5NcXHRjwoXCt1x1MDAwMsKWwrwkw4nDnVx1MDAwZsKyd1HCk0liwoXCuVx1MDAwMsKmwrwgwq3DnS/Cs3dSwpPCiWLChcK7XHUwMDAywrbCvCDCscOdT8Kzd1PCk8OJYsKFwr1cdTAwMDLDhsK8IMK1w51vwrN3VMKTXFx0YsKFwr9cdTAwMDLDlsK8IMK5w53Cj8Kzd1XCk0ljwoXDgVx1MDAwMsOmwrwgwr3DncKvwrN3VsKTwoljwoXDg1x1MDAwMsO2w77Cr8KawrImwqpcdTAwMWJAwpvCpXbDmD19NsK9JXPCpXfDiFFCUFx1MDAxMzs2wr1cdTAwMWUzwrDDsyUywrDDsyUzwrBzwqgywrBzKMKywqdqXHUwMDFjdVp2XHUwMDFjeVp2w7RtWnbDtHFadsO0dVp2w7R5WnZcXFwia1p2XFxcIm1adlxcXCJvWnZcXFwicVp2XFxcInNadlxcXCJ1WnZcXFwid1p2XFxcInladlx1MDAwZWtadlx1MDAwZW1adlx1MDAwZW9adlx1MDAwZXFadlx1MDAwZXNadlx1MDAwZXVadlx1MDAwZXdadlx1MDAwZXladlx1MDAxZcKrworDglx1MDAxMjHDq1rDu0HCrMKLw4xpLsOtbsOJMsKwwrPCqDs2PX3Cp01CUCRxXHUwMDE2acOMwrkuw61uaTPCsMKzw6g8Nj19J09CUCR2WnZcdTAwMWXDhcKKw4JcdTAwMTJlw6taw7vCqcKswovCrDHCrMKLwqw5wqzCi8KsQcKswovCrEnCrMKLwqxRwqzCi8KsWcKswovCrGHCrMKLwqxpwqzCi8KsccKswovCrHnCrMKLwqzCgcKswovCrMKJwrhOIF7CocK3XHUwMDA2TcObw6HDo8KRc0Q8wqXDhnXDhcOmbcKMw5nCnVx1MDAxOVDCo8K6XHUwMDAyXHUwMDFkwoZcXGJySE8gaMOBwqF8MHPCqcKqVUVTw43DjsOpw6rCv8OHXHUwMDFhasO8w4k9SsKibcKiTlx1MDAxM8KZwprDpk1mwr5cdTAwMWVxYlxcYjxIdSRVRlx1MDAxOcKzNk4nQ3hgbnDCvCg4UWVMbXPCqcKywr1XwrvDm8OOw6nDrsOzw4hcdTAwMTLCqsOOacOvXHUwMDEzMMO7O3PCqcK1w71Hw4xtwrwoQsORwoVuw7FOJ194IcKyOHQkwp3DhsKYPEfCv1x1MDAxZSFiXHUwMDA3T2RWXHUwMDEzOcKcw6R3wp7ChsO8wolcdTAwMGXCnsOJwopqw7zDiVx1MDAwZcOaa1pMXHUwMDEzwpnCnFx1MDAwMktCwrxcdTAwMWVxY8KWO8K2cyTDlUYgMjBPJ8KDw4vDjsKpw7XCi8K/wopAwoBywq3DqsK6Lz1Kw618wq9vw7PCnMOqwp3DvzBrTMONw6rDgcOfMcOmwoNcXFxcw75qXHUwMDFhXVcrecK9UD8qwojDjXc9SmHDnMOOTMOqPU3CnirCpng0wr4xXFxcIsOhwoDCqsKxdcOBNDDCmcO/YFx1MDAxYcKBXHUwMDAzfMKNw6vDvcKfLsKmwofCtDrCj8K/M0jDjlU6wp9fRsKmdGXDq8OVw77CucK0L8Kpw74zXHUwMDFhcsO7w5rCnHIswqLCq8KEwoovPMKJXHUwMDFhNcOXMcO5wrpDw5YwfC8ow4rDkTrDpV8yJmd1w6s9TcONL1XCsT7CqsOJXHUwMDExYMOWalxcXFwwZmkxw6shw63CrX9ww7zDq3HCnjvCgMKwMivDmXtNXFxcIsK3XHUwMDE2wopcdTAwMGbCumRcdTAwMWFAw6fCrz9Nwq49SjfChC0oSk3CgsKPw45Gw6ZqwrnCisOfwrxcdTAwMWI9SkHClDDDucK6Plx1MDAwZixIw4dvPUrDvXvCsSfDkcOQwqpRXHUwMDExMC5uwrcwXFx0w7hoXHUwMDFhXHUwMDE4w7J7wpg9SsKhwoMww4hBwpdUOsOmUsKFw6rCucKMd2/CrDFcdTAwMTA6XFxcIsKKXFxcIsOaeilOXHUwMDFhw7/ChsKsXHUwMDBmXFxcIsKxwqwhwpBlXFxcIsKZXHUwMDE2wotjKMKDPUrDn8KjMVvCkDbCosKPRMOqWcKNNsO7wo8/PUrCt8Kjdlx1MDAxZsORUMKqwqnCsC85wrdew5bCvMK8LsKIwrvDvcOaXHUwMDA0wrRpXFxcInNgwqzDkcOuLMKAaMODOCjCu1x1MDAxMTrDkVx1MDAxMDgowrlcdTAwMGY9SivDu8Krf3zCtMOqXHUwMDE5wpsxwoDChcKzLHnDssKLXHUwMDFhwq8ywopvwr82XHUwMDFhw4PChsKwwr/Cg8KwwqtBwo8xXFxcIntGworCv8K+XHUwMDAzPUpnwqM5w5XDokpcdTAwMWHCuMOWLynCsjPDlsOSTCzDmcOyPX3CgsODTzgmTkJmT8OaPit/YcKdUMKDwrwtw6JcdTAwMTQ2I3pcdTAwMGbCrMKpw6JcdTAwMWHDiTlhwpLCq8KGZlbDlWzDrMKpw5BcdTAwMDfDji/Cn3zDpMKaeVrCksKuLMKSwqsxXHUwMDEya0RcdTAwMDbCmTXDhFtAwp5tME5jOsKOw4M2w5zDny5cdTAwMTNwwqrCpl9rw5ArSsO/wqZyeTnCjkQsfFx1MDAwZsKrTmdrw4BcdTAwMTNKwoVlwrpcdTAwMThiwrrDmVZywo06w7LCjUzDssOxNE5eMMKOw44vwpxDLMK8UyrDk1x1MDAxMsKtwobCsMKswo5cXFwiSjdZwrrDsU7CusK5Z3JSRMKOTjFGwp8tw4jDkCrCucOXwqvDtcK7w6rCkcKXPUrCl0rCmsOhOnTCjirDpkcwXHUwMDA2PypxMS15XcKqw7E4w6pcdTAwMGZCPUrDnWbCmsOvR1xcXCLCvDTCpsOcK3hvK8OZSlxcZkHDokYxwqZQO8KxXcKRVMKiwr1Pw5TCjmvCtcOzw6TCrCkzwrjChMKnRcOifTNbwrHCrmUlPUrDscKGXHUwMDFhw5VcdTAwMTRsw7PDh1xcdsOkVFx1MDAxYcOsQMOiw4sqRlovSMKiw6o9fXRcdTAwMDbDgDUtSk9fUsOXR8K+w4Exwo9ewq18wqRsw5TDtHpwwpVSw49Gwr7DtkLDtFx1MDAxMDDCj8O/wrDDvCDCsVx1MDAxY3RtXHUwMDE4NkrCqcOYwrrCiTfDssObLVx1MDAwZcKDKiPDnsKqw4Y4MHjCnVxcXFxcdTAwMWVAw5k9TcONw7JvYcKcY8Omw794NcKcIGpuTlx1MDAwZXpcdTAwMWPCocO3wrHDjFgqRytcdTAwMDQ4w54rwpI/w7osw4pjasOVwqvDgCtXLMOEUSPDpy7Ckj1AKVx1MDAwNm3CqMOZwrrChsO5I8KpwrzCmVx1MDAwNUfChFx1MDAxYX9UwoJcdTAwMGXChVx1MDAwZsKBXHUwMDEzwoVcdTAwMTN9w7MqI37DsMK4wrJHQ2VMwqTCjsOowofDiFx1MDAxNz5cdTAwMDXClCfClCfCr8KUXHUwMDE1PyFcdTAwMWEhNMKeIWXDucKcw5XCn8OVSH49TVvDrcOnXHUwMDA0w6fChGJPWsKoXHUwMDEyXHUwMDAywovCjcONwrDCuFx1MDAxZMK1XHUwMDFieUjDhlx1MDAxM3zClmXDv1TDq8KLwq51XFxcIsKywrLDmsObw61MwrFwL2/CscK2SWTCqMKSw4BcdTAwMTc+w7UsXHUwMDFkLFx1MDAxZCPClDXDv0HCk8KWelx1MDAwNsO2XFx0UVxcdFbDsVRcdTAwMTZcdTAwMGZcdTAwMTNcdTAwMTbCncO1bVPCqMKzbcK8wrDCuDXCtDPCs0NbWMKcfsOWXFx0wqLDicK+w6vDk1xcYsKTXFxiLy11JcO3w5zDgsKLwrzCikdcdTAwMTRSwrZIXHUwMDE5w4fCmMOJwovDgVx1MDAxN8OCwpnDh8KVw4fCjcKHw5DCicKXWn3CjcK4wpDDp1x1MDAxY8KEw78wXHUwMDFmXHUwMDE3dMKlI8OxP3jDtFx1MDAxN1x1MDAxMMOXXHUwMDBmwpVcdTAwMTdFw4ZHPmPClnZuwqLCtlxcdFx1MDAwMsK6w5I9Slx1MDAwMsKLwrPDq1x1MDAxM8KIQ8KYwqMtw5HDolx1MDAxMcKifsOjwoBcdTAwMDVYXcOFwo3CvsKSO8KUwpnCiTxcdTAwMTnDgVx1MDAxM1pcdTAwMDPDoMOKwonDk8KTw5vCj8K7w4PDssOWw7DCpsOgPUDCjMOHP8OEN8Kkw5VcdTAwMWXDocKSX8OTSHtkw6zCicOQXsKFb8KlScOEXFxcXMKewp5uwqJcdTAwMTZcdTAwMTJ+UGhiXFxiwqnCjHJwwprDmMKlXFx2w6pcdTAwMWPCq8KvLTVcdTAwMDbClTHDvlx1MDAwM8OWW8KHwpLCvsKKQDTCtcK9w49qdXBAZ8OdXHUwMDEwwoRew5RQLcOrXHUwMDFjXHUwMDAywrLDtMKrwrPChcKXw61Dw5xqXHUwMDA2XHUwMDFmJcOeworDhsKswrzDlMKww4DCuMOYw6jCq8OLwrvDm8Kzw5PDk8ODw6PDoy92w47Dm0zDlWPCs8OBwoPCrcK/wp/CnDRcdTAwMWNMPHxcdTAwMWTDosKtPUrCszPDs8O+w7LDvsO+wprClFx1MDAxZSpBwrliXFx0XFx2wqjCjWw9TcKswqZtcMKywqlxwrYgXHUwMDFmSVAoXHUwMDE3wqU9SitXwoJcXGbCnVx1MDAwMsOSb1DCpVx1MDAxYV5cXGJnwpXCqcOPwrHCr1xcXFxEQ0PCkcKfIMKvPUBcdTAwMTLDtcK4NFxcXFxoXHUwMDFje8OrwoTDj1x1MDAxZMOMwqPCpSVWw5HCrsO1w61GwrxcdTAwMTU/MVx1MDAwN8OWw6NkwqrDqcKYw4jCocKdXHUwMDFkcsK5w4YxwpTDrcO5w4nClTVgXHUwMDE4woJmw47Dm8Khw55cdTAwMTnDuFDDl2LCrWfDocKMeFfChUjCg1plwpxcdTAwMWUvYcOnc0zCscOlXHUwMDAzwoXCvlx1MDAxNMK9w75+w419X8KnwrZ0YMK4wqnCgmjDn8KewpfDuMO/wr4zI0fCsVbCgG5cdTAwMTfCosOgwqRcXGJcdTAwMDZcdTAwMWY1Z0HDrllcdTAwMWZowpNdwqUgw43CgVx1MDAxZHEpXHUwMDAzZlx1MDAxN1x1MDAwZsOVXHUwMDBlw4TDm1s4XHUwMDE2XHUwMDExw6rCocOxXHUwMDA2XFxmRTnCgcK/w5FcdTAwMTfDmcKgwp7ClMKcwp8ow75cXFwieMOlwpPDvcKia1x1MDAxMMOkL8KDWMOhwpbCnMOow58nwrdcdTAwMDZcdTAwMWRSwo7Cglx1MDAxOMOnXFx2MMKYXHUwMDExKcOyJ2TCl8KYwqQ9Slx1MDAwNHzCi8OrT1x1MDAwNXTDmcOZwpVcdTAwMDEmI0PCoibDssOJWcKFdCTDqCnCjsOIJMOpXHUwMDE5wqXDo1x1MDAxNFx1MDAxNMKzYcK4wpdcdTAwMGZJwrTCnMKUMMOIw7Y0wpw9QEVQTVx1MDAwNj/Coz1Awp3CsVx1MDAwNl5FbS3CqcK1w51sw5QpPsO9QCU9QF9cdTAwMWTDvsK1VXHClMOZXFx0w4zCksOKwqcmw5TCs8OwJcKDXHUwMDFlw5DDicOtwo7DtVx1MDAwNT4+WMKHw6fDklLDqcKNwqNcdTAwMWLDiG3Cu8KPXHUwMDEzNcOewpxJw7nDp39cdTAwMWE9SsO7XFxmwrbDtsK9w41RScKmw4/DgFJcdTAwMWbDkVcvMcOYw4fDijpdSyTCpMOje350JsOtXHUwMDFhTlx1MDAxMSTDusKFwrjDu0t0LMOnwqrCjVx1MDAwNMKhwqfDgMOJXHUwMDA1w6bDvVx1MDAxZWtcdTAwMWPDoMOYwojDhcO3TWTCiMOXScOgwpFnXHUwMDE4wpPCtGnCmF9cdTAwMDVcXGbDusOMwo/DuSBjY17Dt8KEXFx2w4Bjw7nCgcO/wpMkecOPecOfXFx0w7Bhw5g2XHUwMDFhc8KFw51Qw6/Ci8KrwqdcdTAwMTPDpU/DmcK3OMKewrbDjDTCiMO+woPDpcOnwo8wKSRiYsKNw7nDoWPCr8Ojw6nDsMK2wpxcdTAwMTPCqEAkXHUwMDE3wpnChlx1MDAxMcKzwp3CmWjDgMOJRMKaw4PCk8OXwpNcdTAwMTnDpWbDp1x1MDAxMMOyXHUwMDE3wqtcdTAwMWZPXHUwMDAxaWDCpWfCtsKIIVx1MDAxMVx1MDAxOMOROMOvXHUwMDFlwpvDp8KBw51UScO2wrXCoWlhXFxcXFx1MDAwM8KPw4PDrMO+Q8OdWcKAw65gw7fDtMKlw6nCkcKCe8OOwrzDtsOyw5HDlMKRwrHCo8Oiw78uw7jCoTJcdTAwMWPDhX90w680fcKEw7DDqFx1MDAxYcODYFDCpsOmwqnCgsOtwopNVWVcdTAwMTXCscKQw4fDvlx1MDAwNMKoa3A9fcKWJ2xcdTAwMWZcdTAwMDbCqMK2w6RcdTAwMTXDvMOZw5pIw7/CkW45w6DCmFx1MDAwMcK8wojCoiPDgMKmXHUwMDFhw7FcdTAwMGYmw6jDuHJcdTAwMGZcdTAwMTjCn8KUw5TDi8O3wpfDhHVcdTAwMTRBXHUwMDE1woPDvsK2YHzCuMKeJMKcwp5cdTAwMDLDkUlcdTAwMWLCg3fDqVx1MDAxOVx1MDAwZcKOIFx1MDAwNlrCn8KiYHtcXFwiXHUwMDE4w78zwq3DsCEsw6PDnsO5wrHCuFx1MDAwNVx1MDAwNsOLw6HDpsOkwqPDocKcXHUwMDFkPU3Ds8KVwrxcdTAwMTl5w6TClMKbXHUwMDEwe1x1MDAwNcOdwr1cXFxcaVx1MDAwMcKJXHUwMDA3KWgowozDr8KGw5AjXFxmwqzDqMONw5TCsXhGXHUwMDAyw6TDjcKmw7nCsGnCiMOlw57CiCdcdTAwMDPCqFx1MDAwZlx1MDAwZcK7w5fDj8K5dGDDiMK1wqHDlcO5VynDn8KgwoXDtsKrb1DCqy/DtVx1MDAxZcOfwofCkGAzw6jDt8OzwqFcdTAwMDZ9wp9cdTAwMDRjwqHDsMO0L8Odw7Ahw4llwpZcdTAwMDbDmUc0O2jCsVjCuERcdTAwMWPClFxcYsKyw5nCqXA4wp/CosOOQsOeJFx1MDAwZX/CqcOdXHUwMDFjwpPDj8O1XFxmJ29NLcOTU8Opwo3ChDTCpS9fwpNtw5/CrVxcXFxBZcO1TsKCZMOIw4dcXFwiwqDCgsOnXHUwMDA0wq7DssKSw5dcdTAwMDRGZ8KHXHUwMDExw5bDpcKwwq3CrsKVw4/DkMODeMK6wrXCu108wqZawqLDkjzDoMKPw5slw5U9TcONwofDu0RfwpDCkMKPw4VcdTAwMDFcdTAwMDbDoFx1MDAwZsOAwojCgU13w4nDqVx1MDAwMcKcwrZcXFwiwqPDtcOYw67DpFx1MDAxYlx1MDAxNsOfw6vCk1dkcDjCgT1Ae1x1MDAxOVjClkjDv8O+w5hIw4TCoz1NwpzCsMO9wr3DnMOseTnChFjDmcKpwohcdTAwMDJIKcKkwqHDkcOvZVx1MDAwN8K5w7loQ1/CmVx1MDAxOFx1MDAwNsOoWCPCpcKIwrd3XHUwMDAxw4MkwoHDp8OmXFxiTcKfwpZxw7NcdTAwMDbDvsKdwojCv8KXOSh+XFx0w4jCp8KMf1xcZsOcXHUwMDFjwrA9TcKlw4LDr8K0d8Knw7Uhw5RcdTAwMThcdTAwMDNXw5HCvsOlPU3Cs8Ktw7XDgF7DocKZRcOcfDjDhsOiwonChMKabsKkw6ZcdTAwMDXDqy1ow6nDssKcwpDDvsOtQMOnRVQ3wolcdTAwMDFcdTAwMDfCtsKlacOPw7vDtsKccmvCscKaI0BcdTAwMDYowpzClG/DlSXCkik9SsKDXHUwMDFkw5DCr8K3RylcdTAwMTLDgsKnwr9cXHbDsFxcdMKpPF3ChcKXYEBCwqdcdTAwMTnCk8OCwpZVw5bClz1Aw5I5fcKXwrc4aMKPUsOlwpvDucOzXcOxPMK5R1VCwr18w4TCg8Klw7rDnCBxJMO1MEVcXHTDpcKkw5U9QFx1MDAxMnvDq00sXFx0wqVXw5QnJFx1MDAxMHfDgVx1MDAxYcOzajl1w49cdTAwMDHDk8OXw4zDq8KFXHUwMDA0w4XDllx1MDAwN2DDhMKgKWQgw7/CmMKFwoJcdTAwMGbCuVx1MDAxZT1Kw7tcdTAwMWTCn8KUUcKww6FhRsOYw5ZVYkVFw4bDk8K9wolcdTAwMWHCqCXDoC3CicK1dVxcdFx1MDAxNVx1MDAxYsOhXHUwMDA0fcKhSW/DnsKow5DDgcOgNcKZwoY8wrh+QMKCw5hDw75cdTAwMWXDvyPCl1x1MDAxMCXCkcKIw5jDvsKswoHCiVx1MDAxZibCgMO5wpNZXHUwMDFhM8KXXHUwMDA3w6TCglx1MDAwN1x1MDAxYyDDssOFbCPDvnnDscK4R8KhXHUwMDA0w4LDgMOAPX3DlsKpworCmVx1MDAwMsKvwpXDlzfCp1x1MDAxNMO0w5/CuFfCi8ODwptwNTRcdTAwMTA4w7k2XHUwMDFlwofDuj7DoVx1MDAwMilcdTAwMTXCq8ORwpXCh8OFwobCicKwUMO0wqLDuFPCl8KpwqHCncOrUGFcdTAwMWbDpGzCjVFcdTAwMGbDtcORaFx1MDAxM1x1MDAxMsOTXHUwMDE3XHUwMDE3w7PDosOEXHUwMDFkXHUwMDFjXHUwMDEywovCjyXCo0PDl8OYw5txQFx1MDAwNlx1MDAxN8OJRj1Aw7w9fSF1UcKWw6TDhVx1MDAxY1x1MDAxZXtcdTAwMTNZw6nDtlx1MDAwMz1Awo1cdTAwMWLDnVx1MDAwN3/DvcKIw7EowobCgcKaw7Urw5XDpMOlU3QxXFxmSMKGWTJcdTAwMGVzXHUwMDAzYcK/aMKowqnDisKbw73DvMO8wrBcXGbCssOuXFx2ZS7Cn3bDu8OPL0lQb8OpdmJ+XFx0w53CqVxcZkPDh8OAw43DnMO0RMORdcKFVnfCuFx1MDAwNyfCo1x1MDAwZsOPwpXDn8OUw4/Cp8OOwrHCiMO9JUHCoTnCosOkXHUwMDAxw7A3wqVJQsOiwpzDi3FcdTAwMDfDmMO6w5gvwo83woV0wr8nfD19ScOAw55Gw7JcdTAwMDd2X8KXVsK2NcOmw6jDp0t4w6TDl8KNw6tqb8Odw6TCgXlUPMOBcj1Nw7xqwrHCk2fCqcKoI8Opw57DnV5+wrgjJ3LDkcKYXHUwMDA0w7DDpVx1MDAxNsKuw67DgMO2w6NswqU9TcOaSFx1MDAwMVVVXHUwMDE4w7jDg0DDisOhwp7Dvlx1MDAxY8OqNFx1MDAxZMKLw5/Dk8OHLcOkw6DDhylcdTAwMTLDm8KBwrVzwrd4wqfDoMOvKT1Kw48kXTRcdTAwMDTDu8K5XHUwMDE4w4nCv8KfXHUwMDA1w5DCocOwwpPClMO8w5vCuHrChlx1MDAwNMOfYMO9fCc9TcOIw4EsXlx1MDAwNSnDu8OMw5LCk8KRwqbDlEljw6PCtl/Cnlx1MDAxNVp5XHUwMDE2w6RcdTAwMWTCocKNwrHDlsKNwrnDilx1MDAxMsK1esKnXHUwMDFkZ8KUw5PDmMKWw7XDhnVcdTAwMTc3w5NxXFxcIsKbP8K9wpzDtiDCuFxcdFx1MDAwM8ObN1BcdTAwMTklIcKYw5bCssKgwoxpY8KXcsKewpzDtVx1MDAwM8OFXHUwMDFkclTClVx1MDAxOcODYMOHwoDDq1x1MDAxNcO1w7RcdTAwMTTCrcKew63DpMKsw7hWXHUwMDEywoIkw4tTw789QGPDncOMJcOjXHUwMDE1w7zDg1x1MDAxMlx1MDAxNcOGXHUwMDEyS8KdJsOdwoDCsHA9TcOLXHUwMDE0wqXDmVjDpcOjw7fDjsOTw4rCjMKJXHUwMDE4wqvDvlxcXCI3XHUwMDE5XHUwMDExw5LCgVx1MDAwMllnUz19OydcdTAwMTVcdTAwMTh8wqlVw6vDj8KXe8KhLsKlwpFcdTAwMWXDo8OjwqPCgibCnMKkXHUwMDAxw6NcdTAwMTfDtsK0wqhcdTAwMTPCucKwcFx1MDAxNMOSw4HDucKUQVx1MDAxNkjCgVx1MDAwMVx1MDAxYsKScMKaw4HDtMOXLcOBeFU+XHUwMDA2fsKlwopcdTAwMTnCu04pXFxiwpbCmSPDvHlfXHUwMDE1TcKob3Y7QsKEXHUwMDE5w6ROJcOnXHUwMDEwXHUwMDAxw57CusKSw6EkJMOkXHUwMDFlw4bDocKNw6DDjznCoMKUXFx0w4xcXFwidzFpYDfCuFx1MDAwMlx1MDAwM31BwoTCm1xcYsOTKMOQw6vDkcKTXHUwMDFlwq/Dp1x1MDAxM8Kjw4RjY1x1MDAxNcOdwr9cdTAwMWLDnMKnw5fChSw8QMKuw6RfwrFvw6bCgsOEwqPCncKGcsO9w49cdTAwMDPDlcOow4TCny/DpMKkYsKiwrEoXFxcXFx1MDAxNsOCXHUwMDFkXHUwMDEzw4RcdTAwMTV3XHUwMDAzPX3DicO/N8Odw6l4dcKpXFxiXFx0acKRasOZwovDp8OpXHUwMDAzw43CkzXCjWDCsMKYw5N3wrbDssK5OsKMw6PDg2fChcKYw5fClVt1WcONZsK4XHUwMDE5wrjDpcKjW8OZXFx2wrwrw5ltw6BcXHTCl13DrcOpwpw/w6lcdTAwMTBcdTAwMDbDscOJUGbDv1x1MDAxZFxcXCJQw6bClcKQIMOTIHzDonU9SsO3w5TCijnDrW11w6TCjsK9wq3DoMKmw7zDmHknwp/CkMKpwp54w7NcdTAwMGUkXHUwMDFlR1HDuHbDpUFZwoVZw7pZwrdcdTAwMWFowqFWXHUwMDFlwr09QMO1V8OVWcKEwozCglx1MDAwZjfDgDZcdTAwMDLCo8OBwoBIw6HCgcOkXHUwMDE4ccOkwr5cXHbDqG4jwqQ9TcKNwpxcdTAwMTRcdTAwMTnCmcO0Vjc8w7LCpE7DiX/DsEHCtn5cdTAwMDbCriN0wqVBXHUwMDE4fsOewpZcXHTDtFx1MDAwNWJ/w47CimnCicOFXFx0wo7Cm3fCusKdwovDgMO7w5lcdTAwMGXDu8KwPzUxRcKhM8OJw4XCjnjCp8ONKcOoXHUwMDA3XHUwMDAzSsO7wozDhlxcYsO1I3/DpMOrZXHClMOefMO1w78twqkmf8KXQ8KRw5dAwotcdTAwMTbDksKjwp1cXHQ5w5dcdTAwMTLDisO/ZMK5XFxiMcKSwqFWw7osNVx1MDAxOMOUXHUwMDAxw5HCtcOFZsO8UcOAwqMgw4JBwqPDgcO4XHUwMDA1VybChMKkOD9cdTAwMDZbwpBcdTAwMTjCqMKZRT5hwoDCi8KKwqV9wqzChULCp8O+J3Y9SmhBKcKhwr3ChlnDg3I5Mlx1MDAwNynDqsKjw6tcdTAwMDLDnz1AZFxcdMKtwpZEXHUwMDEyKMKAwqR3aVdcdTAwMTHDplx1MDAxNV89fS7ChMODeFx1MDAwNWlcdTAwMDbChj1Awo7Cs8OvYFx1MDAxOcKSwoXDkS/DvVx1MDAxNsOgdsKmXHUwMDE5worCoMO7w78ow6pmOVHCgVx1MDAxZMK4KMOxXHUwMDE4w75cdTAwMWY9fcOAwrBjw4hewp1SNsOEJcOXXHUwMDEywoRcdTAwMWLDlMKswrrChcKoIzlBwrFcdTAwMGXDsMOKwq9jYVgnw4hcXFxcUMOvXlx1MDAxOSHCunnDr8OMw6HCmE9pNz1NdMKdIcO+eMKnXHUwMDFiwpXCuFJTUMOMXFxmXHUwMDA3WMKLwoPDgMO+w7VcdTAwMWNnwplcdTAwMDHCkcOiOVPDg8OuXHUwMDE4e3dcdTAwMWRew6bCusOoXVx1MDAxMMKew5DDrVnCrcOWN3x9UMKFXHUwMDE3XHUwMDA0w4hnwp3CmFx1MDAxY24/w509fcOzX8OhwpjDkcO6w690w5N1wrrChsOMw7BcXGbDsXPDlXw4UULCh8OERsKZw6TDgTNcdTAwMDfClFx1MDAxZcKUwqIpYVx1MDAxZHFeMG7Ct1x1MDAxZcOAwrhHwqTCpsKhXHUwMDFmWsOBXHUwMDEywrlLMcKpODQ9QMOnJ8OxwqnCl8Kzwq/DiSDDhsOLaDV3QSPDtMOOw5g2w4LCqFx1MDAwM8KhMsOJw5s3w4TDpcOSXcKafsOzwqt7wqHCmMKRwrB3WsK/N8OpYVx1MDAxMcO7XHUwMDEyXFx2w4FcdTAwMDXDjVjDkVRxJFd0wrdiw7U9SlvCk3DDoz19aFx1MDAxOcKXwrZ1M2JjKFx1MDAxM0VcdTAwMDdcdTAwMDImXHUwMDA3RD1Nw6hzwolIZVx1MDAxZlx1MDAxMcKwXHUwMDEyXFxiXHUwMDEyw5Nbwr8owrtJXHUwMDBlacO5JWJ5KVx1MDAxZsKRXFxiS1x1MDAxZcKTXHUwMDFmw4HCq1x1MDAxOTfDsMKpwqLDocKSXHUwMDA1wrZhwoRcXFxcPU1cXHRIw5vCgyY2w7dIICZ6wq8jw70rYcOkZWBXJ1x1MDAxY8O8w6zDvVx1MDAxOMOvIFVow5lGPU3CgcOmXHUwMDE4w4YnXHUwMDFhdcK7wrd2XHUwMDExXFx0RcKDwol1VDjCqCU9SsOzKMO2woLDhFx1MDAxY1x1MDAxNcKDw6bDtMK5wrPCgVx1MDAxOMKmw6lcdTAwMWHCg8OZwpnDjsKpw7VcXHTCncKxw6BcdTAwMWZcXFwiXHUwMDE0XHUwMDExXHUwMDFlXFxiRMKJJGUmw7XDsMOYJVxcXFzDgSjCtlxcdMOQXFxiR8Kpw70pw7jClXvCp8KlIMOWw5nDoVxcYsKEXHUwMDA1XFx0WHVawpUlwp3Dn1x1MDAxNSQ+wrkvYcKpVjPDqFsgwprDt8OnUTA9fVx1MDAxOHDCqMKcw6nCqVx1MDAwN1x1MDAxOVx1MDAxZMKtKlx1MDAwM0HCuXlhwqRpQ0RlXHUwMDEww7vDv8O4w6M5fzdYwojChMKowoJcdTAwMTfDnMObwolcdTAwMWLDr8K/w4k9QMKHesKWXHUwMDA2wpvCn8OgwpZcXGI/w5N4J8KVXcKMecOfXHUwMDA0wrQ+w7lcdTAwMTbDqMKjXHUwMDE1w5bDn8KfXHUwMDFkI1x1MDAxZsOdUMOIRcKiXyVcdTAwMWUowq5tw5HDpsOAZmNcdTAwMDNcdTAwMTZLXFx0XFxmwr3CgsOoXHUwMDE0JsOfw7dcdTAwMWZNMMKJwoPCo8Kbw6NcdTAwMTDCtFx1MDAwMmDCvV85w7TDuMOZSMKHw6HDlVxcdsOgf1xcdlx1MDAwNMKMw6NNdSTDoMOxWVfCtj1NVylcdTAwMWNcdTAwMTckw5xcdTAwMGUtIUFpXHUwMDAxwr/ChF5cdTAwMTPCjcOwwqzCucOoJUFkwpkpf8KlwoLDuMOTwrAjQMKCwqdew5jCi3BpXHUwMDA3w4/Cv2U4wq7CgMODJcKEeFxcdCbDm8KRw4TDrF/DgcOkI8KzXHUwMDE5wpDDtFfDiWjDlcKUwprDtsKWw7fDnHtcdTAwMWRAw6HDt8OGw5nCmVx1MDAxZsKeXHUwMDE4w4Rkw7ljXHUwMDE1w6jDkMOXw6HDg8OawpFcdTAwMDfDmEchYFx1MDAwMsOzw71FeVxcXCJcdTAwMWHDoTYowprCjVx1MDAxNWjDpz1Nw4UxR3ZcdTAwMDTDnsKMwoPDvcKYPX3DmcKswofDtcKEN8Khw5RPw4fCk8OUw6DCllx1MDAwN1BnfcORwpvCgMKjw684w49cdTAwMTXChcOgw6HCo2dlO8Ofw7bDlSPCm3xiSFx1MDAwMWTDhcOnXFxcXMOdXHUwMDFjXFxcIlrDtcObw7F4wodJwprCjnIjXHUwMDA1w43CmVBcdTAwMDJcdTAwMTbDhSbDn8KZKVUjwo/CpT19wqDCtlx1MDAwMlx1MDAxZCfDrcK6wq3Co2jClTjCnkkmwqjDksKGw5lJwoPDrMK+ZMOmVFx1MDAxNVxcdmfChSc9fVx1MDAwMyXCtFxcZsKPwrEpUlx1MDAwNVx1MDAwMcOowoxcdTAwMDfDrVx1MDAwZcO5UV0oeF1cdTAwMGXDmcKiXHUwMDAxw79Wf8KVwp/CnXlcdTAwMTHCusKOJV9Vf8KYw4PDtmJcXFxcwozDtMOiIEjCg8O5wq7CvsOew4FFR1/CqcKTSFjCm8OCVMOVZlx1MDAxNlx1MDAxNFx1MDAwNMOOXHUwMDBmwoU8w4jDuMKAJV1RdD5cdTAwMWPDsSfDrMO3wo9cdTAwMTlFOSh/YMKgwoTCpk3CkcO3wrXCp1x1MDAxMVx1MDAwZlx1MDAxNcOcwqHCoDPDkEJOw49cdTAwMTZUw6LDmMKgXHUwMDE3w77DmlxcXFxcdTAwMWZZwqvCmVxcdC9ow5bCoMOdw7coQMOjIMKlw63Dllx1MDAxOcKmw63Cjyg1wpzCsWTDhMO1XHUwMDAzw5lkwrxcdTAwMWJcdTAwMWTDucKNwpPCt1xcditcdTAwMDPDl1x1MDAxMGlcdTAwMWbCoFnDt8O2w7klw6VcdTAwMTJcdTAwMTFcdTAwMGU6wq8kJ2DDsWhcdTAwMDbChsKKwoTDj1xcXFxkw41cdTAwMDFcdTAwMTJcdTAwMGbDgS9Xw50nwonDmSHDqGHDlWbDtHBLw4vDjcKjwoxcdTAwMWRmP1x1MDAxZnHDiHVvXHUwMDFlXHUwMDAywplkWWjDkXlcdTAwMWbDksKkw4pePUDDt2HDqMKkZsKow6BcXGbDh8O/JsKqXHUwMDE0XHUwMDBmw6lXwofCv8OAKEjDnWo9TSRdwqjCr8O8w4ZNw6bDlsOrXHUwMDEww7PCpXFnwqbDv1x1MDAxZWTCmsKgwphcdTAwMDchSF9QwqVcXHbDv2LCr1hcdTAwMDVhwrXDgMKmw5lbwqfDqMKOw6rDm8Kjw6vDuyvCtDtJSVHDtsOGw4jDkyfCkD1Kw7nDvMKracOFXHUwMDBmw5fCp8KXUMKfZVdfwoTDn2xPUVx1MDAxYVx1MDAwNcOBw5nDuytDwpXClVx1MDAxNlx1MDAxOcOnwqPDn8OwwqnCsMKBwrnDv8OxUcOtwprDj8Oewr/DvMOZw45vw7XCgVxcdsOYwp5cdTAwMDfCt03DqD/CsnbCp8OPdsOAacOCwqbCpH3CpSHCisK3XFx2w7XCicOBKVx1MDAxN8OSw6fCvmZhwpAnVMK/SsKXVMObw6jCosOJPUDDicKAXHUwMDA1wozDhcKHTX55XHUwMDEzXHUwMDA3VGFYdFxcdsKBw4ZcdTAwMTZzXHUwMDA3w5ptXHUwMDE0T8KVw6LCjMKQXFxmPiVow5PDncKlQGfDgClcdTAwMWRcdTAwMTPDtMOIwq5cdTAwMTPDlMK5wpnCqMO5cznCg8OjfVx1MDAxNMOaw6vDiMKtwrjCr8ODOT1Aw7zCtMODw5zDg8KXdHNcXFxcwq3CuMKfw4/DqcOnX8O2w6JYXHUwMDEzwqRcXGJCL8ORWUtcXFwiPUpcdTAwMTTDj1x1MDAwMVx1MDAwZlxcdClywoN9wo3CkU7CpsOfwo8lPUBcdTAwMDN9w7nCklx1MDAxZlx1MDAxMlx1MDAxMcO3wonConhhwoE9TShcdTAwMTghP8KcVz1NwqJTwq/DkcK9wrlcdTAwMTPClsKAwrbChcKxPMOQwonDhcOVJ8OmbsORPsOTw6lcdTAwMTfDnFx1MDAwMsOGw6HDjlx1MDAxOcKcw7VcdTAwMWTDn8KPW1x1MDAxZCbCg8O/w5nCi8OmwoPClVx1MDAxMcOQwqTDpiNcdTAwMDLDoMKLw7DCqj1Nw5tcdTAwMWPCuMK0XHUwMDExUMKnc8O2YcKEwqIlfXhcdTAwMTLCq8ODw6RcdTAwMDXDjsO/NVx1MDAxY8OdPUBzwpNcXGIhw4TCpsKLXHUwMDE5w4PCucOhXHUwMDBlUH5Uw47Cp1xcXCLCvyDDjsKaw7/CqznDj1TDrcKNw4hQWEI+w5jDv2NcdTAwMTfCjMKbw6nDoVx1MDAxOFx1MDAwN8O4PX3DhMOAwqnCmmBcdTAwMTPDgn1lwo1cdTAwMTjDksKBw7nCiUg2VcODw4PCuFghXHUwMDFiwpDCsFfDpCfCpsOhXHUwMDE0w6/CsmtcdTAwMGbChMKIw58mwqzDo3DDk8K3TU03wrgpw6h8w4LDpMOWwqzDgGHCpcK7I8KKw5Iow5FcdTAwMWTDp8K/w703QMOlwqZZw59cdTAwMDbDoMKcXHUwMDE1wrrClcKJJsOocMOWwpjCgidcdTAwMTQnwonCscOcRMKdw4nCk1xcXFzDtllcdTAwMDdcdTAwMWXCkVXDoUV5XHUwMDE1XHUwMDE5w4ZhS8OiXHUwMDEzcXvDiSXCtEc1KcKJwofDh8KPdsKGwovDjcKuwrXDpW3DoXpcdTAwMDZcdTAwMDfCh0BAVVx1MDAxOMOPelx1MDAwNsKHwrXDpVx1MDAwNVxcZsOvw4vDosOlw57CgsKbwpHDu0DCsUzCtWU+w5FcdTAwMDIvwphcdTAwMTjDgcOFXHUwMDE5TnlcXFxcwpHDuFx1MDAwZSbCpsKpw6fDgzNnQ8OLTzUsUmxcXHTDiidcdTAwMWTDoMOFdURQwpTDjHzCocOhO1x1MDAxMUvCtcOnw5bCm8KAw7VOaz1Kwo44w6FmKD1Kw6PCqcKgw6Q7w7jDhMOXwqTDlMOuWlx1MDAxY1dcdTAwMWJKKkTDinU+w5fDtcKDwqRRRsO0w4PDnMKgZsK0wqnDmcOXXHUwMDEzc8O4w6HCs1NAPUrCkcK8L8KnwrFcdTAwMTDDk0PCjsKIw67DucK4w71JwoFcdTAwMThtw6LDk1x1MDAxYsKyw4poKMKfa8OuwpHDnU/ClGXDvMOWXHUwMDBmwqpcXFwiRcOQwr09fcOyw5pBwrvCjHhcdTAwMDVcdTAwMTDDi8OXwo45wrRQPEzCjEDCocOYIcOFSmXDmlxcdsO1wr9TJsKIwpDDncOfw7hcXHYmXHUwMDFjwp0rwpHDjVJcdTAwMDZlw4JMJWgxKsKLXFx2wqbCtsK1McO7KsOcwp/Cv8OYwoPCjVx1MDAxOVtcdTAwMTjDlsK1wrVpVMKDw77DrVx1MDAwNXxcdTAwMTbCosOyaih4w6M9fcKpwr5Fw6AoJFx1MDAwMcK8w6hiXHUwMDBmwovDoUVgw6nDrVx1MDAwZcKdLMKGw6pzwqjCrkFcdTAwMDHDkkrCsMOkwqHDmFxcdnVPXHUwMDFjw4VCNTbCg8OMM8OMw67DvnzDqnzCmlx1MDAxYS9jXHUwMDEwXHUwMDEww5d/w6TDrMKbZ2jDvcOwR0zDvEgywpbDosKzdmbCnmjCv3pcdTAwMWTDgjtEbMKMwq7DpsKrd8OJTcK5wp7CuMO1wrZcdTAwMDTCtMK4I2Viw7rClD9cdTAwMWPDoMKlMlHDncOiwolVWMKww6AqwqDDicKTacKDwobDgj1NRzfCsTFUwrR6ecOiZ1lCwqXCqmxcdTAwMGbChUhdwovCjsO+w65kJnt5w6/CgcOTQ3F8w7TCo8KrREJdYnTCnXXDo0k9TSgzJsKPw7hcdTAwMWTDtmszfsKjwoXCgz1Aw6bCtD1Kw6TDicK2wothwo/CssO7XFxmw75wwqvCkjfDrVPCvcOqXHUwMDE0w7bCnsOwejk9TcK8wp/CgVDCoGM9TcO9wqBAwrHDgCzDlsOQKsKAw7U9QFxcdsOAw5hUwoZcdTAwMTjCvMKGR1x1MDAxY8KSwrNcdTAwMDbDlC3Dj2drM8KXw7hQwpQ3XHUwMDE5TMKOJ8KYwqQxXHUwMDFmwrLDuGtzwp/DuMKGwoNMwoTCmmPDnlxcZsOaw45+woLDnCB1R3/DpcOKaEYuwpvDtMKeesKDwpzCnlxcXFzCk8OiwozCo8KjYypyw5XDnMOtXHUwMDBmWsOSdifCh8K4w4hcXHZrNcOIXHUwMDE0w63CtjNVw5BcXFwiwrLDqsO2bk/CoT1AfFxcXCLDhsKvXHUwMDEwXHUwMDA0TMKVw6HDtlx1MDAwMsOPLMKFwoHDhUTDsMOlw7p/wpXCrHvDg0jCgmrCqTvDgCjDmVx1MDAwMsOtTFx1MDAwN2dcdTAwMTJcXHYyXHUwMDEywrR5w4Qgw7h5LVx1MDAxZsKZXFx0wqxcdTAwMDfCp8K2fCnCq8KQwpkoYFx1MDAwM8KGTsOsXHUwMDEwXHUwMDExwo1cdTAwMGXDlFvCk1xcXFxhWzTChsO7w6nDml8yaMKQIzQxwo1pfMO3w7XDhcKBw4Ytwp/CksOIw6BfwpdXwr9qd8KFNjTCuVx1MDAwMTLDvMK8wojDsFx1MDAxY0JxOlx1MDAwN8KDw61Uw79Gw4HDmsKkw73ChcKSUcK1w6fCllx1MDAxM8O/MMKVe1x1MDAxMS3DpMKZw4LDjcK3PU3DrnjDmS/DqMKfw4vDn8OIwonChsKOXHUwMDFiI8KYw7LCs8OTXHUwMDAywoFcdTAwMThnw6TCllxcdGXDnsOOa2FcdTAwMDVcdTAwMWXCgsKSwolcdTAwMTZxXHUwMDA1wqzCisKMwrkyw63Dh8O1PX3DpcKUPU05wojDmFFcdTAwMGVcdTAwMTjDrMKXwrJzQkZwXHUwMDEzwrzDr8Otw5tjdsO/w6vDncOMw4vCsFZcdTAwMWZcdTAwMTXCoMOQXsKcwojDh8OPVlx1MDAxOMKBw5daw6g0wqZcdTAwMTDCuDLDoz1NQFVWwo89QMOTLGvCu8OgXFx0w6FswpLDkj7DqWjCgF3CkGHDv0x1w7HCtGLDsjnDgDlcdTAwMTQ8w71cdTAwMGbDlMKoXHUwMDBlLFx1MDAwMcKBwqFGwqBcdTAwMThacsOANEF8P8OjYMKMw792MsKDXHUwMDEwwrF/wqAnw7rDjVLCk8OwXHUwMDExwrM9QGPCk2jDulbCkMK9KiNcdTAwMTB9VcKaPU1LJ8Ovw7Zgw6YpwqpcXFxcwp7Cuj98w51nPX1JwqzDqnTDnMKrwpY7T3k9QMKww67CtsKlI8KGwovDkMOGwpBrwqrCsl8rw6VGfsK0wr/CvjzCplx1MDAxMlx1MDAxYcKoPX10RcOXwppcdTAwMWYqw63CniHDhzbCr1RQw7vDiMOfOcKLasKqVkzCucKFXVXClMOYNFx1MDAxMcKSwptddsKUdj7Ct8Ocw7XCtzo9fVxcXFzDhMKOX0I0XHUwMDAxZ8OTScKFw6Y2w7LCsitILCDDo8K0LMOuw5MnWsKSQlxcXCI9QDtcdTAwMWXDu0bCtsO/w6/CmUrCvFx1MDAxM8OYf8Ocwr1wwotcdTAwMGZ2wrHDujzCjcKZXHUwMDAzXHUwMDA0w4BVPUAgw713XHUwMDAyUGNVw53CgMOiw7HDm8OUI1lcdTAwMGbDozNAwqs8PUAlXHUwMDA1dH7DqHRcdTAwMDRhw5E2RMKfw7HCksO7O1DDoMKrXHUwMDA3QcKnU27DiC/Dg1x1MDAxNMKgO0jDj8KVUcOYeiE5w7DCrCnDskfDqFx1MDAxNsOMw4U3w4VcdTAwMDPCgjDDhlx1MDAxZiRcdTAwMTVcXFwiQWQ9TVx1MDAwNMOuT1x1MDAxNsKXXHUwMDE5wpBcdTAwMGZkwrPCq8OnXHUwMDE5XHUwMDEzw6xiP1xcdsKvwrrDpXbComvDiXBSXFxcXEBVw4PDkcOww61RXHUwMDEyTz1AwqTCtsOQwo/CkMKEw59cdTAwMDNcdTAwMTDDuVx1MDAwZlxcdsKow7U4w4LDmMOoe0dHwoQkfcO7w4liPmrClU/Dn8OtbijChcKDXFxcIsO4wqrDiMONSMKuw6QxSMOfXHUwMDA1XHUwMDE2w7tcdTAwMTNpUcOGw7fCqX5cdTAwMTPCs07Dk3pow7DCiMOJw4FwPFxcXCJywqtcdTAwMTRcXFwiw6ZdOMKrwoLCjS5cdTAwMTVcdTAwMWY6wpN3QCvCmiTCjFkgwo8hwpg1woBqw7FIXHUwMDE0w55Fw5nDvTFIQlx1MDAxZVx1MDAxOXnCs37Cok0qSFbClWbDo8OgwpMmO1x1MDAxOFx1MDAwMsKWw5HDiVdTXHUwMDExa8KHYMKMNcO3XHUwMDEww4BnXHUwMDE2eFx1MDAwMlFcXFxcaCZBXHUwMDBlJMKVacOew77CscOUUU/ClcKtdcKPw73DvFxcXCJKw4pwXHUwMDBma8OVw5TDq3PDhsKqw7jCj8Krw7bDo1FcdTAwMTLCjMO3XHUwMDAzwpphXHUwMDA3woBcdTAwMDfDi8OrwpgkXHUwMDFmwp9IwrZtwoZPwq01w7x5f8KXKXB5wptqfEjDhm3CpFx1MDAwZcOlw4dcdTAwMDLDqWZjw6s1w5Y1wrtcXGbDgMKjSz1AwolCw6hcXGZcdTAwMTTDlcKQNXQzw57Dl8Otwq1cdTAwMTRKwo7DrcOvXHUwMDFmw4bCnz9DNsKuXHUwMDE1w5rCn3BRwrZcdTAwMGbCpWHClFxcdjPDgcKIwoPDocKdI8O1wqvCtXstUsKNwpExeMKHwrXDkcOxPMKaVVN0difDjlx1MDAwNFx1MDAxNMOlXHUwMDEwRFxcYlx1MDAxMcOCwpgvXHUwMDFmwphcXGI9SsOccVx1MDAwNVx1MDAxZMK6WsONw49GwoDCpDNOd0RFXFxmP3hmwrjCjHtLw7DCm8K8N8OFcFx1MDAxNjtxSnzCrcOIXsKUw5DCnmfCiFx1MDAxMk7CrsOewpRuRsKPwpDChTooXFx2a8K3w4DDkMK3wrszw41OwolcdTAwMDJfwpTCu21Zw6tcdTAwMDPDjUkvw79cdTAwMWYyYcOyYsKDXHUwMDFlw4ltZcKfw4zDjMODXHUwMDAzw6jDgsOMw4lcdTAwMWJRSMKfw4zDuU5cXFxcw4s1wqdcdTAwMTA5w73CscOow5jDp3NUQj1NwpdcdTAwMWPCkMKxw5DDkk56L8OGXHUwMDBlVcKYXFx2w41lwoxkw5Mkwrp4wrvDuMO0w6xJw4/DvcK7wo1vIcKzb1xcdsO+fcO1e1x1MDAxMm1Jw6nDo8KWw5vDrlx1MDAxNWhcdTAwMDTCjjZgPU3Dj8OIPsKOMMOOw7DCmMOuwp5Qwq3ClVbDkMO5XHUwMDFkwr9Rw6bCqVx1MDAxYcOXw61fwr1cdTAwMDfCgCY3YcOEw6TDmVx1MDAxYsO8Y8OCJW7DnyfDjkpcXHRxwrHDq1/Ctlx1MDAxZiBcdTAwMTHCtMOlelx1MDAxOcK+K8Ojw5h0QlDDn8KIX2vDj1x1MDAwNlYpXHUwMDFlwrFxw5RgXcKEPU1odXZ5L8KpYTfCmMKRwqdcdTAwMGZWw4vCq8Ojd1xcYj1Ne8KFwrQ+UmjCncOxaUl2XHUwMDFkw4lcdTAwMWHCmnTDo8O7XFxcIsOmW0HCrsOOU33CrE1vP8KmRUd+XHUwMDBlw4PCicKfwoJETMOiw5rClsKwXHUwMDBmwotPwqghPDJnJ8KmwrHDocKzw5E0IMObw7tXw5pcdTAwMDLCusKJwrzDtcK+aMKBZ2HCj8OsMMKFw6vDi8OrI8Kjw73CpMKpe0FcdTAwMDNmwrfDrMO1wqTDsnHDsFxcdMKJw47Dm1x1MDAwN2Mtw6whXSQlNsOrw4TCiMOWwqTDs3ApwoB9w43DuMKuasKefT1Awql3McKQXHUwMDA2woFwXHUwMDAxXHUwMDE5XHUwMDFlf8KFQcOhP8Kyw6HCncKpQcK2woHCksOrL8ONYG7CuGPCoVx1MDAwZcO3KFXChcOiNVQmw6XDoEnDsMK6w4EywrDCk0/DtFx1MDAxY3ZfeHrCt8Kww7Y5PU1cdTAwMDHDuWrDmy7CpcO8U8OvUVx1MDAxNC5CwrnDlmbDvj1AalDCtVx1MDAwMSx0IynCmmjCtMKiOMKjdcOjw5ZDwrjDg8OOUyjDmsOZw7/ChsKAw5ouPsKrw67DusKDXiNTaFx1MDAxNMKKNWg9SnBcdTAwMGXCscK8XHUwMDBmw6DCikrDuVHDo0zDhsOwwrvDusO7wrnDhVvDqMODYzxcdTAwMWLDonPCkMKBXHUwMDAzWsKMesKcT8OOYMOheT1KTMK/XHUwMDAyLVx1MDAxY8KULzxJPX1cXGJcXGY2w6pkS8Kgw5rDi8OKw4/Cmlx1MDAxMcKzwo3CgFhSw71gw5PClFx1MDAxM8KRWsKmwp41LsOjwoHCoTPCosKvV8O/XHUwMDAzZ8KIN0XDuEjCk8KYwopcdTAwMWbDnEjDvcO3QVxcdETChsOYwobDoklhw7g9QMO+wrZZwq/CqcOBSMKndDHCoMO5L8OPblI9fUfCscKEw6rDglHCvFvCvVx1MDAxMFx1MDAxYVx1MDAxYsOjw5/DicOiwos9QDhcdTAwMDTCr8K/wp7CtGfDgMORXHUwMDE0Xlx1MDAxMcOMwr3Cnn97TcO0w55cdTAwMTRcXFxcw5thw6PDmsKVT8KBZMK7w5HCr8KCw4HDsFx1MDAwN8Kpw4I2w4Q9QFx1MDAxZkJ7XHUwMDEywqVcdTAwMWTCpipuJkxoZSfDrcOnw4EgwqLCgsOkwqBcXGJcdTAwMDHCisOjXHUwMDAzw4DCt8Onw4E+RMKRw5fCgsKbwpfCi8KAXHUwMDE1XHUwMDE5clx1MDAxYzfDs8OBUcO2w6s9SsKSOsOKPUApUXHDlCdcdTAwMTnCuHZcdTAwMWPDqFxcXFw2wrBdSWTCt39cdTAwMTHCpWfDs8Orw6HDmDBfXHUwMDA2f8OOwp0sw4syMMOWOVx1MDAxZcKefl1ZfTjCmcKaVmlTfXjCgMKRwp1fXFx0KGTCmcO5PMKCw4lDwpslwo/DscKDw7zCr8KKw6DDpVx1MDAxN1dcdTAwMWFcdTAwMGZEw7nCiMOiw5lMXHUwMDFmwpLDkMOhVcOJworDinI4w6gkNsKrXHUwMDE5V1x1MDAwNF7Dl8OJwphcdTAwMTBcdTAwMTLDn1x1MDAxZCDCnDh3XHUwMDAzW1x1MDAwN0nCuVHCj1rDicOSXHUwMDA2XHUwMDFiVFXCj3Vmc8KwQjInNsKqw7NCV8OJVsOec8OmwrLDlsOlwq9ww7LCh1nDo8OqW8KBY8OOR8OawpsxXHUwMDFmXHUwMDBlXHUwMDA2wrnCjlx1MDAxZsKPZcONSCzCkMKmM8Oxw4rCtsO8TsOAwoVQJsONXHUwMDA2JsKhwrZcdTAwMTjDjj1NW1x1MDAxMcOXw63Ds1/CssKmYsK8XHUwMDBlXHUwMDExZn5cdTAwMThcXGZqw6XCq1x1MDAxMEnDscOQw59KwqHCijrCvVx1MDAxOFx1MDAxNlx1MDAwMsOld2DCjMK+wpI5XHUwMDFmNy53PUBdZULDjVx1MDAxOMODw4VcdTAwMDTDsyDDhFFcdTAwMTbCkDIqwpBcdTAwMWPDhUDDkcOPwpNOw79Fw5grLmkxZybDoSbDosKew79cdTAwMDfDp8OmLVPDu8KBw6dcdTAwMTHDkGU/wq92w73CosKkKSTDp3vCqVx1MDAxNlx1MDAwN3BOXHUwMDA3TsOWWMK3WsO6w4xYwqzDhsOOwrJOXHUwMDFiw5XDusOCTz1AI8K9woTDo0JcdTAwMTjCucKmw5rCrFx1MDAxNMKgciHDoXXCg8O+w7Jmwq8vwo/Colx1MDAxOW/Cg8KAwrhowqNPw5bDhi7CtXfCrnnCjcO7wooowp1cdTAwMTBgw5k8a8KEw7tiwqZcdTAwMDUywoFaXHUwMDA1wopYacOiw64rwqnCi1xcXFxew53Cr8OAwr3Du1x1MDAxNVx1MDAwNDVcdTAwMWTDhU5zM8KEwo7DgcKdZFBiw7Nowo7DqnnCu8K1XHUwMDE2wrglXHUwMDE4wplbw4bCjVx1MDAxYlxcYirChMOPXHUwMDE4w4bDs0dcXGJcdTAwMTA8wpbDucKPw63DsULDiHDCoF1cdTAwMTQ/NXDCqsKjIEdMXHUwMDEwXHUwMDFhwqHCnMOxwo5gwrjCoWfCsMOaw6Nswp/Com3DoMK5fcKNUsKZwqXCtFx1MDAxZcOfKcK8wr5uw5bDo8OIOMOMXFxiw5nDnsOoecK0w6bDjsKRwqDDjkDCusOOw53Doy/CszFcdTAwMTlcXFxcOsK2WE9GwrxqwpjCqcOUR8KwXHUwMDE5NmnDhsO+wrDCt8Kpwrwnw55UdCTCuHbDuiU+fcK3I8OjQMKNw7DDiGNSwrLDrFx1MDAxNsKiwrzDr09WXHUwMDA2XFxcIi3DusOZa33CvVxcdmhvwocracKGXHUwMDEyw6fDuCE9Slx1MDAxZsOSw4zCrUknw6vDs8KlJMKzOUdiwqN8ScOkwpTCg8OaPU1GXHUwMDEzwodXwrbDrlJcdTAwMTPDv8KYw4DCmE9cXGbDjUXDtTJcdTAwMWRxw4TDh1htw6rDrVx1MDAxMkldXHUwMDFjwp7CsmhBLMO5XHUwMDBlccOXXHUwMDA0Z8KGXFxmwpfDl8KyMcOTwr7Ct13DhVx1MDAxZntxw5lcdTAwMTdcdTAwMTTCo8KSwqdAwrfDl1x1MDAwNMKAwrssw5XDhH7DsMOdw5vDtMOyXFxmVkh/XHUwMDBlwrJZw6DCnsKGNMO0V3FpwqXCpUDCjMKaw6FcdTAwMGXCgyhTR0Anw4RcdTAwMTNeSkhvw4LCqnvCk1vDgMO8wrjCv8ObOlx1MDAwNcKOwqzDhsOdw7Qnw6vCinvDn3DDk0jCm8O3QVx1MDAxZsKzw609QMOiw75ZXHUwMDE2SjZYX1xcXCLDgWzDizonw6FJXHUwMDE0KMOpwodfwrMud8KrwrTDmMOJw6zDqEF0ScKZRkLDsMKhZGRcdTAwMDdcdTAwMTbCtMK0wrVcXHZGw5XDvXVcdTAwMTHCp8KPw4vCvDfCvMKca8OWwqXCssODw7V3woh2wrUwwpLDn8KmXHUwMDFkw7HDpMOUSMOmw4xcdTAwMTXDlsOzw51cdTAwMWVZXHUwMDE5NcOaXHUwMDE5I2TDi1x1MDAxMcKPd8OUwqpVw4zClMKXwpUuXHUwMDFiwrBcdTAwMTE3wr/Ck8OFw7rDusOIeMKlw4koXHUwMDE1XFx2ZsOMw4/Dplx1MDAxN1HCtsOkwofDoz9mw49cdTAwMDJEw43Cq8KUwq5Zw6BbwqVyIUHDl8OTXHUwMDAyMMOncFx1MDAxZMKmSFJtbMO2w6XDhcKqV1x1MDAwZsOQXFxmdmZcdTAwMTDDkMKdc8K9OiMgJMKOw5QnwrHCucOewpsuwrx0XHUwMDFkw4lcdTAwMDfDmVLDqlx1MDAxMFx1MDAwM8KYwqcvwoVoeFx1MDAxZlt2w6pqw4hcXHRRXHUwMDFiwqTDi8OjVMKEwpVcXFxcSiBQTlx1MDAxMTLDj8KDwr1fw6zCnsOTwpZTwoLCt1XChm81w4/CrVZhXHUwMDA0w6DDk3DDlC/DizwjwoLDgcOOwp0hw4zDunZcdTAwMWPCpzHChsO2fmlZXHUwMDE3wqPDr8OIwoY+XHUwMDA3XHUwMDFjwpVcdTAwMTPDlsOEw65cdTAwMTTDgsOrwqjCksKxw6lawqU3w6rDsGnDvMK0wpldN8Oww5rDjMOMT1x1MDAwN8OVXHUwMDFmXHUwMDAxYsK5XHUwMDAxwp7Dr8Ocd1x1MDAwNcKnw4xAZsKswq7DlsOXXHUwMDA0wpXDu1dcdTAwMGV5w4h4fMK1bsK9w6hcdTAwMDMkwovCuMOnw55cdTAwMWbDsSRHOMOeY8KuXHUwMDBmwpjDnsOsWj1KwpxcdTAwMWVcdTAwMWUvNnXChsOjXHUwMDEzwq7Cs8KLw51nwqnCiC3DjsOtw7DDq8KQwrUxXzxcdTAwMGbCk8OAwojCl8OOwo7DqDTDsFx1MDAwNVx1MDAxZMO0wqpewr1Sw6NxOsOOW8OGZ8OCd0rDhMO/XHUwMDBmw6JcdTAwMTbCssKEXHUwMDEzw63Cnlx1MDAxM8OPXFx2U8KEwqZzwpPDvjVCw5lKwpV2w6DDsMOxw6/DtUfClMK6wqPDlnxXXHUwMDBlwqBkwqfDjHrCnV5iwrInLyk9TcKqwpVcdTAwMDHDiVnDm8OLbcOCw4HDscKPV8O/w4hbw75fwpJ3wqXCpMKrVlx1MDAxOEhmw43DmGEzXHUwMDEwXHUwMDE3PjBcdTAwMTfCvcKELmrChcOLwpxMXHUwMDE5woVcdTAwMWLDn8KYX8KBbMOeWiBZdcO5w7JDesO0Jj44w47DqMOxw7XCu8OkwpBIw5HCn8Koelx1MDAxOMKvfMKAw5tbZ8OMw6V2w719w73CvMKIwq4kwrRPwoJOblM4alx1MDAwZcOPwrc/LF3CpCvDlXk+wqEufivDo1xcZsKvwpVHO0jDisOXwoPCvCw+XFxmwpjCgsOfwo9yXHUwMDFiXj1KV3zDhlx1MDAxNsOBV8K9PUpEc8KoSXnChVx1MDAxNcOww4xbwrhcdTAwMDdYw6DCj3RcXGZcdTAwMDLDmjcqPU1FwrA7w5rCuMKlw59/fcOlXHUwMDFkw7rCi05GacOIw67ClMOkNnPDlcKhXFx2w4YjXFxmw73ChWVpw7lpwp/DlcK+a8O9TD1NXFxcXMOywoPDs3dVXFx0McKnwoszw5zDklbDmEchwqjClFxcXFzDu1x1MDAwMcOIf8OXXHUwMDA1w5TCicOfw4vDvjvDo8O3worCrXbDmFxcZsOLwo/CtkbDl1x1MDAwMcO0fcOETMKJw4dbXHUwMDE4w73CkMOrw6bCvFx1MDAxOMK9w4A+w7PDrCM5XHUwMDA2QMKkdsOuZsOTXHUwMDAxXHUwMDE3IMOtwrMwa8KadMK5NWd8w4k3wrrDvVx1MDAxOT1KX1x1MDAxOTPCocOdw7LDhUV0f8KPPsK2wo0gKsOsw6XCksKhwoFcdTAwMDZcdTAwMGbDo8Kmw4zDuS0pRV/DqC/Ci8K0M8KAw4k5S1PDu8KnwpPDpFTCkMOnw5pmXFx2wpZtwqXDnsO5w5U9SmvCkcOnasOUw5zCmWRcdTAwMDd8w4nDrDdzw6Now6hcdTAwMWLDpsK3w7bDjVZjwr5Cw6HCjcKJecOYPsK8w7BdXFx0XHUwMDAzwrtcXHY5bFJmw71ZwqbDrMKywrLDmETDvsKKw6N0XHUwMDExw4JKfGnDnDFPwphtMMOfLsKXw5w6N0xHccKtXHUwMDEzw4PCmMO4XHUwMDEww5FjwoNnPU3Cllx1MDAwZl13wrR9LyNXw5zDnGXDlMOIwoVYw7nCk8OAey7CmMKnw74wXHUwMDAyXlxcYsOKw4nCiVx1MDAxNMOSw48qw4TDvFx1MDAwZUQ5w59rw6I9QMKJw6lfwprCtlx1MDAwN8OSWE17w4nCsFxcdkxjw7zDuFknXHUwMDFjN1x1MDAxNT1KdHpaeMKuw67Cglx1MDAxYlTCplxcXCLCuzRKw4bCnsOnw4Vsw4nDuMKPwojDpmlcdTAwMDVww75VwpVgwqPCmD1AXHUwMDE0Tk/Cl1xcXCJcXGLDhFx1MDAxMMKTI8Oow4E4PU3DgFx1MDAxN1x1MDAxMsOBw4DDtWzCmFNCw7kxwo98wrtcdTAwMWFqYsOmwonDuGzCpCZCRMK3w5VcdTAwMDYkXHUwMDA1J8KjwqfDmCxHwo3DscOBXHUwMDA0wqpPWT4odcOJw6/CmMO1w6XCqzA5ZsKNw4gkwrPCiCXDrcKcwrRKwoTDocKqL8ORw6nClcKtacKDasKDwoVcXFxcL8K4wpZzw5p2w7Fjw69/w748csKBwojDnsKFbsOfKU5rw7TDtsOgwqLDi8ORwo1cXFxcdcOzwpbCr2LDnMObecK9XFxmwrbDiG5cdTAwMDPCinTDs2XDlVx1MDAxYsKCw6TDi1x1MDAwZcKAd8KowpXDscOSwp44PUA9fVx1MDAxOVx1MDAwZnfDmMOvWkTCqMOpYVHDhcOVZMKfwqtMd1xcYsKkwoPCsUs9Slx1MDAxOUd0w4kyw6DDmmPDmXtAwrlfw79cXGLCmcOHdyk8esK5wrXDvcOXXcK7NMOqXHUwMDEwwoFTwrJ5w7VcdTAwMWFcdTAwMTFcdTAwMTJcdTAwMTdNw4TCjMOtRsKawqDDg0LDhWdtw6rCm1nDvcKbc8OAdFJcdTAwMGZQw58hTcKAUsO2wpkxJkVew6LCjcKpKcOCJUElXcOXw7pcdTAwMTLDh8OZwoNDwotswrfClV1OPX3CiMKwccKfwqjDuUjDlUdXw5JcXHTDksKmK1xcYkTDvcKKw6bDmzBowqh0wpshXT1Awottw7tsScO+K8Orw5bCv8OtWsKGXHUwMDFkw5jCt0Btw5pTMsKmwpRtX8KDwrdcdTAwMDNXwpYkXHUwMDA1w7pcXGZcXHbCtD1Kw5/DiUU7wqFEXFxcIsOswrXCqFx1MDAxZmrDkcODw5rCklx1MDAwZXIwXHUwMDFkKcOlw7ggXFxcXFFcdTAwMWbDlmnDhSguLGfDn8KIXFx2asKoXFxiw5gqw7/CkMOrw4zDu8OJw4DDplxcYsKLwqJtQMKkKsKmXFx2b8OpwqIqQ8KWw7tcdTAwMTPCtsKMPUo1WSQjw5nDucKbwqDDmlfDvMKVRk/DlD19XFxcIsOswrXCqFx1MDAxYmLDvCHCq8KKXHUwMDA1XHUwMDFhwoHCiFx1MDAxZcKpw6jCrcKUw6nDq8OML8OqOsK6XHUwMDE2w6fCkFx1MDAwM8OANcKrWcOmXHUwMDEyQcOZOGQ2wo7CkcOewqRcdTAwMGZvw5nCn8Ouw6hcdTAwMWMpwp1ZecO8w7/DqsOVeMOTwrkww6hcdTAwMWHCqVxcYsOWwpBPWlx1MDAxM1x1MDAxNMOjw5kkw4NBJ1xcdFx1MDAxOSnDs8KtwpTDncKLw7s9SjbDvX8oMVwiKSk7dmFyICQsbSxILEkscSxSLGs9e2E6e2I6ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGguY29zKHQpfSxhOmZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLmV4cCh0KX0sYzpmdW5jdGlvbih0LGYsdil7cC5jb3B5V2l0aGluKHQsZixmK3YpfSxkOmZ1bmN0aW9uKHQpe3AubGVuZ3RoLGZ1bmN0aW9uKHQpe3Rocm93XCJPT01cIn0oKX19fTtXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShPLndhc20saykudGhlbigoZnVuY3Rpb24odCl7dmFyIGYsdj10Lmluc3RhbmNlLmV4cG9ydHM7JD12LmcsbT12LmgsSD12LmksST12LmoscT12LmssUj12Lmwsdi5tLGY9di5lLmJ1ZmZlcixuZXcgSW50OEFycmF5KGYpLG5ldyBJbnQxNkFycmF5KGYpLG5ldyBJbnQzMkFycmF5KGYpLHA9bmV3IFVpbnQ4QXJyYXkoZiksbmV3IFVpbnQxNkFycmF5KGYpLG5ldyBVaW50MzJBcnJheShmKSxRPW5ldyBGbG9hdDMyQXJyYXkoZiksbmV3IEZsb2F0NjRBcnJheShmKSxmdW5jdGlvbih0KXt0LmYoKX0odiksZygpfSkpO2NvbnN0IFQ9bmV3IFByb21pc2UoKHQ9PntnPXR9KSksWT0odCxmKT0+e2NvbnN0IHY9bmV3IEZsb2F0MzJBcnJheShmKTtsZXQgYj0wO2Zvcihjb25zdCBNIG9mIHQpdi5zZXQoTSxiKSxiKz1NLmxlbmd0aDtyZXR1cm4gdn07Y2xhc3MgWntjb25zdHJ1Y3Rvcih0LGYpe3RoaXMuY2hhbm5lbERhdGE9dCx0aGlzLnNhbXBsZXNEZWNvZGVkPWYsdGhpcy5zYW1wbGVSYXRlPTQ4ZTN9fWNsYXNzIE57Y29uc3RydWN0b3IodCl7dGhpcy5yZWFkeT1ULHRoaXMub25EZWNvZGU9dC5vbkRlY29kZSx0aGlzLm9uRGVjb2RlQWxsPXQub25EZWNvZGVBbGx9cCh0KXtjb25zdCBmPUkoRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKnQpO3JldHVybltmLG5ldyBGbG9hdDMyQXJyYXkoUS5idWZmZXIsZix0KV19ZGVjb2RlKHQpe2lmKCEodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKXRocm93IEVycm9yKFwiRGF0YSB0byBkZWNvZGUgbXVzdCBiZSBVaW50OEFycmF5XCIpO3RoaXMuT3x8KHRoaXMuTz1IKCkpO2xldCBmLHYsYixNLEoscixlLGE9W10sbj1bXSxpPTA7dHJ5e2NvbnN0IG89MTE1MjA7W3YsYl09dGhpcy5wKG8pLFtNLEpdPXRoaXMucChvLzIpLFtyLGVdPXRoaXMucChvLzIpO2xldCBzLHU9NjU1MzYsYz0wO2NvbnN0IGg9dC5ieXRlTGVuZ3RoO2ZvcihmPUkodC5CWVRFU19QRVJfRUxFTUVOVCp1KTtjPGg7KXtpZihzPU1hdGgubWluKHUsaC1jKSxwLnNldCh0LnN1YmFycmF5KGMsYytzKSxmKSxjKz1zLCEkKHRoaXMuTyxmLHMpKXRocm93IEVycm9yKFwiQ291bGQgbm90IGVucXVldWUgYnl0ZXMgZm9yIGRlY29kaW5nLiAgWW91IG1heSBhbHNvIGhhdmUgaW52YWxpZCBPZ2cgT3B1cyBmaWxlLlwiKTtsZXQgYjtmb3IoOyhiPW0odGhpcy5PLHYsbyxNLHIpKT4wOyl7Y29uc3QgdD1KLnNsaWNlKDAsYiksZj1lLnNsaWNlKDAsYik7dGhpcy5vbkRlY29kZSYmdGhpcy5vbkRlY29kZShuZXcgWihbdCxmXSxiKSksdGhpcy5vbkRlY29kZUFsbCYmKGEucHVzaCh0KSxuLnB1c2goZiksaSs9Yil9aWYoYjwwKXRocm93IEVycm9yKGBsaWJvcHVzZmlsZSAke2J9OiAke3tbLTFdOlwiQSByZXF1ZXN0IGRpZCBub3Qgc3VjY2VlZC5cIixbLTNdOlwiVGhlcmUgd2FzIGEgaG9sZSBpbiB0aGUgcGFnZSBzZXF1ZW5jZSBudW1iZXJzIChlLmcuLCBhIHBhZ2Ugd2FzIGNvcnJ1cHQgb3IgbWlzc2luZykuXCIsWy0xMjhdOlwiQW4gdW5kZXJseWluZyByZWFkLCBzZWVrLCBvciB0ZWxsIG9wZXJhdGlvbiBmYWlsZWQgd2hlbiBpdCBzaG91bGQgaGF2ZSBzdWNjZWVkZWQuXCIsWy0xMjldOlwiQSBOVUxMIHBvaW50ZXIgd2FzIHBhc3NlZCB3aGVyZSBvbmUgd2FzIHVuZXhwZWN0ZWQsIG9yIGFuIGludGVybmFsIG1lbW9yeSBhbGxvY2F0aW9uIGZhaWxlZCwgb3IgYW4gaW50ZXJuYWwgbGlicmFyeSBlcnJvciB3YXMgZW5jb3VudGVyZWQuXCIsWy0xMzBdOlwiVGhlIHN0cmVhbSB1c2VkIGEgZmVhdHVyZSB0aGF0IGlzIG5vdCBpbXBsZW1lbnRlZCwgc3VjaCBhcyBhbiB1bnN1cHBvcnRlZCBjaGFubmVsIGZhbWlseS5cIixbLTEzMV06XCJPbmUgb3IgbW9yZSBwYXJhbWV0ZXJzIHRvIGEgZnVuY3Rpb24gd2VyZSBpbnZhbGlkLlwiLFstMTMyXTonQSBwdXJwb3J0ZWQgT2dnIE9wdXMgc3RyZWFtIGRpZCBub3QgYmVnaW4gd2l0aCBhbiBPZ2cgcGFnZSwgYSBwdXJwb3J0ZWQgaGVhZGVyIHBhY2tldCBkaWQgbm90IHN0YXJ0IHdpdGggb25lIG9mIHRoZSByZXF1aXJlZCBzdHJpbmdzLCBcIk9wdXNIZWFkXCIgb3IgXCJPcHVzVGFnc1wiLCBvciBhIGxpbmsgaW4gYSBjaGFpbmVkIGZpbGUgd2FzIGVuY291bnRlcmVkIHRoYXQgZGlkIG5vdCBjb250YWluIGFueSBsb2dpY2FsIE9wdXMgc3RyZWFtcy4nLFstMTMzXTpcIkEgcmVxdWlyZWQgaGVhZGVyIHBhY2tldCB3YXMgbm90IHByb3Blcmx5IGZvcm1hdHRlZCwgY29udGFpbmVkIGlsbGVnYWwgdmFsdWVzLCBvciB3YXMgbWlzc2luZyBhbHRvZ2V0aGVyLlwiLFstMTM0XTpcIlRoZSBJRCBoZWFkZXIgY29udGFpbmVkIGFuIHVucmVjb2duaXplZCB2ZXJzaW9uIG51bWJlci5cIixbLTEzNl06XCJBbiBhdWRpbyBwYWNrZXQgZmFpbGVkIHRvIGRlY29kZSBwcm9wZXJseS4gVGhpcyBpcyB1c3VhbGx5IGNhdXNlZCBieSBhIG11bHRpc3RyZWFtIE9nZyBwYWNrZXQgd2hlcmUgdGhlIGR1cmF0aW9ucyBvZiB0aGUgaW5kaXZpZHVhbCBPcHVzIHBhY2tldHMgY29udGFpbmVkIGluIGl0IGFyZSBub3QgYWxsIHRoZSBzYW1lLlwiLFstMTM3XTpcIldlIGZhaWxlZCB0byBmaW5kIGRhdGEgd2UgaGFkIHNlZW4gYmVmb3JlLCBvciB0aGUgYml0c3RyZWFtIHN0cnVjdHVyZSB3YXMgc3VmZmljaWVudGx5IG1hbGZvcm1lZCB0aGF0IHNlZWtpbmcgdG8gdGhlIHRhcmdldCBkZXN0aW5hdGlvbiB3YXMgaW1wb3NzaWJsZS5cIixbLTEzOF06XCJBbiBvcGVyYXRpb24gdGhhdCByZXF1aXJlcyBzZWVraW5nIHdhcyByZXF1ZXN0ZWQgb24gYW4gdW5zZWVrYWJsZSBzdHJlYW0uXCIsWy0xMzldOlwiVGhlIGZpcnN0IG9yIGxhc3QgZ3JhbnVsZSBwb3NpdGlvbiBvZiBhIGxpbmsgZmFpbGVkIGJhc2ljIHZhbGlkaXR5IGNoZWNrcy5cIn1bYl18fFwiVW5rbm93biBFcnJvclwifWApfXRoaXMub25EZWNvZGVBbGwmJmkmJnRoaXMub25EZWNvZGVBbGwobmV3IFooW1koYSxpKSxZKG4saSldLGkpKX1jYXRjaChvKXt0aHJvdyBvfWZpbmFsbHl7UihmKSxSKHYpLFIoTSksUihyKX19ZnJlZSgpe3RoaXMuTyYmcSh0aGlzLk8pfX1PLk9nZ09wdXNEZWNvZGVyPU4sXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbCYmZXhwb3J0cyYmKG1vZHVsZS5leHBvcnRzLk9nZ09wdXNEZWNvZGVyPU4pfSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2dnLW9wdXMtZGVjb2Rlci5taW4uanMubWFwIiwiY29uc3QgeyBFdmVudFRhcmdldCwgZGVmaW5lRXZlbnRBdHRyaWJ1dGUgfSA9IHJlcXVpcmUoJ2V2ZW50LXRhcmdldC1zaGltJyk7XG5jb25zdCB7IGRldGVjdCB9ID0gcmVxdWlyZSgnZGV0ZWN0LWJyb3dzZXInKTtcbmNvbnN0IGJyb3dzZXIgPSBkZXRlY3QoKTtcblxuY29uc3QgQXVkaW9Db250ZXh0ID0gZ2xvYmFsLkF1ZGlvQ29udGV4dCB8fCBnbG9iYWwud2Via2l0QXVkaW9Db250ZXh0O1xuY29uc3QgQlVGRkVSX1NJWkUgPSA0MDk2O1xuXG4vKipcbiAqIFJlZmVyZW5jZTogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL21lZGlhY2FwdHVyZS1yZWNvcmQvI21lZGlhcmVjb3JkZXItYXBpXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICovXG5jbGFzcyBPcHVzTWVkaWFSZWNvcmRlciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBlbmNvZGVyIHdlYiB3b3JrZXJcbiAgICogQG5hbWUgd29ya2VyRmFjdG9yeVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge3dvcmtlcn0gQW4gaW5zdGFuY2Ugb2YgLi9lbmNvZGVyV29ya2VyLmpzIHdlYiB3b3JrZXIuXG4gICAqL1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW0gLSBUaGUgTWVkaWFTdHJlYW0gdG8gYmUgcmVjb3JkZWQuIFRoaXMgd2lsbFxuICAgKiAgICAgICAgICBiZSB0aGUgdmFsdWUgb2YgdGhlIHN0cmVhbSBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSB7TWVkaWFSZWNvcmRlck9wdGlvbnN9IFtvcHRpb25zXSAtIEEgZGljdGlvbmFyeSBvZiBvcHRpb25zIHRvIGZvclxuICAgKiAgICAgICAgICB0aGUgVUEgaW5zdHJ1Y3RpbmcgaG93IHRoZSByZWNvcmRpbmcgd2lsbCB0YWtlIHBhcnQuXG4gICAqICAgICAgICAgIG9wdGlvbnMubWltZVR5cGUsIGlmIHByZXNlbnQsIHdpbGwgYmVjb21lIHRoZSB2YWx1ZSBvZiBtaW1lVHlwZVxuICAgKiAgICAgICAgICBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbd29ya2VyT3B0aW9uc10gVGhpcyBpcyBhIE5PTi1TVEFOREFSRCBvcHRpb25zIHRvXG4gICAqICAgICAgICAgIGNvbmZpZ3VyZSBob3cgdG8gaW1wb3J0IHRoZSB3ZWIgd29ya2VyIC53YXNtIGNvbXBpbGVkIGJpbmFyaWVzXG4gICAqICAgICAgICAgIHVzZWQgZm9yIGVuY29kaW5nLlxuICAgKiBAcGFyYW0ge3dvcmtlckZhY3Rvcnl9IFt3b3JrZXJPcHRpb25zLmVuY29kZXJXb3JrZXJGYWN0b3J5XSBBIGZhY3RvcnlcbiAgICogICAgICAgICAgZnVuY3Rpb24gdGhhdCBjcmVhdGUgYSB3ZWIgd29ya2VyIGluc3RhbmNlIG9mIC4vZW5jb2Rlcldvcmtlci5qc1xuICAgKiAgICAgICAgICBhbmQgcmV0dXJucyBpdC4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFdvcmtlcignLi9lbmNvZGVyV29ya2VyLnVtZC5qcycpfVxuICAgKiAgICAgICAgICBpcyB1c2VkIGJ5IGRlZmF1bHQuIFRoaXMgaXMgTk9OLVNUQU5EQVJELlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3dvcmtlck9wdGlvbnMuT2dnT3B1c0VuY29kZXJXYXNtUGF0aF1cbiAgICogICAgICAgICAgUGF0aCBvZiAuL09nZ09wdXNFbmNvZGVyLndhc20gd2hpY2ggaXMgdXNlZCBmb3IgT0dHIE9wdXMgZW5jb2RpbmdcbiAgICogICAgICAgICAgYnkgdGhlIGVuY29kZXIgd29ya2VyLiBUaGlzIGlzIE5PTi1TVEFOREFSRC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt3b3JrZXJPcHRpb25zLldlYk1PcHVzRW5jb2Rlcldhc21QYXRoXVxuICAgKiAgICAgICAgICBQYXRoIG9mIC4vV2ViTU9wdXNFbmNvZGVyLndhc20gd2hpY2ggaXMgdXNlZCBmb3IgV2ViTSBPcHVzIGVuY29kaW5nXG4gICAqICAgICAgICAgIGJ5IHRoZSBlbmNvZGVyIHdvcmtlci4gVGhpcyBpcyBOT04tU1RBTkRBUkQuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc3RyZWFtLCBvcHRpb25zID0ge30sIHdvcmtlck9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbWltZVR5cGUsIGF1ZGlvQml0c1BlclNlY29uZCwgdmlkZW9CaXRzUGVyU2Vjb25kLCBiaXRzUGVyU2Vjb25kIH0gPSBvcHRpb25zOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgLy8gTk9OLVNUQU5EQVJEIG9wdGlvbnNcbiAgICBjb25zdCB7IGVuY29kZXJXb3JrZXJGYWN0b3J5LCBPZ2dPcHVzRW5jb2Rlcldhc21QYXRoLCBXZWJNT3B1c0VuY29kZXJXYXNtUGF0aCB9ID0gd29ya2VyT3B0aW9ucztcblxuICAgIHN1cGVyKCk7XG4gICAgLy8gQXR0cmlidXRlcyBmb3IgdGhlIHNwZWNpZmljYXRpb24gY29uZm9ybWFuY2UuIFRoZXNlIGhhdmUgdGhlaXIgb3duIGdldHRlcnMuXG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3N0YXRlID0gJ2luYWN0aXZlJztcbiAgICB0aGlzLl9taW1lVHlwZSA9IG1pbWVUeXBlIHx8ICcnO1xuICAgIHRoaXMuX2F1ZGlvQml0c1BlclNlY29uZCA9IGF1ZGlvQml0c1BlclNlY29uZCB8fCBiaXRzUGVyU2Vjb25kO1xuICAgIC8qKiBAdHlwZSB7J2luYWN0aXZlJ3wncmVhZHlUb0luaXQnfCdlbmNvZGluZyd8J2Nsb3NlZCd9ICovXG4gICAgdGhpcy53b3JrZXJTdGF0ZSA9ICdpbmFjdGl2ZSc7XG5cbiAgICAvLyBQYXJzZSBNSU1FIFR5cGVcbiAgICBpZiAoIU9wdXNNZWRpYVJlY29yZGVyLmlzVHlwZVN1cHBvcnRlZCh0aGlzLl9taW1lVHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnRzLCBhIE1JTUUgVHlwZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIHN3aXRjaCAoT3B1c01lZGlhUmVjb3JkZXIuX3BhcnNlVHlwZSh0aGlzLl9taW1lVHlwZSkuc3VidHlwZSkge1xuICAgICAgY2FzZSAnd2F2ZSc6XG4gICAgICBjYXNlICd3YXYnOlxuICAgICAgICB0aGlzLl9taW1lVHlwZSA9ICdhdWRpby93YXZlJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3dlYm0nOlxuICAgICAgICB0aGlzLl9taW1lVHlwZSA9ICdhdWRpby93ZWJtJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29nZyc6XG4gICAgICAgIHRoaXMuX21pbWVUeXBlID0gJ2F1ZGlvL29nZyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBTZWxlY3QgYSB0eXBlIGRlcGVuZGluZyBvbiBPUy5cbiAgICAgICAgc3dpdGNoIChicm93c2VyICYmIGJyb3dzZXIubmFtZSkge1xuICAgICAgICAgIGNhc2UgJ2Nocm9tZSc6XG4gICAgICAgICAgICB0aGlzLl9taW1lVHlwZSA9ICdhdWRpby93ZWJtJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZmlyZWZveCc6XG4gICAgICAgICAgICB0aGlzLl9taW1lVHlwZSA9ICdhdWRpby9vZ2cnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdlZGdlJzpcbiAgICAgICAgICAgIHRoaXMuX21pbWVUeXBlID0gJ2F1ZGlvL3dlYm0nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdpb3MnOlxuICAgICAgICAgIGNhc2UgJ3NhZmFyaSc6XG4gICAgICAgICAgICB0aGlzLl9taW1lVHlwZSA9ICdhdWRpby93YXZlJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuX21pbWVUeXBlID0gJ2F1ZGlvL3dlYm0nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5fbWltZVR5cGUpIHtcbiAgICAgIGNhc2UgJ2F1ZGlvL3dhdmUnOlxuICAgICAgICB0aGlzLl93YXNtUGF0aCA9ICcnOyAvLyB3YXNtIGlzIG5vdCB1c2VkXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhdWRpby93ZWJtJzpcbiAgICAgICAgdGhpcy5fd2FzbVBhdGggPSBXZWJNT3B1c0VuY29kZXJXYXNtUGF0aCB8fCAnJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2F1ZGlvL29nZyc6XG4gICAgICAgIHRoaXMuX3dhc21QYXRoID0gT2dnT3B1c0VuY29kZXJXYXNtUGF0aCB8fCAnJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgRXJyb3I6IFVuZXhwZWN0ZWQgTUlNRSBUeXBlOiAke3RoaXMuX21pbWVUeXBlfWApO1xuICAgIH1cblxuICAgIC8vIEdldCBjdXJyZW50IGRpcmVjdG9yeSBmb3Igd29ya2VyXG4gICAgbGV0IHdvcmtlckRpciA9ICcnO1xuICAgIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgICB3b3JrZXJEaXIgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcbiAgICB9IGVsc2UgaWYgKHNlbGYubG9jYXRpb24pIHtcbiAgICAgIHdvcmtlckRpciA9IHNlbGYubG9jYXRpb24uaHJlZjtcbiAgICB9XG4gICAgd29ya2VyRGlyID0gd29ya2VyRGlyLnN1YnN0cigwLCB3b3JrZXJEaXIubGFzdEluZGV4T2YoJy8nKSkgK1xuICAgICAgICAgICAgICAgICcvZW5jb2Rlcldvcmtlci51bWQuanMnO1xuICAgIC8vIElmIHdvcmtlciBmdW5jdGlvbiBpcyBpbXBvcnRlZCB2aWEgPHNjcmlwdD4gdGFnLCBtYWtlIGl0IGJsb2IgdG8gZ2V0IFVSTC5cbiAgICBpZiAodHlwZW9mIE9wdXNNZWRpYVJlY29yZGVyLmVuY29kZXJXb3JrZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtlckRpciA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2AoJHtPcHVzTWVkaWFSZWNvcmRlci5lbmNvZGVyV29ya2VyfSkoKWBdKSk7XG4gICAgfVxuXG4gICAgLy8gU3Bhd24gYSBlbmNvZGVyIHdvcmtlclxuICAgIHRoaXMuX3dvcmtlckZhY3RvcnkgPSB0eXBlb2YgZW5jb2RlcldvcmtlckZhY3RvcnkgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVuY29kZXJXb3JrZXJGYWN0b3J5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfID0+IG5ldyBXb3JrZXIod29ya2VyRGlyKTtcbiAgICB0aGlzLl9zcGF3bldvcmtlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBNZWRpYVN0cmVhbSBbR0VUVVNFUk1FRElBXSB0byBiZSByZWNvcmRlZC5cbiAgICogQHJldHVybiB7TWVkaWFTdHJlYW19XG4gICAqL1xuICBnZXQgc3RyZWFtICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBNSU1FIHR5cGUgW1JGQzIwNDZdIHRoYXQgaGFzIGJlZW4gc2VsZWN0ZWQgYXMgdGhlIGNvbnRhaW5lciBmb3JcbiAgICogcmVjb3JkaW5nLiBUaGlzIGVudHJ5IGluY2x1ZGVzIGFsbCB0aGUgcGFyYW1ldGVycyB0byB0aGUgYmFzZVxuICAgKiBtaW1lVHlwZS4gVGhlIFVBIHNob3VsZCBiZSBhYmxlIHRvIHBsYXkgYmFjayBhbnkgb2YgdGhlIE1JTUUgdHlwZXNcbiAgICogaXQgc3VwcG9ydHMgZm9yIHJlY29yZGluZy4gRm9yIGV4YW1wbGUsIGl0IHNob3VsZCBiZSBhYmxlIHRvIGRpc3BsYXlcbiAgICogYSB2aWRlbyByZWNvcmRpbmcgaW4gdGhlIEhUTUwgPHZpZGVvPiB0YWcuIFRoZSBkZWZhdWx0IHZhbHVlIGZvclxuICAgKiB0aGlzIHByb3BlcnR5IGlzIHBsYXRmb3JtLXNwZWNpZmljLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbWltZVR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9taW1lVHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgT3B1c01lZGlhUmVjb3JkZXIgb2JqZWN0LiBXaGVuIHRoZSBPcHVzTWVkaWFSZWNvcmRlclxuICAgKiBpcyBjcmVhdGVkLCB0aGUgVUEgTVVTVCBzZXQgdGhpcyBhdHRyaWJ1dGUgdG8gaW5hY3RpdmUuXG4gICAqIEByZXR1cm4ge1wiaW5hY3RpdmVcInxcInJlY29yZGluZ1wifFwicGF1c2VkXCJ9XG4gICAqL1xuICBnZXQgc3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIFZpZGVvIGVuY29kaW5nLiBVbnN1cHBvcnRlZC5cbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0IHZpZGVvQml0c1BlclNlY29uZCAoKSB7XG4gICAgLy8gVmlkZW8gZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBBdWRpbyBlbmNvZGluZyB0YXJnZXQgYml0IHJhdGUgdGhhdCB3YXMgcGFzc2VkIHRvXG4gICAqIHRoZSBQbGF0Zm9ybSAocG90ZW50aWFsbHkgdHJ1bmNhdGVkLCByb3VuZGVkLCBldGMpLCBvciB0aGUgY2FsY3VsYXRlZCBvbmVcbiAgICogaWYgdGhlIHVzZXIgaGFzIHNwZWNpZmllZCBiaXRzUGVyU2Vjb25kLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0IGF1ZGlvQml0c1BlclNlY29uZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1ZGlvQml0c1BlclNlY29uZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHdvcmtlclxuICAgKi9cbiAgX3NwYXduV29ya2VyICgpIHtcbiAgICB0aGlzLndvcmtlciA9IHRoaXMuX3dvcmtlckZhY3RvcnkoKTtcbiAgICB0aGlzLndvcmtlci5vbm1lc3NhZ2UgPSAoZSkgPT4gdGhpcy5fb25tZXNzYWdlRnJvbVdvcmtlcihlKTtcbiAgICB0aGlzLndvcmtlci5vbmVycm9yID0gKGUpID0+IHRoaXMuX29uZXJyb3JGcm9tV29ya2VyKGUpO1xuXG4gICAgdGhpcy5fcG9zdE1lc3NhZ2VUb1dvcmtlcignbG9hZEVuY29kZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBtaW1lVHlwZTogdGhpcy5fbWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc21QYXRoOiB0aGlzLl93YXNtUGF0aCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3N0IG1lc3NhZ2UgdG8gdGhlIGVuY29kZXIgd2ViIHdvcmtlci5cbiAgICogQHBhcmFtIHtcImluaXRcInxcInB1c2hJbnB1dERhdGFcInxcImdldEVuY29kZWREYXRhXCJ8XCJkb25lXCJ9IGNvbW1hbmQgLSBUeXBlIG9mIG1lc3NhZ2UgdG8gc2VuZCB0byB0aGUgd29ya2VyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtZXNzYWdlIC0gUGF5bG9hZCB0byB0aGUgd29ya2VyXG4gICAqL1xuICBfcG9zdE1lc3NhZ2VUb1dvcmtlciAoY29tbWFuZCwgbWVzc2FnZSA9IHt9KSB7XG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICBjYXNlICdsb2FkRW5jb2Rlcic6XG4gICAgICAgIGxldCB7IG1pbWVUeXBlLCB3YXNtUGF0aCB9ID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoeyBjb21tYW5kLCBtaW1lVHlwZSwgd2FzbVBhdGggfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgd29ya2VyXG4gICAgICAgIGxldCB7IHNhbXBsZVJhdGUsIGNoYW5uZWxDb3VudCwgYml0c1BlclNlY29uZCB9ID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoeyBjb21tYW5kLCBzYW1wbGVSYXRlLCBjaGFubmVsQ291bnQsIGJpdHNQZXJTZWNvbmQgfSk7XG4gICAgICAgIHRoaXMud29ya2VyU3RhdGUgPSAnZW5jb2RpbmcnO1xuXG4gICAgICAgIC8vIFN0YXJ0IHN0cmVhbWluZ1xuICAgICAgICB0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMucHJvY2Vzc29yKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IuY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICBsZXQgZXZlbnRUb1B1c2ggPSBuZXcgZ2xvYmFsLkV2ZW50KCdzdGFydCcpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnRUb1B1c2gpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncHVzaElucHV0RGF0YSc6XG4gICAgICAgIC8vIFBhc3MgaW5wdXQgYXVkaW8gYnVmZmVyIHRvIHRoZSBlbmNvZGVyIHRvIGVuY29kZS5cbiAgICAgICAgLy8gVGhlIHdvcmtlciBNQVkgdHJpZ2dlciAnZW5jb2RlZERhdGEnLlxuICAgICAgICBsZXQgeyBjaGFubmVsQnVmZmVycywgbGVuZ3RoLCBkdXJhdGlvbiB9ID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGNvbW1hbmQsIGNoYW5uZWxCdWZmZXJzLCBsZW5ndGgsIGR1cmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZ2V0RW5jb2RlZERhdGEnOlxuICAgICAgICAvLyBSZXF1ZXN0IGVuY29kZWQgcmVzdWx0LlxuICAgICAgICAvLyBFeHBlY3RlZCAnZW5jb2RlZERhdGEnIGV2ZW50IGZyb20gdGhlIHdvcmtlclxuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7IGNvbW1hbmQgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgLy8gVGVsbCBlbmNvZGVyIGZpbmFsbGl6ZSB0aGUgam9iIGFuZCBkZXN0b3J5IGl0c2VsZi5cbiAgICAgICAgLy8gRXhwZWN0ZWQgJ2xhc3RFbmNvZGVkRGF0YScgZXZlbnQgZnJvbSB0aGUgd29ya2VyLlxuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7IGNvbW1hbmQgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBUaGlzIGlzIGFuIGVycm9yIGNhc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBFcnJvcjogSW5jb3JyZWN0IHBvc3RNZXNzYWdlIHJlcXVlc3RlZC4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogb25tZXNzYWdlKCkgY2FsbGJhY2sgZnJvbSB0aGUgd29ya2VyLlxuICAgKiBAcGFyYW0ge21lc3NhZ2V9IGV2ZW50IC0gbWVzc2FnZSBmcm9tIHRoZSB3b3JrZXJcbiAgICovXG4gIF9vbm1lc3NhZ2VGcm9tV29ya2VyIChldmVudCkge1xuICAgIGNvbnN0IHsgY29tbWFuZCwgYnVmZmVycyB9ID0gZXZlbnQuZGF0YTtcbiAgICBsZXQgZXZlbnRUb1B1c2g7XG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICBjYXNlICdyZWFkeVRvSW5pdCc6XG4gICAgICAgIGNvbnN0IHsgc2FtcGxlUmF0ZSwgY2hhbm5lbENvdW50IH0gPSB0aGlzO1xuICAgICAgICB0aGlzLndvcmtlclN0YXRlID0gJ3JlYWR5VG9Jbml0JztcblxuICAgICAgICAvLyBJZiBzdGFydCgpIGlzIGFscmVhZHkgY2FsbGVkIGluaXRpYWxpemUgd29ya2VyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAncmVjb3JkaW5nJykge1xuICAgICAgICAgIHRoaXMuX3Bvc3RNZXNzYWdlVG9Xb3JrZXIoJ2luaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzYW1wbGVSYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHNQZXJTZWNvbmQ6IHRoaXMuYXVkaW9CaXRzUGVyU2Vjb25kfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2VuY29kZWREYXRhJzpcbiAgICAgIGNhc2UgJ2xhc3RFbmNvZGVkRGF0YSc6XG4gICAgICAgIGxldCBkYXRhID0gbmV3IEJsb2IoYnVmZmVycywgeyd0eXBlJzogdGhpcy5fbWltZVR5cGV9KTtcbiAgICAgICAgZXZlbnRUb1B1c2ggPSBuZXcgZ2xvYmFsLkV2ZW50KCdkYXRhYXZhaWxhYmxlJyk7XG4gICAgICAgIGV2ZW50VG9QdXNoLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnRUb1B1c2gpO1xuXG4gICAgICAgIC8vIERldGVjdCBvZiBzdG9wKCkgY2FsbGVkIGJlZm9yZVxuICAgICAgICBpZiAoY29tbWFuZCA9PT0gJ2xhc3RFbmNvZGVkRGF0YScpIHtcbiAgICAgICAgICBldmVudFRvUHVzaCA9IG5ldyBnbG9iYWwuRXZlbnQoJ3N0b3AnKTtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnRUb1B1c2gpO1xuXG4gICAgICAgICAgdGhpcy53b3JrZXJTdGF0ZSA9ICdjbG9zZWQnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhazsgLy8gSWdub3JlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIG9uZXJyb3IoKSBjYWxsYmFjayBmcm9tIHRoZSB3b3JrZXIuXG4gICAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXJyb3IgLSBlcnJvciBvYmplY3QgZnJvbSB0aGUgd29ya2VyXG4gICAqL1xuICBfb25lcnJvckZyb21Xb3JrZXIgKGVycm9yKSB7XG4gICAgLy8gU3RvcCBzdHJlYW0gZmlyc3RcbiAgICB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5wcm9jZXNzb3IuZGlzY29ubmVjdCgpO1xuXG4gICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgdGhpcy53b3JrZXJTdGF0ZSA9ICdjbG9zZWQnO1xuXG4gICAgLy8gU2VuZCBtZXNzYWdlIHRvIGhvc3RcbiAgICBsZXQgbWVzc2FnZSA9IFtcbiAgICAgICdGaWxlTmFtZTogJyArIGVycm9yLmZpbGVuYW1lLFxuICAgICAgJ0xpbmVOdW1iZXI6ICcgKyBlcnJvci5saW5lbm8sXG4gICAgICAnTWVzc2FnZTogJyArIGVycm9yLm1lc3NhZ2VcbiAgICBdLmpvaW4oJyAtICcpO1xuICAgIGxldCBlcnJvclRvUHVzaCA9IG5ldyBnbG9iYWwuRXZlbnQoJ2Vycm9yJyk7XG4gICAgZXJyb3JUb1B1c2gubmFtZSA9ICdVbmtub3duRXJyb3InO1xuICAgIGVycm9yVG9QdXNoLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvclRvUHVzaCk7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlIG9uYXVkaW9wcm9jZXNzKCkgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc2xpY2UgLSBJbiBzZWNvbmRzLiBPcHVzTWVkaWFSZWNvcmRlciBzaG91bGQgcmVxdWVzdCBkYXRhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSB0aGUgd29ya2VyIGV2ZXJ5IHRpbWVzbGljZSBzZWNvbmRzLlxuICAgKi9cbiAgX2VuYWJsZUF1ZGlvUHJvY2Vzc0NhbGxiYWNrICh0aW1lc2xpY2UpIHtcbiAgICAvLyBwYXNzIGZyYW1lIGJ1ZmZlcnMgdG8gdGhlIHdvcmtlclxuICAgIGxldCBlbGFwc2VkVGltZSA9IDA7XG4gICAgdGhpcy5wcm9jZXNzb3Iub25hdWRpb3Byb2Nlc3MgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgeyBpbnB1dEJ1ZmZlciwgcGxheWJhY2tUaW1lIH0gPSBlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBjb25zdCB7IHNhbXBsZVJhdGUsIGxlbmd0aCwgZHVyYXRpb24sIG51bWJlck9mQ2hhbm5lbHMgfSA9IGlucHV0QnVmZmVyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgIC8vIENyZWF0ZSBjaGFubmVsIGJ1ZmZlcnMgdG8gcGFzcyB0byB0aGUgd29ya2VyXG4gICAgICBjb25zdCBjaGFubmVsQnVmZmVycyA9IG5ldyBBcnJheShudW1iZXJPZkNoYW5uZWxzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDaGFubmVsczsgaSsrKSB7XG4gICAgICAgIGNoYW5uZWxCdWZmZXJzW2ldID0gaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhc3MgZGF0YSB0byB0aGUgd29ya2VyXG4gICAgICBjb25zdCBtZXNzYWdlID0geyBjaGFubmVsQnVmZmVycywgbGVuZ3RoLCBkdXJhdGlvbiB9O1xuICAgICAgdGhpcy5fcG9zdE1lc3NhZ2VUb1dvcmtlcigncHVzaElucHV0RGF0YScsIG1lc3NhZ2UpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGltZVxuICAgICAgZWxhcHNlZFRpbWUgKz0gZHVyYXRpb247XG4gICAgICBpZiAoZWxhcHNlZFRpbWUgPj0gdGltZXNsaWNlKSB7XG4gICAgICAgIHRoaXMuX3Bvc3RNZXNzYWdlVG9Xb3JrZXIoJ2dldEVuY29kZWREYXRhJyk7XG4gICAgICAgIGVsYXBzZWRUaW1lID0gMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJlZ2lucyByZWNvcmRpbmcgbWVkaWE7IHRoaXMgbWV0aG9kIGNhbiBvcHRpb25hbGx5IGJlIHBhc3NlZCBhIHRpbWVzbGljZVxuICAgKiBhcmd1bWVudCB3aXRoIGEgdmFsdWUgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXNsaWNlIC0gSWYgdGhpcyBpcyBzcGVjaWZpZWQsIHRoZSBtZWRpYSB3aWxsIGJlIGNhcHR1cmVkXG4gICAqICAgICAgICBpbiBzZXBhcmF0ZSBjaHVua3Mgb2YgdGhhdCBkdXJhdGlvbiwgcmF0aGVyIHRoYW4gdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICogICAgICAgIG9mIHJlY29yZGluZyB0aGUgbWVkaWEgaW4gYSBzaW5nbGUgbGFyZ2UgY2h1bmsuIEluIG90aGVyIHdvcmRzLCBhblxuICAgKiAgICAgICAgdW5kZWZpbmVkIHZhbHVlIG9mIHRpbWVzbGljZSB3aWxsIGJlIHVuZGVyc3Rvb2QgYXMgdGhlIGxhcmdlc3QgbG9uZyB2YWx1ZS5cbiAgICovXG4gIHN0YXJ0ICh0aW1lc2xpY2UgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSAnaW5hY3RpdmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogSU5WQUxJRF9TVEFURV9FUlIsIHN0YXRlIG11c3QgYmUgaW5hY3RpdmUuJyk7XG4gICAgfVxuICAgIGlmICh0aW1lc2xpY2UgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50cywgdGltZXNsaWNlIHNob3VsZCBiZSAwIG9yIGhpZ2hlci4nKTtcbiAgICB9XG4gICAgdGltZXNsaWNlIC89IDEwMDA7IC8vIENvbnZlcnQgbWlsbGlzZWNvbmRzIHRvIHNlY29uZHNcblxuICAgIC8vIENoZWNrIHdvcmtlciBpcyBjbG9zZWQgKHVzdWFsbHkgYnkgc3RvcCgpKSBhbmQgaW5pdC5cbiAgICBpZiAodGhpcy53b3JrZXJTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRoaXMuX3NwYXduV29ya2VyKCk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGNoYW5uZWwgY291bnQgYW5kIHNhbXBsaW5nIHJhdGVcbiAgICAvLyBjaGFubmVsQ291bnQ6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9tZWRpYWNhcHR1cmUtc3RyZWFtcy8jbWVkaWEtdHJhY2stc2V0dGluZ3NcbiAgICAvLyBzYW1wbGVSYXRlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmFzZUF1ZGlvQ29udGV4dC9zYW1wbGVSYXRlXG4gICAgdGhpcy5jb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgIGxldCB0cmFja3MgPSB0aGlzLnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgIGlmICghdHJhY2tzWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogVW5rb3duRXJyb3IsIG1lZGlhIHRyYWNrIG5vdCBmb3VuZC4nKTtcbiAgICB9XG4gICAgdGhpcy5jaGFubmVsQ291bnQgPSB0cmFja3NbMF0uZ2V0U2V0dGluZ3MoKS5jaGFubmVsQ291bnQgfHwgMTtcbiAgICB0aGlzLnNhbXBsZVJhdGUgPSB0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZTtcblxuICAgIC8qKiBAdHlwZSB7TWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGV9ICovXG4gICAgdGhpcy5zb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UodGhpcy5zdHJlYW0pO1xuICAgIC8qKiBAdHlwZSB7U2NyaXB0UHJvY2Vzc29yTm9kZX0gKi9cbiAgICB0aGlzLnByb2Nlc3NvciA9IHRoaXMuY29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoQlVGRkVSX1NJWkUsIHRoaXMuY2hhbm5lbENvdW50LCB0aGlzLmNoYW5uZWxDb3VudCk7XG5cbiAgICAvLyBTdGFydCByZWNvcmRpbmdcbiAgICB0aGlzLl9zdGF0ZSA9ICdyZWNvcmRpbmcnO1xuICAgIHRoaXMuX2VuYWJsZUF1ZGlvUHJvY2Vzc0NhbGxiYWNrKHRpbWVzbGljZSk7XG5cbiAgICAvLyBJZiB0aGUgd29ya2VyIGlzIGFscmVhZHkgbG9hZGVkIHRoZW4gc3RhcnRcbiAgICBpZiAodGhpcy53b3JrZXJTdGF0ZSA9PT0gJ3JlYWR5VG9Jbml0Jykge1xuICAgICAgY29uc3QgeyBzYW1wbGVSYXRlLCBjaGFubmVsQ291bnQgfSA9IHRoaXM7XG4gICAgICB0aGlzLl9wb3N0TWVzc2FnZVRvV29ya2VyKCdpbml0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzYW1wbGVSYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzUGVyU2Vjb25kOiB0aGlzLmF1ZGlvQml0c1BlclNlY29uZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgcmVjb3JkaW5nLCBhdCB3aGljaCBwb2ludCBhIGRhdGFhdmFpbGFibGUgZXZlbnQgY29udGFpbmluZ1xuICAgKiB0aGUgZmluYWwgQmxvYiBvZiBzYXZlZCBkYXRhIGlzIGZpcmVkLiBObyBtb3JlIHJlY29yZGluZyBvY2N1cnMuXG4gICAqL1xuICBzdG9wICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2luYWN0aXZlJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdET01FeGNlcHRpb246IElOVkFMSURfU1RBVEVfRVJSLCBzdGF0ZSBtdXN0IE5PVCBiZSBpbmFjdGl2ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBTdG9wIHN0cmVhbSBmaXJzdFxuICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnByb2Nlc3Nvci5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5jb250ZXh0LmNsb3NlKCk7XG5cbiAgICAvLyBTdG9wIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIGF0IF9vbm1lc3NhZ2VGcm9tV29ya2VyKCksXG4gICAgdGhpcy5fcG9zdE1lc3NhZ2VUb1dvcmtlcignZG9uZScpO1xuXG4gICAgdGhpcy5fc3RhdGUgPSAnaW5hY3RpdmUnO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlcyB0aGUgcmVjb3JkaW5nIG9mIG1lZGlhLlxuICAgKi9cbiAgcGF1c2UgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAnaW5hY3RpdmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogSU5WQUxJRF9TVEFURV9FUlIsIHN0YXRlIG11c3QgTk9UIGJlIGluYWN0aXZlLicpO1xuICAgIH1cblxuICAgIC8vIFN0b3Agc3RyZWFtIGZpcnN0XG4gICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMucHJvY2Vzc29yLmRpc2Nvbm5lY3QoKTtcblxuICAgIGxldCBldmVudCA9IG5ldyBnbG9iYWwuRXZlbnQoJ3BhdXNlJyk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB0aGlzLl9zdGF0ZSA9ICdwYXVzZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZXMgcmVjb3JkaW5nIG9mIG1lZGlhIGFmdGVyIGhhdmluZyBiZWVuIHBhdXNlZC5cbiAgICovXG4gIHJlc3VtZSAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICdpbmFjdGl2ZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRE9NRXhjZXB0aW9uOiBJTlZBTElEX1NUQVRFX0VSUiwgc3RhdGUgbXVzdCBOT1QgYmUgaW5hY3RpdmUuJyk7XG4gICAgfVxuXG4gICAgLy8gUmVzdGFydCBzdHJlYW1pbmcgZGF0YVxuICAgIHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5wcm9jZXNzb3IpO1xuICAgIHRoaXMucHJvY2Vzc29yLmNvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblxuICAgIGxldCBldmVudCA9IG5ldyBnbG9iYWwuRXZlbnQoJ3Jlc3VtZScpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgdGhpcy5fc3RhdGUgPSAncmVjb3JkaW5nJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhIEJsb2IgY29udGFpbmluZyB0aGUgc2F2ZWQgZGF0YSByZWNlaXZlZCB0aHVzIGZhciAob3Igc2luY2VcbiAgICogdGhlIGxhc3QgdGltZSByZXF1ZXN0RGF0YSgpIHdhcyBjYWxsZWQuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsXG4gICAqIHJlY29yZGluZyBjb250aW51ZXMsIGJ1dCBpbiBhIG5ldyBCbG9iLlxuICAgKi9cbiAgcmVxdWVzdERhdGEgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAnaW5hY3RpdmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogSU5WQUxJRF9TVEFURV9FUlIsIHN0YXRlIG11c3QgTk9UIGJlIGluYWN0aXZlLicpO1xuICAgIH1cblxuICAgIC8vIGRhdGFhdmFpbGFibGUgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZCBhdCBfb25tZXNzYWdlRnJvbVdvcmtlcigpXG4gICAgdGhpcy5fcG9zdE1lc3NhZ2VUb1dvcmtlcignZ2V0RW5jb2RlZERhdGEnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgQm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBnaXZlbiBNSU1FIHR5cGUgaXMgc3VwcG9ydGVkXG4gICAqIGJ5IHRoZSBjdXJyZW50IHVzZXIgYWdlbnQgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVR5cGUgLSBBIE1JTUUgVHlwZSwgaW5jbHVkaW5nIHBhcmFtZXRlcnMgd2hlbiBuZWVkZWQsXG4gICAqICAgICAgICAgIHNwZWNpZnlpbmcgYSBjb250YWluZXIgYW5kL29yIGNvZGVjIGZvcm1hdHMgZm9yIHJlY29yZGluZy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1R5cGVTdXBwb3J0ZWQgKG1pbWVUeXBlKSB7XG4gICAgLy8gU2VlOiBodHRwczovL3czYy5naXRodWIuaW8vbWVkaWFjYXB0dXJlLXJlY29yZC8jZG9tLW1lZGlhcmVjb3JkZXItaXN0eXBlc3VwcG9ydGVkXG5cbiAgICAvLyAxLiBJZiBlbXB0eSBzdHJpbmcsIHJldHVybiB0cnVlLlxuICAgIGlmICh0eXBlb2YgbWltZVR5cGUgPT09ICdzdHJpbmcnICYmICFtaW1lVHlwZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB2YXIge3R5cGUsIHN1YnR5cGUsIGNvZGVjfSA9IE9wdXNNZWRpYVJlY29yZGVyLl9wYXJzZVR5cGUobWltZVR5cGUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyAyLiBJZiBub3QgYSB2YWxpZCBzdHJpbmcsIHJldHVybiBmYWxzZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgIT09ICdhdWRpbycgfHxcbiAgICAgICEoc3VidHlwZSA9PT0gJ29nZycgfHwgc3VidHlwZSA9PT0gJ3dlYm0nIHx8XG4gICAgICAgIHN1YnR5cGUgPT09ICd3YXZlJyB8fCBzdWJ0eXBlID09PSAnd2F2JykpIHtcbiAgICAgIC8vIDMsNC4gSWYgdHlwZSBhbmQgc3VidHlwZSBhcmUgdW5zdXBwb3J0ZWQgdGhlIHJldHVybiBmYWxzZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gNS4gSWYgY29kZWMgaXMgdW5zdXBwb3J0ZWQgdGhlbiByZXR1cm4gZmFsc2UuXG4gICAgLy8gNi4gSWYgdGhlIHNwZWNpZmllZCBjb21iaW5hdGlvbiBvZiBhbGwgaXMgbm90IHN1cHBvcnRlZCB0aGFuIHJldHVybiBmYWxzZS5cbiAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgIGNhc2UgJ29nZyc6XG4gICAgICAgIGlmIChjb2RlYyAhPT0gJ29wdXMnICYmIGNvZGVjKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2VibSc6XG4gICAgICAgIGlmIChjb2RlYyAhPT0gJ29wdXMnICYmIGNvZGVjKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2F2ZSc6XG4gICAgICBjYXNlICd3YXYnOlxuICAgICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHNpZ25lZCAxNiBiaXRzXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIDcuIHJldHVybiB0cnVlLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIE1JTUUuIEEgaGVscGVyIGZ1bmN0aW9uIGZvciBpc1R5cGVTdXBwb3J0ZWQoKSBhbmQgZXRjLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWltZVR5cGUgLSB0eXBlVHlwZSAtIEEgTUlNRSBUeXBlLCBpbmNsdWRpbmcgcGFyYW1ldGVycyB3aGVuIG5lZWRlZCxcbiAgICogICAgICAgICAgc3BlY2lmeWluZyBhIGNvbnRhaW5lciBhbmQvb3IgY29kZWMgZm9ybWF0cyBmb3IgcmVjb3JkaW5nLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSAtIEFuIG9iamVjdCB3aXRoIHR5cGUsIHN1YnR5cGUsIGNvZGVjIGF0dHJpYnV0ZXNcbiAgICogICAgICAgICAgaWYgcGFyc2VkIGNvcnJlY3RseS4gbnVsbCBpcyByZXR1cm5lZCBpZiBwYXJzaW5nIGZhaWxlZC5cbiAgICogICAgICAgICAgSWYgbWltZVR5cGUgaXMgYW4gZW1wdHkgc3RyaW5nIHRoZW4gcmV0dXJuIGFuIG9iamVjdCB3aXRoIGF0dHJpYnV0ZXNcbiAgICogICAgICAgICAgYXJlIGVtcHR5IHN0cmluZ3NcbiAgICovXG4gIHN0YXRpYyBfcGFyc2VUeXBlIChtaW1lVHlwZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZWdleCA9IC9eKFxcdyspXFwvKFxcdyspKDtcXHMqY29kZWNzPShcXHcrKSk/JC87XG4gICAgICB2YXIgWywgdHlwZSwgc3VidHlwZSwgLCBjb2RlY10gPSBtaW1lVHlwZS5tYXRjaChyZWdleCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICh0eXBlb2YgbWltZVR5cGUgPT09ICdzdHJpbmcnICYmICFtaW1lVHlwZSkge1xuICAgICAgICByZXR1cm4ge3R5cGU6ICcnLCBzdWJ0eXBlOiAnJywgY29kZWM6ICcnfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge3R5cGUsIHN1YnR5cGUsIGNvZGVjfTtcbiAgfVxufVxuXG4vLyBFdmVudEhhbmRsZXIgYXR0cmlidXRlcy5cbi8vIFRoaXMgY29kZSBpcyBhIG5vbi1zdGFuZGFyZCBFdmVudFRhcmdldCBidXQgcmVxdWlyZWQgYnkgZXZlbnQtdGFyZ2V0LXNoaW0uXG5bXG4gICdzdGFydCcsIC8vIENhbGxlZCB0byBoYW5kbGUgdGhlIHtAbGluayBNZWRpYVJlY29yZGVyI3N0YXJ0fSBldmVudC5cbiAgJ3N0b3AnLCAvLyBDYWxsZWQgdG8gaGFuZGxlIHRoZSBzdG9wIGV2ZW50LlxuICAnZGF0YWF2YWlsYWJsZScsIC8qIENhbGxlZCB0byBoYW5kbGUgdGhlIGRhdGFhdmFpbGFibGUgZXZlbnQuIFRoZSBCbG9iIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRlZCBkYXRhIGlzIGNvbnRhaW5lZCBpbiB0aGlzIGV2ZW50IGFuZCBjYW4gYmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc2VkIHZpYSBpdHMgZGF0YSBhdHRyaWJ1dGUuICovXG4gICdwYXVzZScsIC8vIENhbGxlZCB0byBoYW5kbGUgdGhlIHBhdXNlIGV2ZW50LlxuICAncmVzdW1lJywgLy8gQ2FsbGVkIHRvIGhhbmRsZSB0aGUgcmVzdW1lIGV2ZW50LlxuICAnZXJyb3InIC8vIENhbGxlZCB0byBoYW5kbGUgYSBNZWRpYVJlY29yZGVyRXJyb3JFdmVudC5cbl0uZm9yRWFjaChuYW1lID0+IGRlZmluZUV2ZW50QXR0cmlidXRlKE9wdXNNZWRpYVJlY29yZGVyLnByb3RvdHlwZSwgbmFtZSkpO1xuXG4vLyBNUyBFZGdlIHNwZWNpZmljIG1vbmtleSBwYXRjaGluZzpcbi8vIG9uYXVkaW9wcm9jZXNzIGNhbGxiYWNrIGNhbm5vdCBiZSB0cmlnZ2VyZWQgbW9yZSB0aGFuIHR3aWNlIHdoZW4gcG9zdE1lc3NhZ2Vcbi8vIHVzZXMgdGhlIHNlY29uZGUgdHJhbnNmZXIgYXJndW1lbnQuIFNvIGRpc2FibGUgdGhlIHRyYW5zZmVyIGFyZ3VtZW50IG9ubHkgaW4gRWRnZS5cbmlmIChicm93c2VyICYmIGJyb3dzZXIubmFtZSA9PT0gJ2VkZ2UnKSB7XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9yaWdpbmFsID0gV29ya2VyLnByb3RvdHlwZS5wb3N0TWVzc2FnZTtcbiAgICBXb3JrZXIucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHRyYW5zZmVyID0gbnVsbCkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgW21lc3NhZ2VdKTtcbiAgICB9O1xuICB9KSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9wdXNNZWRpYVJlY29yZGVyO1xuIiwiLyohIHF1ZXVlLW1pY3JvdGFzay4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xubGV0IHByb21pc2VcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbidcbiAgPyBxdWV1ZU1pY3JvdGFzay5iaW5kKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKVxuICAvLyByZXVzZSByZXNvbHZlZCBwcm9taXNlLCBhbmQgYWxsb2NhdGUgaXQgbGF6aWx5XG4gIDogY2IgPT4gKHByb21pc2UgfHwgKHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKSkpXG4gICAgLnRoZW4oY2IpXG4gICAgLmNhdGNoKGVyciA9PiBzZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZXJyIH0sIDApKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIGxpbWl0IG9mIENyeXB0by5nZXRSYW5kb21WYWx1ZXMoKVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NyeXB0by9nZXRSYW5kb21WYWx1ZXNcbnZhciBNQVhfQllURVMgPSA2NTUzNlxuXG4vLyBOb2RlIHN1cHBvcnRzIHJlcXVlc3RpbmcgdXAgdG8gdGhpcyBudW1iZXIgb2YgYnl0ZXNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvaW50ZXJuYWwvY3J5cHRvL3JhbmRvbS5qcyNMNDhcbnZhciBNQVhfVUlOVDMyID0gNDI5NDk2NzI5NVxuXG5mdW5jdGlvbiBvbGRCcm93c2VyICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdTZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLlxcblVzZSBDaHJvbWUsIEZpcmVmb3ggb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTEnKVxufVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0b1xuXG5pZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByYW5kb21CeXRlc1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBvbGRCcm93c2VyXG59XG5cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzIChzaXplLCBjYikge1xuICAvLyBwaGFudG9tanMgbmVlZHMgdG8gdGhyb3dcbiAgaWYgKHNpemUgPiBNQVhfVUlOVDMyKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncmVxdWVzdGVkIHRvbyBtYW55IHJhbmRvbSBieXRlcycpXG5cbiAgdmFyIGJ5dGVzID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpXG5cbiAgaWYgKHNpemUgPiAwKSB7ICAvLyBnZXRSYW5kb21WYWx1ZXMgZmFpbHMgb24gSUUgaWYgc2l6ZSA9PSAwXG4gICAgaWYgKHNpemUgPiBNQVhfQllURVMpIHsgLy8gdGhpcyBpcyB0aGUgbWF4IGJ5dGVzIGNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAgIC8vIGNhbiBkbyBhdCBvbmNlIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAgIGZvciAodmFyIGdlbmVyYXRlZCA9IDA7IGdlbmVyYXRlZCA8IHNpemU7IGdlbmVyYXRlZCArPSBNQVhfQllURVMpIHtcbiAgICAgICAgLy8gYnVmZmVyLnNsaWNlIGF1dG9tYXRpY2FsbHkgY2hlY2tzIGlmIHRoZSBlbmQgaXMgcGFzdCB0aGUgZW5kIG9mXG4gICAgICAgIC8vIHRoZSBidWZmZXIgc28gd2UgZG9uJ3QgaGF2ZSB0byBoZXJlXG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMuc2xpY2UoZ2VuZXJhdGVkLCBnZW5lcmF0ZWQgKyBNQVhfQllURVMpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYihudWxsLCBieXRlcylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgY29kZXMgPSB7fTtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0c0xvb3NlKE5vZGVFcnJvciwgX0Jhc2UpO1xuXG4gICAgZnVuY3Rpb24gTm9kZUVycm9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHJldHVybiBfQmFzZS5jYWxsKHRoaXMsIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBOb2RlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBCYXNlLm5hbWU7XG4gIE5vZGVFcnJvci5wcm90b3R5cGUuY29kZSA9IGNvZGU7XG4gIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTAuOC4wL2xpYi9pbnRlcm5hbC9lcnJvcnMuanNcblxuXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpKTtcbiAgICB9KTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyksIFwiLCBvciBcIikgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChTdHJpbmcoZXhwZWN0ZWQpKTtcbiAgfVxufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuXG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gsIHBvcykge1xuICByZXR1cm4gc3RyLnN1YnN0cighcG9zIHx8IHBvcyA8IDAgPyAwIDogK3Bvcywgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xuXG5cbmZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChzdGFydCArIHNlYXJjaC5sZW5ndGggPiBzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzZWFyY2gsIHN0YXJ0KSAhPT0gLTE7XG4gIH1cbn1cblxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9PUFRfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuICdUaGUgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwiJyArIG5hbWUgKyAnXCInO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICB2YXIgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfVxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQodHlwZW9mIGFjdHVhbCk7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GJywgJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdUaGUgJyArIG5hbWUgKyAnIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJywgJ1ByZW1hdHVyZSBjbG9zZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0RFU1RST1lFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnQ2Fubm90IGNhbGwgJyArIG5hbWUgKyAnIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NVUxUSVBMRV9DQUxMQkFDSycsICdDYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9DQU5OT1RfUElQRScsICdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EJywgJ3dyaXRlIGFmdGVyIGVuZCcpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX05VTExfVkFMVUVTJywgJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJywgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1VOS05PV05fRU5DT0RJTkcnLCBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiAnVW5rbm93biBlbmNvZGluZzogJyArIGFyZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQnLCAnc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG4ndXNlIHN0cmljdCc7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG5cbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcblxuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5cbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBJZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwgdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjsgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cblxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgZGVidWc7XG5cbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0Jyk7XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7IC8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG5cblxudmFyIFN0cmluZ0RlY29kZXI7XG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yO1xudmFyIGZyb207XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7IC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7IC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcblxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuXG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7IC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFJlYWRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5XG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IC8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTsgLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgZGVidWcoJ3JlYWRhYmxlQWRkQ2h1bmsnLCBjaHVuayk7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcblxuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQoKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSAvLyBXZSBjYW4gcHVzaCBtb3JlIGRhdGEgaWYgd2UgYXJlIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLlxuICAvLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZSBtb3JlIGJ5dGVzLlxuICAvLyBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLCBzdWNoIGFzIHRoZSByZXBsLlxuXG5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG5cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG5cbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInLCAnVWludDhBcnJheSddLCBjaHVuayk7XG4gIH1cblxuICByZXR1cm4gZXI7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHZhciBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gZGVjb2RlcjsgLy8gSWYgc2V0RW5jb2RpbmcobnVsbCksIGRlY29kZXIuZW5jb2RpbmcgZXF1YWxzIHV0ZjhcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nOyAvLyBJdGVyYXRlIG92ZXIgY3VycmVudCBidWZmZXIgdG8gY29udmVydCBhbHJlYWR5IHN0b3JlZCBCdWZmZXJzOlxuXG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICB3aGlsZSAocCAhPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShwLmRhdGEpO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuXG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG5cblxudmFyIE1BWF9IV00gPSAweDQwMDAwMDAwO1xuXG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG5cbiAgcmV0dXJuIG47XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG5cbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH0gLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG5cblxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjsgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcblxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59IC8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7IC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7IC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cblxuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfSAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG5cblxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlOyAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcblxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpO1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcblxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG5cbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAgIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH1cbiAgfVxufSAvLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuXG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcblxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9IC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZlxuICAvLyAxLiBJdCBpcyBub3QgZmxvd2luZywgYXMgdGhlIGZsb3cgbWVjaGFuaXNtIHdpbGwgdGFrZVxuICAvLyAgICBjYXJlIG9mIGl0LlxuICAvLyAyLiBJdCBpcyBub3QgZW5kZWQuXG4gIC8vIDMuIEl0IGlzIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLCBzbyB3ZSBjYW4gc2NoZWR1bGVcbiAgLy8gICAgYW5vdGhlciByZWFkYWJsZSBsYXRlci5cblxuXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgZmxvdyhzdHJlYW0pO1xufSAvLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cblxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIEF0dGVtcHQgdG8gcmVhZCBtb3JlIGRhdGEgaWYgd2Ugc2hvdWxkLlxuICAvL1xuICAvLyBUaGUgY29uZGl0aW9ucyBmb3IgcmVhZGluZyBtb3JlIGRhdGEgYXJlIChvbmUgb2YpOlxuICAvLyAtIE5vdCBlbm91Z2ggZGF0YSBidWZmZXJlZCAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykuIFRoZSBsb29wXG4gIC8vICAgaXMgcmVzcG9uc2libGUgZm9yIGZpbGxpbmcgdGhlIGJ1ZmZlciB3aXRoIGVub3VnaCBkYXRhIGlmIHN1Y2ggZGF0YVxuICAvLyAgIGlzIGF2YWlsYWJsZS4gSWYgaGlnaFdhdGVyTWFyayBpcyAwIGFuZCB3ZSBhcmUgbm90IGluIHRoZSBmbG93aW5nIG1vZGVcbiAgLy8gICB3ZSBzaG91bGQgX25vdF8gYXR0ZW1wdCB0byBidWZmZXIgYW55IGV4dHJhIGRhdGEuIFdlJ2xsIGdldCBtb3JlIGRhdGFcbiAgLy8gICB3aGVuIHRoZSBzdHJlYW0gY29uc3VtZXIgY2FsbHMgcmVhZCgpIGluc3RlYWQuXG4gIC8vIC0gTm8gZGF0YSBpbiB0aGUgYnVmZmVyLCBhbmQgdGhlIHN0cmVhbSBpcyBpbiBmbG93aW5nIG1vZGUuIEluIHRoaXMgbW9kZVxuICAvLyAgIHRoZSBsb29wIGJlbG93IGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyByZWFkKCkgaXMgY2FsbGVkLiBGYWlsaW5nIHRvXG4gIC8vICAgY2FsbCByZWFkIGhlcmUgd291bGQgYWJvcnQgdGhlIGZsb3cgYW5kIHRoZXJlJ3Mgbm8gb3RoZXIgbWVjaGFuaXNtIGZvclxuICAvLyAgIGNvbnRpbnVpbmcgdGhlIGZsb3cgaWYgdGhlIHN0cmVhbSBjb25zdW1lciBoYXMganVzdCBzdWJzY3JpYmVkIHRvIHRoZVxuICAvLyAgICdkYXRhJyBldmVudC5cbiAgLy9cbiAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGFib3ZlIGNvbmRpdGlvbnMgdG8ga2VlcCByZWFkaW5nIGRhdGEsIHRoZSBmb2xsb3dpbmdcbiAgLy8gY29uZGl0aW9ucyBwcmV2ZW50IHRoZSBkYXRhIGZyb20gYmVpbmcgcmVhZDpcbiAgLy8gLSBUaGUgc3RyZWFtIGhhcyBlbmRlZCAoc3RhdGUuZW5kZWQpLlxuICAvLyAtIFRoZXJlIGlzIGFscmVhZHkgYSBwZW5kaW5nICdyZWFkJyBvcGVyYXRpb24gKHN0YXRlLnJlYWRpbmcpLiBUaGlzIGlzIGFcbiAgLy8gICBjYXNlIHdoZXJlIHRoZSB0aGUgc3RyZWFtIGhhcyBjYWxsZWQgdGhlIGltcGxlbWVudGF0aW9uIGRlZmluZWQgX3JlYWQoKVxuICAvLyAgIG1ldGhvZCwgYnV0IHRoZXkgYXJlIHByb2Nlc3NpbmcgdGhlIGNhbGwgYXN5bmNocm9ub3VzbHkgYW5kIGhhdmUgX25vdF9cbiAgLy8gICBjYWxsZWQgcHVzaCgpIHdpdGggbmV3IGRhdGEuIEluIHRoaXMgY2FzZSB3ZSBza2lwIHBlcmZvcm1pbmcgbW9yZVxuICAvLyAgIHJlYWQoKXMuIFRoZSBleGVjdXRpb24gZW5kcyBpbiB0aGlzIG1ldGhvZCBhZ2FpbiBhZnRlciB0aGUgX3JlYWQoKSBlbmRzXG4gIC8vICAgdXAgY2FsbGluZyBwdXNoKCkgd2l0aCBtb3JlIGRhdGEuXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDApKSB7XG4gICAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59IC8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG5cbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcblxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9IC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuXG5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpOyAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7IC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgZGVidWcoJ2Rlc3Qud3JpdGUnLCByZXQpO1xuXG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICB9XG5cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfSAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuXG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpO1xuICB9IC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cblxuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTsgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcblxuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9IC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG5cblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpOyAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHtcbiAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICB9OyAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzOyAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7IC8vIGdvdCBhIG1hdGNoLlxuXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cblxuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gdXBkYXRlIHJlYWRhYmxlTGlzdGVuaW5nIHNvIHRoYXQgcmVzdW1lKCkgbWF5IGJlIGEgbm8tb3BcbiAgICAvLyBhIGZldyBsaW5lcyBkb3duLiBUaGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJykuXG4gICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwOyAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG5cbiAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGRlYnVnKCdvbiByZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUucmVhZGluZyk7XG5cbiAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2KSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYpIHtcbiAgdmFyIHN0YXRlID0gc2VsZi5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwO1xuXG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7IC8vIGNydWRlIHdheSB0byBjaGVjayBpZiB3ZSBzaG91bGQgcmVzdW1lXG4gIH0gZWxzZSBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKSB7XG4gICAgc2VsZi5yZXN1bWUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59IC8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTsgLy8gd2UgZmxvdyBvbmx5IGlmIHRoZXJlIGlzIG5vIG9uZSBsaXN0ZW5pbmdcbiAgICAvLyBmb3IgcmVhZGFibGUsIGJ1dCB3ZSBzdGlsbCBoYXZlIHRvIGNhbGxcbiAgICAvLyByZXN1bWUoKVxuXG4gICAgc3RhdGUuZmxvd2luZyA9ICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZztcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG5cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdyZXN1bWUnLCBzdGF0ZS5yZWFkaW5nKTtcblxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcblxuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7XG4gICAgO1xuICB9XG59IC8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG5cbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7IC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiBtZXRob2RXcmFwKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfSAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG5cblxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9IC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG5cblxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuXG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcyk7XG4gIH07XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pOyAvLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmZpcnN0KCk7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlTlQnLCBzdGF0ZS5lbmRFbWl0dGVkLCBzdGF0ZS5sZW5ndGgpOyAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblxuICAgICAgaWYgKCF3U3RhdGUgfHwgd1N0YXRlLmF1dG9EZXN0cm95ICYmIHdTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5mcm9tID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBvcHRzKSB7XG4gICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9mcm9tJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cblxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyxcbiAgICBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzA7XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCkpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG4gIGNiKGVyKTtcbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuXG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9OyAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9IC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cblxuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCkge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTsgLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ190cmFuc2Zvcm0oKScpKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG5cbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59OyAvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpOyAvLyBUT0RPKEJyaWRnZUFSKTogV3JpdGUgYSB0ZXN0IGZvciB0aGVzZSB0d28gZXJyb3IgY2FzZXNcbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcblxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCgpO1xuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HKCk7XG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcbi8qIDxyZXBsYWNlbWVudD4gKi9cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufSAvLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuXG5cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVELFxuICAgIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX05VTExfVkFMVUVTLFxuICAgIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gICAgRVJSX1VOS05PV05fRU5DT0RJTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVU5LTk9XTl9FTkNPRElORztcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0sXG4gIC8vIGUuZy4gb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgdnMuIG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlLCBldGMuXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG5cbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlOyAvLyBkcmFpbiBldmVudCBmbGFnLlxuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7IC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG5cbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTsgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTsgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG5cbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlOyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuXG4gIHRoaXMubGVuZ3RoID0gMDsgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cblxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTsgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuXG4gIHRoaXMuY29ya2VkID0gMDsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cblxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07IC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuXG5cbiAgdGhpcy53cml0ZWNiID0gbnVsbDsgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7IC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuXG4gIHRoaXMucGVuZGluZ2NiID0gMDsgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2ZpbmlzaCcgKGFuZCBwb3RlbnRpYWxseSAnZW5kJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwOyAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cblxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUJ1ZmZlckdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7IC8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxuXG5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIHJlYWxIYXNJbnN0YW5jZShvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpOyAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFdyaXRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3kuXG5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufSAvLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5cblxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFKCkpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCgpOyAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG59IC8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cblxuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgZXI7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInXSwgY2h1bmspO1xuICB9XG5cbiAgaWYgKGVyKSB7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcbiAgaWYgKHN0YXRlLmVuZGluZykgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTsgLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cblxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cblxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrOyAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cblxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpKTtlbHNlIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcblxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCk7XG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKSB8fCBzdHJlYW0uZGVzdHJveWVkO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn0gLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5cblxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufSAvLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuXG5cbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcblxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpOyAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tOyAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3dyaXRlKCknKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpOyAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH0gLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuXG5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG5cbiAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAgIC8vIGlmIHRoZSByZWFkYWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcblxuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3MubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG5cbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH0gLy8gcmV1c2UgdGhlIGZyZWUgY29ya1JlcS5cblxuXG4gIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGZpbmlzaGVkID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG5cbnZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woJ2xhc3RSZXNvbHZlJyk7XG52YXIga0xhc3RSZWplY3QgPSBTeW1ib2woJ2xhc3RSZWplY3QnKTtcbnZhciBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG52YXIga0VuZGVkID0gU3ltYm9sKCdlbmRlZCcpO1xudmFyIGtMYXN0UHJvbWlzZSA9IFN5bWJvbCgnbGFzdFByb21pc2UnKTtcbnZhciBrSGFuZGxlUHJvbWlzZSA9IFN5bWJvbCgnaGFuZGxlUHJvbWlzZScpO1xudmFyIGtTdHJlYW0gPSBTeW1ib2woJ3N0cmVhbScpO1xuXG5mdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6IGRvbmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikge1xuICB2YXIgcmVzb2x2ZSA9IGl0ZXJba0xhc3RSZXNvbHZlXTtcblxuICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgIHZhciBkYXRhID0gaXRlcltrU3RyZWFtXS5yZWFkKCk7IC8vIHdlIGRlZmVyIGlmIGRhdGEgaXMgbnVsbFxuICAgIC8vIHdlIGNhbiBiZSBleHBlY3RpbmcgZWl0aGVyICdlbmQnIG9yXG4gICAgLy8gJ2Vycm9yJ1xuXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVhZGFibGUoaXRlcikge1xuICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGl0IG1pZ2h0XG4gIC8vIGVtaXQgYW4gZXJyb3Igd2l0aCBwcm9jZXNzLm5leHRUaWNrXG4gIHByb2Nlc3MubmV4dFRpY2socmVhZEFuZFJlc29sdmUsIGl0ZXIpO1xufVxuXG5mdW5jdGlvbiB3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgaXRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGl0ZXJba0VuZGVkXSkge1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlcltrSGFuZGxlUHJvbWlzZV0ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9LCByZWplY3QpO1xuICB9O1xufVxuXG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiAoKSB7fSk7XG52YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKChfT2JqZWN0JHNldFByb3RvdHlwZU8gPSB7XG4gIGdldCBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XG4gIH0sXG5cbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBkZXRlY3RlZCBhbiBlcnJvciBpbiB0aGUgbWVhbndoaWxlXG4gICAgLy8gcmVqZWN0IHN0cmFpZ2h0IGF3YXlcbiAgICB2YXIgZXJyb3IgPSB0aGlzW2tFcnJvcl07XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0VuZGVkXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tTdHJlYW1dLmRlc3Ryb3llZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBkZWZlciB2aWEgbmV4dFRpY2sgYmVjYXVzZSBpZiAuZGVzdHJveShlcnIpIGlzXG4gICAgICAvLyBjYWxsZWQsIHRoZSBlcnJvciB3aWxsIGJlIGVtaXR0ZWQgdmlhIG5leHRUaWNrLCBhbmRcbiAgICAgIC8vIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBubyBlcnJvciBsaW5nZXJpbmcgYXJvdW5kXG4gICAgICAvLyB3YWl0aW5nIHRvIGJlIGVtaXR0ZWQuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXNba0Vycm9yXSkge1xuICAgICAgICAgICAgcmVqZWN0KF90aGlzW2tFcnJvcl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBuZXh0KCkgY2FsbHNcbiAgICAvLyB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBQcm9taXNlIHRvIGZpbmlzaFxuICAgIC8vIHRoaXMgbG9naWMgaXMgb3B0aW1pemVkIHRvIHN1cHBvcnQgZm9yIGF3YWl0IGxvb3BzLFxuICAgIC8vIHdoZXJlIG5leHQoKSBpcyBvbmx5IGNhbGxlZCBvbmNlIGF0IGEgdGltZVxuXG5cbiAgICB2YXIgbGFzdFByb21pc2UgPSB0aGlzW2tMYXN0UHJvbWlzZV07XG4gICAgdmFyIHByb21pc2U7XG5cbiAgICBpZiAobGFzdFByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYXN0IHBhdGggbmVlZGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgdGhpcy5wdXNoKClcbiAgICAgIC8vIHdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgbmV4dCgpIHF1ZXVlXG4gICAgICB2YXIgZGF0YSA9IHRoaXNba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHRoaXNba0hhbmRsZVByb21pc2VdKTtcbiAgICB9XG5cbiAgICB0aGlzW2tMYXN0UHJvbWlzZV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBcInJldHVyblwiLCBmdW5jdGlvbiBfcmV0dXJuKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAvLyBkZXN0cm95KGVyciwgY2IpIGlzIGEgcHJpdmF0ZSBBUElcbiAgLy8gd2UgY2FuIGd1YXJhbnRlZSB3ZSBoYXZlIHRoYXQgaGVyZSwgYmVjYXVzZSB3ZSBjb250cm9sIHRoZVxuICAvLyBSZWFkYWJsZSBjbGFzcyB0aGlzIGlzIGF0dGFjaGVkIHRvXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfSk7XG4gIH0pO1xufSksIF9PYmplY3Qkc2V0UHJvdG90eXBlTyksIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSkge1xuICB2YXIgX09iamVjdCRjcmVhdGU7XG5cbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIChfT2JqZWN0JGNyZWF0ZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtTdHJlYW0sIHtcbiAgICB2YWx1ZTogc3RyZWFtLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVzb2x2ZSwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVqZWN0LCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0Vycm9yLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0VuZGVkLCB7XG4gICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtIYW5kbGVQcm9taXNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGRhdGEgPSBpdGVyYXRvcltrU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gcmVzb2x2ZTtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gcmVqZWN0O1xuICAgICAgfVxuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9PYmplY3QkY3JlYXRlKSk7XG4gIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICBmaW5pc2hlZChzdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XG4gICAgICB2YXIgcmVqZWN0ID0gaXRlcmF0b3Jba0xhc3RSZWplY3RdOyAvLyByZWplY3QgaWYgd2UgYXJlIHdhaXRpbmcgZm9yIGRhdGEgaW4gdGhlIFByb21pc2VcbiAgICAgIC8vIHJldHVybmVkIGJ5IG5leHQoKSBhbmQgc3RvcmUgdGhlIGVycm9yXG5cbiAgICAgIGlmIChyZWplY3QgIT09IG51bGwpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0b3Jba0Vycm9yXSA9IGVycjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XG5cbiAgICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaXRlcmF0b3Jba0VuZGVkXSA9IHRydWU7XG4gIH0pO1xuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgb25SZWFkYWJsZS5iaW5kKG51bGwsIGl0ZXJhdG9yKSk7XG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnYnVmZmVyJyksXG4gICAgQnVmZmVyID0gX3JlcXVpcmUuQnVmZmVyO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgndXRpbCcpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIGN1c3RvbSA9IGluc3BlY3QgJiYgaW5zcGVjdC5jdXN0b20gfHwgJ2luc3BlY3QnO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoc3JjLCB0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckxpc3QsIFt7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuc2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IHRoaXMuaGVhZFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpvaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gam9pbihzKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uY2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgb3IgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uc3VtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1lKG4sIGhhc1N0cmluZ3MpIHtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIGlmIChuIDwgdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIGBzbGljZWAgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICAgIHJldCA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgICAgICB0aGlzLmhlYWQuZGF0YSA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICAgICAgfSBlbHNlIGlmIChuID09PSB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gRmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoLlxuICAgICAgICByZXQgPSB0aGlzLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXIuXG4gICAgICAgIHJldCA9IGhhc1N0cmluZ3MgPyB0aGlzLl9nZXRTdHJpbmcobikgOiB0aGlzLl9nZXRCdWZmZXIobik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0cmluZyhuKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHZhciByZXQgPSBwLmRhdGE7XG4gICAgICBuIC09IHJldC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgICAgIG4gLT0gbmI7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QnVmZmVyKG4pIHtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHAuZGF0YS5jb3B5KHJldCk7XG4gICAgICBuIC09IHAuZGF0YS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gTWFrZSBzdXJlIHRoZSBsaW5rZWQgbGlzdCBvbmx5IHNob3dzIHRoZSBtaW5pbWFsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbi5cblxuICB9LCB7XG4gICAga2V5OiBjdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKF8sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgLy8gT25seSBpbnNwZWN0IG9uZSBsZXZlbC5cbiAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgIC8vIEl0IHNob3VsZCBub3QgcmVjdXJzZS5cbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTsiLCIndXNlIHN0cmljdCc7IC8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcblxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9IC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcblxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGVtaXRDbG9zZU5UKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUgJiYgIXNlbGYuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIGlmIChzZWxmLl9yZWFkYWJsZVN0YXRlICYmICFzZWxmLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cbiAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHJTdGF0ZSAmJiByU3RhdGUuYXV0b0Rlc3Ryb3kgfHwgd1N0YXRlICYmIHdTdGF0ZS5hdXRvRGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koZXJyKTtlbHNlIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3k6IGVycm9yT3JEZXN0cm95XG59OyIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvZW5kLW9mLXN0cmVhbSB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0U7XG5cbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBlb3Moc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgdmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCBvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGU7XG4gIHZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgb3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlO1xuXG4gIHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uIG9ubGVnYWN5ZmluaXNoKCkge1xuICAgIGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuICB9O1xuXG4gIHZhciB3cml0YWJsZUVuZGVkID0gc3RyZWFtLl93cml0YWJsZVN0YXRlICYmIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZDtcblxuICB2YXIgb25maW5pc2ggPSBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgIHdyaXRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcblxuICB2YXIgcmVhZGFibGVFbmRlZCA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZDtcblxuICB2YXIgb25lbmQgPSBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgIHJlYWRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghd3JpdGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcblxuICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gIH07XG5cbiAgdmFyIG9uY2xvc2UgPSBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIHZhciBlcnI7XG5cbiAgICBpZiAocmVhZGFibGUgJiYgIXJlYWRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl9yZWFkYWJsZVN0YXRlIHx8ICFzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIGlmICh3cml0YWJsZSAmJiAhd3JpdGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3dyaXRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbiBvbnJlcXVlc3QoKSB7XG4gICAgc3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICB9O1xuXG4gIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkge1xuICAgIHN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTtlbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gIH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSkge1xuICAgIC8vIGxlZ2FjeSBzdHJlYW1zXG4gICAgc3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgfVxuXG4gIHN0cmVhbS5vbignZW5kJywgb25lbmQpO1xuICBzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgaWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVvczsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWFkYWJsZS5mcm9tIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXInKVxufTtcbiIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvcHVtcCB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVvcztcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUyxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVEO1xuXG5mdW5jdGlvbiBub29wKGVycikge1xuICAvLyBSZXRocm93IHRoZSBlcnJvciBpZiBpdCBleGlzdHMgdG8gYXZvaWQgc3dhbGxvd2luZyBpdFxuICBpZiAoZXJyKSB0aHJvdyBlcnI7XG59XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTtcbiAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsb3NlZCA9IHRydWU7XG4gIH0pO1xuICBpZiAoZW9zID09PSB1bmRlZmluZWQpIGVvcyA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuICBlb3Moc3RyZWFtLCB7XG4gICAgcmVhZGFibGU6IHJlYWRpbmcsXG4gICAgd3JpdGFibGU6IHdyaXRpbmdcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIGNsb3NlZCA9IHRydWU7XG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7IC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XG5cbiAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHJldHVybiBzdHJlYW0uYWJvcnQoKTtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gc3RyZWFtLmRlc3Ryb3koKTtcbiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdwaXBlJykpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjYWxsKGZuKSB7XG4gIGZuKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGUoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZyb20ucGlwZSh0byk7XG59XG5cbmZ1bmN0aW9uIHBvcENhbGxiYWNrKHN0cmVhbXMpIHtcbiAgaWYgKCFzdHJlYW1zLmxlbmd0aCkgcmV0dXJuIG5vb3A7XG4gIGlmICh0eXBlb2Ygc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbm9vcDtcbiAgcmV0dXJuIHN0cmVhbXMucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RyZWFtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdHJlYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGNhbGxiYWNrID0gcG9wQ2FsbGJhY2soc3RyZWFtcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNbMF0pKSBzdHJlYW1zID0gc3RyZWFtc1swXTtcblxuICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ3N0cmVhbXMnKTtcbiAgfVxuXG4gIHZhciBlcnJvcjtcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xuICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgd3JpdGluZyA9IGkgPiAwO1xuICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBpZiAocmVhZGluZykgcmV0dXJuO1xuICAgICAgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzdHJlYW1zLnJlZHVjZShwaXBlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaXBlbGluZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfSU5WQUxJRF9PUFRfVkFMVUUgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfSU5WQUxJRF9PUFRfVkFMVUU7XG5cbmZ1bmN0aW9uIGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpIHtcbiAgcmV0dXJuIG9wdGlvbnMuaGlnaFdhdGVyTWFyayAhPSBudWxsID8gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrIDogaXNEdXBsZXggPyBvcHRpb25zW2R1cGxleEtleV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRIaWdoV2F0ZXJNYXJrKHN0YXRlLCBvcHRpb25zLCBkdXBsZXhLZXksIGlzRHVwbGV4KSB7XG4gIHZhciBod20gPSBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KTtcblxuICBpZiAoaHdtICE9IG51bGwpIHtcbiAgICBpZiAoIShpc0Zpbml0ZShod20pICYmIE1hdGguZmxvb3IoaHdtKSA9PT0gaHdtKSB8fCBod20gPCAwKSB7XG4gICAgICB2YXIgbmFtZSA9IGlzRHVwbGV4ID8gZHVwbGV4S2V5IDogJ2hpZ2hXYXRlck1hcmsnO1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX09QVF9WQUxVRShuYW1lLCBod20pO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLmZsb29yKGh3bSk7XG4gIH0gLy8gRGVmYXVsdCB2YWx1ZVxuXG5cbiAgcmV0dXJuIHN0YXRlLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEhpZ2hXYXRlck1hcms6IGdldEhpZ2hXYXRlck1hcmtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuZXhwb3J0cy5maW5pc2hlZCA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcycpO1xuZXhwb3J0cy5waXBlbGluZSA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMnKTtcbiIsIi8qISBydW4td2F0ZXJmYWxsLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5tb2R1bGUuZXhwb3J0cyA9IHJ1bldhdGVyZmFsbFxuXG5mdW5jdGlvbiBydW5XYXRlcmZhbGwgKHRhc2tzLCBjYikge1xuICB2YXIgY3VycmVudCA9IDBcbiAgdmFyIGlzU3luYyA9IHRydWVcblxuICBmdW5jdGlvbiBkb25lIChlcnIsIGFyZ3MpIHtcbiAgICBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgYXJncyA9IGFyZ3MgPyBbXS5jb25jYXQoZXJyLCBhcmdzKSA6IFtlcnJdXG4gICAgICBpZiAoY2IpIGNiLmFwcGx5KHVuZGVmaW5lZCwgYXJncylcbiAgICB9XG4gICAgaWYgKGlzU3luYykgcHJvY2Vzcy5uZXh0VGljayhlbmQpXG4gICAgZWxzZSBlbmQoKVxuICB9XG5cbiAgZnVuY3Rpb24gZWFjaCAoZXJyKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgaWYgKCsrY3VycmVudCA+PSB0YXNrcy5sZW5ndGggfHwgZXJyKSB7XG4gICAgICBkb25lKGVyciwgYXJncylcbiAgICB9IGVsc2Uge1xuICAgICAgdGFza3NbY3VycmVudF0uYXBwbHkodW5kZWZpbmVkLCBbXS5jb25jYXQoYXJncywgZWFjaCkpXG4gICAgfVxuICB9XG5cbiAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgIHRhc2tzWzBdKGVhY2gpXG4gIH0gZWxzZSB7XG4gICAgZG9uZShudWxsKVxuICB9XG5cbiAgaXNTeW5jID0gZmFsc2Vcbn1cbiIsIi8qISBzYWZlLWJ1ZmZlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSlcblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIgLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFNEUCBoZWxwZXJzLlxudmFyIFNEUFV0aWxzID0ge307XG5cbi8vIEdlbmVyYXRlIGFuIGFscGhhbnVtZXJpYyBpZGVudGlmaWVyIGZvciBjbmFtZSBvciBtaWRzLlxuLy8gVE9ETzogdXNlIFVVSURzIGluc3RlYWQ/IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcblNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDEwKTtcbn07XG5cbi8vIFRoZSBSVENQIENOQU1FIHVzZWQgYnkgYWxsIHBlZXJjb25uZWN0aW9ucyBmcm9tIHRoZSBzYW1lIEpTLlxuU0RQVXRpbHMubG9jYWxDTmFtZSA9IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuXG4vLyBTcGxpdHMgU0RQIGludG8gbGluZXMsIGRlYWxpbmcgd2l0aCBib3RoIENSTEYgYW5kIExGLlxuU0RQVXRpbHMuc3BsaXRMaW5lcyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgcmV0dXJuIGJsb2IudHJpbSgpLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgIHJldHVybiBsaW5lLnRyaW0oKTtcbiAgfSk7XG59O1xuLy8gU3BsaXRzIFNEUCBpbnRvIHNlc3Npb25wYXJ0IGFuZCBtZWRpYXNlY3Rpb25zLiBFbnN1cmVzIENSTEYuXG5TRFBVdGlscy5zcGxpdFNlY3Rpb25zID0gZnVuY3Rpb24oYmxvYikge1xuICB2YXIgcGFydHMgPSBibG9iLnNwbGl0KCdcXG5tPScpO1xuICByZXR1cm4gcGFydHMubWFwKGZ1bmN0aW9uKHBhcnQsIGluZGV4KSB7XG4gICAgcmV0dXJuIChpbmRleCA+IDAgPyAnbT0nICsgcGFydCA6IHBhcnQpLnRyaW0oKSArICdcXHJcXG4nO1xuICB9KTtcbn07XG5cbi8vIFJldHVybnMgbGluZXMgdGhhdCBzdGFydCB3aXRoIGEgY2VydGFpbiBwcmVmaXguXG5TRFBVdGlscy5tYXRjaFByZWZpeCA9IGZ1bmN0aW9uKGJsb2IsIHByZWZpeCkge1xuICByZXR1cm4gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgIHJldHVybiBsaW5lLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbiAgfSk7XG59O1xuXG4vLyBQYXJzZXMgYW4gSUNFIGNhbmRpZGF0ZSBsaW5lLiBTYW1wbGUgaW5wdXQ6XG4vLyBjYW5kaWRhdGU6NzAyNzg2MzUwIDIgdWRwIDQxODE5OTAyIDguOC44LjggNjA3NjkgdHlwIHJlbGF5IHJhZGRyIDguOC44Ljhcbi8vIHJwb3J0IDU1OTk2XCJcblNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHM7XG4gIC8vIFBhcnNlIGJvdGggdmFyaWFudHMuXG4gIGlmIChsaW5lLmluZGV4T2YoJ2E9Y2FuZGlkYXRlOicpID09PSAwKSB7XG4gICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMikuc3BsaXQoJyAnKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICB9XG5cbiAgdmFyIGNhbmRpZGF0ZSA9IHtcbiAgICBmb3VuZGF0aW9uOiBwYXJ0c1swXSxcbiAgICBjb21wb25lbnQ6IHBhcnRzWzFdLFxuICAgIHByb3RvY29sOiBwYXJ0c1syXS50b0xvd2VyQ2FzZSgpLFxuICAgIHByaW9yaXR5OiBwYXJzZUludChwYXJ0c1szXSwgMTApLFxuICAgIGlwOiBwYXJ0c1s0XSxcbiAgICBwb3J0OiBwYXJzZUludChwYXJ0c1s1XSwgMTApLFxuICAgIC8vIHNraXAgcGFydHNbNl0gPT0gJ3R5cCdcbiAgICB0eXBlOiBwYXJ0c1s3XVxuICB9O1xuXG4gIGZvciAodmFyIGkgPSA4OyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBzd2l0Y2ggKHBhcnRzW2ldKSB7XG4gICAgICBjYXNlICdyYWRkcic6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdycG9ydCc6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCA9IHBhcnNlSW50KHBhcnRzW2kgKyAxXSwgMTApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RjcHR5cGUnOlxuICAgICAgICBjYW5kaWRhdGUudGNwVHlwZSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBleHRlbnNpb24gaGFuZGxpbmcsIGluIHBhcnRpY3VsYXIgdWZyYWdcbiAgICAgICAgY2FuZGlkYXRlW3BhcnRzW2ldXSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5kaWRhdGU7XG59O1xuXG4vLyBUcmFuc2xhdGVzIGEgY2FuZGlkYXRlIG9iamVjdCBpbnRvIFNEUCBjYW5kaWRhdGUgYXR0cmlidXRlLlxuU0RQVXRpbHMud3JpdGVDYW5kaWRhdGUgPSBmdW5jdGlvbihjYW5kaWRhdGUpIHtcbiAgdmFyIHNkcCA9IFtdO1xuICBzZHAucHVzaChjYW5kaWRhdGUuZm91bmRhdGlvbik7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5jb21wb25lbnQpO1xuICBzZHAucHVzaChjYW5kaWRhdGUucHJvdG9jb2wudG9VcHBlckNhc2UoKSk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcmlvcml0eSk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5pcCk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5wb3J0KTtcblxuICB2YXIgdHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuICBzZHAucHVzaCgndHlwJyk7XG4gIHNkcC5wdXNoKHR5cGUpO1xuICBpZiAodHlwZSAhPT0gJ2hvc3QnICYmIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyAmJlxuICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KSB7XG4gICAgc2RwLnB1c2goJ3JhZGRyJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzKTsgLy8gd2FzOiByZWxBZGRyXG4gICAgc2RwLnB1c2goJ3Jwb3J0Jyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KTsgLy8gd2FzOiByZWxQb3J0XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZS50Y3BUeXBlICYmIGNhbmRpZGF0ZS5wcm90b2NvbC50b0xvd2VyQ2FzZSgpID09PSAndGNwJykge1xuICAgIHNkcC5wdXNoKCd0Y3B0eXBlJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnRjcFR5cGUpO1xuICB9XG4gIHJldHVybiAnY2FuZGlkYXRlOicgKyBzZHAuam9pbignICcpO1xufTtcblxuLy8gUGFyc2VzIGFuIGljZS1vcHRpb25zIGxpbmUsIHJldHVybnMgYW4gYXJyYXkgb2Ygb3B0aW9uIHRhZ3MuXG4vLyBhPWljZS1vcHRpb25zOmZvbyBiYXJcblNEUFV0aWxzLnBhcnNlSWNlT3B0aW9ucyA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgcmV0dXJuIGxpbmUuc3Vic3RyKDE0KS5zcGxpdCgnICcpO1xufVxuXG4vLyBQYXJzZXMgYW4gcnRwbWFwIGxpbmUsIHJldHVybnMgUlRDUnRwQ29kZGVjUGFyYW1ldGVycy4gU2FtcGxlIGlucHV0OlxuLy8gYT1ydHBtYXA6MTExIG9wdXMvNDgwMDAvMlxuU0RQVXRpbHMucGFyc2VSdHBNYXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDkpLnNwbGl0KCcgJyk7XG4gIHZhciBwYXJzZWQgPSB7XG4gICAgcGF5bG9hZFR5cGU6IHBhcnNlSW50KHBhcnRzLnNoaWZ0KCksIDEwKSAvLyB3YXM6IGlkXG4gIH07XG5cbiAgcGFydHMgPSBwYXJ0c1swXS5zcGxpdCgnLycpO1xuXG4gIHBhcnNlZC5uYW1lID0gcGFydHNbMF07XG4gIHBhcnNlZC5jbG9ja1JhdGUgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOyAvLyB3YXM6IGNsb2NrcmF0ZVxuICAvLyB3YXM6IGNoYW5uZWxzXG4gIHBhcnNlZC5udW1DaGFubmVscyA9IHBhcnRzLmxlbmd0aCA9PT0gMyA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiAxO1xuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLy8gR2VuZXJhdGUgYW4gYT1ydHBtYXAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvclxuLy8gUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdHBNYXAgPSBmdW5jdGlvbihjb2RlYykge1xuICB2YXIgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIHJldHVybiAnYT1ydHBtYXA6JyArIHB0ICsgJyAnICsgY29kZWMubmFtZSArICcvJyArIGNvZGVjLmNsb2NrUmF0ZSArXG4gICAgICAoY29kZWMubnVtQ2hhbm5lbHMgIT09IDEgPyAnLycgKyBjb2RlYy5udW1DaGFubmVscyA6ICcnKSArICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIGFuIGE9ZXh0bWFwIGxpbmUgKGhlYWRlcmV4dGVuc2lvbiBmcm9tIFJGQyA1Mjg1KS4gU2FtcGxlIGlucHV0OlxuLy8gYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4vLyBhPWV4dG1hcDoyL3NlbmRvbmx5IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcblNEUFV0aWxzLnBhcnNlRXh0bWFwID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cig5KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGlkOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgIGRpcmVjdGlvbjogcGFydHNbMF0uaW5kZXhPZignLycpID4gMCA/IHBhcnRzWzBdLnNwbGl0KCcvJylbMV0gOiAnc2VuZHJlY3YnLFxuICAgIHVyaTogcGFydHNbMV1cbiAgfTtcbn07XG5cbi8vIEdlbmVyYXRlcyBhPWV4dG1hcCBsaW5lIGZyb20gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGVycyBvclxuLy8gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uLlxuU0RQVXRpbHMud3JpdGVFeHRtYXAgPSBmdW5jdGlvbihoZWFkZXJFeHRlbnNpb24pIHtcbiAgcmV0dXJuICdhPWV4dG1hcDonICsgKGhlYWRlckV4dGVuc2lvbi5pZCB8fCBoZWFkZXJFeHRlbnNpb24ucHJlZmVycmVkSWQpICtcbiAgICAgIChoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICYmIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kcmVjdidcbiAgICAgICAgICA/ICcvJyArIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb25cbiAgICAgICAgICA6ICcnKSArXG4gICAgICAnICcgKyBoZWFkZXJFeHRlbnNpb24udXJpICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgYW4gZnRtcCBsaW5lLCByZXR1cm5zIGRpY3Rpb25hcnkuIFNhbXBsZSBpbnB1dDpcbi8vIGE9Zm10cDo5NiB2YnI9b247Y25nPW9uXG4vLyBBbHNvIGRlYWxzIHdpdGggdmJyPW9uOyBjbmc9b25cblNEUFV0aWxzLnBhcnNlRm10cCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga3Y7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJzsnKTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgIGt2ID0gcGFydHNbal0udHJpbSgpLnNwbGl0KCc9Jyk7XG4gICAgcGFyc2VkW2t2WzBdLnRyaW0oKV0gPSBrdlsxXTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLy8gR2VuZXJhdGVzIGFuIGE9ZnRtcCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlRm10cCA9IGZ1bmN0aW9uKGNvZGVjKSB7XG4gIHZhciBsaW5lID0gJyc7XG4gIHZhciBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gIH1cbiAgaWYgKGNvZGVjLnBhcmFtZXRlcnMgJiYgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykubGVuZ3RoKSB7XG4gICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmZvckVhY2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIHBhcmFtcy5wdXNoKHBhcmFtICsgJz0nICsgY29kZWMucGFyYW1ldGVyc1twYXJhbV0pO1xuICAgIH0pO1xuICAgIGxpbmUgKz0gJ2E9Zm10cDonICsgcHQgKyAnICcgKyBwYXJhbXMuam9pbignOycpICsgJ1xcclxcbic7XG4gIH1cbiAgcmV0dXJuIGxpbmU7XG59O1xuXG4vLyBQYXJzZXMgYW4gcnRjcC1mYiBsaW5lLCByZXR1cm5zIFJUQ1BSdGNwRmVlZGJhY2sgb2JqZWN0LiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXJ0Y3AtZmI6OTggbmFjayBycHNpXG5TRFBVdGlscy5wYXJzZVJ0Y3BGYiA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHBhcnRzLnNoaWZ0KCksXG4gICAgcGFyYW1ldGVyOiBwYXJ0cy5qb2luKCcgJylcbiAgfTtcbn07XG4vLyBHZW5lcmF0ZSBhPXJ0Y3AtZmIgbGluZXMgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdGNwRmIgPSBmdW5jdGlvbihjb2RlYykge1xuICB2YXIgbGluZXMgPSAnJztcbiAgdmFyIHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBpZiAoY29kZWMucnRjcEZlZWRiYWNrICYmIGNvZGVjLnJ0Y3BGZWVkYmFjay5sZW5ndGgpIHtcbiAgICAvLyBGSVhNRTogc3BlY2lhbCBoYW5kbGluZyBmb3IgdHJyLWludD9cbiAgICBjb2RlYy5ydGNwRmVlZGJhY2suZm9yRWFjaChmdW5jdGlvbihmYikge1xuICAgICAgbGluZXMgKz0gJ2E9cnRjcC1mYjonICsgcHQgKyAnICcgKyBmYi50eXBlICtcbiAgICAgIChmYi5wYXJhbWV0ZXIgJiYgZmIucGFyYW1ldGVyLmxlbmd0aCA/ICcgJyArIGZiLnBhcmFtZXRlciA6ICcnKSArXG4gICAgICAgICAgJ1xcclxcbic7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxpbmVzO1xufTtcblxuLy8gUGFyc2VzIGFuIFJGQyA1NTc2IHNzcmMgbWVkaWEgYXR0cmlidXRlLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXNzcmM6MzczNTkyODU1OSBjbmFtZTpzb21ldGhpbmdcblNEUFV0aWxzLnBhcnNlU3NyY01lZGlhID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgc3AgPSBsaW5lLmluZGV4T2YoJyAnKTtcbiAgdmFyIHBhcnRzID0ge1xuICAgIHNzcmM6IHBhcnNlSW50KGxpbmUuc3Vic3RyKDcsIHNwIC0gNyksIDEwKVxuICB9O1xuICB2YXIgY29sb24gPSBsaW5lLmluZGV4T2YoJzonLCBzcCk7XG4gIGlmIChjb2xvbiA+IC0xKSB7XG4gICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHIoc3AgKyAxLCBjb2xvbiAtIHNwIC0gMSk7XG4gICAgcGFydHMudmFsdWUgPSBsaW5lLnN1YnN0cihjb2xvbiArIDEpO1xuICB9IGVsc2Uge1xuICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyKHNwICsgMSk7XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufTtcblxuLy8gRXh0cmFjdHMgdGhlIE1JRCAoUkZDIDU4ODgpIGZyb20gYSBtZWRpYSBzZWN0aW9uLlxuLy8gcmV0dXJucyB0aGUgTUlEIG9yIHVuZGVmaW5lZCBpZiBubyBtaWQgbGluZSB3YXMgZm91bmQuXG5TRFBVdGlscy5nZXRNaWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIG1pZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWlkOicpWzBdO1xuICBpZiAobWlkKSB7XG4gICAgcmV0dXJuIG1pZC5zdWJzdHIoNik7XG4gIH1cbn1cblxuU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIoMTQpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgYWxnb3JpdGhtOiBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLCAvLyBhbGdvcml0aG0gaXMgY2FzZS1zZW5zaXRpdmUgaW4gRWRnZS5cbiAgICB2YWx1ZTogcGFydHNbMV1cbiAgfTtcbn07XG5cbi8vIEV4dHJhY3RzIERUTFMgcGFyYW1ldGVycyBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4vLyAgIGdldCB0aGUgZmluZ2VycHJpbnQgbGluZSBhcyBpbnB1dC4gU2VlIGFsc28gZ2V0SWNlUGFyYW1ldGVycy5cblNEUFV0aWxzLmdldER0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICB2YXIgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAgICdhPWZpbmdlcnByaW50OicpO1xuICAvLyBOb3RlOiBhPXNldHVwIGxpbmUgaXMgaWdub3JlZCBzaW5jZSB3ZSB1c2UgdGhlICdhdXRvJyByb2xlLlxuICAvLyBOb3RlMjogJ2FsZ29yaXRobScgaXMgbm90IGNhc2Ugc2Vuc2l0aXZlIGV4Y2VwdCBpbiBFZGdlLlxuICByZXR1cm4ge1xuICAgIHJvbGU6ICdhdXRvJyxcbiAgICBmaW5nZXJwcmludHM6IGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUZpbmdlcnByaW50KVxuICB9O1xufTtcblxuLy8gU2VyaWFsaXplcyBEVExTIHBhcmFtZXRlcnMgdG8gU0RQLlxuU0RQVXRpbHMud3JpdGVEdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtcywgc2V0dXBUeXBlKSB7XG4gIHZhciBzZHAgPSAnYT1zZXR1cDonICsgc2V0dXBUeXBlICsgJ1xcclxcbic7XG4gIHBhcmFtcy5maW5nZXJwcmludHMuZm9yRWFjaChmdW5jdGlvbihmcCkge1xuICAgIHNkcCArPSAnYT1maW5nZXJwcmludDonICsgZnAuYWxnb3JpdGhtICsgJyAnICsgZnAudmFsdWUgKyAnXFxyXFxuJztcbiAgfSk7XG4gIHJldHVybiBzZHA7XG59O1xuLy8gUGFyc2VzIElDRSBpbmZvcm1hdGlvbiBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4vLyAgIGdldCB0aGUgaWNlLXVmcmFnIGFuZCBpY2UtcHdkIGxpbmVzIGFzIGlucHV0LlxuU0RQVXRpbHMuZ2V0SWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAvLyBTZWFyY2ggaW4gc2Vzc2lvbiBwYXJ0LCB0b28uXG4gIGxpbmVzID0gbGluZXMuY29uY2F0KFNEUFV0aWxzLnNwbGl0TGluZXMoc2Vzc2lvbnBhcnQpKTtcbiAgdmFyIGljZVBhcmFtZXRlcnMgPSB7XG4gICAgdXNlcm5hbWVGcmFnbWVudDogbGluZXMuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHJldHVybiBsaW5lLmluZGV4T2YoJ2E9aWNlLXVmcmFnOicpID09PSAwO1xuICAgIH0pWzBdLnN1YnN0cigxMiksXG4gICAgcGFzc3dvcmQ6IGxpbmVzLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICByZXR1cm4gbGluZS5pbmRleE9mKCdhPWljZS1wd2Q6JykgPT09IDA7XG4gICAgfSlbMF0uc3Vic3RyKDEwKVxuICB9O1xuICByZXR1cm4gaWNlUGFyYW1ldGVycztcbn07XG5cbi8vIFNlcmlhbGl6ZXMgSUNFIHBhcmFtZXRlcnMgdG8gU0RQLlxuU0RQVXRpbHMud3JpdGVJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiAnYT1pY2UtdWZyYWc6JyArIHBhcmFtcy51c2VybmFtZUZyYWdtZW50ICsgJ1xcclxcbicgK1xuICAgICAgJ2E9aWNlLXB3ZDonICsgcGFyYW1zLnBhc3N3b3JkICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIFJUQ1J0cFBhcmFtZXRlcnMuXG5TRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIGRlc2NyaXB0aW9uID0ge1xuICAgIGNvZGVjczogW10sXG4gICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgZmVjTWVjaGFuaXNtczogW10sXG4gICAgcnRjcDogW11cbiAgfTtcbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICB2YXIgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICBmb3IgKHZhciBpID0gMzsgaSA8IG1saW5lLmxlbmd0aDsgaSsrKSB7IC8vIGZpbmQgYWxsIGNvZGVjcyBmcm9tIG1saW5lWzMuLl1cbiAgICB2YXIgcHQgPSBtbGluZVtpXTtcbiAgICB2YXIgcnRwbWFwbGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0cG1hcDonICsgcHQgKyAnICcpWzBdO1xuICAgIGlmIChydHBtYXBsaW5lKSB7XG4gICAgICB2YXIgY29kZWMgPSBTRFBVdGlscy5wYXJzZVJ0cE1hcChydHBtYXBsaW5lKTtcbiAgICAgIHZhciBmbXRwcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICAgIG1lZGlhU2VjdGlvbiwgJ2E9Zm10cDonICsgcHQgKyAnICcpO1xuICAgICAgLy8gT25seSB0aGUgZmlyc3QgYT1mbXRwOjxwdD4gaXMgY29uc2lkZXJlZC5cbiAgICAgIGNvZGVjLnBhcmFtZXRlcnMgPSBmbXRwcy5sZW5ndGggPyBTRFBVdGlscy5wYXJzZUZtdHAoZm10cHNbMF0pIDoge307XG4gICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnKVxuICAgICAgICAubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICAgIC8vIHBhcnNlIEZFQyBtZWNoYW5pc21zIGZyb20gcnRwbWFwIGxpbmVzLlxuICAgICAgc3dpdGNoIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnUkVEJzpcbiAgICAgICAgY2FzZSAnVUxQRkVDJzpcbiAgICAgICAgICBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLnB1c2goY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gb25seSBSRUQgYW5kIFVMUEZFQyBhcmUgcmVjb2duaXplZCBhcyBGRUMgbWVjaGFuaXNtcy5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1leHRtYXA6JykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgZGVzY3JpcHRpb24uaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKFNEUFV0aWxzLnBhcnNlRXh0bWFwKGxpbmUpKTtcbiAgfSk7XG4gIC8vIEZJWE1FOiBwYXJzZSBydGNwLlxuICByZXR1cm4gZGVzY3JpcHRpb247XG59O1xuXG4vLyBHZW5lcmF0ZXMgcGFydHMgb2YgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGRlc2NyaWJpbmcgdGhlIGNhcGFiaWxpdGllcyAvXG4vLyBwYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGtpbmQsIGNhcHMpIHtcbiAgdmFyIHNkcCA9ICcnO1xuXG4gIC8vIEJ1aWxkIHRoZSBtbGluZS5cbiAgc2RwICs9ICdtPScgKyBraW5kICsgJyAnO1xuICBzZHAgKz0gY2Fwcy5jb2RlY3MubGVuZ3RoID4gMCA/ICc5JyA6ICcwJzsgLy8gcmVqZWN0IGlmIG5vIGNvZGVjcy5cbiAgc2RwICs9ICcgVURQL1RMUy9SVFAvU0FWUEYgJztcbiAgc2RwICs9IGNhcHMuY29kZWNzLm1hcChmdW5jdGlvbihjb2RlYykge1xuICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gICAgfVxuICAgIHJldHVybiBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgfSkuam9pbignICcpICsgJ1xcclxcbic7XG5cbiAgc2RwICs9ICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJztcbiAgc2RwICs9ICdhPXJ0Y3A6OSBJTiBJUDQgMC4wLjAuMFxcclxcbic7XG5cbiAgLy8gQWRkIGE9cnRwbWFwIGxpbmVzIGZvciBlYWNoIGNvZGVjLiBBbHNvIGZtdHAgYW5kIHJ0Y3AtZmIuXG4gIGNhcHMuY29kZWNzLmZvckVhY2goZnVuY3Rpb24oY29kZWMpIHtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdHBNYXAoY29kZWMpO1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUZtdHAoY29kZWMpO1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0Y3BGYihjb2RlYyk7XG4gIH0pO1xuICB2YXIgbWF4cHRpbWUgPSAwO1xuICBjYXBzLmNvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgaWYgKGNvZGVjLm1heHB0aW1lID4gbWF4cHRpbWUpIHtcbiAgICAgIG1heHB0aW1lID0gY29kZWMubWF4cHRpbWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKG1heHB0aW1lID4gMCkge1xuICAgIHNkcCArPSAnYT1tYXhwdGltZTonICsgbWF4cHRpbWUgKyAnXFxyXFxuJztcbiAgfVxuICBzZHAgKz0gJ2E9cnRjcC1tdXhcXHJcXG4nO1xuXG4gIGNhcHMuaGVhZGVyRXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUV4dG1hcChleHRlbnNpb24pO1xuICB9KTtcbiAgLy8gRklYTUU6IHdyaXRlIGZlY01lY2hhbmlzbXMuXG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mXG4vLyBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnMuXG5TRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgZW5jb2RpbmdQYXJhbWV0ZXJzID0gW107XG4gIHZhciBkZXNjcmlwdGlvbiA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICB2YXIgaGFzUmVkID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdSRUQnKSAhPT0gLTE7XG4gIHZhciBoYXNVbHBmZWMgPSBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLmluZGV4T2YoJ1VMUEZFQycpICE9PSAtMTtcblxuICAvLyBmaWx0ZXIgYT1zc3JjOi4uLiBjbmFtZTosIGlnbm9yZSBQbGFuQi1tc2lkXG4gIHZhciBzc3JjcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICByZXR1cm4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSk7XG4gIH0pXG4gIC5maWx0ZXIoZnVuY3Rpb24ocGFydHMpIHtcbiAgICByZXR1cm4gcGFydHMuYXR0cmlidXRlID09PSAnY25hbWUnO1xuICB9KTtcbiAgdmFyIHByaW1hcnlTc3JjID0gc3NyY3MubGVuZ3RoID4gMCAmJiBzc3Jjc1swXS5zc3JjO1xuICB2YXIgc2Vjb25kYXJ5U3NyYztcblxuICB2YXIgZmxvd3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmMtZ3JvdXA6RklEJylcbiAgLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnICcpO1xuICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHBhcnRzLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQocGFydCwgMTApO1xuICAgIH0pO1xuICB9KTtcbiAgaWYgKGZsb3dzLmxlbmd0aCA+IDAgJiYgZmxvd3NbMF0ubGVuZ3RoID4gMSAmJiBmbG93c1swXVswXSA9PT0gcHJpbWFyeVNzcmMpIHtcbiAgICBzZWNvbmRhcnlTc3JjID0gZmxvd3NbMF1bMV07XG4gIH1cblxuICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjb2RlYykge1xuICAgIGlmIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdSVFgnICYmIGNvZGVjLnBhcmFtZXRlcnMuYXB0KSB7XG4gICAgICB2YXIgZW5jUGFyYW0gPSB7XG4gICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICBjb2RlY1BheWxvYWRUeXBlOiBwYXJzZUludChjb2RlYy5wYXJhbWV0ZXJzLmFwdCwgMTApLFxuICAgICAgICBydHg6IHtcbiAgICAgICAgICBzc3JjOiBzZWNvbmRhcnlTc3JjXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICBpZiAoaGFzUmVkKSB7XG4gICAgICAgIGVuY1BhcmFtID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbmNQYXJhbSkpO1xuICAgICAgICBlbmNQYXJhbS5mZWMgPSB7XG4gICAgICAgICAgc3NyYzogc2Vjb25kYXJ5U3NyYyxcbiAgICAgICAgICBtZWNoYW5pc206IGhhc1VscGZlYyA/ICdyZWQrdWxwZmVjJyA6ICdyZWQnXG4gICAgICAgIH07XG4gICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAoZW5jb2RpbmdQYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMCAmJiBwcmltYXJ5U3NyYykge1xuICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKHtcbiAgICAgIHNzcmM6IHByaW1hcnlTc3JjXG4gICAgfSk7XG4gIH1cblxuICAvLyB3ZSBzdXBwb3J0IGJvdGggYj1BUyBhbmQgYj1USUFTIGJ1dCBpbnRlcnByZXQgQVMgYXMgVElBUy5cbiAgdmFyIGJhbmR3aWR0aCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2I9Jyk7XG4gIGlmIChiYW5kd2lkdGgubGVuZ3RoKSB7XG4gICAgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPVRJQVM6JykgPT09IDApIHtcbiAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHIoNyksIDEwKTtcbiAgICB9IGVsc2UgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPUFTOicpID09PSAwKSB7XG4gICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyKDUpLCAxMCk7XG4gICAgfVxuICAgIGVuY29kaW5nUGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgcGFyYW1zLm1heEJpdHJhdGUgPSBiYW5kd2lkdGg7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nUGFyYW1ldGVycztcbn07XG5cbi8vIHBhcnNlcyBodHRwOi8vZHJhZnQub3J0Yy5vcmcvI3J0Y3J0Y3BwYXJhbWV0ZXJzKlxuU0RQVXRpbHMucGFyc2VSdGNwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgcnRjcFBhcmFtZXRlcnMgPSB7fTtcblxuICB2YXIgY25hbWU7XG4gIC8vIEdldHMgdGhlIGZpcnN0IFNTUkMuIE5vdGUgdGhhdCB3aXRoIFJUWCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZVxuICAvLyBTU1JDcy5cbiAgdmFyIHJlbW90ZVNzcmMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAgIC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICByZXR1cm4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iai5hdHRyaWJ1dGUgPT09ICdjbmFtZSc7XG4gICAgICB9KVswXTtcbiAgaWYgKHJlbW90ZVNzcmMpIHtcbiAgICBydGNwUGFyYW1ldGVycy5jbmFtZSA9IHJlbW90ZVNzcmMudmFsdWU7XG4gICAgcnRjcFBhcmFtZXRlcnMuc3NyYyA9IHJlbW90ZVNzcmMuc3NyYztcbiAgfVxuXG4gIC8vIEVkZ2UgdXNlcyB0aGUgY29tcG91bmQgYXR0cmlidXRlIGluc3RlYWQgb2YgcmVkdWNlZFNpemVcbiAgLy8gY29tcG91bmQgaXMgIXJlZHVjZWRTaXplXG4gIHZhciByc2l6ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1yc2l6ZScpO1xuICBydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSA9IHJzaXplLmxlbmd0aCA+IDA7XG4gIHJ0Y3BQYXJhbWV0ZXJzLmNvbXBvdW5kID0gcnNpemUubGVuZ3RoID09PSAwO1xuXG4gIC8vIHBhcnNlcyB0aGUgcnRjcC1tdXggYXR0ctGWYnV0ZS5cbiAgLy8gTm90ZSB0aGF0IEVkZ2UgZG9lcyBub3Qgc3VwcG9ydCB1bm11eGVkIFJUQ1AuXG4gIHZhciBtdXggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtbXV4Jyk7XG4gIHJ0Y3BQYXJhbWV0ZXJzLm11eCA9IG11eC5sZW5ndGggPiAwO1xuXG4gIHJldHVybiBydGNwUGFyYW1ldGVycztcbn07XG5cbi8vIHBhcnNlcyBlaXRoZXIgYT1tc2lkOiBvciBhPXNzcmM6Li4uIG1zaWQgbGluZXMgYW5kIHJldHVybnNcbi8vIHRoZSBpZCBvZiB0aGUgTWVkaWFTdHJlYW0gYW5kIE1lZGlhU3RyZWFtVHJhY2suXG5TRFBVdGlscy5wYXJzZU1zaWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIHBhcnRzO1xuICB2YXIgc3BlYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bXNpZDonKTtcbiAgaWYgKHNwZWMubGVuZ3RoID09PSAxKSB7XG4gICAgcGFydHMgPSBzcGVjWzBdLnN1YnN0cig3KS5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7c3RyZWFtOiBwYXJ0c1swXSwgdHJhY2s6IHBhcnRzWzFdfTtcbiAgfVxuICB2YXIgcGxhbkIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgcmV0dXJuIFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpO1xuICB9KVxuICAuZmlsdGVyKGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgcmV0dXJuIHBhcnRzLmF0dHJpYnV0ZSA9PT0gJ21zaWQnO1xuICB9KTtcbiAgaWYgKHBsYW5CLmxlbmd0aCA+IDApIHtcbiAgICBwYXJ0cyA9IHBsYW5CWzBdLnZhbHVlLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtzdHJlYW06IHBhcnRzWzBdLCB0cmFjazogcGFydHNbMV19O1xuICB9XG59O1xuXG5TRFBVdGlscy53cml0ZVNlc3Npb25Cb2lsZXJwbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBGSVhNRTogc2Vzcy1pZCBzaG91bGQgYmUgYW4gTlRQIHRpbWVzdGFtcC5cbiAgcmV0dXJuICd2PTBcXHJcXG4nICtcbiAgICAgICdvPXRoaXNpc2FkYXB0ZXJvcnRjIDgxNjk2Mzk5MTU2NDY5NDMxMzcgMiBJTiBJUDQgMTI3LjAuMC4xXFxyXFxuJyArXG4gICAgICAncz0tXFxyXFxuJyArXG4gICAgICAndD0wIDBcXHJcXG4nO1xufTtcblxuU0RQVXRpbHMud3JpdGVNZWRpYVNlY3Rpb24gPSBmdW5jdGlvbih0cmFuc2NlaXZlciwgY2FwcywgdHlwZSwgc3RyZWFtKSB7XG4gIHZhciBzZHAgPSBTRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uKHRyYW5zY2VpdmVyLmtpbmQsIGNhcHMpO1xuXG4gIC8vIE1hcCBJQ0UgcGFyYW1ldGVycyAodWZyYWcsIHB3ZCkgdG8gU0RQLlxuICBzZHAgKz0gU0RQVXRpbHMud3JpdGVJY2VQYXJhbWV0ZXJzKFxuICAgICAgdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIuZ2V0TG9jYWxQYXJhbWV0ZXJzKCkpO1xuXG4gIC8vIE1hcCBEVExTIHBhcmFtZXRlcnMgdG8gU0RQLlxuICBzZHAgKz0gU0RQVXRpbHMud3JpdGVEdGxzUGFyYW1ldGVycyhcbiAgICAgIHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQuZ2V0TG9jYWxQYXJhbWV0ZXJzKCksXG4gICAgICB0eXBlID09PSAnb2ZmZXInID8gJ2FjdHBhc3MnIDogJ2FjdGl2ZScpO1xuXG4gIHNkcCArPSAnYT1taWQ6JyArIHRyYW5zY2VpdmVyLm1pZCArICdcXHJcXG4nO1xuXG4gIGlmICh0cmFuc2NlaXZlci5kaXJlY3Rpb24pIHtcbiAgICBzZHAgKz0gJ2E9JyArIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiArICdcXHJcXG4nO1xuICB9IGVsc2UgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlciAmJiB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcikge1xuICAgIHNkcCArPSAnYT1zZW5kcmVjdlxcclxcbic7XG4gIH0gZWxzZSBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyKSB7XG4gICAgc2RwICs9ICdhPXNlbmRvbmx5XFxyXFxuJztcbiAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5ydHBSZWNlaXZlcikge1xuICAgIHNkcCArPSAnYT1yZWN2b25seVxcclxcbic7XG4gIH0gZWxzZSB7XG4gICAgc2RwICs9ICdhPWluYWN0aXZlXFxyXFxuJztcbiAgfVxuXG4gIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIpIHtcbiAgICAvLyBzcGVjLlxuICAgIHZhciBtc2lkID0gJ21zaWQ6JyArIHN0cmVhbS5pZCArICcgJyArXG4gICAgICAgIHRyYW5zY2VpdmVyLnJ0cFNlbmRlci50cmFjay5pZCArICdcXHJcXG4nO1xuICAgIHNkcCArPSAnYT0nICsgbXNpZDtcblxuICAgIC8vIGZvciBDaHJvbWUuXG4gICAgc2RwICs9ICdhPXNzcmM6JyArIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYyArXG4gICAgICAgICcgJyArIG1zaWQ7XG4gICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4KSB7XG4gICAgICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHguc3NyYyArXG4gICAgICAgICAgJyAnICsgbXNpZDtcbiAgICAgIHNkcCArPSAnYT1zc3JjLWdyb3VwOkZJRCAnICtcbiAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmMgKyAnICcgK1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4LnNzcmMgK1xuICAgICAgICAgICdcXHJcXG4nO1xuICAgIH1cbiAgfVxuICAvLyBGSVhNRTogdGhpcyBzaG91bGQgYmUgd3JpdHRlbiBieSB3cml0ZVJ0cERlc2NyaXB0aW9uLlxuICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjICtcbiAgICAgICcgY25hbWU6JyArIFNEUFV0aWxzLmxvY2FsQ05hbWUgKyAnXFxyXFxuJztcbiAgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlciAmJiB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eCkge1xuICAgIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eC5zc3JjICtcbiAgICAgICAgJyBjbmFtZTonICsgU0RQVXRpbHMubG9jYWxDTmFtZSArICdcXHJcXG4nO1xuICB9XG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBHZXRzIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGUgbWVkaWFTZWN0aW9uIG9yIHRoZSBzZXNzaW9ucGFydC5cblNEUFV0aWxzLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgLy8gTG9vayBmb3Igc2VuZHJlY3YsIHNlbmRvbmx5LCByZWN2b25seSwgaW5hY3RpdmUsIGRlZmF1bHQgdG8gc2VuZHJlY3YuXG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHN3aXRjaCAobGluZXNbaV0pIHtcbiAgICAgIGNhc2UgJ2E9c2VuZHJlY3YnOlxuICAgICAgY2FzZSAnYT1zZW5kb25seSc6XG4gICAgICBjYXNlICdhPXJlY3Zvbmx5JzpcbiAgICAgIGNhc2UgJ2E9aW5hY3RpdmUnOlxuICAgICAgICByZXR1cm4gbGluZXNbaV0uc3Vic3RyKDIpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRklYTUU6IFdoYXQgc2hvdWxkIGhhcHBlbiBoZXJlP1xuICAgIH1cbiAgfVxuICBpZiAoc2Vzc2lvbnBhcnQpIHtcbiAgICByZXR1cm4gU0RQVXRpbHMuZ2V0RGlyZWN0aW9uKHNlc3Npb25wYXJ0KTtcbiAgfVxuICByZXR1cm4gJ3NlbmRyZWN2Jztcbn07XG5cblNEUFV0aWxzLmdldEtpbmQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICB2YXIgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICByZXR1cm4gbWxpbmVbMF0uc3Vic3RyKDIpO1xufTtcblxuU0RQVXRpbHMuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICByZXR1cm4gbWVkaWFTZWN0aW9uLnNwbGl0KCcgJywgMilbMV0gPT09ICcwJztcbn07XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbm1vZHVsZS5leHBvcnRzID0gU0RQVXRpbHM7XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuLy8gcHJvdG90eXBlIGNsYXNzIGZvciBoYXNoIGZ1bmN0aW9uc1xuZnVuY3Rpb24gSGFzaCAoYmxvY2tTaXplLCBmaW5hbFNpemUpIHtcbiAgdGhpcy5fYmxvY2sgPSBCdWZmZXIuYWxsb2MoYmxvY2tTaXplKVxuICB0aGlzLl9maW5hbFNpemUgPSBmaW5hbFNpemVcbiAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXG4gIHRoaXMuX2xlbiA9IDBcbn1cblxuSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gZW5jIHx8ICd1dGY4J1xuICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmMpXG4gIH1cblxuICB2YXIgYmxvY2sgPSB0aGlzLl9ibG9ja1xuICB2YXIgYmxvY2tTaXplID0gdGhpcy5fYmxvY2tTaXplXG4gIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aFxuICB2YXIgYWNjdW0gPSB0aGlzLl9sZW5cblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBsZW5ndGg7KSB7XG4gICAgdmFyIGFzc2lnbmVkID0gYWNjdW0gJSBibG9ja1NpemVcbiAgICB2YXIgcmVtYWluZGVyID0gTWF0aC5taW4obGVuZ3RoIC0gb2Zmc2V0LCBibG9ja1NpemUgLSBhc3NpZ25lZClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtYWluZGVyOyBpKyspIHtcbiAgICAgIGJsb2NrW2Fzc2lnbmVkICsgaV0gPSBkYXRhW29mZnNldCArIGldXG4gICAgfVxuXG4gICAgYWNjdW0gKz0gcmVtYWluZGVyXG4gICAgb2Zmc2V0ICs9IHJlbWFpbmRlclxuXG4gICAgaWYgKChhY2N1bSAlIGJsb2NrU2l6ZSkgPT09IDApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShibG9jaylcbiAgICB9XG4gIH1cblxuICB0aGlzLl9sZW4gKz0gbGVuZ3RoXG4gIHJldHVybiB0aGlzXG59XG5cbkhhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdmFyIHJlbSA9IHRoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZVxuXG4gIHRoaXMuX2Jsb2NrW3JlbV0gPSAweDgwXG5cbiAgLy8gemVybyAocmVtICsgMSkgdHJhaWxpbmcgYml0cywgd2hlcmUgKHJlbSArIDEpIGlzIHRoZSBzbWFsbGVzdFxuICAvLyBub24tbmVnYXRpdmUgc29sdXRpb24gdG8gdGhlIGVxdWF0aW9uIChsZW5ndGggKyAxICsgKHJlbSArIDEpKSA9PT0gZmluYWxTaXplIG1vZCBibG9ja1NpemVcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCByZW0gKyAxKVxuXG4gIGlmIChyZW0gPj0gdGhpcy5fZmluYWxTaXplKSB7XG4gICAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMClcbiAgfVxuXG4gIHZhciBiaXRzID0gdGhpcy5fbGVuICogOFxuXG4gIC8vIHVpbnQzMlxuICBpZiAoYml0cyA8PSAweGZmZmZmZmZmKSB7XG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShiaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuXG4gIC8vIHVpbnQ2NFxuICB9IGVsc2Uge1xuICAgIHZhciBsb3dCaXRzID0gKGJpdHMgJiAweGZmZmZmZmZmKSA+Pj4gMFxuICAgIHZhciBoaWdoQml0cyA9IChiaXRzIC0gbG93Qml0cykgLyAweDEwMDAwMDAwMFxuXG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShoaWdoQml0cywgdGhpcy5fYmxvY2tTaXplIC0gOClcbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGxvd0JpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG4gIH1cblxuICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gIHZhciBoYXNoID0gdGhpcy5faGFzaCgpXG5cbiAgcmV0dXJuIGVuYyA/IGhhc2gudG9TdHJpbmcoZW5jKSA6IGhhc2hcbn1cblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3MnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hcbiIsInZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTSEEgKGFsZ29yaXRobSkge1xuICBhbGdvcml0aG0gPSBhbGdvcml0aG0udG9Mb3dlckNhc2UoKVxuXG4gIHZhciBBbGdvcml0aG0gPSBleHBvcnRzW2FsZ29yaXRobV1cbiAgaWYgKCFBbGdvcml0aG0pIHRocm93IG5ldyBFcnJvcihhbGdvcml0aG0gKyAnIGlzIG5vdCBzdXBwb3J0ZWQgKHdlIGFjY2VwdCBwdWxsIHJlcXVlc3RzKScpXG5cbiAgcmV0dXJuIG5ldyBBbGdvcml0aG0oKVxufVxuXG5leHBvcnRzLnNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbmV4cG9ydHMuc2hhMSA9IHJlcXVpcmUoJy4vc2hhMScpXG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhMjI0JylcbmV4cG9ydHMuc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxuZXhwb3J0cy5zaGEzODQgPSByZXF1aXJlKCcuL3NoYTM4NCcpXG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTAsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGRlcml2ZWQgZnJvbSBzaGExLmpzIG9mIHRoZSBzYW1lIHJlcG9zaXRvcnkuXG4gKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFNIQS0wIGFuZCBTSEEtMSBpcyBqdXN0IGEgYml0d2lzZSByb3RhdGUgbGVmdFxuICogb3BlcmF0aW9uIHdhcyBhZGRlZC5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEsIEhhc2gpXG5cblNoYS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsNSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDUpIHwgKG51bSA+Pj4gMjcpXG59XG5cbmZ1bmN0aW9uIHJvdGwzMCAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDMwKSB8IChudW0gPj4+IDIpXG59XG5cbmZ1bmN0aW9uIGZ0IChzLCBiLCBjLCBkKSB7XG4gIGlmIChzID09PSAwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZClcbiAgaWYgKHMgPT09IDIpIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZClcbiAgcmV0dXJuIGIgXiBjIF4gZFxufVxuXG5TaGEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGExICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGExLCBIYXNoKVxuXG5TaGExLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHJvdGwxIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMSkgfCAobnVtID4+PiAzMSlcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IHJvdGwxKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0pXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhMS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMVxuIiwiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTIyNCAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTIyNCwgU2hhMjU2KVxuXG5TaGEyMjQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2IgPSAweDM2N2NkNTA3XG4gIHRoaXMuX2MgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2QgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2UgPSAweGZmYzAwYjMxXG4gIHRoaXMuX2YgPSAweDY4NTgxNTExXG4gIHRoaXMuX2cgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2ggPSAweGJlZmE0ZmE0XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMjI0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjgpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyMjRcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXG4gIDB4Mzk1NkMyNUIsIDB4NTlGMTExRjEsIDB4OTIzRjgyQTQsIDB4QUIxQzVFRDUsXG4gIDB4RDgwN0FBOTgsIDB4MTI4MzVCMDEsIDB4MjQzMTg1QkUsIDB4NTUwQzdEQzMsXG4gIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXG4gIDB4RTQ5QjY5QzEsIDB4RUZCRTQ3ODYsIDB4MEZDMTlEQzYsIDB4MjQwQ0ExQ0MsXG4gIDB4MkRFOTJDNkYsIDB4NEE3NDg0QUEsIDB4NUNCMEE5REMsIDB4NzZGOTg4REEsXG4gIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXG4gIDB4QzZFMDBCRjMsIDB4RDVBNzkxNDcsIDB4MDZDQTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdCNzBBODUsIDB4MkUxQjIxMzgsIDB4NEQyQzZERkMsIDB4NTMzODBEMTMsXG4gIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXG4gIDB4QTJCRkU4QTEsIDB4QTgxQTY2NEIsIDB4QzI0QjhCNzAsIDB4Qzc2QzUxQTMsXG4gIDB4RDE5MkU4MTksIDB4RDY5OTA2MjQsIDB4RjQwRTM1ODUsIDB4MTA2QUEwNzAsXG4gIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXG4gIDB4MzkxQzBDQjMsIDB4NEVEOEFBNEEsIDB4NUI5Q0NBNEYsIDB4NjgyRTZGRjMsXG4gIDB4NzQ4RjgyRUUsIDB4NzhBNTYzNkYsIDB4ODRDODc4MTQsIDB4OENDNzAyMDgsXG4gIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTI1NiAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTI1NiwgSGFzaClcblxuU2hhMjU2LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2YTA5ZTY2N1xuICB0aGlzLl9iID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kID0gMHhhNTRmZjUzYVxuICB0aGlzLl9lID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9mID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9nID0gMHgxZjgzZDlhYlxuICB0aGlzLl9oID0gMHg1YmUwY2QxOVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGNoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDIgfCB4IDw8IDMwKSBeICh4ID4+PiAxMyB8IHggPDwgMTkpIF4gKHggPj4+IDIyIHwgeCA8PCAxMClcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNiB8IHggPDwgMjYpIF4gKHggPj4+IDExIHwgeCA8PCAyMSkgXiAoeCA+Pj4gMjUgfCB4IDw8IDcpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDcgfCB4IDw8IDI1KSBeICh4ID4+PiAxOCB8IHggPDwgMTQpIF4gKHggPj4+IDMpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDE3IHwgeCA8PCAxNSkgXiAoeCA+Pj4gMTkgfCB4IDw8IDEzKSBeICh4ID4+PiAxMClcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG4gIHZhciBmID0gdGhpcy5fZiB8IDBcbiAgdmFyIGcgPSB0aGlzLl9nIHwgMFxuICB2YXIgaCA9IHRoaXMuX2ggfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA2NDsgKytpKSBXW2ldID0gKGdhbW1hMShXW2kgLSAyXSkgKyBXW2kgLSA3XSArIGdhbW1hMChXW2kgLSAxNV0pICsgV1tpIC0gMTZdKSB8IDBcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDY0OyArK2opIHtcbiAgICB2YXIgVDEgPSAoaCArIHNpZ21hMShlKSArIGNoKGUsIGYsIGcpICsgS1tqXSArIFdbal0pIHwgMFxuICAgIHZhciBUMiA9IChzaWdtYTAoYSkgKyBtYWooYSwgYiwgYykpIHwgMFxuXG4gICAgaCA9IGdcbiAgICBnID0gZlxuICAgIGYgPSBlXG4gICAgZSA9IChkICsgVDEpIHwgMFxuICAgIGQgPSBjXG4gICAgYyA9IGJcbiAgICBiID0gYVxuICAgIGEgPSAoVDEgKyBUMikgfCAwXG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG4gIHRoaXMuX2YgPSAoZiArIHRoaXMuX2YpIHwgMFxuICB0aGlzLl9nID0gKGcgKyB0aGlzLl9nKSB8IDBcbiAgdGhpcy5faCA9IChoICsgdGhpcy5faCkgfCAwXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDMyKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9oLCAyOClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTI1NlxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNIQTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTM4NCAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGEzODQsIFNIQTUxMilcblxuU2hhMzg0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4Y2JiYjlkNWRcbiAgdGhpcy5fYmggPSAweDYyOWEyOTJhXG4gIHRoaXMuX2NoID0gMHg5MTU5MDE1YVxuICB0aGlzLl9kaCA9IDB4MTUyZmVjZDhcbiAgdGhpcy5fZWggPSAweDY3MzMyNjY3XG4gIHRoaXMuX2ZoID0gMHg4ZWI0NGE4N1xuICB0aGlzLl9naCA9IDB4ZGIwYzJlMGRcbiAgdGhpcy5faGggPSAweDQ3YjU0ODFkXG5cbiAgdGhpcy5fYWwgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2JsID0gMHgzNjdjZDUwN1xuICB0aGlzLl9jbCA9IDB4MzA3MGRkMTdcbiAgdGhpcy5fZGwgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2VsID0gMHhmZmMwMGIzMVxuICB0aGlzLl9mbCA9IDB4Njg1ODE1MTFcbiAgdGhpcy5fZ2wgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2hsID0gMHhiZWZhNGZhNFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTM4NC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQ4KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYWgsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYmgsIHRoaXMuX2JsLCA4KVxuICB3cml0ZUludDY0QkUodGhpcy5fY2gsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2RoLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9laCwgdGhpcy5fZWwsIDMyKVxuICB3cml0ZUludDY0QkUodGhpcy5fZmgsIHRoaXMuX2ZsLCA0MClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTM4NFxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDE2MClcblxuZnVuY3Rpb24gU2hhNTEyICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgMTI4LCAxMTIpXG59XG5cbmluaGVyaXRzKFNoYTUxMiwgSGFzaClcblxuU2hhNTEyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYmggPSAweGJiNjdhZTg1XG4gIHRoaXMuX2NoID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kaCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZWggPSAweDUxMGU1MjdmXG4gIHRoaXMuX2ZoID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9naCA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faGggPSAweDViZTBjZDE5XG5cbiAgdGhpcy5fYWwgPSAweGYzYmNjOTA4XG4gIHRoaXMuX2JsID0gMHg4NGNhYTczYlxuICB0aGlzLl9jbCA9IDB4ZmU5NGY4MmJcbiAgdGhpcy5fZGwgPSAweDVmMWQzNmYxXG4gIHRoaXMuX2VsID0gMHhhZGU2ODJkMVxuICB0aGlzLl9mbCA9IDB4MmIzZTZjMWZcbiAgdGhpcy5fZ2wgPSAweGZiNDFiZDZiXG4gIHRoaXMuX2hsID0gMHgxMzdlMjE3OVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIENoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAyOCB8IHhsIDw8IDQpIF4gKHhsID4+PiAyIHwgeCA8PCAzMCkgXiAoeGwgPj4+IDcgfCB4IDw8IDI1KVxufVxuXG5mdW5jdGlvbiBzaWdtYTEgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTQgfCB4bCA8PCAxOCkgXiAoeCA+Pj4gMTggfCB4bCA8PCAxNCkgXiAoeGwgPj4+IDkgfCB4IDw8IDIzKVxufVxuXG5mdW5jdGlvbiBHYW1tYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMGwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcgfCB4bCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gR2FtbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNilcbn1cblxuZnVuY3Rpb24gR2FtbWExbCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYgfCB4bCA8PCAyNilcbn1cblxuZnVuY3Rpb24gZ2V0Q2FycnkgKGEsIGIpIHtcbiAgcmV0dXJuIChhID4+PiAwKSA8IChiID4+PiAwKSA/IDEgOiAwXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhaCA9IHRoaXMuX2FoIHwgMFxuICB2YXIgYmggPSB0aGlzLl9iaCB8IDBcbiAgdmFyIGNoID0gdGhpcy5fY2ggfCAwXG4gIHZhciBkaCA9IHRoaXMuX2RoIHwgMFxuICB2YXIgZWggPSB0aGlzLl9laCB8IDBcbiAgdmFyIGZoID0gdGhpcy5fZmggfCAwXG4gIHZhciBnaCA9IHRoaXMuX2doIHwgMFxuICB2YXIgaGggPSB0aGlzLl9oaCB8IDBcblxuICB2YXIgYWwgPSB0aGlzLl9hbCB8IDBcbiAgdmFyIGJsID0gdGhpcy5fYmwgfCAwXG4gIHZhciBjbCA9IHRoaXMuX2NsIHwgMFxuICB2YXIgZGwgPSB0aGlzLl9kbCB8IDBcbiAgdmFyIGVsID0gdGhpcy5fZWwgfCAwXG4gIHZhciBmbCA9IHRoaXMuX2ZsIHwgMFxuICB2YXIgZ2wgPSB0aGlzLl9nbCB8IDBcbiAgdmFyIGhsID0gdGhpcy5faGwgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSArPSAyKSB7XG4gICAgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gICAgV1tpICsgMV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0ICsgNClcbiAgfVxuICBmb3IgKDsgaSA8IDE2MDsgaSArPSAyKSB7XG4gICAgdmFyIHhoID0gV1tpIC0gMTUgKiAyXVxuICAgIHZhciB4bCA9IFdbaSAtIDE1ICogMiArIDFdXG4gICAgdmFyIGdhbW1hMCA9IEdhbW1hMCh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMGwgPSBHYW1tYTBsKHhsLCB4aClcblxuICAgIHhoID0gV1tpIC0gMiAqIDJdXG4gICAgeGwgPSBXW2kgLSAyICogMiArIDFdXG4gICAgdmFyIGdhbW1hMSA9IEdhbW1hMSh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMWwgPSBHYW1tYTFsKHhsLCB4aClcblxuICAgIC8vIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XVxuICAgIHZhciBXaTdoID0gV1tpIC0gNyAqIDJdXG4gICAgdmFyIFdpN2wgPSBXW2kgLSA3ICogMiArIDFdXG5cbiAgICB2YXIgV2kxNmggPSBXW2kgLSAxNiAqIDJdXG4gICAgdmFyIFdpMTZsID0gV1tpIC0gMTYgKiAyICsgMV1cblxuICAgIHZhciBXaWwgPSAoZ2FtbWEwbCArIFdpN2wpIHwgMFxuICAgIHZhciBXaWggPSAoZ2FtbWEwICsgV2k3aCArIGdldENhcnJ5KFdpbCwgZ2FtbWEwbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBnYW1tYTFsKSB8IDBcbiAgICBXaWggPSAoV2loICsgZ2FtbWExICsgZ2V0Q2FycnkoV2lsLCBnYW1tYTFsKSkgfCAwXG4gICAgV2lsID0gKFdpbCArIFdpMTZsKSB8IDBcbiAgICBXaWggPSAoV2loICsgV2kxNmggKyBnZXRDYXJyeShXaWwsIFdpMTZsKSkgfCAwXG5cbiAgICBXW2ldID0gV2loXG4gICAgV1tpICsgMV0gPSBXaWxcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgMTYwOyBqICs9IDIpIHtcbiAgICBXaWggPSBXW2pdXG4gICAgV2lsID0gV1tqICsgMV1cblxuICAgIHZhciBtYWpoID0gbWFqKGFoLCBiaCwgY2gpXG4gICAgdmFyIG1hamwgPSBtYWooYWwsIGJsLCBjbClcblxuICAgIHZhciBzaWdtYTBoID0gc2lnbWEwKGFoLCBhbClcbiAgICB2YXIgc2lnbWEwbCA9IHNpZ21hMChhbCwgYWgpXG4gICAgdmFyIHNpZ21hMWggPSBzaWdtYTEoZWgsIGVsKVxuICAgIHZhciBzaWdtYTFsID0gc2lnbWExKGVsLCBlaClcblxuICAgIC8vIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tqXSArIFdbal1cbiAgICB2YXIgS2loID0gS1tqXVxuICAgIHZhciBLaWwgPSBLW2ogKyAxXVxuXG4gICAgdmFyIGNoaCA9IENoKGVoLCBmaCwgZ2gpXG4gICAgdmFyIGNobCA9IENoKGVsLCBmbCwgZ2wpXG5cbiAgICB2YXIgdDFsID0gKGhsICsgc2lnbWExbCkgfCAwXG4gICAgdmFyIHQxaCA9IChoaCArIHNpZ21hMWggKyBnZXRDYXJyeSh0MWwsIGhsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIGNobCkgfCAwXG4gICAgdDFoID0gKHQxaCArIGNoaCArIGdldENhcnJ5KHQxbCwgY2hsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIEtpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIEtpaCArIGdldENhcnJ5KHQxbCwgS2lsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIFdpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIFdpaCArIGdldENhcnJ5KHQxbCwgV2lsKSkgfCAwXG5cbiAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuICAgIHZhciB0MmwgPSAoc2lnbWEwbCArIG1hamwpIHwgMFxuICAgIHZhciB0MmggPSAoc2lnbWEwaCArIG1hamggKyBnZXRDYXJyeSh0MmwsIHNpZ21hMGwpKSB8IDBcblxuICAgIGhoID0gZ2hcbiAgICBobCA9IGdsXG4gICAgZ2ggPSBmaFxuICAgIGdsID0gZmxcbiAgICBmaCA9IGVoXG4gICAgZmwgPSBlbFxuICAgIGVsID0gKGRsICsgdDFsKSB8IDBcbiAgICBlaCA9IChkaCArIHQxaCArIGdldENhcnJ5KGVsLCBkbCkpIHwgMFxuICAgIGRoID0gY2hcbiAgICBkbCA9IGNsXG4gICAgY2ggPSBiaFxuICAgIGNsID0gYmxcbiAgICBiaCA9IGFoXG4gICAgYmwgPSBhbFxuICAgIGFsID0gKHQxbCArIHQybCkgfCAwXG4gICAgYWggPSAodDFoICsgdDJoICsgZ2V0Q2FycnkoYWwsIHQxbCkpIHwgMFxuICB9XG5cbiAgdGhpcy5fYWwgPSAodGhpcy5fYWwgKyBhbCkgfCAwXG4gIHRoaXMuX2JsID0gKHRoaXMuX2JsICsgYmwpIHwgMFxuICB0aGlzLl9jbCA9ICh0aGlzLl9jbCArIGNsKSB8IDBcbiAgdGhpcy5fZGwgPSAodGhpcy5fZGwgKyBkbCkgfCAwXG4gIHRoaXMuX2VsID0gKHRoaXMuX2VsICsgZWwpIHwgMFxuICB0aGlzLl9mbCA9ICh0aGlzLl9mbCArIGZsKSB8IDBcbiAgdGhpcy5fZ2wgPSAodGhpcy5fZ2wgKyBnbCkgfCAwXG4gIHRoaXMuX2hsID0gKHRoaXMuX2hsICsgaGwpIHwgMFxuXG4gIHRoaXMuX2FoID0gKHRoaXMuX2FoICsgYWggKyBnZXRDYXJyeSh0aGlzLl9hbCwgYWwpKSB8IDBcbiAgdGhpcy5fYmggPSAodGhpcy5fYmggKyBiaCArIGdldENhcnJ5KHRoaXMuX2JsLCBibCkpIHwgMFxuICB0aGlzLl9jaCA9ICh0aGlzLl9jaCArIGNoICsgZ2V0Q2FycnkodGhpcy5fY2wsIGNsKSkgfCAwXG4gIHRoaXMuX2RoID0gKHRoaXMuX2RoICsgZGggKyBnZXRDYXJyeSh0aGlzLl9kbCwgZGwpKSB8IDBcbiAgdGhpcy5fZWggPSAodGhpcy5fZWggKyBlaCArIGdldENhcnJ5KHRoaXMuX2VsLCBlbCkpIHwgMFxuICB0aGlzLl9maCA9ICh0aGlzLl9maCArIGZoICsgZ2V0Q2FycnkodGhpcy5fZmwsIGZsKSkgfCAwXG4gIHRoaXMuX2doID0gKHRoaXMuX2doICsgZ2ggKyBnZXRDYXJyeSh0aGlzLl9nbCwgZ2wpKSB8IDBcbiAgdGhpcy5faGggPSAodGhpcy5faGggKyBoaCArIGdldENhcnJ5KHRoaXMuX2hsLCBobCkpIHwgMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg2NClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9naCwgdGhpcy5fZ2wsIDQ4KVxuICB3cml0ZUludDY0QkUodGhpcy5faGgsIHRoaXMuX2hsLCA1NilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTUxMlxuIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IFNhbXVlbCBvbiA2LzQvMjAxNi5cbiAqIFNpbXBsZSB3cmFwcGVyIGZ1bmN0aW9ucyB0byBwcm9kdWNlIHNob3J0ZXIgVVVJRHMgZm9yIGNvb2tpZXMsIG1heWJlIGV2ZXJ5dGhpbmc/XG4gKi9cblxuY29uc3QgeyB2NDogdXVpZHY0IH0gPSByZXF1aXJlKCd1dWlkJyk7XG5jb25zdCBhbnlCYXNlID0gcmVxdWlyZSgnYW55LWJhc2UnKTtcblxuY29uc3QgZmxpY2tyQmFzZTU4ID0gJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonO1xuY29uc3QgY29va2llQmFzZTkwID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiEjJCUmJygpKistLi86PD0+P0BbXV5fYHt8fX5cIjtcblxuY29uc3QgYmFzZU9wdGlvbnMgPSB7XG4gIGNvbnNpc3RlbnRMZW5ndGg6IHRydWUsXG59O1xuXG4vLyBBIGRlZmF1bHQgZ2VuZXJhdG9yLCBpbnN0YW50aWF0ZWQgb25seSBpZiB1c2VkLlxubGV0IHRvRmxpY2tyO1xuXG4vKipcbiAqIFRha2VzIGEgVVVJRCwgc3RyaXBzIHRoZSBkYXNoZXMsIGFuZCB0cmFuc2xhdGVzLlxuICogQHBhcmFtIHtzdHJpbmd9IGxvbmdJZFxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpfSB0cmFuc2xhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhZGRpbmdQYXJhbXNdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBzaG9ydGVuVVVJRCA9IChsb25nSWQsIHRyYW5zbGF0b3IsIHBhZGRpbmdQYXJhbXMpID0+IHtcbiAgY29uc3QgdHJhbnNsYXRlZCA9IHRyYW5zbGF0b3IobG9uZ0lkLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCAnJykpO1xuXG4gIGlmICghcGFkZGluZ1BhcmFtcyB8fCAhcGFkZGluZ1BhcmFtcy5jb25zaXN0ZW50TGVuZ3RoKSByZXR1cm4gdHJhbnNsYXRlZDtcblxuICByZXR1cm4gdHJhbnNsYXRlZC5wYWRTdGFydChcbiAgICBwYWRkaW5nUGFyYW1zLnNob3J0SWRMZW5ndGgsXG4gICAgcGFkZGluZ1BhcmFtcy5wYWRkaW5nQ2hhcixcbiAgKTtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlIGJhY2sgdG8gaGV4IGFuZCB0dXJuIGJhY2sgaW50byBVVUlEIGZvcm1hdCwgd2l0aCBkYXNoZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydElkXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyl9IHRyYW5zbGF0b3JcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGVubGFyZ2VVVUlEID0gKHNob3J0SWQsIHRyYW5zbGF0b3IpID0+IHtcbiAgY29uc3QgdXUxID0gdHJhbnNsYXRvcihzaG9ydElkKS5wYWRTdGFydCgzMiwgJzAnKTtcblxuICAvLyBKb2luIHRoZSB6ZXJvIHBhZGRpbmcgYW5kIHRoZSBVVUlEIGFuZCB0aGVuIHNsaWNlIGl0IHVwIHdpdGggbWF0Y2hcbiAgY29uc3QgbSA9IHV1MS5tYXRjaCgvKFxcd3s4fSkoXFx3ezR9KShcXHd7NH0pKFxcd3s0fSkoXFx3ezEyfSkvKTtcblxuICAvLyBBY2N1bXVsYXRlIHRoZSBtYXRjaGVzIGFuZCBqb2luIHRoZW0uXG4gIHJldHVybiBbbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XV0uam9pbignLScpO1xufTtcblxuLy8gQ2FsY3VsYXRlIGxlbmd0aCBmb3IgdGhlIHNob3J0ZW5lZCBJRFxuY29uc3QgZ2V0U2hvcnRJZExlbmd0aCA9IChhbHBoYWJldExlbmd0aCkgPT4gKFxuICBNYXRoLmNlaWwoTWF0aC5sb2coMiAqKiAxMjgpIC8gTWF0aC5sb2coYWxwaGFiZXRMZW5ndGgpKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gKCgpID0+IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b0FscGhhYmV0IC0gRGVmYXVsdHMgdG8gZmxpY2tyQmFzZTU4IGlmIG5vdCBwcm92aWRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqXG4gICAqIEByZXR1cm5zIHt7bmV3OiAoZnVuY3Rpb24oKSksXG4gICAqICB1dWlkOiAoZnVuY3Rpb24oKSksXG4gICAqICBmcm9tVVVJRDogKGZ1bmN0aW9uKHN0cmluZykpLFxuICAgKiAgdG9VVUlEOiAoZnVuY3Rpb24oc3RyaW5nKSksXG4gICAqICBhbHBoYWJldDogKHN0cmluZyl9fVxuICAgKi9cbiAgY29uc3QgbWFrZUNvbnZlcnRvciA9ICh0b0FscGhhYmV0LCBvcHRpb25zKSA9PiB7XG4gICAgLy8gRGVmYXVsdCB0byBGbGlja3IgNThcbiAgICBjb25zdCB1c2VBbHBoYWJldCA9IHRvQWxwaGFiZXQgfHwgZmxpY2tyQmFzZTU4O1xuXG4gICAgLy8gRGVmYXVsdCB0byBiYXNlT3B0aW9uc1xuICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9ucyA9IHsgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcblxuICAgIC8vIENoZWNrIGFscGhhYmV0IGZvciBkdXBsaWNhdGUgZW50cmllc1xuICAgIGlmIChbLi4ubmV3IFNldChBcnJheS5mcm9tKHVzZUFscGhhYmV0KSldLmxlbmd0aCAhPT0gdXNlQWxwaGFiZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBBbHBoYWJldCBoYXMgZHVwbGljYXRlIGNoYXJhY3RlcnMgcmVzdWx0aW5nIGluIHVucmVsaWFibGUgcmVzdWx0cycpO1xuICAgIH1cblxuICAgIGNvbnN0IHNob3J0SWRMZW5ndGggPSBnZXRTaG9ydElkTGVuZ3RoKHVzZUFscGhhYmV0Lmxlbmd0aCk7XG5cbiAgICAvLyBQYWRkaW5nIFBhcmFtc1xuICAgIGNvbnN0IHBhZGRpbmdQYXJhbXMgPSB7XG4gICAgICBzaG9ydElkTGVuZ3RoLFxuICAgICAgY29uc2lzdGVudExlbmd0aDogc2VsZWN0ZWRPcHRpb25zLmNvbnNpc3RlbnRMZW5ndGgsXG4gICAgICBwYWRkaW5nQ2hhcjogdXNlQWxwaGFiZXRbMF0sXG4gICAgfTtcblxuICAgIC8vIFVVSURzIGFyZSBpbiBoZXgsIHNvIHdlIHRyYW5zbGF0ZSB0byBhbmQgZnJvbS5cbiAgICBjb25zdCBmcm9tSGV4ID0gYW55QmFzZShhbnlCYXNlLkhFWCwgdXNlQWxwaGFiZXQpO1xuICAgIGNvbnN0IHRvSGV4ID0gYW55QmFzZSh1c2VBbHBoYWJldCwgYW55QmFzZS5IRVgpO1xuICAgIGNvbnN0IGdlbmVyYXRlID0gKCkgPT4gc2hvcnRlblVVSUQodXVpZHY0KCksIGZyb21IZXgsIHBhZGRpbmdQYXJhbXMpO1xuXG4gICAgY29uc3QgdHJhbnNsYXRvciA9IHtcbiAgICAgIG5ldzogZ2VuZXJhdGUsXG4gICAgICBnZW5lcmF0ZSxcbiAgICAgIHV1aWQ6IHV1aWR2NCxcbiAgICAgIGZyb21VVUlEOiAodXVpZCkgPT4gc2hvcnRlblVVSUQodXVpZCwgZnJvbUhleCwgcGFkZGluZ1BhcmFtcyksXG4gICAgICB0b1VVSUQ6IChzaG9ydFV1aWQpID0+IGVubGFyZ2VVVUlEKHNob3J0VXVpZCwgdG9IZXgpLFxuICAgICAgYWxwaGFiZXQ6IHVzZUFscGhhYmV0LFxuICAgICAgbWF4TGVuZ3RoOiBzaG9ydElkTGVuZ3RoLFxuICAgIH07XG5cbiAgICBPYmplY3QuZnJlZXplKHRyYW5zbGF0b3IpO1xuXG4gICAgcmV0dXJuIHRyYW5zbGF0b3I7XG4gIH07XG5cbiAgLy8gRXhwb3NlIHRoZSBjb25zdGFudHMgZm9yIG90aGVyIHB1cnBvc2VzLlxuICBtYWtlQ29udmVydG9yLmNvbnN0YW50cyA9IHtcbiAgICBmbGlja3JCYXNlNTgsXG4gICAgY29va2llQmFzZTkwLFxuICB9O1xuXG4gIC8vIEV4cG9zZSB0aGUgZ2VuZXJpYyB2NCBVVUlEIGdlbmVyYXRvciBmb3IgY29udmVuaWVuY2VcbiAgbWFrZUNvbnZlcnRvci51dWlkID0gdXVpZHY0O1xuXG4gIC8vIFByb3ZpZGUgYSBnZW5lcmljIGdlbmVyYXRvclxuICBtYWtlQ29udmVydG9yLmdlbmVyYXRlID0gKCkgPT4ge1xuICAgIGlmICghdG9GbGlja3IpIHtcbiAgICAgIC8vIEdlbmVyYXRlIG9uIGZpcnN0IHVzZTtcbiAgICAgIHRvRmxpY2tyID0gbWFrZUNvbnZlcnRvcihmbGlja3JCYXNlNTgpLmdlbmVyYXRlO1xuICAgIH1cbiAgICByZXR1cm4gdG9GbGlja3IoKTtcbiAgfTtcblxuICByZXR1cm4gbWFrZUNvbnZlcnRvcjtcbn0pKCk7XG4iLCJ2YXIgZXNzID0gcmVxdWlyZSgnZXZlbnQtc291cmNlLXN0cmVhbScpXG52YXIgbmV0cyA9IHJlcXVpcmUoJ25ldHMnKVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgYXBwKSB7XG4gIGlmICghdXJsKSB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25hbGh1YiB1cmwgcmVxdWlyZWQnKVxuICBpZiAoIWFwcCkgdGhyb3cgbmV3IEVycm9yKCdhcHAgbmFtZSByZXF1aXJlZCBhcyAybmQgYXJndW1lbnQnKVxuICB2YXIgdGhhdCA9IHt9XG5cbiAgaWYgKHVybC5pbmRleE9mKCc6Ly8nKSA9PT0gLTEpIHVybCA9ICdodHRwOi8vJyArIHVybFxuXG4gIHRoYXQuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICByZXR1cm4gZXNzKHVybCArICcvdjEvJyArIGFwcCArICcvJyArIGNoYW5uZWwsIHtqc29uOiB0cnVlfSlcbiAgfVxuXG4gIHRoYXQuYnJvYWRjYXN0ID0gZnVuY3Rpb24gKGNoYW5uZWwsIG1lc3NhZ2UsIGNiKSB7XG4gICAgaWYgKCFjYikgY2IgPSBub29wXG4gICAgbmV0cyh7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGpzb246IG1lc3NhZ2UsXG4gICAgICB1cmw6IHVybCArICcvdjEvJyArIGFwcCArICcvJyArIGNoYW5uZWxcbiAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBpZiAocmVzLnN0YXR1c0NvZGUgIT09IDIwMCkgcmV0dXJuIGNiKG5ldyBFcnJvcignQmFkIHN0YXR1czogJyArIHJlcy5zdGF0dXNDb2RlKSlcbiAgICAgIGNiKClcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cbiIsInZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVybCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIHZhciBlcyA9IG5ldyBFdmVudFNvdXJjZSh1cmwpXG4gIHZhciBycyA9IG5ldyBzdHJlYW0uUmVhZGFibGUoe29iamVjdE1vZGU6dHJ1ZX0pXG5cbiAgdmFyIGpzb24gPSAhIW9wdHMuanNvblxuICB2YXIgZGVjb2RlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGpzb24pIHJldHVybiBKU09OLnBhcnNlKGRhdGEpXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIHJzLl9yZWFkID0gZnVuY3Rpb24oKSB7fVxuXG4gIGVzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBycy5wdXNoKGRlY29kZShlLmRhdGEpKVxuICB9XG5cbiAgZXMub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChycy5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoKSBycy5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxuXG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZVxuICBycy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuICAgIGVzLmNsb3NlKClcbiAgICBwYXJzZS5lbWl0KCdjbG9zZScpXG4gIH1cblxuICByZXR1cm4gcnNcbn0iLCJ2YXIgcmVxID0gcmVxdWlyZSgncmVxdWVzdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gTmV0c1xuXG5mdW5jdGlvbiBOZXRzIChvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSBvcHRzID0geyB1cmk6IG9wdHMgfVxuXG4gIC8vIGluIG5vZGUsIGlmIGVuY29kaW5nID09PSBudWxsIHRoZW4gcmVzcG9uc2Ugd2lsbCBiZSBhIEJ1ZmZlci4gd2Ugd2FudCB0aGlzIHRvIGJlIHRoZSBkZWZhdWx0XG4gIGlmICghb3B0cy5oYXNPd25Qcm9wZXJ0eSgnZW5jb2RpbmcnKSkgb3B0cy5lbmNvZGluZyA9IG51bGxcblxuICAvLyBpbiBicm93c2VyLCB3ZSBzaG91bGQgYnkgZGVmYXVsdCBjb252ZXJ0IHRoZSBhcnJheWJ1ZmZlciBpbnRvIGEgQnVmZmVyXG4gIGlmIChwcm9jZXNzLmJyb3dzZXIgJiYgIW9wdHMuaGFzT3duUHJvcGVydHkoJ2pzb24nKSAmJiBvcHRzLmVuY29kaW5nID09PSBudWxsKSB7XG4gICAgb3B0cy5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgdmFyIG9yaWdpbmFsQ2IgPSBjYlxuICAgIGNiID0gYnVmZmVyaWZ5XG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJpZnkgKGVyciwgcmVzcCwgYm9keSkge1xuICAgIGlmIChib2R5KSBib2R5ID0gbmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShib2R5KSlcbiAgICBvcmlnaW5hbENiKGVyciwgcmVzcCwgYm9keSlcbiAgfVxuXG4gIHJldHVybiByZXEob3B0cywgY2IpXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB3aW5kb3cgPSByZXF1aXJlKFwiZ2xvYmFsL3dpbmRvd1wiKVxudmFyIG9uY2UgPSByZXF1aXJlKFwib25jZVwiKVxudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoXCJwYXJzZS1oZWFkZXJzXCIpXG5cblxudmFyIFhIUiA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCB8fCBub29wXG52YXIgWERSID0gXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiAobmV3IFhIUigpKSA/IFhIUiA6IHdpbmRvdy5YRG9tYWluUmVxdWVzdFxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVhIUlxuXG5mdW5jdGlvbiBjcmVhdGVYSFIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIGxvYWRGdW5jKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICAgIC8vIENocm9tZSB3aXRoIHJlcXVlc3RUeXBlPWJsb2IgdGhyb3dzIGVycm9ycyBhcnJvdW5kIHdoZW4gZXZlbiB0ZXN0aW5nIGFjY2VzcyB0byByZXNwb25zZVRleHRcbiAgICAgICAgdmFyIGJvZHkgPSB1bmRlZmluZWRcblxuICAgICAgICBpZiAoeGhyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlXG4gICAgICAgIH0gZWxzZSBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJ0ZXh0XCIgfHwgIXhoci5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VUZXh0IHx8IHhoci5yZXNwb25zZVhNTFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSnNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2R5XG4gICAgfVxuICAgIFxuICAgIHZhciBmYWlsdXJlUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDAsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXG4gICAgICAgICAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgICAgICAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZXJyb3JGdW5jKGV2dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKVxuICAgICAgICBpZighKGV2dCBpbnN0YW5jZW9mIEVycm9yKSl7XG4gICAgICAgICAgICBldnQgPSBuZXcgRXJyb3IoXCJcIiArIChldnQgfHwgXCJ1bmtub3duXCIpIClcbiAgICAgICAgfVxuICAgICAgICBldnQuc3RhdHVzQ29kZSA9IDBcbiAgICAgICAgY2FsbGJhY2soZXZ0LCBmYWlsdXJlUmVzcG9uc2UpXG4gICAgfVxuXG4gICAgLy8gd2lsbCBsb2FkIHRoZSBkYXRhICYgcHJvY2VzcyB0aGUgcmVzcG9uc2UgaW4gYSBzcGVjaWFsIHJlc3BvbnNlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGxvYWRGdW5jKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRpbWVyKVxuICAgICAgICBcbiAgICAgICAgdmFyIHN0YXR1cyA9ICh4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cylcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gZmFpbHVyZVJlc3BvbnNlXG4gICAgICAgIHZhciBlcnIgPSBudWxsXG4gICAgICAgIFxuICAgICAgICBpZiAoc3RhdHVzICE9PSAwKXtcbiAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGdldEJvZHkoKSxcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXG4gICAgICAgICAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKXsgLy9yZW1lbWJlciB4aHIgY2FuIGluIGZhY3QgYmUgWERSIGZvciBDT1JTIGluIElFXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoXCJJbnRlcm5hbCBYTUxIdHRwUmVxdWVzdCBFcnJvclwiKVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIHJlc3BvbnNlLmJvZHkpXG4gICAgICAgIFxuICAgIH1cbiAgICBcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgdXJpOiBvcHRpb25zIH1cbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIGlmKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIilcbiAgICB9XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKVxuXG4gICAgdmFyIHhociA9IG9wdGlvbnMueGhyIHx8IG51bGxcblxuICAgIGlmICgheGhyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvcnMgfHwgb3B0aW9ucy51c2VYRFIpIHtcbiAgICAgICAgICAgIHhociA9IG5ldyBYRFIoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHhociA9IG5ldyBYSFIoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleVxuICAgIHZhciB1cmkgPSB4aHIudXJsID0gb3B0aW9ucy51cmkgfHwgb3B0aW9ucy51cmxcbiAgICB2YXIgbWV0aG9kID0geGhyLm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCJcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBvcHRpb25zLmRhdGFcbiAgICB2YXIgaGVhZGVycyA9IHhoci5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9XG4gICAgdmFyIHN5bmMgPSAhIW9wdGlvbnMuc3luY1xuICAgIHZhciBpc0pzb24gPSBmYWxzZVxuICAgIHZhciB0aW1lb3V0VGltZXJcblxuICAgIGlmIChcImpzb25cIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlzSnNvbiA9IHRydWVcbiAgICAgICAgaGVhZGVyc1tcIkFjY2VwdFwiXSB8fCAoaGVhZGVyc1tcIkFjY2VwdFwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKSAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxuICAgICAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuanNvbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByZWFkeXN0YXRlY2hhbmdlXG4gICAgeGhyLm9ubG9hZCA9IGxvYWRGdW5jXG4gICAgeGhyLm9uZXJyb3IgPSBlcnJvckZ1bmNcbiAgICAvLyBJRTkgbXVzdCBoYXZlIG9ucHJvZ3Jlc3MgYmUgc2V0IHRvIGEgdW5pcXVlIGZ1bmN0aW9uLlxuICAgIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJRSBtdXN0IGRpZVxuICAgIH1cbiAgICB4aHIub250aW1lb3V0ID0gZXJyb3JGdW5jXG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmksICFzeW5jKVxuICAgIC8vaGFzIHRvIGJlIGFmdGVyIG9wZW5cbiAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRpb25zLndpdGhDcmVkZW50aWFsc1xuICAgIFxuICAgIC8vIENhbm5vdCBzZXQgdGltZW91dCB3aXRoIHN5bmMgcmVxdWVzdFxuICAgIC8vIG5vdCBzZXR0aW5nIHRpbWVvdXQgb24gdGhlIHhociBvYmplY3QsIGJlY2F1c2Ugb2Ygb2xkIHdlYmtpdHMgZXRjLiBub3QgaGFuZGxpbmcgdGhhdCBjb3JyZWN0bHlcbiAgICAvLyBib3RoIG5wbSdzIHJlcXVlc3QgYW5kIGpxdWVyeSAxLnggdXNlIHRoaXMga2luZCBvZiB0aW1lb3V0LCBzbyB0aGlzIGlzIGJlaW5nIGNvbnNpc3RlbnRcbiAgICBpZiAoIXN5bmMgJiYgb3B0aW9ucy50aW1lb3V0ID4gMCApIHtcbiAgICAgICAgdGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgeGhyLmFib3J0KFwidGltZW91dFwiKTtcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KzIgKTtcbiAgICB9XG5cbiAgICBpZiAoeGhyLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgZm9yKGtleSBpbiBoZWFkZXJzKXtcbiAgICAgICAgICAgIGlmKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSl7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXJzIGNhbm5vdCBiZSBzZXQgb24gYW4gWERvbWFpblJlcXVlc3Qgb2JqZWN0XCIpXG4gICAgfVxuXG4gICAgaWYgKFwicmVzcG9uc2VUeXBlXCIgaW4gb3B0aW9ucykge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGVcbiAgICB9XG4gICAgXG4gICAgaWYgKFwiYmVmb3JlU2VuZFwiIGluIG9wdGlvbnMgJiYgXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmJlZm9yZVNlbmQgPT09IFwiZnVuY3Rpb25cIlxuICAgICkge1xuICAgICAgICBvcHRpb25zLmJlZm9yZVNlbmQoeGhyKVxuICAgIH1cblxuICAgIHhoci5zZW5kKGJvZHkpXG5cbiAgICByZXR1cm4geGhyXG5cblxufVxuXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwiaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZWxmO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHt9O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBvbmNlXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVyblxuICAgIGNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG59XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXNGdW5jdGlvbihpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXNcbiAgICB9XG4gICAgXG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZVxuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVtpXSwgaSwgYXJyYXkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmplY3Rba10sIGssIG9iamVjdClcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvblxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzdHJpbmcgPSB0b1N0cmluZy5jYWxsKGZuKVxuICByZXR1cm4gc3RyaW5nID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBzdHJpbmcgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB8fFxuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAvLyBJRTggYW5kIGJlbG93XG4gICAgIChmbiA9PT0gd2luZG93LnNldFRpbWVvdXQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuYWxlcnQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuY29uZmlybSB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5wcm9tcHQpKVxufTtcbiIsIlxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHJpbTtcblxuZnVuY3Rpb24gdHJpbShzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcbn1cblxuZXhwb3J0cy5sZWZ0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKTtcbn07XG5cbmV4cG9ydHMucmlnaHQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccyokLywgJycpO1xufTtcbiIsInZhciB0cmltID0gcmVxdWlyZSgndHJpbScpXG4gICwgZm9yRWFjaCA9IHJlcXVpcmUoJ2Zvci1lYWNoJylcbiAgLCBpc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4ge31cblxuICB2YXIgcmVzdWx0ID0ge31cblxuICBmb3JFYWNoKFxuICAgICAgdHJpbShoZWFkZXJzKS5zcGxpdCgnXFxuJylcbiAgICAsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcm93LmluZGV4T2YoJzonKVxuICAgICAgICAgICwga2V5ID0gdHJpbShyb3cuc2xpY2UoMCwgaW5kZXgpKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgLCB2YWx1ZSA9IHRyaW0ocm93LnNsaWNlKGluZGV4ICsgMSkpXG5cbiAgICAgICAgaWYgKHR5cGVvZihyZXN1bHRba2V5XSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IFsgcmVzdWx0W2tleV0sIHZhbHVlIF1cbiAgICAgICAgfVxuICAgICAgfVxuICApXG5cbiAgcmV0dXJuIHJlc3VsdFxufSIsIi8qISBzaW1wbGUtcGVlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzaW1wbGUtcGVlcicpXG5jb25zdCBnZXRCcm93c2VyUlRDID0gcmVxdWlyZSgnZ2V0LWJyb3dzZXItcnRjJylcbmNvbnN0IHJhbmRvbWJ5dGVzID0gcmVxdWlyZSgncmFuZG9tYnl0ZXMnKVxuY29uc3Qgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbmNvbnN0IHF1ZXVlTWljcm90YXNrID0gcmVxdWlyZSgncXVldWUtbWljcm90YXNrJykgLy8gVE9ETzogcmVtb3ZlIHdoZW4gTm9kZSAxMCBpcyBub3Qgc3VwcG9ydGVkXG5jb25zdCBlcnJDb2RlID0gcmVxdWlyZSgnZXJyLWNvZGUnKVxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5cbmNvbnN0IE1BWF9CVUZGRVJFRF9BTU9VTlQgPSA2NCAqIDEwMjRcbmNvbnN0IElDRUNPTVBMRVRFX1RJTUVPVVQgPSA1ICogMTAwMFxuY29uc3QgQ0hBTk5FTF9DTE9TSU5HX1RJTUVPVVQgPSA1ICogMTAwMFxuXG4vLyBIQUNLOiBGaWx0ZXIgdHJpY2tsZSBsaW5lcyB3aGVuIHRyaWNrbGUgaXMgZGlzYWJsZWQgIzM1NFxuZnVuY3Rpb24gZmlsdGVyVHJpY2tsZSAoc2RwKSB7XG4gIHJldHVybiBzZHAucmVwbGFjZSgvYT1pY2Utb3B0aW9uczp0cmlja2xlXFxzXFxuL2csICcnKVxufVxuXG5mdW5jdGlvbiB3YXJuIChtZXNzYWdlKSB7XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKVxufVxuXG4vKipcbiAqIFdlYlJUQyBwZWVyIGNvbm5lY3Rpb24uIFNhbWUgQVBJIGFzIG5vZGUgY29yZSBgbmV0LlNvY2tldGAsIHBsdXMgYSBmZXcgZXh0cmEgbWV0aG9kcy5cbiAqIER1cGxleCBzdHJlYW0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5jbGFzcyBQZWVyIGV4dGVuZHMgc3RyZWFtLkR1cGxleCB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgYWxsb3dIYWxmT3BlbjogZmFsc2VcbiAgICB9LCBvcHRzKVxuXG4gICAgc3VwZXIob3B0cylcblxuICAgIHRoaXMuX2lkID0gcmFuZG9tYnl0ZXMoNCkudG9TdHJpbmcoJ2hleCcpLnNsaWNlKDAsIDcpXG4gICAgdGhpcy5fZGVidWcoJ25ldyBwZWVyICVvJywgb3B0cylcblxuICAgIHRoaXMuY2hhbm5lbE5hbWUgPSBvcHRzLmluaXRpYXRvclxuICAgICAgPyBvcHRzLmNoYW5uZWxOYW1lIHx8IHJhbmRvbWJ5dGVzKDIwKS50b1N0cmluZygnaGV4JylcbiAgICAgIDogbnVsbFxuXG4gICAgdGhpcy5pbml0aWF0b3IgPSBvcHRzLmluaXRpYXRvciB8fCBmYWxzZVxuICAgIHRoaXMuY2hhbm5lbENvbmZpZyA9IG9wdHMuY2hhbm5lbENvbmZpZyB8fCBQZWVyLmNoYW5uZWxDb25maWdcbiAgICB0aGlzLmNoYW5uZWxOZWdvdGlhdGVkID0gdGhpcy5jaGFubmVsQ29uZmlnLm5lZ290aWF0ZWRcbiAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIFBlZXIuY29uZmlnLCBvcHRzLmNvbmZpZylcbiAgICB0aGlzLm9mZmVyT3B0aW9ucyA9IG9wdHMub2ZmZXJPcHRpb25zIHx8IHt9XG4gICAgdGhpcy5hbnN3ZXJPcHRpb25zID0gb3B0cy5hbnN3ZXJPcHRpb25zIHx8IHt9XG4gICAgdGhpcy5zZHBUcmFuc2Zvcm0gPSBvcHRzLnNkcFRyYW5zZm9ybSB8fCAoc2RwID0+IHNkcClcbiAgICB0aGlzLnN0cmVhbXMgPSBvcHRzLnN0cmVhbXMgfHwgKG9wdHMuc3RyZWFtID8gW29wdHMuc3RyZWFtXSA6IFtdKSAvLyBzdXBwb3J0IG9sZCBcInN0cmVhbVwiIG9wdGlvblxuICAgIHRoaXMudHJpY2tsZSA9IG9wdHMudHJpY2tsZSAhPT0gdW5kZWZpbmVkID8gb3B0cy50cmlja2xlIDogdHJ1ZVxuICAgIHRoaXMuYWxsb3dIYWxmVHJpY2tsZSA9IG9wdHMuYWxsb3dIYWxmVHJpY2tsZSAhPT0gdW5kZWZpbmVkID8gb3B0cy5hbGxvd0hhbGZUcmlja2xlIDogZmFsc2VcbiAgICB0aGlzLmljZUNvbXBsZXRlVGltZW91dCA9IG9wdHMuaWNlQ29tcGxldGVUaW1lb3V0IHx8IElDRUNPTVBMRVRFX1RJTUVPVVRcblxuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcbiAgICB0aGlzLmRlc3Ryb3lpbmcgPSBmYWxzZVxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlXG5cbiAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSB1bmRlZmluZWRcbiAgICB0aGlzLnJlbW90ZUZhbWlseSA9IHVuZGVmaW5lZFxuICAgIHRoaXMucmVtb3RlUG9ydCA9IHVuZGVmaW5lZFxuICAgIHRoaXMubG9jYWxBZGRyZXNzID0gdW5kZWZpbmVkXG4gICAgdGhpcy5sb2NhbEZhbWlseSA9IHVuZGVmaW5lZFxuICAgIHRoaXMubG9jYWxQb3J0ID0gdW5kZWZpbmVkXG5cbiAgICB0aGlzLl93cnRjID0gKG9wdHMud3J0YyAmJiB0eXBlb2Ygb3B0cy53cnRjID09PSAnb2JqZWN0JylcbiAgICAgID8gb3B0cy53cnRjXG4gICAgICA6IGdldEJyb3dzZXJSVEMoKVxuXG4gICAgaWYgKCF0aGlzLl93cnRjKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ05vIFdlYlJUQyBzdXBwb3J0OiBTcGVjaWZ5IGBvcHRzLndydGNgIG9wdGlvbiBpbiB0aGlzIGVudmlyb25tZW50JyksICdFUlJfV0VCUlRDX1NVUFBPUlQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ05vIFdlYlJUQyBzdXBwb3J0OiBOb3QgYSBzdXBwb3J0ZWQgYnJvd3NlcicpLCAnRVJSX1dFQlJUQ19TVVBQT1JUJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9wY1JlYWR5ID0gZmFsc2VcbiAgICB0aGlzLl9jaGFubmVsUmVhZHkgPSBmYWxzZVxuICAgIHRoaXMuX2ljZUNvbXBsZXRlID0gZmFsc2UgLy8gaWNlIGNhbmRpZGF0ZSB0cmlja2xlIGRvbmUgKGdvdCBudWxsIGNhbmRpZGF0ZSlcbiAgICB0aGlzLl9pY2VDb21wbGV0ZVRpbWVyID0gbnVsbCAvLyBzZW5kIGFuIG9mZmVyL2Fuc3dlciBhbnl3YXkgYWZ0ZXIgc29tZSB0aW1lb3V0XG4gICAgdGhpcy5fY2hhbm5lbCA9IG51bGxcbiAgICB0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdXG5cbiAgICB0aGlzLl9pc05lZ290aWF0aW5nID0gZmFsc2UgLy8gaXMgdGhpcyBwZWVyIHdhaXRpbmcgZm9yIG5lZ290aWF0aW9uIHRvIGNvbXBsZXRlP1xuICAgIHRoaXMuX2ZpcnN0TmVnb3RpYXRpb24gPSB0cnVlXG4gICAgdGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9uID0gZmFsc2UgLy8gYmF0Y2ggc3luY2hyb25vdXMgbmVnb3RpYXRpb25zXG4gICAgdGhpcy5fcXVldWVkTmVnb3RpYXRpb24gPSBmYWxzZSAvLyBpcyB0aGVyZSBhIHF1ZXVlZCBuZWdvdGlhdGlvbiByZXF1ZXN0P1xuICAgIHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZSA9IFtdXG4gICAgdGhpcy5fc2VuZGVyTWFwID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fY2xvc2luZ0ludGVydmFsID0gbnVsbFxuXG4gICAgdGhpcy5fcmVtb3RlVHJhY2tzID0gW11cbiAgICB0aGlzLl9yZW1vdGVTdHJlYW1zID0gW11cblxuICAgIHRoaXMuX2NodW5rID0gbnVsbFxuICAgIHRoaXMuX2NiID0gbnVsbFxuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbFxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3BjID0gbmV3ICh0aGlzLl93cnRjLlJUQ1BlZXJDb25uZWN0aW9uKSh0aGlzLmNvbmZpZylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9QQ19DT05TVFJVQ1RPUicpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gV2UgcHJlZmVyIGZlYXR1cmUgZGV0ZWN0aW9uIHdoZW5ldmVyIHBvc3NpYmxlLCBidXQgc29tZXRpbWVzIHRoYXQncyBub3RcbiAgICAvLyBwb3NzaWJsZSBmb3IgY2VydGFpbiBpbXBsZW1lbnRhdGlvbnMuXG4gICAgdGhpcy5faXNSZWFjdE5hdGl2ZVdlYnJ0YyA9IHR5cGVvZiB0aGlzLl9wYy5fcGVlckNvbm5lY3Rpb25JZCA9PT0gJ251bWJlcidcblxuICAgIHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25JY2VTdGF0ZUNoYW5nZSgpXG4gICAgfVxuICAgIHRoaXMuX3BjLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkljZVN0YXRlQ2hhbmdlKClcbiAgICB9XG4gICAgdGhpcy5fcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSgpXG4gICAgfVxuICAgIHRoaXMuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlKClcbiAgICB9XG4gICAgdGhpcy5fcGMub25pY2VjYW5kaWRhdGUgPSBldmVudCA9PiB7XG4gICAgICB0aGlzLl9vbkljZUNhbmRpZGF0ZShldmVudClcbiAgICB9XG5cbiAgICAvLyBIQUNLOiBGaXggZm9yIG9kZCBGaXJlZm94IGJlaGF2aW9yLCBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3Mvc2ltcGxlLXBlZXIvcHVsbC83ODNcbiAgICBpZiAodHlwZW9mIHRoaXMuX3BjLnBlZXJJZGVudGl0eSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuX3BjLnBlZXJJZGVudGl0eS5jYXRjaChlcnIgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfUENfUEVFUl9JREVOVElUWScpKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBPdGhlciBzcGVjIGV2ZW50cywgdW51c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb246XG4gICAgLy8gLSBvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZVxuICAgIC8vIC0gb25pY2VjYW5kaWRhdGVlcnJvclxuICAgIC8vIC0gb25maW5nZXJwcmludGZhaWx1cmVcbiAgICAvLyAtIG9ubmVnb3RpYXRpb25uZWVkZWRcblxuICAgIGlmICh0aGlzLmluaXRpYXRvciB8fCB0aGlzLmNoYW5uZWxOZWdvdGlhdGVkKSB7XG4gICAgICB0aGlzLl9zZXR1cERhdGEoe1xuICAgICAgICBjaGFubmVsOiB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbCh0aGlzLmNoYW5uZWxOYW1lLCB0aGlzLmNoYW5uZWxDb25maWcpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYy5vbmRhdGFjaGFubmVsID0gZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9zZXR1cERhdGEoZXZlbnQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RyZWFtcykge1xuICAgICAgdGhpcy5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgdGhpcy5hZGRTdHJlYW0oc3RyZWFtKVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5fcGMub250cmFjayA9IGV2ZW50ID0+IHtcbiAgICAgIHRoaXMuX29uVHJhY2soZXZlbnQpXG4gICAgfVxuXG4gICAgdGhpcy5fZGVidWcoJ2luaXRpYWwgbmVnb3RpYXRpb24nKVxuICAgIHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKVxuXG4gICAgdGhpcy5fb25GaW5pc2hCb3VuZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uRmluaXNoKClcbiAgICB9XG4gICAgdGhpcy5vbmNlKCdmaW5pc2gnLCB0aGlzLl9vbkZpbmlzaEJvdW5kKVxuICB9XG5cbiAgZ2V0IGJ1ZmZlclNpemUgKCkge1xuICAgIHJldHVybiAodGhpcy5fY2hhbm5lbCAmJiB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KSB8fCAwXG4gIH1cblxuICAvLyBIQUNLOiBpdCdzIHBvc3NpYmxlIGNoYW5uZWwucmVhZHlTdGF0ZSBpcyBcImNsb3NpbmdcIiBiZWZvcmUgcGVlci5kZXN0cm95KCkgZmlyZXNcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODgyNzQzXG4gIGdldCBjb25uZWN0ZWQgKCkge1xuICAgIHJldHVybiAodGhpcy5fY29ubmVjdGVkICYmIHRoaXMuX2NoYW5uZWwucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKVxuICB9XG5cbiAgYWRkcmVzcyAoKSB7XG4gICAgcmV0dXJuIHsgcG9ydDogdGhpcy5sb2NhbFBvcnQsIGZhbWlseTogdGhpcy5sb2NhbEZhbWlseSwgYWRkcmVzczogdGhpcy5sb2NhbEFkZHJlc3MgfVxuICB9XG5cbiAgc2lnbmFsIChkYXRhKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IHNpZ25hbCBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkYXRhID0ge31cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGVidWcoJ3NpZ25hbCgpJylcblxuICAgIGlmIChkYXRhLnJlbmVnb3RpYXRlICYmIHRoaXMuaW5pdGlhdG9yKSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnZ290IHJlcXVlc3QgdG8gcmVuZWdvdGlhdGUnKVxuICAgICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpXG4gICAgfVxuICAgIGlmIChkYXRhLnRyYW5zY2VpdmVyUmVxdWVzdCAmJiB0aGlzLmluaXRpYXRvcikge1xuICAgICAgdGhpcy5fZGVidWcoJ2dvdCByZXF1ZXN0IGZvciB0cmFuc2NlaXZlcicpXG4gICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKGRhdGEudHJhbnNjZWl2ZXJSZXF1ZXN0LmtpbmQsIGRhdGEudHJhbnNjZWl2ZXJSZXF1ZXN0LmluaXQpXG4gICAgfVxuICAgIGlmIChkYXRhLmNhbmRpZGF0ZSkge1xuICAgICAgaWYgKHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uICYmIHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uLnR5cGUpIHtcbiAgICAgICAgdGhpcy5fYWRkSWNlQ2FuZGlkYXRlKGRhdGEuY2FuZGlkYXRlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NhbmRpZGF0ZXMucHVzaChkYXRhLmNhbmRpZGF0ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEuc2RwKSB7XG4gICAgICB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgKHRoaXMuX3dydGMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShkYXRhKSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAgICAgICB0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcy5mb3JFYWNoKGNhbmRpZGF0ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5fcGVuZGluZ0NhbmRpZGF0ZXMgPSBbXVxuXG4gICAgICAgICAgaWYgKHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicpIHRoaXMuX2NyZWF0ZUFuc3dlcigpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9TRVRfUkVNT1RFX0RFU0NSSVBUSU9OJykpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIGlmICghZGF0YS5zZHAgJiYgIWRhdGEuY2FuZGlkYXRlICYmICFkYXRhLnJlbmVnb3RpYXRlICYmICFkYXRhLnRyYW5zY2VpdmVyUmVxdWVzdCkge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUobmV3IEVycm9yKCdzaWduYWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIHNpZ25hbCBkYXRhJyksICdFUlJfU0lHTkFMSU5HJykpXG4gICAgfVxuICB9XG5cbiAgX2FkZEljZUNhbmRpZGF0ZSAoY2FuZGlkYXRlKSB7XG4gICAgY29uc3QgaWNlQ2FuZGlkYXRlT2JqID0gbmV3IHRoaXMuX3dydGMuUlRDSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSlcbiAgICB0aGlzLl9wYy5hZGRJY2VDYW5kaWRhdGUoaWNlQ2FuZGlkYXRlT2JqKVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmICghaWNlQ2FuZGlkYXRlT2JqLmFkZHJlc3MgfHwgaWNlQ2FuZGlkYXRlT2JqLmFkZHJlc3MuZW5kc1dpdGgoJy5sb2NhbCcpKSB7XG4gICAgICAgICAgd2FybignSWdub3JpbmcgdW5zdXBwb3J0ZWQgSUNFIGNhbmRpZGF0ZS4nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9BRERfSUNFX0NBTkRJREFURScpKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgdGV4dC9iaW5hcnkgZGF0YSB0byB0aGUgcmVtb3RlIHBlZXIuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fEFycmF5QnVmZmVyfEJ1ZmZlcnxzdHJpbmd8QmxvYn0gY2h1bmtcbiAgICovXG4gIHNlbmQgKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IHNlbmQgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2NoYW5uZWwuc2VuZChjaHVuaylcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBUcmFuc2NlaXZlciB0byB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtpbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IGluaXRcbiAgICovXG4gIGFkZFRyYW5zY2VpdmVyIChraW5kLCBpbml0KSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IGFkZFRyYW5zY2VpdmVyIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICB0aGlzLl9kZWJ1ZygnYWRkVHJhbnNjZWl2ZXIoKScpXG5cbiAgICBpZiAodGhpcy5pbml0aWF0b3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKGtpbmQsIGluaXQpXG4gICAgICAgIHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9BRERfVFJBTlNDRUlWRVInKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdzaWduYWwnLCB7IC8vIHJlcXVlc3QgaW5pdGlhdG9yIHRvIHJlbmVnb3RpYXRlXG4gICAgICAgIHR5cGU6ICd0cmFuc2NlaXZlclJlcXVlc3QnLFxuICAgICAgICB0cmFuc2NlaXZlclJlcXVlc3Q6IHsga2luZCwgaW5pdCB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBNZWRpYVN0cmVhbSB0byB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gICAqL1xuICBhZGRTdHJlYW0gKHN0cmVhbSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCBhZGRTdHJlYW0gYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdhZGRTdHJlYW0oKScpXG5cbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICB0aGlzLmFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBNZWRpYVN0cmVhbVRyYWNrIHRvIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbVxuICAgKi9cbiAgYWRkVHJhY2sgKHRyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgYWRkVHJhY2sgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdhZGRUcmFjaygpJylcblxuICAgIGNvbnN0IHN1Ym1hcCA9IHRoaXMuX3NlbmRlck1hcC5nZXQodHJhY2spIHx8IG5ldyBNYXAoKSAvLyBuZXN0ZWQgTWFwcyBtYXAgW3RyYWNrLCBzdHJlYW1dIHRvIHNlbmRlclxuICAgIGxldCBzZW5kZXIgPSBzdWJtYXAuZ2V0KHN0cmVhbSlcbiAgICBpZiAoIXNlbmRlcikge1xuICAgICAgc2VuZGVyID0gdGhpcy5fcGMuYWRkVHJhY2sodHJhY2ssIHN0cmVhbSlcbiAgICAgIHN1Ym1hcC5zZXQoc3RyZWFtLCBzZW5kZXIpXG4gICAgICB0aGlzLl9zZW5kZXJNYXAuc2V0KHRyYWNrLCBzdWJtYXApXG4gICAgICB0aGlzLl9uZWVkc05lZ290aWF0aW9uKClcbiAgICB9IGVsc2UgaWYgKHNlbmRlci5yZW1vdmVkKSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVHJhY2sgaGFzIGJlZW4gcmVtb3ZlZC4gWW91IHNob3VsZCBlbmFibGUvZGlzYWJsZSB0cmFja3MgdGhhdCB5b3Ugd2FudCB0byByZS1hZGQuJyksICdFUlJfU0VOREVSX1JFTU9WRUQnKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignVHJhY2sgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGF0IHN0cmVhbS4nKSwgJ0VSUl9TRU5ERVJfQUxSRUFEWV9BRERFRCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgYSBNZWRpYVN0cmVhbVRyYWNrIGJ5IGFub3RoZXIgaW4gdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gb2xkVHJhY2tcbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSBuZXdUcmFja1xuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICovXG4gIHJlcGxhY2VUcmFjayAob2xkVHJhY2ssIG5ld1RyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgcmVwbGFjZVRyYWNrIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICB0aGlzLl9kZWJ1ZygncmVwbGFjZVRyYWNrKCknKVxuXG4gICAgY29uc3Qgc3VibWFwID0gdGhpcy5fc2VuZGVyTWFwLmdldChvbGRUcmFjaylcbiAgICBjb25zdCBzZW5kZXIgPSBzdWJtYXAgPyBzdWJtYXAuZ2V0KHN0cmVhbSkgOiBudWxsXG4gICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdDYW5ub3QgcmVwbGFjZSB0cmFjayB0aGF0IHdhcyBuZXZlciBhZGRlZC4nKSwgJ0VSUl9UUkFDS19OT1RfQURERUQnKVxuICAgIH1cbiAgICBpZiAobmV3VHJhY2spIHRoaXMuX3NlbmRlck1hcC5zZXQobmV3VHJhY2ssIHN1Ym1hcClcblxuICAgIGlmIChzZW5kZXIucmVwbGFjZVRyYWNrICE9IG51bGwpIHtcbiAgICAgIHNlbmRlci5yZXBsYWNlVHJhY2sobmV3VHJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKG5ldyBFcnJvcigncmVwbGFjZVRyYWNrIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyksICdFUlJfVU5TVVBQT1JURURfUkVQTEFDRVRSQUNLJykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIE1lZGlhU3RyZWFtVHJhY2sgZnJvbSB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICovXG4gIHJlbW92ZVRyYWNrICh0cmFjaywgc3RyZWFtKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IHJlbW92ZVRyYWNrIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICB0aGlzLl9kZWJ1ZygncmVtb3ZlU2VuZGVyKCknKVxuXG4gICAgY29uc3Qgc3VibWFwID0gdGhpcy5fc2VuZGVyTWFwLmdldCh0cmFjaylcbiAgICBjb25zdCBzZW5kZXIgPSBzdWJtYXAgPyBzdWJtYXAuZ2V0KHN0cmVhbSkgOiBudWxsXG4gICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdDYW5ub3QgcmVtb3ZlIHRyYWNrIHRoYXQgd2FzIG5ldmVyIGFkZGVkLicpLCAnRVJSX1RSQUNLX05PVF9BRERFRCcpXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBzZW5kZXIucmVtb3ZlZCA9IHRydWVcbiAgICAgIHRoaXMuX3BjLnJlbW92ZVRyYWNrKHNlbmRlcilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIubmFtZSA9PT0gJ05TX0VSUk9SX1VORVhQRUNURUQnKSB7XG4gICAgICAgIHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZS5wdXNoKHNlbmRlcikgLy8gSEFDSzogRmlyZWZveCBtdXN0IHdhaXQgdW50aWwgKHNpZ25hbGluZ1N0YXRlID09PSBzdGFibGUpIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMzM4NzRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9SRU1PVkVfVFJBQ0snKSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgTWVkaWFTdHJlYW0gZnJvbSB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gICAqL1xuICByZW1vdmVTdHJlYW0gKHN0cmVhbSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCByZW1vdmVTdHJlYW0gYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdyZW1vdmVTZW5kZXJzKCknKVxuXG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVUcmFjayh0cmFjaywgc3RyZWFtKVxuICAgIH0pXG4gIH1cblxuICBfbmVlZHNOZWdvdGlhdGlvbiAoKSB7XG4gICAgdGhpcy5fZGVidWcoJ19uZWVkc05lZ290aWF0aW9uJylcbiAgICBpZiAodGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9uKSByZXR1cm4gLy8gYmF0Y2ggc3luY2hyb25vdXMgcmVuZWdvdGlhdGlvbnNcbiAgICB0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb24gPSB0cnVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgdGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9uID0gZmFsc2VcbiAgICAgIGlmICh0aGlzLmluaXRpYXRvciB8fCAhdGhpcy5fZmlyc3ROZWdvdGlhdGlvbikge1xuICAgICAgICB0aGlzLl9kZWJ1Zygnc3RhcnRpbmcgYmF0Y2hlZCBuZWdvdGlhdGlvbicpXG4gICAgICAgIHRoaXMubmVnb3RpYXRlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdub24taW5pdGlhdG9yIGluaXRpYWwgbmVnb3RpYXRpb24gcmVxdWVzdCBkaXNjYXJkZWQnKVxuICAgICAgfVxuICAgICAgdGhpcy5fZmlyc3ROZWdvdGlhdGlvbiA9IGZhbHNlXG4gICAgfSlcbiAgfVxuXG4gIG5lZ290aWF0ZSAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IG5lZ290aWF0ZSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG5cbiAgICBpZiAodGhpcy5pbml0aWF0b3IpIHtcbiAgICAgIGlmICh0aGlzLl9pc05lZ290aWF0aW5nKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uID0gdHJ1ZVxuICAgICAgICB0aGlzLl9kZWJ1ZygnYWxyZWFkeSBuZWdvdGlhdGluZywgcXVldWVpbmcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3N0YXJ0IG5lZ290aWF0aW9uJylcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IC8vIEhBQ0s6IENocm9tZSBjcmFzaGVzIGlmIHdlIGltbWVkaWF0ZWx5IGNhbGwgY3JlYXRlT2ZmZXJcbiAgICAgICAgICB0aGlzLl9jcmVhdGVPZmZlcigpXG4gICAgICAgIH0sIDApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9pc05lZ290aWF0aW5nKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uID0gdHJ1ZVxuICAgICAgICB0aGlzLl9kZWJ1ZygnYWxyZWFkeSBuZWdvdGlhdGluZywgcXVldWVpbmcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3JlcXVlc3RpbmcgbmVnb3RpYXRpb24gZnJvbSBpbml0aWF0b3InKVxuICAgICAgICB0aGlzLmVtaXQoJ3NpZ25hbCcsIHsgLy8gcmVxdWVzdCBpbml0aWF0b3IgdG8gcmVuZWdvdGlhdGVcbiAgICAgICAgICB0eXBlOiAncmVuZWdvdGlhdGUnLFxuICAgICAgICAgIHJlbmVnb3RpYXRlOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2lzTmVnb3RpYXRpbmcgPSB0cnVlXG4gIH1cblxuICAvLyBUT0RPOiBEZWxldGUgdGhpcyBtZXRob2Qgb25jZSByZWFkYWJsZS1zdHJlYW0gaXMgdXBkYXRlZCB0byBjb250YWluIGEgZGVmYXVsdFxuICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBkZXN0cm95KCkgdGhhdCBhdXRvbWF0aWNhbGx5IGNhbGxzIF9kZXN0cm95KClcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3JlYWRhYmxlLXN0cmVhbS9pc3N1ZXMvMjgzXG4gIGRlc3Ryb3kgKGVycikge1xuICAgIHRoaXMuX2Rlc3Ryb3koZXJyLCAoKSA9PiB7fSlcbiAgfVxuXG4gIF9kZXN0cm95IChlcnIsIGNiKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkIHx8IHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgdGhpcy5kZXN0cm95aW5nID0gdHJ1ZVxuXG4gICAgdGhpcy5fZGVidWcoJ2Rlc3Ryb3lpbmcgKGVycm9yOiAlcyknLCBlcnIgJiYgKGVyci5tZXNzYWdlIHx8IGVycikpXG5cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7IC8vIGFsbG93IGV2ZW50cyBjb25jdXJyZW50IHdpdGggdGhlIGNhbGwgdG8gX2Rlc3Ryb3koKSB0byBmaXJlIChzZWUgIzY5MilcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICAgICAgdGhpcy5kZXN0cm95aW5nID0gZmFsc2VcblxuICAgICAgdGhpcy5fZGVidWcoJ2Rlc3Ryb3kgKGVycm9yOiAlcyknLCBlcnIgJiYgKGVyci5tZXNzYWdlIHx8IGVycikpXG5cbiAgICAgIHRoaXMucmVhZGFibGUgPSB0aGlzLndyaXRhYmxlID0gZmFsc2VcblxuICAgICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSB0aGlzLnB1c2gobnVsbClcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkgdGhpcy5lbmQoKVxuXG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgdGhpcy5fcGNSZWFkeSA9IGZhbHNlXG4gICAgICB0aGlzLl9jaGFubmVsUmVhZHkgPSBmYWxzZVxuICAgICAgdGhpcy5fcmVtb3RlVHJhY2tzID0gbnVsbFxuICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcyA9IG51bGxcbiAgICAgIHRoaXMuX3NlbmRlck1hcCA9IG51bGxcblxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jbG9zaW5nSW50ZXJ2YWwpXG4gICAgICB0aGlzLl9jbG9zaW5nSW50ZXJ2YWwgPSBudWxsXG5cbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGxcbiAgICAgIHRoaXMuX2NodW5rID0gbnVsbFxuICAgICAgdGhpcy5fY2IgPSBudWxsXG5cbiAgICAgIGlmICh0aGlzLl9vbkZpbmlzaEJvdW5kKSB0aGlzLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCB0aGlzLl9vbkZpbmlzaEJvdW5kKVxuICAgICAgdGhpcy5fb25GaW5pc2hCb3VuZCA9IG51bGxcblxuICAgICAgaWYgKHRoaXMuX2NoYW5uZWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLl9jaGFubmVsLmNsb3NlKClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgICAgIC8vIGFsbG93IGV2ZW50cyBjb25jdXJyZW50IHdpdGggZGVzdHJ1Y3Rpb24gdG8gYmUgaGFuZGxlZFxuICAgICAgICB0aGlzLl9jaGFubmVsLm9ubWVzc2FnZSA9IG51bGxcbiAgICAgICAgdGhpcy5fY2hhbm5lbC5vbm9wZW4gPSBudWxsXG4gICAgICAgIHRoaXMuX2NoYW5uZWwub25jbG9zZSA9IG51bGxcbiAgICAgICAgdGhpcy5fY2hhbm5lbC5vbmVycm9yID0gbnVsbFxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAgICAgLy8gYWxsb3cgZXZlbnRzIGNvbmN1cnJlbnQgd2l0aCBkZXN0cnVjdGlvbiB0byBiZSBoYW5kbGVkXG4gICAgICAgIHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICB0aGlzLl9wYy5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICB0aGlzLl9wYy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICB0aGlzLl9wYy5vbmljZWNhbmRpZGF0ZSA9IG51bGxcbiAgICAgICAgdGhpcy5fcGMub250cmFjayA9IG51bGxcbiAgICAgICAgdGhpcy5fcGMub25kYXRhY2hhbm5lbCA9IG51bGxcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BjID0gbnVsbFxuICAgICAgdGhpcy5fY2hhbm5lbCA9IG51bGxcblxuICAgICAgaWYgKGVycikgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKVxuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICBfc2V0dXBEYXRhIChldmVudCkge1xuICAgIGlmICghZXZlbnQuY2hhbm5lbCkge1xuICAgICAgLy8gSW4gc29tZSBzaXR1YXRpb25zIGBwYy5jcmVhdGVEYXRhQ2hhbm5lbCgpYCByZXR1cm5zIGB1bmRlZmluZWRgIChpbiB3cnRjKSxcbiAgICAgIC8vIHdoaWNoIGlzIGludmFsaWQgYmVoYXZpb3IuIEhhbmRsZSBpdCBncmFjZWZ1bGx5LlxuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL3NpbXBsZS1wZWVyL2lzc3Vlcy8xNjNcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koZXJyQ29kZShuZXcgRXJyb3IoJ0RhdGEgY2hhbm5lbCBldmVudCBpcyBtaXNzaW5nIGBjaGFubmVsYCBwcm9wZXJ0eScpLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuICAgIH1cblxuICAgIHRoaXMuX2NoYW5uZWwgPSBldmVudC5jaGFubmVsXG4gICAgdGhpcy5fY2hhbm5lbC5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJ1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IE1BWF9CVUZGRVJFRF9BTU9VTlRcbiAgICB9XG5cbiAgICB0aGlzLmNoYW5uZWxOYW1lID0gdGhpcy5fY2hhbm5lbC5sYWJlbFxuXG4gICAgdGhpcy5fY2hhbm5lbC5vbm1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICB0aGlzLl9vbkNoYW5uZWxNZXNzYWdlKGV2ZW50KVxuICAgIH1cbiAgICB0aGlzLl9jaGFubmVsLm9uYnVmZmVyZWRhbW91bnRsb3cgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdygpXG4gICAgfVxuICAgIHRoaXMuX2NoYW5uZWwub25vcGVuID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25DaGFubmVsT3BlbigpXG4gICAgfVxuICAgIHRoaXMuX2NoYW5uZWwub25jbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uQ2hhbm5lbENsb3NlKClcbiAgICB9XG4gICAgdGhpcy5fY2hhbm5lbC5vbmVycm9yID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZXJyID0gZXZlbnQuZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICA/IGV2ZW50LmVycm9yXG4gICAgICAgIDogbmV3IEVycm9yKGBEYXRhY2hhbm5lbCBlcnJvcjogJHtldmVudC5tZXNzYWdlfSAke2V2ZW50LmZpbGVuYW1lfToke2V2ZW50LmxpbmVub306JHtldmVudC5jb2xub31gKVxuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuICAgIH1cblxuICAgIC8vIEhBQ0s6IENocm9tZSB3aWxsIHNvbWV0aW1lcyBnZXQgc3R1Y2sgaW4gcmVhZHlTdGF0ZSBcImNsb3NpbmdcIiwgbGV0J3MgY2hlY2sgZm9yIHRoaXMgY29uZGl0aW9uXG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODgyNzQzXG4gICAgbGV0IGlzQ2xvc2luZyA9IGZhbHNlXG4gICAgdGhpcy5fY2xvc2luZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4geyAvLyBObyBcIm9uY2xvc2luZ1wiIGV2ZW50XG4gICAgICBpZiAodGhpcy5fY2hhbm5lbCAmJiB0aGlzLl9jaGFubmVsLnJlYWR5U3RhdGUgPT09ICdjbG9zaW5nJykge1xuICAgICAgICBpZiAoaXNDbG9zaW5nKSB0aGlzLl9vbkNoYW5uZWxDbG9zZSgpIC8vIGNsb3NpbmcgdGltZWQgb3V0OiBlcXVpdmFsZW50IHRvIG9uY2xvc2UgZmlyaW5nXG4gICAgICAgIGlzQ2xvc2luZyA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzQ2xvc2luZyA9IGZhbHNlXG4gICAgICB9XG4gICAgfSwgQ0hBTk5FTF9DTE9TSU5HX1RJTUVPVVQpXG4gIH1cblxuICBfcmVhZCAoKSB7fVxuXG4gIF93cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuIGNiKGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3Qgd3JpdGUgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9EQVRBX0NIQU5ORUwnKSlcblxuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2VuZChjaHVuaylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQgPiBNQVhfQlVGRkVSRURfQU1PVU5UKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdzdGFydCBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudClcbiAgICAgICAgdGhpcy5fY2IgPSBjYlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGVidWcoJ3dyaXRlIGJlZm9yZSBjb25uZWN0JylcbiAgICAgIHRoaXMuX2NodW5rID0gY2h1bmtcbiAgICAgIHRoaXMuX2NiID0gY2JcbiAgICB9XG4gIH1cblxuICAvLyBXaGVuIHN0cmVhbSBmaW5pc2hlcyB3cml0aW5nLCBjbG9zZSBzb2NrZXQuIEhhbGYgb3BlbiBjb25uZWN0aW9ucyBhcmUgbm90XG4gIC8vIHN1cHBvcnRlZC5cbiAgX29uRmluaXNoICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgLy8gV2FpdCBhIGJpdCBiZWZvcmUgZGVzdHJveWluZyBzbyB0aGUgc29ja2V0IGZsdXNoZXMuXG4gICAgLy8gVE9ETzogaXMgdGhlcmUgYSBtb3JlIHJlbGlhYmxlIHdheSB0byBhY2NvbXBsaXNoIHRoaXM/XG4gICAgY29uc3QgZGVzdHJveVNvb24gPSAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGVzdHJveSgpLCAxMDAwKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgIGRlc3Ryb3lTb29uKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbmNlKCdjb25uZWN0JywgZGVzdHJveVNvb24pXG4gICAgfVxuICB9XG5cbiAgX3N0YXJ0SWNlQ29tcGxldGVUaW1lb3V0ICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmICh0aGlzLl9pY2VDb21wbGV0ZVRpbWVyKSByZXR1cm5cbiAgICB0aGlzLl9kZWJ1Zygnc3RhcnRlZCBpY2VDb21wbGV0ZSB0aW1lb3V0JylcbiAgICB0aGlzLl9pY2VDb21wbGV0ZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2ljZUNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMuX2ljZUNvbXBsZXRlID0gdHJ1ZVxuICAgICAgICB0aGlzLl9kZWJ1ZygnaWNlQ29tcGxldGUgdGltZW91dCBjb21wbGV0ZWQnKVxuICAgICAgICB0aGlzLmVtaXQoJ2ljZVRpbWVvdXQnKVxuICAgICAgICB0aGlzLmVtaXQoJ19pY2VDb21wbGV0ZScpXG4gICAgICB9XG4gICAgfSwgdGhpcy5pY2VDb21wbGV0ZVRpbWVvdXQpXG4gIH1cblxuICBfY3JlYXRlT2ZmZXIgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICB0aGlzLl9wYy5jcmVhdGVPZmZlcih0aGlzLm9mZmVyT3B0aW9ucylcbiAgICAgIC50aGVuKG9mZmVyID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgaWYgKCF0aGlzLnRyaWNrbGUgJiYgIXRoaXMuYWxsb3dIYWxmVHJpY2tsZSkgb2ZmZXIuc2RwID0gZmlsdGVyVHJpY2tsZShvZmZlci5zZHApXG4gICAgICAgIG9mZmVyLnNkcCA9IHRoaXMuc2RwVHJhbnNmb3JtKG9mZmVyLnNkcClcblxuICAgICAgICBjb25zdCBzZW5kT2ZmZXIgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uIHx8IG9mZmVyXG4gICAgICAgICAgdGhpcy5fZGVidWcoJ3NpZ25hbCcpXG4gICAgICAgICAgdGhpcy5lbWl0KCdzaWduYWwnLCB7XG4gICAgICAgICAgICB0eXBlOiBzaWduYWwudHlwZSxcbiAgICAgICAgICAgIHNkcDogc2lnbmFsLnNkcFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvblN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fZGVidWcoJ2NyZWF0ZU9mZmVyIHN1Y2Nlc3MnKVxuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICAgICAgaWYgKHRoaXMudHJpY2tsZSB8fCB0aGlzLl9pY2VDb21wbGV0ZSkgc2VuZE9mZmVyKClcbiAgICAgICAgICBlbHNlIHRoaXMub25jZSgnX2ljZUNvbXBsZXRlJywgc2VuZE9mZmVyKSAvLyB3YWl0IGZvciBjYW5kaWRhdGVzXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbkVycm9yID0gZXJyID0+IHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfU0VUX0xPQ0FMX0RFU0NSSVBUSU9OJykpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKVxuICAgICAgICAgIC50aGVuKG9uU3VjY2VzcylcbiAgICAgICAgICAuY2F0Y2gob25FcnJvcilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0NSRUFURV9PRkZFUicpKVxuICAgICAgfSlcbiAgfVxuXG4gIF9yZXF1ZXN0TWlzc2luZ1RyYW5zY2VpdmVycyAoKSB7XG4gICAgaWYgKHRoaXMuX3BjLmdldFRyYW5zY2VpdmVycykge1xuICAgICAgdGhpcy5fcGMuZ2V0VHJhbnNjZWl2ZXJzKCkuZm9yRWFjaCh0cmFuc2NlaXZlciA9PiB7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIubWlkICYmIHRyYW5zY2VpdmVyLnNlbmRlci50cmFjayAmJiAhdHJhbnNjZWl2ZXIucmVxdWVzdGVkKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIucmVxdWVzdGVkID0gdHJ1ZSAvLyBIQUNLOiBTYWZhcmkgcmV0dXJucyBuZWdvdGlhdGVkIHRyYW5zY2VpdmVycyB3aXRoIGEgbnVsbCBtaWRcbiAgICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKHRyYW5zY2VpdmVyLnNlbmRlci50cmFjay5raW5kKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVBbnN3ZXIgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIodGhpcy5hbnN3ZXJPcHRpb25zKVxuICAgICAgLnRoZW4oYW5zd2VyID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgaWYgKCF0aGlzLnRyaWNrbGUgJiYgIXRoaXMuYWxsb3dIYWxmVHJpY2tsZSkgYW5zd2VyLnNkcCA9IGZpbHRlclRyaWNrbGUoYW5zd2VyLnNkcClcbiAgICAgICAgYW5zd2VyLnNkcCA9IHRoaXMuc2RwVHJhbnNmb3JtKGFuc3dlci5zZHApXG5cbiAgICAgICAgY29uc3Qgc2VuZEFuc3dlciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24gfHwgYW5zd2VyXG4gICAgICAgICAgdGhpcy5fZGVidWcoJ3NpZ25hbCcpXG4gICAgICAgICAgdGhpcy5lbWl0KCdzaWduYWwnLCB7XG4gICAgICAgICAgICB0eXBlOiBzaWduYWwudHlwZSxcbiAgICAgICAgICAgIHNkcDogc2lnbmFsLnNkcFxuICAgICAgICAgIH0pXG4gICAgICAgICAgaWYgKCF0aGlzLmluaXRpYXRvcikgdGhpcy5fcmVxdWVzdE1pc3NpbmdUcmFuc2NlaXZlcnMoKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb25TdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICAgICAgaWYgKHRoaXMudHJpY2tsZSB8fCB0aGlzLl9pY2VDb21wbGV0ZSkgc2VuZEFuc3dlcigpXG4gICAgICAgICAgZWxzZSB0aGlzLm9uY2UoJ19pY2VDb21wbGV0ZScsIHNlbmRBbnN3ZXIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbkVycm9yID0gZXJyID0+IHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfU0VUX0xPQ0FMX0RFU0NSSVBUSU9OJykpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcilcbiAgICAgICAgICAudGhlbihvblN1Y2Nlc3MpXG4gICAgICAgICAgLmNhdGNoKG9uRXJyb3IpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9DUkVBVEVfQU5TV0VSJykpXG4gICAgICB9KVxuICB9XG5cbiAgX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmICh0aGlzLl9wYy5jb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZmFpbGVkLicpLCAnRVJSX0NPTk5FQ1RJT05fRkFJTFVSRScpKVxuICAgIH1cbiAgfVxuXG4gIF9vbkljZVN0YXRlQ2hhbmdlICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGNvbnN0IGljZUNvbm5lY3Rpb25TdGF0ZSA9IHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZVxuICAgIGNvbnN0IGljZUdhdGhlcmluZ1N0YXRlID0gdGhpcy5fcGMuaWNlR2F0aGVyaW5nU3RhdGVcblxuICAgIHRoaXMuX2RlYnVnKFxuICAgICAgJ2ljZVN0YXRlQ2hhbmdlIChjb25uZWN0aW9uOiAlcykgKGdhdGhlcmluZzogJXMpJyxcbiAgICAgIGljZUNvbm5lY3Rpb25TdGF0ZSxcbiAgICAgIGljZUdhdGhlcmluZ1N0YXRlXG4gICAgKVxuICAgIHRoaXMuZW1pdCgnaWNlU3RhdGVDaGFuZ2UnLCBpY2VDb25uZWN0aW9uU3RhdGUsIGljZUdhdGhlcmluZ1N0YXRlKVxuXG4gICAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgfHwgaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29tcGxldGVkJykge1xuICAgICAgdGhpcy5fcGNSZWFkeSA9IHRydWVcbiAgICAgIHRoaXMuX21heWJlUmVhZHkoKVxuICAgIH1cbiAgICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUobmV3IEVycm9yKCdJY2UgY29ubmVjdGlvbiBmYWlsZWQuJyksICdFUlJfSUNFX0NPTk5FQ1RJT05fRkFJTFVSRScpKVxuICAgIH1cbiAgICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUobmV3IEVycm9yKCdJY2UgY29ubmVjdGlvbiBjbG9zZWQuJyksICdFUlJfSUNFX0NPTk5FQ1RJT05fQ0xPU0VEJykpXG4gICAgfVxuICB9XG5cbiAgZ2V0U3RhdHMgKGNiKSB7XG4gICAgLy8gc3RhdHJlcG9ydHMgY2FuIGNvbWUgd2l0aCBhIHZhbHVlIGFycmF5IGluc3RlYWQgb2YgcHJvcGVydGllc1xuICAgIGNvbnN0IGZsYXR0ZW5WYWx1ZXMgPSByZXBvcnQgPT4ge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXBvcnQudmFsdWVzKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICByZXBvcnQudmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVwb3J0LCB2YWx1ZSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXBvcnRcbiAgICB9XG5cbiAgICAvLyBQcm9taXNlLWJhc2VkIGdldFN0YXRzKCkgKHN0YW5kYXJkKVxuICAgIGlmICh0aGlzLl9wYy5nZXRTdGF0cy5sZW5ndGggPT09IDAgfHwgdGhpcy5faXNSZWFjdE5hdGl2ZVdlYnJ0Yykge1xuICAgICAgdGhpcy5fcGMuZ2V0U3RhdHMoKVxuICAgICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlcG9ydHMgPSBbXVxuICAgICAgICAgIHJlcy5mb3JFYWNoKHJlcG9ydCA9PiB7XG4gICAgICAgICAgICByZXBvcnRzLnB1c2goZmxhdHRlblZhbHVlcyhyZXBvcnQpKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgY2IobnVsbCwgcmVwb3J0cylcbiAgICAgICAgfSwgZXJyID0+IGNiKGVycikpXG5cbiAgICAvLyBTaW5nbGUtcGFyYW1ldGVyIGNhbGxiYWNrLWJhc2VkIGdldFN0YXRzKCkgKG5vbi1zdGFuZGFyZClcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BjLmdldFN0YXRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX3BjLmdldFN0YXRzKHJlcyA9PiB7XG4gICAgICAgIC8vIElmIHdlIGRlc3Ryb3kgY29ubmVjdGlvbiBpbiBgY29ubmVjdGAgY2FsbGJhY2sgdGhpcyBjb2RlIG1pZ2h0IGhhcHBlbiB0byBydW4gd2hlbiBhY3R1YWwgY29ubmVjdGlvbiBpcyBhbHJlYWR5IGNsb3NlZFxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHJlcG9ydHMgPSBbXVxuICAgICAgICByZXMucmVzdWx0KCkuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHt9XG4gICAgICAgICAgcmVzdWx0Lm5hbWVzKCkuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgIHJlcG9ydFtuYW1lXSA9IHJlc3VsdC5zdGF0KG5hbWUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXBvcnQuaWQgPSByZXN1bHQuaWRcbiAgICAgICAgICByZXBvcnQudHlwZSA9IHJlc3VsdC50eXBlXG4gICAgICAgICAgcmVwb3J0LnRpbWVzdGFtcCA9IHJlc3VsdC50aW1lc3RhbXBcbiAgICAgICAgICByZXBvcnRzLnB1c2goZmxhdHRlblZhbHVlcyhyZXBvcnQpKVxuICAgICAgICB9KVxuICAgICAgICBjYihudWxsLCByZXBvcnRzKVxuICAgICAgfSwgZXJyID0+IGNiKGVycikpXG5cbiAgICAvLyBVbmtub3duIGJyb3dzZXIsIHNraXAgZ2V0U3RhdHMoKSBzaW5jZSBpdCdzIGFueW9uZSdzIGd1ZXNzIHdoaWNoIHN0eWxlIG9mXG4gICAgLy8gZ2V0U3RhdHMoKSB0aGV5IGltcGxlbWVudC5cbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbCwgW10pXG4gICAgfVxuICB9XG5cbiAgX21heWJlUmVhZHkgKCkge1xuICAgIHRoaXMuX2RlYnVnKCdtYXliZVJlYWR5IHBjICVzIGNoYW5uZWwgJXMnLCB0aGlzLl9wY1JlYWR5LCB0aGlzLl9jaGFubmVsUmVhZHkpXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCB8fCB0aGlzLl9jb25uZWN0aW5nIHx8ICF0aGlzLl9wY1JlYWR5IHx8ICF0aGlzLl9jaGFubmVsUmVhZHkpIHJldHVyblxuXG4gICAgdGhpcy5fY29ubmVjdGluZyA9IHRydWVcblxuICAgIC8vIEhBQ0s6IFdlIGNhbid0IHJlbHkgb24gb3JkZXIgaGVyZSwgZm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcy1wbGF0Zm9ybS9ub2RlLXdlYnJ0Yy9pc3N1ZXMvMzM5XG4gICAgY29uc3QgZmluZENhbmRpZGF0ZVBhaXIgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgICB0aGlzLmdldFN0YXRzKChlcnIsIGl0ZW1zKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAgICAgLy8gVHJlYXQgZ2V0U3RhdHMgZXJyb3IgYXMgbm9uLWZhdGFsLiBJdCdzIG5vdCBlc3NlbnRpYWwuXG4gICAgICAgIGlmIChlcnIpIGl0ZW1zID0gW11cblxuICAgICAgICBjb25zdCByZW1vdGVDYW5kaWRhdGVzID0ge31cbiAgICAgICAgY29uc3QgbG9jYWxDYW5kaWRhdGVzID0ge31cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlUGFpcnMgPSB7fVxuICAgICAgICBsZXQgZm91bmRTZWxlY3RlZENhbmRpZGF0ZVBhaXIgPSBmYWxzZVxuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgLy8gVE9ETzogT25jZSBhbGwgYnJvd3NlcnMgc3VwcG9ydCB0aGUgaHlwaGVuYXRlZCBzdGF0cyByZXBvcnQgdHlwZXMsIHJlbW92ZVxuICAgICAgICAgIC8vIHRoZSBub24taHlwZW5hdGVkIG9uZXNcbiAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAncmVtb3RlY2FuZGlkYXRlJyB8fCBpdGVtLnR5cGUgPT09ICdyZW1vdGUtY2FuZGlkYXRlJykge1xuICAgICAgICAgICAgcmVtb3RlQ2FuZGlkYXRlc1tpdGVtLmlkXSA9IGl0ZW1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2xvY2FsY2FuZGlkYXRlJyB8fCBpdGVtLnR5cGUgPT09ICdsb2NhbC1jYW5kaWRhdGUnKSB7XG4gICAgICAgICAgICBsb2NhbENhbmRpZGF0ZXNbaXRlbS5pZF0gPSBpdGVtXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdjYW5kaWRhdGVwYWlyJyB8fCBpdGVtLnR5cGUgPT09ICdjYW5kaWRhdGUtcGFpcicpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZVBhaXJzW2l0ZW0uaWRdID0gaXRlbVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBzZXRTZWxlY3RlZENhbmRpZGF0ZVBhaXIgPSBzZWxlY3RlZENhbmRpZGF0ZVBhaXIgPT4ge1xuICAgICAgICAgIGZvdW5kU2VsZWN0ZWRDYW5kaWRhdGVQYWlyID0gdHJ1ZVxuXG4gICAgICAgICAgbGV0IGxvY2FsID0gbG9jYWxDYW5kaWRhdGVzW3NlbGVjdGVkQ2FuZGlkYXRlUGFpci5sb2NhbENhbmRpZGF0ZUlkXVxuXG4gICAgICAgICAgaWYgKGxvY2FsICYmIChsb2NhbC5pcCB8fCBsb2NhbC5hZGRyZXNzKSkge1xuICAgICAgICAgICAgLy8gU3BlY1xuICAgICAgICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBsb2NhbC5pcCB8fCBsb2NhbC5hZGRyZXNzXG4gICAgICAgICAgICB0aGlzLmxvY2FsUG9ydCA9IE51bWJlcihsb2NhbC5wb3J0KVxuICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWwgJiYgbG9jYWwuaXBBZGRyZXNzKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgICB0aGlzLmxvY2FsQWRkcmVzcyA9IGxvY2FsLmlwQWRkcmVzc1xuICAgICAgICAgICAgdGhpcy5sb2NhbFBvcnQgPSBOdW1iZXIobG9jYWwucG9ydE51bWJlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RlZENhbmRpZGF0ZVBhaXIuZ29vZ0xvY2FsQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIG9uY2UgQ2hyb21lIDU4IGlzIHJlbGVhc2VkXG4gICAgICAgICAgICBsb2NhbCA9IHNlbGVjdGVkQ2FuZGlkYXRlUGFpci5nb29nTG9jYWxBZGRyZXNzLnNwbGl0KCc6JylcbiAgICAgICAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gbG9jYWxbMF1cbiAgICAgICAgICAgIHRoaXMubG9jYWxQb3J0ID0gTnVtYmVyKGxvY2FsWzFdKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5sb2NhbEFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxGYW1pbHkgPSB0aGlzLmxvY2FsQWRkcmVzcy5pbmNsdWRlcygnOicpID8gJ0lQdjYnIDogJ0lQdjQnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHJlbW90ZSA9IHJlbW90ZUNhbmRpZGF0ZXNbc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLnJlbW90ZUNhbmRpZGF0ZUlkXVxuXG4gICAgICAgICAgaWYgKHJlbW90ZSAmJiAocmVtb3RlLmlwIHx8IHJlbW90ZS5hZGRyZXNzKSkge1xuICAgICAgICAgICAgLy8gU3BlY1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gcmVtb3RlLmlwIHx8IHJlbW90ZS5hZGRyZXNzXG4gICAgICAgICAgICB0aGlzLnJlbW90ZVBvcnQgPSBOdW1iZXIocmVtb3RlLnBvcnQpXG4gICAgICAgICAgfSBlbHNlIGlmIChyZW1vdGUgJiYgcmVtb3RlLmlwQWRkcmVzcykge1xuICAgICAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gcmVtb3RlLmlwQWRkcmVzc1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVQb3J0ID0gTnVtYmVyKHJlbW90ZS5wb3J0TnVtYmVyKVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGVjdGVkQ2FuZGlkYXRlUGFpci5nb29nUmVtb3RlQWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIG9uY2UgQ2hyb21lIDU4IGlzIHJlbGVhc2VkXG4gICAgICAgICAgICByZW1vdGUgPSBzZWxlY3RlZENhbmRpZGF0ZVBhaXIuZ29vZ1JlbW90ZUFkZHJlc3Muc3BsaXQoJzonKVxuICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gcmVtb3RlWzBdXG4gICAgICAgICAgICB0aGlzLnJlbW90ZVBvcnQgPSBOdW1iZXIocmVtb3RlWzFdKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5yZW1vdGVBZGRyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW90ZUZhbWlseSA9IHRoaXMucmVtb3RlQWRkcmVzcy5pbmNsdWRlcygnOicpID8gJ0lQdjYnIDogJ0lQdjQnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fZGVidWcoXG4gICAgICAgICAgICAnY29ubmVjdCBsb2NhbDogJXM6JXMgcmVtb3RlOiAlczolcycsXG4gICAgICAgICAgICB0aGlzLmxvY2FsQWRkcmVzcyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxQb3J0LFxuICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgdGhpcy5yZW1vdGVQb3J0XG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAvLyBTcGVjLWNvbXBsaWFudFxuICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICd0cmFuc3BvcnQnICYmIGl0ZW0uc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkQ2FuZGlkYXRlUGFpcihjYW5kaWRhdGVQYWlyc1tpdGVtLnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkXSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPbGQgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGl0ZW0udHlwZSA9PT0gJ2dvb2dDYW5kaWRhdGVQYWlyJyAmJiBpdGVtLmdvb2dBY3RpdmVDb25uZWN0aW9uID09PSAndHJ1ZScpIHx8XG4gICAgICAgICAgICAoKGl0ZW0udHlwZSA9PT0gJ2NhbmRpZGF0ZXBhaXInIHx8IGl0ZW0udHlwZSA9PT0gJ2NhbmRpZGF0ZS1wYWlyJykgJiYgaXRlbS5zZWxlY3RlZClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkQ2FuZGlkYXRlUGFpcihpdGVtKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICAvLyBJZ25vcmUgY2FuZGlkYXRlIHBhaXIgc2VsZWN0aW9uIGluIGJyb3dzZXJzIGxpa2UgU2FmYXJpIDExIHRoYXQgZG8gbm90IGhhdmUgYW55IGxvY2FsIG9yIHJlbW90ZSBjYW5kaWRhdGVzXG4gICAgICAgIC8vIEJ1dCB3YWl0IHVudGlsIGF0IGxlYXN0IDEgY2FuZGlkYXRlIHBhaXIgaXMgYXZhaWxhYmxlXG4gICAgICAgIGlmICghZm91bmRTZWxlY3RlZENhbmRpZGF0ZVBhaXIgJiYgKCFPYmplY3Qua2V5cyhjYW5kaWRhdGVQYWlycykubGVuZ3RoIHx8IE9iamVjdC5rZXlzKGxvY2FsQ2FuZGlkYXRlcykubGVuZ3RoKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZmluZENhbmRpZGF0ZVBhaXIsIDEwMClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2VcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY2h1bmspIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zZW5kKHRoaXMuX2NodW5rKVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9EQVRBX0NIQU5ORUwnKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY2h1bmsgPSBudWxsXG4gICAgICAgICAgdGhpcy5fZGVidWcoJ3NlbnQgY2h1bmsgZnJvbSBcIndyaXRlIGJlZm9yZSBjb25uZWN0XCInKVxuXG4gICAgICAgICAgY29uc3QgY2IgPSB0aGlzLl9jYlxuICAgICAgICAgIHRoaXMuX2NiID0gbnVsbFxuICAgICAgICAgIGNiKG51bGwpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBgYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGRgIGFuZCAnb25idWZmZXJlZGFtb3VudGxvdycgYXJlIHVuc3VwcG9ydGVkLFxuICAgICAgICAvLyBmYWxsYmFjayB0byB1c2luZyBzZXRJbnRlcnZhbCB0byBpbXBsZW1lbnQgYmFja3ByZXNzdXJlLlxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLl9vbkludGVydmFsKCksIDE1MClcbiAgICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWwudW5yZWYpIHRoaXMuX2ludGVydmFsLnVucmVmKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RlYnVnKCdjb25uZWN0JylcbiAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JylcbiAgICAgIH0pXG4gICAgfVxuICAgIGZpbmRDYW5kaWRhdGVQYWlyKClcbiAgfVxuXG4gIF9vbkludGVydmFsICgpIHtcbiAgICBpZiAoIXRoaXMuX2NiIHx8ICF0aGlzLl9jaGFubmVsIHx8IHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQgPiBNQVhfQlVGRkVSRURfQU1PVU5UKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5fb25DaGFubmVsQnVmZmVyZWRBbW91bnRMb3coKVxuICB9XG5cbiAgX29uU2lnbmFsaW5nU3RhdGVDaGFuZ2UgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdzdGFibGUnKSB7XG4gICAgICB0aGlzLl9pc05lZ290aWF0aW5nID0gZmFsc2VcblxuICAgICAgLy8gSEFDSzogRmlyZWZveCBkb2Vzbid0IHlldCBzdXBwb3J0IHJlbW92aW5nIHRyYWNrcyB3aGVuIHNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJ1xuICAgICAgdGhpcy5fZGVidWcoJ2ZsdXNoaW5nIHNlbmRlciBxdWV1ZScsIHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZSlcbiAgICAgIHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZS5mb3JFYWNoKHNlbmRlciA9PiB7XG4gICAgICAgIHRoaXMuX3BjLnJlbW92ZVRyYWNrKHNlbmRlcilcbiAgICAgICAgdGhpcy5fcXVldWVkTmVnb3RpYXRpb24gPSB0cnVlXG4gICAgICB9KVxuICAgICAgdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlID0gW11cblxuICAgICAgaWYgKHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdmbHVzaGluZyBuZWdvdGlhdGlvbiBxdWV1ZScpXG4gICAgICAgIHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uID0gZmFsc2VcbiAgICAgICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpIC8vIG5lZ290aWF0ZSBhZ2FpblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ25lZ290aWF0ZWQnKVxuICAgICAgICB0aGlzLmVtaXQoJ25lZ290aWF0ZWQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2RlYnVnKCdzaWduYWxpbmdTdGF0ZUNoYW5nZSAlcycsIHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlKVxuICAgIHRoaXMuZW1pdCgnc2lnbmFsaW5nU3RhdGVDaGFuZ2UnLCB0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSlcbiAgfVxuXG4gIF9vbkljZUNhbmRpZGF0ZSAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGlmIChldmVudC5jYW5kaWRhdGUgJiYgdGhpcy50cmlja2xlKSB7XG4gICAgICB0aGlzLmVtaXQoJ3NpZ25hbCcsIHtcbiAgICAgICAgdHlwZTogJ2NhbmRpZGF0ZScsXG4gICAgICAgIGNhbmRpZGF0ZToge1xuICAgICAgICAgIGNhbmRpZGF0ZTogZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSxcbiAgICAgICAgICBzZHBNTGluZUluZGV4OiBldmVudC5jYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgICAgICBzZHBNaWQ6IGV2ZW50LmNhbmRpZGF0ZS5zZHBNaWRcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKCFldmVudC5jYW5kaWRhdGUgJiYgIXRoaXMuX2ljZUNvbXBsZXRlKSB7XG4gICAgICB0aGlzLl9pY2VDb21wbGV0ZSA9IHRydWVcbiAgICAgIHRoaXMuZW1pdCgnX2ljZUNvbXBsZXRlJylcbiAgICB9XG4gICAgLy8gYXMgc29vbiBhcyB3ZSd2ZSByZWNlaXZlZCBvbmUgdmFsaWQgY2FuZGlkYXRlIHN0YXJ0IHRpbWVvdXRcbiAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XG4gICAgICB0aGlzLl9zdGFydEljZUNvbXBsZXRlVGltZW91dCgpXG4gICAgfVxuICB9XG5cbiAgX29uQ2hhbm5lbE1lc3NhZ2UgKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICBsZXQgZGF0YSA9IGV2ZW50LmRhdGFcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSlcbiAgICB0aGlzLnB1c2goZGF0YSlcbiAgfVxuXG4gIF9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdyAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkIHx8ICF0aGlzLl9jYikgcmV0dXJuXG4gICAgdGhpcy5fZGVidWcoJ2VuZGluZyBiYWNrcHJlc3N1cmU6IGJ1ZmZlcmVkQW1vdW50ICVkJywgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudClcbiAgICBjb25zdCBjYiA9IHRoaXMuX2NiXG4gICAgdGhpcy5fY2IgPSBudWxsXG4gICAgY2IobnVsbClcbiAgfVxuXG4gIF9vbkNoYW5uZWxPcGVuICgpIHtcbiAgICBpZiAodGhpcy5fY29ubmVjdGVkIHx8IHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICB0aGlzLl9kZWJ1Zygnb24gY2hhbm5lbCBvcGVuJylcbiAgICB0aGlzLl9jaGFubmVsUmVhZHkgPSB0cnVlXG4gICAgdGhpcy5fbWF5YmVSZWFkeSgpXG4gIH1cblxuICBfb25DaGFubmVsQ2xvc2UgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgdGhpcy5fZGVidWcoJ29uIGNoYW5uZWwgY2xvc2UnKVxuICAgIHRoaXMuZGVzdHJveSgpXG4gIH1cblxuICBfb25UcmFjayAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgZXZlbnQuc3RyZWFtcy5mb3JFYWNoKGV2ZW50U3RyZWFtID0+IHtcbiAgICAgIHRoaXMuX2RlYnVnKCdvbiB0cmFjaycpXG4gICAgICB0aGlzLmVtaXQoJ3RyYWNrJywgZXZlbnQudHJhY2ssIGV2ZW50U3RyZWFtKVxuXG4gICAgICB0aGlzLl9yZW1vdGVUcmFja3MucHVzaCh7XG4gICAgICAgIHRyYWNrOiBldmVudC50cmFjayxcbiAgICAgICAgc3RyZWFtOiBldmVudFN0cmVhbVxuICAgICAgfSlcblxuICAgICAgaWYgKHRoaXMuX3JlbW90ZVN0cmVhbXMuc29tZShyZW1vdGVTdHJlYW0gPT4ge1xuICAgICAgICByZXR1cm4gcmVtb3RlU3RyZWFtLmlkID09PSBldmVudFN0cmVhbS5pZFxuICAgICAgfSkpIHJldHVybiAvLyBPbmx5IGZpcmUgb25lICdzdHJlYW0nIGV2ZW50LCBldmVuIHRob3VnaCB0aGVyZSBtYXkgYmUgbXVsdGlwbGUgdHJhY2tzIHBlciBzdHJlYW1cblxuICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcy5wdXNoKGV2ZW50U3RyZWFtKVxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLl9kZWJ1Zygnb24gc3RyZWFtJylcbiAgICAgICAgdGhpcy5lbWl0KCdzdHJlYW0nLCBldmVudFN0cmVhbSkgLy8gZW5zdXJlIGFsbCB0cmFja3MgaGF2ZSBiZWVuIGFkZGVkXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBfZGVidWcgKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICBhcmdzWzBdID0gJ1snICsgdGhpcy5faWQgKyAnXSAnICsgYXJnc1swXVxuICAgIGRlYnVnLmFwcGx5KG51bGwsIGFyZ3MpXG4gIH1cbn1cblxuUGVlci5XRUJSVENfU1VQUE9SVCA9ICEhZ2V0QnJvd3NlclJUQygpXG5cbi8qKlxuICogRXhwb3NlIHBlZXIgYW5kIGRhdGEgY2hhbm5lbCBjb25maWcgZm9yIG92ZXJyaWRpbmcgYWxsIFBlZXJcbiAqIGluc3RhbmNlcy4gT3RoZXJ3aXNlLCBqdXN0IHNldCBvcHRzLmNvbmZpZyBvciBvcHRzLmNoYW5uZWxDb25maWdcbiAqIHdoZW4gY29uc3RydWN0aW5nIGEgUGVlci5cbiAqL1xuUGVlci5jb25maWcgPSB7XG4gIGljZVNlcnZlcnM6IFtcbiAgICB7XG4gICAgICB1cmxzOiBbXG4gICAgICAgICdzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyJyxcbiAgICAgICAgJ3N0dW46Z2xvYmFsLnN0dW4udHdpbGlvLmNvbTozNDc4J1xuICAgICAgXVxuICAgIH1cbiAgXSxcbiAgc2RwU2VtYW50aWNzOiAndW5pZmllZC1wbGFuJ1xufVxuXG5QZWVyLmNoYW5uZWxDb25maWcgPSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlZXJcbiIsInZhciBlbmdpbmUgPSByZXF1aXJlKCcuLi9zcmMvc3RvcmUtZW5naW5lJylcblxudmFyIHN0b3JhZ2VzID0gcmVxdWlyZSgnLi4vc3RvcmFnZXMvYWxsJylcbnZhciBwbHVnaW5zID0gW3JlcXVpcmUoJy4uL3BsdWdpbnMvanNvbjInKV1cblxubW9kdWxlLmV4cG9ydHMgPSBlbmdpbmUuY3JlYXRlU3RvcmUoc3RvcmFnZXMsIHBsdWdpbnMpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGpzb24yUGx1Z2luXG5cbmZ1bmN0aW9uIGpzb24yUGx1Z2luKCkge1xuXHRyZXF1aXJlKCcuL2xpYi9qc29uMicpXG5cdHJldHVybiB7fVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuLy8gIGpzb24yLmpzXG4vLyAgMjAxNi0xMC0yOFxuLy8gIFB1YmxpYyBEb21haW4uXG4vLyAgTk8gV0FSUkFOVFkgRVhQUkVTU0VEIE9SIElNUExJRUQuIFVTRSBBVCBZT1VSIE9XTiBSSVNLLlxuLy8gIFNlZSBodHRwOi8vd3d3LkpTT04ub3JnL2pzLmh0bWxcbi8vICBUaGlzIGNvZGUgc2hvdWxkIGJlIG1pbmlmaWVkIGJlZm9yZSBkZXBsb3ltZW50LlxuLy8gIFNlZSBodHRwOi8vamF2YXNjcmlwdC5jcm9ja2ZvcmQuY29tL2pzbWluLmh0bWxcblxuLy8gIFVTRSBZT1VSIE9XTiBDT1BZLiBJVCBJUyBFWFRSRU1FTFkgVU5XSVNFIFRPIExPQUQgQ09ERSBGUk9NIFNFUlZFUlMgWU9VIERPXG4vLyAgTk9UIENPTlRST0wuXG5cbi8vICBUaGlzIGZpbGUgY3JlYXRlcyBhIGdsb2JhbCBKU09OIG9iamVjdCBjb250YWluaW5nIHR3byBtZXRob2RzOiBzdHJpbmdpZnlcbi8vICBhbmQgcGFyc2UuIFRoaXMgZmlsZSBwcm92aWRlcyB0aGUgRVM1IEpTT04gY2FwYWJpbGl0eSB0byBFUzMgc3lzdGVtcy5cbi8vICBJZiBhIHByb2plY3QgbWlnaHQgcnVuIG9uIElFOCBvciBlYXJsaWVyLCB0aGVuIHRoaXMgZmlsZSBzaG91bGQgYmUgaW5jbHVkZWQuXG4vLyAgVGhpcyBmaWxlIGRvZXMgbm90aGluZyBvbiBFUzUgc3lzdGVtcy5cblxuLy8gICAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKVxuLy8gICAgICAgICAgdmFsdWUgICAgICAgYW55IEphdmFTY3JpcHQgdmFsdWUsIHVzdWFsbHkgYW4gb2JqZWN0IG9yIGFycmF5LlxuLy8gICAgICAgICAgcmVwbGFjZXIgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgZGV0ZXJtaW5lcyBob3cgb2JqZWN0XG4vLyAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgYXJlIHN0cmluZ2lmaWVkIGZvciBvYmplY3RzLiBJdCBjYW4gYmUgYVxuLy8gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbi8vICAgICAgICAgIHNwYWNlICAgICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbi8vICAgICAgICAgICAgICAgICAgICAgIG9mIG5lc3RlZCBzdHJ1Y3R1cmVzLiBJZiBpdCBpcyBvbWl0dGVkLCB0aGUgdGV4dCB3aWxsXG4vLyAgICAgICAgICAgICAgICAgICAgICBiZSBwYWNrZWQgd2l0aG91dCBleHRyYSB3aGl0ZXNwYWNlLiBJZiBpdCBpcyBhIG51bWJlcixcbi8vICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnQgYXQgZWFjaFxuLy8gICAgICAgICAgICAgICAgICAgICAgbGV2ZWwuIElmIGl0IGlzIGEgc3RyaW5nIChzdWNoIGFzIFwiXFx0XCIgb3IgXCImbmJzcDtcIiksXG4vLyAgICAgICAgICAgICAgICAgICAgICBpdCBjb250YWlucyB0aGUgY2hhcmFjdGVycyB1c2VkIHRvIGluZGVudCBhdCBlYWNoIGxldmVsLlxuLy8gICAgICAgICAgVGhpcyBtZXRob2QgcHJvZHVjZXMgYSBKU09OIHRleHQgZnJvbSBhIEphdmFTY3JpcHQgdmFsdWUuXG4vLyAgICAgICAgICBXaGVuIGFuIG9iamVjdCB2YWx1ZSBpcyBmb3VuZCwgaWYgdGhlIG9iamVjdCBjb250YWlucyBhIHRvSlNPTlxuLy8gICAgICAgICAgbWV0aG9kLCBpdHMgdG9KU09OIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhbmQgdGhlIHJlc3VsdCB3aWxsIGJlXG4vLyAgICAgICAgICBzdHJpbmdpZmllZC4gQSB0b0pTT04gbWV0aG9kIGRvZXMgbm90IHNlcmlhbGl6ZTogaXQgcmV0dXJucyB0aGVcbi8vICAgICAgICAgIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBuYW1lL3ZhbHVlIHBhaXIgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZCxcbi8vICAgICAgICAgIG9yIHVuZGVmaW5lZCBpZiBub3RoaW5nIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgdG9KU09OIG1ldGhvZFxuLy8gICAgICAgICAgd2lsbCBiZSBwYXNzZWQgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHZhbHVlLCBhbmQgdGhpcyB3aWxsIGJlXG4vLyAgICAgICAgICBib3VuZCB0byB0aGUgdmFsdWUuXG5cbi8vICAgICAgICAgIEZvciBleGFtcGxlLCB0aGlzIHdvdWxkIHNlcmlhbGl6ZSBEYXRlcyBhcyBJU08gc3RyaW5ncy5cblxuLy8gICAgICAgICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcbi8vICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZihuKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuLy8gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuIDwgMTApXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIjBcIiArIG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICA6IG47XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VVRDRnVsbFllYXIoKSAgICsgXCItXCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyBcIi1cIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgICAgICArIFwiVFwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgICAgICsgXCI6XCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICAgKyBcIjpcIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgICArIFwiWlwiO1xuLy8gICAgICAgICAgICAgIH07XG5cbi8vICAgICAgICAgIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbCByZXBsYWNlciBtZXRob2QuIEl0IHdpbGwgYmUgcGFzc2VkIHRoZVxuLy8gICAgICAgICAga2V5IGFuZCB2YWx1ZSBvZiBlYWNoIG1lbWJlciwgd2l0aCB0aGlzIGJvdW5kIHRvIHRoZSBjb250YWluaW5nXG4vLyAgICAgICAgICBvYmplY3QuIFRoZSB2YWx1ZSB0aGF0IGlzIHJldHVybmVkIGZyb20geW91ciBtZXRob2Qgd2lsbCBiZVxuLy8gICAgICAgICAgc2VyaWFsaXplZC4gSWYgeW91ciBtZXRob2QgcmV0dXJucyB1bmRlZmluZWQsIHRoZW4gdGhlIG1lbWJlciB3aWxsXG4vLyAgICAgICAgICBiZSBleGNsdWRlZCBmcm9tIHRoZSBzZXJpYWxpemF0aW9uLlxuXG4vLyAgICAgICAgICBJZiB0aGUgcmVwbGFjZXIgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIHRoZW4gaXQgd2lsbCBiZVxuLy8gICAgICAgICAgdXNlZCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc2VyaWFsaXplZC4gSXQgZmlsdGVycyB0aGUgcmVzdWx0c1xuLy8gICAgICAgICAgc3VjaCB0aGF0IG9ubHkgbWVtYmVycyB3aXRoIGtleXMgbGlzdGVkIGluIHRoZSByZXBsYWNlciBhcnJheSBhcmVcbi8vICAgICAgICAgIHN0cmluZ2lmaWVkLlxuXG4vLyAgICAgICAgICBWYWx1ZXMgdGhhdCBkbyBub3QgaGF2ZSBKU09OIHJlcHJlc2VudGF0aW9ucywgc3VjaCBhcyB1bmRlZmluZWQgb3Jcbi8vICAgICAgICAgIGZ1bmN0aW9ucywgd2lsbCBub3QgYmUgc2VyaWFsaXplZC4gU3VjaCB2YWx1ZXMgaW4gb2JqZWN0cyB3aWxsIGJlXG4vLyAgICAgICAgICBkcm9wcGVkOyBpbiBhcnJheXMgdGhleSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggbnVsbC4gWW91IGNhbiB1c2Vcbi8vICAgICAgICAgIGEgcmVwbGFjZXIgZnVuY3Rpb24gdG8gcmVwbGFjZSB0aG9zZSB3aXRoIEpTT04gdmFsdWVzLlxuXG4vLyAgICAgICAgICBKU09OLnN0cmluZ2lmeSh1bmRlZmluZWQpIHJldHVybnMgdW5kZWZpbmVkLlxuXG4vLyAgICAgICAgICBUaGUgb3B0aW9uYWwgc3BhY2UgcGFyYW1ldGVyIHByb2R1Y2VzIGEgc3RyaW5naWZpY2F0aW9uIG9mIHRoZVxuLy8gICAgICAgICAgdmFsdWUgdGhhdCBpcyBmaWxsZWQgd2l0aCBsaW5lIGJyZWFrcyBhbmQgaW5kZW50YXRpb24gdG8gbWFrZSBpdFxuLy8gICAgICAgICAgZWFzaWVyIHRvIHJlYWQuXG5cbi8vICAgICAgICAgIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBub24tZW1wdHkgc3RyaW5nLCB0aGVuIHRoYXQgc3RyaW5nIHdpbGxcbi8vICAgICAgICAgIGJlIHVzZWQgZm9yIGluZGVudGF0aW9uLiBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCB0aGVuXG4vLyAgICAgICAgICB0aGUgaW5kZW50YXRpb24gd2lsbCBiZSB0aGF0IG1hbnkgc3BhY2VzLlxuXG4vLyAgICAgICAgICBFeGFtcGxlOlxuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW1wiZVwiLCB7cGx1cmlidXM6IFwidW51bVwifV0pO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1wiZVwiLHtcInBsdXJpYnVzXCI6XCJ1bnVtXCJ9XSdcblxuLy8gICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtcImVcIiwge3BsdXJpYnVzOiBcInVudW1cIn1dLCBudWxsLCBcIlxcdFwiKTtcbi8vICAgICAgICAgIC8vIHRleHQgaXMgJ1tcXG5cXHRcImVcIixcXG5cXHR7XFxuXFx0XFx0XCJwbHVyaWJ1c1wiOiBcInVudW1cIlxcblxcdH1cXG5dJ1xuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW25ldyBEYXRlKCldLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV0gaW5zdGFuY2VvZiBEYXRlXG4vLyAgICAgICAgICAgICAgICAgID8gXCJEYXRlKFwiICsgdGhpc1trZXldICsgXCIpXCJcbi8vICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbi8vICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1wiRGF0ZSgtLS1jdXJyZW50IHRpbWUtLS0pXCJdJ1xuXG4vLyAgICAgIEpTT04ucGFyc2UodGV4dCwgcmV2aXZlcilcbi8vICAgICAgICAgIFRoaXMgbWV0aG9kIHBhcnNlcyBhIEpTT04gdGV4dCB0byBwcm9kdWNlIGFuIG9iamVjdCBvciBhcnJheS5cbi8vICAgICAgICAgIEl0IGNhbiB0aHJvdyBhIFN5bnRheEVycm9yIGV4Y2VwdGlvbi5cblxuLy8gICAgICAgICAgVGhlIG9wdGlvbmFsIHJldml2ZXIgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24gdGhhdCBjYW4gZmlsdGVyIGFuZFxuLy8gICAgICAgICAgdHJhbnNmb3JtIHRoZSByZXN1bHRzLiBJdCByZWNlaXZlcyBlYWNoIG9mIHRoZSBrZXlzIGFuZCB2YWx1ZXMsXG4vLyAgICAgICAgICBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyB1c2VkIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIHZhbHVlLlxuLy8gICAgICAgICAgSWYgaXQgcmV0dXJucyB3aGF0IGl0IHJlY2VpdmVkLCB0aGVuIHRoZSBzdHJ1Y3R1cmUgaXMgbm90IG1vZGlmaWVkLlxuLy8gICAgICAgICAgSWYgaXQgcmV0dXJucyB1bmRlZmluZWQgdGhlbiB0aGUgbWVtYmVyIGlzIGRlbGV0ZWQuXG5cbi8vICAgICAgICAgIEV4YW1wbGU6XG5cbi8vICAgICAgICAgIC8vIFBhcnNlIHRoZSB0ZXh0LiBWYWx1ZXMgdGhhdCBsb29rIGxpa2UgSVNPIGRhdGUgc3RyaW5ncyB3aWxsXG4vLyAgICAgICAgICAvLyBiZSBjb252ZXJ0ZWQgdG8gRGF0ZSBvYmplY3RzLlxuXG4vLyAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKHRleHQsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgdmFyIGE7XG4vLyAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuLy8gICAgICAgICAgICAgICAgICBhID1cbi8vICAgL14oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KVQoXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KD86XFwuXFxkKik/KVokLy5leGVjKHZhbHVlKTtcbi8vICAgICAgICAgICAgICAgICAgaWYgKGEpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygrYVsxXSwgK2FbMl0gLSAxLCArYVszXSwgK2FbNF0sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgK2FbNV0sICthWzZdKSk7XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuLy8gICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UoJ1tcIkRhdGUoMDkvMDkvMjAwMSlcIl0nLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHZhciBkO1xuLy8gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbi8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIDUpID09PSBcIkRhdGUoXCIgJiZcbi8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKC0xKSA9PT0gXCIpXCIpIHtcbi8vICAgICAgICAgICAgICAgICAgZCA9IG5ldyBEYXRlKHZhbHVlLnNsaWNlKDUsIC0xKSk7XG4vLyAgICAgICAgICAgICAgICAgIGlmIChkKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbi8vICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4vLyAgICAgICAgICB9KTtcblxuLy8gIFRoaXMgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uIFlvdSBhcmUgZnJlZSB0byBjb3B5LCBtb2RpZnksIG9yXG4vLyAgcmVkaXN0cmlidXRlLlxuXG4vKmpzbGludFxuICAgIGV2YWwsIGZvciwgdGhpc1xuKi9cblxuLypwcm9wZXJ0eVxuICAgIEpTT04sIGFwcGx5LCBjYWxsLCBjaGFyQ29kZUF0LCBnZXRVVENEYXRlLCBnZXRVVENGdWxsWWVhciwgZ2V0VVRDSG91cnMsXG4gICAgZ2V0VVRDTWludXRlcywgZ2V0VVRDTW9udGgsIGdldFVUQ1NlY29uZHMsIGhhc093blByb3BlcnR5LCBqb2luLFxuICAgIGxhc3RJbmRleCwgbGVuZ3RoLCBwYXJzZSwgcHJvdG90eXBlLCBwdXNoLCByZXBsYWNlLCBzbGljZSwgc3RyaW5naWZ5LFxuICAgIHRlc3QsIHRvSlNPTiwgdG9TdHJpbmcsIHZhbHVlT2ZcbiovXG5cblxuLy8gQ3JlYXRlIGEgSlNPTiBvYmplY3Qgb25seSBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC4gV2UgY3JlYXRlIHRoZVxuLy8gbWV0aG9kcyBpbiBhIGNsb3N1cmUgdG8gYXZvaWQgY3JlYXRpbmcgZ2xvYmFsIHZhcmlhYmxlcy5cblxuaWYgKHR5cGVvZiBKU09OICE9PSBcIm9iamVjdFwiKSB7XG4gICAgSlNPTiA9IHt9O1xufVxuXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHJ4X29uZSA9IC9eW1xcXSw6e31cXHNdKiQvO1xuICAgIHZhciByeF90d28gPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xuICAgIHZhciByeF90aHJlZSA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbiAgICB2YXIgcnhfZm91ciA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcbiAgICB2YXIgcnhfZXNjYXBhYmxlID0gL1tcXFxcXCJcXHUwMDAwLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZztcbiAgICB2YXIgcnhfZGFuZ2Vyb3VzID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2c7XG5cbiAgICBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbiAgICAgICAgcmV0dXJuIG4gPCAxMFxuICAgICAgICAgICAgPyBcIjBcIiArIG5cbiAgICAgICAgICAgIDogbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aGlzX3ZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0pTT04gIT09IFwiZnVuY3Rpb25cIikge1xuXG4gICAgICAgIERhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHRoaXMudmFsdWVPZigpKVxuICAgICAgICAgICAgICAgID8gdGhpcy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArIFwiLVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICsgXCJUXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICsgXCI6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSArIFwiWlwiXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIEJvb2xlYW4ucHJvdG90eXBlLnRvSlNPTiA9IHRoaXNfdmFsdWU7XG4gICAgICAgIE51bWJlci5wcm90b3R5cGUudG9KU09OID0gdGhpc192YWx1ZTtcbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS50b0pTT04gPSB0aGlzX3ZhbHVlO1xuICAgIH1cblxuICAgIHZhciBnYXA7XG4gICAgdmFyIGluZGVudDtcbiAgICB2YXIgbWV0YTtcbiAgICB2YXIgcmVwO1xuXG5cbiAgICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcblxuLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbi8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuLy8gc2VxdWVuY2VzLlxuXG4gICAgICAgIHJ4X2VzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gcnhfZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKVxuICAgICAgICAgICAgPyBcIlxcXCJcIiArIHN0cmluZy5yZXBsYWNlKHJ4X2VzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgID8gY1xuICAgICAgICAgICAgICAgICAgICA6IFwiXFxcXHVcIiArIChcIjAwMDBcIiArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgICAgIH0pICsgXCJcXFwiXCJcbiAgICAgICAgICAgIDogXCJcXFwiXCIgKyBzdHJpbmcgKyBcIlxcXCJcIjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuXG4vLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG5cbiAgICAgICAgdmFyIGk7ICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgIHZhciBrOyAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgdmFyIHY7ICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIHZhciBtaW5kID0gZ2FwO1xuICAgICAgICB2YXIgcGFydGlhbDtcbiAgICAgICAgdmFyIHZhbHVlID0gaG9sZGVyW2tleV07XG5cbi8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICAgIH1cblxuLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4vLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodHlwZW9mIHJlcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cblxuLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuXG4vLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cblxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgICAgIDogXCJudWxsXCI7XG5cbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcIm51bGxcIjpcblxuLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSBcIm51bGxcIi4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cblxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbi8vIElmIHRoZSB0eXBlIGlzIFwib2JqZWN0XCIsIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgb3Jcbi8vIG51bGwuXG5cbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuXG4vLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIixcbi8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgICAgfVxuXG4vLyBNYWtlIGFuIGFycmF5IHRvIGhvbGQgdGhlIHBhcnRpYWwgcmVzdWx0cyBvZiBzdHJpbmdpZnlpbmcgdGhpcyBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG5cbi8vIElzIHRoZSB2YWx1ZSBhbiBhcnJheT9cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcblxuLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgXCJudWxsXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuLy8gYnJhY2tldHMuXG5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBcIltdXCJcbiAgICAgICAgICAgICAgICAgICAgOiBnYXBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJbXFxuXCIgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oXCIsXFxuXCIgKyBnYXApICsgXCJcXG5cIiArIG1pbmQgKyBcIl1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIltcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmUgc3RyaW5naWZpZWQuXG5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwW2ldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiOiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjpcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbi8vIE90aGVyd2lzZSwgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuXG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCI6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiOlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4vLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4vLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgPyBcInt9XCJcbiAgICAgICAgICAgICAgICA6IGdhcFxuICAgICAgICAgICAgICAgICAgICA/IFwie1xcblwiICsgZ2FwICsgcGFydGlhbC5qb2luKFwiLFxcblwiICsgZ2FwKSArIFwiXFxuXCIgKyBtaW5kICsgXCJ9XCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIntcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIn1cIjtcbiAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgc3RyaW5naWZ5IG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04uc3RyaW5naWZ5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgICAgIFwiXFxiXCI6IFwiXFxcXGJcIixcbiAgICAgICAgICAgIFwiXFx0XCI6IFwiXFxcXHRcIixcbiAgICAgICAgICAgIFwiXFxuXCI6IFwiXFxcXG5cIixcbiAgICAgICAgICAgIFwiXFxmXCI6IFwiXFxcXGZcIixcbiAgICAgICAgICAgIFwiXFxyXCI6IFwiXFxcXHJcIixcbiAgICAgICAgICAgIFwiXFxcIlwiOiBcIlxcXFxcXFwiXCIsXG4gICAgICAgICAgICBcIlxcXFxcIjogXCJcXFxcXFxcXFwiXG4gICAgICAgIH07XG4gICAgICAgIEpTT04uc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcblxuLy8gVGhlIHN0cmluZ2lmeSBtZXRob2QgdGFrZXMgYSB2YWx1ZSBhbmQgYW4gb3B0aW9uYWwgcmVwbGFjZXIsIGFuZCBhbiBvcHRpb25hbFxuLy8gc3BhY2UgcGFyYW1ldGVyLCBhbmQgcmV0dXJucyBhIEpTT04gdGV4dC4gVGhlIHJlcGxhY2VyIGNhbiBiZSBhIGZ1bmN0aW9uXG4vLyB0aGF0IGNhbiByZXBsYWNlIHZhbHVlcywgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IHdpbGwgc2VsZWN0IHRoZSBrZXlzLlxuLy8gQSBkZWZhdWx0IHJlcGxhY2VyIG1ldGhvZCBjYW4gYmUgcHJvdmlkZWQuIFVzZSBvZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGNhblxuLy8gcHJvZHVjZSB0ZXh0IHRoYXQgaXMgbW9yZSBlYXNpbHkgcmVhZGFibGUuXG5cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZ2FwID0gXCJcIjtcbiAgICAgICAgICAgIGluZGVudCA9IFwiXCI7XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbi8vIG1hbnkgc3BhY2VzLlxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwYWNlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4vLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuXG4gICAgICAgICAgICByZXAgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHJlcGxhY2VyICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09IFwibnVtYmVyXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSlNPTi5zdHJpbmdpZnlcIik7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgXCJcIi5cbi8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG5cbiAgICAgICAgICAgIHJldHVybiBzdHIoXCJcIiwge1wiXCI6IHZhbHVlfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbi8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHBhcnNlIG1ldGhvZCwgZ2l2ZSBpdCBvbmUuXG5cbiAgICBpZiAodHlwZW9mIEpTT04ucGFyc2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBKU09OLnBhcnNlID0gZnVuY3Rpb24gKHRleHQsIHJldml2ZXIpIHtcblxuLy8gVGhlIHBhcnNlIG1ldGhvZCB0YWtlcyBhIHRleHQgYW5kIGFuIG9wdGlvbmFsIHJldml2ZXIgZnVuY3Rpb24sIGFuZCByZXR1cm5zXG4vLyBhIEphdmFTY3JpcHQgdmFsdWUgaWYgdGhlIHRleHQgaXMgYSB2YWxpZCBKU09OIHRleHQuXG5cbiAgICAgICAgICAgIHZhciBqO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG5cbi8vIFRoZSB3YWxrIG1ldGhvZCBpcyB1c2VkIHRvIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIHJlc3VsdGluZyBzdHJ1Y3R1cmUgc29cbi8vIHRoYXQgbW9kaWZpY2F0aW9ucyBjYW4gYmUgbWFkZS5cblxuICAgICAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgICAgIHZhciB2O1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuXG4vLyBQYXJzaW5nIGhhcHBlbnMgaW4gZm91ciBzdGFnZXMuIEluIHRoZSBmaXJzdCBzdGFnZSwgd2UgcmVwbGFjZSBjZXJ0YWluXG4vLyBVbmljb2RlIGNoYXJhY3RlcnMgd2l0aCBlc2NhcGUgc2VxdWVuY2VzLiBKYXZhU2NyaXB0IGhhbmRsZXMgbWFueSBjaGFyYWN0ZXJzXG4vLyBpbmNvcnJlY3RseSwgZWl0aGVyIHNpbGVudGx5IGRlbGV0aW5nIHRoZW0sIG9yIHRyZWF0aW5nIHRoZW0gYXMgbGluZSBlbmRpbmdzLlxuXG4gICAgICAgICAgICB0ZXh0ID0gU3RyaW5nKHRleHQpO1xuICAgICAgICAgICAgcnhfZGFuZ2Vyb3VzLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAocnhfZGFuZ2Vyb3VzLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJ4X2Rhbmdlcm91cywgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHVcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiMDAwMFwiICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4vLyBJbiB0aGUgc2Vjb25kIHN0YWdlLCB3ZSBydW4gdGhlIHRleHQgYWdhaW5zdCByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbG9va1xuLy8gZm9yIG5vbi1KU09OIHBhdHRlcm5zLiBXZSBhcmUgZXNwZWNpYWxseSBjb25jZXJuZWQgd2l0aCBcIigpXCIgYW5kIFwibmV3XCJcbi8vIGJlY2F1c2UgdGhleSBjYW4gY2F1c2UgaW52b2NhdGlvbiwgYW5kIFwiPVwiIGJlY2F1c2UgaXQgY2FuIGNhdXNlIG11dGF0aW9uLlxuLy8gQnV0IGp1c3QgdG8gYmUgc2FmZSwgd2Ugd2FudCB0byByZWplY3QgYWxsIHVuZXhwZWN0ZWQgZm9ybXMuXG5cbi8vIFdlIHNwbGl0IHRoZSBzZWNvbmQgc3RhZ2UgaW50byA0IHJlZ2V4cCBvcGVyYXRpb25zIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kXG4vLyBjcmlwcGxpbmcgaW5lZmZpY2llbmNpZXMgaW4gSUUncyBhbmQgU2FmYXJpJ3MgcmVnZXhwIGVuZ2luZXMuIEZpcnN0IHdlXG4vLyByZXBsYWNlIHRoZSBKU09OIGJhY2tzbGFzaCBwYWlycyB3aXRoIFwiQFwiIChhIG5vbi1KU09OIGNoYXJhY3RlcikuIFNlY29uZCwgd2Vcbi8vIHJlcGxhY2UgYWxsIHNpbXBsZSB2YWx1ZSB0b2tlbnMgd2l0aCBcIl1cIiBjaGFyYWN0ZXJzLiBUaGlyZCwgd2UgZGVsZXRlIGFsbFxuLy8gb3BlbiBicmFja2V0cyB0aGF0IGZvbGxvdyBhIGNvbG9uIG9yIGNvbW1hIG9yIHRoYXQgYmVnaW4gdGhlIHRleHQuIEZpbmFsbHksXG4vLyB3ZSBsb29rIHRvIHNlZSB0aGF0IHRoZSByZW1haW5pbmcgY2hhcmFjdGVycyBhcmUgb25seSB3aGl0ZXNwYWNlIG9yIFwiXVwiIG9yXG4vLyBcIixcIiBvciBcIjpcIiBvciBcIntcIiBvciBcIn1cIi4gSWYgdGhhdCBpcyBzbywgdGhlbiB0aGUgdGV4dCBpcyBzYWZlIGZvciBldmFsLlxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcnhfb25lLnRlc3QoXG4gICAgICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJ4X3R3bywgXCJAXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyeF90aHJlZSwgXCJdXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyeF9mb3VyLCBcIlwiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuXG4vLyBJbiB0aGUgdGhpcmQgc3RhZ2Ugd2UgdXNlIHRoZSBldmFsIGZ1bmN0aW9uIHRvIGNvbXBpbGUgdGhlIHRleHQgaW50byBhXG4vLyBKYXZhU2NyaXB0IHN0cnVjdHVyZS4gVGhlIFwie1wiIG9wZXJhdG9yIGlzIHN1YmplY3QgdG8gYSBzeW50YWN0aWMgYW1iaWd1aXR5XG4vLyBpbiBKYXZhU2NyaXB0OiBpdCBjYW4gYmVnaW4gYSBibG9jayBvciBhbiBvYmplY3QgbGl0ZXJhbC4gV2Ugd3JhcCB0aGUgdGV4dFxuLy8gaW4gcGFyZW5zIHRvIGVsaW1pbmF0ZSB0aGUgYW1iaWd1aXR5LlxuXG4gICAgICAgICAgICAgICAgaiA9IGV2YWwoXCIoXCIgKyB0ZXh0ICsgXCIpXCIpO1xuXG4vLyBJbiB0aGUgb3B0aW9uYWwgZm91cnRoIHN0YWdlLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLCBwYXNzaW5nXG4vLyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byBhIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlIHRyYW5zZm9ybWF0aW9uLlxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgcmV2aXZlciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICA/IHdhbGsoe1wiXCI6IGp9LCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICA6IGo7XG4gICAgICAgICAgICB9XG5cbi8vIElmIHRoZSB0ZXh0IGlzIG5vdCBKU09OIHBhcnNlYWJsZSwgdGhlbiBhIFN5bnRheEVycm9yIGlzIHRocm93bi5cblxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiSlNPTi5wYXJzZVwiKTtcbiAgICAgICAgfTtcbiAgICB9XG59KCkpOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbnZhciBzbGljZSA9IHV0aWwuc2xpY2VcbnZhciBwbHVjayA9IHV0aWwucGx1Y2tcbnZhciBlYWNoID0gdXRpbC5lYWNoXG52YXIgYmluZCA9IHV0aWwuYmluZFxudmFyIGNyZWF0ZSA9IHV0aWwuY3JlYXRlXG52YXIgaXNMaXN0ID0gdXRpbC5pc0xpc3RcbnZhciBpc0Z1bmN0aW9uID0gdXRpbC5pc0Z1bmN0aW9uXG52YXIgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRjcmVhdGVTdG9yZTogY3JlYXRlU3RvcmVcbn1cblxudmFyIHN0b3JlQVBJID0ge1xuXHR2ZXJzaW9uOiAnMi4wLjEyJyxcblx0ZW5hYmxlZDogZmFsc2UsXG5cdFxuXHQvLyBnZXQgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGtleS4gSWYgdGhhdCB2YWx1ZVxuXHQvLyBpcyB1bmRlZmluZWQsIGl0IHJldHVybnMgb3B0aW9uYWxEZWZhdWx0VmFsdWUgaW5zdGVhZC5cblx0Z2V0OiBmdW5jdGlvbihrZXksIG9wdGlvbmFsRGVmYXVsdFZhbHVlKSB7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLnN0b3JhZ2UucmVhZCh0aGlzLl9uYW1lc3BhY2VQcmVmaXggKyBrZXkpXG5cdFx0cmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplKGRhdGEsIG9wdGlvbmFsRGVmYXVsdFZhbHVlKVxuXHR9LFxuXG5cdC8vIHNldCB3aWxsIHN0b3JlIHRoZSBnaXZlbiB2YWx1ZSBhdCBrZXkgYW5kIHJldHVybnMgdmFsdWUuXG5cdC8vIENhbGxpbmcgc2V0IHdpdGggdmFsdWUgPT09IHVuZGVmaW5lZCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgcmVtb3ZlLlxuXHRzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVtb3ZlKGtleSlcblx0XHR9XG5cdFx0dGhpcy5zdG9yYWdlLndyaXRlKHRoaXMuX25hbWVzcGFjZVByZWZpeCArIGtleSwgdGhpcy5fc2VyaWFsaXplKHZhbHVlKSlcblx0XHRyZXR1cm4gdmFsdWVcblx0fSxcblxuXHQvLyByZW1vdmUgZGVsZXRlcyB0aGUga2V5IGFuZCB2YWx1ZSBzdG9yZWQgYXQgdGhlIGdpdmVuIGtleS5cblx0cmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcblx0XHR0aGlzLnN0b3JhZ2UucmVtb3ZlKHRoaXMuX25hbWVzcGFjZVByZWZpeCArIGtleSlcblx0fSxcblxuXHQvLyBlYWNoIHdpbGwgY2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBrZXktdmFsdWUgcGFpclxuXHQvLyBpbiB0aGlzIHN0b3JlLlxuXHRlYWNoOiBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdHZhciBzZWxmID0gdGhpc1xuXHRcdHRoaXMuc3RvcmFnZS5lYWNoKGZ1bmN0aW9uKHZhbCwgbmFtZXNwYWNlZEtleSkge1xuXHRcdFx0Y2FsbGJhY2suY2FsbChzZWxmLCBzZWxmLl9kZXNlcmlhbGl6ZSh2YWwpLCAobmFtZXNwYWNlZEtleSB8fCAnJykucmVwbGFjZShzZWxmLl9uYW1lc3BhY2VSZWdleHAsICcnKSlcblx0XHR9KVxuXHR9LFxuXG5cdC8vIGNsZWFyQWxsIHdpbGwgcmVtb3ZlIGFsbCB0aGUgc3RvcmVkIGtleS12YWx1ZSBwYWlycyBpbiB0aGlzIHN0b3JlLlxuXHRjbGVhckFsbDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9yYWdlLmNsZWFyQWxsKClcblx0fSxcblxuXHQvLyBhZGRpdGlvbmFsIGZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4ndCBsaXZlIGluIHBsdWdpbnNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0Ly8gaGFzTmFtZXNwYWNlIHJldHVybnMgdHJ1ZSBpZiB0aGlzIHN0b3JlIGluc3RhbmNlIGhhcyB0aGUgZ2l2ZW4gbmFtZXNwYWNlLlxuXHRoYXNOYW1lc3BhY2U6IGZ1bmN0aW9uKG5hbWVzcGFjZSkge1xuXHRcdHJldHVybiAodGhpcy5fbmFtZXNwYWNlUHJlZml4ID09ICdfX3N0b3JlanNfJytuYW1lc3BhY2UrJ18nKVxuXHR9LFxuXG5cdC8vIGNyZWF0ZVN0b3JlIGNyZWF0ZXMgYSBzdG9yZS5qcyBpbnN0YW5jZSB3aXRoIHRoZSBmaXJzdFxuXHQvLyBmdW5jdGlvbmluZyBzdG9yYWdlIGluIHRoZSBsaXN0IG9mIHN0b3JhZ2UgY2FuZGlkYXRlcyxcblx0Ly8gYW5kIGFwcGxpZXMgdGhlIHRoZSBnaXZlbiBtaXhpbnMgdG8gdGhlIGluc3RhbmNlLlxuXHRjcmVhdGVTdG9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZVN0b3JlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblx0fSxcblx0XG5cdGFkZFBsdWdpbjogZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0dGhpcy5fYWRkUGx1Z2luKHBsdWdpbilcblx0fSxcblx0XG5cdG5hbWVzcGFjZTogZnVuY3Rpb24obmFtZXNwYWNlKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZVN0b3JlKHRoaXMuc3RvcmFnZSwgdGhpcy5wbHVnaW5zLCBuYW1lc3BhY2UpXG5cdH1cbn1cblxuZnVuY3Rpb24gX3dhcm4oKSB7XG5cdHZhciBfY29uc29sZSA9ICh0eXBlb2YgY29uc29sZSA9PSAndW5kZWZpbmVkJyA/IG51bGwgOiBjb25zb2xlKVxuXHRpZiAoIV9jb25zb2xlKSB7IHJldHVybiB9XG5cdHZhciBmbiA9IChfY29uc29sZS53YXJuID8gX2NvbnNvbGUud2FybiA6IF9jb25zb2xlLmxvZylcblx0Zm4uYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RvcmUoc3RvcmFnZXMsIHBsdWdpbnMsIG5hbWVzcGFjZSkge1xuXHRpZiAoIW5hbWVzcGFjZSkge1xuXHRcdG5hbWVzcGFjZSA9ICcnXG5cdH1cblx0aWYgKHN0b3JhZ2VzICYmICFpc0xpc3Qoc3RvcmFnZXMpKSB7XG5cdFx0c3RvcmFnZXMgPSBbc3RvcmFnZXNdXG5cdH1cblx0aWYgKHBsdWdpbnMgJiYgIWlzTGlzdChwbHVnaW5zKSkge1xuXHRcdHBsdWdpbnMgPSBbcGx1Z2luc11cblx0fVxuXG5cdHZhciBuYW1lc3BhY2VQcmVmaXggPSAobmFtZXNwYWNlID8gJ19fc3RvcmVqc18nK25hbWVzcGFjZSsnXycgOiAnJylcblx0dmFyIG5hbWVzcGFjZVJlZ2V4cCA9IChuYW1lc3BhY2UgPyBuZXcgUmVnRXhwKCdeJytuYW1lc3BhY2VQcmVmaXgpIDogbnVsbClcblx0dmFyIGxlZ2FsTmFtZXNwYWNlcyA9IC9eW2EtekEtWjAtOV9cXC1dKiQvIC8vIGFscGhhLW51bWVyaWMgKyB1bmRlcnNjb3JlIGFuZCBkYXNoXG5cdGlmICghbGVnYWxOYW1lc3BhY2VzLnRlc3QobmFtZXNwYWNlKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignc3RvcmUuanMgbmFtZXNwYWNlcyBjYW4gb25seSBoYXZlIGFscGhhbnVtZXJpY3MgKyB1bmRlcnNjb3JlcyBhbmQgZGFzaGVzJylcblx0fVxuXHRcblx0dmFyIF9wcml2YXRlU3RvcmVQcm9wcyA9IHtcblx0XHRfbmFtZXNwYWNlUHJlZml4OiBuYW1lc3BhY2VQcmVmaXgsXG5cdFx0X25hbWVzcGFjZVJlZ2V4cDogbmFtZXNwYWNlUmVnZXhwLFxuXG5cdFx0X3Rlc3RTdG9yYWdlOiBmdW5jdGlvbihzdG9yYWdlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgdGVzdFN0ciA9ICdfX3N0b3JlanNfX3Rlc3RfXydcblx0XHRcdFx0c3RvcmFnZS53cml0ZSh0ZXN0U3RyLCB0ZXN0U3RyKVxuXHRcdFx0XHR2YXIgb2sgPSAoc3RvcmFnZS5yZWFkKHRlc3RTdHIpID09PSB0ZXN0U3RyKVxuXHRcdFx0XHRzdG9yYWdlLnJlbW92ZSh0ZXN0U3RyKVxuXHRcdFx0XHRyZXR1cm4gb2tcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2Fzc2lnblBsdWdpbkZuUHJvcDogZnVuY3Rpb24ocGx1Z2luRm5Qcm9wLCBwcm9wTmFtZSkge1xuXHRcdFx0dmFyIG9sZEZuID0gdGhpc1twcm9wTmFtZV1cblx0XHRcdHRoaXNbcHJvcE5hbWVdID0gZnVuY3Rpb24gcGx1Z2luRm4oKSB7XG5cdFx0XHRcdHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAwKVxuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXNcblxuXHRcdFx0XHQvLyBzdXBlcl9mbiBjYWxscyB0aGUgb2xkIGZ1bmN0aW9uIHdoaWNoIHdhcyBvdmVyd3JpdHRlbiBieVxuXHRcdFx0XHQvLyB0aGlzIG1peGluLlxuXHRcdFx0XHRmdW5jdGlvbiBzdXBlcl9mbigpIHtcblx0XHRcdFx0XHRpZiAoIW9sZEZuKSB7IHJldHVybiB9XG5cdFx0XHRcdFx0ZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKGFyZywgaSkge1xuXHRcdFx0XHRcdFx0YXJnc1tpXSA9IGFyZ1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0cmV0dXJuIG9sZEZuLmFwcGx5KHNlbGYsIGFyZ3MpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHaXZlIG1peGluZyBmdW5jdGlvbiBhY2Nlc3MgdG8gc3VwZXJfZm4gYnkgcHJlZml4aW5nIGFsbCBtaXhpbiBmdW5jdGlvblxuXHRcdFx0XHQvLyBhcmd1bWVudHMgd2l0aCBzdXBlcl9mbi5cblx0XHRcdFx0dmFyIG5ld0ZuQXJncyA9IFtzdXBlcl9mbl0uY29uY2F0KGFyZ3MpXG5cblx0XHRcdFx0cmV0dXJuIHBsdWdpbkZuUHJvcC5hcHBseShzZWxmLCBuZXdGbkFyZ3MpXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iailcblx0XHR9LFxuXG5cdFx0X2Rlc2VyaWFsaXplOiBmdW5jdGlvbihzdHJWYWwsIGRlZmF1bHRWYWwpIHtcblx0XHRcdGlmICghc3RyVmFsKSB7IHJldHVybiBkZWZhdWx0VmFsIH1cblx0XHRcdC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgYSByYXcgc3RyaW5nIHZhbHVlIGhhcyBiZWVuIHByZXZpb3VzbHkgc3RvcmVkXG5cdFx0XHQvLyBpbiBhIHN0b3JhZ2Ugd2l0aG91dCB1c2luZyBzdG9yZS5qcywgbWVhbmluZyBpdCB3aWxsIGJlIGEgcmF3XG5cdFx0XHQvLyBzdHJpbmcgdmFsdWUgaW5zdGVhZCBvZiBhIEpTT04gc2VyaWFsaXplZCBzdHJpbmcuIEJ5IGRlZmF1bHRpbmdcblx0XHRcdC8vIHRvIHRoZSByYXcgc3RyaW5nIHZhbHVlIGluIGNhc2Ugb2YgYSBKU09OIHBhcnNlIGVycm9yLCB3ZSBhbGxvd1xuXHRcdFx0Ly8gZm9yIHBhc3Qgc3RvcmVkIHZhbHVlcyB0byBiZSBmb3J3YXJkcy1jb21wYXRpYmxlIHdpdGggc3RvcmUuanNcblx0XHRcdHZhciB2YWwgPSAnJ1xuXHRcdFx0dHJ5IHsgdmFsID0gSlNPTi5wYXJzZShzdHJWYWwpIH1cblx0XHRcdGNhdGNoKGUpIHsgdmFsID0gc3RyVmFsIH1cblxuXHRcdFx0cmV0dXJuICh2YWwgIT09IHVuZGVmaW5lZCA/IHZhbCA6IGRlZmF1bHRWYWwpXG5cdFx0fSxcblx0XHRcblx0XHRfYWRkU3RvcmFnZTogZnVuY3Rpb24oc3RvcmFnZSkge1xuXHRcdFx0aWYgKHRoaXMuZW5hYmxlZCkgeyByZXR1cm4gfVxuXHRcdFx0aWYgKHRoaXMuX3Rlc3RTdG9yYWdlKHN0b3JhZ2UpKSB7XG5cdFx0XHRcdHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2Vcblx0XHRcdFx0dGhpcy5lbmFibGVkID0gdHJ1ZVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfYWRkUGx1Z2luOiBmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdHZhciBzZWxmID0gdGhpc1xuXG5cdFx0XHQvLyBJZiB0aGUgcGx1Z2luIGlzIGFuIGFycmF5LCB0aGVuIGFkZCBhbGwgcGx1Z2lucyBpbiB0aGUgYXJyYXkuXG5cdFx0XHQvLyBUaGlzIGFsbG93cyBmb3IgYSBwbHVnaW4gdG8gZGVwZW5kIG9uIG90aGVyIHBsdWdpbnMuXG5cdFx0XHRpZiAoaXNMaXN0KHBsdWdpbikpIHtcblx0XHRcdFx0ZWFjaChwbHVnaW4sIGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0XHRcdHNlbGYuX2FkZFBsdWdpbihwbHVnaW4pXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIGFsbCBwbHVnaW5zIHdlJ3ZlIHNlZW4gc28gZmFyLCBzbyB0aGF0IHdlXG5cdFx0XHQvLyBkb24ndCBhZGQgYW55IG9mIHRoZW0gdHdpY2UuXG5cdFx0XHR2YXIgc2VlblBsdWdpbiA9IHBsdWNrKHRoaXMucGx1Z2lucywgZnVuY3Rpb24oc2VlblBsdWdpbikge1xuXHRcdFx0XHRyZXR1cm4gKHBsdWdpbiA9PT0gc2VlblBsdWdpbilcblx0XHRcdH0pXG5cdFx0XHRpZiAoc2VlblBsdWdpbikge1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHRoaXMucGx1Z2lucy5wdXNoKHBsdWdpbilcblxuXHRcdFx0Ly8gQ2hlY2sgdGhhdCB0aGUgcGx1Z2luIGlzIHByb3Blcmx5IGZvcm1lZFxuXHRcdFx0aWYgKCFpc0Z1bmN0aW9uKHBsdWdpbikpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQbHVnaW5zIG11c3QgYmUgZnVuY3Rpb24gdmFsdWVzIHRoYXQgcmV0dXJuIG9iamVjdHMnKVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGx1Z2luUHJvcGVydGllcyA9IHBsdWdpbi5jYWxsKHRoaXMpXG5cdFx0XHRpZiAoIWlzT2JqZWN0KHBsdWdpblByb3BlcnRpZXMpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUGx1Z2lucyBtdXN0IHJldHVybiBhbiBvYmplY3Qgb2YgZnVuY3Rpb24gcHJvcGVydGllcycpXG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0aGUgcGx1Z2luIGZ1bmN0aW9uIHByb3BlcnRpZXMgdG8gdGhpcyBzdG9yZSBpbnN0YW5jZS5cblx0XHRcdGVhY2gocGx1Z2luUHJvcGVydGllcywgZnVuY3Rpb24ocGx1Z2luRm5Qcm9wLCBwcm9wTmFtZSkge1xuXHRcdFx0XHRpZiAoIWlzRnVuY3Rpb24ocGx1Z2luRm5Qcm9wKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQmFkIHBsdWdpbiBwcm9wZXJ0eTogJytwcm9wTmFtZSsnIGZyb20gcGx1Z2luICcrcGx1Z2luLm5hbWUrJy4gUGx1Z2lucyBzaG91bGQgb25seSByZXR1cm4gZnVuY3Rpb25zLicpXG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5fYXNzaWduUGx1Z2luRm5Qcm9wKHBsdWdpbkZuUHJvcCwgcHJvcE5hbWUpXG5cdFx0XHR9KVxuXHRcdH0sXG5cdFx0XG5cdFx0Ly8gUHV0IGRlcHJlY2F0ZWQgcHJvcGVydGllcyBpbiB0aGUgcHJpdmF0ZSBBUEksIHNvIGFzIHRvIG5vdCBleHBvc2UgaXQgdG8gYWNjaWRlbnRpYWxcblx0XHQvLyBkaXNjb3ZlcnkgdGhyb3VnaCBpbnNwZWN0aW9uIG9mIHRoZSBzdG9yZSBvYmplY3QuXG5cdFx0XG5cdFx0Ly8gRGVwcmVjYXRlZDogYWRkU3RvcmFnZVxuXHRcdGFkZFN0b3JhZ2U6IGZ1bmN0aW9uKHN0b3JhZ2UpIHtcblx0XHRcdF93YXJuKCdzdG9yZS5hZGRTdG9yYWdlKHN0b3JhZ2UpIGlzIGRlcHJlY2F0ZWQuIFVzZSBjcmVhdGVTdG9yZShbc3RvcmFnZXNdKScpXG5cdFx0XHR0aGlzLl9hZGRTdG9yYWdlKHN0b3JhZ2UpXG5cdFx0fVxuXHR9XG5cblx0dmFyIHN0b3JlID0gY3JlYXRlKF9wcml2YXRlU3RvcmVQcm9wcywgc3RvcmVBUEksIHtcblx0XHRwbHVnaW5zOiBbXVxuXHR9KVxuXHRzdG9yZS5yYXcgPSB7fVxuXHRlYWNoKHN0b3JlLCBmdW5jdGlvbihwcm9wLCBwcm9wTmFtZSkge1xuXHRcdGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG5cdFx0XHRzdG9yZS5yYXdbcHJvcE5hbWVdID0gYmluZChzdG9yZSwgcHJvcClcdFx0XHRcblx0XHR9XG5cdH0pXG5cdGVhY2goc3RvcmFnZXMsIGZ1bmN0aW9uKHN0b3JhZ2UpIHtcblx0XHRzdG9yZS5fYWRkU3RvcmFnZShzdG9yYWdlKVxuXHR9KVxuXHRlYWNoKHBsdWdpbnMsIGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdHN0b3JlLl9hZGRQbHVnaW4ocGx1Z2luKVxuXHR9KVxuXHRyZXR1cm4gc3RvcmVcbn1cbiIsInZhciBhc3NpZ24gPSBtYWtlX2Fzc2lnbigpXG52YXIgY3JlYXRlID0gbWFrZV9jcmVhdGUoKVxudmFyIHRyaW0gPSBtYWtlX3RyaW0oKVxudmFyIEdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGFzc2lnbjogYXNzaWduLFxuXHRjcmVhdGU6IGNyZWF0ZSxcblx0dHJpbTogdHJpbSxcblx0YmluZDogYmluZCxcblx0c2xpY2U6IHNsaWNlLFxuXHRlYWNoOiBlYWNoLFxuXHRtYXA6IG1hcCxcblx0cGx1Y2s6IHBsdWNrLFxuXHRpc0xpc3Q6IGlzTGlzdCxcblx0aXNGdW5jdGlvbjogaXNGdW5jdGlvbixcblx0aXNPYmplY3Q6IGlzT2JqZWN0LFxuXHRHbG9iYWw6IEdsb2JhbFxufVxuXG5mdW5jdGlvbiBtYWtlX2Fzc2lnbigpIHtcblx0aWYgKE9iamVjdC5hc3NpZ24pIHtcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnblxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBmdW5jdGlvbiBzaGltQXNzaWduKG9iaiwgcHJvcHMxLCBwcm9wczIsIGV0Yykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZWFjaChPYmplY3QoYXJndW1lbnRzW2ldKSwgZnVuY3Rpb24odmFsLCBrZXkpIHtcblx0XHRcdFx0XHRvYmpba2V5XSA9IHZhbFxuXHRcdFx0XHR9KVxuXHRcdFx0fVx0XHRcdFxuXHRcdFx0cmV0dXJuIG9ialxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBtYWtlX2NyZWF0ZSgpIHtcblx0aWYgKE9iamVjdC5jcmVhdGUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlKG9iaiwgYXNzaWduUHJvcHMxLCBhc3NpZ25Qcm9wczIsIGV0Yykge1xuXHRcdFx0dmFyIGFzc2lnbkFyZ3NMaXN0ID0gc2xpY2UoYXJndW1lbnRzLCAxKVxuXHRcdFx0cmV0dXJuIGFzc2lnbi5hcHBseSh0aGlzLCBbT2JqZWN0LmNyZWF0ZShvYmopXS5jb25jYXQoYXNzaWduQXJnc0xpc3QpKVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmdW5jdGlvbiBGKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbm5lci1kZWNsYXJhdGlvbnNcblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlKG9iaiwgYXNzaWduUHJvcHMxLCBhc3NpZ25Qcm9wczIsIGV0Yykge1xuXHRcdFx0dmFyIGFzc2lnbkFyZ3NMaXN0ID0gc2xpY2UoYXJndW1lbnRzLCAxKVxuXHRcdFx0Ri5wcm90b3R5cGUgPSBvYmpcblx0XHRcdHJldHVybiBhc3NpZ24uYXBwbHkodGhpcywgW25ldyBGKCldLmNvbmNhdChhc3NpZ25BcmdzTGlzdCkpXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIG1ha2VfdHJpbSgpIHtcblx0aWYgKFN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiB0cmltKHN0cikge1xuXHRcdFx0cmV0dXJuIFN0cmluZy5wcm90b3R5cGUudHJpbS5jYWxsKHN0cilcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJylcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYmluZChvYmosIGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNsaWNlKGFyciwgaW5kZXgpIHtcblx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyciwgaW5kZXggfHwgMClcbn1cblxuZnVuY3Rpb24gZWFjaChvYmosIGZuKSB7XG5cdHBsdWNrKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcblx0XHRmbih2YWwsIGtleSlcblx0XHRyZXR1cm4gZmFsc2Vcblx0fSlcbn1cblxuZnVuY3Rpb24gbWFwKG9iaiwgZm4pIHtcblx0dmFyIHJlcyA9IChpc0xpc3Qob2JqKSA/IFtdIDoge30pXG5cdHBsdWNrKG9iaiwgZnVuY3Rpb24odiwgaykge1xuXHRcdHJlc1trXSA9IGZuKHYsIGspXG5cdFx0cmV0dXJuIGZhbHNlXG5cdH0pXG5cdHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gcGx1Y2sob2JqLCBmbikge1xuXHRpZiAoaXNMaXN0KG9iaikpIHtcblx0XHRmb3IgKHZhciBpPTA7IGk8b2JqLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoZm4ob2JqW2ldLCBpKSkge1xuXHRcdFx0XHRyZXR1cm4gb2JqW2ldXG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRpZiAoZm4ob2JqW2tleV0sIGtleSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqW2tleV1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBpc0xpc3QodmFsKSB7XG5cdHJldHVybiAodmFsICE9IG51bGwgJiYgdHlwZW9mIHZhbCAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWwubGVuZ3RoID09ICdudW1iZXInKVxufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuXHRyZXR1cm4gdmFsICYmIHt9LnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcblx0cmV0dXJuIHZhbCAmJiB7fS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcblx0Ly8gTGlzdGVkIGluIG9yZGVyIG9mIHVzYWdlIHByZWZlcmVuY2Vcblx0cmVxdWlyZSgnLi9sb2NhbFN0b3JhZ2UnKSxcblx0cmVxdWlyZSgnLi9vbGRGRi1nbG9iYWxTdG9yYWdlJyksXG5cdHJlcXVpcmUoJy4vb2xkSUUtdXNlckRhdGFTdG9yYWdlJyksXG5cdHJlcXVpcmUoJy4vY29va2llU3RvcmFnZScpLFxuXHRyZXF1aXJlKCcuL3Nlc3Npb25TdG9yYWdlJyksXG5cdHJlcXVpcmUoJy4vbWVtb3J5U3RvcmFnZScpXG5dXG4iLCIvLyBjb29raWVTdG9yYWdlIGlzIHVzZWZ1bCBTYWZhcmkgcHJpdmF0ZSBicm93c2VyIG1vZGUsIHdoZXJlIGxvY2FsU3RvcmFnZVxuLy8gZG9lc24ndCB3b3JrIGJ1dCBjb29raWVzIGRvLiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGFkb3B0ZWQgZnJvbVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N0b3JhZ2UvTG9jYWxTdG9yYWdlXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKVxudmFyIEdsb2JhbCA9IHV0aWwuR2xvYmFsXG52YXIgdHJpbSA9IHV0aWwudHJpbVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ2Nvb2tpZVN0b3JhZ2UnLFxuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGUsXG5cdGVhY2g6IGVhY2gsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRjbGVhckFsbDogY2xlYXJBbGwsXG59XG5cbnZhciBkb2MgPSBHbG9iYWwuZG9jdW1lbnRcblxuZnVuY3Rpb24gcmVhZChrZXkpIHtcblx0aWYgKCFrZXkgfHwgIV9oYXMoa2V5KSkgeyByZXR1cm4gbnVsbCB9XG5cdHZhciByZWdleHBTdHIgPSBcIig/Ol58Lio7XFxcXHMqKVwiICtcblx0XHRlc2NhcGUoa2V5KS5yZXBsYWNlKC9bXFwtXFwuXFwrXFwqXS9nLCBcIlxcXFwkJlwiKSArXG5cdFx0XCJcXFxccypcXFxcPVxcXFxzKigoPzpbXjtdKD8hOykpKlteO10/KS4qXCJcblx0cmV0dXJuIHVuZXNjYXBlKGRvYy5jb29raWUucmVwbGFjZShuZXcgUmVnRXhwKHJlZ2V4cFN0ciksIFwiJDFcIikpXG59XG5cbmZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcblx0dmFyIGNvb2tpZXMgPSBkb2MuY29va2llLnNwbGl0KC87ID8vZylcblx0Zm9yICh2YXIgaSA9IGNvb2tpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRpZiAoIXRyaW0oY29va2llc1tpXSkpIHtcblx0XHRcdGNvbnRpbnVlXG5cdFx0fVxuXHRcdHZhciBrdnAgPSBjb29raWVzW2ldLnNwbGl0KCc9Jylcblx0XHR2YXIga2V5ID0gdW5lc2NhcGUoa3ZwWzBdKVxuXHRcdHZhciB2YWwgPSB1bmVzY2FwZShrdnBbMV0pXG5cdFx0Y2FsbGJhY2sodmFsLCBrZXkpXG5cdH1cbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBkYXRhKSB7XG5cdGlmKCFrZXkpIHsgcmV0dXJuIH1cblx0ZG9jLmNvb2tpZSA9IGVzY2FwZShrZXkpICsgXCI9XCIgKyBlc2NhcGUoZGF0YSkgKyBcIjsgZXhwaXJlcz1UdWUsIDE5IEphbiAyMDM4IDAzOjE0OjA3IEdNVDsgcGF0aD0vXCJcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuXHRpZiAoIWtleSB8fCAhX2hhcyhrZXkpKSB7XG5cdFx0cmV0dXJuXG5cdH1cblx0ZG9jLmNvb2tpZSA9IGVzY2FwZShrZXkpICsgXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgR01UOyBwYXRoPS9cIlxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0ZWFjaChmdW5jdGlvbihfLCBrZXkpIHtcblx0XHRyZW1vdmUoa2V5KVxuXHR9KVxufVxuXG5mdW5jdGlvbiBfaGFzKGtleSkge1xuXHRyZXR1cm4gKG5ldyBSZWdFeHAoXCIoPzpefDtcXFxccyopXCIgKyBlc2NhcGUoa2V5KS5yZXBsYWNlKC9bXFwtXFwuXFwrXFwqXS9nLCBcIlxcXFwkJlwiKSArIFwiXFxcXHMqXFxcXD1cIikpLnRlc3QoZG9jLmNvb2tpZSlcbn1cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKVxudmFyIEdsb2JhbCA9IHV0aWwuR2xvYmFsXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnbG9jYWxTdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG5mdW5jdGlvbiBsb2NhbFN0b3JhZ2UoKSB7XG5cdHJldHVybiBHbG9iYWwubG9jYWxTdG9yYWdlXG59XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdHJldHVybiBsb2NhbFN0b3JhZ2UoKS5nZXRJdGVtKGtleSlcbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBkYXRhKSB7XG5cdHJldHVybiBsb2NhbFN0b3JhZ2UoKS5zZXRJdGVtKGtleSwgZGF0YSlcbn1cblxuZnVuY3Rpb24gZWFjaChmbikge1xuXHRmb3IgKHZhciBpID0gbG9jYWxTdG9yYWdlKCkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHR2YXIga2V5ID0gbG9jYWxTdG9yYWdlKCkua2V5KGkpXG5cdFx0Zm4ocmVhZChrZXkpLCBrZXkpXG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuXHRyZXR1cm4gbG9jYWxTdG9yYWdlKCkucmVtb3ZlSXRlbShrZXkpXG59XG5cbmZ1bmN0aW9uIGNsZWFyQWxsKCkge1xuXHRyZXR1cm4gbG9jYWxTdG9yYWdlKCkuY2xlYXIoKVxufVxuIiwiLy8gbWVtb3J5U3RvcmFnZSBpcyBhIHVzZWZ1bCBsYXN0IGZhbGxiYWNrIHRvIGVuc3VyZSB0aGF0IHRoZSBzdG9yZVxuLy8gaXMgZnVuY3Rpb25zIChtZWFuaW5nIHN0b3JlLmdldCgpLCBzdG9yZS5zZXQoKSwgZXRjIHdpbGwgYWxsIGZ1bmN0aW9uKS5cbi8vIEhvd2V2ZXIsIHN0b3JlZCB2YWx1ZXMgd2lsbCBub3QgcGVyc2lzdCB3aGVuIHRoZSBicm93c2VyIG5hdmlnYXRlcyB0b1xuLy8gYSBuZXcgcGFnZSBvciByZWxvYWRzIHRoZSBjdXJyZW50IHBhZ2UuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnbWVtb3J5U3RvcmFnZScsXG5cdHJlYWQ6IHJlYWQsXG5cdHdyaXRlOiB3cml0ZSxcblx0ZWFjaDogZWFjaCxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGNsZWFyQWxsOiBjbGVhckFsbCxcbn1cblxudmFyIG1lbW9yeVN0b3JhZ2UgPSB7fVxuXG5mdW5jdGlvbiByZWFkKGtleSkge1xuXHRyZXR1cm4gbWVtb3J5U3RvcmFnZVtrZXldXG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgZGF0YSkge1xuXHRtZW1vcnlTdG9yYWdlW2tleV0gPSBkYXRhXG59XG5cbmZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcblx0Zm9yICh2YXIga2V5IGluIG1lbW9yeVN0b3JhZ2UpIHtcblx0XHRpZiAobWVtb3J5U3RvcmFnZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRjYWxsYmFjayhtZW1vcnlTdG9yYWdlW2tleV0sIGtleSlcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuXHRkZWxldGUgbWVtb3J5U3RvcmFnZVtrZXldXG59XG5cbmZ1bmN0aW9uIGNsZWFyQWxsKGtleSkge1xuXHRtZW1vcnlTdG9yYWdlID0ge31cbn1cbiIsIi8vIG9sZEZGLWdsb2JhbFN0b3JhZ2UgcHJvdmlkZXMgc3RvcmFnZSBmb3IgRmlyZWZveFxuLy8gdmVyc2lvbnMgNiBhbmQgNywgd2hlcmUgbm8gbG9jYWxTdG9yYWdlLCBldGNcbi8vIGlzIGF2YWlsYWJsZS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi9zcmMvdXRpbCcpXG52YXIgR2xvYmFsID0gdXRpbC5HbG9iYWxcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6ICdvbGRGRi1nbG9iYWxTdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG52YXIgZ2xvYmFsU3RvcmFnZSA9IEdsb2JhbC5nbG9iYWxTdG9yYWdlXG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdHJldHVybiBnbG9iYWxTdG9yYWdlW2tleV1cbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBkYXRhKSB7XG5cdGdsb2JhbFN0b3JhZ2Vba2V5XSA9IGRhdGFcbn1cblxuZnVuY3Rpb24gZWFjaChmbikge1xuXHRmb3IgKHZhciBpID0gZ2xvYmFsU3RvcmFnZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdHZhciBrZXkgPSBnbG9iYWxTdG9yYWdlLmtleShpKVxuXHRcdGZuKGdsb2JhbFN0b3JhZ2Vba2V5XSwga2V5KVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcblx0cmV0dXJuIGdsb2JhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpXG59XG5cbmZ1bmN0aW9uIGNsZWFyQWxsKCkge1xuXHRlYWNoKGZ1bmN0aW9uKGtleSwgXykge1xuXHRcdGRlbGV0ZSBnbG9iYWxTdG9yYWdlW2tleV1cblx0fSlcbn1cbiIsIi8vIG9sZElFLXVzZXJEYXRhU3RvcmFnZSBwcm92aWRlcyBzdG9yYWdlIGZvciBJbnRlcm5ldCBFeHBsb3JlclxuLy8gdmVyc2lvbnMgNiBhbmQgNywgd2hlcmUgbm8gbG9jYWxTdG9yYWdlLCBzZXNzaW9uU3RvcmFnZSwgZXRjXG4vLyBpcyBhdmFpbGFibGUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKVxudmFyIEdsb2JhbCA9IHV0aWwuR2xvYmFsXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnb2xkSUUtdXNlckRhdGFTdG9yYWdlJyxcblx0d3JpdGU6IHdyaXRlLFxuXHRyZWFkOiByZWFkLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG52YXIgc3RvcmFnZU5hbWUgPSAnc3RvcmVqcydcbnZhciBkb2MgPSBHbG9iYWwuZG9jdW1lbnRcbnZhciBfd2l0aFN0b3JhZ2VFbCA9IF9tYWtlSUVTdG9yYWdlRWxGdW5jdGlvbigpXG52YXIgZGlzYWJsZSA9IChHbG9iYWwubmF2aWdhdG9yID8gR2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQgOiAnJykubWF0Y2goLyAoTVNJRSA4fE1TSUUgOXxNU0lFIDEwKVxcLi8pIC8vIE1TSUUgOS54LCBNU0lFIDEwLnhcblxuZnVuY3Rpb24gd3JpdGUodW5maXhlZEtleSwgZGF0YSkge1xuXHRpZiAoZGlzYWJsZSkgeyByZXR1cm4gfVxuXHR2YXIgZml4ZWRLZXkgPSBmaXhLZXkodW5maXhlZEtleSlcblx0X3dpdGhTdG9yYWdlRWwoZnVuY3Rpb24oc3RvcmFnZUVsKSB7XG5cdFx0c3RvcmFnZUVsLnNldEF0dHJpYnV0ZShmaXhlZEtleSwgZGF0YSlcblx0XHRzdG9yYWdlRWwuc2F2ZShzdG9yYWdlTmFtZSlcblx0fSlcbn1cblxuZnVuY3Rpb24gcmVhZCh1bmZpeGVkS2V5KSB7XG5cdGlmIChkaXNhYmxlKSB7IHJldHVybiB9XG5cdHZhciBmaXhlZEtleSA9IGZpeEtleSh1bmZpeGVkS2V5KVxuXHR2YXIgcmVzID0gbnVsbFxuXHRfd2l0aFN0b3JhZ2VFbChmdW5jdGlvbihzdG9yYWdlRWwpIHtcblx0XHRyZXMgPSBzdG9yYWdlRWwuZ2V0QXR0cmlidXRlKGZpeGVkS2V5KVxuXHR9KVxuXHRyZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcblx0X3dpdGhTdG9yYWdlRWwoZnVuY3Rpb24oc3RvcmFnZUVsKSB7XG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBzdG9yYWdlRWwuWE1MRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dHJpYnV0ZXNcblx0XHRmb3IgKHZhciBpPWF0dHJpYnV0ZXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0dmFyIGF0dHIgPSBhdHRyaWJ1dGVzW2ldXG5cdFx0XHRjYWxsYmFjayhzdG9yYWdlRWwuZ2V0QXR0cmlidXRlKGF0dHIubmFtZSksIGF0dHIubmFtZSlcblx0XHR9XG5cdH0pXG59XG5cbmZ1bmN0aW9uIHJlbW92ZSh1bmZpeGVkS2V5KSB7XG5cdHZhciBmaXhlZEtleSA9IGZpeEtleSh1bmZpeGVkS2V5KVxuXHRfd2l0aFN0b3JhZ2VFbChmdW5jdGlvbihzdG9yYWdlRWwpIHtcblx0XHRzdG9yYWdlRWwucmVtb3ZlQXR0cmlidXRlKGZpeGVkS2V5KVxuXHRcdHN0b3JhZ2VFbC5zYXZlKHN0b3JhZ2VOYW1lKVxuXHR9KVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0X3dpdGhTdG9yYWdlRWwoZnVuY3Rpb24oc3RvcmFnZUVsKSB7XG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBzdG9yYWdlRWwuWE1MRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dHJpYnV0ZXNcblx0XHRzdG9yYWdlRWwubG9hZChzdG9yYWdlTmFtZSlcblx0XHRmb3IgKHZhciBpPWF0dHJpYnV0ZXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0c3RvcmFnZUVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVzW2ldLm5hbWUpXG5cdFx0fVxuXHRcdHN0b3JhZ2VFbC5zYXZlKHN0b3JhZ2VOYW1lKVxuXHR9KVxufVxuXG4vLyBIZWxwZXJzXG4vLy8vLy8vLy8vXG5cbi8vIEluIElFNywga2V5cyBjYW5ub3Qgc3RhcnQgd2l0aCBhIGRpZ2l0IG9yIGNvbnRhaW4gY2VydGFpbiBjaGFycy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFyY3Vzd2VzdGluL3N0b3JlLmpzL2lzc3Vlcy80MFxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjdXN3ZXN0aW4vc3RvcmUuanMvaXNzdWVzLzgzXG52YXIgZm9yYmlkZGVuQ2hhcnNSZWdleCA9IG5ldyBSZWdFeHAoXCJbIVxcXCIjJCUmJygpKissL1xcXFxcXFxcOjs8PT4/QFtcXFxcXV5ge3x9fl1cIiwgXCJnXCIpXG5mdW5jdGlvbiBmaXhLZXkoa2V5KSB7XG5cdHJldHVybiBrZXkucmVwbGFjZSgvXlxcZC8sICdfX18kJicpLnJlcGxhY2UoZm9yYmlkZGVuQ2hhcnNSZWdleCwgJ19fXycpXG59XG5cbmZ1bmN0aW9uIF9tYWtlSUVTdG9yYWdlRWxGdW5jdGlvbigpIHtcblx0aWYgKCFkb2MgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQuYWRkQmVoYXZpb3IpIHtcblx0XHRyZXR1cm4gbnVsbFxuXHR9XG5cdHZhciBzY3JpcHRUYWcgPSAnc2NyaXB0Jyxcblx0XHRzdG9yYWdlT3duZXIsXG5cdFx0c3RvcmFnZUNvbnRhaW5lcixcblx0XHRzdG9yYWdlRWxcblxuXHQvLyBTaW5jZSAjdXNlckRhdGEgc3RvcmFnZSBhcHBsaWVzIG9ubHkgdG8gc3BlY2lmaWMgcGF0aHMsIHdlIG5lZWQgdG9cblx0Ly8gc29tZWhvdyBsaW5rIG91ciBkYXRhIHRvIGEgc3BlY2lmaWMgcGF0aC4gIFdlIGNob29zZSAvZmF2aWNvbi5pY29cblx0Ly8gYXMgYSBwcmV0dHkgc2FmZSBvcHRpb24sIHNpbmNlIGFsbCBicm93c2VycyBhbHJlYWR5IG1ha2UgYSByZXF1ZXN0IHRvXG5cdC8vIHRoaXMgVVJMIGFueXdheSBhbmQgYmVpbmcgYSA0MDQgd2lsbCBub3QgaHVydCB1cyBoZXJlLiAgV2Ugd3JhcCBhblxuXHQvLyBpZnJhbWUgcG9pbnRpbmcgdG8gdGhlIGZhdmljb24gaW4gYW4gQWN0aXZlWE9iamVjdChodG1sZmlsZSkgb2JqZWN0XG5cdC8vIChzZWU6IGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9hYTc1MjU3NCh2PVZTLjg1KS5hc3B4KVxuXHQvLyBzaW5jZSB0aGUgaWZyYW1lIGFjY2VzcyBydWxlcyBhcHBlYXIgdG8gYWxsb3cgZGlyZWN0IGFjY2VzcyBhbmRcblx0Ly8gbWFuaXB1bGF0aW9uIG9mIHRoZSBkb2N1bWVudCBlbGVtZW50LCBldmVuIGZvciBhIDQwNCBwYWdlLiAgVGhpc1xuXHQvLyBkb2N1bWVudCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IGRvY3VtZW50ICh3aGljaCB3b3VsZFxuXHQvLyBoYXZlIGJlZW4gbGltaXRlZCB0byB0aGUgY3VycmVudCBwYXRoKSB0byBwZXJmb3JtICN1c2VyRGF0YSBzdG9yYWdlLlxuXHR0cnkge1xuXHRcdC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0ICovXG5cdFx0c3RvcmFnZUNvbnRhaW5lciA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpXG5cdFx0c3RvcmFnZUNvbnRhaW5lci5vcGVuKClcblx0XHRzdG9yYWdlQ29udGFpbmVyLndyaXRlKCc8JytzY3JpcHRUYWcrJz5kb2N1bWVudC53PXdpbmRvdzwvJytzY3JpcHRUYWcrJz48aWZyYW1lIHNyYz1cIi9mYXZpY29uLmljb1wiPjwvaWZyYW1lPicpXG5cdFx0c3RvcmFnZUNvbnRhaW5lci5jbG9zZSgpXG5cdFx0c3RvcmFnZU93bmVyID0gc3RvcmFnZUNvbnRhaW5lci53LmZyYW1lc1swXS5kb2N1bWVudFxuXHRcdHN0b3JhZ2VFbCA9IHN0b3JhZ2VPd25lci5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXHR9IGNhdGNoKGUpIHtcblx0XHQvLyBzb21laG93IEFjdGl2ZVhPYmplY3QgaW5zdGFudGlhdGlvbiBmYWlsZWQgKHBlcmhhcHMgc29tZSBzcGVjaWFsXG5cdFx0Ly8gc2VjdXJpdHkgc2V0dGluZ3Mgb3Igb3RoZXJ3c2UpLCBmYWxsIGJhY2sgdG8gcGVyLXBhdGggc3RvcmFnZVxuXHRcdHN0b3JhZ2VFbCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXHRcdHN0b3JhZ2VPd25lciA9IGRvYy5ib2R5XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24oc3RvcmVGdW5jdGlvbikge1xuXHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG5cdFx0YXJncy51bnNoaWZ0KHN0b3JhZ2VFbClcblx0XHQvLyBTZWUgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxMDgxKHY9VlMuODUpLmFzcHhcblx0XHQvLyBhbmQgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTMxNDI0KHY9VlMuODUpLmFzcHhcblx0XHRzdG9yYWdlT3duZXIuYXBwZW5kQ2hpbGQoc3RvcmFnZUVsKVxuXHRcdHN0b3JhZ2VFbC5hZGRCZWhhdmlvcignI2RlZmF1bHQjdXNlckRhdGEnKVxuXHRcdHN0b3JhZ2VFbC5sb2FkKHN0b3JhZ2VOYW1lKVxuXHRcdHN0b3JlRnVuY3Rpb24uYXBwbHkodGhpcywgYXJncylcblx0XHRzdG9yYWdlT3duZXIucmVtb3ZlQ2hpbGQoc3RvcmFnZUVsKVxuXHRcdHJldHVyblxuXHR9XG59XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ3Nlc3Npb25TdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsXG59XG5cbmZ1bmN0aW9uIHNlc3Npb25TdG9yYWdlKCkge1xuXHRyZXR1cm4gR2xvYmFsLnNlc3Npb25TdG9yYWdlXG59XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdHJldHVybiBzZXNzaW9uU3RvcmFnZSgpLmdldEl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIGRhdGEpIHtcblx0cmV0dXJuIHNlc3Npb25TdG9yYWdlKCkuc2V0SXRlbShrZXksIGRhdGEpXG59XG5cbmZ1bmN0aW9uIGVhY2goZm4pIHtcblx0Zm9yICh2YXIgaSA9IHNlc3Npb25TdG9yYWdlKCkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHR2YXIga2V5ID0gc2Vzc2lvblN0b3JhZ2UoKS5rZXkoaSlcblx0XHRmbihyZWFkKGtleSksIGtleSlcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdHJldHVybiBzZXNzaW9uU3RvcmFnZSgpLnJlbW92ZUl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0cmV0dXJuIHNlc3Npb25TdG9yYWdlKCkuY2xlYXIoKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSksIGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn0pO1xuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSlcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcbiAgICByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5pZiAoIUVFLmxpc3RlbmVyQ291bnQpIEVFLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBmYWxzZTtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gSW4gc3RyZWFtcyB0aGF0IG5ldmVyIGhhdmUgYW55IGRhdGEsIGFuZCBkbyBwdXNoKG51bGwpIHJpZ2h0IGF3YXksXG4gIC8vIHRoZSBjb25zdW1lciBjYW4gbWlzcyB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhleSBkbyBzb21lIEkvTyBiZWZvcmVcbiAgLy8gY29uc3VtaW5nIHRoZSBzdHJlYW0uICBTbywgd2UgZG9uJ3QgZW1pdCgnZW5kJykgdW50aWwgc29tZSByZWFkaW5nXG4gIC8vIGhhcHBlbnMuXG4gIHRoaXMuY2FsbGVkUmVhZCA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIGlmICghc3RhdGUuZW5kZWQpXG4gICAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKVxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXG4gICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIChzdGF0ZS5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbihlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLmNhbGxlZFJlYWQgPSB0cnVlO1xuICB2YXIgbk9yaWcgPSBuO1xuICB2YXIgcmV0O1xuXG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICByZXQgPSBudWxsO1xuXG4gICAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIGRlY29kZXIgZGlkIG5vdCByZWNlaXZlIGVub3VnaCBkYXRhXG4gICAgLy8gdG8gcHJvZHVjZSBhIGZ1bGwgY2h1bmssIHRoZW4gaW1tZWRpYXRlbHkgcmVjZWl2ZWQgYW5cbiAgICAvLyBFT0YsIHN0YXRlLmJ1ZmZlciB3aWxsIGNvbnRhaW4gWzxCdWZmZXIgPiwgPEJ1ZmZlciAwMCAuLi4+XS5cbiAgICAvLyBob3dNdWNoVG9SZWFkIHdpbGwgc2VlIHRoaXMgYW5kIGNvZXJjZSB0aGUgYW1vdW50IHRvXG4gICAgLy8gcmVhZCB0byB6ZXJvIChiZWNhdXNlIGl0J3MgbG9va2luZyBhdCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIC8vIGZpcnN0IDxCdWZmZXIgPiBpbiBzdGF0ZS5idWZmZXIpLCBhbmQgd2UnbGwgZW5kIHVwIGhlcmUuXG4gICAgLy9cbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiB2aWEgc3RhdGUuZGVjb2RlciAtLSBubyBvdGhlciB2ZW51ZVxuICAgIC8vIGV4aXN0cyBmb3IgcHVzaGluZyBhIHplcm8tbGVuZ3RoIGNodW5rIGludG8gc3RhdGUuYnVmZmVyXG4gICAgLy8gYW5kIHRyaWdnZXJpbmcgdGhpcyBiZWhhdmlvci4gSW4gdGhpcyBjYXNlLCB3ZSByZXR1cm4gb3VyXG4gICAgLy8gcmVtYWluaW5nIGRhdGEgYW5kIGVuZCB0aGUgc3RyZWFtLCBpZiBhcHByb3ByaWF0ZS5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID4gMCAmJiBzdGF0ZS5kZWNvZGVyKSB7XG4gICAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5sZW5ndGggLT0gcmV0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggLSBuIDw9IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgZG9SZWFkID0gdHJ1ZTtcblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKVxuICAgIGRvUmVhZCA9IGZhbHNlO1xuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIGNhbGxlZCBpdHMgY2FsbGJhY2sgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2BcbiAgLy8gd2lsbCBiZSBmYWxzZSwgYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZVxuICAvLyBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIGhhcHBlbmVkIHRvIHJlYWQoKSBleGFjdGx5IHRoZSByZW1haW5pbmcgYW1vdW50IGluIHRoZVxuICAvLyBidWZmZXIsIGFuZCB0aGUgRU9GIGhhcyBiZWVuIHNlZW4gYXQgdGhpcyBwb2ludCwgdGhlbiBtYWtlIHN1cmVcbiAgLy8gdGhhdCB3ZSBlbWl0ICdlbmQnIG9uIHRoZSB2ZXJ5IG5leHQgdGljay5cbiAgaWYgKHN0YXRlLmVuZGVkICYmICFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCBhbmQgd2UgaGF2ZSBzb21lIGRhdGEgbGVmdCwgdGhlbiBlbWl0XG4gIC8vICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIGVsc2VcbiAgICBlbmRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoc3RhdGUuZW1pdHRlZFJlYWRhYmxlKVxuICAgIHJldHVybjtcblxuICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICBpZiAoc3RhdGUuc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH0pO1xuICBlbHNlXG4gICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgaWYgKHJlYWRhYmxlICE9PSBzcmMpIHJldHVybjtcbiAgICBjbGVhbnVwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbilcbiAgICAgIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKVxuICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuXG4gIGlmICghZGVzdC5fZXZlbnRzIHx8ICFkZXN0Ll9ldmVudHMuZXJyb3IpXG4gICAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZWxzZSBpZiAoaXNBcnJheShkZXN0Ll9ldmVudHMuZXJyb3IpKVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvci51bnNoaWZ0KG9uZXJyb3IpO1xuICBlbHNlXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yID0gW29uZXJyb3IsIGRlc3QuX2V2ZW50cy5lcnJvcl07XG5cblxuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICAvLyB0aGUgaGFuZGxlciB0aGF0IHdhaXRzIGZvciByZWFkYWJsZSBldmVudHMgYWZ0ZXIgYWxsXG4gICAgLy8gdGhlIGRhdGEgZ2V0cyBzdWNrZWQgb3V0IGluIGZsb3cuXG4gICAgLy8gVGhpcyB3b3VsZCBiZSBlYXNpZXIgdG8gZm9sbG93IHdpdGggYSAub25jZSgpIGhhbmRsZXJcbiAgICAvLyBpbiBmbG93KCksIGJ1dCB0aGF0IGlzIHRvbyBzbG93LlxuICAgIHRoaXMub24oJ3JlYWRhYmxlJywgcGlwZU9uUmVhZGFibGUpO1xuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVzdCA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMClcbiAgICAgIGZsb3coc3JjKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvdyhzcmMpIHtcbiAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgY2h1bms7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuXG4gIGZ1bmN0aW9uIHdyaXRlKGRlc3QsIGksIGxpc3QpIHtcbiAgICB2YXIgd3JpdHRlbiA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gd3JpdHRlbikge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5waXBlc0NvdW50ICYmIG51bGwgIT09IChjaHVuayA9IHNyYy5yZWFkKCkpKSB7XG5cbiAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICAgIHdyaXRlKHN0YXRlLnBpcGVzLCAwLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICBmb3JFYWNoKHN0YXRlLnBpcGVzLCB3cml0ZSk7XG5cbiAgICBzcmMuZW1pdCgnZGF0YScsIGNodW5rKTtcblxuICAgIC8vIGlmIGFueW9uZSBuZWVkcyBhIGRyYWluLCB0aGVuIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhhdC5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA+IDApXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiBldmVyeSBkZXN0aW5hdGlvbiB3YXMgdW5waXBlZCwgZWl0aGVyIGJlZm9yZSBlbnRlcmluZyB0aGlzXG4gIC8vIGZ1bmN0aW9uLCBvciBpbiB0aGUgd2hpbGUgbG9vcCwgdGhlbiBzdG9wIGZsb3dpbmcuXG4gIC8vXG4gIC8vIE5COiBUaGlzIGlzIGEgcHJldHR5IHJhcmUgZWRnZSBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkge1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIC8vIGlmIHRoZXJlIHdlcmUgZGF0YSBldmVudCBsaXN0ZW5lcnMgYWRkZWQsIHRoZW4gc3dpdGNoIHRvIG9sZCBtb2RlLlxuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSA+IDApXG4gICAgICBlbWl0RGF0YUV2ZW50cyhzcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIG5vIG9uZSBuZWVkZWQgYSBkcmFpbiwgc28gd2UganVzdCByYW4gb3V0IG9mIGRhdGFcbiAgLy8gb24gdGhlIG5leHQgcmVhZGFibGUgZXZlbnQsIHN0YXJ0IGl0IG92ZXIgYWdhaW4uXG4gIHN0YXRlLnJhbk91dCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHBpcGVPblJlYWRhYmxlKCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5yYW5PdXQpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCA9IGZhbHNlO1xuICAgIGZsb3codGhpcyk7XG4gIH1cbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKVxuICAgIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdGhpcy5yZWFkKDApO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBlbWl0RGF0YUV2ZW50cyh0aGlzKTtcbiAgdGhpcy5yZWFkKDApO1xuICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMsIHRydWUpO1xuICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5mdW5jdGlvbiBlbWl0RGF0YUV2ZW50cyhzdHJlYW0sIHN0YXJ0UGF1c2VkKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvcmVhZGFibGUtc3RyZWFtL2lzc3Vlcy8xNlxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3aXRjaCB0byBvbGQgbW9kZSBub3cuJyk7XG4gIH1cblxuICB2YXIgcGF1c2VkID0gc3RhcnRQYXVzZWQgfHwgZmFsc2U7XG4gIHZhciByZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGNvbnZlcnQgdG8gYW4gb2xkLXN0eWxlIHN0cmVhbS5cbiAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcbiAgc3RyZWFtLnBpcGUgPSBTdHJlYW0ucHJvdG90eXBlLnBpcGU7XG4gIHN0cmVhbS5vbiA9IHN0cmVhbS5hZGRMaXN0ZW5lciA9IFN0cmVhbS5wcm90b3R5cGUub247XG5cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIHZhciBjO1xuICAgIHdoaWxlICghcGF1c2VkICYmIChudWxsICE9PSAoYyA9IHN0cmVhbS5yZWFkKCkpKSlcbiAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYyk7XG5cbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgc3RyZWFtLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH07XG5cbiAgc3RyZWFtLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGlmIChyZWFkYWJsZSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5yZWFkKDApO1xuICAgIHRoaXMuZW1pdCgncmVzdW1lJyk7XG4gIH07XG5cbiAgLy8gbm93IG1ha2UgaXQgc3RhcnQsIGp1c3QgaW4gY2FzZSBpdCBoYWRuJ3QgYWxyZWFkeS5cbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aClcbiAgICAgICAgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgLy9pZiAoc3RhdGUub2JqZWN0TW9kZSAmJiB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSlcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpXG4gICAgICByZXR1cm47XG4gICAgZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSlcbiAgICAgIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiB0aGlzW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uKG1ldGhvZCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICB9fShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmNhbGxlZFJlYWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuX2ZsdXNoKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogMTYgKiAxMDI0O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGNiKGVyKTtcbiAgfSk7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAnc3RyaW5nJyAhPT0gdHlwZW9mIGNodW5rICYmXG4gICAgICBjaHVuayAhPT0gbnVsbCAmJlxuICAgICAgY2h1bmsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICB2YXIgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIGVsc2UgaWYgKCFlbmNvZGluZylcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKVxuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nKVxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XG4gIGVsc2VcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlXG4gICAgY2IoZXIpO1xuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgY2IoKTtcbiAgaWYgKGZpbmlzaGVkKVxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcltjXTtcbiAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICBjKys7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG4gIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gIGVsc2VcbiAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNodW5rICE9PSAndW5kZWZpbmVkJyAmJiBjaHVuayAhPT0gbnVsbClcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybScpXG4gICwgaW5oZXJpdHMgID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG4gICwgeHRlbmQgICAgID0gcmVxdWlyZSgneHRlbmQnKVxuXG5mdW5jdGlvbiBEZXN0cm95YWJsZVRyYW5zZm9ybShvcHRzKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKERlc3Ryb3lhYmxlVHJhbnNmb3JtLCBUcmFuc2Zvcm0pXG5cbkRlc3Ryb3lhYmxlVHJhbnNmb3JtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gIFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBpZiAoZXJyKVxuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgfSlcbn1cblxuLy8gYSBub29wIF90cmFuc2Zvcm0gZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AgKGNodW5rLCBlbmMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKG51bGwsIGNodW5rKVxufVxuXG5cbi8vIGNyZWF0ZSBhIG5ldyBleHBvcnQgZnVuY3Rpb24sIHVzZWQgYnkgYm90aCB0aGUgbWFpbiBleHBvcnQgYW5kXG4vLyB0aGUgLmN0b3IgZXhwb3J0LCBjb250YWlucyBjb21tb24gbG9naWMgZm9yIGRlYWxpbmcgd2l0aCBhcmd1bWVudHNcbmZ1bmN0aW9uIHRocm91Z2gyIChjb25zdHJ1Y3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZsdXNoICAgICA9IHRyYW5zZm9ybVxuICAgICAgdHJhbnNmb3JtID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyAgID0ge31cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSAhPSAnZnVuY3Rpb24nKVxuICAgICAgdHJhbnNmb3JtID0gbm9vcFxuXG4gICAgaWYgKHR5cGVvZiBmbHVzaCAhPSAnZnVuY3Rpb24nKVxuICAgICAgZmx1c2ggPSBudWxsXG5cbiAgICByZXR1cm4gY29uc3RydWN0KG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpXG4gIH1cbn1cblxuXG4vLyBtYWluIGV4cG9ydCwganVzdCBtYWtlIG1lIGEgdHJhbnNmb3JtIHN0cmVhbSFcbm1vZHVsZS5leHBvcnRzID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgdmFyIHQyID0gbmV3IERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdGlvbnMpXG5cbiAgdDIuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICB0Mi5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiB0MlxufSlcblxuXG4vLyBtYWtlIG1lIGEgcmV1c2FibGUgcHJvdG90eXBlIHRoYXQgSSBjYW4gYG5ld2AsIG9yIGltcGxpY2l0bHkgYG5ld2Bcbi8vIHdpdGggYSBjb25zdHJ1Y3RvciBjYWxsXG5tb2R1bGUuZXhwb3J0cy5jdG9yID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgZnVuY3Rpb24gVGhyb3VnaDIgKG92ZXJyaWRlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRocm91Z2gyKSlcbiAgICAgIHJldHVybiBuZXcgVGhyb3VnaDIob3ZlcnJpZGUpXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB4dGVuZChvcHRpb25zLCBvdmVycmlkZSlcblxuICAgIERlc3Ryb3lhYmxlVHJhbnNmb3JtLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW5oZXJpdHMoVGhyb3VnaDIsIERlc3Ryb3lhYmxlVHJhbnNmb3JtKVxuXG4gIFRocm91Z2gyLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIFRocm91Z2gyLnByb3RvdHlwZS5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiBUaHJvdWdoMlxufSlcblxuXG5tb2R1bGUuZXhwb3J0cy5vYmogPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0oeHRlbmQoeyBvYmplY3RNb2RlOiB0cnVlLCBoaWdoV2F0ZXJNYXJrOiAxNiB9LCBvcHRpb25zKSlcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChidWYpIHtcblx0Ly8gSWYgdGhlIGJ1ZmZlciBpcyBiYWNrZWQgYnkgYSBVaW50OEFycmF5LCBhIGZhc3RlciB2ZXJzaW9uIHdpbGwgd29ya1xuXHRpZiAoYnVmIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHRcdC8vIElmIHRoZSBidWZmZXIgaXNuJ3QgYSBzdWJhcnJheSwgcmV0dXJuIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyXG5cdFx0aWYgKGJ1Zi5ieXRlT2Zmc2V0ID09PSAwICYmIGJ1Zi5ieXRlTGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcblx0XHRcdHJldHVybiBidWYuYnVmZmVyXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgYnVmLmJ1ZmZlci5zbGljZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gZ2V0IGEgcHJvcGVyIGNvcHlcblx0XHRcdHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKVxuXHRcdH1cblx0fVxuXG5cdGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuXHRcdC8vIFRoaXMgaXMgdGhlIHNsb3cgdmVyc2lvbiB0aGF0IHdpbGwgd29yayB3aXRoIGFueSBCdWZmZXJcblx0XHQvLyBpbXBsZW1lbnRhdGlvbiAoZXZlbiBpbiBvbGQgYnJvd3NlcnMpXG5cdFx0dmFyIGFycmF5Q29weSA9IG5ldyBVaW50OEFycmF5KGJ1Zi5sZW5ndGgpXG5cdFx0dmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRhcnJheUNvcHlbaV0gPSBidWZbaV1cblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5Q29weS5idWZmZXJcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuXHR9XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInYxXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3YyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3YzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3Y0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTklMXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9uaWwuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92ZXJzaW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFsaWRhdGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3ZhbGlkYXRlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyaW5naWZ5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcGFyc2UuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfdiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjEuanNcIikpO1xuXG52YXIgX3YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92My5qc1wiKSk7XG5cbnZhciBfdjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Y0LmpzXCIpKTtcblxudmFyIF92NCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjUuanNcIikpO1xuXG52YXIgX25pbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbmlsLmpzXCIpKTtcblxudmFyIF92ZXJzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92ZXJzaW9uLmpzXCIpKTtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG52YXIgX3N0cmluZ2lmeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpKTtcblxudmFyIF9wYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGFyc2UuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG4vKlxuICogQnJvd3Nlci1jb21wYXRpYmxlIEphdmFTY3JpcHQgTUQ1XG4gKlxuICogTW9kaWZpY2F0aW9uIG9mIEphdmFTY3JpcHQgTUQ1XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LU1ENVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiBCYXNlZCBvblxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4yIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwOVxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5mdW5jdGlvbiBtZDUoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBtc2cgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYnl0ZXMpKTsgLy8gVVRGOCBlc2NhcGVcblxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobXNnLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXNbaV0gPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWQ1VG9IZXhFbmNvZGVkQXJyYXkod29yZHNUb01kNShieXRlc1RvV29yZHMoYnl0ZXMpLCBieXRlcy5sZW5ndGggKiA4KSk7XG59XG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGFuIGFycmF5IG9mIGJ5dGVzXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVUb0hleEVuY29kZWRBcnJheShpbnB1dCkge1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgY29uc3QgbGVuZ3RoMzIgPSBpbnB1dC5sZW5ndGggKiAzMjtcbiAgY29uc3QgaGV4VGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoMzI7IGkgKz0gOCkge1xuICAgIGNvbnN0IHggPSBpbnB1dFtpID4+IDVdID4+PiBpICUgMzIgJiAweGZmO1xuICAgIGNvbnN0IGhleCA9IHBhcnNlSW50KGhleFRhYi5jaGFyQXQoeCA+Pj4gNCAmIDB4MGYpICsgaGV4VGFiLmNoYXJBdCh4ICYgMHgwZiksIDE2KTtcbiAgICBvdXRwdXQucHVzaChoZXgpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG91dHB1dCBsZW5ndGggd2l0aCBwYWRkaW5nIGFuZCBiaXQgbGVuZ3RoXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRPdXRwdXRMZW5ndGgoaW5wdXRMZW5ndGg4KSB7XG4gIHJldHVybiAoaW5wdXRMZW5ndGg4ICsgNjQgPj4+IDkgPDwgNCkgKyAxNCArIDE7XG59XG4vKlxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdvcmRzVG9NZDUoeCwgbGVuKSB7XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgbGVuICUgMzI7XG4gIHhbZ2V0T3V0cHV0TGVuZ3RoKGxlbikgLSAxXSA9IGxlbjtcbiAgbGV0IGEgPSAxNzMyNTg0MTkzO1xuICBsZXQgYiA9IC0yNzE3MzM4Nzk7XG4gIGxldCBjID0gLTE3MzI1ODQxOTQ7XG4gIGxldCBkID0gMjcxNzMzODc4O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICBjb25zdCBvbGRhID0gYTtcbiAgICBjb25zdCBvbGRiID0gYjtcbiAgICBjb25zdCBvbGRjID0gYztcbiAgICBjb25zdCBvbGRkID0gZDtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpXSwgNywgLTY4MDg3NjkzNik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNywgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA3LCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgNV0sIDEyLCAxMjAwMDgwNDI2KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgOF0sIDcsIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDcsIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDE1XSwgMjIsIDEyMzY1MzUzMjkpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNSwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDZdLCA5LCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaV0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgNV0sIDUsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxMF0sIDksIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDldLCA1LCA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sIDksIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgOF0sIDIwLCAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCA1LCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDJdLCA5LCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTQsIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA0LCAtMzc4NTU4KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTYsIDE4MzkwMzA1NjIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNCwgLTE1MzA5OTIwNjApO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA0XSwgMTEsIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNCwgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyA2XSwgMjMsIDc2MDI5MTg5KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgOV0sIDQsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyAxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNiwgNTMwNzQyNTIwKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpXSwgNiwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDddLCAxMCwgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDYsIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgOF0sIDYsIDE4NzMzMTMzNTkpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMTNdLCAyMSwgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA2LCAtMTQ1NTIzMDcwKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTUsIDcxODc4NzI1OSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG4gICAgYSA9IHNhZmVBZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVBZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVBZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVBZGQoZCwgb2xkZCk7XG4gIH1cblxuICByZXR1cm4gW2EsIGIsIGMsIGRdO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgYnl0ZXMgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBieXRlc1RvV29yZHMoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aDggPSBpbnB1dC5sZW5ndGggKiA4O1xuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDMyQXJyYXkoZ2V0T3V0cHV0TGVuZ3RoKGxlbmd0aDgpKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDg7IGkgKz0gOCkge1xuICAgIG91dHB1dFtpID4+IDVdIHw9IChpbnB1dFtpIC8gOF0gJiAweGZmKSA8PCBpICUgMzI7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cblxuXG5mdW5jdGlvbiBzYWZlQWRkKHgsIHkpIHtcbiAgY29uc3QgbHN3ID0gKHggJiAweGZmZmYpICsgKHkgJiAweGZmZmYpO1xuICBjb25zdCBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIG1zdyA8PCAxNiB8IGxzdyAmIDB4ZmZmZjtcbn1cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cblxuXG5mdW5jdGlvbiBiaXRSb3RhdGVMZWZ0KG51bSwgY250KSB7XG4gIHJldHVybiBudW0gPDwgY250IHwgbnVtID4+PiAzMiAtIGNudDtcbn1cbi8qXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICovXG5cblxuZnVuY3Rpb24gbWQ1Y21uKHEsIGEsIGIsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIHNhZmVBZGQoYml0Um90YXRlTGVmdChzYWZlQWRkKHNhZmVBZGQoYSwgcSksIHNhZmVBZGQoeCwgdCkpLCBzKSwgYik7XG59XG5cbmZ1bmN0aW9uIG1kNWZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiICYgYyB8IH5iICYgZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWdnKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiICYgZCB8IGMgJiB+ZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWhoKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVpaShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYyBeIChiIHwgfmQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gbWQ1O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2RlZmF1bHQgPSAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCEoMCwgX3ZhbGlkYXRlLmRlZmF1bHQpKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIGxldCB2O1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7IC8vIFBhcnNlICMjIyMjIyMjLS4uLi4tLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0jIyMjLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0jIyMjLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tIyMjIy0uLi4uLi4uLi4uLi5cblxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0uLi4uLSMjIyMjIyMjIyMjI1xuICAvLyAoVXNlIFwiL1wiIHRvIGF2b2lkIDMyLWJpdCB0cnVuY2F0aW9uIHdoZW4gYml0LXNoaWZ0aW5nIGhpZ2gtb3JkZXIgYnl0ZXMpXG5cbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cblxudmFyIF9kZWZhdWx0ID0gcGFyc2U7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmYXVsdCA9IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcm5nO1xuLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG5sZXQgZ2V0UmFuZG9tVmFsdWVzO1xuY29uc3Qgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5cbmZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLiBBbHNvLFxuICAgIC8vIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byAobXNDcnlwdG8pIG9uIElFMTEuXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLy8gQWRhcHRlZCBmcm9tIENocmlzIFZlbmVzcycgU0hBMSBjb2RlIGF0XG4vLyBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL3NoYTEuaHRtbFxuZnVuY3Rpb24gZihzLCB4LCB5LCB6KSB7XG4gIHN3aXRjaCAocykge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB4ICYgeSBeIH54ICYgejtcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4geCAmIHkgXiB4ICYgeiBeIHkgJiB6O1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgfVxufVxuXG5mdW5jdGlvbiBST1RMKHgsIG4pIHtcbiAgcmV0dXJuIHggPDwgbiB8IHggPj4+IDMyIC0gbjtcbn1cblxuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICBjb25zdCBLID0gWzB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4Y2E2MmMxZDZdO1xuICBjb25zdCBIID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdO1xuXG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzLnB1c2gobXNnLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICAvLyBDb252ZXJ0IEFycmF5LWxpa2UgdG8gQXJyYXlcbiAgICBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ5dGVzKTtcbiAgfVxuXG4gIGJ5dGVzLnB1c2goMHg4MCk7XG4gIGNvbnN0IGwgPSBieXRlcy5sZW5ndGggLyA0ICsgMjtcbiAgY29uc3QgTiA9IE1hdGguY2VpbChsIC8gMTYpO1xuICBjb25zdCBNID0gbmV3IEFycmF5KE4pO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgYXJyW2pdID0gYnl0ZXNbaSAqIDY0ICsgaiAqIDRdIDw8IDI0IHwgYnl0ZXNbaSAqIDY0ICsgaiAqIDQgKyAxXSA8PCAxNiB8IGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgMl0gPDwgOCB8IGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgM107XG4gICAgfVxuXG4gICAgTVtpXSA9IGFycjtcbiAgfVxuXG4gIE1bTiAtIDFdWzE0XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggLyBNYXRoLnBvdygyLCAzMik7XG4gIE1bTiAtIDFdWzE0XSA9IE1hdGguZmxvb3IoTVtOIC0gMV1bMTRdKTtcbiAgTVtOIC0gMV1bMTVdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAmIDB4ZmZmZmZmZmY7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICBjb25zdCBXID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcblxuICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMTY7ICsrdCkge1xuICAgICAgV1t0XSA9IE1baV1bdF07XG4gICAgfVxuXG4gICAgZm9yIChsZXQgdCA9IDE2OyB0IDwgODA7ICsrdCkge1xuICAgICAgV1t0XSA9IFJPVEwoV1t0IC0gM10gXiBXW3QgLSA4XSBeIFdbdCAtIDE0XSBeIFdbdCAtIDE2XSwgMSk7XG4gICAgfVxuXG4gICAgbGV0IGEgPSBIWzBdO1xuICAgIGxldCBiID0gSFsxXTtcbiAgICBsZXQgYyA9IEhbMl07XG4gICAgbGV0IGQgPSBIWzNdO1xuICAgIGxldCBlID0gSFs0XTtcblxuICAgIGZvciAobGV0IHQgPSAwOyB0IDwgODA7ICsrdCkge1xuICAgICAgY29uc3QgcyA9IE1hdGguZmxvb3IodCAvIDIwKTtcbiAgICAgIGNvbnN0IFQgPSBST1RMKGEsIDUpICsgZihzLCBiLCBjLCBkKSArIGUgKyBLW3NdICsgV1t0XSA+Pj4gMDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gUk9UTChiLCAzMCkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSBUO1xuICAgIH1cblxuICAgIEhbMF0gPSBIWzBdICsgYSA+Pj4gMDtcbiAgICBIWzFdID0gSFsxXSArIGIgPj4+IDA7XG4gICAgSFsyXSA9IEhbMl0gKyBjID4+PiAwO1xuICAgIEhbM10gPSBIWzNdICsgZCA+Pj4gMDtcbiAgICBIWzRdID0gSFs0XSArIGUgPj4+IDA7XG4gIH1cblxuICByZXR1cm4gW0hbMF0gPj4gMjQgJiAweGZmLCBIWzBdID4+IDE2ICYgMHhmZiwgSFswXSA+PiA4ICYgMHhmZiwgSFswXSAmIDB4ZmYsIEhbMV0gPj4gMjQgJiAweGZmLCBIWzFdID4+IDE2ICYgMHhmZiwgSFsxXSA+PiA4ICYgMHhmZiwgSFsxXSAmIDB4ZmYsIEhbMl0gPj4gMjQgJiAweGZmLCBIWzJdID4+IDE2ICYgMHhmZiwgSFsyXSA+PiA4ICYgMHhmZiwgSFsyXSAmIDB4ZmYsIEhbM10gPj4gMjQgJiAweGZmLCBIWzNdID4+IDE2ICYgMHhmZiwgSFszXSA+PiA4ICYgMHhmZiwgSFszXSAmIDB4ZmYsIEhbNF0gPj4gMjQgJiAweGZmLCBIWzRdID4+IDE2ICYgMHhmZiwgSFs0XSA+PiA4ICYgMHhmZiwgSFs0XSAmIDB4ZmZdO1xufVxuXG52YXIgX2RlZmF1bHQgPSBzaGExO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5jb25zdCBieXRlVG9IZXggPSBbXTtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgY29uc3QgdXVpZCA9IChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghKDAsIF92YWxpZGF0ZS5kZWZhdWx0KSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxudmFyIF9kZWZhdWx0ID0gc3RyaW5naWZ5O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcm5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ybmcuanNcIikpO1xuXG52YXIgX3N0cmluZ2lmeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxubGV0IF9ub2RlSWQ7XG5cbmxldCBfY2xvY2tzZXE7IC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuXG5cbmxldCBfbGFzdE1TZWNzID0gMDtcbmxldCBfbGFzdE5TZWNzID0gMDsgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCBmb3IgQVBJIGRldGFpbHNcblxuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgbGV0IGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIGNvbnN0IGIgPSBidWYgfHwgbmV3IEFycmF5KDE2KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxldCBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIGxldCBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7IC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuXG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIGNvbnN0IHNlZWRCeXRlcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nLmRlZmF1bHQpKCk7XG5cbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgICAgIG5vZGUgPSBfbm9kZUlkID0gW3NlZWRCeXRlc1swXSB8IDB4MDEsIHNlZWRCeXRlc1sxXSwgc2VlZEJ5dGVzWzJdLCBzZWVkQnl0ZXNbM10sIHNlZWRCeXRlc1s0XSwgc2VlZEJ5dGVzWzVdXTtcbiAgICB9XG5cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgICAgIGNsb2Nrc2VxID0gX2Nsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcbiAgICB9XG4gIH0gLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG5cblxuICBsZXQgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogRGF0ZS5ub3coKTsgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuXG4gIGxldCBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTsgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuXG4gIGNvbnN0IGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDsgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH0gLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuXG5cbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH0gLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuXG5cbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXVpZC52MSgpOiBDYW4ndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWNcIik7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7IC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwOyAvLyBgdGltZV9sb3dgXG5cbiAgY29uc3QgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmOyAvLyBgdGltZV9taWRgXG5cbiAgY29uc3QgdG1oID0gbXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmOyAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjsgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG5cbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwOyAvLyBgY2xvY2tfc2VxX2xvd2BcblxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7IC8vIGBub2RlYFxuXG4gIGZvciAobGV0IG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCAoMCwgX3N0cmluZ2lmeS5kZWZhdWx0KShiKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdjE7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92MzUuanNcIikpO1xuXG52YXIgX21kID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tZDUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCB2MyA9ICgwLCBfdi5kZWZhdWx0KSgndjMnLCAweDMwLCBfbWQuZGVmYXVsdCk7XG52YXIgX2RlZmF1bHQgPSB2MztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5leHBvcnRzLlVSTCA9IGV4cG9ydHMuRE5TID0gdm9pZCAwO1xuXG52YXIgX3N0cmluZ2lmeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpKTtcblxudmFyIF9wYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGFyc2UuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgY29uc3QgYnl0ZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5jb25zdCBETlMgPSAnNmJhN2I4MTAtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydHMuRE5TID0gRE5TO1xuY29uc3QgVVJMID0gJzZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnRzLlVSTCA9IFVSTDtcblxuZnVuY3Rpb24gX2RlZmF1bHQobmFtZSwgdmVyc2lvbiwgaGFzaGZ1bmMpIHtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lc3BhY2UgPSAoMCwgX3BhcnNlLmRlZmF1bHQpKG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVzcGFjZS5sZW5ndGggIT09IDE2KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ05hbWVzcGFjZSBtdXN0IGJlIGFycmF5LWxpa2UgKDE2IGl0ZXJhYmxlIGludGVnZXIgdmFsdWVzLCAwLTI1NSknKTtcbiAgICB9IC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG5cblxuICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2ICsgdmFsdWUubGVuZ3RoKTtcbiAgICBieXRlcy5zZXQobmFtZXNwYWNlKTtcbiAgICBieXRlcy5zZXQodmFsdWUsIG5hbWVzcGFjZS5sZW5ndGgpO1xuICAgIGJ5dGVzID0gaGFzaGZ1bmMoYnl0ZXMpO1xuICAgIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX3N0cmluZ2lmeS5kZWZhdWx0KShieXRlcyk7XG4gIH0gLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG5cblxuICB0cnkge1xuICAgIGdlbmVyYXRlVVVJRC5uYW1lID0gbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gIH0gY2F0Y2ggKGVycikge30gLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcblxuXG4gIGdlbmVyYXRlVVVJRC5ETlMgPSBETlM7XG4gIGdlbmVyYXRlVVVJRC5VUkwgPSBVUkw7XG4gIHJldHVybiBnZW5lcmF0ZVVVSUQ7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcm5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ybmcuanNcIikpO1xuXG52YXIgX3N0cmluZ2lmeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc3RyaW5naWZ5LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nLmRlZmF1bHQpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuICgwLCBfc3RyaW5naWZ5LmRlZmF1bHQpKHJuZHMpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2NDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3YzNS5qc1wiKSk7XG5cbnZhciBfc2hhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zaGExLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgdjUgPSAoMCwgX3YuZGVmYXVsdCkoJ3Y1JywgMHg1MCwgX3NoYS5kZWZhdWx0KTtcbnZhciBfZGVmYXVsdCA9IHY1O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVnZXggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JlZ2V4LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIF9yZWdleC5kZWZhdWx0LnRlc3QodXVpZCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IHZhbGlkYXRlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghKDAsIF92YWxpZGF0ZS5kZWZhdWx0KSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQodXVpZC5zdWJzdHIoMTQsIDEpLCAxNik7XG59XG5cbnZhciBfZGVmYXVsdCA9IHZlcnNpb247XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbiAvKiBlc2xpbnQtZW52IG5vZGUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBTaGltbWluZyBzdGFydHMgaGVyZS5cbihmdW5jdGlvbigpIHtcbiAgLy8gVXRpbHMuXG4gIHZhciBsb2dnaW5nID0gcmVxdWlyZSgnLi91dGlscycpLmxvZztcbiAgdmFyIGJyb3dzZXJEZXRhaWxzID0gcmVxdWlyZSgnLi91dGlscycpLmJyb3dzZXJEZXRhaWxzO1xuICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICBtb2R1bGUuZXhwb3J0cy5icm93c2VyRGV0YWlscyA9IGJyb3dzZXJEZXRhaWxzO1xuICBtb2R1bGUuZXhwb3J0cy5leHRyYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vdXRpbHMnKS5leHRyYWN0VmVyc2lvbjtcbiAgbW9kdWxlLmV4cG9ydHMuZGlzYWJsZUxvZyA9IHJlcXVpcmUoJy4vdXRpbHMnKS5kaXNhYmxlTG9nO1xuXG4gIC8vIFVuY29tbWVudCB0aGUgbGluZSBiZWxvdyBpZiB5b3Ugd2FudCBsb2dnaW5nIHRvIG9jY3VyLCBpbmNsdWRpbmcgbG9nZ2luZ1xuICAvLyBmb3IgdGhlIHN3aXRjaCBzdGF0ZW1lbnQgYmVsb3cuIENhbiBhbHNvIGJlIHR1cm5lZCBvbiBpbiB0aGUgYnJvd3NlciB2aWFcbiAgLy8gYWRhcHRlci5kaXNhYmxlTG9nKGZhbHNlKSwgYnV0IHRoZW4gbG9nZ2luZyBmcm9tIHRoZSBzd2l0Y2ggc3RhdGVtZW50IGJlbG93XG4gIC8vIHdpbGwgbm90IGFwcGVhci5cbiAgLy8gcmVxdWlyZSgnLi91dGlscycpLmRpc2FibGVMb2coZmFsc2UpO1xuXG4gIC8vIEJyb3dzZXIgc2hpbXMuXG4gIHZhciBjaHJvbWVTaGltID0gcmVxdWlyZSgnLi9jaHJvbWUvY2hyb21lX3NoaW0nKSB8fCBudWxsO1xuICB2YXIgZWRnZVNoaW0gPSByZXF1aXJlKCcuL2VkZ2UvZWRnZV9zaGltJykgfHwgbnVsbDtcbiAgdmFyIGZpcmVmb3hTaGltID0gcmVxdWlyZSgnLi9maXJlZm94L2ZpcmVmb3hfc2hpbScpIHx8IG51bGw7XG4gIHZhciBzYWZhcmlTaGltID0gcmVxdWlyZSgnLi9zYWZhcmkvc2FmYXJpX3NoaW0nKSB8fCBudWxsO1xuXG4gIC8vIFNoaW0gYnJvd3NlciBpZiBmb3VuZC5cbiAgc3dpdGNoIChicm93c2VyRGV0YWlscy5icm93c2VyKSB7XG4gICAgY2FzZSAnb3BlcmEnOiAvLyBmYWxsdGhyb3VnaCBhcyBpdCB1c2VzIGNocm9tZSBzaGltc1xuICAgIGNhc2UgJ2Nocm9tZSc6XG4gICAgICBpZiAoIWNocm9tZVNoaW0gfHwgIWNocm9tZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBjaHJvbWUuJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgbW9kdWxlLmV4cG9ydHMuYnJvd3NlclNoaW0gPSBjaHJvbWVTaGltO1xuXG4gICAgICBjaHJvbWVTaGltLnNoaW1HZXRVc2VyTWVkaWEoKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbU1lZGlhU3RyZWFtKCk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1Tb3VyY2VPYmplY3QoKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKCk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1PblRyYWNrKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmaXJlZm94JzpcbiAgICAgIGlmICghZmlyZWZveFNoaW0gfHwgIWZpcmVmb3hTaGltLnNoaW1QZWVyQ29ubmVjdGlvbikge1xuICAgICAgICBsb2dnaW5nKCdGaXJlZm94IHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIGZpcmVmb3guJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgbW9kdWxlLmV4cG9ydHMuYnJvd3NlclNoaW0gPSBmaXJlZm94U2hpbTtcblxuICAgICAgZmlyZWZveFNoaW0uc2hpbUdldFVzZXJNZWRpYSgpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVNvdXJjZU9iamVjdCgpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKCk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltT25UcmFjaygpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZWRnZSc6XG4gICAgICBpZiAoIWVkZ2VTaGltIHx8ICFlZGdlU2hpbS5zaGltUGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgbG9nZ2luZygnTVMgZWRnZSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBlZGdlLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIG1vZHVsZS5leHBvcnRzLmJyb3dzZXJTaGltID0gZWRnZVNoaW07XG5cbiAgICAgIGVkZ2VTaGltLnNoaW1HZXRVc2VyTWVkaWEoKTtcbiAgICAgIGVkZ2VTaGltLnNoaW1QZWVyQ29ubmVjdGlvbigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2FmYXJpJzpcbiAgICAgIGlmICghc2FmYXJpU2hpbSkge1xuICAgICAgICBsb2dnaW5nKCdTYWZhcmkgc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgc2FmYXJpLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIG1vZHVsZS5leHBvcnRzLmJyb3dzZXJTaGltID0gc2FmYXJpU2hpbTtcblxuICAgICAgc2FmYXJpU2hpbS5zaGltR2V0VXNlck1lZGlhKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbG9nZ2luZygnVW5zdXBwb3J0ZWQgYnJvd3NlciEnKTtcbiAgfVxufSkoKTtcbiIsIlxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4gLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG52YXIgbG9nZ2luZyA9IHJlcXVpcmUoJy4uL3V0aWxzLmpzJykubG9nO1xudmFyIGJyb3dzZXJEZXRhaWxzID0gcmVxdWlyZSgnLi4vdXRpbHMuanMnKS5icm93c2VyRGV0YWlscztcblxudmFyIGNocm9tZVNoaW0gPSB7XG4gIHNoaW1NZWRpYVN0cmVhbTogZnVuY3Rpb24oKSB7XG4gICAgd2luZG93Lk1lZGlhU3RyZWFtID0gd2luZG93Lk1lZGlhU3RyZWFtIHx8IHdpbmRvdy53ZWJraXRNZWRpYVN0cmVhbTtcbiAgfSxcblxuICBzaGltT25UcmFjazogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAhKCdvbnRyYWNrJyBpblxuICAgICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbnRyYWNrJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9vbnRyYWNrO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgaWYgKHRoaXMuX29udHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb250cmFja3BvbHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayA9IGYpO1xuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb250cmFja3BvbHkgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyBvbmFkZHN0cmVhbSBkb2VzIG5vdCBmaXJlIHdoZW4gYSB0cmFjayBpcyBhZGRlZCB0byBhbiBleGlzdGluZ1xuICAgICAgICAgICAgLy8gc3RyZWFtLiBCdXQgc3RyZWFtLm9uYWRkdHJhY2sgaXMgaW1wbGVtZW50ZWQgc28gd2UgdXNlIHRoYXQuXG4gICAgICAgICAgICBlLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIGZ1bmN0aW9uKHRlKSB7XG4gICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0ZS50cmFjaztcbiAgICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSB7dHJhY2s6IHRlLnRyYWNrfTtcbiAgICAgICAgICAgICAgZXZlbnQuc3RyZWFtcyA9IFtlLnN0cmVhbV07XG4gICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUuc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgICBldmVudC50cmFjayA9IHRyYWNrO1xuICAgICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHt0cmFjazogdHJhY2t9O1xuICAgICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHNoaW1Tb3VyY2VPYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHdpbmRvdy5IVE1MTWVkaWFFbGVtZW50ICYmXG4gICAgICAgICEoJ3NyY09iamVjdCcgaW4gd2luZG93LkhUTUxNZWRpYUVsZW1lbnQucHJvdG90eXBlKSkge1xuICAgICAgICAvLyBTaGltIHRoZSBzcmNPYmplY3QgcHJvcGVydHksIG9uY2UsIHdoZW4gSFRNTE1lZGlhRWxlbWVudCBpcyBmb3VuZC5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5IVE1MTWVkaWFFbGVtZW50LnByb3RvdHlwZSwgJ3NyY09iamVjdCcsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NyY09iamVjdDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBVc2UgX3NyY09iamVjdCBhcyBhIHByaXZhdGUgcHJvcGVydHkgZm9yIHRoaXMgc2hpbVxuICAgICAgICAgICAgdGhpcy5fc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3JjKSB7XG4gICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5zcmMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgICAgICB0aGlzLnNyYyA9ICcnO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtKTtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcmVjcmVhdGUgdGhlIGJsb2IgdXJsIHdoZW4gYSB0cmFjayBpcyBhZGRlZCBvclxuICAgICAgICAgICAgLy8gcmVtb3ZlZC4gRG9pbmcgaXQgbWFudWFsbHkgc2luY2Ugd2Ugd2FudCB0byBhdm9pZCBhIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgIHN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoc2VsZi5zcmMpIHtcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHNlbGYuc3JjKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZWxmLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmLnNyYykge1xuICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc2VsZi5zcmMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc2hpbVBlZXJDb25uZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAvLyBUaGUgUlRDUGVlckNvbm5lY3Rpb24gb2JqZWN0LlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKSB7XG4gICAgICAvLyBUcmFuc2xhdGUgaWNlVHJhbnNwb3J0UG9saWN5IHRvIGljZVRyYW5zcG9ydHMsXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD00ODY5XG4gICAgICBsb2dnaW5nKCdQZWVyQ29ubmVjdGlvbicpO1xuICAgICAgaWYgKHBjQ29uZmlnICYmIHBjQ29uZmlnLmljZVRyYW5zcG9ydFBvbGljeSkge1xuICAgICAgICBwY0NvbmZpZy5pY2VUcmFuc3BvcnRzID0gcGNDb25maWcuaWNlVHJhbnNwb3J0UG9saWN5O1xuICAgICAgfVxuXG4gICAgICB2YXIgcGMgPSBuZXcgd2Via2l0UlRDUGVlckNvbm5lY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpO1xuICAgICAgdmFyIG9yaWdHZXRTdGF0cyA9IHBjLmdldFN0YXRzLmJpbmQocGMpO1xuICAgICAgcGMuZ2V0U3RhdHMgPSBmdW5jdGlvbihzZWxlY3Rvciwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgLy8gSWYgc2VsZWN0b3IgaXMgYSBmdW5jdGlvbiB0aGVuIHdlIGFyZSBpbiB0aGUgb2xkIHN0eWxlIHN0YXRzIHNvIGp1c3RcbiAgICAgICAgLy8gcGFzcyBiYWNrIHRoZSBvcmlnaW5hbCBnZXRTdGF0cyBmb3JtYXQgdG8gYXZvaWQgYnJlYWtpbmcgb2xkIHVzZXJzLlxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdHZXRTdGF0cyhzZWxlY3Rvciwgc3VjY2Vzc0NhbGxiYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXhDaHJvbWVTdGF0c18gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHZhciBzdGFuZGFyZFJlcG9ydCA9IHt9O1xuICAgICAgICAgIHZhciByZXBvcnRzID0gcmVzcG9uc2UucmVzdWx0KCk7XG4gICAgICAgICAgcmVwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHJlcG9ydCkge1xuICAgICAgICAgICAgdmFyIHN0YW5kYXJkU3RhdHMgPSB7XG4gICAgICAgICAgICAgIGlkOiByZXBvcnQuaWQsXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogcmVwb3J0LnRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgdHlwZTogcmVwb3J0LnR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXBvcnQubmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgc3RhbmRhcmRTdGF0c1tuYW1lXSA9IHJlcG9ydC5zdGF0KG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGFuZGFyZFJlcG9ydFtzdGFuZGFyZFN0YXRzLmlkXSA9IHN0YW5kYXJkU3RhdHM7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gc3RhbmRhcmRSZXBvcnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2hpbSBnZXRTdGF0cyB3aXRoIG1hcGxpa2Ugc3VwcG9ydFxuICAgICAgICB2YXIgbWFrZU1hcFN0YXRzID0gZnVuY3Rpb24oc3RhdHMsIGxlZ2FjeVN0YXRzKSB7XG4gICAgICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoT2JqZWN0LmtleXMoc3RhdHMpLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybltrZXksIHN0YXRzW2tleV1dO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBsZWdhY3lTdGF0cyA9IGxlZ2FjeVN0YXRzIHx8IHN0YXRzO1xuICAgICAgICAgIE9iamVjdC5rZXlzKGxlZ2FjeVN0YXRzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgbWFwW2tleV0gPSBsZWdhY3lTdGF0c1trZXldO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIHZhciBzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXyA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBhcmdzWzFdKG1ha2VNYXBTdGF0cyhmaXhDaHJvbWVTdGF0c18ocmVzcG9uc2UpKSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgW3N1Y2Nlc3NDYWxsYmFja1dyYXBwZXJfLFxuICAgICAgICAgICAgICBhcmd1bWVudHNbMF1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByb21pc2Utc3VwcG9ydFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9yaWdHZXRTdGF0cy5hcHBseShzZWxmLCBbXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtYWtlTWFwU3RhdHMoZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSkpO1xuICAgICAgICAgICAgICB9LCByZWplY3RdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgbGVnYWN5IGNocm9tZSBzdGF0cyBvbmx5IG9uIGxlZ2FjeSBhY2Nlc3Mgb2Ygc3RhdHMgb2JqXG4gICAgICAgICAgICBvcmlnR2V0U3RhdHMuYXBwbHkoc2VsZiwgW1xuICAgICAgICAgICAgICBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobWFrZU1hcFN0YXRzKGZpeENocm9tZVN0YXRzXyhyZXNwb25zZSksXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJlc3VsdCgpKSk7XG4gICAgICAgICAgICAgIH0sIHJlamVjdF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHBjO1xuICAgIH07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSA9IHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcblxuICAgIC8vIHdyYXAgc3RhdGljIG1ldGhvZHMuIEN1cnJlbnRseSBqdXN0IGdlbmVyYXRlQ2VydGlmaWNhdGUuXG4gICAgaWYgKHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLmdlbmVyYXRlQ2VydGlmaWNhdGUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24sICdnZW5lcmF0ZUNlcnRpZmljYXRlJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5nZW5lcmF0ZUNlcnRpZmljYXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBbJ2NyZWF0ZU9mZmVyJywgJ2NyZWF0ZUFuc3dlciddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICB2YXIgbmF0aXZlTWV0aG9kID0gd2Via2l0UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSB8fCAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIG5hdGl2ZU1ldGhvZC5hcHBseShzZWxmLCBbcmVzb2x2ZSwgcmVqZWN0LCBvcHRzXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBwcm9taXNlIHN1cHBvcnQgLS0gbmF0aXZlbHkgYXZhaWxhYmxlIGluIENocm9tZSA1MVxuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTEpIHtcbiAgICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgdmFyIG5hdGl2ZU1ldGhvZCA9IHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICAgICAgd2Via2l0UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVNZXRob2QuYXBwbHkoc2VsZiwgW2FyZ3NbMF0sIHJlc29sdmUsIHJlamVjdF0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXJnc1sxXS5hcHBseShudWxsLCBbXSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzWzJdLmFwcGx5KG51bGwsIFtlcnJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzaGltIGltcGxpY2l0IGNyZWF0aW9uIG9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbi9SVENJY2VDYW5kaWRhdGVcbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ11cbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgdmFyIG5hdGl2ZU1ldGhvZCA9IHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICAgIHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgKChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnKSA/XG4gICAgICAgICAgICAgICAgUlRDSWNlQ2FuZGlkYXRlIDogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgLy8gc3VwcG9ydCBmb3IgYWRkSWNlQ2FuZGlkYXRlKG51bGwgb3IgdW5kZWZpbmVkKVxuICAgIHZhciBuYXRpdmVBZGRJY2VDYW5kaWRhdGUgPVxuICAgICAgICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuICAgIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgICBhcmd1bWVudHNbMV0uYXBwbHkobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn07XG5cblxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNoaW1NZWRpYVN0cmVhbTogY2hyb21lU2hpbS5zaGltTWVkaWFTdHJlYW0sXG4gIHNoaW1PblRyYWNrOiBjaHJvbWVTaGltLnNoaW1PblRyYWNrLFxuICBzaGltU291cmNlT2JqZWN0OiBjaHJvbWVTaGltLnNoaW1Tb3VyY2VPYmplY3QsXG4gIHNoaW1QZWVyQ29ubmVjdGlvbjogY2hyb21lU2hpbS5zaGltUGVlckNvbm5lY3Rpb24sXG4gIHNoaW1HZXRVc2VyTWVkaWE6IHJlcXVpcmUoJy4vZ2V0dXNlcm1lZGlhJylcbn07XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbiAvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBsb2dnaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMuanMnKS5sb2c7XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb25zdHJhaW50c1RvQ2hyb21lXyA9IGZ1bmN0aW9uKGMpIHtcbiAgICBpZiAodHlwZW9mIGMgIT09ICdvYmplY3QnIHx8IGMubWFuZGF0b3J5IHx8IGMub3B0aW9uYWwpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICB2YXIgY2MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlcXVpcmUnIHx8IGtleSA9PT0gJ2FkdmFuY2VkJyB8fCBrZXkgPT09ICdtZWRpYVNvdXJjZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHIgPSAodHlwZW9mIGNba2V5XSA9PT0gJ29iamVjdCcpID8gY1trZXldIDoge2lkZWFsOiBjW2tleV19O1xuICAgICAgaWYgKHIuZXhhY3QgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygci5leGFjdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgci5taW4gPSByLm1heCA9IHIuZXhhY3Q7XG4gICAgICB9XG4gICAgICB2YXIgb2xkbmFtZV8gPSBmdW5jdGlvbihwcmVmaXgsIG5hbWUpIHtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5hbWUgPT09ICdkZXZpY2VJZCcpID8gJ3NvdXJjZUlkJyA6IG5hbWU7XG4gICAgICB9O1xuICAgICAgaWYgKHIuaWRlYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYy5vcHRpb25hbCA9IGNjLm9wdGlvbmFsIHx8IFtdO1xuICAgICAgICB2YXIgb2MgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiByLmlkZWFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCdtaW4nLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgICAgb2MgPSB7fTtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWF4Jywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9jW29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNjLm1hbmRhdG9yeSA9IGNjLm1hbmRhdG9yeSB8fCB7fTtcbiAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKCcnLCBrZXkpXSA9IHIuZXhhY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbJ21pbicsICdtYXgnXS5mb3JFYWNoKGZ1bmN0aW9uKG1peCkge1xuICAgICAgICAgIGlmIChyW21peF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2MubWFuZGF0b3J5ID0gY2MubWFuZGF0b3J5IHx8IHt9O1xuICAgICAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKG1peCwga2V5KV0gPSByW21peF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoYy5hZHZhbmNlZCkge1xuICAgICAgY2Mub3B0aW9uYWwgPSAoY2Mub3B0aW9uYWwgfHwgW10pLmNvbmNhdChjLmFkdmFuY2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNjO1xuICB9O1xuXG4gIHZhciBzaGltQ29uc3RyYWludHNfID0gZnVuY3Rpb24oY29uc3RyYWludHMsIGZ1bmMpIHtcbiAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICBpZiAoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMuYXVkaW8pIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMuYXVkaW8pO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMgJiYgdHlwZW9mIGNvbnN0cmFpbnRzLnZpZGVvID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gU2hpbSBmYWNpbmdNb2RlIGZvciBtb2JpbGUsIHdoZXJlIGl0IGRlZmF1bHRzIHRvIFwidXNlclwiLlxuICAgICAgdmFyIGZhY2UgPSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xuICAgICAgZmFjZSA9IGZhY2UgJiYgKCh0eXBlb2YgZmFjZSA9PT0gJ29iamVjdCcpID8gZmFjZSA6IHtpZGVhbDogZmFjZX0pO1xuXG4gICAgICBpZiAoKGZhY2UgJiYgKGZhY2UuZXhhY3QgPT09ICd1c2VyJyB8fCBmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8XG4gICAgICAgICAgICAgICAgICAgIGZhY2UuaWRlYWwgPT09ICd1c2VyJyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSkgJiZcbiAgICAgICAgICAhKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMgJiZcbiAgICAgICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKS5mYWNpbmdNb2RlKSkge1xuICAgICAgICBkZWxldGUgY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgICAgaWYgKGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50Jykge1xuICAgICAgICAgIC8vIExvb2sgZm9yIFwiYmFja1wiIGluIGxhYmVsLCBvciB1c2UgbGFzdCBjYW0gKHR5cGljYWxseSBiYWNrIGNhbSkuXG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGV2aWNlcykge1xuICAgICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQua2luZCA9PT0gJ3ZpZGVvaW5wdXQnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgYmFjayA9IGRldmljZXMuZmluZChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignYmFjaycpICE9PSAtMTtcbiAgICAgICAgICAgIH0pIHx8IChkZXZpY2VzLmxlbmd0aCAmJiBkZXZpY2VzW2RldmljZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgaWYgKGJhY2spIHtcbiAgICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8uZGV2aWNlSWQgPSBmYWNlLmV4YWN0ID8ge2V4YWN0OiBiYWNrLmRldmljZUlkfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpZGVhbDogYmFjay5kZXZpY2VJZH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICAgICAgICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgIH1cbiAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgfTtcblxuICB2YXIgc2hpbUVycm9yXyA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToge1xuICAgICAgICBQZXJtaXNzaW9uRGVuaWVkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBDb25zdHJhaW50Tm90U2F0aXNmaWVkRXJyb3I6ICdPdmVyY29uc3RyYWluZWRFcnJvcidcbiAgICAgIH1bZS5uYW1lXSB8fCBlLm5hbWUsXG4gICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICBjb25zdHJhaW50OiBlLmNvbnN0cmFpbnROYW1lLFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgKHRoaXMubWVzc2FnZSAmJiAnOiAnKSArIHRoaXMubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBnZXRVc2VyTWVkaWFfID0gZnVuY3Rpb24oY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIHNoaW1Db25zdHJhaW50c18oY29uc3RyYWludHMsIGZ1bmN0aW9uKGMpIHtcbiAgICAgIG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEoYywgb25TdWNjZXNzLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIG9uRXJyb3Ioc2hpbUVycm9yXyhlKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZ2V0VXNlck1lZGlhXztcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZ2V0VXNlck1lZGlhIGFzIGEgUHJvbWlzZS5cbiAgdmFyIGdldFVzZXJNZWRpYVByb21pc2VfID0gZnVuY3Rpb24oY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzLCByZXNvbHZlLCByZWplY3QpO1xuICAgIH0pO1xuICB9O1xuXG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMgPSB7XG4gICAgICBnZXRVc2VyTWVkaWE6IGdldFVzZXJNZWRpYVByb21pc2VfLFxuICAgICAgZW51bWVyYXRlRGV2aWNlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgdmFyIGtpbmRzID0ge2F1ZGlvOiAnYXVkaW9pbnB1dCcsIHZpZGVvOiAndmlkZW9pbnB1dCd9O1xuICAgICAgICAgIHJldHVybiBNZWRpYVN0cmVhbVRyYWNrLmdldFNvdXJjZXMoZnVuY3Rpb24oZGV2aWNlcykge1xuICAgICAgICAgICAgcmVzb2x2ZShkZXZpY2VzLm1hcChmdW5jdGlvbihkZXZpY2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtsYWJlbDogZGV2aWNlLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmRzW2RldmljZS5raW5kXSxcbiAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VJZDogZGV2aWNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGdyb3VwSWQ6ICcnfTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIEEgc2hpbSBmb3IgZ2V0VXNlck1lZGlhIG1ldGhvZCBvbiB0aGUgbWVkaWFEZXZpY2VzIG9iamVjdC5cbiAgLy8gVE9ETyhLYXB0ZW5KYW5zc29uKSByZW1vdmUgb25jZSBpbXBsZW1lbnRlZCBpbiBDaHJvbWUgc3RhYmxlLlxuICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbihjb25zdHJhaW50cykge1xuICAgICAgcmV0dXJuIGdldFVzZXJNZWRpYVByb21pc2VfKGNvbnN0cmFpbnRzKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIEV2ZW4gdGhvdWdoIENocm9tZSA0NSBoYXMgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyBhbmQgYSBnZXRVc2VyTWVkaWFcbiAgICAvLyBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgUHJvbWlzZSwgaXQgZG9lcyBub3QgYWNjZXB0IHNwZWMtc3R5bGVcbiAgICAvLyBjb25zdHJhaW50cy5cbiAgICB2YXIgb3JpZ0dldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLlxuICAgICAgICBiaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oY3MpIHtcbiAgICAgIHJldHVybiBzaGltQ29uc3RyYWludHNfKGNzLCBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBvcmlnR2V0VXNlck1lZGlhKGMpLnRoZW4oZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgaWYgKGMuYXVkaW8gJiYgIXN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCB8fFxuICAgICAgICAgICAgICBjLnZpZGVvICYmICFzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignJywgJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChzaGltRXJyb3JfKGUpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgLy8gRHVtbXkgZGV2aWNlY2hhbmdlIGV2ZW50IG1ldGhvZHMuXG4gIC8vIFRPRE8oS2FwdGVuSmFuc3NvbikgcmVtb3ZlIG9uY2UgaW1wbGVtZW50ZWQgaW4gQ2hyb21lIHN0YWJsZS5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmFkZEV2ZW50TGlzdGVuZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBsb2dnaW5nKCdEdW1teSBtZWRpYURldmljZXMuYWRkRXZlbnRMaXN0ZW5lciBjYWxsZWQuJyk7XG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIG5hdmlnYXRvci5tZWRpYURldmljZXMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGxvZ2dpbmcoJ0R1bW15IG1lZGlhRGV2aWNlcy5yZW1vdmVFdmVudExpc3RlbmVyIGNhbGxlZC4nKTtcbiAgICB9O1xuICB9XG59O1xuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4gLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTRFBVdGlscyA9IHJlcXVpcmUoJ3NkcCcpO1xudmFyIGJyb3dzZXJEZXRhaWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5icm93c2VyRGV0YWlscztcblxudmFyIGVkZ2VTaGltID0ge1xuICBzaGltUGVlckNvbm5lY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgIGlmICh3aW5kb3cuUlRDSWNlR2F0aGVyZXIpIHtcbiAgICAgIC8vIE9SVEMgZGVmaW5lcyBhbiBSVENJY2VDYW5kaWRhdGUgb2JqZWN0IGJ1dCBubyBjb25zdHJ1Y3Rvci5cbiAgICAgIC8vIE5vdCBpbXBsZW1lbnRlZCBpbiBFZGdlLlxuICAgICAgaWYgKCF3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlKSB7XG4gICAgICAgIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBPUlRDIGRvZXMgbm90IGhhdmUgYSBzZXNzaW9uIGRlc2NyaXB0aW9uIG9iamVjdCBidXRcbiAgICAgIC8vIG90aGVyIGJyb3dzZXJzIChpLmUuIENocm9tZSkgdGhhdCB3aWxsIHN1cHBvcnQgYm90aCBQQyBhbmQgT1JUQ1xuICAgICAgLy8gaW4gdGhlIGZ1dHVyZSBtaWdodCBoYXZlIHRoaXMgZGVmaW5lZCBhbHJlYWR5LlxuICAgICAgaWYgKCF3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGFkZHMgYW4gYWRkaXRpb25hbCBldmVudCBsaXN0ZW5lciB0byBNZWRpYVN0cmFja1RyYWNrIHRoYXQgc2lnbmFsc1xuICAgICAgLy8gd2hlbiBhIHRyYWNrcyBlbmFibGVkIHByb3BlcnR5IHdhcyBjaGFuZ2VkLlxuICAgICAgdmFyIG9yaWdNU1RFbmFibGVkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZSwgJ2VuYWJsZWQnKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZSwgJ2VuYWJsZWQnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBvcmlnTVNURW5hYmxlZC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgdmFyIGV2ID0gbmV3IEV2ZW50KCdlbmFibGVkJyk7XG4gICAgICAgICAgZXYuZW5hYmxlZCA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB2YXIgX2V2ZW50VGFyZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgWydhZGRFdmVudExpc3RlbmVyJywgJ3JlbW92ZUV2ZW50TGlzdGVuZXInLCAnZGlzcGF0Y2hFdmVudCddXG4gICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICBzZWxmW21ldGhvZF0gPSBfZXZlbnRUYXJnZXRbbWV0aG9kXS5iaW5kKF9ldmVudFRhcmdldCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgIHRoaXMub25pY2VjYW5kaWRhdGUgPSBudWxsO1xuICAgICAgdGhpcy5vbmFkZHN0cmVhbSA9IG51bGw7XG4gICAgICB0aGlzLm9udHJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5vbnJlbW92ZXN0cmVhbSA9IG51bGw7XG4gICAgICB0aGlzLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLm9ubmVnb3RpYXRpb25uZWVkZWQgPSBudWxsO1xuICAgICAgdGhpcy5vbmRhdGFjaGFubmVsID0gbnVsbDtcblxuICAgICAgdGhpcy5sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgIHRoaXMucmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgICAgdGhpcy5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubG9jYWxTdHJlYW1zO1xuICAgICAgfTtcbiAgICAgIHRoaXMuZ2V0UmVtb3RlU3RyZWFtcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5yZW1vdGVTdHJlYW1zO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5sb2NhbERlc2NyaXB0aW9uID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgIHR5cGU6ICcnLFxuICAgICAgICBzZHA6ICcnXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVtb3RlRGVzY3JpcHRpb24gPSBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgdHlwZTogJycsXG4gICAgICAgIHNkcDogJydcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaWduYWxpbmdTdGF0ZSA9ICdzdGFibGUnO1xuICAgICAgdGhpcy5pY2VDb25uZWN0aW9uU3RhdGUgPSAnbmV3JztcbiAgICAgIHRoaXMuaWNlR2F0aGVyaW5nU3RhdGUgPSAnbmV3JztcblxuICAgICAgdGhpcy5pY2VPcHRpb25zID0ge1xuICAgICAgICBnYXRoZXJQb2xpY3k6ICdhbGwnLFxuICAgICAgICBpY2VTZXJ2ZXJzOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLmljZVRyYW5zcG9ydFBvbGljeSkge1xuICAgICAgICBzd2l0Y2ggKGNvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3kpIHtcbiAgICAgICAgICBjYXNlICdhbGwnOlxuICAgICAgICAgIGNhc2UgJ3JlbGF5JzpcbiAgICAgICAgICAgIHRoaXMuaWNlT3B0aW9ucy5nYXRoZXJQb2xpY3kgPSBjb25maWcuaWNlVHJhbnNwb3J0UG9saWN5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAvLyBGSVhNRTogcmVtb3ZlIG9uY2UgaW1wbGVtZW50YXRpb24gYW5kIHNwZWMgaGF2ZSBhZGRlZCB0aGlzLlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWNlVHJhbnNwb3J0UG9saWN5IFwibm9uZVwiIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gZG9uJ3Qgc2V0IGljZVRyYW5zcG9ydFBvbGljeS5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVzaW5nQnVuZGxlID0gY29uZmlnICYmIGNvbmZpZy5idW5kbGVQb2xpY3kgPT09ICdtYXgtYnVuZGxlJztcblxuICAgICAgaWYgKGNvbmZpZyAmJiBjb25maWcuaWNlU2VydmVycykge1xuICAgICAgICAvLyBFZGdlIGRvZXMgbm90IGxpa2VcbiAgICAgICAgLy8gMSkgc3R1bjpcbiAgICAgICAgLy8gMikgdHVybjogdGhhdCBkb2VzIG5vdCBoYXZlIGFsbCBvZiB0dXJuOmhvc3Q6cG9ydD90cmFuc3BvcnQ9dWRwXG4gICAgICAgIC8vIDMpIHR1cm46IHdpdGggaXB2NiBhZGRyZXNzZXNcbiAgICAgICAgdmFyIGljZVNlcnZlcnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbmZpZy5pY2VTZXJ2ZXJzKSk7XG4gICAgICAgIHRoaXMuaWNlT3B0aW9ucy5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycy5maWx0ZXIoZnVuY3Rpb24oc2VydmVyKSB7XG4gICAgICAgICAgaWYgKHNlcnZlciAmJiBzZXJ2ZXIudXJscykge1xuICAgICAgICAgICAgdmFyIHVybHMgPSBzZXJ2ZXIudXJscztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJscyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdXJscyA9IFt1cmxzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybHMgPSB1cmxzLmZpbHRlcihmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICh1cmwuaW5kZXhPZigndHVybjonKSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgdXJsLmluZGV4T2YoJ3RyYW5zcG9ydD11ZHAnKSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgIHVybC5pbmRleE9mKCd0dXJuOlsnKSA9PT0gLTEpIHx8XG4gICAgICAgICAgICAgICAgICAodXJsLmluZGV4T2YoJ3N0dW46JykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSAxNDM5Myk7XG4gICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIHJldHVybiAhIXVybHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG5cbiAgICAgIC8vIHBlci10cmFjayBpY2VHYXRoZXJzLCBpY2VUcmFuc3BvcnRzLCBkdGxzVHJhbnNwb3J0cywgcnRwU2VuZGVycywgLi4uXG4gICAgICAvLyBldmVyeXRoaW5nIHRoYXQgaXMgbmVlZGVkIHRvIGRlc2NyaWJlIGEgU0RQIG0tbGluZS5cbiAgICAgIHRoaXMudHJhbnNjZWl2ZXJzID0gW107XG5cbiAgICAgIC8vIHNpbmNlIHRoZSBpY2VHYXRoZXJlciBpcyBjdXJyZW50bHkgY3JlYXRlZCBpbiBjcmVhdGVPZmZlciBidXQgd2VcbiAgICAgIC8vIG11c3Qgbm90IGVtaXQgY2FuZGlkYXRlcyB1bnRpbCBhZnRlciBzZXRMb2NhbERlc2NyaXB0aW9uIHdlIGJ1ZmZlclxuICAgICAgLy8gdGhlbSBpbiB0aGlzIGFycmF5LlxuICAgICAgdGhpcy5fbG9jYWxJY2VDYW5kaWRhdGVzQnVmZmVyID0gW107XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX2VtaXRCdWZmZXJlZENhbmRpZGF0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoc2VsZi5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAvLyBGSVhNRTogbmVlZCB0byBhcHBseSBpY2UgY2FuZGlkYXRlcyBpbiBhIHdheSB3aGljaCBpcyBhc3luYyBidXRcbiAgICAgIC8vIGluLW9yZGVyXG4gICAgICB0aGlzLl9sb2NhbEljZUNhbmRpZGF0ZXNCdWZmZXIuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgZW5kID0gIWV2ZW50LmNhbmRpZGF0ZSB8fCBPYmplY3Qua2V5cyhldmVudC5jYW5kaWRhdGUpLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgc2VjdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uc1tqXS5pbmRleE9mKCdcXHJcXG5hPWVuZC1vZi1jYW5kaWRhdGVzXFxyXFxuJykgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHNlY3Rpb25zW2pdICs9ICdhPWVuZC1vZi1jYW5kaWRhdGVzXFxyXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZS5pbmRleE9mKCd0eXAgZW5kT2ZDYW5kaWRhdGVzJylcbiAgICAgICAgICAgID09PSAtMSkge1xuICAgICAgICAgIHNlY3Rpb25zW2V2ZW50LmNhbmRpZGF0ZS5zZHBNTGluZUluZGV4ICsgMV0gKz1cbiAgICAgICAgICAgICAgJ2E9JyArIGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUgKyAnXFxyXFxuJztcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmxvY2FsRGVzY3JpcHRpb24uc2RwID0gc2VjdGlvbnMuam9pbignJyk7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIGlmIChzZWxmLm9uaWNlY2FuZGlkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgc2VsZi5vbmljZWNhbmRpZGF0ZShldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFldmVudC5jYW5kaWRhdGUgJiYgc2VsZi5pY2VHYXRoZXJpbmdTdGF0ZSAhPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgIHZhciBjb21wbGV0ZSA9IHNlbGYudHJhbnNjZWl2ZXJzLmV2ZXJ5KGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIgJiZcbiAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5zdGF0ZSA9PT0gJ2NvbXBsZXRlZCc7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICBzZWxmLmljZUdhdGhlcmluZ1N0YXRlID0gJ2NvbXBsZXRlJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fbG9jYWxJY2VDYW5kaWRhdGVzQnVmZmVyID0gW107XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0Q29uZmlndXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIC8vIENsb25lIGlzIG5lY2Vzc2FyeSBmb3IgbG9jYWwgZGVtb3MgbW9zdGx5LCBhdHRhY2hpbmcgZGlyZWN0bHlcbiAgICAgIC8vIHRvIHR3byBkaWZmZXJlbnQgc2VuZGVycyBkb2VzIG5vdCB3b3JrIChidWlsZCAxMDU0NykuXG4gICAgICB2YXIgY2xvbmVkU3RyZWFtID0gc3RyZWFtLmNsb25lKCk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaywgaWR4KSB7XG4gICAgICAgIHZhciBjbG9uZWRUcmFjayA9IGNsb25lZFN0cmVhbS5nZXRUcmFja3MoKVtpZHhdO1xuICAgICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmFibGVkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICBjbG9uZWRUcmFjay5lbmFibGVkID0gZXZlbnQuZW5hYmxlZDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9jYWxTdHJlYW1zLnB1c2goY2xvbmVkU3RyZWFtKTtcbiAgICAgIHRoaXMuX21heWJlRmlyZU5lZ290aWF0aW9uTmVlZGVkKCk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICB2YXIgaWR4ID0gdGhpcy5sb2NhbFN0cmVhbXMuaW5kZXhPZihzdHJlYW0pO1xuICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdHJlYW1zLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB0aGlzLl9tYXliZUZpcmVOZWdvdGlhdGlvbk5lZWRlZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zY2VpdmVycy5maWx0ZXIoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuICEhdHJhbnNjZWl2ZXIucnRwU2VuZGVyO1xuICAgICAgfSlcbiAgICAgIC5tYXAoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJ0cFNlbmRlcjtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNjZWl2ZXJzLmZpbHRlcihmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICByZXR1cm4gISF0cmFuc2NlaXZlci5ydHBSZWNlaXZlcjtcbiAgICAgIH0pXG4gICAgICAubWFwKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcjtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBEZXRlcm1pbmVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgbG9jYWwgYW5kIHJlbW90ZSBjYXBhYmlsaXRpZXMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fZ2V0Q29tbW9uQ2FwYWJpbGl0aWVzID1cbiAgICAgICAgZnVuY3Rpb24obG9jYWxDYXBhYmlsaXRpZXMsIHJlbW90ZUNhcGFiaWxpdGllcykge1xuICAgICAgICAgIHZhciBjb21tb25DYXBhYmlsaXRpZXMgPSB7XG4gICAgICAgICAgICBjb2RlY3M6IFtdLFxuICAgICAgICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgICAgICAgICBmZWNNZWNoYW5pc21zOiBbXVxuICAgICAgICAgIH07XG4gICAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXMuY29kZWNzLmZvckVhY2goZnVuY3Rpb24obENvZGVjKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW90ZUNhcGFiaWxpdGllcy5jb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHJDb2RlYyA9IHJlbW90ZUNhcGFiaWxpdGllcy5jb2RlY3NbaV07XG4gICAgICAgICAgICAgIGlmIChsQ29kZWMubmFtZS50b0xvd2VyQ2FzZSgpID09PSByQ29kZWMubmFtZS50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgICAgICAgICAgICBsQ29kZWMuY2xvY2tSYXRlID09PSByQ29kZWMuY2xvY2tSYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGNoYW5uZWxzIGlzIHRoZSBoaWdoZXN0IGNvbW1vbiBudW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgICAgICAgICAgICByQ29kZWMubnVtQ2hhbm5lbHMgPSBNYXRoLm1pbihsQ29kZWMubnVtQ2hhbm5lbHMsXG4gICAgICAgICAgICAgICAgICAgIHJDb2RlYy5udW1DaGFubmVscyk7XG4gICAgICAgICAgICAgICAgLy8gcHVzaCByQ29kZWMgc28gd2UgcmVwbHkgd2l0aCBvZmZlcmVyIHBheWxvYWQgdHlwZVxuICAgICAgICAgICAgICAgIGNvbW1vbkNhcGFiaWxpdGllcy5jb2RlY3MucHVzaChyQ29kZWMpO1xuXG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGNvbW1vbiBmZWVkYmFjayBtZWNoYW5pc21zXG4gICAgICAgICAgICAgICAgckNvZGVjLnJ0Y3BGZWVkYmFjayA9IHJDb2RlYy5ydGNwRmVlZGJhY2suZmlsdGVyKGZ1bmN0aW9uKGZiKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxDb2RlYy5ydGNwRmVlZGJhY2subGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxDb2RlYy5ydGNwRmVlZGJhY2tbal0udHlwZSA9PT0gZmIudHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbENvZGVjLnJ0Y3BGZWVkYmFja1tqXS5wYXJhbWV0ZXIgPT09IGZiLnBhcmFtZXRlcikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IGFsc28gbmVlZCB0byBkZXRlcm1pbmUgLnBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAvLyAgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVucGVlci9vcnRjL2lzc3Vlcy81NjlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihsSGVhZGVyRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdGVDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBySGVhZGVyRXh0ZW5zaW9uID0gcmVtb3RlQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnNbaV07XG4gICAgICAgICAgICAgICAgICBpZiAobEhlYWRlckV4dGVuc2lvbi51cmkgPT09IHJIZWFkZXJFeHRlbnNpb24udXJpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbkNhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zLnB1c2gockhlYWRlckV4dGVuc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBGSVhNRTogZmVjTWVjaGFuaXNtc1xuICAgICAgICAgIHJldHVybiBjb21tb25DYXBhYmlsaXRpZXM7XG4gICAgICAgIH07XG5cbiAgICAvLyBDcmVhdGUgSUNFIGdhdGhlcmVyLCBJQ0UgdHJhbnNwb3J0IGFuZCBEVExTIHRyYW5zcG9ydC5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9jcmVhdGVJY2VBbmREdGxzVHJhbnNwb3J0cyA9XG4gICAgICAgIGZ1bmN0aW9uKG1pZCwgc2RwTUxpbmVJbmRleCkge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICB2YXIgaWNlR2F0aGVyZXIgPSBuZXcgUlRDSWNlR2F0aGVyZXIoc2VsZi5pY2VPcHRpb25zKTtcbiAgICAgICAgICB2YXIgaWNlVHJhbnNwb3J0ID0gbmV3IFJUQ0ljZVRyYW5zcG9ydChpY2VHYXRoZXJlcik7XG4gICAgICAgICAgaWNlR2F0aGVyZXIub25sb2NhbGNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdpY2VjYW5kaWRhdGUnKTtcbiAgICAgICAgICAgIGV2ZW50LmNhbmRpZGF0ZSA9IHtzZHBNaWQ6IG1pZCwgc2RwTUxpbmVJbmRleDogc2RwTUxpbmVJbmRleH07XG5cbiAgICAgICAgICAgIHZhciBjYW5kID0gZXZ0LmNhbmRpZGF0ZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSAhY2FuZCB8fCBPYmplY3Qua2V5cyhjYW5kKS5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICAvLyBFZGdlIGVtaXRzIGFuIGVtcHR5IG9iamVjdCBmb3IgUlRDSWNlQ2FuZGlkYXRlQ29tcGxldGXigKVcbiAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgLy8gcG9seWZpbGwgc2luY2UgUlRDSWNlR2F0aGVyZXIuc3RhdGUgaXMgbm90IGltcGxlbWVudGVkIGluXG4gICAgICAgICAgICAgIC8vIEVkZ2UgMTA1NDcgeWV0LlxuICAgICAgICAgICAgICBpZiAoaWNlR2F0aGVyZXIuc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGljZUdhdGhlcmVyLnN0YXRlID0gJ2NvbXBsZXRlZCc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBFbWl0IGEgY2FuZGlkYXRlIHdpdGggdHlwZSBlbmRPZkNhbmRpZGF0ZXMgdG8gbWFrZSB0aGUgc2FtcGxlc1xuICAgICAgICAgICAgICAvLyB3b3JrLiBFZGdlIHJlcXVpcmVzIGFkZEljZUNhbmRpZGF0ZSB3aXRoIHRoaXMgZW1wdHkgY2FuZGlkYXRlXG4gICAgICAgICAgICAgIC8vIHRvIHN0YXJ0IGNoZWNraW5nLiBUaGUgcmVhbCBzb2x1dGlvbiBpcyB0byBzaWduYWxcbiAgICAgICAgICAgICAgLy8gZW5kLW9mLWNhbmRpZGF0ZXMgdG8gdGhlIG90aGVyIHNpZGUgd2hlbiBnZXR0aW5nIHRoZSBudWxsXG4gICAgICAgICAgICAgIC8vIGNhbmRpZGF0ZSBidXQgc29tZSBhcHBzIChsaWtlIHRoZSBzYW1wbGVzKSBkb24ndCBkbyB0aGF0LlxuICAgICAgICAgICAgICBldmVudC5jYW5kaWRhdGUuY2FuZGlkYXRlID1cbiAgICAgICAgICAgICAgICAgICdjYW5kaWRhdGU6MSAxIHVkcCAxIDAuMC4wLjAgOSB0eXAgZW5kT2ZDYW5kaWRhdGVzJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJUQ0ljZUNhbmRpZGF0ZSBkb2Vzbid0IGhhdmUgYSBjb21wb25lbnQsIG5lZWRzIHRvIGJlIGFkZGVkXG4gICAgICAgICAgICAgIGNhbmQuY29tcG9uZW50ID0gaWNlVHJhbnNwb3J0LmNvbXBvbmVudCA9PT0gJ1JUQ1AnID8gMiA6IDE7XG4gICAgICAgICAgICAgIGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUgPSBTRFBVdGlscy53cml0ZUNhbmRpZGF0ZShjYW5kKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdXBkYXRlIGxvY2FsIGRlc2NyaXB0aW9uLlxuICAgICAgICAgICAgdmFyIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhzZWxmLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgICAgIGlmIChldmVudC5jYW5kaWRhdGUuY2FuZGlkYXRlLmluZGV4T2YoJ3R5cCBlbmRPZkNhbmRpZGF0ZXMnKVxuICAgICAgICAgICAgICAgID09PSAtMSkge1xuICAgICAgICAgICAgICBzZWN0aW9uc1tldmVudC5jYW5kaWRhdGUuc2RwTUxpbmVJbmRleCArIDFdICs9XG4gICAgICAgICAgICAgICAgICAnYT0nICsgZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSArICdcXHJcXG4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VjdGlvbnNbZXZlbnQuY2FuZGlkYXRlLnNkcE1MaW5lSW5kZXggKyAxXSArPVxuICAgICAgICAgICAgICAgICAgJ2E9ZW5kLW9mLWNhbmRpZGF0ZXNcXHJcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5sb2NhbERlc2NyaXB0aW9uLnNkcCA9IHNlY3Rpb25zLmpvaW4oJycpO1xuXG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBzZWxmLnRyYW5zY2VpdmVycy5ldmVyeShmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIgJiZcbiAgICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyLnN0YXRlID09PSAnY29tcGxldGVkJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBFbWl0IGNhbmRpZGF0ZSBpZiBsb2NhbERlc2NyaXB0aW9uIGlzIHNldC5cbiAgICAgICAgICAgIC8vIEFsc28gZW1pdHMgbnVsbCBjYW5kaWRhdGUgd2hlbiBhbGwgZ2F0aGVyZXJzIGFyZSBjb21wbGV0ZS5cbiAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5pY2VHYXRoZXJpbmdTdGF0ZSkge1xuICAgICAgICAgICAgICBjYXNlICduZXcnOlxuICAgICAgICAgICAgICAgIHNlbGYuX2xvY2FsSWNlQ2FuZGlkYXRlc0J1ZmZlci5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kICYmIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLl9sb2NhbEljZUNhbmRpZGF0ZXNCdWZmZXIucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgRXZlbnQoJ2ljZWNhbmRpZGF0ZScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2dhdGhlcmluZyc6XG4gICAgICAgICAgICAgICAgc2VsZi5fZW1pdEJ1ZmZlcmVkQ2FuZGlkYXRlcygpO1xuICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYub25pY2VjYW5kaWRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYub25pY2VjYW5kaWRhdGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2ljZWNhbmRpZGF0ZScpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzZWxmLm9uaWNlY2FuZGlkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25pY2VjYW5kaWRhdGUobmV3IEV2ZW50KCdpY2VjYW5kaWRhdGUnKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzZWxmLmljZUdhdGhlcmluZ1N0YXRlID0gJ2NvbXBsZXRlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlJzpcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgbm90IGhhcHBlbi4uLiBjdXJyZW50bHkhXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IC8vIG5vLW9wLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWNlVHJhbnNwb3J0Lm9uaWNlc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUNvbm5lY3Rpb25TdGF0ZSgpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgZHRsc1RyYW5zcG9ydCA9IG5ldyBSVENEdGxzVHJhbnNwb3J0KGljZVRyYW5zcG9ydCk7XG4gICAgICAgICAgZHRsc1RyYW5zcG9ydC5vbmR0bHNzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlQ29ubmVjdGlvblN0YXRlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBkdGxzVHJhbnNwb3J0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIG9uZXJyb3IgZG9lcyBub3Qgc2V0IHN0YXRlIHRvIGZhaWxlZCBieSBpdHNlbGYuXG4gICAgICAgICAgICBkdGxzVHJhbnNwb3J0LnN0YXRlID0gJ2ZhaWxlZCc7XG4gICAgICAgICAgICBzZWxmLl91cGRhdGVDb25uZWN0aW9uU3RhdGUoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGljZUdhdGhlcmVyOiBpY2VHYXRoZXJlcixcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydDogaWNlVHJhbnNwb3J0LFxuICAgICAgICAgICAgZHRsc1RyYW5zcG9ydDogZHRsc1RyYW5zcG9ydFxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAvLyBTdGFydCB0aGUgUlRQIFNlbmRlciBhbmQgUmVjZWl2ZXIgZm9yIGEgdHJhbnNjZWl2ZXIuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fdHJhbnNjZWl2ZSA9IGZ1bmN0aW9uKHRyYW5zY2VpdmVyLFxuICAgICAgICBzZW5kLCByZWN2KSB7XG4gICAgICB2YXIgcGFyYW1zID0gdGhpcy5fZ2V0Q29tbW9uQ2FwYWJpbGl0aWVzKHRyYW5zY2VpdmVyLmxvY2FsQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgIHRyYW5zY2VpdmVyLnJlbW90ZUNhcGFiaWxpdGllcyk7XG4gICAgICBpZiAoc2VuZCAmJiB0cmFuc2NlaXZlci5ydHBTZW5kZXIpIHtcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICAgIHBhcmFtcy5ydGNwID0ge1xuICAgICAgICAgIGNuYW1lOiBTRFBVdGlscy5sb2NhbENOYW1lXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5yZWN2RW5jb2RpbmdQYXJhbWV0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHBhcmFtcy5ydGNwLnNzcmMgPSB0cmFuc2NlaXZlci5yZWN2RW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmM7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNjZWl2ZXIucnRwU2VuZGVyLnNlbmQocGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWN2ICYmIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyKSB7XG4gICAgICAgIC8vIHJlbW92ZSBSVFggZmllbGQgaW4gRWRnZSAxNDk0MlxuICAgICAgICBpZiAodHJhbnNjZWl2ZXIua2luZCA9PT0gJ3ZpZGVvJ1xuICAgICAgICAgICAgJiYgdHJhbnNjZWl2ZXIucmVjdkVuY29kaW5nUGFyYW1ldGVycykge1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICBkZWxldGUgcC5ydHg7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IHRyYW5zY2VpdmVyLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICAgIHBhcmFtcy5ydGNwID0ge1xuICAgICAgICAgIGNuYW1lOiB0cmFuc2NlaXZlci5jbmFtZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBwYXJhbXMucnRjcC5zc3JjID0gdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyLnJlY2VpdmUocGFyYW1zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID1cbiAgICAgICAgZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgdmFyIHNlY3Rpb25zO1xuICAgICAgICAgIHZhciBzZXNzaW9ucGFydDtcbiAgICAgICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgICAgICAgLy8gRklYTUU6IFdoYXQgd2FzIHRoZSBwdXJwb3NlIG9mIHRoaXMgZW1wdHkgaWYgc3RhdGVtZW50P1xuICAgICAgICAgICAgLy8gaWYgKCF0aGlzLl9wZW5kaW5nT2ZmZXIpIHtcbiAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ09mZmVyKSB7XG4gICAgICAgICAgICAgIC8vIFZFUlkgbGltaXRlZCBzdXBwb3J0IGZvciBTRFAgbXVuZ2luZy4gTGltaXRlZCB0bzpcbiAgICAgICAgICAgICAgLy8gKiBjaGFuZ2luZyB0aGUgb3JkZXIgb2YgY29kZWNzXG4gICAgICAgICAgICAgIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhkZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAgICAgICBzZXNzaW9ucGFydCA9IHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhcHMgPSBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9wZW5kaW5nT2ZmZXJbc2RwTUxpbmVJbmRleF0ubG9jYWxDYXBhYmlsaXRpZXMgPSBjYXBzO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy50cmFuc2NlaXZlcnMgPSB0aGlzLl9wZW5kaW5nT2ZmZXI7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nT2ZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgICAgICAgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKHNlbGYucmVtb3RlRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgICAgIHNlc3Npb25wYXJ0ID0gc2VjdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBpc0ljZUxpdGUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChzZXNzaW9ucGFydCxcbiAgICAgICAgICAgICAgICAnYT1pY2UtbGl0ZScpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBzZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2RwTUxpbmVJbmRleCkge1xuICAgICAgICAgICAgICB2YXIgdHJhbnNjZWl2ZXIgPSBzZWxmLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XTtcbiAgICAgICAgICAgICAgdmFyIGljZUdhdGhlcmVyID0gdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXI7XG4gICAgICAgICAgICAgIHZhciBpY2VUcmFuc3BvcnQgPSB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQ7XG4gICAgICAgICAgICAgIHZhciBkdGxzVHJhbnNwb3J0ID0gdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydDtcbiAgICAgICAgICAgICAgdmFyIGxvY2FsQ2FwYWJpbGl0aWVzID0gdHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXM7XG4gICAgICAgICAgICAgIHZhciByZW1vdGVDYXBhYmlsaXRpZXMgPSB0cmFuc2NlaXZlci5yZW1vdGVDYXBhYmlsaXRpZXM7XG5cbiAgICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gbWVkaWFTZWN0aW9uLnNwbGl0KCdcXG4nLCAxKVswXVxuICAgICAgICAgICAgICAgICAgLnNwbGl0KCcgJywgMilbMV0gPT09ICcwJztcblxuICAgICAgICAgICAgICBpZiAoIXJlamVjdGVkICYmICF0cmFuc2NlaXZlci5pc0RhdGFjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW90ZUljZVBhcmFtZXRlcnMgPSBTRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzKFxuICAgICAgICAgICAgICAgICAgICBtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJY2VMaXRlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FuZHMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPWNhbmRpZGF0ZTonKVxuICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihjYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShjYW5kKTtcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGNhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbmQuY29tcG9uZW50ID09PSAnMSc7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIC8vIGljZS1saXRlIG9ubHkgaW5jbHVkZXMgaG9zdCBjYW5kaWRhdGVzIGluIHRoZSBTRFAgc28gd2UgY2FuXG4gICAgICAgICAgICAgICAgICAvLyB1c2Ugc2V0UmVtb3RlQ2FuZGlkYXRlcyAod2hpY2ggaW1wbGllcyBhblxuICAgICAgICAgICAgICAgICAgLy8gUlRDSWNlQ2FuZGlkYXRlQ29tcGxldGUpXG4gICAgICAgICAgICAgICAgICBpZiAoY2FuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGljZVRyYW5zcG9ydC5zZXRSZW1vdGVDYW5kaWRhdGVzKGNhbmRzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlbW90ZUR0bHNQYXJhbWV0ZXJzID0gU0RQVXRpbHMuZ2V0RHRsc1BhcmFtZXRlcnMoXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ljZUxpdGUpIHtcbiAgICAgICAgICAgICAgICAgIHJlbW90ZUR0bHNQYXJhbWV0ZXJzLnJvbGUgPSAnc2VydmVyJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYudXNpbmdCdW5kbGUgfHwgc2RwTUxpbmVJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgaWNlVHJhbnNwb3J0LnN0YXJ0KGljZUdhdGhlcmVyLCByZW1vdGVJY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgICAgICAgIGlzSWNlTGl0ZSA/ICdjb250cm9sbGluZycgOiAnY29udHJvbGxlZCcpO1xuICAgICAgICAgICAgICAgICAgZHRsc1RyYW5zcG9ydC5zdGFydChyZW1vdGVEdGxzUGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbiBvZiBjYXBhYmlsaXRpZXMuXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHNlbGYuX2dldENvbW1vbkNhcGFiaWxpdGllcyhsb2NhbENhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlQ2FwYWJpbGl0aWVzKTtcblxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBSVENSdHBTZW5kZXIuIFRoZSBSVENSdHBSZWNlaXZlciBmb3IgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zY2VpdmVyIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCBpbiBzZXRSZW1vdGVEZXNjcmlwdGlvbi5cbiAgICAgICAgICAgICAgICBzZWxmLl90cmFuc2NlaXZlKHRyYW5zY2VpdmVyLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY29kZWNzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sb2NhbERlc2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgICAgICAgIHNkcDogZGVzY3JpcHRpb24uc2RwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzd2l0Y2ggKGRlc2NyaXB0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29mZmVyJzpcbiAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2lnbmFsaW5nU3RhdGUoJ2hhdmUtbG9jYWwtb2ZmZXInKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbnN3ZXInOlxuICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTaWduYWxpbmdTdGF0ZSgnc3RhYmxlJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgdHlwZSBcIicgKyBkZXNjcmlwdGlvbi50eXBlICtcbiAgICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGEgc3VjY2VzcyBjYWxsYmFjayB3YXMgcHJvdmlkZWQsIGVtaXQgSUNFIGNhbmRpZGF0ZXMgYWZ0ZXIgaXRcbiAgICAgICAgICAvLyBoYXMgYmVlbiBleGVjdXRlZC4gT3RoZXJ3aXNlLCBlbWl0IGNhbGxiYWNrIGFmdGVyIHRoZSBQcm9taXNlIGlzXG4gICAgICAgICAgLy8gcmVzb2x2ZWQuXG4gICAgICAgICAgdmFyIGhhc0NhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbic7XG4gICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgY2IgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgaWYgKHNlbGYuaWNlR2F0aGVyaW5nU3RhdGUgPT09ICduZXcnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pY2VHYXRoZXJpbmdTdGF0ZSA9ICdnYXRoZXJpbmcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYuX2VtaXRCdWZmZXJlZENhbmRpZGF0ZXMoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIHAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGYuaWNlR2F0aGVyaW5nU3RhdGUgPT09ICduZXcnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pY2VHYXRoZXJpbmdTdGF0ZSA9ICdnYXRoZXJpbmcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFVzdWFsbHkgY2FuZGlkYXRlcyB3aWxsIGJlIGVtaXR0ZWQgZWFybGllci5cbiAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoc2VsZi5fZW1pdEJ1ZmZlcmVkQ2FuZGlkYXRlcy5iaW5kKHNlbGYpLCA1MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9XG4gICAgICAgIGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHZhciBzdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXJMaXN0ID0gW107XG4gICAgICAgICAgdmFyIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhkZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAgIHZhciBzZXNzaW9ucGFydCA9IHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgdmFyIGlzSWNlTGl0ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KHNlc3Npb25wYXJ0LFxuICAgICAgICAgICAgICAnYT1pY2UtbGl0ZScpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgdGhpcy51c2luZ0J1bmRsZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KHNlc3Npb25wYXJ0LFxuICAgICAgICAgICAgICAnYT1ncm91cDpCVU5ETEUgJykubGVuZ3RoID4gMDtcbiAgICAgICAgICBzZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2RwTUxpbmVJbmRleCkge1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIG1saW5lID0gbGluZXNbMF0uc3Vic3RyKDIpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICB2YXIga2luZCA9IG1saW5lWzBdO1xuICAgICAgICAgICAgdmFyIHJlamVjdGVkID0gbWxpbmVbMV0gPT09ICcwJztcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBTRFBVdGlscy5nZXREaXJlY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCk7XG5cbiAgICAgICAgICAgIHZhciBtaWQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1pZDonKTtcbiAgICAgICAgICAgIGlmIChtaWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1pZCA9IG1pZFswXS5zdWJzdHIoNik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtaWQgPSBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVqZWN0IGRhdGFjaGFubmVscyB3aGljaCBhcmUgbm90IGltcGxlbWVudGVkIHlldC5cbiAgICAgICAgICAgIGlmIChraW5kID09PSAnYXBwbGljYXRpb24nICYmIG1saW5lWzJdID09PSAnRFRMUy9TQ1RQJykge1xuICAgICAgICAgICAgICBzZWxmLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICBtaWQ6IG1pZCxcbiAgICAgICAgICAgICAgICBpc0RhdGFjaGFubmVsOiB0cnVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRyYW5zY2VpdmVyO1xuICAgICAgICAgICAgdmFyIGljZUdhdGhlcmVyO1xuICAgICAgICAgICAgdmFyIGljZVRyYW5zcG9ydDtcbiAgICAgICAgICAgIHZhciBkdGxzVHJhbnNwb3J0O1xuICAgICAgICAgICAgdmFyIHJ0cFNlbmRlcjtcbiAgICAgICAgICAgIHZhciBydHBSZWNlaXZlcjtcbiAgICAgICAgICAgIHZhciBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgdmFyIHJlY3ZFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICAgICAgICB2YXIgbG9jYWxDYXBhYmlsaXRpZXM7XG5cbiAgICAgICAgICAgIHZhciB0cmFjaztcbiAgICAgICAgICAgIC8vIEZJWE1FOiBlbnN1cmUgdGhlIG1lZGlhU2VjdGlvbiBoYXMgcnRjcC1tdXggc2V0LlxuICAgICAgICAgICAgdmFyIHJlbW90ZUNhcGFiaWxpdGllcyA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIHJlbW90ZUljZVBhcmFtZXRlcnM7XG4gICAgICAgICAgICB2YXIgcmVtb3RlRHRsc1BhcmFtZXRlcnM7XG4gICAgICAgICAgICBpZiAoIXJlamVjdGVkKSB7XG4gICAgICAgICAgICAgIHJlbW90ZUljZVBhcmFtZXRlcnMgPSBTRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbixcbiAgICAgICAgICAgICAgICAgIHNlc3Npb25wYXJ0KTtcbiAgICAgICAgICAgICAgcmVtb3RlRHRsc1BhcmFtZXRlcnMgPSBTRFBVdGlscy5nZXREdGxzUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24sXG4gICAgICAgICAgICAgICAgICBzZXNzaW9ucGFydCk7XG4gICAgICAgICAgICAgIHJlbW90ZUR0bHNQYXJhbWV0ZXJzLnJvbGUgPSAnY2xpZW50JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY3ZFbmNvZGluZ1BhcmFtZXRlcnMgPVxuICAgICAgICAgICAgICAgIFNEUFV0aWxzLnBhcnNlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG5cbiAgICAgICAgICAgIHZhciBjbmFtZTtcbiAgICAgICAgICAgIC8vIEdldHMgdGhlIGZpcnN0IFNTUkMuIE5vdGUgdGhhdCB3aXRoIFJUWCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZVxuICAgICAgICAgICAgLy8gU1NSQ3MuXG4gICAgICAgICAgICB2YXIgcmVtb3RlU3NyYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvYmouYXR0cmlidXRlID09PSAnY25hbWUnO1xuICAgICAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgaWYgKHJlbW90ZVNzcmMpIHtcbiAgICAgICAgICAgICAgY25hbWUgPSByZW1vdGVTc3JjLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXNDb21wbGV0ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbixcbiAgICAgICAgICAgICAgICAnYT1lbmQtb2YtY2FuZGlkYXRlcycsIHNlc3Npb25wYXJ0KS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgdmFyIGNhbmRzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1jYW5kaWRhdGU6JylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGNhbmQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShjYW5kKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY2FuZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbmQuY29tcG9uZW50ID09PSAnMSc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJyAmJiAhcmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHRyYW5zcG9ydHMgPSBzZWxmLnVzaW5nQnVuZGxlICYmIHNkcE1MaW5lSW5kZXggPiAwID8ge1xuICAgICAgICAgICAgICAgIGljZUdhdGhlcmVyOiBzZWxmLnRyYW5zY2VpdmVyc1swXS5pY2VHYXRoZXJlcixcbiAgICAgICAgICAgICAgICBpY2VUcmFuc3BvcnQ6IHNlbGYudHJhbnNjZWl2ZXJzWzBdLmljZVRyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICBkdGxzVHJhbnNwb3J0OiBzZWxmLnRyYW5zY2VpdmVyc1swXS5kdGxzVHJhbnNwb3J0XG4gICAgICAgICAgICAgIH0gOiBzZWxmLl9jcmVhdGVJY2VBbmREdGxzVHJhbnNwb3J0cyhtaWQsIHNkcE1MaW5lSW5kZXgpO1xuXG4gICAgICAgICAgICAgIGlmIChpc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0cy5pY2VUcmFuc3BvcnQuc2V0UmVtb3RlQ2FuZGlkYXRlcyhjYW5kcyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsb2NhbENhcGFiaWxpdGllcyA9IFJUQ1J0cFJlY2VpdmVyLmdldENhcGFiaWxpdGllcyhraW5kKTtcblxuICAgICAgICAgICAgICAvLyBmaWx0ZXIgUlRYIHVudGlsIGFkZGl0aW9uYWwgc3R1ZmYgbmVlZGVkIGZvciBSVFggaXMgaW1wbGVtZW50ZWRcbiAgICAgICAgICAgICAgLy8gaW4gYWRhcHRlci5qc1xuICAgICAgICAgICAgICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MgPSBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oY29kZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVjLm5hbWUgIT09ICdydHgnO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgc2VuZEVuY29kaW5nUGFyYW1ldGVycyA9IFt7XG4gICAgICAgICAgICAgICAgc3NyYzogKDIgKiBzZHBNTGluZUluZGV4ICsgMikgKiAxMDAxXG4gICAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICAgIHJ0cFJlY2VpdmVyID0gbmV3IFJUQ1J0cFJlY2VpdmVyKHRyYW5zcG9ydHMuZHRsc1RyYW5zcG9ydCwga2luZCk7XG5cbiAgICAgICAgICAgICAgdHJhY2sgPSBydHBSZWNlaXZlci50cmFjaztcbiAgICAgICAgICAgICAgcmVjZWl2ZXJMaXN0LnB1c2goW3RyYWNrLCBydHBSZWNlaXZlcl0pO1xuICAgICAgICAgICAgICAvLyBGSVhNRTogbm90IGNvcnJlY3Qgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgc3RyZWFtcyBidXQgdGhhdCBpc1xuICAgICAgICAgICAgICAvLyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBpbiB0aGlzIHNoaW0uXG4gICAgICAgICAgICAgIHN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cbiAgICAgICAgICAgICAgLy8gRklYTUU6IGxvb2sgYXQgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICBpZiAoc2VsZi5sb2NhbFN0cmVhbXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgc2VsZi5sb2NhbFN0cmVhbXNbMF0uZ2V0VHJhY2tzKCkubGVuZ3RoID49IHNkcE1MaW5lSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxUcmFjaztcbiAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgICAgICAgbG9jYWxUcmFjayA9IHNlbGYubG9jYWxTdHJlYW1zWzBdLmdldEF1ZGlvVHJhY2tzKClbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChraW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgICBsb2NhbFRyYWNrID0gc2VsZi5sb2NhbFN0cmVhbXNbMF0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsVHJhY2spIHtcbiAgICAgICAgICAgICAgICAgIHJ0cFNlbmRlciA9IG5ldyBSVENSdHBTZW5kZXIobG9jYWxUcmFjayxcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnRzLmR0bHNUcmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNlbGYudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdID0ge1xuICAgICAgICAgICAgICAgIGljZUdhdGhlcmVyOiB0cmFuc3BvcnRzLmljZUdhdGhlcmVyLFxuICAgICAgICAgICAgICAgIGljZVRyYW5zcG9ydDogdHJhbnNwb3J0cy5pY2VUcmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgZHRsc1RyYW5zcG9ydDogdHJhbnNwb3J0cy5kdGxzVHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzOiBsb2NhbENhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICAgICByZW1vdGVDYXBhYmlsaXRpZXM6IHJlbW90ZUNhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICAgICBydHBTZW5kZXI6IHJ0cFNlbmRlcixcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlcjogcnRwUmVjZWl2ZXIsXG4gICAgICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgICAgICBtaWQ6IG1pZCxcbiAgICAgICAgICAgICAgICBjbmFtZTogY25hbWUsXG4gICAgICAgICAgICAgICAgc2VuZEVuY29kaW5nUGFyYW1ldGVyczogc2VuZEVuY29kaW5nUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICByZWN2RW5jb2RpbmdQYXJhbWV0ZXJzOiByZWN2RW5jb2RpbmdQYXJhbWV0ZXJzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBSVENSdHBSZWNlaXZlciBub3cuIFRoZSBSVFBTZW5kZXIgaXMgc3RhcnRlZCBpblxuICAgICAgICAgICAgICAvLyBzZXRMb2NhbERlc2NyaXB0aW9uLlxuICAgICAgICAgICAgICBzZWxmLl90cmFuc2NlaXZlKHNlbGYudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09ICdzZW5kcmVjdicgfHwgZGlyZWN0aW9uID09PSAnc2VuZG9ubHknKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ2Fuc3dlcicgJiYgIXJlamVjdGVkKSB7XG4gICAgICAgICAgICAgIHRyYW5zY2VpdmVyID0gc2VsZi50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF07XG4gICAgICAgICAgICAgIGljZUdhdGhlcmVyID0gdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXI7XG4gICAgICAgICAgICAgIGljZVRyYW5zcG9ydCA9IHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydDtcbiAgICAgICAgICAgICAgZHRsc1RyYW5zcG9ydCA9IHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQ7XG4gICAgICAgICAgICAgIHJ0cFNlbmRlciA9IHRyYW5zY2VpdmVyLnJ0cFNlbmRlcjtcbiAgICAgICAgICAgICAgcnRwUmVjZWl2ZXIgPSB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcjtcbiAgICAgICAgICAgICAgc2VuZEVuY29kaW5nUGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICAgICAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzID0gdHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXM7XG5cbiAgICAgICAgICAgICAgc2VsZi50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0ucmVjdkVuY29kaW5nUGFyYW1ldGVycyA9XG4gICAgICAgICAgICAgICAgICByZWN2RW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICBzZWxmLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5yZW1vdGVDYXBhYmlsaXRpZXMgPVxuICAgICAgICAgICAgICAgICAgcmVtb3RlQ2FwYWJpbGl0aWVzO1xuICAgICAgICAgICAgICBzZWxmLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5jbmFtZSA9IGNuYW1lO1xuXG4gICAgICAgICAgICAgIGlmICgoaXNJY2VMaXRlIHx8IGlzQ29tcGxldGUpICYmIGNhbmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGljZVRyYW5zcG9ydC5zZXRSZW1vdGVDYW5kaWRhdGVzKGNhbmRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXNlbGYudXNpbmdCdW5kbGUgfHwgc2RwTUxpbmVJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGljZVRyYW5zcG9ydC5zdGFydChpY2VHYXRoZXJlciwgcmVtb3RlSWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgJ2NvbnRyb2xsaW5nJyk7XG4gICAgICAgICAgICAgICAgZHRsc1RyYW5zcG9ydC5zdGFydChyZW1vdGVEdGxzUGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZWxmLl90cmFuc2NlaXZlKHRyYW5zY2VpdmVyLFxuICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnIHx8IGRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5JyxcbiAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2JyB8fCBkaXJlY3Rpb24gPT09ICdzZW5kb25seScpO1xuXG4gICAgICAgICAgICAgIGlmIChydHBSZWNlaXZlciAmJlxuICAgICAgICAgICAgICAgICAgKGRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2JyB8fCBkaXJlY3Rpb24gPT09ICdzZW5kb25seScpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2sgPSBydHBSZWNlaXZlci50cmFjaztcbiAgICAgICAgICAgICAgICByZWNlaXZlckxpc3QucHVzaChbdHJhY2ssIHJ0cFJlY2VpdmVyXSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogYWN0dWFsbHkgdGhlIHJlY2VpdmVyIHNob3VsZCBiZSBjcmVhdGVkIGxhdGVyLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5yZW1vdGVEZXNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICAgICAgICBzZHA6IGRlc2NyaXB0aW9uLnNkcFxuICAgICAgICAgIH07XG4gICAgICAgICAgc3dpdGNoIChkZXNjcmlwdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdvZmZlcic6XG4gICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlKCdoYXZlLXJlbW90ZS1vZmZlcicpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Fuc3dlcic6XG4gICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlKCdzdGFibGUnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnN1cHBvcnRlZCB0eXBlIFwiJyArIGRlc2NyaXB0aW9uLnR5cGUgK1xuICAgICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLnJlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XG4gICAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgaWYgKHNlbGYub25hZGRzdHJlYW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYub25hZGRzdHJlYW0oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVjZWl2ZXJMaXN0LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IGl0ZW1bMF07XG4gICAgICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gaXRlbVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tFdmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgICAgICB0cmFja0V2ZW50LnRyYWNrID0gdHJhY2s7XG4gICAgICAgICAgICAgICAgdHJhY2tFdmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgICAgIHRyYWNrRXZlbnQuc3RyZWFtcyA9IFtzdHJlYW1dO1xuICAgICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYub250cmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub250cmFjayh0cmFja0V2ZW50KTtcbiAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGFyZ3VtZW50c1sxXSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgLyogbm90IHlldFxuICAgICAgICBpZiAodHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIpIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQpIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5kdGxzVHJhbnNwb3J0KSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlcikge1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnJ0cFNlbmRlci5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEZJWE1FOiBjbGVhbiB1cCB0cmFja3MsIGxvY2FsIHN0cmVhbXMsIHJlbW90ZSBzdHJlYW1zLCBldGNcbiAgICAgIHRoaXMuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlKCdjbG9zZWQnKTtcbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIHRoZSBzaWduYWxpbmcgc3RhdGUuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fdXBkYXRlU2lnbmFsaW5nU3RhdGUgPVxuICAgICAgICBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ3NpZ25hbGluZ3N0YXRlY2hhbmdlJyk7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBpZiAodGhpcy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8vIERldGVybWluZSB3aGV0aGVyIHRvIGZpcmUgdGhlIG5lZ290aWF0aW9ubmVlZGVkIGV2ZW50LlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX21heWJlRmlyZU5lZ290aWF0aW9uTmVlZGVkID1cbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gRmlyZSBhd2F5IChmb3Igbm93KS5cbiAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJyk7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBpZiAodGhpcy5vbm5lZ290aWF0aW9ubmVlZGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9ubmVnb3RpYXRpb25uZWVkZWQoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgY29ubmVjdGlvbiBzdGF0ZS5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl91cGRhdGVDb25uZWN0aW9uU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBuZXdTdGF0ZTtcbiAgICAgIHZhciBzdGF0ZXMgPSB7XG4gICAgICAgICduZXcnOiAwLFxuICAgICAgICBjbG9zZWQ6IDAsXG4gICAgICAgIGNvbm5lY3Rpbmc6IDAsXG4gICAgICAgIGNoZWNraW5nOiAwLFxuICAgICAgICBjb25uZWN0ZWQ6IDAsXG4gICAgICAgIGNvbXBsZXRlZDogMCxcbiAgICAgICAgZmFpbGVkOiAwXG4gICAgICB9O1xuICAgICAgdGhpcy50cmFuc2NlaXZlcnMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICBzdGF0ZXNbdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LnN0YXRlXSsrO1xuICAgICAgICBzdGF0ZXNbdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydC5zdGF0ZV0rKztcbiAgICAgIH0pO1xuICAgICAgLy8gSUNFVHJhbnNwb3J0LmNvbXBsZXRlZCBhbmQgY29ubmVjdGVkIGFyZSB0aGUgc2FtZSBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgc3RhdGVzLmNvbm5lY3RlZCArPSBzdGF0ZXMuY29tcGxldGVkO1xuXG4gICAgICBuZXdTdGF0ZSA9ICduZXcnO1xuICAgICAgaWYgKHN0YXRlcy5mYWlsZWQgPiAwKSB7XG4gICAgICAgIG5ld1N0YXRlID0gJ2ZhaWxlZCc7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlcy5jb25uZWN0aW5nID4gMCB8fCBzdGF0ZXMuY2hlY2tpbmcgPiAwKSB7XG4gICAgICAgIG5ld1N0YXRlID0gJ2Nvbm5lY3RpbmcnO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZXMuZGlzY29ubmVjdGVkID4gMCkge1xuICAgICAgICBuZXdTdGF0ZSA9ICdkaXNjb25uZWN0ZWQnO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZXMubmV3ID4gMCkge1xuICAgICAgICBuZXdTdGF0ZSA9ICduZXcnO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZXMuY29ubmVjdGVkID4gMCB8fCBzdGF0ZXMuY29tcGxldGVkID4gMCkge1xuICAgICAgICBuZXdTdGF0ZSA9ICdjb25uZWN0ZWQnO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3U3RhdGUgIT09IHNlbGYuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgIHNlbGYuaWNlQ29ubmVjdGlvblN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIGlmICh0aGlzLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZShldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdPZmZlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZU9mZmVyIGNhbGxlZCB3aGlsZSB0aGVyZSBpcyBhIHBlbmRpbmcgb2ZmZXIuJyk7XG4gICAgICB9XG4gICAgICB2YXIgb2ZmZXJPcHRpb25zO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvZmZlck9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgb2ZmZXJPcHRpb25zID0gYXJndW1lbnRzWzJdO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJhY2tzID0gW107XG4gICAgICB2YXIgbnVtQXVkaW9UcmFja3MgPSAwO1xuICAgICAgdmFyIG51bVZpZGVvVHJhY2tzID0gMDtcbiAgICAgIC8vIERlZmF1bHQgdG8gc2VuZHJlY3YuXG4gICAgICBpZiAodGhpcy5sb2NhbFN0cmVhbXMubGVuZ3RoKSB7XG4gICAgICAgIG51bUF1ZGlvVHJhY2tzID0gdGhpcy5sb2NhbFN0cmVhbXNbMF0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGg7XG4gICAgICAgIG51bVZpZGVvVHJhY2tzID0gdGhpcy5sb2NhbFN0cmVhbXNbMF0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICAvLyBEZXRlcm1pbmUgbnVtYmVyIG9mIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3Mgd2UgbmVlZCB0byBzZW5kL3JlY3YuXG4gICAgICBpZiAob2ZmZXJPcHRpb25zKSB7XG4gICAgICAgIC8vIFJlamVjdCBDaHJvbWUgbGVnYWN5IGNvbnN0cmFpbnRzLlxuICAgICAgICBpZiAob2ZmZXJPcHRpb25zLm1hbmRhdG9yeSB8fCBvZmZlck9wdGlvbnMub3B0aW9uYWwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAnTGVnYWN5IG1hbmRhdG9yeS9vcHRpb25hbCBjb25zdHJhaW50cyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtQXVkaW9UcmFja3MgPSBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbztcbiAgICAgICAgfVxuICAgICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bVZpZGVvVHJhY2tzID0gb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxvY2FsU3RyZWFtcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gUHVzaCBsb2NhbCBzdHJlYW1zLlxuICAgICAgICB0aGlzLmxvY2FsU3RyZWFtc1swXS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICAgICAgdHJhY2tzLnB1c2goe1xuICAgICAgICAgICAga2luZDogdHJhY2sua2luZCxcbiAgICAgICAgICAgIHRyYWNrOiB0cmFjayxcbiAgICAgICAgICAgIHdhbnRSZWNlaXZlOiB0cmFjay5raW5kID09PSAnYXVkaW8nID9cbiAgICAgICAgICAgICAgICBudW1BdWRpb1RyYWNrcyA+IDAgOiBudW1WaWRlb1RyYWNrcyA+IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgbnVtQXVkaW9UcmFja3MtLTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgIG51bVZpZGVvVHJhY2tzLS07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIENyZWF0ZSBNLWxpbmVzIGZvciByZWN2b25seSBzdHJlYW1zLlxuICAgICAgd2hpbGUgKG51bUF1ZGlvVHJhY2tzID4gMCB8fCBudW1WaWRlb1RyYWNrcyA+IDApIHtcbiAgICAgICAgaWYgKG51bUF1ZGlvVHJhY2tzID4gMCkge1xuICAgICAgICAgIHRyYWNrcy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6ICdhdWRpbycsXG4gICAgICAgICAgICB3YW50UmVjZWl2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG51bUF1ZGlvVHJhY2tzLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bVZpZGVvVHJhY2tzID4gMCkge1xuICAgICAgICAgIHRyYWNrcy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6ICd2aWRlbycsXG4gICAgICAgICAgICB3YW50UmVjZWl2ZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG51bVZpZGVvVHJhY2tzLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNkcCA9IFNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlKCk7XG4gICAgICB2YXIgdHJhbnNjZWl2ZXJzID0gW107XG4gICAgICB0cmFja3MuZm9yRWFjaChmdW5jdGlvbihtbGluZSwgc2RwTUxpbmVJbmRleCkge1xuICAgICAgICAvLyBGb3IgZWFjaCB0cmFjaywgY3JlYXRlIGFuIGljZSBnYXRoZXJlciwgaWNlIHRyYW5zcG9ydCxcbiAgICAgICAgLy8gZHRscyB0cmFuc3BvcnQsIHBvdGVudGlhbGx5IHJ0cHNlbmRlciBhbmQgcnRwcmVjZWl2ZXIuXG4gICAgICAgIHZhciB0cmFjayA9IG1saW5lLnRyYWNrO1xuICAgICAgICB2YXIga2luZCA9IG1saW5lLmtpbmQ7XG4gICAgICAgIHZhciBtaWQgPSBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIoKTtcblxuICAgICAgICB2YXIgdHJhbnNwb3J0cyA9IHNlbGYudXNpbmdCdW5kbGUgJiYgc2RwTUxpbmVJbmRleCA+IDAgPyB7XG4gICAgICAgICAgaWNlR2F0aGVyZXI6IHRyYW5zY2VpdmVyc1swXS5pY2VHYXRoZXJlcixcbiAgICAgICAgICBpY2VUcmFuc3BvcnQ6IHRyYW5zY2VpdmVyc1swXS5pY2VUcmFuc3BvcnQsXG4gICAgICAgICAgZHRsc1RyYW5zcG9ydDogdHJhbnNjZWl2ZXJzWzBdLmR0bHNUcmFuc3BvcnRcbiAgICAgICAgfSA6IHNlbGYuX2NyZWF0ZUljZUFuZER0bHNUcmFuc3BvcnRzKG1pZCwgc2RwTUxpbmVJbmRleCk7XG5cbiAgICAgICAgdmFyIGxvY2FsQ2FwYWJpbGl0aWVzID0gUlRDUnRwU2VuZGVyLmdldENhcGFiaWxpdGllcyhraW5kKTtcbiAgICAgICAgLy8gZmlsdGVyIFJUWCB1bnRpbCBhZGRpdGlvbmFsIHN0dWZmIG5lZWRlZCBmb3IgUlRYIGlzIGltcGxlbWVudGVkXG4gICAgICAgIC8vIGluIGFkYXB0ZXIuanNcbiAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXMuY29kZWNzID0gbG9jYWxDYXBhYmlsaXRpZXMuY29kZWNzLmZpbHRlcihcbiAgICAgICAgICAgIGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb2RlYy5uYW1lICE9PSAncnR4JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjb2RlYykge1xuICAgICAgICAgIC8vIHdvcmsgYXJvdW5kIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD02NTUyXG4gICAgICAgICAgLy8gYnkgYWRkaW5nIGxldmVsLWFzeW1tZXRyeS1hbGxvd2VkPTFcbiAgICAgICAgICBpZiAoY29kZWMubmFtZSA9PT0gJ0gyNjQnICYmXG4gICAgICAgICAgICAgIGNvZGVjLnBhcmFtZXRlcnNbJ2xldmVsLWFzeW1tZXRyeS1hbGxvd2VkJ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29kZWMucGFyYW1ldGVyc1snbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQnXSA9ICcxJztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBydHBTZW5kZXI7XG4gICAgICAgIHZhciBydHBSZWNlaXZlcjtcblxuICAgICAgICAvLyBnZW5lcmF0ZSBhbiBzc3JjIG5vdywgdG8gYmUgdXNlZCBsYXRlciBpbiBydHBTZW5kZXIuc2VuZFxuICAgICAgICB2YXIgc2VuZEVuY29kaW5nUGFyYW1ldGVycyA9IFt7XG4gICAgICAgICAgc3NyYzogKDIgKiBzZHBNTGluZUluZGV4ICsgMSkgKiAxMDAxXG4gICAgICAgIH1dO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICBydHBTZW5kZXIgPSBuZXcgUlRDUnRwU2VuZGVyKHRyYWNrLCB0cmFuc3BvcnRzLmR0bHNUcmFuc3BvcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1saW5lLndhbnRSZWNlaXZlKSB7XG4gICAgICAgICAgcnRwUmVjZWl2ZXIgPSBuZXcgUlRDUnRwUmVjZWl2ZXIodHJhbnNwb3J0cy5kdGxzVHJhbnNwb3J0LCBraW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XSA9IHtcbiAgICAgICAgICBpY2VHYXRoZXJlcjogdHJhbnNwb3J0cy5pY2VHYXRoZXJlcixcbiAgICAgICAgICBpY2VUcmFuc3BvcnQ6IHRyYW5zcG9ydHMuaWNlVHJhbnNwb3J0LFxuICAgICAgICAgIGR0bHNUcmFuc3BvcnQ6IHRyYW5zcG9ydHMuZHRsc1RyYW5zcG9ydCxcbiAgICAgICAgICBsb2NhbENhcGFiaWxpdGllczogbG9jYWxDYXBhYmlsaXRpZXMsXG4gICAgICAgICAgcmVtb3RlQ2FwYWJpbGl0aWVzOiBudWxsLFxuICAgICAgICAgIHJ0cFNlbmRlcjogcnRwU2VuZGVyLFxuICAgICAgICAgIHJ0cFJlY2VpdmVyOiBydHBSZWNlaXZlcixcbiAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgIG1pZDogbWlkLFxuICAgICAgICAgIHNlbmRFbmNvZGluZ1BhcmFtZXRlcnM6IHNlbmRFbmNvZGluZ1BhcmFtZXRlcnMsXG4gICAgICAgICAgcmVjdkVuY29kaW5nUGFyYW1ldGVyczogbnVsbFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy51c2luZ0J1bmRsZSkge1xuICAgICAgICBzZHAgKz0gJ2E9Z3JvdXA6QlVORExFICcgKyB0cmFuc2NlaXZlcnMubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5taWQ7XG4gICAgICAgIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuICAgICAgfVxuICAgICAgdHJhY2tzLmZvckVhY2goZnVuY3Rpb24obWxpbmUsIHNkcE1MaW5lSW5kZXgpIHtcbiAgICAgICAgdmFyIHRyYW5zY2VpdmVyID0gdHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdO1xuICAgICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIsXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5sb2NhbENhcGFiaWxpdGllcywgJ29mZmVyJywgc2VsZi5sb2NhbFN0cmVhbXNbMF0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3BlbmRpbmdPZmZlciA9IHRyYW5zY2VpdmVycztcbiAgICAgIHZhciBkZXNjID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgIHR5cGU6ICdvZmZlcicsXG4gICAgICAgIHNkcDogc2RwXG4gICAgICB9KTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoYXJndW1lbnRzWzBdLCAwLCBkZXNjKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzYyk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHZhciBzZHAgPSBTRFBVdGlscy53cml0ZVNlc3Npb25Cb2lsZXJwbGF0ZSgpO1xuICAgICAgaWYgKHRoaXMudXNpbmdCdW5kbGUpIHtcbiAgICAgICAgc2RwICs9ICdhPWdyb3VwOkJVTkRMRSAnICsgdGhpcy50cmFuc2NlaXZlcnMubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5taWQ7XG4gICAgICAgIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2NlaXZlcnMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICBpZiAodHJhbnNjZWl2ZXIuaXNEYXRhY2hhbm5lbCkge1xuICAgICAgICAgIHNkcCArPSAnbT1hcHBsaWNhdGlvbiAwIERUTFMvU0NUUCA1MDAwXFxyXFxuJyArXG4gICAgICAgICAgICAgICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJyArXG4gICAgICAgICAgICAgICdhPW1pZDonICsgdHJhbnNjZWl2ZXIubWlkICsgJ1xcclxcbic7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gb2YgY2FwYWJpbGl0aWVzLlxuICAgICAgICB2YXIgY29tbW9uQ2FwYWJpbGl0aWVzID0gc2VsZi5fZ2V0Q29tbW9uQ2FwYWJpbGl0aWVzKFxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5yZW1vdGVDYXBhYmlsaXRpZXMpO1xuXG4gICAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlciwgY29tbW9uQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgJ2Fuc3dlcicsIHNlbGYubG9jYWxTdHJlYW1zWzBdKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZGVzYyA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICB0eXBlOiAnYW5zd2VyJyxcbiAgICAgICAgc2RwOiBzZHBcbiAgICAgIH0pO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChhcmd1bWVudHNbMF0sIDAsIGRlc2MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZXNjKTtcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbihjYW5kaWRhdGUpIHtcbiAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgIHRoaXMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQuYWRkUmVtb3RlQ2FuZGlkYXRlKHt9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbUxpbmVJbmRleCA9IGNhbmRpZGF0ZS5zZHBNTGluZUluZGV4O1xuICAgICAgICBpZiAoY2FuZGlkYXRlLnNkcE1pZCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50cmFuc2NlaXZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zY2VpdmVyc1tpXS5taWQgPT09IGNhbmRpZGF0ZS5zZHBNaWQpIHtcbiAgICAgICAgICAgICAgbUxpbmVJbmRleCA9IGk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhbnNjZWl2ZXIgPSB0aGlzLnRyYW5zY2VpdmVyc1ttTGluZUluZGV4XTtcbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgdmFyIGNhbmQgPSBPYmplY3Qua2V5cyhjYW5kaWRhdGUuY2FuZGlkYXRlKS5sZW5ndGggPiAwID9cbiAgICAgICAgICAgICAgU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoY2FuZGlkYXRlLmNhbmRpZGF0ZSkgOiB7fTtcbiAgICAgICAgICAvLyBJZ25vcmUgQ2hyb21lJ3MgaW52YWxpZCBjYW5kaWRhdGVzIHNpbmNlIEVkZ2UgZG9lcyBub3QgbGlrZSB0aGVtLlxuICAgICAgICAgIGlmIChjYW5kLnByb3RvY29sID09PSAndGNwJyAmJiAoY2FuZC5wb3J0ID09PSAwIHx8IGNhbmQucG9ydCA9PT0gOSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWdub3JlIFJUQ1AgY2FuZGlkYXRlcywgd2UgYXNzdW1lIFJUQ1AtTVVYLlxuICAgICAgICAgIGlmIChjYW5kLmNvbXBvbmVudCAhPT0gJzEnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEEgZGlydHkgaGFjayB0byBtYWtlIHNhbXBsZXMgd29yay5cbiAgICAgICAgICBpZiAoY2FuZC50eXBlID09PSAnZW5kT2ZDYW5kaWRhdGVzJykge1xuICAgICAgICAgICAgY2FuZCA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQuYWRkUmVtb3RlQ2FuZGlkYXRlKGNhbmQpO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSByZW1vdGVEZXNjcmlwdGlvbi5cbiAgICAgICAgICB2YXIgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKHRoaXMucmVtb3RlRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgICBzZWN0aW9uc1ttTGluZUluZGV4ICsgMV0gKz0gKGNhbmQudHlwZSA/IGNhbmRpZGF0ZS5jYW5kaWRhdGUudHJpbSgpXG4gICAgICAgICAgICAgIDogJ2E9ZW5kLW9mLWNhbmRpZGF0ZXMnKSArICdcXHJcXG4nO1xuICAgICAgICAgIHRoaXMucmVtb3RlRGVzY3JpcHRpb24uc2RwID0gc2VjdGlvbnMuam9pbignJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGFyZ3VtZW50c1sxXSwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgdGhpcy50cmFuc2NlaXZlcnMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICBbJ3J0cFNlbmRlcicsICdydHBSZWNlaXZlcicsICdpY2VHYXRoZXJlcicsICdpY2VUcmFuc3BvcnQnLFxuICAgICAgICAgICAgJ2R0bHNUcmFuc3BvcnQnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgICBpZiAodHJhbnNjZWl2ZXJbbWV0aG9kXSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godHJhbnNjZWl2ZXJbbWV0aG9kXS5nZXRTdGF0cygpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBjYiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICBhcmd1bWVudHNbMV07XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAvLyBzaGltIGdldFN0YXRzIHdpdGggbWFwbGlrZSBzdXBwb3J0XG4gICAgICAgIHZhciByZXN1bHRzID0gbmV3IE1hcCgpO1xuICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICByZXMuZm9yRWFjaChmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICByZXN1bHRzLnNldChpZCwgcmVzdWx0W2lkXSk7XG4gICAgICAgICAgICAgIHJlc3VsdHNbaWRdID0gcmVzdWx0W2lkXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2IsIDAsIHJlc3VsdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn07XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaGltUGVlckNvbm5lY3Rpb246IGVkZ2VTaGltLnNoaW1QZWVyQ29ubmVjdGlvbixcbiAgc2hpbUdldFVzZXJNZWRpYTogcmVxdWlyZSgnLi9nZXR1c2VybWVkaWEnKVxufTtcbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuIC8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2hpbUVycm9yXyA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToge1Blcm1pc3Npb25EZW5pZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcid9W2UubmFtZV0gfHwgZS5uYW1lLFxuICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgY29uc3RyYWludDogZS5jb25zdHJhaW50LFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gZ2V0VXNlck1lZGlhIGVycm9yIHNoaW0uXG4gIHZhciBvcmlnR2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuXG4gICAgICBiaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gb3JpZ0dldFVzZXJNZWRpYShjKS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoc2hpbUVycm9yXyhlKSk7XG4gICAgfSk7XG4gIH07XG59O1xuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4gLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyRGV0YWlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuYnJvd3NlckRldGFpbHM7XG5cbnZhciBmaXJlZm94U2hpbSA9IHtcbiAgc2hpbU9uVHJhY2s6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnb250cmFjaycgaW5cbiAgICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb250cmFjaycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb250cmFjaztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX29udHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb250cmFja3BvbHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayA9IGYpO1xuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb250cmFja3BvbHkgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSB7dHJhY2s6IHRyYWNrfTtcbiAgICAgICAgICAgICAgZXZlbnQuc3RyZWFtcyA9IFtlLnN0cmVhbV07XG4gICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBzaGltU291cmNlT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAvLyBGaXJlZm94IGhhcyBzdXBwb3J0ZWQgbW96U3JjT2JqZWN0IHNpbmNlIEZGMjIsIHVucHJlZml4ZWQgaW4gNDIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAod2luZG93LkhUTUxNZWRpYUVsZW1lbnQgJiZcbiAgICAgICAgISgnc3JjT2JqZWN0JyBpbiB3aW5kb3cuSFRNTE1lZGlhRWxlbWVudC5wcm90b3R5cGUpKSB7XG4gICAgICAgIC8vIFNoaW0gdGhlIHNyY09iamVjdCBwcm9wZXJ0eSwgb25jZSwgd2hlbiBIVE1MTWVkaWFFbGVtZW50IGlzIGZvdW5kLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LkhUTUxNZWRpYUVsZW1lbnQucHJvdG90eXBlLCAnc3JjT2JqZWN0Jywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3pTcmNPYmplY3Q7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5tb3pTcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc2hpbVBlZXJDb25uZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgICAgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgICAgcmV0dXJuOyAvLyBwcm9iYWJseSBtZWRpYS5wZWVyY29ubmVjdGlvbi5lbmFibGVkPWZhbHNlIGluIGFib3V0OmNvbmZpZ1xuICAgIH1cbiAgICAvLyBUaGUgUlRDUGVlckNvbm5lY3Rpb24gb2JqZWN0LlxuICAgIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSBmdW5jdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cykge1xuICAgICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDM4KSB7XG4gICAgICAgICAgLy8gLnVybHMgaXMgbm90IHN1cHBvcnRlZCBpbiBGRiA8IDM4LlxuICAgICAgICAgIC8vIGNyZWF0ZSBSVENJY2VTZXJ2ZXJzIHdpdGggYSBzaW5nbGUgdXJsLlxuICAgICAgICAgIGlmIChwY0NvbmZpZyAmJiBwY0NvbmZpZy5pY2VTZXJ2ZXJzKSB7XG4gICAgICAgICAgICB2YXIgbmV3SWNlU2VydmVycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwY0NvbmZpZy5pY2VTZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBzZXJ2ZXIgPSBwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldO1xuICAgICAgICAgICAgICBpZiAoc2VydmVyLmhhc093blByb3BlcnR5KCd1cmxzJykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcnZlci51cmxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmV3U2VydmVyID0ge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHNlcnZlci51cmxzW2pdXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgaWYgKHNlcnZlci51cmxzW2pdLmluZGV4T2YoJ3R1cm4nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTZXJ2ZXIudXNlcm5hbWUgPSBzZXJ2ZXIudXNlcm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlcnZlci5jcmVkZW50aWFsID0gc2VydmVyLmNyZWRlbnRpYWw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2gobmV3U2VydmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3SWNlU2VydmVycy5wdXNoKHBjQ29uZmlnLmljZVNlcnZlcnNbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwY0NvbmZpZy5pY2VTZXJ2ZXJzID0gbmV3SWNlU2VydmVycztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBtb3pSVENQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cyk7XG4gICAgICB9O1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSA9IG1velJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcblxuICAgICAgLy8gd3JhcCBzdGF0aWMgbWV0aG9kcy4gQ3VycmVudGx5IGp1c3QgZ2VuZXJhdGVDZXJ0aWZpY2F0ZS5cbiAgICAgIGlmIChtb3pSVENQZWVyQ29ubmVjdGlvbi5nZW5lcmF0ZUNlcnRpZmljYXRlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24sICdnZW5lcmF0ZUNlcnRpZmljYXRlJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbW96UlRDUGVlckNvbm5lY3Rpb24uZ2VuZXJhdGVDZXJ0aWZpY2F0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID0gbW96UlRDU2Vzc2lvbkRlc2NyaXB0aW9uO1xuICAgICAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA9IG1velJUQ0ljZUNhbmRpZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBzaGltIGF3YXkgbmVlZCBmb3Igb2Jzb2xldGUgUlRDSWNlQ2FuZGlkYXRlL1JUQ1Nlc3Npb25EZXNjcmlwdGlvbi5cbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ11cbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgdmFyIG5hdGl2ZU1ldGhvZCA9IFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICAgIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgKChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnKSA/XG4gICAgICAgICAgICAgICAgUlRDSWNlQ2FuZGlkYXRlIDogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgLy8gc3VwcG9ydCBmb3IgYWRkSWNlQ2FuZGlkYXRlKG51bGwgb3IgdW5kZWZpbmVkKVxuICAgIHZhciBuYXRpdmVBZGRJY2VDYW5kaWRhdGUgPVxuICAgICAgICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuICAgIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgICBhcmd1bWVudHNbMV0uYXBwbHkobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDQ4KSB7XG4gICAgICAvLyBzaGltIGdldFN0YXRzIHdpdGggbWFwbGlrZSBzdXBwb3J0XG4gICAgICB2YXIgbWFrZU1hcFN0YXRzID0gZnVuY3Rpb24oc3RhdHMpIHtcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgT2JqZWN0LmtleXMoc3RhdHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgbWFwLnNldChrZXksIHN0YXRzW2tleV0pO1xuICAgICAgICAgIG1hcFtrZXldID0gc3RhdHNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbmF0aXZlR2V0U3RhdHMgPSBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHM7XG4gICAgICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbihzZWxlY3Rvciwgb25TdWNjLCBvbkVycikge1xuICAgICAgICByZXR1cm4gbmF0aXZlR2V0U3RhdHMuYXBwbHkodGhpcywgW3NlbGVjdG9yIHx8IG51bGxdKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHN0YXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZU1hcFN0YXRzKHN0YXRzKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKG9uU3VjYywgb25FcnIpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaGltT25UcmFjazogZmlyZWZveFNoaW0uc2hpbU9uVHJhY2ssXG4gIHNoaW1Tb3VyY2VPYmplY3Q6IGZpcmVmb3hTaGltLnNoaW1Tb3VyY2VPYmplY3QsXG4gIHNoaW1QZWVyQ29ubmVjdGlvbjogZmlyZWZveFNoaW0uc2hpbVBlZXJDb25uZWN0aW9uLFxuICBzaGltR2V0VXNlck1lZGlhOiByZXF1aXJlKCcuL2dldHVzZXJtZWRpYScpXG59O1xuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4gLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsb2dnaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5sb2c7XG52YXIgYnJvd3NlckRldGFpbHMgPSByZXF1aXJlKCcuLi91dGlscycpLmJyb3dzZXJEZXRhaWxzO1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2hpbUVycm9yXyA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToge1xuICAgICAgICBTZWN1cml0eUVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgUGVybWlzc2lvbkRlbmllZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJ1xuICAgICAgfVtlLm5hbWVdIHx8IGUubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgJ1RoZSBvcGVyYXRpb24gaXMgaW5zZWN1cmUuJzogJ1RoZSByZXF1ZXN0IGlzIG5vdCBhbGxvd2VkIGJ5IHRoZSAnICtcbiAgICAgICAgJ3VzZXIgYWdlbnQgb3IgdGhlIHBsYXRmb3JtIGluIHRoZSBjdXJyZW50IGNvbnRleHQuJ1xuICAgICAgfVtlLm1lc3NhZ2VdIHx8IGUubWVzc2FnZSxcbiAgICAgIGNvbnN0cmFpbnQ6IGUuY29uc3RyYWludCxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICh0aGlzLm1lc3NhZ2UgJiYgJzogJykgKyB0aGlzLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBnZXRVc2VyTWVkaWEgY29uc3RyYWludHMgc2hpbS5cbiAgdmFyIGdldFVzZXJNZWRpYV8gPSBmdW5jdGlvbihjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgdmFyIGNvbnN0cmFpbnRzVG9GRjM3XyA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIGlmICh0eXBlb2YgYyAhPT0gJ29iamVjdCcgfHwgYy5yZXF1aXJlKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgICAgdmFyIHJlcXVpcmUgPSBbXTtcbiAgICAgIE9iamVjdC5rZXlzKGMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdyZXF1aXJlJyB8fCBrZXkgPT09ICdhZHZhbmNlZCcgfHwga2V5ID09PSAnbWVkaWFTb3VyY2UnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByID0gY1trZXldID0gKHR5cGVvZiBjW2tleV0gPT09ICdvYmplY3QnKSA/XG4gICAgICAgICAgICBjW2tleV0gOiB7aWRlYWw6IGNba2V5XX07XG4gICAgICAgIGlmIChyLm1pbiAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICByLm1heCAhPT0gdW5kZWZpbmVkIHx8IHIuZXhhY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlcXVpcmUucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHIuZXhhY3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByLiBtaW4gPSByLm1heCA9IHIuZXhhY3Q7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNba2V5XSA9IHIuZXhhY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSByLmV4YWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyLmlkZWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjLmFkdmFuY2VkID0gYy5hZHZhbmNlZCB8fCBbXTtcbiAgICAgICAgICB2YXIgb2MgPSB7fTtcbiAgICAgICAgICBpZiAodHlwZW9mIHIuaWRlYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvY1trZXldID0ge21pbjogci5pZGVhbCwgbWF4OiByLmlkZWFsfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Nba2V5XSA9IHIuaWRlYWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGMuYWR2YW5jZWQucHVzaChvYyk7XG4gICAgICAgICAgZGVsZXRlIHIuaWRlYWw7XG4gICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhyKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZXF1aXJlLmxlbmd0aCkge1xuICAgICAgICBjLnJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDM4KSB7XG4gICAgICBsb2dnaW5nKCdzcGVjOiAnICsgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICAgIGlmIChjb25zdHJhaW50cy5hdWRpbykge1xuICAgICAgICBjb25zdHJhaW50cy5hdWRpbyA9IGNvbnN0cmFpbnRzVG9GRjM3Xyhjb25zdHJhaW50cy5hdWRpbyk7XG4gICAgICB9XG4gICAgICBpZiAoY29uc3RyYWludHMudmlkZW8pIHtcbiAgICAgICAgY29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50c1RvRkYzN18oY29uc3RyYWludHMudmlkZW8pO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnZmYzNzogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgfVxuICAgIHJldHVybiBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIG9uRXJyb3Ioc2hpbUVycm9yXyhlKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGdldFVzZXJNZWRpYSBhcyBhIFByb21pc2UuXG4gIHZhciBnZXRVc2VyTWVkaWFQcm9taXNlXyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZ2V0VXNlck1lZGlhXyhjb25zdHJhaW50cywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBTaGltIGZvciBtZWRpYURldmljZXMgb24gb2xkZXIgdmVyc2lvbnMuXG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMgPSB7Z2V0VXNlck1lZGlhOiBnZXRVc2VyTWVkaWFQcm9taXNlXyxcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7IH1cbiAgICB9O1xuICB9XG4gIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcyA9XG4gICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgdmFyIGluZm9zID0gW1xuICAgICAgICAgICAge2tpbmQ6ICdhdWRpb2lucHV0JywgZGV2aWNlSWQ6ICdkZWZhdWx0JywgbGFiZWw6ICcnLCBncm91cElkOiAnJ30sXG4gICAgICAgICAgICB7a2luZDogJ3ZpZGVvaW5wdXQnLCBkZXZpY2VJZDogJ2RlZmF1bHQnLCBsYWJlbDogJycsIGdyb3VwSWQ6ICcnfVxuICAgICAgICAgIF07XG4gICAgICAgICAgcmVzb2x2ZShpbmZvcyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDQxKSB7XG4gICAgLy8gV29yayBhcm91bmQgaHR0cDovL2J1Z3ppbC5sYS8xMTY5NjY1XG4gICAgdmFyIG9yZ0VudW1lcmF0ZURldmljZXMgPVxuICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMuYmluZChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBvcmdFbnVtZXJhdGVEZXZpY2VzKCkudGhlbih1bmRlZmluZWQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNDkpIHtcbiAgICB2YXIgb3JpZ0dldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLlxuICAgICAgICBiaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIG9yaWdHZXRVc2VyTWVkaWEoYykudGhlbihmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgLy8gV29yayBhcm91bmQgaHR0cHM6Ly9idWd6aWwubGEvODAyMzI2XG4gICAgICAgIGlmIChjLmF1ZGlvICYmICFzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggfHxcbiAgICAgICAgICAgIGMudmlkZW8gJiYgIXN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCkge1xuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIG9iamVjdCBjYW4gbm90IGJlIGZvdW5kIGhlcmUuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdOb3RGb3VuZEVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHNoaW1FcnJvcl8oZSkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNDQpIHtcbiAgICAgIHJldHVybiBnZXRVc2VyTWVkaWFfKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICAgIH1cbiAgICAvLyBSZXBsYWNlIEZpcmVmb3ggNDQrJ3MgZGVwcmVjYXRpb24gd2FybmluZyB3aXRoIHVucHJlZml4ZWQgdmVyc2lvbi5cbiAgICBjb25zb2xlLndhcm4oJ25hdmlnYXRvci5nZXRVc2VyTWVkaWEgaGFzIGJlZW4gcmVwbGFjZWQgYnkgJyArXG4gICAgICAgICAgICAgICAgICduYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYScpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gIH07XG59O1xuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgc2FmYXJpU2hpbSA9IHtcbiAgLy8gVE9ETzogRHJBbGV4LCBzaG91bGQgYmUgaGVyZSwgZG91YmxlIGNoZWNrIGFnYWluc3QgTGF5b3V0VGVzdHNcbiAgLy8gc2hpbU9uVHJhY2s6IGZ1bmN0aW9uKCkgeyB9LFxuXG4gIC8vIFRPRE86IG9uY2UgdGhlIGJhY2stZW5kIGZvciB0aGUgbWFjIHBvcnQgaXMgZG9uZSwgYWRkLlxuICAvLyBUT0RPOiBjaGVjayBmb3Igd2Via2l0R1RLK1xuICAvLyBzaGltUGVlckNvbm5lY3Rpb246IGZ1bmN0aW9uKCkgeyB9LFxuXG4gIHNoaW1HZXRVc2VyTWVkaWE6IGZ1bmN0aW9uKCkge1xuICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhO1xuICB9XG59O1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hpbUdldFVzZXJNZWRpYTogc2FmYXJpU2hpbS5zaGltR2V0VXNlck1lZGlhXG4gIC8vIFRPRE9cbiAgLy8gc2hpbU9uVHJhY2s6IHNhZmFyaVNoaW0uc2hpbU9uVHJhY2ssXG4gIC8vIHNoaW1QZWVyQ29ubmVjdGlvbjogc2FmYXJpU2hpbS5zaGltUGVlckNvbm5lY3Rpb25cbn07XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbiAvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ0Rpc2FibGVkXyA9IHRydWU7XG5cbi8vIFV0aWxpdHkgbWV0aG9kcy5cbnZhciB1dGlscyA9IHtcbiAgZGlzYWJsZUxvZzogZnVuY3Rpb24oYm9vbCkge1xuICAgIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIGJvb2wgK1xuICAgICAgICAgICcuIFBsZWFzZSB1c2UgYSBib29sZWFuLicpO1xuICAgIH1cbiAgICBsb2dEaXNhYmxlZF8gPSBib29sO1xuICAgIHJldHVybiAoYm9vbCkgPyAnYWRhcHRlci5qcyBsb2dnaW5nIGRpc2FibGVkJyA6XG4gICAgICAgICdhZGFwdGVyLmpzIGxvZ2dpbmcgZW5hYmxlZCc7XG4gIH0sXG5cbiAgbG9nOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChsb2dEaXNhYmxlZF8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgYnJvd3NlciB2ZXJzaW9uIG91dCBvZiB0aGUgcHJvdmlkZWQgdXNlciBhZ2VudCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdWFzdHJpbmcgdXNlckFnZW50IHN0cmluZy5cbiAgICogQHBhcmFtIHshc3RyaW5nfSBleHByIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIGFzIG1hdGNoIGNyaXRlcmlhLlxuICAgKiBAcGFyYW0geyFudW1iZXJ9IHBvcyBwb3NpdGlvbiBpbiB0aGUgdmVyc2lvbiBzdHJpbmcgdG8gYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4geyFudW1iZXJ9IGJyb3dzZXIgdmVyc2lvbi5cbiAgICovXG4gIGV4dHJhY3RWZXJzaW9uOiBmdW5jdGlvbih1YXN0cmluZywgZXhwciwgcG9zKSB7XG4gICAgdmFyIG1hdGNoID0gdWFzdHJpbmcubWF0Y2goZXhwcik7XG4gICAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSBwb3MgJiYgcGFyc2VJbnQobWF0Y2hbcG9zXSwgMTApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCcm93c2VyIGRldGVjdG9yLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IHJlc3VsdCBjb250YWluaW5nIGJyb3dzZXIgYW5kIHZlcnNpb25cbiAgICogICAgIHByb3BlcnRpZXMuXG4gICAqL1xuICBkZXRlY3RCcm93c2VyOiBmdW5jdGlvbigpIHtcbiAgICAvLyBSZXR1cm5lZCByZXN1bHQgb2JqZWN0LlxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICByZXN1bHQuYnJvd3NlciA9IG51bGw7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBudWxsO1xuXG4gICAgLy8gRmFpbCBlYXJseSBpZiBpdCdzIG5vdCBhIGJyb3dzZXJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5uYXZpZ2F0b3IpIHtcbiAgICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIGJyb3dzZXIuJztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRmlyZWZveC5cbiAgICBpZiAobmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkge1xuICAgICAgcmVzdWx0LmJyb3dzZXIgPSAnZmlyZWZveCc7XG4gICAgICByZXN1bHQudmVyc2lvbiA9IHRoaXMuZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICAvRmlyZWZveFxcLyhbMC05XSspXFwuLywgMSk7XG5cbiAgICAvLyBhbGwgd2Via2l0LWJhc2VkIGJyb3dzZXJzXG4gICAgfSBlbHNlIGlmIChuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhKSB7XG4gICAgICAvLyBDaHJvbWUsIENocm9taXVtLCBXZWJ2aWV3LCBPcGVyYSwgYWxsIHVzZSB0aGUgY2hyb21lIHNoaW0gZm9yIG5vd1xuICAgICAgaWYgKHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbikge1xuICAgICAgICByZXN1bHQuYnJvd3NlciA9ICdjaHJvbWUnO1xuICAgICAgICByZXN1bHQudmVyc2lvbiA9IHRoaXMuZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICAvQ2hyb20oZXxpdW0pXFwvKFswLTldKylcXC4vLCAyKTtcblxuICAgICAgLy8gU2FmYXJpIG9yIHVua25vd24gd2Via2l0LWJhc2VkXG4gICAgICAvLyBmb3IgdGhlIHRpbWUgYmVpbmcgU2FmYXJpIGhhcyBzdXBwb3J0IGZvciBNZWRpYVN0cmVhbXMgYnV0IG5vdCB3ZWJSVENcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNhZmFyaSBVQSBzdWJzdHJpbmdzIG9mIGludGVyZXN0IGZvciByZWZlcmVuY2U6XG4gICAgICAgIC8vIC0gd2Via2l0IHZlcnNpb246ICAgICAgICAgICBBcHBsZVdlYktpdC82MDIuMS4yNSAoYWxzbyB1c2VkIGluIE9wLENyKVxuICAgICAgICAvLyAtIHNhZmFyaSBVSSB2ZXJzaW9uOiAgICAgICAgVmVyc2lvbi85LjAuMyAodW5pcXVlIHRvIFNhZmFyaSlcbiAgICAgICAgLy8gLSBzYWZhcmkgVUkgd2Via2l0IHZlcnNpb246IFNhZmFyaS82MDEuNC40IChhbHNvIHVzZWQgaW4gT3AsQ3IpXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlmIHRoZSB3ZWJraXQgdmVyc2lvbiBhbmQgc2FmYXJpIFVJIHdlYmtpdCB2ZXJzaW9ucyBhcmUgZXF1YWxzLFxuICAgICAgICAvLyAuLi4gdGhpcyBpcyBhIHN0YWJsZSB2ZXJzaW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBvbmx5IHRoZSBpbnRlcm5hbCB3ZWJraXQgdmVyc2lvbiBpcyBpbXBvcnRhbnQgdG9kYXkgdG8ga25vdyBpZlxuICAgICAgICAvLyBtZWRpYSBzdHJlYW1zIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC8oXFxkKykuKFxcZCspLykpIHtcbiAgICAgICAgICByZXN1bHQuYnJvd3NlciA9ICdzYWZhcmknO1xuICAgICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdGhpcy5leHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICAgICAgL0FwcGxlV2ViS2l0XFwvKFswLTldKylcXC4vLCAxKTtcblxuICAgICAgICAvLyB1bmtub3duIHdlYmtpdC1iYXNlZCBicm93c2VyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LmJyb3dzZXIgPSAnVW5zdXBwb3J0ZWQgd2Via2l0LWJhc2VkIGJyb3dzZXIgJyArXG4gICAgICAgICAgICAgICd3aXRoIEdVTSBzdXBwb3J0IGJ1dCBubyBXZWJSVEMgc3VwcG9ydC4nO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vIEVkZ2UuXG4gICAgfSBlbHNlIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmXG4gICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8oXFxkKykuKFxcZCspJC8pKSB7XG4gICAgICByZXN1bHQuYnJvd3NlciA9ICdlZGdlJztcbiAgICAgIHJlc3VsdC52ZXJzaW9uID0gdGhpcy5leHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICAgIC9FZGdlXFwvKFxcZCspLihcXGQrKSQvLCAyKTtcblxuICAgIC8vIERlZmF1bHQgZmFsbHRocm91Z2g6IG5vdCBzdXBwb3J0ZWQuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIHN1cHBvcnRlZCBicm93c2VyLic7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIEV4cG9ydC5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb2c6IHV0aWxzLmxvZyxcbiAgZGlzYWJsZUxvZzogdXRpbHMuZGlzYWJsZUxvZyxcbiAgYnJvd3NlckRldGFpbHM6IHV0aWxzLmRldGVjdEJyb3dzZXIoKSxcbiAgZXh0cmFjdFZlcnNpb246IHV0aWxzLmV4dHJhY3RWZXJzaW9uXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsInZhciBtczJzID0gMS4wIC8gMTAwMC4wO1xudmFyIG5zMm1zID0gMS4wIC8gMTAwMDAwMC4wXG52YXIgbnMycyA9IDFlLTlcblxubW9kdWxlLmV4cG9ydHMgPSBUXG5cbmZ1bmN0aW9uIFQoKXtcblx0aWYoIXByb2Nlc3MuaHJ0aW1lKXsgLy8gYnJvd3NlciBmaWxsXG5cblx0XHRwcm9jZXNzLmhydGltZSA9IGZ1bmN0aW9uKCl7XG5cblx0XHRcdGlmKGFyZ3VtZW50cy5sZW5ndGgpe1xuXHRcdFx0XHRhcmd1bWVudHNbMV0gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRcdFx0YXJndW1lbnRzWzBdID0gIGFyZ3VtZW50c1sxXSAtIG1pbGxpZXMoYXJndW1lbnRzWzBdKVxuXHRcdFx0fVxuXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YXJndW1lbnRzWzBdID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBbcGFyc2VJbnQoYXJndW1lbnRzWzBdICogbXMycyksIHBhcnNlSW50KCgoYXJndW1lbnRzWzBdICogbXMycykgJSAxKSAvIG5zMnMpXTtcblx0XHRcdFxuXHRcdH1cblx0fVxuICBpZighKHRoaXMgaW5zdGFuY2VvZiBUKSkgcmV0dXJuIG5ldyBUKCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5zdGFydCA9IHNlbGYubGFzdCA9IHNlbGYuYmVhdCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gIHNlbGYueCA9IFtdXG4gIHNlbGYuZW5kID0gW11cbiAgc2VsZi5iZWF0cyA9ICBbXVxuICBzZWxmLmF2ZXJhZ2VTZXRTaXplID0gMzMzXG4gIHNlbGYudGhyZXNob2xkID0gMWU2IC8vIDEwLDAwMCwwMDAgbnMgKCAxMCBtcyApXG4gIHNlbGYuc2tpcCA9IGZhbHNlXG59O1xuXG5ULnByb3RvdHlwZS5zaW5jZUJlZ2luID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHByb2Nlc3MuaHJ0aW1lKHRoaXMuc3RhcnQpXG59O1xuXG5ULnByb3RvdHlwZS5zaW5jZUxhc3QgPSBmdW5jdGlvbigpe1xuICB0aGlzLnggPSBwcm9jZXNzLmhydGltZSh0aGlzLmxhc3QpXG4gIHRoaXMubGFzdCA9IHByb2Nlc3MuaHJ0aW1lKClcbiAgcmV0dXJuIHRoaXMueFxufVxuXG5ULnByb3RvdHlwZS5zaW5jZUxhc3ROUyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBuYW5vcyh0aGlzLnNpbmNlTGFzdCgpKVxufTtcblxuVC5wcm90b3R5cGUuc2luY2VCZWdpbk5TID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5hbm9zKHRoaXMuc2luY2VCZWdpbigpKVxufTtcblxuVC5wcm90b3R5cGUuYXZnID0gZnVuY3Rpb24oKXtcbiAgdmFyIG5zID0gbmFub3ModGhpcy5zaW5jZUxhc3QoKSlcbiAgdGhpcy5iZWF0cy5wdXNoKG5zKTtcbiAgdGhpcy5iZWF0cyA9IHRoaXMuYmVhdHMuc3BsaWNlKC10aGlzLmF2ZXJhZ2VTZXRTaXplKVxuICByZXR1cm4gYXZnKHRoaXMuYmVhdHMpO1xufTtcblxuVC5wcm90b3R5cGUuZXZlcnlTID0gZnVuY3Rpb24ocywgZm4sIGdvKXtcblx0dGhpcy5ldmVyeShzICogMWU5LCBmbiwgZ28pXG59XG5cblQucHJvdG90eXBlLmV2ZXJ5ID0gZnVuY3Rpb24obnMsIGZuLCBnbyl7XG5cbiAgdmFyIHNlbGYgPSBuZXcgVCgpO1xuICB2YXIgdGltZXIgPSBuZXcgVCgpO1xuXG4gIHZhciBpbnRlciA9IG5zIHx8IDBcbiAgICAsIGZuID0gZm4gfHwgZnVuY3Rpb24odCxjKXtjKCl9XG4gICAgOyAgIFxuICAgICAgXG4gIGZ1bmN0aW9uIHRpY2soKXtcblxuICAgIHZhciBucyA9IG5hbm9zKHNlbGYuc2luY2VMYXN0KCkpO1xuLy8gIHVubmVjZXNzYXJ5IGN1eiBubyBsb25nZXIgdHJ5aW5nIHRvIG9wdGltaXplIGluIGxvb3AoKVxuLy8gICAgc2VsZi5iZWF0cy5wdXNoKG5zKTtcbiAgICBsb29wKClcblxuICB9O1xuXG4gIGZ1bmN0aW9uIGxvb3AoKXtcbiAgICB2YXIgZCA9IGludGVyIC0gKG5hbm9zKHByb2Nlc3MuaHJ0aW1lKCkpIC0gbmFub3Moc2VsZi5iZWF0KSk7XG5cbiAgICBpZihkIDwgMTAwMDApIHtcbiAgICAgIHRvY2soKVxuICAgIH1cblxuICAgIGVsc2UgaWYoc2VsZi5za2lwKSB7XG4gICAgIHNldEltbWVkaWF0ZShsb29wKVxuICAgIH1cblxuICAgIGVsc2UgaWYoZCA8IHNlbGYudGhyZXNob2xkKSB7XG4gICAgICAvLyB1bmRlciB0aGUgdGhyZXNob2xkLCBpdHMgbmV4dFRpY2tzIHVudGlsIHRoZSBpbnRlcnZhbCBpcyB1cFxuICAgICAgc2VsZi5za2lwID0gdHJ1ZTsgc2V0SW1tZWRpYXRlKGxvb3ApIFxuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgaWYoZmFsc2UgJiYgc2VsZi5iZWF0cy5sZW5ndGggPiA5KSB7XG4gICAgICAgIHZhciByID0gc2VsZi5iZWF0cy5sZW5ndGggLyBzZWxmLmF2ZXJhZ2VTZXRTaXplO1xuICAgICAgICBzZWxmLnRocmVzaG9sZCA9IGF2ZyhzZWxmLmJlYXRzKSAqIC40NSAqIHIgKiAyXG4gICAgICB9XG5cbiAgICAgIC8vIGZvciBmdXR1cmUgcmVmZXJlbmNlOlxuICAgICAgLy8gY29uc29sZS5sb2coYXZnKHNlbGYuYmVhdHMpLCBzZWxmLmJlYXRzLmxlbmd0aCwgJ3RocmVzaG9sZCA9ICcgKyBzZWxmLnRocmVzaG9sZClcblxuICAgICAgc2VsZi5za2lwID0gZmFsc2U7IFxuICAgICAgc2V0VGltZW91dChsb29wLCBzZWxmLnRocmVzaG9sZCAvIDFlNilcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9jaygpe1xuICAgIHNlbGYuYmVhdCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgc2VsZi5za2lwID0gZmFsc2U7XG4gICAgZm4odGljaywgbmFub3ModGltZXIuc2luY2VMYXN0KCkpKVxuICB9O1xuICBcbiAgaWYoZ28pIHRvY2soKVxuXG4gIGVsc2UgbG9vcCgpXG5cbn1cblxuZnVuY3Rpb24gbWlsbGllcyhhcnIpe1xuXHRyZXR1cm4gKGFyclswXSAqIDFlMykgKyAoYXJyWzFdICogbnMybXMpXG59XG5cbmZ1bmN0aW9uIG5hbm9zKGFycil7XG4gIHJldHVybiBhcnJbMF0gKiAxZTkgKyBhcnJbMV1cbn1cblxuZnVuY3Rpb24gYWRkKGEsIGIpe1xuICB2YXIgbnMgPSBhWzFdICsgYlsxXTtcbiAgYlswXSArPSBhWzBdO1xuICBiWzFdID0gbnMgJSAxZTk7XG4gIGlmKG5zICE9PSBiWzFdKSBiWzBdKys7XG4gIHJldHVybiBiXG59O1xuXG5mdW5jdGlvbiBhdmcoKXtcblxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzWzBdKS5yZWR1Y2UoZnVuY3Rpb24oYSxpKXtyZXR1cm4gYSArPSBpIH0sMCkgLyBhcmd1bWVudHNbMF0ubGVuZ3RoXG5cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBvc3NpYmxlTmFtZXMgPSBbXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5Jyxcblx0J0Zsb2F0MzJBcnJheScsXG5cdCdGbG9hdDY0QXJyYXknLFxuXHQnSW50MTZBcnJheScsXG5cdCdJbnQzMkFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdVaW50OEFycmF5Jyxcblx0J1VpbnQ4Q2xhbXBlZEFycmF5J1xuXTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xuXHR2YXIgb3V0ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVOYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZ1twb3NzaWJsZU5hbWVzW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3V0W291dC5sZW5ndGhdID0gcG9zc2libGVOYW1lc1tpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHsgX19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAhPSBudWxsICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdGlmICh0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTEpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGRlZmluZVByb3BlcnR5XG5cdFx0JGRlZmluZVByb3BlcnR5ID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kKG9yaWdpbmFsRnVuY3Rpb24pIHtcblx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xuXHRpZiAoJGdPUEQgJiYgJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dmFyIGRlc2MgPSAkZ09QRChmdW5jLCAnbGVuZ3RoJyk7XG5cdFx0aWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG5cdFx0XHQvLyBvcmlnaW5hbCBsZW5ndGgsIHBsdXMgdGhlIHJlY2VpdmVyLCBtaW51cyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgKGFmdGVyIHRoZSByZWNlaXZlcilcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eShcblx0XHRcdFx0ZnVuYyxcblx0XHRcdFx0J2xlbmd0aCcsXG5cdFx0XHRcdHsgdmFsdWU6IDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSkgfVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZ1bmM7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJyk7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRTeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6IEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6IEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6IFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCclVVJJRXJyb3IlJzogVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0JyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ0FycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcblx0JyVBcnJheVByb3RvX2ZvckVhY2glJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZm9yRWFjaCddLFxuXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXG5cdCclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXG5cdCclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0FzeW5jRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclQm9vbGVhblByb3RvdHlwZSUnOiBbJ0Jvb2xlYW4nLCAncHJvdG90eXBlJ10sXG5cdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcblx0JyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcblx0JyVFcnJvclByb3RvdHlwZSUnOiBbJ0Vycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQ2NEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnSW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnSW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG5cdCclSlNPTlN0cmluZ2lmeSUnOiBbJ0pTT04nLCAnc3RyaW5naWZ5J10sXG5cdCclTWFwUHJvdG90eXBlJSc6IFsnTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcblx0JyVPYmplY3RQcm90b3R5cGUlJzogWydPYmplY3QnLCAncHJvdG90eXBlJ10sXG5cdCclT2JqUHJvdG9fdG9TdHJpbmclJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3RvU3RyaW5nJ10sXG5cdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuXHQnJVByb21pc2VQcm90b3R5cGUlJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZSddLFxuXHQnJVByb21pc2VQcm90b190aGVuJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnLCAndGhlbiddLFxuXHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcblx0JyVQcm9taXNlX3JlamVjdCUnOiBbJ1Byb21pc2UnLCAncmVqZWN0J10sXG5cdCclUHJvbWlzZV9yZXNvbHZlJSc6IFsnUHJvbWlzZScsICdyZXNvbHZlJ10sXG5cdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogWydSZWZlcmVuY2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWdFeHBQcm90b3R5cGUlJzogWydSZWdFeHAnLCAncHJvdG90eXBlJ10sXG5cdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnU2hhcmVkQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclU3RyaW5nUHJvdG90eXBlJSc6IFsnU3RyaW5nJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcblx0JyVTeW50YXhFcnJvclByb3RvdHlwZSUnOiBbJ1N5bnRheEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVkQXJyYXlQcm90b3R5cGUlJzogWydUeXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDMyQXJyYXlQcm90b3R5cGUlJzogWydVaW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVUklFcnJvclByb3RvdHlwZSUnOiBbJ1VSSUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtTZXRQcm90b3R5cGUlJzogWydXZWFrU2V0JywgJ3Byb3RvdHlwZSddXG59O1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCdoYXMnKTtcbnZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0dmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcblxuXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcblx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcblx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xuXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0aWYgKGFsaWFzKSB7XG5cdFx0aW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxuXHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHQpXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xuXHRcdH1cblx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xuXG5cdFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0aXNPd24gPSAhIWRlc2M7XG5cblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXG5cdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxuXHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG5cdFx0XHRcdC8vIGl0c2VsZi5cblx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkZXNjLmdldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc093biA9IGhhc093bih2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSByZXF1aXJlKCcuL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scy9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1RvU3RyaW5nVGFnU2hhbXMoKSB7XG5cdHJldHVybiBoYXNTeW1ib2xzKCkgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGblJlZ2V4ID0gL15cXHMqKD86ZnVuY3Rpb24pP1xcKi87XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIGdldEdlbmVyYXRvckZ1bmMgPSBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uKigpIHt9JykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHR9XG59O1xudmFyIEdlbmVyYXRvckZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24oZm4pIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAoaXNGblJlZ2V4LnRlc3QoZm5Ub1N0ci5jYWxsKGZuKSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0dmFyIHN0ciA9IHRvU3RyLmNhbGwoZm4pO1xuXHRcdHJldHVybiBzdHIgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cdH1cblx0aWYgKCFnZXRQcm90bykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAodHlwZW9mIEdlbmVyYXRvckZ1bmN0aW9uID09PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciBnZW5lcmF0b3JGdW5jID0gZ2V0R2VuZXJhdG9yRnVuYygpO1xuXHRcdEdlbmVyYXRvckZ1bmN0aW9uID0gZ2VuZXJhdG9yRnVuYyA/IGdldFByb3RvKGdlbmVyYXRvckZ1bmMpIDogZmFsc2U7XG5cdH1cblx0cmV0dXJuIGdldFByb3RvKGZuKSA9PT0gR2VuZXJhdG9yRnVuY3Rpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgdG9TdHJUYWdzID0ge307XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0dG9TdHJUYWdzW3R5cGVkQXJyYXldID0gZGVzY3JpcHRvci5nZXQ7XG5cdFx0fVxuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGFueVRydWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWFueVRydWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGFueVRydWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSkgPT09IHR5cGVkQXJyYXk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBhbnlUcnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnIHx8ICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSkge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdHJldHVybiAkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gZmFsc2U7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5TdHJlYW0uZmluaXNoZWQgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcycpXG5TdHJlYW0ucGlwZWxpbmUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMnKVxuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG4ndXNlIHN0cmljdCc7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG5cbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcblxuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5cbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBJZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwgdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjsgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cblxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIEVFbGlzdGVuZXJDb3VudChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBkZWJ1ZztcblxuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QnKTtcblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVDsgLy8gTGF6eSBsb2FkZWQgdG8gaW1wcm92ZSB0aGUgc3RhcnR1cCBwZXJmb3JtYW5jZS5cblxuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTsgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcblxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB0aGlzLnBhdXNlZCA9IHRydWU7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG5cbiAgdGhpcy5hd2FpdERyYWluID0gMDsgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3lcblxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsgLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cblxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59OyAvLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuXG4gICAgaWYgKGVyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCgpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRigpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IC8vIFdlIGNhbiBwdXNoIG1vcmUgZGF0YSBpZiB3ZSBhcmUgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmsuXG4gIC8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lIG1vcmUgYnl0ZXMuXG4gIC8vIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsIHN1Y2ggYXMgdGhlIHJlcGwuXG5cblxuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cblxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcblxuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKTtcbiAgfVxuXG4gIHJldHVybiBlcjtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyOyAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7IC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG5cbiAgdmFyIHAgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5oZWFkO1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIHdoaWxlIChwICE9PSBudWxsKSB7XG4gICAgY29udGVudCArPSBkZWNvZGVyLndyaXRlKHAuZGF0YSk7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG5cbiAgaWYgKGNvbnRlbnQgIT09ICcnKSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5wdXNoKGNvbnRlbnQpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xuICByZXR1cm4gdGhpcztcbn07IC8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxR0JcblxuXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5cbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIC8vIFRPRE8ocm9uYWcpOiBUaHJvdyBFUlJfVkFMVUVfT1VUX09GX1JBTkdFLlxuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cblxuICByZXR1cm4gbjtcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcblxuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfSAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cblxuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOyAvLyBEb24ndCBoYXZlIGVub3VnaFxuXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn0gLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoKHN0YXRlLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayA6IHN0YXRlLmxlbmd0aCA+IDApIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuXG5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpOyAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9IC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cblxuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7IC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG5cbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuXG4gICAgc3RhdGUuc3luYyA9IGZhbHNlOyAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cblxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cblxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcblxuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnN5bmMpIHtcbiAgICAvLyBpZiB3ZSBhcmUgc3luYywgd2FpdCB1bnRpbCBuZXh0IHRpY2sgdG8gZW1pdCB0aGUgZGF0YS5cbiAgICAvLyBPdGhlcndpc2Ugd2UgcmlzayBlbWl0dGluZyBkYXRhIGluIHRoZSBmbG93KClcbiAgICAvLyB0aGUgcmVhZGFibGUgY29kZSB0cmlnZ2VycyBkdXJpbmcgYSByZWFkKCkgY2FsbFxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfVxuICB9XG59IC8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5uZWVkUmVhZGFibGUsIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSk7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuXG4gIGlmICghc3RhdGUuZGVzdHJveWVkICYmIChzdGF0ZS5sZW5ndGggfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIH0gLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuXG5cbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBmbG93KHN0cmVhbSk7XG59IC8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuXG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHRoZSBzdHJlYW0gaGFzIGNhbGxlZCB0aGUgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBfcmVhZCgpXG4gIC8vICAgbWV0aG9kLCBidXQgdGhleSBhcmUgcHJvY2Vzc2luZyB0aGUgY2FsbCBhc3luY2hyb25vdXNseSBhbmQgaGF2ZSBfbm90X1xuICAvLyAgIGNhbGxlZCBwdXNoKCkgd2l0aCBuZXcgZGF0YS4gSW4gdGhpcyBjYXNlIHdlIHNraXAgcGVyZm9ybWluZyBtb3JlXG4gIC8vICAgcmVhZCgpcy4gVGhlIGV4ZWN1dGlvbiBlbmRzIGluIHRoaXMgbWV0aG9kIGFnYWluIGFmdGVyIHRoZSBfcmVhZCgpIGVuZHNcbiAgLy8gICB1cCBjYWxsaW5nIHB1c2goKSB3aXRoIG1vcmUgZGF0YS5cbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn0gLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcblxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH0gLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG5cblxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7IC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgY2xlYW5lZFVwID0gdHJ1ZTsgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBkZWJ1ZygnZGVzdC53cml0ZScsIHJldCk7XG5cbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cblxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9IC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG5cblxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBlcnJvck9yRGVzdHJveShkZXN0LCBlcik7XG4gIH0gLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuXG5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpOyAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH0gLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cblxuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7IC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gcGlwZU9uRHJhaW5GdW5jdGlvblJlc3VsdCgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07IC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7IC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlczsgLy8gZ290IGEgbWF0Y2guXG5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuXG5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07IC8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5cblxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7IC8vIFRyeSBzdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcblxuICAgIGlmIChzdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKTtcblxuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgaWYgKHN0YXRlLnJlc3VtZVNjaGVkdWxlZCAmJiAhc3RhdGUucGF1c2VkKSB7XG4gICAgLy8gZmxvd2luZyBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZSBub3csIG90aGVyd2lzZVxuICAgIC8vIHRoZSB1cGNvbWluZyByZXN1bWUgd2lsbCBub3QgZmxvdy5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsgLy8gY3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWVcbiAgfSBlbHNlIGlmIChzZWxmLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICBzZWxmLnJlc3VtZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn0gLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpOyAvLyB3ZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpXG5cbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuXG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnBhdXNlZCA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHtcbiAgICA7XG4gIH1cbn0gLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOyAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcblxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcblxuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTsgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cblxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9IC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cblxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH0gLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cblxuXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG5cbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUZsb3dpbmcnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IHN0YXRlO1xuICAgIH1cbiAgfVxufSk7IC8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZScsIHN0YXRlLmVuZEVtaXR0ZWQpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7IC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgIC8vIGlmIHRoZSB3cml0YWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuXG4gICAgICBpZiAoIXdTdGF0ZSB8fCB3U3RhdGUuYXV0b0Rlc3Ryb3kgJiYgd1N0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbShSZWFkYWJsZSwgaXRlcmFibGUsIG9wdHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcbi8qIDxyZXBsYWNlbWVudD4gKi9cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufSAvLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuXG5cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVELFxuICAgIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX05VTExfVkFMVUVTLFxuICAgIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gICAgRVJSX1VOS05PV05fRU5DT0RJTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVU5LTk9XTl9FTkNPRElORztcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0sXG4gIC8vIGUuZy4gb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgdnMuIG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlLCBldGMuXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG5cbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlOyAvLyBkcmFpbiBldmVudCBmbGFnLlxuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7IC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG5cbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTsgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTsgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG5cbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlOyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuXG4gIHRoaXMubGVuZ3RoID0gMDsgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cblxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTsgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuXG4gIHRoaXMuY29ya2VkID0gMDsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cblxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07IC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuXG5cbiAgdGhpcy53cml0ZWNiID0gbnVsbDsgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7IC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuXG4gIHRoaXMucGVuZGluZ2NiID0gMDsgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2ZpbmlzaCcgKGFuZCBwb3RlbnRpYWxseSAnZW5kJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwOyAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cblxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUJ1ZmZlckdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7IC8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxuXG5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIHJlYWxIYXNJbnN0YW5jZShvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpOyAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFdyaXRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3kuXG5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufSAvLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5cblxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFKCkpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCgpOyAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG59IC8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cblxuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgZXI7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInXSwgY2h1bmspO1xuICB9XG5cbiAgaWYgKGVyKSB7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcbiAgaWYgKHN0YXRlLmVuZGluZykgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTsgLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cblxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cblxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrOyAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cblxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpKTtlbHNlIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcblxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCk7XG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKSB8fCBzdHJlYW0uZGVzdHJveWVkO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn0gLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5cblxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufSAvLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuXG5cbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcblxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpOyAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tOyAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3dyaXRlKCknKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpOyAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH0gLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuXG5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG5cbiAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAgIC8vIGlmIHRoZSByZWFkYWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcblxuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3MubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG5cbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH0gLy8gcmV1c2UgdGhlIGZyZWUgY29ya1JlcS5cblxuXG4gIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGZpbmlzaGVkID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG5cbnZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woJ2xhc3RSZXNvbHZlJyk7XG52YXIga0xhc3RSZWplY3QgPSBTeW1ib2woJ2xhc3RSZWplY3QnKTtcbnZhciBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG52YXIga0VuZGVkID0gU3ltYm9sKCdlbmRlZCcpO1xudmFyIGtMYXN0UHJvbWlzZSA9IFN5bWJvbCgnbGFzdFByb21pc2UnKTtcbnZhciBrSGFuZGxlUHJvbWlzZSA9IFN5bWJvbCgnaGFuZGxlUHJvbWlzZScpO1xudmFyIGtTdHJlYW0gPSBTeW1ib2woJ3N0cmVhbScpO1xuXG5mdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6IGRvbmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikge1xuICB2YXIgcmVzb2x2ZSA9IGl0ZXJba0xhc3RSZXNvbHZlXTtcblxuICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgIHZhciBkYXRhID0gaXRlcltrU3RyZWFtXS5yZWFkKCk7IC8vIHdlIGRlZmVyIGlmIGRhdGEgaXMgbnVsbFxuICAgIC8vIHdlIGNhbiBiZSBleHBlY3RpbmcgZWl0aGVyICdlbmQnIG9yXG4gICAgLy8gJ2Vycm9yJ1xuXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVhZGFibGUoaXRlcikge1xuICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGl0IG1pZ2h0XG4gIC8vIGVtaXQgYW4gZXJyb3Igd2l0aCBwcm9jZXNzLm5leHRUaWNrXG4gIHByb2Nlc3MubmV4dFRpY2socmVhZEFuZFJlc29sdmUsIGl0ZXIpO1xufVxuXG5mdW5jdGlvbiB3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgaXRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGl0ZXJba0VuZGVkXSkge1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlcltrSGFuZGxlUHJvbWlzZV0ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9LCByZWplY3QpO1xuICB9O1xufVxuXG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiAoKSB7fSk7XG52YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKChfT2JqZWN0JHNldFByb3RvdHlwZU8gPSB7XG4gIGdldCBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XG4gIH0sXG5cbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBkZXRlY3RlZCBhbiBlcnJvciBpbiB0aGUgbWVhbndoaWxlXG4gICAgLy8gcmVqZWN0IHN0cmFpZ2h0IGF3YXlcbiAgICB2YXIgZXJyb3IgPSB0aGlzW2tFcnJvcl07XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0VuZGVkXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tTdHJlYW1dLmRlc3Ryb3llZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBkZWZlciB2aWEgbmV4dFRpY2sgYmVjYXVzZSBpZiAuZGVzdHJveShlcnIpIGlzXG4gICAgICAvLyBjYWxsZWQsIHRoZSBlcnJvciB3aWxsIGJlIGVtaXR0ZWQgdmlhIG5leHRUaWNrLCBhbmRcbiAgICAgIC8vIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBubyBlcnJvciBsaW5nZXJpbmcgYXJvdW5kXG4gICAgICAvLyB3YWl0aW5nIHRvIGJlIGVtaXR0ZWQuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXNba0Vycm9yXSkge1xuICAgICAgICAgICAgcmVqZWN0KF90aGlzW2tFcnJvcl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBuZXh0KCkgY2FsbHNcbiAgICAvLyB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBQcm9taXNlIHRvIGZpbmlzaFxuICAgIC8vIHRoaXMgbG9naWMgaXMgb3B0aW1pemVkIHRvIHN1cHBvcnQgZm9yIGF3YWl0IGxvb3BzLFxuICAgIC8vIHdoZXJlIG5leHQoKSBpcyBvbmx5IGNhbGxlZCBvbmNlIGF0IGEgdGltZVxuXG5cbiAgICB2YXIgbGFzdFByb21pc2UgPSB0aGlzW2tMYXN0UHJvbWlzZV07XG4gICAgdmFyIHByb21pc2U7XG5cbiAgICBpZiAobGFzdFByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYXN0IHBhdGggbmVlZGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgdGhpcy5wdXNoKClcbiAgICAgIC8vIHdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgbmV4dCgpIHF1ZXVlXG4gICAgICB2YXIgZGF0YSA9IHRoaXNba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHRoaXNba0hhbmRsZVByb21pc2VdKTtcbiAgICB9XG5cbiAgICB0aGlzW2tMYXN0UHJvbWlzZV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBcInJldHVyblwiLCBmdW5jdGlvbiBfcmV0dXJuKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAvLyBkZXN0cm95KGVyciwgY2IpIGlzIGEgcHJpdmF0ZSBBUElcbiAgLy8gd2UgY2FuIGd1YXJhbnRlZSB3ZSBoYXZlIHRoYXQgaGVyZSwgYmVjYXVzZSB3ZSBjb250cm9sIHRoZVxuICAvLyBSZWFkYWJsZSBjbGFzcyB0aGlzIGlzIGF0dGFjaGVkIHRvXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfSk7XG4gIH0pO1xufSksIF9PYmplY3Qkc2V0UHJvdG90eXBlTyksIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSkge1xuICB2YXIgX09iamVjdCRjcmVhdGU7XG5cbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIChfT2JqZWN0JGNyZWF0ZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtTdHJlYW0sIHtcbiAgICB2YWx1ZTogc3RyZWFtLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVzb2x2ZSwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVqZWN0LCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0Vycm9yLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0VuZGVkLCB7XG4gICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtIYW5kbGVQcm9taXNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGRhdGEgPSBpdGVyYXRvcltrU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gcmVzb2x2ZTtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gcmVqZWN0O1xuICAgICAgfVxuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9PYmplY3QkY3JlYXRlKSk7XG4gIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICBmaW5pc2hlZChzdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XG4gICAgICB2YXIgcmVqZWN0ID0gaXRlcmF0b3Jba0xhc3RSZWplY3RdOyAvLyByZWplY3QgaWYgd2UgYXJlIHdhaXRpbmcgZm9yIGRhdGEgaW4gdGhlIFByb21pc2VcbiAgICAgIC8vIHJldHVybmVkIGJ5IG5leHQoKSBhbmQgc3RvcmUgdGhlIGVycm9yXG5cbiAgICAgIGlmIChyZWplY3QgIT09IG51bGwpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0b3Jba0Vycm9yXSA9IGVycjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XG5cbiAgICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaXRlcmF0b3Jba0VuZGVkXSA9IHRydWU7XG4gIH0pO1xuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgb25SZWFkYWJsZS5iaW5kKG51bGwsIGl0ZXJhdG9yKSk7XG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOyIsIid1c2Ugc3RyaWN0JzsgLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH0gLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuXG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZU5UKHNlbGYsIGVycikge1xuICBlbWl0RXJyb3JOVChzZWxmLCBlcnIpO1xuICBlbWl0Q2xvc2VOVChzZWxmKTtcbn1cblxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xuICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZSAmJiAhc2VsZi5fd3JpdGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgaWYgKHNlbGYuX3JlYWRhYmxlU3RhdGUgJiYgIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5mdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycikge1xuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxuICAvLyBpbiB0aGUgc2FtZSB0aWNrLCBzbyBjaGFuZ2luZyB0aGlzIGlzIHNlbXZlciBtYWpvci5cbiAgLy8gRm9yIG5vdyB3aGVuIHlvdSBvcHQtaW4gdG8gYXV0b0Rlc3Ryb3kgd2UgYWxsb3dcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXG4gIC8vIHNlbXZlciBtYWpvciB1cGRhdGUgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgZGVmYXVsdCB0byB0aGlzLlxuICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICBpZiAoclN0YXRlICYmIHJTdGF0ZS5hdXRvRGVzdHJveSB8fCB3U3RhdGUgJiYgd1N0YXRlLmF1dG9EZXN0cm95KSBzdHJlYW0uZGVzdHJveShlcnIpO2Vsc2Ugc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95LFxuICBlcnJvck9yRGVzdHJveTogZXJyb3JPckRlc3Ryb3lcbn07IiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvdXRpbC90eXBlcy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8xMTJjYzdjMjc1NTEyNTRhYTJiMTcwOThmYjc3NDg2N2YwNWVkMGQ5XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gcmVxdWlyZSgnaXMtYXJndW1lbnRzJyk7XG52YXIgaXNHZW5lcmF0b3JGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWdlbmVyYXRvci1mdW5jdGlvbicpO1xudmFyIHdoaWNoVHlwZWRBcnJheSA9IHJlcXVpcmUoJ3doaWNoLXR5cGVkLWFycmF5Jyk7XG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWQtYXJyYXknKTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcblxudmFyIE9iamVjdFRvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbnZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgc3RyaW5nVmFsdWUgPSB1bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIGJvb2xlYW5WYWx1ZSA9IHVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO1xuXG5pZiAoQmlnSW50U3VwcG9ydGVkKSB7XG4gIHZhciBiaWdJbnRWYWx1ZSA9IHVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmlmIChTeW1ib2xTdXBwb3J0ZWQpIHtcbiAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIHByb3RvdHlwZVZhbHVlT2YodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuXG4vLyBUYWtlbiBmcm9tIGhlcmUgYW5kIG1vZGlmaWVkIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtaXMtcHJvbWlzZS9ibG9iL2NkYTM1YTUxM2JkYTAzZjk3N2FkNWNkZTNhMDc5ZDIzN2U4MmQ3ZWYvaW5kZXguanNcbmZ1bmN0aW9uIGlzUHJvbWlzZShpbnB1dCkge1xuXHRyZXR1cm4gKFxuXHRcdChcblx0XHRcdHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0aW5wdXQgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0KSB8fFxuXHRcdChcblx0XHRcdGlucHV0ICE9PSBudWxsICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LmNhdGNoID09PSAnZnVuY3Rpb24nXG5cdFx0KVxuXHQpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICBpc1R5cGVkQXJyYXkodmFsdWUpIHx8XG4gICAgaXNEYXRhVmlldyh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlclZpZXcgPSBpc0FycmF5QnVmZmVyVmlldztcblxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OEFycmF5ID0gaXNVaW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4Q2xhbXBlZEFycmF5ID0gaXNVaW50OENsYW1wZWRBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDMyQXJyYXkgPSBpc1VpbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5leHBvcnRzLmlzSW50OEFycmF5ID0gaXNJbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDMyQXJyYXkgPSBpc0ludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDMyQXJyYXkgPSBpc0Zsb2F0MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdJbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdJbnQ2NEFycmF5ID0gaXNCaWdJbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ1VpbnQ2NEFycmF5ID0gaXNCaWdVaW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmlzTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNNYXBUb1N0cmluZyhuZXcgTWFwKCkpXG4pO1xuXG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBNYXA7XG59XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5cbmZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG59XG5pc1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzU2V0VG9TdHJpbmcobmV3IFNldCgpKVxuKTtcbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2V0VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNldDtcbn1cbmV4cG9ydHMuaXNTZXQgPSBpc1NldDtcblxuZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha01hcF0nO1xufVxuaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha01hcFRvU3RyaW5nKG5ldyBXZWFrTWFwKCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNXZWFrTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG59XG5leHBvcnRzLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcblxuZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFdlYWtTZXQgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzV2Vha1NldFRvU3RyaW5nKG5ldyBXZWFrU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG59XG5leHBvcnRzLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBEYXRhVmlld10nO1xufVxuaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpXG4pO1xuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRhVmlldztcbn1cbmV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG5cbi8vIFN0b3JlIGEgY29weSBvZiBTaGFyZWRBcnJheUJ1ZmZlciBpbiBjYXNlIGl0J3MgZGVsZXRlZCBlbHNld2hlcmVcbnZhciBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPSB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnID8gU2hhcmVkQXJyYXlCdWZmZXIgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2hhcmVkQXJyYXlCdWZmZXJdJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgU2hhcmVkQXJyYXlCdWZmZXJDb3B5KCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weTtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52UmVnZXggPSAvXiQvO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykge1xuICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHO1xuICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9cXCovZywgJy4qJylcbiAgICAucmVwbGFjZSgvLC9nLCAnJHxeJylcbiAgICAudG9VcHBlckNhc2UoKTtcbiAgZGVidWdFbnZSZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgZGVidWdFbnYgKyAnJCcsICdpJyk7XG59XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmV4cG9ydHMudHlwZXMgPSByZXF1aXJlKCcuL3N1cHBvcnQvdHlwZXMnKTtcblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbmV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLnR5cGVzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgcmV0KSkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZC5iaW5kKG51bGwsIHJlaiwgY2IpKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG52YXIgYXZhaWxhYmxlVHlwZWRBcnJheXMgPSByZXF1aXJlKCdhdmFpbGFibGUtdHlwZWQtYXJyYXlzJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IGdsb2JhbFRoaXM7XG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgdG9TdHJUYWdzID0ge307XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2VzLWFic3RyYWN0L2hlbHBlcnMvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5pZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRCAmJiBnZXRQcm90b3R5cGVPZikge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdGlmICh0eXBlb2YgZ1t0eXBlZEFycmF5XSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikge1xuXHRcdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dG9TdHJUYWdzW3R5cGVkQXJyYXldID0gZGVzY3JpcHRvci5nZXQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGZvdW5kTmFtZSA9IGZhbHNlO1xuXHRmb3JFYWNoKHRvU3RyVGFncywgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuXHRcdGlmICghZm91bmROYW1lKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgbmFtZSA9IGdldHRlci5jYWxsKHZhbHVlKTtcblx0XHRcdFx0aWYgKG5hbWUgPT09IHR5cGVkQXJyYXkpIHtcblx0XHRcdFx0XHRmb3VuZE5hbWUgPSBuYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZE5hbWU7XG59O1xuXG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWQtYXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCFpc1R5cGVkQXJyYXkodmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnIHx8ICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSkgeyByZXR1cm4gJHNsaWNlKCR0b1N0cmluZyh2YWx1ZSksIDgsIC0xKTsgfVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiJdfQ==
