(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// handles audio files and raw, mono, audio buffers

module.exports = function(context, buff, cb){
  
  var name = buff.constructor.name
  //if(Math.random() < .05) console.log(buff)
  if(name == 'ArrayBuffer'){
    context.decodeAudioData(buff).then(function(data){
      var source = context.createBufferSource()
      source.buffer = data
/*      var gain = context.createGain()
      gain.channelCount = 1
      gain.channelCountMode = 'explicit'
      gain.channelInterpretation = 'speakers'
      source.connect(gain)
      source._connect = source.connect
      source.connect = gain.connect
 */     cb(null, source) 
    }).catch(function(err){cb(err, null)})
	
  }else if(name == 'Array'){
  
    var source = context.createBufferSource();
      
    var buffer = context.createBuffer(2, buff[0].length, context.sampleRate)

    try{ // new
      buffer.copyToChannel(buff[0], 0, 0)
      buffer.copyToChannel(buff[1], 1, 0)

    }catch(err){ // old
      //buffer.getChannelData(0).set(buff)
    }
    
    source.buffer = buffer;
    
    /*
    var gain = context.createGain()
    gain.channelCount = 2
    gain.channelCountMode = 'explicit'
    gain.channelInterpretation = 'speakers'
    source.gain = gain
    source.connect(gain)
    source._connect = source.connect
    source.connect = gain.connect
    if(cb) cb(null, source)
    */
    return source
  }
}

},{}],2:[function(require,module,exports){
module.exports = function(master, stream){
    var node = master.createMediaStreamSource(stream)
    var gain = master.createGain()
    gain.channelCount = 1
    gain.channelCountMode = 'explicit'
    gain. channelInterpretation = 'speakers'
    node.connect(gain)
    return gain
}

},{}],3:[function(require,module,exports){
(function (process,Buffer){(function (){

require('domready')(re => {
  const WebAudioContext = window.AudioContext || window.webkitAudioContext
  var master 
  var h = require('hyperscript')
  var ui = require('getids')()
  var bus = require('./sharedEmitter')
  bus.once('iframeLoaded', e => {
    console.log(e)
    bus.emit('pong', {goat: 1})
    bus.on('clock', e => console.log(e))
  })
  //var iframe = require('../iframarfi')
  //var peering = iframe(require('./peering.js'))
  //ui.peering.appendChild(peering)
  
  var Peer = require('simple-peer')
  var signalhub = require('signalhub')
  const {makeAutoObservable,  autorun} = require('mobx')
  const short = require('short-uuid');
  const toa = require('to-arraybuffer')
  const btob = require('blob-to-buffer')
  const thru = require('through2')
  var store = require('store')
  const Time = require('../since-when')
  var jmic = require('../jsynth-mic/stream')
  var sampler = require('../jsynth-file-sample')
  var media 
  var runp =require('run-waterfall')
  var qs = require('querystring')
  var nana = require('nanohref')
  var minimist = require('minimist')
  var argv = minimist(process.argv, {
    default: {
      host: 'folkstack.com',
      port: 80,
      protocol: 'https'
    }
  })
  var debub = signalhub('https://folkstack.com:80', 'debug')
  //var ret=debub.subscribe('return')

  var app 

  window.store = store
  store.clearAll();
  runp([initState, initUI], (err, app)=>{
    app = app

    ui.init.addEventListener('change', e => {
      app._log('init')

      try{
        runp([captureSource, captureSink, captureNetwork, initAudio, initCast(app)].reverse(), (err, app)=>{
          console.log(err, app)
          //app.audio.sourceStream.pipe(app.audio.sinkStream) // heh
          if(app.session.broadcasting) {
            app.network.distance = 1
//            app.network.sourceStream = app.audio.sourceStream
            app.network.isSeekWorthy()
            app.network.allowCalls(app.session.stream)
          
          }
          else app.network.sourceSeek()
      })} catch (err){
        app._log(err)
      }
    })
    
  })

  var ael = ui.player
  var mime = 'audio/ogg;codecs=opus'


  function initState(cb){

    class App {
    
      constructor(){
        this.mic = 1/2
        this.monitor = 0
        this.call = 1/2
        this.track = 1/2
        this.quality = 64000
        this.update = null
        makeAutoObservable(this)
      }

      setGain(dial, value){
        this[dial] = value
        this.update = [dial, value]
      }
    
    }

    const app = new App
    bus.on('appStateChange', e =>{
      app.setGain(e[0], e[1])
    })
    var session = store.get('session')
    if(!session) session = {id: short().generate().split().reverse().join().slice(0,11)}
    session.broadcasting = true
    var q = qs.parse(window.location.search.slice(1))
    if(q.stream) {
      session.stream = q.stream
      session.broadcasting = false 
    }
    else {
      session.stream = session.stream || short().generate().split().reverse().join().slice(0,11)
    }

    app.session = session
  app._log = function(_id) { return e => {
      //ui.debug.appendChild(h('p', e.toString()))    
      debub.broadcast('debug', JSON.stringify({id: _id, log: e}))
  } }(session.id)
    store.set('session', session)
    console.log(app)
    cb(null, app)
  }

  function initAudio(app, cb){
    const audio = {}
    var OpusMediaRecorder = require('opus-media-recorder') 
    window.MediaRecorder = OpusMediaRecorder;
    master = new WebAudioContext({sampleRate: 48000})
    audio.master = master
    audio.broadcastmixer = master.createChannelMerger(2)
    audio.callmixer = master.createChannelMerger(2)
    audio.broadcaststream = master.createMediaStreamDestination()
    audio.callstream = master.createMediaStreamDestination()
    audio.monitor = master.createGain()
    audio.mic = master.createGain()
    audio.call = master.createGain()
    audio.trackmixer = master.createChannelMerger(2)
    audio.track = master.createGain()
    audio.trackmixer.connect(audio.track)

    audio.broadcastmixer.connect(audio.broadcaststream)
    //audio.broadcastmixer.connect(audio.monitor)

    audio.callmixer.connect(audio.callstream)
    //audio.callmixer.connect(audio.monitor)


    audio.mic.connect(audio.monitor)
    audio.call.connect(audio.monitor)
    audio.track.connect(audio.monitor)
    audio.monitor.connect(master.destination)

    audio.mic.connect(audio.broadcastmixer)
    //audio.track.connect(audio.broadcastmixer)
    //audio.call.connect(audio.broadcastmixer)

    //audio.mic.connect(audio.callmixer)
    //audio.track.connect(audio.callmixer)

    audio.broadcastmixer.connect(audio.broadcaststream)
    audio.callmixer.connect(audio.callstream)
    
    const workerOptions = {
      encoderWorkerFactory: function () {
        // UMD should be used if you don't use a web worker bundler for this.
        return new Worker(tob(Buffer("CihmdW5jdGlvbiBPcHVzTWVkaWFXb3JrZXJVTUQocm9vdCwgZmFjdG9yeSkgewogIGlmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmCiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHsKICAgIHZhciBpbml0V29ya2VyID0gZmFjdG9yeSgpOwogICAgaW5pdFdvcmtlcigpOwogIH0KCWVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKQoJCW1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOwoJZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpCgkJZGVmaW5lKFtdLCBmYWN0b3J5KTsKCWVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKQoJCWV4cG9ydHNbImVuY29kZXJXb3JrZXIiXSA9IGZhY3RvcnkoKTsKCWVsc2UKCQlyb290WyJlbmNvZGVyV29ya2VyIl0gPSBmYWN0b3J5KCk7Cn0pKHR5cGVvZiBPcHVzTWVkaWFSZWNvcmRlciAhPT0gJ3VuZGVmaW5lZCcgPyBPcHVzTWVkaWFSZWNvcmRlciA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHsKcmV0dXJuIGZ1bmN0aW9uKCkgeyFmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiBuKHIpe2lmKHRbcl0pcmV0dXJuIHRbcl0uZXhwb3J0czt2YXIgbz10W3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtyXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxuKSxvLmw9ITAsby5leHBvcnRzfW4ubT1lLG4uYz10LG4uZD1mdW5jdGlvbihlLHQscil7bi5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0OnJ9KX0sbi5yPWZ1bmN0aW9uKGUpeyJ1bmRlZmluZWQiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6Ik1vZHVsZSJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSl9LG4udD1mdW5jdGlvbihlLHQpe2lmKDEmdCYmKGU9bihlKSksOCZ0KXJldHVybiBlO2lmKDQmdCYmIm9iamVjdCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHI9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihuLnIociksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJiJzdHJpbmciIT10eXBlb2YgZSlmb3IodmFyIG8gaW4gZSluLmQocixvLGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfS5iaW5kKG51bGwsbykpO3JldHVybiByfSxuLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIG4uZCh0LCJhIix0KSx0fSxuLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LG4ucD0iIixuKG4ucz01KX0oW2Z1bmN0aW9uKGUsdCxuKXsoZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihlLHQpe2Zvcih2YXIgbj0wLHI9ZS5sZW5ndGgtMTtyPj0wO3ItLSl7dmFyIG89ZVtyXTsiLiI9PT1vP2Uuc3BsaWNlKHIsMSk6Ii4uIj09PW8/KGUuc3BsaWNlKHIsMSksbisrKTpuJiYoZS5zcGxpY2UociwxKSxuLS0pfWlmKHQpZm9yKDtuLS07billLnVuc2hpZnQoIi4uIik7cmV0dXJuIGV9ZnVuY3Rpb24gcihlLHQpe2lmKGUuZmlsdGVyKXJldHVybiBlLmZpbHRlcih0KTtmb3IodmFyIG49W10scj0wO3I8ZS5sZW5ndGg7cisrKXQoZVtyXSxyLGUpJiZuLnB1c2goZVtyXSk7cmV0dXJuIG59dC5yZXNvbHZlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PSIiLG89ITEsaT1hcmd1bWVudHMubGVuZ3RoLTE7aT49LTEmJiFvO2ktLSl7dmFyIHU9aT49MD9hcmd1bWVudHNbaV06ZS5jd2QoKTtpZigic3RyaW5nIiE9dHlwZW9mIHUpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MiKTt1JiYodD11KyIvIit0LG89Ii8iPT09dS5jaGFyQXQoMCkpfXJldHVybihvPyIvIjoiIikrKHQ9bihyKHQuc3BsaXQoIi8iKSwoZnVuY3Rpb24oZSl7cmV0dXJuISFlfSkpLCFvKS5qb2luKCIvIikpfHwiLiJ9LHQubm9ybWFsaXplPWZ1bmN0aW9uKGUpe3ZhciBpPXQuaXNBYnNvbHV0ZShlKSx1PSIvIj09PW8oZSwtMSk7cmV0dXJuKGU9bihyKGUuc3BsaXQoIi8iKSwoZnVuY3Rpb24oZSl7cmV0dXJuISFlfSkpLCFpKS5qb2luKCIvIikpfHxpfHwoZT0iLiIpLGUmJnUmJihlKz0iLyIpLChpPyIvIjoiIikrZX0sdC5pc0Fic29sdXRlPWZ1bmN0aW9uKGUpe3JldHVybiIvIj09PWUuY2hhckF0KDApfSx0LmpvaW49ZnVuY3Rpb24oKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cmV0dXJuIHQubm9ybWFsaXplKHIoZSwoZnVuY3Rpb24oZSx0KXtpZigic3RyaW5nIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MiKTtyZXR1cm4gZX0pKS5qb2luKCIvIikpfSx0LnJlbGF0aXZlPWZ1bmN0aW9uKGUsbil7ZnVuY3Rpb24gcihlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoJiYiIj09PWVbdF07dCsrKTtmb3IodmFyIG49ZS5sZW5ndGgtMTtuPj0wJiYiIj09PWVbbl07bi0tKTtyZXR1cm4gdD5uP1tdOmUuc2xpY2UodCxuLXQrMSl9ZT10LnJlc29sdmUoZSkuc3Vic3RyKDEpLG49dC5yZXNvbHZlKG4pLnN1YnN0cigxKTtmb3IodmFyIG89cihlLnNwbGl0KCIvIikpLGk9cihuLnNwbGl0KCIvIikpLHU9TWF0aC5taW4oby5sZW5ndGgsaS5sZW5ndGgpLGE9dSxzPTA7czx1O3MrKylpZihvW3NdIT09aVtzXSl7YT1zO2JyZWFrfXZhciBjPVtdO2ZvcihzPWE7czxvLmxlbmd0aDtzKyspYy5wdXNoKCIuLiIpO3JldHVybihjPWMuY29uY2F0KGkuc2xpY2UoYSkpKS5qb2luKCIvIil9LHQuc2VwPSIvIix0LmRlbGltaXRlcj0iOiIsdC5kaXJuYW1lPWZ1bmN0aW9uKGUpe2lmKCJzdHJpbmciIT10eXBlb2YgZSYmKGUrPSIiKSwwPT09ZS5sZW5ndGgpcmV0dXJuIi4iO2Zvcih2YXIgdD1lLmNoYXJDb2RlQXQoMCksbj00Nz09PXQscj0tMSxvPSEwLGk9ZS5sZW5ndGgtMTtpPj0xOy0taSlpZig0Nz09PSh0PWUuY2hhckNvZGVBdChpKSkpe2lmKCFvKXtyPWk7YnJlYWt9fWVsc2Ugbz0hMTtyZXR1cm4tMT09PXI/bj8iLyI6Ii4iOm4mJjE9PT1yPyIvIjplLnNsaWNlKDAscil9LHQuYmFzZW5hbWU9ZnVuY3Rpb24oZSx0KXt2YXIgbj1mdW5jdGlvbihlKXsic3RyaW5nIiE9dHlwZW9mIGUmJihlKz0iIik7dmFyIHQsbj0wLHI9LTEsbz0hMDtmb3IodD1lLmxlbmd0aC0xO3Q+PTA7LS10KWlmKDQ3PT09ZS5jaGFyQ29kZUF0KHQpKXtpZighbyl7bj10KzE7YnJlYWt9fWVsc2UtMT09PXImJihvPSExLHI9dCsxKTtyZXR1cm4tMT09PXI/IiI6ZS5zbGljZShuLHIpfShlKTtyZXR1cm4gdCYmbi5zdWJzdHIoLTEqdC5sZW5ndGgpPT09dCYmKG49bi5zdWJzdHIoMCxuLmxlbmd0aC10Lmxlbmd0aCkpLG59LHQuZXh0bmFtZT1mdW5jdGlvbihlKXsic3RyaW5nIiE9dHlwZW9mIGUmJihlKz0iIik7Zm9yKHZhciB0PS0xLG49MCxyPS0xLG89ITAsaT0wLHU9ZS5sZW5ndGgtMTt1Pj0wOy0tdSl7dmFyIGE9ZS5jaGFyQ29kZUF0KHUpO2lmKDQ3IT09YSktMT09PXImJihvPSExLHI9dSsxKSw0Nj09PWE/LTE9PT10P3Q9dToxIT09aSYmKGk9MSk6LTEhPT10JiYoaT0tMSk7ZWxzZSBpZighbyl7bj11KzE7YnJlYWt9fXJldHVybi0xPT09dHx8LTE9PT1yfHwwPT09aXx8MT09PWkmJnQ9PT1yLTEmJnQ9PT1uKzE/IiI6ZS5zbGljZSh0LHIpfTt2YXIgbz0iYiI9PT0iYWIiLnN1YnN0cigtMSk/ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlLnN1YnN0cih0LG4pfTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHQ8MCYmKHQ9ZS5sZW5ndGgrdCksZS5zdWJzdHIodCxuKX19KS5jYWxsKHRoaXMsbigyKSl9LGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbihlKXtyZXR1cm4obj0iZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYic3ltYm9sIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiYiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT8ic3ltYm9sIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIHIoZSx0KXtpZigiZnVuY3Rpb24iIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmbyhlLHQpfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4obz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX0pKGUsdCl9ZnVuY3Rpb24gaShlKXt2YXIgdD1mdW5jdGlvbigpe2lmKCJ1bmRlZmluZWQiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoImZ1bmN0aW9uIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBuLHI9YShlKTtpZih0KXt2YXIgbz1hKHRoaXMpLmNvbnN0cnVjdG9yO249UmVmbGVjdC5jb25zdHJ1Y3Qocixhcmd1bWVudHMsbyl9ZWxzZSBuPXIuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB1KHRoaXMsbil9fWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm4hdHx8Im9iamVjdCIhPT1uKHQpJiYiZnVuY3Rpb24iIT10eXBlb2YgdD9mdW5jdGlvbihlKXtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7cmV0dXJuIGV9KGUpOnR9ZnVuY3Rpb24gYShlKXtyZXR1cm4oYT1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfSkoZSl9ZnVuY3Rpb24gcyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfWZ1bmN0aW9uIGMoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBmKGUsdCxuKXtyZXR1cm4gdCYmYyhlLnByb3RvdHlwZSx0KSxuJiZjKGUsbiksZX12YXIgbD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIsbyl7c3dpdGNoKHModGhpcyxlKSx0aGlzLl9zaXplPW4sdGhpcy5fbW9kdWxlPXQsdGhpcy5fc2l6ZSl7Y2FzZSAxOnRoaXMuX2hlYXBBcnJheT1yP3RoaXMuX21vZHVsZS5IRUFQODp0aGlzLl9tb2R1bGUuSEVBUFU4O2JyZWFrO2Nhc2UgMjp0aGlzLl9oZWFwQXJyYXk9cj90aGlzLl9tb2R1bGUuSEVBUDE2OnRoaXMuX21vZHVsZS5IRUFQVTE2O2JyZWFrO2Nhc2UgNDp0aGlzLl9oZWFwQXJyYXk9cj90aGlzLl9tb2R1bGUuSEVBUDMyOnRoaXMuX21vZHVsZS5IRUFQVTMyO2JyZWFrO2RlZmF1bHQ6dGhpcy5faGVhcEFycmF5PXRoaXMuX21vZHVsZS5IRUFQVTh9byYmKHRoaXMuX3NpemU9NCx0aGlzLl9oZWFwQXJyYXk9dGhpcy5fbW9kdWxlLkhFQVBGMzIpLHRoaXMuX3BvaW50ZXI9dGhpcy5fbW9kdWxlLl9tYWxsb2Mobil9cmV0dXJuIGYoZSxbe2tleToiZnJlZSIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9tb2R1bGUuX2ZyZWUodGhpcy5wb2ludGVyKX19LHtrZXk6InBvaW50ZXIiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wb2ludGVyfX0se2tleToidmFsdWUiLGdldDpmdW5jdGlvbigpe3ZhciBlPTA7c3dpdGNoKHRoaXMuX3NpemUpe2Nhc2UgMjplPTE7YnJlYWs7Y2FzZSA0OmU9MjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiUG9pbnRlciBjYW4gYmUgb25seSBkZWZlcmVuY2VkIGFzIGludGVnZXItc2l6ZWQiKX1yZXR1cm4gdGhpcy5faGVhcEFycmF5W3RoaXMucG9pbnRlcj4+ZV19LHNldDpmdW5jdGlvbihlKXt2YXIgdD0wO3N3aXRjaCh0aGlzLl9zaXplKXtjYXNlIDI6dD0xO2JyZWFrO2Nhc2UgNDp0PTI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIlBvaW50ZXIgY2FuIGJlIG9ubHkgZGVmZXJlbmNlZCBhcyBpbnRlZ2VyLXNpemVkIil9dGhpcy5faGVhcEFycmF5W3RoaXMucG9pbnRlcj4+dF09ZX19XSksZX0oKSxwPWZ1bmN0aW9uKGUpe3IobixlKTt2YXIgdD1pKG4pO2Z1bmN0aW9uIG4oZSxyKXt2YXIgbztyZXR1cm4gcyh0aGlzLG4pLG89dC5jYWxsKHRoaXMsZSw0LCEwLCExKSx2b2lkIDAhPT1yJiYoby52YWx1ZT1yKSxvfXJldHVybiBufShsKSxfPWZ1bmN0aW9uKGUpe3IobixlKTt2YXIgdD1pKG4pO2Z1bmN0aW9uIG4oZSxyKXt2YXIgbztyZXR1cm4gcyh0aGlzLG4pLG89dC5jYWxsKHRoaXMsZSw0LCExLCExKSx2b2lkIDAhPT1yJiYoby52YWx1ZT1yKSxvfXJldHVybiBufShsKSxkPWZ1bmN0aW9uKGUpe3IobixlKTt2YXIgdD1pKG4pO2Z1bmN0aW9uIG4oZSxyLG8saSx1KXt2YXIgYTtzKHRoaXMsbiksYT10LmNhbGwodGhpcyxlLHIqbyxpLHUpO3ZhciBjPTA7c3dpdGNoKG8pe2Nhc2UgMTphLl9oZWFwQXJyYXk9aT9hLl9tb2R1bGUuSEVBUDg6YS5fbW9kdWxlLkhFQVBVOCxjPTA7YnJlYWs7Y2FzZSAyOmEuX2hlYXBBcnJheT1pP2EuX21vZHVsZS5IRUFQMTY6YS5fbW9kdWxlLkhFQVBVMTYsYz0xO2JyZWFrO2Nhc2UgNDphLl9oZWFwQXJyYXk9aT9hLl9tb2R1bGUuSEVBUDMyOmEuX21vZHVsZS5IRUFQVTMyLGM9MjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5pdCBzaXplIG11c3QgYmUgYW4gaW50ZWdlci1zaXplIil9dSYmKGEuX2hlYXBBcnJheT1hLl9tb2R1bGUuSEVBUEYzMixjPTIpO3ZhciBmPWEuX3BvaW50ZXI+PmM7cmV0dXJuIGEuX2J1ZmZlcj1hLl9oZWFwQXJyYXkuc3ViYXJyYXkoZixmK3IpLGEuX2xlbmd0aD1yLGF9cmV0dXJuIGYobixbe2tleToic2V0Iix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuX2J1ZmZlci5zZXQoZSx0KX19LHtrZXk6InN1YmFycmF5Iix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9idWZmZXIuc3ViYXJyYXkoZSx0KX19LHtrZXk6Imxlbmd0aCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xlbmd0aH19XSksbn0obCksaD1mdW5jdGlvbihlKXtyKG4sZSk7dmFyIHQ9aShuKTtmdW5jdGlvbiBuKGUscil7cmV0dXJuIHModGhpcyxuKSx0LmNhbGwodGhpcyxlLHIsNCwhMCwhMCl9cmV0dXJuIG59KGQpLG09ZnVuY3Rpb24oZSl7cihuLGUpO3ZhciB0PWkobik7ZnVuY3Rpb24gbihlLHIpe3JldHVybiBzKHRoaXMsbiksdC5jYWxsKHRoaXMsZSxyLDEsITEsITEpfXJldHVybiBufShkKSx5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtzKHRoaXMsZSksdGhpcy5fbW9kdWxlPXR9cmV0dXJuIGYoZSxbe2tleToibWFsbG9jSW50MzIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgcCh0aGlzLl9tb2R1bGUsZSl9fSx7a2V5OiJtYWxsb2NVaW50MzIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgXyh0aGlzLl9tb2R1bGUsZSl9fSx7a2V5OiJtYWxsb2NVaW50OEJ1ZmZlciIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBtKHRoaXMuX21vZHVsZSxlKX19LHtrZXk6Im1hbGxvY0Zsb2F0MzJCdWZmZXIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgaCh0aGlzLl9tb2R1bGUsZSl9fV0pLGV9KCk7ZS5leHBvcnRzPXt3cml0ZVN0cmluZzpmdW5jdGlvbihlLHQsbil7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspZS5zZXRVaW50OCh0K3Isbi5jaGFyQ29kZUF0KHIpKX0sRW1zY3JpcHRlbk1lbW9yeUFsbG9jYXRvcjp5fX0sZnVuY3Rpb24oZSx0KXt2YXIgbixyLG89ZS5leHBvcnRzPXt9O2Z1bmN0aW9uIGkoKXt0aHJvdyBuZXcgRXJyb3IoInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX1mdW5jdGlvbiB1KCl7dGhyb3cgbmV3IEVycm9yKCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX1mdW5jdGlvbiBhKGUpe2lmKG49PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KGUsMCk7aWYoKG49PT1pfHwhbikmJnNldFRpbWVvdXQpcmV0dXJuIG49c2V0VGltZW91dCxzZXRUaW1lb3V0KGUsMCk7dHJ5e3JldHVybiBuKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlLDApfX19IWZ1bmN0aW9uKCl7dHJ5e249ImZ1bmN0aW9uIj09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDppfWNhdGNoKGUpe249aX10cnl7cj0iZnVuY3Rpb24iPT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDp1fWNhdGNoKGUpe3I9dX19KCk7dmFyIHMsYz1bXSxmPSExLGw9LTE7ZnVuY3Rpb24gcCgpe2YmJnMmJihmPSExLHMubGVuZ3RoP2M9cy5jb25jYXQoYyk6bD0tMSxjLmxlbmd0aCYmXygpKX1mdW5jdGlvbiBfKCl7aWYoIWYpe3ZhciBlPWEocCk7Zj0hMDtmb3IodmFyIHQ9Yy5sZW5ndGg7dDspe2ZvcihzPWMsYz1bXTsrK2w8dDspcyYmc1tsXS5ydW4oKTtsPS0xLHQ9Yy5sZW5ndGh9cz1udWxsLGY9ITEsZnVuY3Rpb24oZSl7aWYocj09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KGUpO2lmKChyPT09dXx8IXIpJiZjbGVhclRpbWVvdXQpcmV0dXJuIHI9Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dChlKTt0cnl7cihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlKX19fShlKX19ZnVuY3Rpb24gZChlLHQpe3RoaXMuZnVuPWUsdGhpcy5hcnJheT10fWZ1bmN0aW9uIGgoKXt9by5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciBuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0W24tMV09YXJndW1lbnRzW25dO2MucHVzaChuZXcgZChlLHQpKSwxIT09Yy5sZW5ndGh8fGZ8fGEoXyl9LGQucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LG8udGl0bGU9ImJyb3dzZXIiLG8uYnJvd3Nlcj0hMCxvLmVudj17fSxvLmFyZ3Y9W10sby52ZXJzaW9uPSIiLG8udmVyc2lvbnM9e30sby5vbj1oLG8uYWRkTGlzdGVuZXI9aCxvLm9uY2U9aCxvLm9mZj1oLG8ucmVtb3ZlTGlzdGVuZXI9aCxvLnJlbW92ZUFsbExpc3RlbmVycz1oLG8uZW1pdD1oLG8ucHJlcGVuZExpc3RlbmVyPWgsby5wcmVwZW5kT25jZUxpc3RlbmVyPWgsby5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119LG8uYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkIil9LG8uY3dkPWZ1bmN0aW9uKCl7cmV0dXJuIi8ifSxvLmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcigicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkIil9LG8udW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBlLndlYnBhY2tQb2x5ZmlsbHx8KGUuZGVwcmVjYXRlPWZ1bmN0aW9uKCl7fSxlLnBhdGhzPVtdLGUuY2hpbGRyZW58fChlLmNoaWxkcmVuPVtdKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwibG9hZGVkIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZS5sfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJpZCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGUuaX19KSxlLndlYnBhY2tQb2x5ZmlsbD0xKSxlfX0sZnVuY3Rpb24oZSx0KXt9LGZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUpe3ZhciB0LHI9big2KSxvPW4oNyksaT1uKDgpO2Uub25tZXNzYWdlPWZ1bmN0aW9uKGUpe3ZhciBuPWUuZGF0YS5jb21tYW5kO3N3aXRjaChuKXtjYXNlImxvYWRFbmNvZGVyIjp2YXIgdSxhPWUuZGF0YSxzPWEubWltZVR5cGUsYz1hLndhc21QYXRoO3N3aXRjaChzKXtjYXNlImF1ZGlvL3dhdiI6Y2FzZSJhdWRpby93YXZlIjp1PXI7YnJlYWs7Y2FzZSJhdWRpby93ZWJtIjp1PW87YnJlYWs7Y2FzZSJhdWRpby9vZ2ciOnU9aX12YXIgZj17fTtjJiYoZi5sb2NhdGVGaWxlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubWF0Y2goLy53YXNtLyk/Yzp0K2V9KSx1KGYpLnRoZW4oKGZ1bmN0aW9uKGUpe3Q9ZSxzZWxmLnBvc3RNZXNzYWdlKHtjb21tYW5kOiJyZWFkeVRvSW5pdCJ9KX0pKTticmVhaztjYXNlImluaXQiOnZhciBsPWUuZGF0YSxwPWwuc2FtcGxlUmF0ZSxfPWwuY2hhbm5lbENvdW50LGQ9bC5iaXRzUGVyU2Vjb25kO3QuaW5pdChwLF8sZCk7YnJlYWs7Y2FzZSJwdXNoSW5wdXREYXRhIjpmb3IodmFyIGg9ZS5kYXRhLG09aC5jaGFubmVsQnVmZmVycyx5PShoLmxlbmd0aCxoLmR1cmF0aW9uLDApO3k8bS5sZW5ndGg7eSsrKW1beV09bmV3IEZsb2F0MzJBcnJheShtW3ldLmJ1ZmZlcik7dC5lbmNvZGUobSk7YnJlYWs7Y2FzZSJnZXRFbmNvZGVkRGF0YSI6Y2FzZSJkb25lIjoiZG9uZSI9PT1uJiZ0LmNsb3NlKCk7dmFyIHY9dC5mbHVzaCgpO3NlbGYucG9zdE1lc3NhZ2Uoe2NvbW1hbmQ6ImRvbmUiPT09bj8ibGFzdEVuY29kZWREYXRhIjoiZW5jb2RlZERhdGEiLGJ1ZmZlcnM6dn0sdiksImRvbmUiPT09biYmc2VsZi5jbG9zZSgpfX19InVuZGVmaW5lZCIhPXR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSYmc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlJiZyKHNlbGYpLGUuZXhwb3J0cz1yfSxmdW5jdGlvbihlLHQsbil7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gbyhlKX0oZSl8fGZ1bmN0aW9uKGUpe2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpKXJldHVybiBBcnJheS5mcm9tKGUpfShlKXx8ZnVuY3Rpb24oZSx0KXtpZighZSlyZXR1cm47aWYoInN0cmluZyI9PXR5cGVvZiBlKXJldHVybiBvKGUsdCk7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpOyJPYmplY3QiPT09biYmZS5jb25zdHJ1Y3RvciYmKG49ZS5jb25zdHJ1Y3Rvci5uYW1lKTtpZigiTWFwIj09PW58fCJTZXQiPT09bilyZXR1cm4gQXJyYXkuZnJvbShlKTtpZigiQXJndW1lbnRzIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKXJldHVybiBvKGUsdCl9KGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLiIpfSgpfWZ1bmN0aW9uIG8oZSx0KXsobnVsbD09dHx8dD5lLmxlbmd0aCkmJih0PWUubGVuZ3RoKTtmb3IodmFyIG49MCxyPW5ldyBBcnJheSh0KTtuPHQ7bisrKXJbbl09ZVtuXTtyZXR1cm4gcn1mdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsInZhbHVlImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19dmFyIHU9bigxKS53cml0ZVN0cmluZyxhPUludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQscz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfSh0aGlzLGUpLHRoaXMuY29uZmlnPXtpbnB1dFNhbXBsZVJhdGU6dCxjaGFubmVsQ291bnQ6bn0sdGhpcy5lbmNvZGVkQnVmZmVycz1bXX12YXIgdCxuLHI7cmV0dXJuIHQ9ZSwobj1be2tleToiZW5jb2RlIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9ZVswXS5sZW5ndGgsbj1uZXcgQXJyYXlCdWZmZXIodCphKnRoaXMuY29uZmlnLmNoYW5uZWxDb3VudCkscj1uZXcgRGF0YVZpZXcobiksbz0wO288dGhpcy5jb25maWcuY2hhbm5lbENvdW50O28rKylmb3IodmFyIGk9ZVtvXSx1PTA7dTx0O3UrKyl7dmFyIHM9MzI3NjcqaVt1XXwwO3M+MzI3Njc/cz0zMjc2NzpzPC0zMjc2OCYmKHM9LTMyNzY4KTt2YXIgYz0odSp0aGlzLmNvbmZpZy5jaGFubmVsQ291bnQrbykqYTtyLnNldEludDE2KGMsMHxzLCEwKX10aGlzLmVuY29kZWRCdWZmZXJzLnB1c2gobil9fSx7a2V5OiJnZXRIZWFkZXIiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5lbmNvZGVkQnVmZmVycy5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdC5ieXRlTGVuZ3RofSksMCksdD1uZXcgQXJyYXlCdWZmZXIoNDQpLG49bmV3IERhdGFWaWV3KHQpO3JldHVybiB1KG4sMCwiUklGRiIpLG4uc2V0VWludDMyKDQsMzYrZSwhMCksdShuLDgsIldBVkUiKSx1KG4sMTIsImZtdCAiKSxuLnNldFVpbnQzMigxNiwxNiwhMCksbi5zZXRVaW50MTYoMjAsMSwhMCksbi5zZXRVaW50MTYoMjIsdGhpcy5jb25maWcuY2hhbm5lbENvdW50LCEwKSxuLnNldFVpbnQzMigyNCx0aGlzLmNvbmZpZy5pbnB1dFNhbXBsZVJhdGUsITApLG4uc2V0VWludDMyKDI4LHRoaXMuY29uZmlnLmlucHV0U2FtcGxlUmF0ZSphKnRoaXMuY29uZmlnLmNoYW5uZWxDb3VudCwhMCksbi5zZXRVaW50MTYoMzIsYSp0aGlzLmNvbmZpZy5jaGFubmVsQ291bnQsITApLG4uc2V0VWludDE2KDM0LDgqYSwhMCksdShuLDM2LCJkYXRhIiksbi5zZXRVaW50MzIoNDAsZSwhMCksdH19XSkmJmkodC5wcm90b3R5cGUsbiksciYmaSh0LHIpLGV9KCk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxuKXsoZT12b2lkIDAhPT1lJiZlfHx7fSkuaW5pdD1mdW5jdGlvbih0LG4scil7ZS5lbmNvZGVyPW5ldyBzKHQsbixyKX0sZS5lbmNvZGU9ZnVuY3Rpb24odCl7ZS5lbmNvZGVyLmVuY29kZSh0KX0sZS5mbHVzaD1mdW5jdGlvbigpe3ZhciB0PWUuZW5jb2Rlci5nZXRIZWFkZXIoKSxuPWUuZW5jb2Rlci5lbmNvZGVkQnVmZmVycy5zcGxpY2UoMCxlLmVuY29kZXIuZW5jb2RlZEJ1ZmZlcnMubGVuZ3RoKTtyZXR1cm5bdF0uY29uY2F0KHIobikpfSxlLmNsb3NlPWZ1bmN0aW9uKCl7fSx0KGUpfSkpfX0sZnVuY3Rpb24oZSx0LG4peyhmdW5jdGlvbihlLHIsbyxpKXt2YXIgdTtmdW5jdGlvbiBhKGUpe3JldHVybihhPSJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJiJzeW1ib2wiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJiJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlPyJzeW1ib2wiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gcyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfWZ1bmN0aW9uIGMoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBmKGUsdCxuKXtyZXR1cm4gdCYmYyhlLnByb3RvdHlwZSx0KSxuJiZjKGUsbiksZX12YXIgbCxwPShsPShsPSJ1bmRlZmluZWQiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8ZSxmdW5jdGlvbihlKXtlPXZvaWQgMCE9PShlPWV8fHt9KT9lOnt9O3ZhciB0PW4oMSksaT10LkVtc2NyaXB0ZW5NZW1vcnlBbGxvY2F0b3IsdT0yMDQ5LGM9NDhlMyxwPTRlMyxfPTIwLGQ9NixoPTQwOTYsbT0wLHk9NDAwMix2PTAsYj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobixyKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dm9pZCAwO3ModGhpcyx0KSx0aGlzLmNvbmZpZz17aW5wdXRTYW1wbGVSYXRlOm4sY2hhbm5lbENvdW50OnJ9LHRoaXMubWVtb3J5PW5ldyBpKGUpLHRoaXMuX29wdXNfZW5jb2Rlcl9jcmVhdGU9ZS5fb3B1c19lbmNvZGVyX2NyZWF0ZSx0aGlzLl9vcHVzX2VuY29kZXJfY3RsPWUuX29wdXNfZW5jb2Rlcl9jdGwsdGhpcy5fb3B1c19lbmNvZGVfZmxvYXQ9ZS5fb3B1c19lbmNvZGVfZmxvYXQsdGhpcy5fb3B1c19lbmNvZGVyX2Rlc3Ryb3k9ZS5fb3B1c19lbmNvZGVyX2Rlc3Ryb3ksdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQsdGhpcy5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQ9ZS5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQsdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3k9ZS5fc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3ksdGhpcy5fY29udGFpbmVyPW5ldyBlLkNvbnRhaW5lcix0aGlzLl9jb250YWluZXIuaW5pdChjLHIsTWF0aC5mbG9vcig0Mjk0OTY3Mjk1Kk1hdGgucmFuZG9tKCkpKSx0aGlzLk9wdXNJbml0Q29kZWMoYyxyLG8pLHRoaXMuU3BlZXhJbml0UmVzYW1wbGVyKG4sYyxyKSx0aGlzLmlucHV0U2FtcGxlc1BlckNoYW5uZWw9bipfLzFlMyx0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWw9YypfLzFlMyx0aGlzLmlucHV0QnVmZmVySW5kZXg9MCx0aGlzLm1JbnB1dEJ1ZmZlcj10aGlzLm1lbW9yeS5tYWxsb2NGbG9hdDMyQnVmZmVyKHRoaXMuaW5wdXRTYW1wbGVzUGVyQ2hhbm5lbCpyKSx0aGlzLm1SZXNhbXBsZWRCdWZmZXI9dGhpcy5tZW1vcnkubWFsbG9jRmxvYXQzMkJ1ZmZlcih0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWwqciksdGhpcy5tT3V0cHV0QnVmZmVyPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQ4QnVmZmVyKHApLHRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzPTEhPT1yP25ldyBGbG9hdDMyQXJyYXkoaCpyKTp2b2lkIDB9cmV0dXJuIGYodCxbe2tleToiZW5jb2RlIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcy5pbnRlcmxlYXZlKGUpLG49MDtuPHQubGVuZ3RoOyl7dmFyIHI9TWF0aC5taW4odGhpcy5tSW5wdXRCdWZmZXIubGVuZ3RoLXRoaXMuaW5wdXRCdWZmZXJJbmRleCx0Lmxlbmd0aC1uKTtpZih0aGlzLm1JbnB1dEJ1ZmZlci5zZXQodC5zdWJhcnJheShuLG4rciksdGhpcy5pbnB1dEJ1ZmZlckluZGV4KSx0aGlzLmlucHV0QnVmZmVySW5kZXgrPXIsdGhpcy5pbnB1dEJ1ZmZlckluZGV4Pj10aGlzLm1JbnB1dEJ1ZmZlci5sZW5ndGgpe3ZhciBvPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih0aGlzLmlucHV0U2FtcGxlc1BlckNoYW5uZWwpLGk9dGhpcy5tZW1vcnkubWFsbG9jVWludDMyKHRoaXMub3V0cHV0U2FtcGxlUGVyQ2hhbm5lbCksdT10aGlzLl9zcGVleF9yZXNhbXBsZXJfcHJvY2Vzc19pbnRlcmxlYXZlZF9mbG9hdCh0aGlzLnJlc2FtcGxlcix0aGlzLm1JbnB1dEJ1ZmZlci5wb2ludGVyLG8ucG9pbnRlcix0aGlzLm1SZXNhbXBsZWRCdWZmZXIucG9pbnRlcixpLnBvaW50ZXIpO2lmKG8uZnJlZSgpLGkuZnJlZSgpLHUhPT12KXRocm93IG5ldyBFcnJvcigiUmVzYW1wbGluZyBlcnJvci4iKTt2YXIgYT10aGlzLl9vcHVzX2VuY29kZV9mbG9hdCh0aGlzLmVuY29kZXIsdGhpcy5tUmVzYW1wbGVkQnVmZmVyLnBvaW50ZXIsdGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsLHRoaXMubU91dHB1dEJ1ZmZlci5wb2ludGVyLHRoaXMubU91dHB1dEJ1ZmZlci5sZW5ndGgpO2lmKGE8MCl0aHJvdyBuZXcgRXJyb3IoIk9wdXMgZW5jb2RpbmcgZXJyb3IuIik7dGhpcy5fY29udGFpbmVyLndyaXRlRnJhbWUodGhpcy5tT3V0cHV0QnVmZmVyLnBvaW50ZXIsYSx0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWwpLHRoaXMuaW5wdXRCdWZmZXJJbmRleD0wfW4rPXJ9fX0se2tleToiY2xvc2UiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuY29uZmlnLmNoYW5uZWxDb3VudCxuPVtdLHI9MDtyPHQ7KytyKW4ucHVzaChuZXcgRmxvYXQzMkFycmF5KGgtdGhpcy5pbnB1dEJ1ZmZlckluZGV4L3QpKTt0aGlzLmVuY29kZShuKSxlLmRlc3Ryb3kodGhpcy5fY29udGFpbmVyKSx0aGlzLm1JbnB1dEJ1ZmZlci5mcmVlKCksdGhpcy5tUmVzYW1wbGVkQnVmZmVyLmZyZWUoKSx0aGlzLm1PdXRwdXRCdWZmZXIuZnJlZSgpLHRoaXMuX29wdXNfZW5jb2Rlcl9kZXN0cm95KHRoaXMuZW5jb2RlciksdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3kodGhpcy5yZXNhbXBsZXIpfX0se2tleToiaW50ZXJsZWF2ZSIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGg7aWYoMT09PXQpcmV0dXJuIGVbMF07Zm9yKHZhciBuPTA7bjx0O24rKylmb3IodmFyIHI9ZVtuXSxvPTA7bzxyLmxlbmd0aDtvKyspdGhpcy5pbnRlcmxlYXZlZEJ1ZmZlcnNbbyp0K25dPXJbb107cmV0dXJuIHRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzfX0se2tleToiT3B1c0luaXRDb2RlYyIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dm9pZCAwLHI9dGhpcy5tZW1vcnkubWFsbG9jVWludDMyKHZvaWQgMCk7dGhpcy5lbmNvZGVyPXRoaXMuX29wdXNfZW5jb2Rlcl9jcmVhdGUoZSx0LHUsci5wb2ludGVyKTt2YXIgbz1yLnZhbHVlO2lmKHIuZnJlZSgpLG8hPT1tKXRocm93IG5ldyBFcnJvcigiT3B1cyBlbmNvZG9yIGluaXRpYWxpemF0aW9uIGZhaWxlZC4iKTtuJiZ0aGlzLk9wdXNTZXRPcHVzQ29udHJvbCh5LG4pfX0se2tleToiT3B1c1NldE9wdXNDb250cm9sIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMubWVtb3J5Lm1hbGxvY0ludDMyKHQpO3RoaXMuX29wdXNfZW5jb2Rlcl9jdGwodGhpcy5lbmNvZGVyLGUsbi5wb2ludGVyKSxuLmZyZWUoKX19LHtrZXk6IlNwZWV4SW5pdFJlc2FtcGxlciIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih2b2lkIDApO3RoaXMucmVzYW1wbGVyPXRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9pbml0KG4sZSx0LGQsci5wb2ludGVyKTt2YXIgbz1yLnZhbHVlO2lmKHIuZnJlZSgpLG8hPT12KXRocm93IG5ldyBFcnJvcigiSW5pdGlhbGl6aW5nIHJlc2FtcGxlciBmYWlsZWQuIil9fV0pLHR9KCk7ZS5pbml0PWZ1bmN0aW9uKHQsbixyKXtlLmVuY29kZWRCdWZmZXJzPVtdLGUuZW5jb2Rlcj1uZXcgYih0LG4scil9LGUuZW5jb2RlPWZ1bmN0aW9uKHQpe2UuZW5jb2Rlci5lbmNvZGUodCl9LGUuZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4gZS5lbmNvZGVkQnVmZmVycy5zcGxpY2UoMCxlLmVuY29kZWRCdWZmZXJzLmxlbmd0aCl9LGUuY2xvc2U9ZnVuY3Rpb24oKXtlLmVuY29kZXIuY2xvc2UoKX07dmFyIGcsdz17fTtmb3IoZyBpbiBlKWUuaGFzT3duUHJvcGVydHkoZykmJih3W2ddPWVbZ10pO3ZhciBBPVtdLEM9ITEsUz0hMSx4PSExLFA9ITE7Qz0ib2JqZWN0Ij09PSgidW5kZWZpbmVkIj09dHlwZW9mIHdpbmRvdz8idW5kZWZpbmVkIjphKHdpbmRvdykpLFM9ImZ1bmN0aW9uIj09dHlwZW9mIGltcG9ydFNjcmlwdHMseD0ib2JqZWN0Ij09PSh2b2lkIDA9PT1yPyJ1bmRlZmluZWQiOmEocikpJiYib2JqZWN0Ij09PWEoci52ZXJzaW9ucykmJiJzdHJpbmciPT10eXBlb2Ygci52ZXJzaW9ucy5ub2RlLFA9IUMmJiF4JiYhUzt2YXIgRSxCLEksUixPPSIiO2Z1bmN0aW9uIGoodCl7cmV0dXJuIGUubG9jYXRlRmlsZT9lLmxvY2F0ZUZpbGUodCxPKTpPK3R9eD8oTz1TP24oMCkuZGlybmFtZShPKSsiLyI6bysiLyIsRT1mdW5jdGlvbihlLHQpe3JldHVybiBJfHwoST1uKDQpKSxSfHwoUj1uKDApKSxlPVIubm9ybWFsaXplKGUpLEkucmVhZEZpbGVTeW5jKGUsdD9udWxsOiJ1dGY4Iil9LEI9ZnVuY3Rpb24oZSl7dmFyIHQ9RShlLCEwKTtyZXR1cm4gdC5idWZmZXJ8fCh0PW5ldyBVaW50OEFycmF5KHQpKSxXKHQuYnVmZmVyKSx0fSxyLmFyZ3YubGVuZ3RoPjEmJnIuYXJndlsxXS5yZXBsYWNlKC9cXC9nLCIvIiksQT1yLmFyZ3Yuc2xpY2UoMiksci5vbigidW5jYXVnaHRFeGNlcHRpb24iLChmdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiBxZSkpdGhyb3cgZX0pKSxyLm9uKCJ1bmhhbmRsZWRSZWplY3Rpb24iLF9lKSxlLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4iW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF0ifSk6UD8oInVuZGVmaW5lZCIhPXR5cGVvZiByZWFkJiYoRT1mdW5jdGlvbihlKXtyZXR1cm4gcmVhZChlKX0pLEI9ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHJlYWRidWZmZXI/bmV3IFVpbnQ4QXJyYXkocmVhZGJ1ZmZlcihlKSk6KFcoIm9iamVjdCI9PT1hKHQ9cmVhZChlLCJiaW5hcnkiKSkpLHQpfSwidW5kZWZpbmVkIiE9dHlwZW9mIHNjcmlwdEFyZ3M/QT1zY3JpcHRBcmdzOnZvaWQgMCE9PWFyZ3VtZW50cyYmKEE9YXJndW1lbnRzKSwidW5kZWZpbmVkIiE9dHlwZW9mIHByaW50JiYoInVuZGVmaW5lZCI9PXR5cGVvZiBjb25zb2xlJiYoY29uc29sZT17fSksY29uc29sZS5sb2c9cHJpbnQsY29uc29sZS53YXJuPWNvbnNvbGUuZXJyb3I9InVuZGVmaW5lZCIhPXR5cGVvZiBwcmludEVycj9wcmludEVycjpwcmludCkpOihDfHxTKSYmKFM/Tz1zZWxmLmxvY2F0aW9uLmhyZWY6ZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKE89ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLGwmJihPPWwpLE89MCE9PU8uaW5kZXhPZigiYmxvYjoiKT9PLnN1YnN0cigwLE8ubGFzdEluZGV4T2YoIi8iKSsxKToiIixFPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKCJHRVQiLGUsITEpLHQuc2VuZChudWxsKSx0LnJlc3BvbnNlVGV4dH0sUyYmKEI9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oIkdFVCIsZSwhMSksdC5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIix0LnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkodC5yZXNwb25zZSl9KSk7dmFyIGssVSxUPWUucHJpbnR8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksRj1lLnByaW50RXJyfHxjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtmb3IoZyBpbiB3KXcuaGFzT3duUHJvcGVydHkoZykmJihlW2ddPXdbZ10pO3c9bnVsbCxlLmFyZ3VtZW50cyYmKEE9ZS5hcmd1bWVudHMpLGUudGhpc1Byb2dyYW0mJmUudGhpc1Byb2dyYW0sZS5xdWl0JiZlLnF1aXQsZS53YXNtQmluYXJ5JiYoaz1lLndhc21CaW5hcnkpLGUubm9FeGl0UnVudGltZSYmZS5ub0V4aXRSdW50aW1lLCJvYmplY3QiIT09KCJ1bmRlZmluZWQiPT10eXBlb2YgV2ViQXNzZW1ibHk/InVuZGVmaW5lZCI6YShXZWJBc3NlbWJseSkpJiZGKCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkIik7dmFyIEg9bmV3IFdlYkFzc2VtYmx5LlRhYmxlKHtpbml0aWFsOjYwLG1heGltdW06NjAsZWxlbWVudDoiYW55ZnVuYyJ9KSxNPSExO2Z1bmN0aW9uIFcoZSx0KXtlfHxfZSgiQXNzZXJ0aW9uIGZhaWxlZDogIit0KX12YXIgRD0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcigidXRmOCIpOnZvaWQgMDtmdW5jdGlvbiB6KGUsdCxuKXtmb3IodmFyIHI9dCtuLG89dDtlW29dJiYhKG8+PXIpOykrK287aWYoby10PjE2JiZlLnN1YmFycmF5JiZEKXJldHVybiBELmRlY29kZShlLnN1YmFycmF5KHQsbykpO2Zvcih2YXIgaT0iIjt0PG87KXt2YXIgdT1lW3QrK107aWYoMTI4JnUpe3ZhciBhPTYzJmVbdCsrXTtpZigxOTIhPSgyMjQmdSkpe3ZhciBzPTYzJmVbdCsrXTtpZigodT0yMjQ9PSgyNDAmdSk/KDE1JnUpPDwxMnxhPDw2fHM6KDcmdSk8PDE4fGE8PDEyfHM8PDZ8NjMmZVt0KytdKTw2NTUzNilpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUpO2Vsc2V7dmFyIGM9dS02NTUzNjtpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGM+PjEwLDU2MzIwfDEwMjMmYyl9fWVsc2UgaSs9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmdSk8PDZ8YSl9ZWxzZSBpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUpfXJldHVybiBpfWZ1bmN0aW9uIEwoZSx0KXtyZXR1cm4gZT96KHEsZSx0KToiIn0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHREZWNvZGVyJiZuZXcgVGV4dERlY29kZXIoInV0Zi0xNmxlIik7dmFyIFYscSxOLEc9NjU1MzY7ZnVuY3Rpb24gWCh0KXtWPXQsZS5IRUFQOD1uZXcgSW50OEFycmF5KHQpLGUuSEVBUDE2PW5ldyBJbnQxNkFycmF5KHQpLGUuSEVBUDMyPU49bmV3IEludDMyQXJyYXkodCksZS5IRUFQVTg9cT1uZXcgVWludDhBcnJheSh0KSxlLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KHQpLGUuSEVBUFUzMj1uZXcgVWludDMyQXJyYXkodCksZS5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkodCksZS5IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkodCl9dmFyIFk9NTI4OTAyNCwkPTQ1OTg0LEo9ZS5JTklUSUFMX01FTU9SWXx8MTY3NzcyMTY7ZnVuY3Rpb24gSyh0KXtmb3IoO3QubGVuZ3RoPjA7KXt2YXIgbj10LnNoaWZ0KCk7aWYoImZ1bmN0aW9uIiE9dHlwZW9mIG4pe3ZhciByPW4uZnVuYzsibnVtYmVyIj09dHlwZW9mIHI/dm9pZCAwPT09bi5hcmc/ZS5keW5DYWxsX3Yocik6ZS5keW5DYWxsX3ZpKHIsbi5hcmcpOnIodm9pZCAwPT09bi5hcmc/bnVsbDpuLmFyZyl9ZWxzZSBuKCl9fShVPWUud2FzbU1lbW9yeT9lLndhc21NZW1vcnk6bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpKL0csbWF4aW11bTpKL0d9KSkmJihWPVUuYnVmZmVyKSxKPVYuYnl0ZUxlbmd0aCxYKFYpLE5bJD4+Ml09WTt2YXIgUT1bXSxaPVtdLGVlPVtdLHRlPVtdO2Z1bmN0aW9uIG5lKCl7aWYoZS5wcmVSdW4pZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBlLnByZVJ1biYmKGUucHJlUnVuPVtlLnByZVJ1bl0pO2UucHJlUnVuLmxlbmd0aDspdWUoZS5wcmVSdW4uc2hpZnQoKSk7SyhRKX1mdW5jdGlvbiByZSgpe0soWil9ZnVuY3Rpb24gb2UoKXtLKGVlKX1mdW5jdGlvbiBpZSgpe2lmKGUucG9zdFJ1bilmb3IoImZ1bmN0aW9uIj09dHlwZW9mIGUucG9zdFJ1biYmKGUucG9zdFJ1bj1bZS5wb3N0UnVuXSk7ZS5wb3N0UnVuLmxlbmd0aDspYWUoZS5wb3N0UnVuLnNoaWZ0KCkpO0sodGUpfWZ1bmN0aW9uIHVlKGUpe1EudW5zaGlmdChlKX1mdW5jdGlvbiBhZShlKXt0ZS51bnNoaWZ0KGUpfXZhciBzZT0wLGNlPW51bGwsZmU9bnVsbDtmdW5jdGlvbiBsZSh0KXtzZSsrLGUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKHNlKX1mdW5jdGlvbiBwZSh0KXtpZihzZS0tLGUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKHNlKSwwPT1zZSYmKG51bGwhPT1jZSYmKGNsZWFySW50ZXJ2YWwoY2UpLGNlPW51bGwpLGZlKSl7dmFyIG49ZmU7ZmU9bnVsbCxuKCl9fWZ1bmN0aW9uIF9lKHQpe3Rocm93IGUub25BYm9ydCYmZS5vbkFib3J0KHQpLFQodCs9IiIpLEYodCksTT0hMCx0PSJhYm9ydCgiK3QrIikuIEJ1aWxkIHdpdGggLXMgQVNTRVJUSU9OUz0xIGZvciBtb3JlIGluZm8uIixuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHQpfWUucHJlbG9hZGVkSW1hZ2VzPXt9LGUucHJlbG9hZGVkQXVkaW9zPXt9O3ZhciBkZT0iZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCI7ZnVuY3Rpb24gaGUoZSl7cmV0dXJuIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aD9lLnN0YXJ0c1dpdGgoZGUpOjA9PT1lLmluZGV4T2YoZGUpfXZhciBtZT0iV2ViTU9wdXNFbmNvZGVyLndhc20iO2Z1bmN0aW9uIHllKCl7dHJ5e2lmKGspcmV0dXJuIG5ldyBVaW50OEFycmF5KGspO2lmKEIpcmV0dXJuIEIobWUpO3Rocm93ImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkIn1jYXRjaChlKXtfZShlKX19ZnVuY3Rpb24gdmUoKXtyZXR1cm4ga3x8IUMmJiFTfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2g/bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7ZSh5ZSgpKX0pKTpmZXRjaChtZSx7Y3JlZGVudGlhbHM6InNhbWUtb3JpZ2luIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKCFlLm9rKXRocm93ImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJyIrbWUrIiciO3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIHllKCl9KSl9ZnVuY3Rpb24gYmUoKXt2YXIgdD17YTpUZX07ZnVuY3Rpb24gbih0LG4pe3ZhciByPXQuZXhwb3J0cztlLmFzbT1yLHBlKCl9ZnVuY3Rpb24gcihlKXtuKGUuaW5zdGFuY2UpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIHZlKCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsdCl9KSkudGhlbihlLChmdW5jdGlvbihlKXtGKCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAiK2UpLF9lKGUpfSkpfWlmKGxlKCksZS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBlLmluc3RhbnRpYXRlV2FzbSh0LG4pfWNhdGNoKGUpe3JldHVybiBGKCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAiK2UpLCExfXJldHVybiBmdW5jdGlvbigpe2lmKGt8fCJmdW5jdGlvbiIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8aGUobWUpfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2gpcmV0dXJuIG8ocik7ZmV0Y2gobWUse2NyZWRlbnRpYWxzOiJzYW1lLW9yaWdpbiJ9KS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZSx0KS50aGVuKHIsKGZ1bmN0aW9uKGUpe0YoIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAiK2UpLEYoImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uIiksbyhyKX0pKX0pKX0oKSx7fX1mdW5jdGlvbiBnZSh0LG4pe3ZhciByPW5ldyBVaW50OEFycmF5KGUuSEVBUFU4LmJ1ZmZlcix0LG4pO2UuZW5jb2RlZEJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShyKS5idWZmZXIpfWZ1bmN0aW9uIHdlKGUsdCxuLHIpe19lKCJBc3NlcnRpb24gZmFpbGVkOiAiK0woZSkrIiwgYXQ6ICIrW3Q/TCh0KToidW5rbm93biBmaWxlbmFtZSIsbixyP0wocik6InVua25vd24gZnVuY3Rpb24iXSl9aGUobWUpfHwobWU9aihtZSkpLFoucHVzaCh7ZnVuYzpmdW5jdGlvbigpe01lKCl9fSk7dmFyIEFlPXttYXBwaW5nczp7fSxidWZmZXJzOltudWxsLFtdLFtdXSxwcmludENoYXI6ZnVuY3Rpb24oZSx0KXt2YXIgbj1BZS5idWZmZXJzW2VdOzA9PT10fHwxMD09PXQ/KCgxPT09ZT9UOkYpKHoobiwwKSksbi5sZW5ndGg9MCk6bi5wdXNoKHQpfSx2YXJhcmdzOnZvaWQgMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQWUudmFyYXJncys9NCxOW0FlLnZhcmFyZ3MtND4+Ml19LGdldFN0cjpmdW5jdGlvbihlKXtyZXR1cm4gTChlKX0sZ2V0NjQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZX19O2Z1bmN0aW9uIENlKGUsdCxuKXtyZXR1cm4gQWUudmFyYXJncz1uLDB9ZnVuY3Rpb24gU2UoZSx0LG4pe0FlLnZhcmFyZ3M9bn1mdW5jdGlvbiB4ZShlLHQsbil7cmV0dXJuIEFlLnZhcmFyZ3M9biwwfWZ1bmN0aW9uIFBlKCl7X2UoKX1mdW5jdGlvbiBFZShlLHQsbil7cS5jb3B5V2l0aGluKGUsdCx0K24pfWZ1bmN0aW9uIEJlKGUpe19lKCJPT00iKX1mdW5jdGlvbiBJZShlKXtCZSgpfWZ1bmN0aW9uIFJlKGUpe3JldHVybiAwfWZ1bmN0aW9uIE9lKGUsdCxuLHIpe3ZhciBvPUFlLmdldFN0cmVhbUZyb21GRChlKSxpPUFlLmRvUmVhZHYobyx0LG4pO3JldHVybiBOW3I+PjJdPWksMH1mdW5jdGlvbiBqZShlLHQsbixyLG8pe31mdW5jdGlvbiBrZShlLHQsbixyKXtmb3IodmFyIG89MCxpPTA7aTxuO2krKyl7Zm9yKHZhciB1PU5bdCs4Kmk+PjJdLGE9Tlt0Kyg4KmkrNCk+PjJdLHM9MDtzPGE7cysrKUFlLnByaW50Q2hhcihlLHFbdStzXSk7bys9YX1yZXR1cm4gTltyPj4yXT1vLDB9ZnVuY3Rpb24gVWUoZSl7dmFyIHQ9RGF0ZS5ub3coKS8xZTN8MDtyZXR1cm4gZSYmKE5bZT4+Ml09dCksdH12YXIgVGU9e2E6d2UsZTpDZSxoOlNlLGc6eGUsYjpQZSxtOmdlLGs6RWUsbDpJZSxjOlJlLGY6T2UsajpqZSxkOmtlLG1lbW9yeTpVLHRhYmxlOkgsaTpVZX0sRmU9YmUoKTtlLmFzbT1GZTt2YXIgSGUsTWU9ZS5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4oTWU9ZS5fX193YXNtX2NhbGxfY3RvcnM9ZS5hc20ubikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxXZT0oZS5fX19lbV9qc19fZW1zY3JpcHRlblB1c2hCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fX19lbV9qc19fZW1zY3JpcHRlblB1c2hCdWZmZXI9ZS5hc20ubykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9lbXNjcmlwdGVuX2JpbmRfVm9pZFB0cl9fX2Rlc3Ryb3lfX18wPWZ1bmN0aW9uKCl7cmV0dXJuKFdlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Wb2lkUHRyX19fZGVzdHJveV9fXzA9ZS5hc20ucCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSksRGU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9Db250YWluZXJfMD1mdW5jdGlvbigpe3JldHVybihEZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX0NvbnRhaW5lcl8wPWUuYXNtLnEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0semU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9pbml0XzM9ZnVuY3Rpb24oKXtyZXR1cm4oemU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9pbml0XzM9ZS5hc20ucikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxMZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX3dyaXRlRnJhbWVfMz1mdW5jdGlvbigpe3JldHVybihMZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX3dyaXRlRnJhbWVfMz1lLmFzbS5zKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFZlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfX19kZXN0cm95X19fMD1mdW5jdGlvbigpe3JldHVybihWZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX19fZGVzdHJveV9fXzA9ZS5hc20udCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBxZShlKXt0aGlzLm5hbWU9IkV4aXRTdGF0dXMiLHRoaXMubWVzc2FnZT0iUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgiK2UrIikiLHRoaXMuc3RhdHVzPWV9ZnVuY3Rpb24gTmUodCl7ZnVuY3Rpb24gbigpe0hlfHwoSGU9ITAsZS5jYWxsZWRSdW49ITAsTXx8KHJlKCksb2UoKSxlLm9uUnVudGltZUluaXRpYWxpemVkJiZlLm9uUnVudGltZUluaXRpYWxpemVkKCksaWUoKSkpfXQ9dHx8QSxzZT4wfHwobmUoKSxzZT4wfHwoZS5zZXRTdGF0dXM/KGUuc2V0U3RhdHVzKCJSdW5uaW5nLi4uIiksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe2Uuc2V0U3RhdHVzKCIiKX0pLDEpLG4oKX0pLDEpKTpuKCkpKX1pZihlLl9vcHVzX2VuY29kZXJfY3JlYXRlPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX29wdXNfZW5jb2Rlcl9jcmVhdGU9ZS5hc20udSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9vcHVzX2VuY29kZV9mbG9hdD1mdW5jdGlvbigpe3JldHVybihlLl9vcHVzX2VuY29kZV9mbG9hdD1lLmFzbS52KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX29wdXNfZW5jb2Rlcl9jdGw9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fb3B1c19lbmNvZGVyX2N0bD1lLmFzbS53KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX29wdXNfZW5jb2Rlcl9kZXN0cm95PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX29wdXNfZW5jb2Rlcl9kZXN0cm95PWUuYXNtLngpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZS5hc20ueSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1mdW5jdGlvbigpe3JldHVybihlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1lLmFzbS56KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWUuYXNtLkEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fZnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9mcmVlPWUuYXNtLkIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fbWFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX21hbGxvYz1lLmFzbS5DKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuZHluQ2FsbF92aT1mdW5jdGlvbigpe3JldHVybihlLmR5bkNhbGxfdmk9ZS5hc20uRCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLmR5bkNhbGxfdj1mdW5jdGlvbigpe3JldHVybihlLmR5bkNhbGxfdj1lLmFzbS5FKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuYXNtPUZlLGUudGhlbj1mdW5jdGlvbih0KXtpZihIZSl0KGUpO2Vsc2V7dmFyIG49ZS5vblJ1bnRpbWVJbml0aWFsaXplZDtlLm9uUnVudGltZUluaXRpYWxpemVkPWZ1bmN0aW9uKCl7biYmbigpLHQoZSl9fXJldHVybiBlfSxmZT1mdW5jdGlvbiBlKCl7SGV8fE5lKCksSGV8fChmZT1lKX0sZS5ydW49TmUsZS5wcmVJbml0KWZvcigiZnVuY3Rpb24iPT10eXBlb2YgZS5wcmVJbml0JiYoZS5wcmVJbml0PVtlLnByZUluaXRdKTtlLnByZUluaXQubGVuZ3RoPjA7KWUucHJlSW5pdC5wb3AoKSgpO2Z1bmN0aW9uIEdlKCl7fWZ1bmN0aW9uIFhlKGUpe3JldHVybihlfHxHZSkuX19jYWNoZV9ffWZ1bmN0aW9uIFllKGUsdCl7dmFyIG49WGUodCkscj1uW2VdO3JldHVybiByfHwoKHI9T2JqZWN0LmNyZWF0ZSgodHx8R2UpLnByb3RvdHlwZSkpLnB0cj1lLG5bZV09cil9ZnVuY3Rpb24gJGUoZSx0KXtyZXR1cm4gWWUoZS5wdHIsdCl9ZnVuY3Rpb24gSmUoZSl7aWYoIWUuX19kZXN0cm95X18pdGhyb3ciRXJyb3I6IENhbm5vdCBkZXN0cm95IG9iamVjdC4gKERpZCB5b3UgY3JlYXRlIGl0IHlvdXJzZWxmPykiO2UuX19kZXN0cm95X18oKSxkZWxldGUgWGUoZS5fX2NsYXNzX18pW2UucHRyXX1mdW5jdGlvbiBLZShlLHQpe3JldHVybiBlLnB0cj09PXQucHRyfWZ1bmN0aW9uIFFlKGUpe3JldHVybiBlLnB0cn1mdW5jdGlvbiBaZShlKXtyZXR1cm4gZS5fX2NsYXNzX199ZnVuY3Rpb24gZXQoKXt0aHJvdyJjYW5ub3QgY29uc3RydWN0IGEgVm9pZFB0ciwgbm8gY29uc3RydWN0b3IgaW4gSURMIn1mdW5jdGlvbiB0dCgpe3RoaXMucHRyPURlKCksWGUodHQpW3RoaXMucHRyXT10aGlzfXJldHVybiBOZSgpLEdlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEdlLnByb3RvdHlwZSksR2UucHJvdG90eXBlLmNvbnN0cnVjdG9yPUdlLEdlLnByb3RvdHlwZS5fX2NsYXNzX189R2UsR2UuX19jYWNoZV9fPXt9LGUuV3JhcHBlck9iamVjdD1HZSxlLmdldENhY2hlPVhlLGUud3JhcFBvaW50ZXI9WWUsZS5jYXN0T2JqZWN0PSRlLGUuTlVMTD1ZZSgwKSxlLmRlc3Ryb3k9SmUsZS5jb21wYXJlPUtlLGUuZ2V0UG9pbnRlcj1RZSxlLmdldENsYXNzPVplLGV0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEdlLnByb3RvdHlwZSksZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yPWV0LGV0LnByb3RvdHlwZS5fX2NsYXNzX189ZXQsZXQuX19jYWNoZV9fPXt9LGUuVm9pZFB0cj1ldCxldC5wcm90b3R5cGUuX19kZXN0cm95X189ZXQucHJvdG90eXBlLl9fZGVzdHJveV9fPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wdHI7V2UoZSl9LHR0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEdlLnByb3RvdHlwZSksdHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXR0LHR0LnByb3RvdHlwZS5fX2NsYXNzX189dHQsdHQuX19jYWNoZV9fPXt9LGUuQ29udGFpbmVyPXR0LHR0LnByb3RvdHlwZS5pbml0PXR0LnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLnB0cjtlJiYib2JqZWN0Ij09PWEoZSkmJihlPWUucHRyKSx0JiYib2JqZWN0Ij09PWEodCkmJih0PXQucHRyKSxuJiYib2JqZWN0Ij09PWEobikmJihuPW4ucHRyKSx6ZShyLGUsdCxuKX0sdHQucHJvdG90eXBlLndyaXRlRnJhbWU9dHQucHJvdG90eXBlLndyaXRlRnJhbWU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMucHRyO2UmJiJvYmplY3QiPT09YShlKSYmKGU9ZS5wdHIpLHQmJiJvYmplY3QiPT09YSh0KSYmKHQ9dC5wdHIpLG4mJiJvYmplY3QiPT09YShuKSYmKG49bi5wdHIpLExlKHIsZSx0LG4pfSx0dC5wcm90b3R5cGUuX19kZXN0cm95X189dHQucHJvdG90eXBlLl9fZGVzdHJveV9fPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wdHI7VmUoZSl9LGV9KTsib2JqZWN0Ij09PWEodCkmJiJvYmplY3QiPT09YShpKT9pLmV4cG9ydHM9cDp2b2lkIDA9PT0odT1mdW5jdGlvbigpe3JldHVybiBwfS5hcHBseSh0LFtdKSl8fChpLmV4cG9ydHM9dSl9KS5jYWxsKHRoaXMsIi9pbmRleC5qcyIsbigyKSwiLyIsbigzKShlKSl9LGZ1bmN0aW9uKGUsdCxuKXsoZnVuY3Rpb24oZSxyLG8saSl7dmFyIHU7ZnVuY3Rpb24gYShlKXtyZXR1cm4oYT0iZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYic3ltYm9sIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiYiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT8ic3ltYm9sIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIHMoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKX1mdW5jdGlvbiBjKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsInZhbHVlImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19ZnVuY3Rpb24gZihlLHQsbil7cmV0dXJuIHQmJmMoZS5wcm90b3R5cGUsdCksbiYmYyhlLG4pLGV9dmFyIGwscD0obD0obD0idW5kZWZpbmVkIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCl8fGUsZnVuY3Rpb24oZSl7ZT12b2lkIDAhPT0oZT1lfHx7fSk/ZTp7fTt2YXIgdD1uKDEpLGk9dC5FbXNjcmlwdGVuTWVtb3J5QWxsb2NhdG9yLHU9MjA0OSxjPTQ4ZTMscD00ZTMsXz0yMCxkPTYsaD00MDk2LG09MCx5PTQwMDIsdj0wLGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG4scil7dmFyIG89YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnZvaWQgMDtzKHRoaXMsdCksdGhpcy5jb25maWc9e2lucHV0U2FtcGxlUmF0ZTpuLGNoYW5uZWxDb3VudDpyfSx0aGlzLm1lbW9yeT1uZXcgaShlKSx0aGlzLl9vcHVzX2VuY29kZXJfY3JlYXRlPWUuX29wdXNfZW5jb2Rlcl9jcmVhdGUsdGhpcy5fb3B1c19lbmNvZGVyX2N0bD1lLl9vcHVzX2VuY29kZXJfY3RsLHRoaXMuX29wdXNfZW5jb2RlX2Zsb2F0PWUuX29wdXNfZW5jb2RlX2Zsb2F0LHRoaXMuX29wdXNfZW5jb2Rlcl9kZXN0cm95PWUuX29wdXNfZW5jb2Rlcl9kZXN0cm95LHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9pbml0PWUuX3NwZWV4X3Jlc2FtcGxlcl9pbml0LHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0LHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95PWUuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95LHRoaXMuX2NvbnRhaW5lcj1uZXcgZS5Db250YWluZXIsdGhpcy5fY29udGFpbmVyLmluaXQoYyxyLE1hdGguZmxvb3IoNDI5NDk2NzI5NSpNYXRoLnJhbmRvbSgpKSksdGhpcy5PcHVzSW5pdENvZGVjKGMscixvKSx0aGlzLlNwZWV4SW5pdFJlc2FtcGxlcihuLGMsciksdGhpcy5pbnB1dFNhbXBsZXNQZXJDaGFubmVsPW4qXy8xZTMsdGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsPWMqXy8xZTMsdGhpcy5pbnB1dEJ1ZmZlckluZGV4PTAsdGhpcy5tSW5wdXRCdWZmZXI9dGhpcy5tZW1vcnkubWFsbG9jRmxvYXQzMkJ1ZmZlcih0aGlzLmlucHV0U2FtcGxlc1BlckNoYW5uZWwqciksdGhpcy5tUmVzYW1wbGVkQnVmZmVyPXRoaXMubWVtb3J5Lm1hbGxvY0Zsb2F0MzJCdWZmZXIodGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsKnIpLHRoaXMubU91dHB1dEJ1ZmZlcj10aGlzLm1lbW9yeS5tYWxsb2NVaW50OEJ1ZmZlcihwKSx0aGlzLmludGVybGVhdmVkQnVmZmVycz0xIT09cj9uZXcgRmxvYXQzMkFycmF5KGgqcik6dm9pZCAwfXJldHVybiBmKHQsW3trZXk6ImVuY29kZSIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMuaW50ZXJsZWF2ZShlKSxuPTA7bjx0Lmxlbmd0aDspe3ZhciByPU1hdGgubWluKHRoaXMubUlucHV0QnVmZmVyLmxlbmd0aC10aGlzLmlucHV0QnVmZmVySW5kZXgsdC5sZW5ndGgtbik7aWYodGhpcy5tSW5wdXRCdWZmZXIuc2V0KHQuc3ViYXJyYXkobixuK3IpLHRoaXMuaW5wdXRCdWZmZXJJbmRleCksdGhpcy5pbnB1dEJ1ZmZlckluZGV4Kz1yLHRoaXMuaW5wdXRCdWZmZXJJbmRleD49dGhpcy5tSW5wdXRCdWZmZXIubGVuZ3RoKXt2YXIgbz10aGlzLm1lbW9yeS5tYWxsb2NVaW50MzIodGhpcy5pbnB1dFNhbXBsZXNQZXJDaGFubmVsKSxpPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWwpLHU9dGhpcy5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQodGhpcy5yZXNhbXBsZXIsdGhpcy5tSW5wdXRCdWZmZXIucG9pbnRlcixvLnBvaW50ZXIsdGhpcy5tUmVzYW1wbGVkQnVmZmVyLnBvaW50ZXIsaS5wb2ludGVyKTtpZihvLmZyZWUoKSxpLmZyZWUoKSx1IT09dil0aHJvdyBuZXcgRXJyb3IoIlJlc2FtcGxpbmcgZXJyb3IuIik7dmFyIGE9dGhpcy5fb3B1c19lbmNvZGVfZmxvYXQodGhpcy5lbmNvZGVyLHRoaXMubVJlc2FtcGxlZEJ1ZmZlci5wb2ludGVyLHRoaXMub3V0cHV0U2FtcGxlUGVyQ2hhbm5lbCx0aGlzLm1PdXRwdXRCdWZmZXIucG9pbnRlcix0aGlzLm1PdXRwdXRCdWZmZXIubGVuZ3RoKTtpZihhPDApdGhyb3cgbmV3IEVycm9yKCJPcHVzIGVuY29kaW5nIGVycm9yLiIpO3RoaXMuX2NvbnRhaW5lci53cml0ZUZyYW1lKHRoaXMubU91dHB1dEJ1ZmZlci5wb2ludGVyLGEsdGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsKSx0aGlzLmlucHV0QnVmZmVySW5kZXg9MH1uKz1yfX19LHtrZXk6ImNsb3NlIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmNvbmZpZy5jaGFubmVsQ291bnQsbj1bXSxyPTA7cjx0OysrciluLnB1c2gobmV3IEZsb2F0MzJBcnJheShoLXRoaXMuaW5wdXRCdWZmZXJJbmRleC90KSk7dGhpcy5lbmNvZGUobiksZS5kZXN0cm95KHRoaXMuX2NvbnRhaW5lciksdGhpcy5tSW5wdXRCdWZmZXIuZnJlZSgpLHRoaXMubVJlc2FtcGxlZEJ1ZmZlci5mcmVlKCksdGhpcy5tT3V0cHV0QnVmZmVyLmZyZWUoKSx0aGlzLl9vcHVzX2VuY29kZXJfZGVzdHJveSh0aGlzLmVuY29kZXIpLHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95KHRoaXMucmVzYW1wbGVyKX19LHtrZXk6ImludGVybGVhdmUiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoO2lmKDE9PT10KXJldHVybiBlWzBdO2Zvcih2YXIgbj0wO248dDtuKyspZm9yKHZhciByPWVbbl0sbz0wO288ci5sZW5ndGg7bysrKXRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzW28qdCtuXT1yW29dO3JldHVybiB0aGlzLmludGVybGVhdmVkQnVmZmVyc319LHtrZXk6Ik9wdXNJbml0Q29kZWMiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnZvaWQgMCxyPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih2b2lkIDApO3RoaXMuZW5jb2Rlcj10aGlzLl9vcHVzX2VuY29kZXJfY3JlYXRlKGUsdCx1LHIucG9pbnRlcik7dmFyIG89ci52YWx1ZTtpZihyLmZyZWUoKSxvIT09bSl0aHJvdyBuZXcgRXJyb3IoIk9wdXMgZW5jb2RvciBpbml0aWFsaXphdGlvbiBmYWlsZWQuIik7biYmdGhpcy5PcHVzU2V0T3B1c0NvbnRyb2woeSxuKX19LHtrZXk6Ik9wdXNTZXRPcHVzQ29udHJvbCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLm1lbW9yeS5tYWxsb2NJbnQzMih0KTt0aGlzLl9vcHVzX2VuY29kZXJfY3RsKHRoaXMuZW5jb2RlcixlLG4ucG9pbnRlciksbi5mcmVlKCl9fSx7a2V5OiJTcGVleEluaXRSZXNhbXBsZXIiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLm1lbW9yeS5tYWxsb2NVaW50MzIodm9pZCAwKTt0aGlzLnJlc2FtcGxlcj10aGlzLl9zcGVleF9yZXNhbXBsZXJfaW5pdChuLGUsdCxkLHIucG9pbnRlcik7dmFyIG89ci52YWx1ZTtpZihyLmZyZWUoKSxvIT09dil0aHJvdyBuZXcgRXJyb3IoIkluaXRpYWxpemluZyByZXNhbXBsZXIgZmFpbGVkLiIpfX1dKSx0fSgpO2UuaW5pdD1mdW5jdGlvbih0LG4scil7ZS5lbmNvZGVkQnVmZmVycz1bXSxlLmVuY29kZXI9bmV3IGIodCxuLHIpfSxlLmVuY29kZT1mdW5jdGlvbih0KXtlLmVuY29kZXIuZW5jb2RlKHQpfSxlLmZsdXNoPWZ1bmN0aW9uKCl7cmV0dXJuIGUuZW5jb2RlZEJ1ZmZlcnMuc3BsaWNlKDAsZS5lbmNvZGVkQnVmZmVycy5sZW5ndGgpfSxlLmNsb3NlPWZ1bmN0aW9uKCl7ZS5lbmNvZGVyLmNsb3NlKCl9O3ZhciBnLHc9e307Zm9yKGcgaW4gZSllLmhhc093blByb3BlcnR5KGcpJiYod1tnXT1lW2ddKTt2YXIgQT1bXSxDPSExLFM9ITEseD0hMSxQPSExO0M9Im9iamVjdCI9PT0oInVuZGVmaW5lZCI9PXR5cGVvZiB3aW5kb3c/InVuZGVmaW5lZCI6YSh3aW5kb3cpKSxTPSJmdW5jdGlvbiI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLHg9Im9iamVjdCI9PT0odm9pZCAwPT09cj8idW5kZWZpbmVkIjphKHIpKSYmIm9iamVjdCI9PT1hKHIudmVyc2lvbnMpJiYic3RyaW5nIj09dHlwZW9mIHIudmVyc2lvbnMubm9kZSxQPSFDJiYheCYmIVM7dmFyIEUsQixJLFIsTz0iIjtmdW5jdGlvbiBqKHQpe3JldHVybiBlLmxvY2F0ZUZpbGU/ZS5sb2NhdGVGaWxlKHQsTyk6Tyt0fXg/KE89Uz9uKDApLmRpcm5hbWUoTykrIi8iOm8rIi8iLEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gSXx8KEk9big0KSksUnx8KFI9bigwKSksZT1SLm5vcm1hbGl6ZShlKSxJLnJlYWRGaWxlU3luYyhlLHQ/bnVsbDoidXRmOCIpfSxCPWZ1bmN0aW9uKGUpe3ZhciB0PUUoZSwhMCk7cmV0dXJuIHQuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksVyh0LmJ1ZmZlciksdH0sci5hcmd2Lmxlbmd0aD4xJiZyLmFyZ3ZbMV0ucmVwbGFjZSgvXFwvZywiLyIpLEE9ci5hcmd2LnNsaWNlKDIpLHIub24oInVuY2F1Z2h0RXhjZXB0aW9uIiwoZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgV2UpKXRocm93IGV9KSksci5vbigidW5oYW5kbGVkUmVqZWN0aW9uIixfZSksZS5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdIn0pOlA/KCJ1bmRlZmluZWQiIT10eXBlb2YgcmVhZCYmKEU9ZnVuY3Rpb24oZSl7cmV0dXJuIHJlYWQoZSl9KSxCPWZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiByZWFkYnVmZmVyP25ldyBVaW50OEFycmF5KHJlYWRidWZmZXIoZSkpOihXKCJvYmplY3QiPT09YSh0PXJlYWQoZSwiYmluYXJ5IikpKSx0KX0sInVuZGVmaW5lZCIhPXR5cGVvZiBzY3JpcHRBcmdzP0E9c2NyaXB0QXJnczp2b2lkIDAhPT1hcmd1bWVudHMmJihBPWFyZ3VtZW50cyksInVuZGVmaW5lZCIhPXR5cGVvZiBwcmludCYmKCJ1bmRlZmluZWQiPT10eXBlb2YgY29uc29sZSYmKGNvbnNvbGU9e30pLGNvbnNvbGUubG9nPXByaW50LGNvbnNvbGUud2Fybj1jb25zb2xlLmVycm9yPSJ1bmRlZmluZWQiIT10eXBlb2YgcHJpbnRFcnI/cHJpbnRFcnI6cHJpbnQpKTooQ3x8UykmJihTP089c2VsZi5sb2NhdGlvbi5ocmVmOmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihPPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxsJiYoTz1sKSxPPTAhPT1PLmluZGV4T2YoImJsb2I6Iik/Ty5zdWJzdHIoMCxPLmxhc3RJbmRleE9mKCIvIikrMSk6IiIsRT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbigiR0VUIixlLCExKSx0LnNlbmQobnVsbCksdC5yZXNwb25zZVRleHR9LFMmJihCPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKCJHRVQiLGUsITEpLHQucmVzcG9uc2VUeXBlPSJhcnJheWJ1ZmZlciIsdC5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KHQucmVzcG9uc2UpfSkpO3ZhciBrLFUsVD1lLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLEY9ZS5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7Zm9yKGcgaW4gdyl3Lmhhc093blByb3BlcnR5KGcpJiYoZVtnXT13W2ddKTt3PW51bGwsZS5hcmd1bWVudHMmJihBPWUuYXJndW1lbnRzKSxlLnRoaXNQcm9ncmFtJiZlLnRoaXNQcm9ncmFtLGUucXVpdCYmZS5xdWl0LGUud2FzbUJpbmFyeSYmKGs9ZS53YXNtQmluYXJ5KSxlLm5vRXhpdFJ1bnRpbWUmJmUubm9FeGl0UnVudGltZSwib2JqZWN0IiE9PSgidW5kZWZpbmVkIj09dHlwZW9mIFdlYkFzc2VtYmx5PyJ1bmRlZmluZWQiOmEoV2ViQXNzZW1ibHkpKSYmRigibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCIpO3ZhciBIPW5ldyBXZWJBc3NlbWJseS5UYWJsZSh7aW5pdGlhbDozNixtYXhpbXVtOjM2LGVsZW1lbnQ6ImFueWZ1bmMifSksTT0hMTtmdW5jdGlvbiBXKGUsdCl7ZXx8X2UoIkFzc2VydGlvbiBmYWlsZWQ6ICIrdCl9dmFyIEQ9InVuZGVmaW5lZCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoInV0ZjgiKTp2b2lkIDA7ZnVuY3Rpb24geihlLHQsbil7Zm9yKHZhciByPXQrbixvPXQ7ZVtvXSYmIShvPj1yKTspKytvO2lmKG8tdD4xNiYmZS5zdWJhcnJheSYmRClyZXR1cm4gRC5kZWNvZGUoZS5zdWJhcnJheSh0LG8pKTtmb3IodmFyIGk9IiI7dDxvOyl7dmFyIHU9ZVt0KytdO2lmKDEyOCZ1KXt2YXIgYT02MyZlW3QrK107aWYoMTkyIT0oMjI0JnUpKXt2YXIgcz02MyZlW3QrK107aWYoKHU9MjI0PT0oMjQwJnUpPygxNSZ1KTw8MTJ8YTw8NnxzOig3JnUpPDwxOHxhPDwxMnxzPDw2fDYzJmVbdCsrXSk8NjU1MzYpaSs9U3RyaW5nLmZyb21DaGFyQ29kZSh1KTtlbHNle3ZhciBjPXUtNjU1MzY7aSs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjPj4xMCw1NjMyMHwxMDIzJmMpfX1lbHNlIGkrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJnUpPDw2fGEpfWVsc2UgaSs9U3RyaW5nLmZyb21DaGFyQ29kZSh1KX1yZXR1cm4gaX1mdW5jdGlvbiBMKGUsdCl7cmV0dXJuIGU/eihxLGUsdCk6IiJ9InVuZGVmaW5lZCIhPXR5cGVvZiBUZXh0RGVjb2RlciYmbmV3IFRleHREZWNvZGVyKCJ1dGYtMTZsZSIpO3ZhciBWLHEsTixHPTY1NTM2O2Z1bmN0aW9uIFgodCl7Vj10LGUuSEVBUDg9bmV3IEludDhBcnJheSh0KSxlLkhFQVAxNj1uZXcgSW50MTZBcnJheSh0KSxlLkhFQVAzMj1OPW5ldyBJbnQzMkFycmF5KHQpLGUuSEVBUFU4PXE9bmV3IFVpbnQ4QXJyYXkodCksZS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheSh0KSxlLkhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KHQpLGUuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KHQpLGUuSEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KHQpfXZhciBZPTUyODk3MjgsJD00NjY4OCxKPWUuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2Z1bmN0aW9uIEsodCl7Zm9yKDt0Lmxlbmd0aD4wOyl7dmFyIG49dC5zaGlmdCgpO2lmKCJmdW5jdGlvbiIhPXR5cGVvZiBuKXt2YXIgcj1uLmZ1bmM7Im51bWJlciI9PXR5cGVvZiByP3ZvaWQgMD09PW4uYXJnP2UuZHluQ2FsbF92KHIpOmUuZHluQ2FsbF92aShyLG4uYXJnKTpyKHZvaWQgMD09PW4uYXJnP251bGw6bi5hcmcpfWVsc2UgbigpfX0oVT1lLndhc21NZW1vcnk/ZS53YXNtTWVtb3J5Om5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6Si9HLG1heGltdW06Si9HfSkpJiYoVj1VLmJ1ZmZlciksSj1WLmJ5dGVMZW5ndGgsWChWKSxOWyQ+PjJdPVk7dmFyIFE9W10sWj1bXSxlZT1bXSx0ZT1bXTtmdW5jdGlvbiBuZSgpe2lmKGUucHJlUnVuKWZvcigiZnVuY3Rpb24iPT10eXBlb2YgZS5wcmVSdW4mJihlLnByZVJ1bj1bZS5wcmVSdW5dKTtlLnByZVJ1bi5sZW5ndGg7KXVlKGUucHJlUnVuLnNoaWZ0KCkpO0soUSl9ZnVuY3Rpb24gcmUoKXtLKFopfWZ1bmN0aW9uIG9lKCl7SyhlZSl9ZnVuY3Rpb24gaWUoKXtpZihlLnBvc3RSdW4pZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBlLnBvc3RSdW4mJihlLnBvc3RSdW49W2UucG9zdFJ1bl0pO2UucG9zdFJ1bi5sZW5ndGg7KWFlKGUucG9zdFJ1bi5zaGlmdCgpKTtLKHRlKX1mdW5jdGlvbiB1ZShlKXtRLnVuc2hpZnQoZSl9ZnVuY3Rpb24gYWUoZSl7dGUudW5zaGlmdChlKX12YXIgc2U9MCxjZT1udWxsLGZlPW51bGw7ZnVuY3Rpb24gbGUodCl7c2UrKyxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhzZSl9ZnVuY3Rpb24gcGUodCl7aWYoc2UtLSxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhzZSksMD09c2UmJihudWxsIT09Y2UmJihjbGVhckludGVydmFsKGNlKSxjZT1udWxsKSxmZSkpe3ZhciBuPWZlO2ZlPW51bGwsbigpfX1mdW5jdGlvbiBfZSh0KXt0aHJvdyBlLm9uQWJvcnQmJmUub25BYm9ydCh0KSxUKHQrPSIiKSxGKHQpLE09ITAsdD0iYWJvcnQoIit0KyIpLiBCdWlsZCB3aXRoIC1zIEFTU0VSVElPTlM9MSBmb3IgbW9yZSBpbmZvLiIsbmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih0KX1lLnByZWxvYWRlZEltYWdlcz17fSxlLnByZWxvYWRlZEF1ZGlvcz17fTt2YXIgZGU9ImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCwiO2Z1bmN0aW9uIGhlKGUpe3JldHVybiBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGg/ZS5zdGFydHNXaXRoKGRlKTowPT09ZS5pbmRleE9mKGRlKX12YXIgbWU9Ik9nZ09wdXNFbmNvZGVyLndhc20iO2Z1bmN0aW9uIHllKCl7dHJ5e2lmKGspcmV0dXJuIG5ldyBVaW50OEFycmF5KGspO2lmKEIpcmV0dXJuIEIobWUpO3Rocm93ImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkIn1jYXRjaChlKXtfZShlKX19ZnVuY3Rpb24gdmUoKXtyZXR1cm4ga3x8IUMmJiFTfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2g/bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7ZSh5ZSgpKX0pKTpmZXRjaChtZSx7Y3JlZGVudGlhbHM6InNhbWUtb3JpZ2luIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKCFlLm9rKXRocm93ImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJyIrbWUrIiciO3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIHllKCl9KSl9ZnVuY3Rpb24gYmUoKXt2YXIgdD17YTpSZX07ZnVuY3Rpb24gbih0LG4pe3ZhciByPXQuZXhwb3J0cztlLmFzbT1yLHBlKCl9ZnVuY3Rpb24gcihlKXtuKGUuaW5zdGFuY2UpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIHZlKCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsdCl9KSkudGhlbihlLChmdW5jdGlvbihlKXtGKCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAiK2UpLF9lKGUpfSkpfWlmKGxlKCksZS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBlLmluc3RhbnRpYXRlV2FzbSh0LG4pfWNhdGNoKGUpe3JldHVybiBGKCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAiK2UpLCExfXJldHVybiBmdW5jdGlvbigpe2lmKGt8fCJmdW5jdGlvbiIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8aGUobWUpfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2gpcmV0dXJuIG8ocik7ZmV0Y2gobWUse2NyZWRlbnRpYWxzOiJzYW1lLW9yaWdpbiJ9KS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZSx0KS50aGVuKHIsKGZ1bmN0aW9uKGUpe0YoIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAiK2UpLEYoImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uIiksbyhyKX0pKX0pKX0oKSx7fX1mdW5jdGlvbiBnZSh0LG4pe3ZhciByPW5ldyBVaW50OEFycmF5KGUuSEVBUFU4LmJ1ZmZlcix0LG4pO2UuZW5jb2RlZEJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShyKS5idWZmZXIpfWZ1bmN0aW9uIHdlKGUsdCxuLHIpe19lKCJBc3NlcnRpb24gZmFpbGVkOiAiK0woZSkrIiwgYXQ6ICIrW3Q/TCh0KToidW5rbm93biBmaWxlbmFtZSIsbixyP0wocik6InVua25vd24gZnVuY3Rpb24iXSl9ZnVuY3Rpb24gQWUoKXtfZSgpfWZ1bmN0aW9uIENlKGUsdCxuKXtxLmNvcHlXaXRoaW4oZSx0LHQrbil9ZnVuY3Rpb24gU2UoZSl7X2UoIk9PTSIpfWZ1bmN0aW9uIHhlKGUpe1NlKCl9aGUobWUpfHwobWU9aihtZSkpLFoucHVzaCh7ZnVuYzpmdW5jdGlvbigpe2tlKCl9fSk7dmFyIFBlPXttYXBwaW5nczp7fSxidWZmZXJzOltudWxsLFtdLFtdXSxwcmludENoYXI6ZnVuY3Rpb24oZSx0KXt2YXIgbj1QZS5idWZmZXJzW2VdOzA9PT10fHwxMD09PXQ/KCgxPT09ZT9UOkYpKHoobiwwKSksbi5sZW5ndGg9MCk6bi5wdXNoKHQpfSx2YXJhcmdzOnZvaWQgMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUGUudmFyYXJncys9NCxOW1BlLnZhcmFyZ3MtND4+Ml19LGdldFN0cjpmdW5jdGlvbihlKXtyZXR1cm4gTChlKX0sZ2V0NjQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZX19O2Z1bmN0aW9uIEVlKGUpe3JldHVybiAwfWZ1bmN0aW9uIEJlKGUsdCxuLHIsbyl7fWZ1bmN0aW9uIEllKGUsdCxuLHIpe2Zvcih2YXIgbz0wLGk9MDtpPG47aSsrKXtmb3IodmFyIHU9Tlt0KzgqaT4+Ml0sYT1OW3QrKDgqaSs0KT4+Ml0scz0wO3M8YTtzKyspUGUucHJpbnRDaGFyKGUscVt1K3NdKTtvKz1hfXJldHVybiBOW3I+PjJdPW8sMH12YXIgUmU9e2E6d2UsYzpBZSxkOmdlLGY6Q2UsZzp4ZSxoOkVlLGU6QmUsYjpJZSxtZW1vcnk6VSx0YWJsZTpIfSxPZT1iZSgpO2UuYXNtPU9lO3ZhciBqZSxrZT1lLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihrZT1lLl9fX3dhc21fY2FsbF9jdG9ycz1lLmFzbS5pKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFVlPShlLl9fX2VtX2pzX19lbXNjcmlwdGVuUHVzaEJ1ZmZlcj1mdW5jdGlvbigpe3JldHVybihlLl9fX2VtX2pzX19lbXNjcmlwdGVuUHVzaEJ1ZmZlcj1lLmFzbS5qKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX2Vtc2NyaXB0ZW5fYmluZF9Wb2lkUHRyX19fZGVzdHJveV9fXzA9ZnVuY3Rpb24oKXtyZXR1cm4oVWU9ZS5fZW1zY3JpcHRlbl9iaW5kX1ZvaWRQdHJfX19kZXN0cm95X19fMD1lLmFzbS5rKS5hcHBseShudWxsLGFyZ3VtZW50cyl9KSxUZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX0NvbnRhaW5lcl8wPWZ1bmN0aW9uKCl7cmV0dXJuKFRlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfQ29udGFpbmVyXzA9ZS5hc20ubCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxGZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX2luaXRfMz1mdW5jdGlvbigpe3JldHVybihGZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX2luaXRfMz1lLmFzbS5tKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfd3JpdGVGcmFtZV8zPWZ1bmN0aW9uKCl7cmV0dXJuKEhlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfd3JpdGVGcmFtZV8zPWUuYXNtLm4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTWU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9fX2Rlc3Ryb3lfX18wPWZ1bmN0aW9uKCl7cmV0dXJuKE1lPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfX19kZXN0cm95X19fMD1lLmFzbS5vKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIFdlKGUpe3RoaXMubmFtZT0iRXhpdFN0YXR1cyIsdGhpcy5tZXNzYWdlPSJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCIrZSsiKSIsdGhpcy5zdGF0dXM9ZX1mdW5jdGlvbiBEZSh0KXtmdW5jdGlvbiBuKCl7amV8fChqZT0hMCxlLmNhbGxlZFJ1bj0hMCxNfHwocmUoKSxvZSgpLGUub25SdW50aW1lSW5pdGlhbGl6ZWQmJmUub25SdW50aW1lSW5pdGlhbGl6ZWQoKSxpZSgpKSl9dD10fHxBLHNlPjB8fChuZSgpLHNlPjB8fChlLnNldFN0YXR1cz8oZS5zZXRTdGF0dXMoIlJ1bm5pbmcuLi4iKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS5zZXRTdGF0dXMoIiIpfSksMSksbigpfSksMSkpOm4oKSkpfWlmKGUuX29wdXNfZW5jb2Rlcl9jcmVhdGU9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fb3B1c19lbmNvZGVyX2NyZWF0ZT1lLmFzbS5wKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX29wdXNfZW5jb2RlX2Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX29wdXNfZW5jb2RlX2Zsb2F0PWUuYXNtLnEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fb3B1c19lbmNvZGVyX2N0bD1mdW5jdGlvbigpe3JldHVybihlLl9vcHVzX2VuY29kZXJfY3RsPWUuYXNtLnIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fb3B1c19lbmNvZGVyX2Rlc3Ryb3k9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fb3B1c19lbmNvZGVyX2Rlc3Ryb3k9ZS5hc20ucykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fbWFsbG9jPWUuYXNtLnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fZnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9mcmVlPWUuYXNtLnUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZS5hc20udikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1mdW5jdGlvbigpe3JldHVybihlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1lLmFzbS53KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWUuYXNtLngpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5keW5DYWxsX3ZpPWZ1bmN0aW9uKCl7cmV0dXJuKGUuZHluQ2FsbF92aT1lLmFzbS55KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuZHluQ2FsbF92PWZ1bmN0aW9uKCl7cmV0dXJuKGUuZHluQ2FsbF92PWUuYXNtLnopLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5hc209T2UsZS50aGVuPWZ1bmN0aW9uKHQpe2lmKGplKXQoZSk7ZWxzZXt2YXIgbj1lLm9uUnVudGltZUluaXRpYWxpemVkO2Uub25SdW50aW1lSW5pdGlhbGl6ZWQ9ZnVuY3Rpb24oKXtuJiZuKCksdChlKX19cmV0dXJuIGV9LGZlPWZ1bmN0aW9uIGUoKXtqZXx8RGUoKSxqZXx8KGZlPWUpfSxlLnJ1bj1EZSxlLnByZUluaXQpZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBlLnByZUluaXQmJihlLnByZUluaXQ9W2UucHJlSW5pdF0pO2UucHJlSW5pdC5sZW5ndGg+MDspZS5wcmVJbml0LnBvcCgpKCk7ZnVuY3Rpb24gemUoKXt9ZnVuY3Rpb24gTGUoZSl7cmV0dXJuKGV8fHplKS5fX2NhY2hlX199ZnVuY3Rpb24gVmUoZSx0KXt2YXIgbj1MZSh0KSxyPW5bZV07cmV0dXJuIHJ8fCgocj1PYmplY3QuY3JlYXRlKCh0fHx6ZSkucHJvdG90eXBlKSkucHRyPWUsbltlXT1yKX1mdW5jdGlvbiBxZShlLHQpe3JldHVybiBWZShlLnB0cix0KX1mdW5jdGlvbiBOZShlKXtpZighZS5fX2Rlc3Ryb3lfXyl0aHJvdyJFcnJvcjogQ2Fubm90IGRlc3Ryb3kgb2JqZWN0LiAoRGlkIHlvdSBjcmVhdGUgaXQgeW91cnNlbGY/KSI7ZS5fX2Rlc3Ryb3lfXygpLGRlbGV0ZSBMZShlLl9fY2xhc3NfXylbZS5wdHJdfWZ1bmN0aW9uIEdlKGUsdCl7cmV0dXJuIGUucHRyPT09dC5wdHJ9ZnVuY3Rpb24gWGUoZSl7cmV0dXJuIGUucHRyfWZ1bmN0aW9uIFllKGUpe3JldHVybiBlLl9fY2xhc3NfX31mdW5jdGlvbiAkZSgpe3Rocm93ImNhbm5vdCBjb25zdHJ1Y3QgYSBWb2lkUHRyLCBubyBjb25zdHJ1Y3RvciBpbiBJREwifWZ1bmN0aW9uIEplKCl7dGhpcy5wdHI9VGUoKSxMZShKZSlbdGhpcy5wdHJdPXRoaXN9cmV0dXJuIERlKCksemUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoemUucHJvdG90eXBlKSx6ZS5wcm90b3R5cGUuY29uc3RydWN0b3I9emUsemUucHJvdG90eXBlLl9fY2xhc3NfXz16ZSx6ZS5fX2NhY2hlX189e30sZS5XcmFwcGVyT2JqZWN0PXplLGUuZ2V0Q2FjaGU9TGUsZS53cmFwUG9pbnRlcj1WZSxlLmNhc3RPYmplY3Q9cWUsZS5OVUxMPVZlKDApLGUuZGVzdHJveT1OZSxlLmNvbXBhcmU9R2UsZS5nZXRQb2ludGVyPVhlLGUuZ2V0Q2xhc3M9WWUsJGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoemUucHJvdG90eXBlKSwkZS5wcm90b3R5cGUuY29uc3RydWN0b3I9JGUsJGUucHJvdG90eXBlLl9fY2xhc3NfXz0kZSwkZS5fX2NhY2hlX189e30sZS5Wb2lkUHRyPSRlLCRlLnByb3RvdHlwZS5fX2Rlc3Ryb3lfXz0kZS5wcm90b3R5cGUuX19kZXN0cm95X189ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnB0cjtVZShlKX0sSmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoemUucHJvdG90eXBlKSxKZS5wcm90b3R5cGUuY29uc3RydWN0b3I9SmUsSmUucHJvdG90eXBlLl9fY2xhc3NfXz1KZSxKZS5fX2NhY2hlX189e30sZS5Db250YWluZXI9SmUsSmUucHJvdG90eXBlLmluaXQ9SmUucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMucHRyO2UmJiJvYmplY3QiPT09YShlKSYmKGU9ZS5wdHIpLHQmJiJvYmplY3QiPT09YSh0KSYmKHQ9dC5wdHIpLG4mJiJvYmplY3QiPT09YShuKSYmKG49bi5wdHIpLEZlKHIsZSx0LG4pfSxKZS5wcm90b3R5cGUud3JpdGVGcmFtZT1KZS5wcm90b3R5cGUud3JpdGVGcmFtZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcy5wdHI7ZSYmIm9iamVjdCI9PT1hKGUpJiYoZT1lLnB0ciksdCYmIm9iamVjdCI9PT1hKHQpJiYodD10LnB0ciksbiYmIm9iamVjdCI9PT1hKG4pJiYobj1uLnB0ciksSGUocixlLHQsbil9LEplLnByb3RvdHlwZS5fX2Rlc3Ryb3lfXz1KZS5wcm90b3R5cGUuX19kZXN0cm95X189ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnB0cjtNZShlKX0sZX0pOyJvYmplY3QiPT09YSh0KSYmIm9iamVjdCI9PT1hKGkpP2kuZXhwb3J0cz1wOnZvaWQgMD09PSh1PWZ1bmN0aW9uKCl7cmV0dXJuIHB9LmFwcGx5KHQsW10pKXx8KGkuZXhwb3J0cz11KX0pLmNhbGwodGhpcywiL2luZGV4LmpzIixuKDIpLCIvIixuKDMpKGUpKX1dKTt9fSk7","base64")))
      },
      OggOpusEncoderWasmPath: tob(Buffer("AGFzbQEAAAABtwVDYAF/AX9gBH9/f38AYAN/f38AYAF/AGACf38Bf2AFf39/f38AYAJ/fwBgA39/fwF/YAZ/f39/f38AYAZ/f39/f38Bf2AFf39/f38Bf2AEf39/fwF/YAAAYAd/f39/f39/AGABfAF8YAh/f39/f39/fwBgC39/f39/f39/f39/AGAHf39/f39/fwF/YAR/f39/AX1gCX9/f39/f39/fwBgCn9/f39/f39/f38AYA9/f39/f39/f39/f39/f38AYAR/f31/AGAEf35+fwBgAAF/YAp/f39/f39/f39/AX9gC39/f39/f39/f39/AX9gBn98f39/fwF/YAJ+fwF/YAJ8fwF8YAJ8fAF8YAx/f39/f39/f39/f38AYBF/f39/f39/f39/f39/f39/fwBgFn9/f39/f39/f39/f39/f39/f39/f38AYBp/f39/f39/f39/f39/f39/f39/f39/f39/fwBgDH9/f39/fX1/f39/fwBgBH9/f30AYAN/f30AYAV/f31/fwBgCX9/fX1/f39/fwBgA399fwBgCX9/f39/f39/fwF/YAx/f39/f39/f39/f38Bf2ASf39/f39/f39/f39/f39/f39/AX9gD39/f39/f39/f39/f399fwF/YAp/f39/f39/f31/AX9gC39/f39/f39/fX9/AX9gCX9/f39/f399fwF/YAd/f39/f399AX9gCX9/f39/f31/fwF/YAt/f39/f399fX9/fwF/YAR/f39+AX9gA35/fwF/YAF9AX9gAn1/AX9gAnx/AX9gA39+fwF+YAN/f38BfWAJf39/f39/f39/AX1gE39/f39/f39/f39/f39/f39/f38BfWAGf39/f31/AX1gBn9/fX9/fwF9YAR9fX9/AX1gAn9/AXxgA39/fwF8YAJ+fgF8YAN8fH8BfAJMCgFhAWEAAQFhAWIACwFhAWMADAFhAWQABgFhAWUACgFhAWYABwFhAWcAAAFhAWgAAAFhBm1lbW9yeQIBgAKAAgFhBXRhYmxlAXAAJAPRAs8CBwEHBwMANQI/BQIHBwACLgAHAAsdHAADAAAJL0IeDgAAQAYGAgQFAwADBAUABh4MDgUFJQEAAQQACAIBAgAKAAATBhoNCAgHAAUBAg4OBQUBCwUHAAEEBAQDAgAdBAcIPgAnKgcKBwQ6AQAQAQIA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ACACRQ0AGiAEQQh1IgEgBEEBcUUNABogAigCACABaigCAAsgAmogA0ECIARBAnEbIAAoAgAoAhwRAQALHAAgABDFAiABBEAgACABEMICIAAgARC+AgsgAAsLACAAIAE2AgAgAAsjACAAQQA2AgwgACABNgIEIAAgATYCACAAIAFBAWo2AgggAAspAQF/IwBBEGsiASQAIAFBADYCDEGIGigCACIBIAAQugEgARCuARACAAujAgACQAJAIAFBFEsNACABQXdqIgFBCUsNAAJAAkACQAJAAkACQAJAAkAgAUEBaw4JAQIJAwQFBgkHAAsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgACACQQoRBgALDwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC0IBA38gACgCACwAABAhBEADQCAAKAIAIgIsAAAhAyAAIAJBAWo2AgAgAyABQQpsakFQaiEBIAIsAAEQIQ0ACwsgAQt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARBkIQAgASgCAEFAags2AgAgAA8LIAEgAkGCeGo2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLEgAgAEUEQEEADwsgACABEL4BC+4FAgp/AX4CQCAARQ0AIAAoAhwiB0H/ASAHQf8BSBsiA0UNACAAKAIAIghFDQACQAJAAkAgACgCzAIiCQRAIAdBAU4NAUJ/IQ1BACEDDAILIANBACADQQBKGyEDA0AgAyAFRg0CIAVBAnQhBiAFQQFqIgQhBSAGIAAoAhBqLQAAQf8BRg0ACyAEIQMMAQsgA0EBIANBAUobIQRCfyENQQAhAwJAA0AgBUGAIEwgBkEDTHJFBEBBASECDAILQQAhBiAAKAIQIANBAnRqLQAAIgpB/wFHBEAg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BUGBAiAFQYECSBshBkEBIARB6QdHDQEaIA1BwANqIAZBfmpBgAIQLEEBDAELIABBADYCwG5BACEGQQALIQUCfyASKAIAIgdB6AdGBEAgDSgC3AMhBCANKALUAyEIIA1BwANqEJYBIAggBGdqQWdqQQN1IgwMAQsgDUHAA2ogGCAGayIMECtBAAshCAJAAkAgBUUEQCASKAIAQegHRg0BCyANIA1BqARqNgLwASAOQabOACANQfABahALGiASKAIAQekHRw0AIA0gACgCZDYCuAMgDSAAKAJoNgK8AyANIA1BuANqNgLQASAOQazOACANQdABahALGgwBCyANQQA2AuABIA5BrM4AIA1B4AFqEAsaCyAUQQBHIAVxIgRBAUYEQCANQQA2AsABIA5Bms4AIA1BwAFqEAsaIA1BADYCsAEgDkGmHyANQbABahALGiANQX82AqABIA5Boh8gDUGgAWoQCxpBfSAOIBEgACgCkAFByAFtIAwgF2ogBkEAECJBAEgNARogDSANQegEajYCkAEgDkG/HyANQZABahALGiAOQbwfQQAQCxoLIA1BAEERIAdB6gdGGzYCgAEgDkGazgAgDUGAAWoQCxoCQCASKAIAIgdB6AdGDQAgByAAKAKsbiILRiALQQFIckUEQCAOQbwfQQAQCxogDiAJIAAoApABQZADbSANQbgDakECQQAQIhogDUEANgJwIA5Bks4AIA1B8ABqEAsaCyANKALUAyANKALcA2dqQWBqIAxBA3RKDQACQCAERQ0AIBIoAgBB6QdHDQAgACgClAFFDQAgDSAAKAKgASAAKAIkazYCYCAOQaIfIA1B4ABqEAsaCyANIAAoApQBNgJQIA5Bph8gDUHQAGoQCxpBfSAOIBEgAkEAIAwgDUHAA2oQIiIIQQBIDQEaIARFDQAgEigCAEHpB0cNACAAKAKUAUUNACAIIBdqIAwgF2ogBhATGiAGIAxqIQwLAkAgFCAFRXJFBEAgACgCkAEhBCAOQbwfQQAQCxogDUEANgJAIA5Bms4AIA1BQGsQCxogDUEANgIwIA5Bks4AIA1BMGoQCxogDUEANgIgIA5Bph8gDUEgahALGiANQX82AhAgDkGiHyANQRBqEAsaIARBkANtIQcgBEHIAW0hBCAAKAKobkHpB0YEQCANQcADaiAIECsgCCEMCyAOIBEgACgC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ABAUBEAgASACIAMQRA8LIAAoAgwhBCAAQRBqIgUgASACIAMQXQJAIARBAkgNACAFIARBA3RqIQQgAEEYaiEAA0AgACABIAIgAxBdIAEtADYNASAAQQhqIgAgBEkNAAsLCzEAIAAgASgCCEEAEBQEQCABIAIgAxBEDwsgACgCCCIAIAEgAiADIAAoAgAoAhwRAQALGAAgACABKAIIQQAQFARAIAEgAiADEEQLC6gCAQR/IwBBQGoiASQAIAAoAgAiAkF8aigCACEDIAJBeGooAgAhBCABQQA2AhQgAUH0GzYCECABIAA2AgwgAUGkHDYCCEEAIQIgAUEYakEAQScQChogACAEaiEAAkAgA0GkHEEAEBQEQCABQQE2AjggAyABQQhqIAAgAEEBQQAgAygCACgCFBEIACAAQQAgASgCIEEBRhshAgwBCyADIAFBCGogAEEBQQAgAygCACgCGBEFACABKAIsIgBBAUsNACAAQQFrBEAgASgCHEEAIAEoAihBAUYbQQAgASgCJEEBRhtBACABKAIwQQFGGyECDAELIAEoAiBBAUcEQCABKAIwDQEgASgCJEEBRw0BIAEoAihBAUcNAQsgASgCGCECCyABQUBrJAAgAgueAQEBfyMAQUBqIgMkAAJ/QQEgACABQQAQFA0AGkEAIAFFDQAaQQAgARCmASIBRQ0AGiADQX82AhQgAyAANgIQIANBADYCDCADIAE2AgggA0EYakEAQScQChogA0EBNgI4IAEgA0EIaiACKAIAQQEgASgCACgCHBEBAEEAIAMoAiBBAUcNABogAiADKAIYNgIAQQELIQAgA0FAayQAIAALSgECfwJAIAAtAAAiAkUgAiABLQAAIgNHcg0AA0AgAS0AASEDIAAtAAEiAkUNASABQQFqIQEgAEEBaiEAIAIgA0YNAAsLIAIgA2sLCABBmhsQYQALMgEBfyMAQRBrIgEkACABQQhqIAAoAgQQXygCAEEBOgAAIAAoAghBAToAACABQRBqJAALMwECfwJAIAAoAggiAC0AACICQQFHBH8gAkECcQ0BIABBAjoAAEEBBUEACw8LQeQaEGEACzUBAn8jAEEQayIBJAAgAUEIaiAAKAIEEF8oAgAtAABBAUcEQCAAEKsBIQILIAFBEGokACACC1ABA38jAEEQayIBJAAgAUE2EF4iAigCACIDEMoB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CyAAQSAgAiALIBEgCUEQamsgD2sgB2ogAyARaiAPa0ECaiADRSAHIAlrQW5qIANOchsiA2oiDCAEEBEgACANIAsQDyAAQTAgAiAMIARBgIAEcxARIAAgCUEQaiAHIAlBEGprIgUQDyAAQTAgAyAFIBEgD2siA2prQQBBABARIAAgDyADEA8LIABBICACIAwgBEGAwABzEBEgCUGwBGokACACIAwgDCACSBsLNAAgAFBFBEADQCABQX9qIgEgAKdBD3FB0BlqLQAAIAJyOgAAIABCBIgiAEIAUg0ACwsgAQstACAAUEUEQANAIAFBf2oiASAAp0EHcUEwcjoAACAAQgOIIgBCAFINAAsLIAELWQAgACABIAIgAxBxIABBEGogAxDGAQRAQagJQbQJQR5B0AkQAAALIABCADcDiAMgAEIANwKUAyAAQQE2ApADIABCADcCnAMgAEEANgKkAyAAELMBIAAQrQELyAIBBH8jAEHQAWsiAiQAIAJBADYCzAEgAkGgAWpBAEEoEAoaIAIgAigCzAE2AsgBAkBBACABIAJByAFqIAJB0ABqIAJBoAFqEEZBAEgNACAAKAJMQQBOBEBBASEECyAAKAIAIQMgACwASkEATARAIAAgA0FfcTYCAAsgA0EgcSEFAn8gACgCMARAIAAgASACQcgBaiACQdAAaiACQaABahBGDAELIABB0AA2AjAgACACQdAAajYCECAAIAI2AhwgACACNgIUIAAoAiwhAyAAIAI2AiwgACABIAJByAFqIAJB0ABqIAJBoAFqEEYgA0UNABogAEEAQQAgACgCJBEHABogAEEANgIwIAAgAzYCLCAAQQA2AhwgAEEANgIQIAAoAhQaIABBADYCFEEACxogACAAKAIAIAVyNgIAIARFDQALIAJB0AFqJAAL2QMCAn8CfiMAQSBrIgIkAAJAIAFC////////////AIMiBUKAgICAgIDA/0N8IAVCgICAgICAwIC8f3xUBEAgAUIEhiAAQjyIhCEEIABC//////////8PgyIAQoGAgICAgICACFoEQCAEQoGAgICAgICAwAB8IQQMAgsgBEKAgICAgICAgEB9IQQgAEKAgICAgICAgAiFQgBSDQEgBEIBgyAEfCEEDAELIABQIAVCgICAgICAwP//AFQgBUKAgICAgIDA//8AURtFBEAgAUIEhiAAQjyIhEL/////////A4NCgICAgICAgPz/AIQhBAwBC0KAgICAgICA+P8AIQQgBUL///////+//8MAVg0AQgAhBCAFQjCIpyIDQZH3AEkNACACQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiBCADQf+If2oQvQEgAiAAIARBgfgAIANrELwBIAIpAwhCBIYgAikDACIAQjyIhCEEIAIpAxAgAikDGIRCAFKtIABC//////////8Pg4QiAEKBgICAgICAgAhaBEAgBEIBfCEEDAELIABCgICAgICAgIAIhUIAUg0AIARCAYMgBHwhBAsgAkEgaiQAIAQgAUKAgICAgICAgIB/g4S/C1ABAX4CQCADQcAAcQRAIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC1ABAX4CQCADQcAAcQRAIAEgA0FAaq2GIQJCACEBDAELIANFDQAgAiADrSIEhiABQcAAIANrrYiEIQIgASAEhiEBCyAAIAE3AwAgACACNwMIC4sCAAJAIAAEfyABQf8ATQ0BAkBB4OECKAIAKAIARQRAIAFBgH9xQYC/A0YNAwwBCyABQf8PTQRAIAAgAUE/cUGAAXI6AAEgACABQQZ2QcABcjoAAEECDwsgAUGAsANPQQAgAUGAQHFBgMADRxtFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAw8LIAFBgIB8akH//z9NBEAgACABQT9xQYABcjoAAyAAIAFBEnZB8AFyOgAAIAAgAUEGdkE/cUGAAXI6AAIgACABQQx2QT9xQYABcjoAAUEEDwsLQfDjAkEZNgIAQX8FQQELDwsgACABOgAAQQELvAEBAX8gAUEARyECAkACQAJAAkAgAUUgAEEDcUVyDQADQCAALQAARQ0CIABBAWohACABQX9qIgFBAEchAiABRQ0BIABBA3ENAAsLIAJFDQELIAAtAABFDQECQCABQQRPBEADQCAAKAIAIgJBf3MgAkH//ft3anFBgIGChHhxDQIgAEEEaiEAIAFBfGoiAUEDSw0ACwsgAUUNAQsDQCAALQAARQ0CIABBAWohACABQX9qIgENAAsLQQAPCyAAC00BAn8CQCAARQ0AIAAo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BygCSBAMIAcoAkwQDCAHKAI8EAwgBygCRBAMIAcoAkAQDCAHEAxBACEHCyAGRQ0AIAYgADYCAAsgBwsTACAAIAEgAiABIAIgAyAEENYBC84BAQJ/IwBBEGsiASQAAkAgAL1CIIinQf////8HcSICQfvDpP8DTQRAIAJBgIDA8gNJDQEgAEQAAAAAAAAAAEEAECQhAAwBCyACQYCAwP8HTwRAIAAgAKEhAAwBCyAAIAEQeEEDcSICQQJNBEACQAJAAkAgAkEBaw4CAQIACyABKwMAIAErAwhBARAkIQAMAwsgASsDACABKwMIECUhAAwCCyABKwMAIAErAwhBARAkmiEADAELIAErAwAgASsDCBAlmiEACyABQRBqJAAgAAu6FwEDfyMAQeABayIDJAAgAyACNgLcASAAIAAoAgBqIQRBeyECAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQeBgaiIFQS9LBEAgAUHhsX9qIgVBC00NASABQYaqf2oiAUERSw0mAkACQAJAIAFBAWsOESkpKSkpKSkpKSkpKSkpKQABAgsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFqQeUASw0oIAAgATYCjAFBACECDCgLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwoCyABIAAoAowBNgIAQQAhAgwnCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUGYeGpBA08EQEF/IQIgAUGYeEcNJwsgACABNgKIAUEAIQIMJgsgBUEBaw4vIyIhHh0SERwbGBcWFRQTGhklJRAPIB8ODSUMAQslCiUlJSUJCCUlBwYFBCUlAwIkCwJAAkACQCAFQQFrDgsnJycnJycnJwInAQALIAMgAygC3AEiAEEEajYC3AEgACgCACIARQRAQX8hAgwnCyADIAA2AnAgBEGfzgAgA0HwAGoQCyECDCYLIAMgAygC3AEiAUEEajYC3AEgACABKAIAIgA2AshuIAMgADYCYCAEQarOACADQeAAahALIQIMJQsgAyADKALcASIBQQRqNgLcASAAIAEoAgAiADYCsAEgAyAANgJQIARBqM4AIANB0ABqEAshAgwkCyAAKAIEIQEg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BCACIApqIAxqQQF0ai4BAEEDdSIOIA5saiEDIAJBAWoiAiAFRw0ACyABIANqIgFB/////wcgAUH/////B0kbIQEgCEEDbCEIIAYoAgAhBkEAIQJBACEDA0AgAyAEIAIgCGogBmpBAXRqLgEAQQN1IgogCmxqIQMgAkEBaiICIAVHDQALCyALIAEgA0EBdmoiAUH/////ByABQf////8HSRs2AgAgDSADNgI4IAlBAWoiCUEERw0AC0EAIQUgACgCjAEiCUHnB0wEQEH//wEgCUEEdUEBam0hBQtB/////wcgBygCICIIIAAoAnxqIgFB/////wcgAUH/////B0kbIgRuIQNBgAEhASAAAn9BgAEgBCAAKAJcIgJBA3RKDQAaQYAIIAQgAkgNABogAkEQdEEQdSIEIANBEHZsIAMgAkEPdUEBakEBdWxqIANB//8DcSAEbEEQdWoiAkEQdUELdCACQQV2Qf8PcXILIgIgBSACIAVKG0EQdEEQdSICIAMgACgCbCIDayIEQRB1bCADaiACIARB//8DcWxBEHVqIgM2AmwgAEH/////ByADbSIDQf///wcgA0H///8HSBsiAzYCXEH/////ByAHKAIkIgogACgCgAFqIgJB/////wcgAkH/////B0kbIgZuIQICQCAGIAAoAmAiBEEDdEoNAEGACCEBIAYgBEgNACAEQRB0QRB1IgEgAkEQdmwgAiAEQQ91QQFqQQF1bGogAkH//wNxIAFsQRB1aiIBQRB1QQt0IAFBBXZB/w9xciEBCyAAIAEgBSABIAVKG0EQdEEQdSIBIAIgACgCcCICayIEQRB1bCACaiABIARB//8DcWxBEHVqIgE2AnAgAEH/////ByABbSIBQf///wcgAUH///8HSBs2AmBB/////wcgBygCKCIMIAAoAoQBaiIBQf////8HIAFB/////wdJGyIGbiECQYABIQEgAAJ/QYABIAYgACgCZCIEQQN0Sg0AGkGACCAGIARIDQAaIARBEHRBEHUiBiACQRB2bCACIARBD3VBAWpBAXVsaiACQf//A3EgBmxBEHVqIgRBEHVBC3QgBEEFdkH/D3FyCyIEIAUgBCAFShtBEHRBEHUiBCACIAAoAnQiAmsiBkEQdWwgAmogBCAGQf//A3FsQRB1aiICNgJ0IABB/////wcgAm0iAkH///8HIAJB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TW9kdWxlLkhFQVBVOC5idWZmZXIsIGJ1ZiwgbGVuKTsgTW9kdWxlLmVuY29kZWRCdWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYXJyYXkpLmJ1ZmZlcik7IH0AAAAAAIwFAAABAAAAAgAAAHJlc3VsdCA9PSAwAC9idWlsZC9zcmMvT2dnQ29udGFpbmVyLmNwcABpbml0AHJlc3VsdCAhPSAwAHByb2R1Y2VJRFBhZ2UAcHJvZHVjZUNvbW1lbnRQYWdlACFvZ2dfc3RyZWFtX2NoZWNrKCZzdHJlYW1fc3RhdGVfKQBwcm9kdWNlUGFja2V0UGFnZQAhKGRhdGEgPT0gbnVsbHB0ciAmJiBzaXplID4gMCkAd3JpdGVQYWNrZXQAIW9nZ19zdHJlYW1fZW9zKCZzdHJlYW1fc3RhdGVfKQA5Q29udGFpbmVyALwOAACBBQAAAAAAAAEAAADYBgAAAAAAAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAAAAAANgGAAAHAAAACAAAAHNhbXBsZV9yYXRlID09IDQ4MDAwAC9idWlsZC9zcmMvQ29udGFpbmVySW50ZXJmYWNlLmNwcABpbml0AGNoYW5uZWxfY291bnQgPiAwICYmIGNoYW5uZWxfY291bnQgPD0gMgBoZWFkZXIAd3JpdGVPcHVzSWRIZWFkZXIAT3B1c0hlYWQAd3JpdGVPcHVzQ29tbWVudEhlYWRlcgBPcHVzVGFncwBvcHVzLW1lZGlhLXJlY29yZGVyAFRJVExFPXJlY29yZGluZwAxOENvbnRhaW5lckludGVyZmFjZQAAOA4AAMIGAAAAAAAAtx3BBG47ggnZJkMN3HYEE2trxReyTYYaBVBHHrjtCCYP8Mki1taKL2HLSytkmww104bNMQqgjjy9vU84cNsRTMfG0Ege4JNFqf1SQaytFV8bsNRbwpaXVnWLVlLINhlqfyvYbqYNm2MREFpnFEAdeaNd3H16e59wzWZedOC2I5hXq+Kcjo2hkTmQYJU8wCeLi93mj1L7pYLl5mSGWFsrvu9G6ro2YKm3gX1os4QtL60zMO6p6hatpF0LbKCQbTLUJ3Dz0P5WsN1JS3HZTBs2x/sG98MiILTOlT11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ycm8vLCNQijBwcHBwcHBwcHBwcHCwsK4uK2LQSfMzMzMzMzMzMnJycnGxsa7u6+MQigAQcK7AQu5KWAAwAAgAYABIACAAOAAQAGgAUAAoAAAAWABwAEIAGgAyAAoAYgBKACIAOgASAGoAUgAqAAIAWgByAEQAHAA0AAwAZABMACQAPAAUAGwAVAAsAAQAXAB0AEYAHgA2AA4AZgBOACYAPgAWAG4AVgAuAAYAXgB2AEEAGQAxAAkAYQBJACEAOQARAGkAUQApAAEAWQBxAEMAGwAzAAsAYwBLACMAOwATAGsAUwArAAMAWwBzAEUAHQA1AA0AZQBNACUAPQAVAG0AVQAtAAUAXQB1AEcAHwA3AA8AZwBPACcAPwAXAG8AVwAvAAcAXwB3AEBAGEAwQAhAYEBIQCBAOEAQQGhAUEAoQABAWEBwQEJAGkAyQApAYkBKQCJAOkASQGpAUkAqQAJAWkByQERAHEA0QAxAZEBMQCRAPEAUQGxAVEAsQARAXEB0QEZAHkA2QA5AZkBOQCZAPkAWQG5AVkAuQAZAXkB2QEFAGUAxQAlAYUBJQCFAOUARQGlAUUApQAFAWUBxQENAG0AzQAtAY0BLQCNAO0ATQGtAU0ArQANAW0BzQEVAHUA1QA1AZUBNQCVAPUAVQG1AVUAtQAVAXUB1QEdAH0A3QA9AZ0BPQCdAP0AXQG9AV0AvQAdAX0B3QECAGIAwgAiAYIBIgCCAOIAQgGiAUIAogACAWIBwgEKAGoAygAqAYoBKgCKAOoASgGqAUoAqgAKAWoBygESAHIA0gAyAZIBMgCSAPIAUgGyAVIAsgASAXIB0gEaAHoA2gA6AZoBOgCaAPoAWgG6AVoAugAaAXoB2gEGAGYAxgAmAYYBJgCGAOYARgGmAUYApgAGAWYBxgEOAG4AzgAuAY4BLgCOAO4ATgGuAU4ArgAOAW4BzgEWAHYA1gA2AZYBNgCWAPYAVgG2AVYAtgAWAXYB1gEeAH4A3gA+AZ4BPgCeAP4AXgG+AV4AvgAeAX4B3gEDAGMAwwAjAYMBIwCDAOMAQwGjAUMAowADAWMBwwELAGsAywArAYsBKwCLAOsASwGrAUsAqwALAWsBywETAHMA0wAzAZMBMwCTAPMAUwGzAVMAswATAXMB0wEbAHsA2wA7AZsBOwCbAPsAWwG7AVsAuwAbAXsB2wEHAGcA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aAAQACgAQABYAHAABAAcADQATABkAAwAJAA8AFQAbAAUACwARABcAHQAAQAZADEASQBhAAkAIQA5AFEAaQARACkAQQBZAHEABQAdADUATQBlAA0AJQA9AFUAbQAVAC0ARQBdAHUAAgAaADIASgBiAAoAIgA6AFIAagASACoAQgBaAHIABgAeADYATgBmAA4AJgA+AFYAbgAWAC4ARgBeAHYAAwAbADMASwBjAAsAIwA7AFMAawATACsAQwBbAHMABwAfADcATwBnAA8AJwA/AFcAbwAXAC8ARwBfAHcAeAAAAIiICDwCAAAABQAYAAMACAACAAQABAABAEG85wELBqByAACAYQBB0ucBC40BDAAYACQAMAAEABAAHAAoADQACAAUACAALAA4AAEADQAZACUAMQAFABEAHQApADUACQAVACEALQA5AAIADgAaACYAMgAGABIAHgAqADYACgAWACIALgA6AAMADwAbACcAMwAHABMAHwArADcACwAXACMALwA7ADwAAACJiIg8AwAAAAUADAADAAQABAABAEH06AELLNBzAACAYQAAAAAAAAAAnT4AQF4+AMAEPgCA7T4AQIk+AAAAAADATD8AAM09AEGx6QELowH/AP8A/wD/AP8A/gEAAf8A/gD9AgAB/wD+AP0DAAH/lYsAADeYAAD/pQAABLUAAGfFAABF1wAAweoAAP//AAAAAM5AAADIQAAAuEAAAKpAAACiQAAAmkAAAJBAAACMQAAAnEAAAJZAAACSQAAAjkAAAJxAAACUQAAAikAAAJBAAACMQAAAlEAAAJhAAACOQAAAcEAAAHBAAABwQAAAcEAAAHBAAEHg6gEL8gJIf0GBQoBBgECAPoBAgECAXE5cT1xOWk90KXMociiEGoQakRGhDLAKsQsYszCKNoc2hDWGOIU3hDeEPXJGYEpYS1hXSllCW0NkO2wyeCh6JWErTjJTTlRRWEtWSldHWkldSl1KbShyJHUidSKPEZESkhOiDKUKsge9Br4IsQkXsjZzP2ZCYkVjSllHW0lbTllWUFxCXUBmO2c8aDx1NHssiiOFH2EmTS09Wl08aSprKW4tdCZxJnAmfBqEG4gTjBSbDp8QnhKqDbEKuwjABq8JnwoVsjtuR1ZLVVRTW0JYSVdIXEtiSGk6azZzNHI3cDiBM4QoliGMHWIjTSoqeWBCbCtv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","base64")),
      WebMOpusEncoderWasmPath: tob(Buffer("AGFzbQEAAAABngZTYAF/AX5gA39/fwF/YAF/AX9gBH9/f38AYAF/AGACf38Bf2ADf39/AGAFf39/f38AYAJ/fwBgAn9+AX9gBn9/f39/fwBgA39+fgBgBn9/f39/fwF/YAR/f39/AX9gBX9/f39/AX9gAABgB39/f39/f38AYAF8AXxgAn9/AX5gAAF/YAh/f39/f39/fwBgC39/f39/f39/f39/AGAHf39/f39/fwF/YAN/fn4Bf2AEf39/fwF9YAl/f39/f39/f38AYAp/f39/f39/f39/AGAPf39/f39/f39/f39/f39/AGAEf399fwBgBH9+fn8AYAp/f39/f39/f39/AX9gC39/f39/f39/f39/AX9gBn98f39/fwF/YAJ+fwF/YAN/f38BfmADf35/AX5gAn5+AX5gAnx/AXxgAnx8AXxgDH9/f39/f39/f39/fwBgEX9/f39/f39/f39/f39/f39/AGAWf39/f39/f39/f39/f39/f39/f39/fwBgGn9/f39/f39/f39/f39/f39/f39/f39/f39/AGAMf39/f399fX9/f39/AGAEf39/fQBgBX9/fn5+AGADf399AGAFf399f38AYAl/f319f39/f38AYAJ/fgBgA399fwBgCX9/f39/f39/fwF/YAx/f39/f39/f39/f38Bf2ASf39/f39/f39/f39/f39/f39/AX9gD39/f39/f39/f39/f399fwF/YAp/f39/f39/f31/AX9gC39/f39/f39/fX9/AX9gCX9/f39/f399fwF/YAd/f39/f399AX9gCX9/f39/f31/fwF/YAt/f39/f399fX9/fwF/YAN/fn8Bf2AEf35/fgF/YAR/fn5/AX9gA39+fQF/YAN+f38Bf2ABfQF/YAJ9fwF/YAJ8fwF/YAJ/fgF+YAJ+fwF+YAN+f34BfmACfn0BfmADf39/AX1gCX9/f39/f39/fwF9YBN/f39/f39/f39/f39/f39/f39/AX1gBn9/f399fwF9YAZ/f31/f38BfWAEfX1/fwF9YAJ/fwF8YAN/f38BfGACfn4BfGADfHx/AXwCag8BYQFhAAMBYQFiAA8BYQFjAAIBYQFkAA0BYQFlAAEBYQFmAA0BYQFnAAEBYQFoAAEBYQFpAAIBYQFqAA4BYQFrAAEBYQFsAAIBYQFtAAgBYQZtZW1vcnkC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NgI8DAULIAMgAygCDCIBQQRqNgIMIAEoAgAiAUH0A0wEQEF/IQIgAUF/Rw0GCyAAIAEgACgCBEGg7w9sIgAgASAASBs2AigMBAsgAyADKAIMIgFBBGo2AgwgACABKAIANgIsDAMLIAMgAygCDCIBQQRqNgIMIAAgASgCADYCNAwCCyADIAMoAgwiAUEEajYCDEF/IQIgASgCACIBQeQASw0CIAAgATYCOAwBCyADIAMoAgwiAUEEajYCDEF/IQIgASgCACIBQQpLDQEgACABNgIYC0EAIQILIANBEGokACACC4YEAgR/An4jAEEQayIFJAACQCAARQ0AIAAgASAAIAAoAgAoAgQRAAAgACgCACgCEBELAEEBIQMCQCABQoACVA0AQQIhAyABQoCABFQNAEEDIQMgAUKAgIAIVA0AQQQhAyABQoCAgIAQVA0AQQUhAyABQoCAgICAIFQNAEEGIQMgAUKAgICAgIDAAFQNAEEHQQggAUKAgICAgICAgAFUGyIDQX9qQQdLDQELIANBAWqtIQhCASEHAkADQAJAIAUgASADIAena0EDdK2HPAANIAAgBUENakEBIAAoAgAoAgARAQAiBCAGIARBAEgbIQYgBEF/TA0AIAggB0IBfCIHUg0BDAILC0EAIQQgBg0BCyAFAn9BASACQoACVA0AGkECIAJCgIAEVA0AGkEDIAJCgICACFQNABpBBCACQoCAgIAQVA0AGkEFIAJCgICAgIAgVA0AGkEGIAJCgICAgICAwABUDQAaQQdBCCACQoCAgICAgICAAVQbCyIDQYABcjoADkEAIQQgACAFQQ5qQQEgACgCACgCABEBAEEASA0AIANBAWqtIQFCASEHAkADQCAFIAIgAyAHp2tBA3SthzwADyAAIAVBD2pBASAAKAIAKAIAEQEAIgQgBiAEQQBIGyEGIARBf0wNASAHQgF8IgcgAVINAAtBACEGCyAGRSEECyAFQRBqJAAgBAvfAQEBfkIBIQICfkIBIABCgAJUDQAaQgIgAEKAgARUDQAaQgMgAEKAgIAIVA0AGkIEIABCgICAgBBUDQAaQgUgAEKAgICAgCBUDQAaQgYgAEKAgICAgIDAAFQNABpCB0IIIABCgICAgICAgIABVBsLIQACQCABQv8AVA0AQgIhAiABQv//AFQNAEIDIQIgAUL///8AVA0AQgQhAiABQv////8AVA0AQgUhAiABQv//////AFQNAEIGIQIgAUL///////8AVA0AQgdCCCABQv////////8AVBshAgsgACACfAv6AwIEfwJ+IwBBEGsiBiQAAkAgAEUNACAAIAEgACAAKAIAKAIEEQAAIAAoAgAoAhARCwBBASEDAkAgAUKAAlQNAEECIQMgAUKAgARUDQBBAyEDIAFCgICACFQNAEEEIQMgAUKAgICAEFQNAEEFIQMgAUKAgICAgCBUDQBBBiEDIAFCgICAgICAwABUDQBBB0EIIAFCgICAgICAgIABVBsiA0F/akEHSw0BCyADQQFqrSEIQgEhBwJAA0ACQCAGIAEgAyAHp2tBA3SthzwADiAAIAZBDmpBASAAKAIAKAIAEQEAIgQgBSAEQQBIGyEFIARBf0wNACAIIAdCAXwiB1INAQwCCwtBACEEIAUNAQtBfyEFAkBCAQJ/QQEgAkL/AFQNABpBAiACQv//AFQNABpBAyACQv///wBUDQAaQQQgAkL/////AFQNABpBBSACQv//////AFQNABpBBiACQv///////wBUDQAaQQdBCCACQv////////8AVBsLIgNBB2ythiIBQn58IAJUDQAgASAChCEBIANBAWqtIQJCASEHA0AgBiABIAMgB6drQQN0rYc8AA8gACAGQQ9qQQEgACgCACgCABEBACIEIAUgBEEASBshBSAEQX9MDQEgB0IBfCIHIAJSDQALQQAhBQsgBUUhBAsgBkEQaiQAIAQLZQECfwJAQRggAGciAWsiAkUNACAAQf8ATQRAIAAgAUFoanQgAEE4IAFrdnIhAAwBCyAAIAFBCGp0IAAgAnZyIQALIABB/wBxIgAgAUEHdGsgAEGAASAAa2xBswFsQRB2akGAH2oLMAECfyAAQQEgABshAANAAkAgABApIgENAEH83gIoAgAiAkUNACACEQ8ADAELCyABCxsAIACQIgCLQwAAAE9dBEAgAKgPC0GAgICAeAt4ACABRQRAQgAPCwJ+QgIgAEKAAlQNABpCAyAAQoCABFQNABpCBCAAQoCAgAhUDQAaQgUgAEKAgICAEFQNABpCBiAAQoCAgICAIFQNABpCByAAQoCAgICAgMAAVA0AGkIIQgkgAEKAgICAgICAgAFUGwsgARAirXwLFwAgAC0AAEEgcUUEQCABIAIgABDq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CxgBAX8gABApIgEEQCABQQAgABARGgsgAQtJAQJ/IAAoAgQiBUEIdSEGIAAoAgAiACABIAVBAXEEfyACKAIAIAZqKAIABSAGCyACaiADQQIgBUECcRsgBCAAKAIAKAIYEQcACxYAIABFBEBBAA8LQfDeAiAANgIAQX8LmwQCBH8CfiMAQRBrIgYkAAJAIANQIABFIAJFcnINACAAIAEgACAAKAIAKAIEEQAAIAAoAgAoAhARCwBBASEFAkAgAUKAAlQNAEECIQUgAUKAgARUDQBBAyEFIAFCgICACFQNAEEEIQUgAUKAgICAEFQNAEEFIQUgAUKAgICAgCBUDQBBBiEFIAFCgICAgICAwABUDQBBB0EIIAFCgICAgICAgIABVBsiBUF/akEHSw0BCyAFQQFqrSEJQgEhCAJAA0ACQCAGIAEgBSAIp2tBA3SthzwADiAAIAZBDmpBASAAKAIAKAIAEQEAIgQgByAEQQBIGyEHIARBf0wNACAJIAhCAXwiCFINAQwCCwtBACEEIAcNAQtBACEEQgECf0EBIANC/wBUDQAaQQIgA0L//wBUDQAaQQMgA0L///8AVA0AGkEEIANC/////wBUDQAaQQUgA0L//////wBUDQAaQQYgA0L///////8AVA0AGkEHQQggA0L/////////AFQbCyIFQQdsrYYiAUJ+fCADVA0AIAEgA4QhASAFQQFqrSEJQgEhCAJAA0ACQCAGIAEgBSAIp2tBA3SthzwADyAAIAZBD2pBASAAKAIAKAIAEQEAIgQgByAEQQBIGyEHIARBf0wNACAJIAhCAXwiCFINAQwCCwtBACEEIAcNAQsgACACIAOnIAAoAgAoAgARAQBFIQQLIAZBEGokACAEC/QDAgV/An4jAEEQayIEJAACQCAARQ0AIAAgASAAIAAoAgAoAgQRAAAgACgCACgCEBELAEEBIQUCQCABQoACVA0AQQIhBSABQoCABFQNAEEDIQUgAUKAgIAIVA0AQQQhBSABQoCAgIAQVA0AQQUhBSABQoCAgICAIFQNAEEGIQUgAUKAgICAgIDAAFQNAEEHQQggAUKAgICAgICAgAFUGyIFQX9qQQdLDQELIAVBAWqtIQlCASEIAkADQAJAIAQgASAFIAina0EDdK2HPAANIAAgBEENakEBIAAoAgAoAgARAQAiAyAGIANBAEgb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CyAAQSAgDCAGIAlrIgogCCAIIApIGyIOaiIGIAsgCyAGSBsiASAGIAcQHSAAIA8gDBAaIABBMCABIAYgB0GAgARzEB0gAEEwIA4gCkEAEB0gACAJIAoQGiAAQSAgASAGIAdBgMAAcxAdDAELC0EAIQwMAQtBfyEMCyAFQdAAaiQAIAwLaQECfwJAIAAoAhQgACgCHE0NACAAQQBBACAAKAIkEQEAGiAAKAIUDQBBfw8LIAAoAgQiASAAKAIIIgJJBEAgACABIAJrrEEBIAAoAigRIwAaCyAAQQA2AhwgAEIANwMQIABCADcCBEEAC54FAgR/Bn4jAEEQayIDJAACQCAARQ0AAn5CASABQn98IgZC/wBUDQAaQgIgBkL//wBUDQAaQgMgBkL///8AVA0AGkIEIAZC/////wBUDQAaQgUgBkL//////wBUDQAaQgYgBkL///////8AVA0AGkIHQgggBkL/////////AFQbCyEHAn5CAiAGIAd9IgZC/wBUDQAaQgMgBkL//wBUDQAaQgQgBkL///8AVA0AGkIFIAZC/////wBUDQAaQgYgBkL//////wBUDQAaQgcgBkL///////8AVA0AGkIIQgkgBkL/////////AFQbCyAGfCABUg0AIAAgACgCACgCBBEAACIJQgBTDQAgAELsASAAIAAoAgAoAgQRAAAgACgCACgCEBELACADQewBOgAOQQEhAiAAIANBDmpBASAAKAIAKAIAEQEAQQBIDQACQCAGQv8AVA0AQQIhAiAGQv//AFQNAEEDIQIgBkL///8AVA0AQQQhAiAGQv////8AVA0AQQUhAiAGQv//////AFQNAEEGIQIgBkL///////8AVA0AQQdBCCAGQv////////8AVBshAgtCASACQQdsrYYiB0J+fCAGVA0AIAYgB4QhCiACQQFqrSELQgEhBwJAA0ACQCADIAogAiAHp2tBA3SthzwADyAAIANBD2pBASAAKAIAKAIAEQEAIgQgBSAEQQBIGyEFIARBf0wNACALIAdCAXwiB1INAQwCCwsgBQ0BC0EAIQIgA0EAOgANAkAgBqciBEEATA0AA0AgACADQQ1qQQEgACgCACgCABEBAEUEQCACQQFqIgIgBEgNAQwCCwsMAQsgAUIAIAEgACAAKAIAKAIEEQAAIgEgCX1RG0IAIAFCf1UbIQgL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AkACQAJAAkACQAJAAkAgAUEBaw4JAQIJAwQFBgkHAAsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgACACQSARCAALDwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC0IBA38gACgCACwAABA6BEADQCAAKAIAIgIsAAAhAyAAIAJBAWo2AgAgAyABQQpsakFQaiEBIAIsAAEQOg0ACwsgAQsDAAELdgEBfyAABEAgACgCTEF/TARAIAAQag8LIAAQag8LQaDeAigCAARAQaDeAigCABDBASEBC0Gs3gIoAgAiAARAA0AgACgCTEEATgR/QQEFQQALGiAAKAIUIAAoAhxLBEAgABBqIAFyIQELIAAoAjgiAA0ACwsgAQsmAQF/IwBBEGsiBCQAIAQgAzYCDCAAIAEgAiADEJcDIARBEGokAAsoAQF/AkAgAUUNACAAKAIEDQAgACABEI8DIgA2AgQgAEEARyECCyACC2UAIAAQKkEEdEGA/gNxIAAQKkEEdkH/AXFyQRB0IAAQKkEEdEGA/gNxciAAECpBBHZB/wFxcq1CEIYgABAqQQR0QYD+A3GthCAAECpBBHZB/wFxrYRCCIYgABAqQQR2Qf8Bca2EC9wTAgR/C34jAEEQayIDJAACQCAARSABRXINACACRSABEK4CIgRFcg0AIAIpAygiB1ANAEJ/IAEpAzggB4AgAikDIH0iByAHQv//AVYbIhBC//8BVg0AAn8CQCABKAIIDQAgASkDQEIAUg0AIAEpAxhQIQULIAULBEAgAEKjASAAIAAoAgAoAgQRAAAgACgCACgCEBELACADQaMBOgALQQEhAiAAIANBC2pBASAAKAIAKAIAEQEAQQBIDQECQCABKQMoQiCGQoCAgIBAfUIghyIIQv8AVA0AQQIhAiAIQv//AFQNAEEDIQIgCEL///8AVA0AQQQhAiAIQv////8AVA0AQQVBCCAIQv//////AFQbIQILQgEgAkEHbK2GIgdCfnwgCFQNASAHIAiEIQkgAkEBaq0hCkIBIQcCQANAAkAgAyAJIAIgB6drQQN0rYc8AAwgACADQQxqQQEgACgCACgCABEBACIFIAQgBUEASBshBCAFQX9MDQAgCiAHQgF8IgdSDQEMAgsLIAQNAgtCAQJ/QQEgASkDMCIHQv8AVA0AGkECIAdC//8AVA0AGkEDIAdC////AFQNABpBBCAHQv////8AVA0AGkEFIAdC//////8AVA0AGkEGIAdC////////AFQNABpBB0EIIAdC/////////wBUGwsiAkEHbK2GIglCfnwgB1QNASAHIAmEIQkgAkEBaq0hCkIBIQcCQANAAkAgAyAJIAIgB6drQQN0rYc8AA0gACADQQ1qQQEgACgCACgCABEBACIFIAQgBUEASBshBCAFQX9MDQAgCiAHQgF8IgdSDQEMAgsLIAQNAgsgAyAQQgiIPAAOIAAgA0EOakEBIAAoAgAoAgARAQAiBEEASA0BIAMgEDwADiAAIANBDmpBASAAKAIAKAIAEQEAIgJBf0xBACACIAQgAkEASBsbDQEgAyABLQAkQQBHQQd0OgAPIAAgA0EPakEBIAAoAgAoAgARAQBBAEgNASAAIAEoAiAgASgCKCAAKAIAKAIAEQEADQECfkIGIAhC/wBUDQAaQgcgCEL//wBUDQAaQgggCEL///8AVA0AGkIJIAhC/////wBUDQAaQgogCEL//////wBUDQAaQgsgCEL///////8AVA0AGkIMQg0gCEL/////////AFQbCyABKQMofCENDAELIAIpAyghDSABKAIIBEBCASEHAn5CASABKQMQIglC/wBUDQAaQgIgCUL//wBUDQAaQgMgCUL///8AVA0AGkIEIAlC/////wBUDQAaQgUgCUL//////wBUDQAaQgYgCUL///////8AVA0AGkIHQgggCUL/////////AFQbCyEKAkAgASkDACIIQoACVA0AQgIhByAIQoCABFQNAEIDIQcgCEKAgIAIVA0AQgQhByAIQoCAgIAQVA0AQgUhByAIQoCAgICAIFQNAEIGIQcgCEKAgICAgIDAAFQNAEIHQgggCEKAgICAgICAgAFUGyEHC0IBIQgCfkIBIAkgCnwgB3xCA3wiCUL/AFQNABpCAiAJQv//AFQNABpCAyAJQv///wBUDQAaQgQgCUL/////AFQNABpCBSAJQv//////AFQNABpCBiAJQv///////wBUDQAaQgdCCCAJQv////////8AVBsLIQcCQCAHIAl8QgF8IgpC/wBUDQBCAiEIIApC//8AVA0AQgMhCCAKQv///wBUDQBCBCEIIApC/////wBUDQBCBSEIIApC//////8AVA0AQgYhCCAKQv///////wBUDQBCB0IIIApC/////////wBUGyEICyAIIAp8QgJ8IQgLIAEpA0AiB1BFBEACfkIBIAdCP4cgB4VCAYYiB0KAAlQNABpCAiAHQoCABFQNABpCAyAHQoCAgAhUDQAaQgQgB0KAgICAEFQNABpCBSAHQoCAgICAIFQNABpCBiAHQoCAgICAgMAAVA0AGkIHQgggB0KAgICAgICAgAFUGwtCA3whEQsgASkDSCANgCELIAEtACRFBEACfkIBIAtCgAJUDQAaQgIgC0KAgARUDQAaQgMgC0KAgIAIVA0AGkIEIAtCgICAgBBUDQAaQgUgC0KAgICAgCBUDQAaQgYgC0KAgICAgIDAAFQNABpCB0IIIAtCgICAgICAgIABVBsLQgJ8IQ8LIAEpAxgiByANgCEMIAcgDVQiBkUEQAJ+QgEgDEKAAlQNABpCAiAMQoCABFQNABpCAyAMQoCAgAhUDQAaQgQgDEKAgICAEFQNABpCBSAMQoCAgICAIFQNABpCBiAMQoCAgICAgMAAVA0AGkIHQgggDEKAgICAgICAgAFUGwtCAnwhDgtCACENIABCoAECfkIBIAEpAyhCBHwiB0L/AFQNABpCAiAHQv//AFQNABpCAyAHQv///wBUDQAaQgQgB0L/////AFQNABpCBSAHQv//////AFQNABpCBiAHQv///////wBUDQAaQgdCCCAHQv////////8AVBsLIAggEXwgD3wgDnwgB3x8QgF8IggQFUUNACAAQqEBIAcQFUUNAEIBAn9BASABKQMwIgdC/wBUDQAaQQIgB0L//wBUDQAaQQMgB0L///8AVA0AGkEEIAdC/////wBUDQAaQQUgB0L//////wBUDQAaQQYgB0L///////8AVA0AGkEHQQggB0L/////////AFQbCyICQQdsrYYiDkJ+fCAHVA0AIAcgDoQhDiACQQFqrSEPQgEhBwJAA0ACQCADIA4gAiAHp2tBA3SthzwACiAAIANBCmpBASAAKAIAKAIAEQEAIgUgBCAFQQBIGyEEIAVBf0wNACAPIAdCAXwiB1INAQwCCwsgBA0BCyADIBBCCIg8AAkgACADQQlqQQEgACgCACgCABEBACIEQQBIDQAgAyAQPAAJIAAgA0EJakEBIAAoAgAoAgARAQAiAkF/TEEAIAIgBCACQQBIGxsNACADQQA6AAggACADQQhqQQEgACgCACgCABEBAEEASA0AIAAgASgCICABKAIoIAAoAgAoAgARAQANACABKAIIBEAgAEKh6wEgChAVRQ0BIABCpgEgCRAVRQ0BIABC7gEgASkDABATRQ0BIABCpQEgASgCCCABKQMQEEhFDQELIAEpA0AiB1BFBEAgACAHEMcBRQ0BCyABLQAkRQRAIABC+wEgCxATRQ0BCyAGRQRAIABCmwEgDBATRQ0BCwJ+QgIgCEL/AFQNABpCAyAIQv//AFQNABpCBCAIQv///wBUDQAaQgUgCEL/////AFQNABpCBiAIQv//////AFQNABpCByAIQv///////wBUDQAaQghCCSAIQv////////8AVBsLIAh8IQ0LIANBEGokACANC5QEAgR/AX4jAEEQayIDJAACQCAARQ0AIABC4YgBIAAgACgCACgCBBEAACAAKAIAKAIQEQsAQgEhBgJAA0ACQCADQuGIAUECIAana0EDdK2HPAANIAAgA0ENakEBIAAoAgAoAgARAQAiBCACIARBAEgbIQIgBEF/TA0AIAZCAXwiBkIDUg0BDAILCyACDQELIANBiAE6AA4gACADQQ5qQQEgACgCACgCABEBAEEASA0AIAMgAUI4iDwADwJAIAAgA0EPakEBIAAoAgAoAgARAQAiBEEASA0AIAMgAUIwiDwADyAAIANBD2pBASAAKAIAKAIAEQEAIgIgBCACQQBIGyEEIAJBf0wNACADIAFCKIg8AA8gACADQQ9qQQEgACgCACgCABEBACICIAQgAkEASCICGyEEIAINACADIAFCIIg8AA8gACADQQ9qQQEgACgCACgCABEBACICIAQgAkEASCICGyEEIAINACADIAFCGIg8AA8gACADQQ9qQQEgACgCACgCABEBACICIAQgAkEASCICGyEEIAINACADIAFCEIg8AA8gACADQQ9qQQEgACgCACgCABEB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BEH/////A3EgBEcbEBciAwR/An8CQAJAQTgQFyIBBEAgAUIANwMwIAFCATcDKCABQgE3AyAgAUIBNwMYIAFCADcDECABQQA2AgggAUIFNwMAIAAoAlghAiAFRQ0BA0AgAyAGQQJ0IgdqIAIgB2ooAgA2AgAgBkEBaiIGIAVHDQALDAILIAMQDkEADwsgAg0AQQAMAQsgAhAOIAAoAlwLIQIgACADNgJYIAMgAkECdGogATYCACAAIAQ2AlxBAQVBAAsLzwEBAn8jAEEQayIBJAACQCAAvUIgiKdB/////wdxIgJB+8Ok/wNNBEAgAkGAgMDyA0kNASAARAAAAAAAAAAAQQAQMiEADAELIAJBgIDA/wdPBEAgACAAoSEADAELIAAgARCEAUEDcSICQQJNBEACQAJAAkAgAkEBaw4CAQIACyABKwMAIAErAwhBARAyIQAMAwsgASsDACABKwMIEDMhAAwCCyABKwMAIAErAwhBARAymiEADAELIAErAwAgASsDCBAzmiEACyABQRBqJAAgAAu6FwEDfyMAQeABayIDJAAgAyACNgLcASAAIAAoAgBqIQRBeyECAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQeBgaiIFQS9LBEAgAUHhsX9qIgVBC00NASABQYaqf2oiAUERSw0mAkACQAJAIAFBAWsOESkpKSkpKSkpKSkpKSkpKQABAgsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFqQeUASw0oIAAgATYCjAFBACECDCgLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwoCyABIAAoAowBNgIAQQAhAgwnCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUGYeGpBA08EQEF/IQIgAUGYeEcNJwsgACABNgKIAUEAIQIMJgsgBUEBaw4vIyIhHh0SERwbGBcWFRQTGhklJRAPIB8ODSUMAQslCiUlJSUJCCUlBwYFBCUlAwIkCwJAAkACQCAFQQFrDgsnJycnJycnJwInAQALIAMgAygC3AEiAEEEajYC3AEgACgCACIARQRAQX8hAgwnCyADIAA2AnAgBEGfzgAgA0HwAGoQEiECDCYLIAMgAygC3AEiAUEEajYC3AEgACABKAIAIgA2AshuIAMgADYCYCAEQarOACADQeAAahASIQIMJQsgAyADKALcASIBQQRqNgLcASAAIAEoAgAiADYCsAEgAyAANgJQIARBqM4AIANB0ABqEBIhAgwkCyAAKAIEIQEgAEG8AWoiAkEMakEAQcDsABARGiACQs2Zs+7jzJmzPzcCwEBBACECIABBiO4AakEAQeweEBEaIARBvB9BABASGiAAIAFqIAAoArQBIANB+ABqEFcaIABBATYCxG4gAEGAgID8AzYClG4gAEGAgAE7AYxuIABB0Qg2ArhuIABB6Qc2AqhuIAAgACgCcDYCiG4gAEE8EBZBCHQ2ApBuDCMLIAMgAygC3AEiAEEEajYC3AEgACgCACIARQRAQX8hAgwjCyADIAA2AkAgBEHPHyADQUBrEBIaQQAhAgwiCyADIAMoAtwBIgBBBGo2AtwBQX8hAiAAKAIAIgBBAUsNISADIAA2AjAgBEHOHyADQTBqEBIaQQAhAgwhCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMIQsgASAAKAJMNgIAQQAhAgwgCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFBAUsNHyAAIAE2AkxBACECDB8LIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwfCyABIAAoApwBNgIAQQAhAgweCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFB+FhqQQlLDR0gACABNgKcASADIAE2AiAgBEHIHyADQSBqEBIaQQAhAgwdCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMHQsgASAAKAKoATYCAEEAIQIMHAsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQXhqQRBLDRsgACABNgKoAUEAIQIMGwsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDBsLIAEgACgC8IwBNgIAQQAhAgwaCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMGgsgASAAKAKQATYCAEEAIQIMGQsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDBkLIAEgACgCkAFBkANtIgQ2AgBBACECIAAoAmxBgxBGDRggASAAKAJ0IARqNgIADBgLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwYCyABIAAoAnw2AgBBACECDBcLIAMgAygC3AEiAUEEajYC3AEgASgCACIBQcdoakECTwRAQX8hAiABQZh4Rw0XCyAAIAE2AnxBACECDBYLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwWCyABIAAoApgBNgIAQQAhAgwVCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFBAUsNFCAAIAE2ApgBQQAhAgwUCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMFAsgASAAKAKUATYCAEEAIQIMEwsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFLDRIgACABNgKUASAAQQEgAWs2AjxBACECDBILIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwSCyABIAAoAig2AgBBACECDBELIAMgAygC3AEiAUEEajYC3AFBfyECIAEoAgAiAUHkAEsNECAAIAE2AiggAyABNgIQIARBrh8gA0EQahASGkEAIQIMEAsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDBALIAEgACgCMDYCAEEAIQIMDwsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFLDQ4gACABNgIwQQAhAgwOCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMDgsgASAAKAIsNgIAQQAhAgwNCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFBCksNDCAAIAE2AiwgAyABNgIAIARBqh8gAxASGkEAIQIMDAsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDAwLIAEgACgCuAE2AgBBACECDAsLIAMgAygC3AEiAUEEajYC3AFBfyECIAEoAgAiAUEBSw0KIAAgATYCuAFBACECDAoLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwKCyABIAAoArhuNgIAQQAhAgwJCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUGzd2pBBU8EQEF/IQIgAUGYeEcNCQsgACABNgKAASABQc0IRgRAIABBwD42AhRBACECDAkLIAFBzghGBEAg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IApqQQF0ai4BAEEDdSIMIAxsaiEDIAJBAWoiAiAFRw0ACyABIANqIgFB/////wcgAUH/////B0kbIQEgCEEBdCEKIAYoAgAhDEEAIQJBACEDA0AgAyAEIAIgCmogDGpBAXRqLgEAQQN1Ig4gDmxqIQMgAkEBaiICIAVHDQALIAEgA2oiAUH/////ByABQf////8HSRshASAIQQNsIQggBigCACEGQQAhAkEAIQMDQCADIAQgAiAIaiAGakEBdGouAQBBA3UiCiAKbGohAyACQQFqIgIgBUcNAAsLIAsgASADQQF2aiIBQf////8HIAFB/////wdJGzYCACANIAM2AjggCUEBaiIJQQRHDQALQQAhBSAAKAKMASIJQecHTARAQf//ASAJQQR1QQFqbSEFC0H/////ByAHKAIgIgggACgCfGoiAUH/////ByABQf////8HSRsiBG4hA0GAASEBIAACf0GAASAEIAAoAlwiAkEDdEoNABpBgAggBCACSA0AGiACQRB0QRB1IgQgA0EQdmwgAyACQQ91QQFqQQF1bGogA0H//wNxIARsQRB1aiICQRB1QQt0IAJBBXZB/w9xcgsiAiAFIAIgBUobQRB0QRB1IgIgAyAAKAJsIgNrIgRBEHVsIANqIAIgBEH//wNxbEEQdWoiAzYCbCAAQf////8HIANtIgNB////ByADQf///wdIGyIDNgJcQf////8HIAcoAiQiCiAAKAKAAWoiAkH/////ByACQf////8HSRsiBm4hAgJAIAYgACgCYCIEQQN0Sg0AQYAIIQEgBiAESA0AIARBEHRBEHUiASACQRB2bCACIARBD3VBAWpBAXVsaiACQf//A3EgAWxBEHVqIgFBEHVBC3QgAUEFdkH/D3FyIQELIAAgASAFIAEgBUobQRB0QRB1IgEgAiAAKAJwIgJrIgRBEHVsIAJqIAEgBEH//wNxbEEQdWoiATYCcCAAQf////8HIAFtIgFB////ByABQf///wdIGzYCYEH/////ByAHKAIoIgwgACgChAFqIgFB/////wcgAUH/////B0kbIgZuIQJBgAEhASAAAn9BgAEgBiAAKAJkIgRBA3RKDQAaQYAIIAYgBEgNABogBEEQdEEQdSIGIAJBEHZsIAIgBEEPdUEBakEBdWxqIAJB//8DcSAGbEEQdWoiBEEQdUELdCAE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GkEAIAFFDQAaQQAgARD6AiIBRQ0AGiADQX82AhQgAyAANgIQIANBADYCDCADIAE2AgggA0EYakEAQScQERogA0EBNgI4IAEgA0EIaiACKAIAQQEgASgCACgCHBEDAEEAIAMoAiBBAUcNABogAiADKAIYNgIAQQELIQAgA0FAayQAIAALCQBB7xUQtwEACzMBAX8jAEEQayIBJAAgAUEIaiAAKAIEELUBKAIAQQE6AAAgACgCCEEBOgAAIAFBEGokAAs0AQJ/AkAgACgCCCIALQAAIgJBAUcEfyACQQJxDQEgAEECOgAAQQEFQQALDwtBuRUQtwEACzYBAn8jAEEQayIBJAAgAUEIaiAAKAIEELUBKAIALQAAQQFHBEAgABD+AiECCyABQRBqJAAgAgt6AQF/IAAoAkxBAEgEQAJAIAAsAEtBCkYNACAAKAIUIgEgACgCEE8NACAAIAFBAWo2AhQgAUEKOgAADwsgABCuAQ8LAkACQCAALABLQQpGDQAgACgCFCIBIAAoAhBPDQAgACABQQFqNgIUIAFBCjoAAAwBCyAAEK4BCwskACAAQQtPBH8gAEEQakFwcSIAIABBf2oiACAAQQtGGwVBCgsLnAEBA38jAEEQayICJABBbyAATwRAAkAgAEEKTQRAQZveAiAAOgAAQZDeAiEBDAELQX8gABCBA0EBaiIDIgFJBEAQuQEAC0GQ3gIgARAXIgE2AgBBmN4CIANBgICAgHhyNgIAQZTeAiAANgIACyAABEAgAUH5DCAAEA0aCyACQQA6AA8gACABaiACLQAPOgAAIAJBEGokAA8LELkBAAvZAwICfwJ+IwBBIGsiAiQAAkAgAUL///////////8AgyIFQoCAgICAgMD/Q3wgBUKAgICAgIDAgLx/fFQEQCABQgSGIABCPIiEIQQgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhBAwCCyAEQoCAgICAgICAQH0hBCAAQoCAgICAgICACIVCAFINASAEQgGDIAR8IQQMAQsgAFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCABQgSGIABCPIiEQv////////8Dg0KAgICAgICA/P8AhCEEDAELQoCAgICAgID4/wAhBCAFQv///////7//wwBWDQBCACEEIAVCMIin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","base64"))
    };

    audio.broadcastencoder = new MediaRecorder(audio.broadcaststream.stream, {audioBitsPerSecond:40000, mimeType:mime}, workerOptions)
    audio.callencoder = new MediaRecorder(audio.callstream.stream, {audioBitsPerSecond:40000, mimeType:mime}, workerOptions)

    audio.broadcastencoder.addEventListener('dataavailable', e => {
      btob(e.data, (err, buf) => {
      if(app.session.broadcasting) app._log(buf.length)
        //bufr.push(new Uint8Array(buf))
    //    app.audio.decoder.decode(buf)     
        app.network.broadcast(buf)
        //strSrc.write(buf)
      })

    })

    audio.callencoder.addEventListener('dataavailable', e => {
      btob(e.data, (err, buf) => {
        //bufr.push(new Uint8Array(buf))
        app.audio.decoder.decode(buf)     
        //app.network.send(buf)
        //strSrc.write(buf)
      })
    })

    
    audio.broadcastencoder.start(1000)

    autorun(()=>{
      if(app.update) {
        audio[app.update[0]].gain.value = Math.max(0, app.update[1])//.monitor
      } 
    })

    app._log(`mediaRecorder added? ${(!!audio.broadcastencoder)}`)

    app.audio = audio
    master.resume()
    cb(null, app)
  }

  function initUI(app, cb){

    ui.livelink.innerText = 'https://gabr.vercel.app?stream='+app.session.stream
    ui.copybutton.onchange = e => {
      navigator.clipboard.writeText(ui.link.innerText)
    }
    ui.request.addEventListener('change', e => {
      app.network.initCall(app.session.stream)
    })
    ui.file.addEventListener('change', e => {
      console.log(e.target.files[0])
      var a = h('audio.invert', {controls: true, src : URL.createObjectURL(e.target.files[0])})
      ui.tracks.appendChild(a)
      var c= app.audio.master.createMediaElementSource(a)
      console.log(a)
      c.connect(app.audio.trackmixer)
      btob(e.target.files[0], (err, buf) => {
        sampler(app.audio.master, buf.buffer, (err, node) =>{
          //node.connect(app.audio.master.destination)
          //node.start(0)
        })      
      })
    })

    ;[].forEach.call(document.querySelectorAll('input[type=range]'), e => {
      e.addEventListener('input', ev => {
        bus.emit('appStateChange', [ev.target.name, Number(ev.target.value)])
      })
    })

    ;[].forEach.call(document.querySelectorAll('[data-mute]'), e => {
      e.addEventListener('change', ev => {
        bus.emit('appStateChange', [ev.target.dataset.mute, - app[ev.target.dataset.mute]])
      })
    })


    ui.monitorRange.addEventListener('change', e => {
      console.log(e.target.value)
      //bus.emit('appStateChange', ['monitor', Number(e.target.value)])
      //app.setGain('monitor', Number(e.target.value))
    })

    cb(null,app)

  }


  function initCast(app){
  
    return function(cb){
      app._log('stateInit')
      cb(null, app)
    
    }
  }
  function captureNetwork(app, cb) {
    var network = new Network(app, argv.protocol + '://' + argv.host + ':' + argv.port)
    app._log('netCap')
    app.network = network

    cb(null, app)
  }

  function captureSource (app, cb) {
    // TODO source is either the mediastream or a peer connection
    
    if(true || app.session.broadcasting){
      addMedia((err, stream) =>{
        app._log(`mediaStream added? ${(!!stream)}`)
        app._log(`mediaStream error? ${(err)}`)

        console.log(err)
        console.log(stream)

        const mic = app.audio.master.createMediaStreamSource(stream) 
        mic.connect(app.audio.mic)

        app.audio.mediastream = stream
        app.audio.micnode = mic
    
        /*
        var bufr = []
        app.audio.buffer = bufr
        const strSrc = thru((b, r, cb)=>{
            console.log('source', b)
          cb(null, b)
        },e=>{
          console.log(e)
        } )
        app.audio.sourceStream = strSrc
        */
        // do same for host monitoring:
        //for(var smith in phonebook) mediaStream.pipe(phonebook[smith]) 
        //ui.monitor.srcObject = stream// = URL.createObjectURL(stream)      
        // Delete the encoder when finished with it (Emscripten does not automatically call C++ object destructors)
        //encoder.delete();
       app._log('sourceCap')
        cb(err, app)
        
      
      })
    }




  }

  function captureSink(app, cb){
    var {OggOpusDecoder} = require('ogg-opus-decoder')

    async function wsm(log){
    
      const decoder = new OggOpusDecoder({onDecode, onDecodeAll})

      function onDecode () {
      }

      function onDecodeAll ({channelData, samplesDecoded, sampleRate}) {
        //console.log(channelData)
        let sam = sampler(app.audio.master, channelData)
        sam.connect(app.audio.master.destination)
        sam.start(0)
      }

      await decoder.ready

      /*
      const sinkStream = thru((buf, enc, cb) => {
        console.log('sink', buf)
        decoder.decode(buf)
        cb()
      }, e =>{
        console.log(e)
      
      })

      var sinkState = {
        sink: sinkStream,
      }
      */
      bus.on("sourcePeerCaptured", id => {
        let peer = app.network.connections[id]
        peer.on('data', buf => {
          app._log(buf.length)
          try{
            decoder.ready.then(() => decoder.decode(buf))
          } catch(err){
            app._log(err.toString())
            decoder.ready.then(()=>decoder.free())
          }
        })
      })

      log()
      app.audio.decoder = decoder
      //app.audio.sinkStream = sinkStream
      app._log('sinkCap')
      cb(null, app)
      
    }


    wsm(function(){console.log('WASM')})

  }



  function tob(buf, type="application/wasm"){
    return URL.createObjectURL(new Blob([new Buffer(buf).buffer], {type}))
  }
   
  var peers = {}

  //ui.addMic.onclick = e => addMedia()

  function mute(torf){
    micStream.getAudioTracks()[0].enabled = torf
  }


  var connecting = {}
  function initBroadcast(){
    // source cap then broadcast
    session.broadcastId = short().generate()
    sessios.distance = 0
    session.maxConnections = 20
    session.offersOut = 0
    // be seekable when..
    seekable(session)
    return session
  }



  class Network { 

    constructor(app, addr){
      const self = this
      //console.log(state, addr)
      this.app = app
      this.hub = signalhub(addr, app.session.stream)
      this.channel = app.session.stream
      this.id = app.session.id
      this.state = app.state
      this.connections = {}
      this.hubs = {} 
      this.peers = {}
      this.callers = {}
      this.connecting = {}
      this.distance = 1
      this.offersOut = 0
      this.maxConnections = 4 // start low, test high, also helps spread early pcast testing
      this.duration = null // since-when
      this.channels = {}
      this.duration = new Time
      this.sinkStream = thru(buf => {
        for(var n in this.peers){
          let p = this.peers[n]
          if(p.writable) p.write(buf)
        }
      }, function close(){})
    }

    broadcast(buf){
      for(var n in this.peers) this.peers[n].write(buf)
    }

    send(buf){
      for(var n in this.callers) this.callers[n].write(buf)
    }

    log(){
      console.log.apply(this, arguments)
    }

    closePeerSignal(addr){
      this.hub.unsubscribe(addr)
      //delete this.connections[addr]
    }

    disallowCalls(id){
      this.hub.unsubscribe('caller:'+id)
    }

    allowCalls(id){
      let calls = this.hub.subscribe('caller:'+id)
      calls.on('data', msg=>{
        msg=JSON.parse(msg)
        bus.emit('caller', msg)
      })
      bus.on('call', msg =>{
        this.callDirect(msg.peerId)
      })

    }

    initCall(id){
      
      this.hub.broadcast('caller:'+id, {peerId: this.id})
      let peer = this.initConnect(id, false, this.id)
      peer.once('connected', e =>{
        this.callers[id] = peer
        bus.emit('Call Source Captured', peer)

      })
      
      
    }

    callDirect(id){
      let peer = this.initConnect(id, true, this.id)
      peer.once('connected', e =>{
        this.callers[id] = peer
        bus.emit('Call Source Captured', peer)

      })
    }

    sourceSeek(){ // id for a peer stream
      var self = this 
      let mask = short().generate()
      let offerings = this.hub.subscribe(mask)
      var best = 0//Infinity
      var chosen
      var start = new Time
      offerings.on('data', offer => {
        offer = JSON.parse(offer)
        self.app._log(offer)
        let score = (1 / offer.distance) * offer.duration
        if(score > best) {
          best = score //offer.distance
          chosen = offer
        }
      console.log(chosen)
      })
      let t0 = setTimeout(e => {
      console.log(chosen)
        if(chosen) {
    //      this.hub.unsubscribe(mask)
          // do chosen
          bus.emit('sourcePeerIdCaptured', chosen.peerId)
          //self.sourceCap(chosen)
          let peer = this.initConnect(chosen.peerId, true, mask)
          peer.once('connect', e => {
            bus.emit('sourcePeerCaptured', chosen.peerId)
            this.distance = chosen.distance + 1
            this.sourceStream = peer
            self.app._log('Source Peer Captured.')

          })
          peer.on('close', e => {
            self.app._log('Source Peer Closed')

          })
        } else {
          self.app._log('Err: No source peer found.')    
        }
      }, 13000)
      

      this.hub.broadcast('source', 
        JSON.stringify({
          peerId: mask
        })
      )
      
    }

    set sourceStream(stream){
      this._sourceStream = stream
      this.duration = new Time()
      //stream.pipe(this.sinkStream)
      //stream.pipe(app.audio.sinkStream)
    }

    get sourceStream(){
      return this._sourceStream
    }

    unseekable(session){
      if(sesion) this.hub.unsubscribe(session)
    }

    isSeekWorthy(){
      let r = this.offersOut < this.maxConnections
      let s = this.maxConnections > Object.keys(this.connections).length  
      let q = r && s 
      this._seekable = q
      if(q) {
        this.sourcer = this.hub.subscribe('source')
        this.sourcer.on('data', msg => this.seekable(JSON.parse(msg)))
      }
      else {
        if(this.sourcer) this.sourcer.close()
        
      }
      return this._seekable
    }

    setsub(id){
      if(this.hubs[id]) return this.hubs[id]
      else this.hubs[id] = this.hub.subscribe(id)
    }
    getsub(id){
      return this.hubs[id]
    }

    unsub(id){
      if(this.hubs[id]) {
        this.hub.unsubscribe(id) 
        delete this.hubs[id] 
      }
    }

    seekable(msg){ 
    this.app._log(msg)
      let self = this
      if(false) return // || Math.random() < 1 / Math.pow(self.distance, 2)) return
      else{
        self.offersOut += 1
        setTimeout(e=>{
          this.offersOut--
          //this.disnit(msg.peerId, mask)
        }, 1111*3)
        let mask = short().generate()
        let peer = this.initConnect(msg.peerId, false, mask)
        peer.once('connect', e =>{
          self.peers[msg.peerId] = peer
        })
        peer.once('close', e =>{
          delete self.peers[msg.peerId]
          self.isSeekWorthy()
        })
        this.hub.broadcast(msg.peerId, JSON.stringify({
          peerId: mask,
          to: msg.peerId,
          distance: this.distance,
          duration: this.duration.sinceBeginNS()
        }))
      }
    }

    disnit(id, mask){
      //delete this.connecting[id]
      //this.hub.unsubscribe(mask)
    }

    initConnect(id, init, mask){
      var self = this
      let pipe = this.hub.subscribe(mask)
      var caller = new Peer({initiator: init, trickle: false, objectMode: false})
      this.connecting[id] = caller
      pipe.on('error', e => console.log.apply(this, arguments))
      pipe.on('data', function(data){
        data = JSON.parse(data)
        // callerID
        var peer = self.connecting[data.peerId]
        peer.signal(data.signal)
        peer.once('connect', e => {
          // close mask hub
        })
        //ui.callers.appendChild(h('div.caller', h('button.connect', `Connect to ${data.name || from}`, {onclick: _connect})))  
      })
      caller._debug = console.log
      caller.on('signal', sig => this.hub.broadcast(id, JSON.stringify({peerId: mask, to: id, signal: sig })))
      caller.once('connect', e => {
        this.connections[id] = caller
        this.connecting[id] = null
        console.log(`connected to ${Object.keys(this.connections).length} peers`)
      })
      caller.on('close', e => {
        this.disnit(id, mask)
      })
      caller.on('error', e => console.log(e))
      return caller
    }

  }

  function addMedia(cb, audio=true, video=false){
    var gam = require('getusermedia')
    // Web worker and .wasm configuration. Note: This is NOT a part of W3C standard.
    gam({video, audio}, function(err, stream){
      //console.log(stream.getAudioTracks())


      cb(err, stream)
    })
   }    
})


}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

},{"../jsynth-file-sample":1,"../jsynth-mic/stream":2,"../since-when":113,"./sharedEmitter":112,"_process":136,"blob-to-buffer":6,"buffer":117,"domready":13,"getids":17,"getusermedia":18,"hyperscript":19,"minimist":22,"mobx":23,"nanohref":28,"ogg-opus-decoder":29,"opus-media-recorder":30,"querystring":139,"run-waterfall":49,"short-uuid":52,"signalhub":53,"simple-peer":63,"store":64,"through2":84,"to-arraybuffer":85}],4:[function(require,module,exports){
var Converter = require('./src/converter');

/**
 * Function get source and destination alphabet and return convert function
 *
 * @param {string|Array} srcAlphabet
 * @param {string|Array} dstAlphabet
 *
 * @returns {function(number|Array)}
 */
function anyBase(srcAlphabet, dstAlphabet) {
    var converter = new Converter(srcAlphabet, dstAlphabet);
    /**
     * Convert function
     *
     * @param {string|Array} number
     *
     * @return {string|Array} number
     */
    return function (number) {
        return converter.convert(number);
    }
};

anyBase.BIN = '01';
anyBase.OCT = '01234567';
anyBase.DEC = '0123456789';
anyBase.HEX = '0123456789abcdef';

module.exports = anyBase;
},{"./src/converter":5}],5:[function(require,module,exports){
'use strict';

/**
 * Converter
 *
 * @param {string|Array} srcAlphabet
 * @param {string|Array} dstAlphabet
 * @constructor
 */
function Converter(srcAlphabet, dstAlphabet) {
    if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
        throw new Error('Bad alphabet');
    }
    this.srcAlphabet = srcAlphabet;
    this.dstAlphabet = dstAlphabet;
}

/**
 * Convert number from source alphabet to destination alphabet
 *
 * @param {string|Array} number - number represented as a string or array of points
 *
 * @returns {string|Array}
 */
Converter.prototype.convert = function(number) {
    var i, divide, newlen,
    numberMap = {},
    fromBase = this.srcAlphabet.length,
    toBase = this.dstAlphabet.length,
    length = number.length,
    result = typeof number === 'string' ? '' : [];

    if (!this.isValid(number)) {
        throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ')');
    }

    if (this.srcAlphabet === this.dstAlphabet) {
        return number;
    }

    for (i = 0; i < length; i++) {
        numberMap[i] = this.srcAlphabet.indexOf(number[i]);
    }
    do {
        divide = 0;
        newlen = 0;
        for (i = 0; i < length; i++) {
            divide = divide * fromBase + numberMap[i];
            if (divide >= toBase) {
                numberMap[newlen++] = parseInt(divide / toBase, 10);
                divide = divide % toBase;
            } else if (newlen > 0) {
                numberMap[newlen++] = 0;
            }
        }
        length = newlen;
        result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
    } while (newlen !== 0);

    return result;
};

/**
 * Valid number with source alphabet
 *
 * @param {number} number
 *
 * @returns {boolean}
 */
Converter.prototype.isValid = function(number) {
    var i = 0;
    for (; i < number.length; ++i) {
        if (this.srcAlphabet.indexOf(number[i]) === -1) {
            return false;
        }
    }
    return true;
};

module.exports = Converter;
},{}],6:[function(require,module,exports){
(function (Buffer){(function (){
/*! blob-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* global Blob, FileReader */

module.exports = function blobToBuffer (blob, cb) {
  if (typeof Blob === 'undefined' || !(blob instanceof Blob)) {
    throw new Error('first argument must be a Blob')
  }
  if (typeof cb !== 'function') {
    throw new Error('second argument must be a function')
  }

  const reader = new FileReader()

  function onLoadEnd (e) {
    reader.removeEventListener('loadend', onLoadEnd, false)
    if (e.error) cb(e.error)
    else cb(null, Buffer.from(reader.result))
  }

  reader.addEventListener('loadend', onLoadEnd, false)
  reader.readAsArrayBuffer(blob)
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":117}],7:[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],8:[function(require,module,exports){
// contains, add, remove, toggle
var indexof = require('indexof')

module.exports = ClassList

function ClassList(elem) {
    var cl = elem.classList

    if (cl) {
        return cl
    }

    var classList = {
        add: add
        , remove: remove
        , contains: contains
        , toggle: toggle
        , toString: $toString
        , length: 0
        , item: item
    }

    return classList

    function add(token) {
        var list = getTokens()
        if (indexof(list, token) > -1) {
            return
        }
        list.push(token)
        setTokens(list)
    }

    function remove(token) {
        var list = getTokens()
            , index = indexof(list, token)

        if (index === -1) {
            return
        }

        list.splice(index, 1)
        setTokens(list)
    }

    function contains(token) {
        return indexof(getTokens(), token) > -1
    }

    function toggle(token) {
        if (contains(token)) {
            remove(token)
            return false
        } else {
            add(token)
            return true
        }
    }

    function $toString() {
        return elem.className
    }

    function item(index) {
        var tokens = getTokens()
        return tokens[index] || null
    }

    function getTokens() {
        var className = elem.className

        return filter(className.split(" "), isTruthy)
    }

    function setTokens(list) {
        var length = list.length

        elem.className = list.join(" ")
        classList.length = length

        for (var i = 0; i < list.length; i++) {
            classList[i] = list[i]
        }

        delete list[length]
    }
}

function filter (arr, fn) {
    var ret = []
    for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i])) ret.push(arr[i])
    }
    return ret
}

function isTruthy(value) {
    return !!value
}

},{"indexof":20}],9:[function(require,module,exports){
(function (Buffer){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this)}).call(this,{"isBuffer":require("../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})

},{"../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":133}],10:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))

},{"./common":11,"_process":136}],11:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":26}],12:[function(require,module,exports){
(function (process){(function (){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BrowserInfo = /** @class */ (function () {
    function BrowserInfo(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
    }
    return BrowserInfo;
}());
exports.BrowserInfo = BrowserInfo;
var NodeInfo = /** @class */ (function () {
    function NodeInfo(version) {
        this.version = version;
        this.name = 'node';
        this.os = process.platform;
    }
    return NodeInfo;
}());
exports.NodeInfo = NodeInfo;
var BotInfo = /** @class */ (function () {
    function BotInfo() {
        this.bot = true; // NOTE: deprecated test name instead
        this.name = 'bot';
        this.version = null;
        this.os = null;
    }
    return BotInfo;
}());
exports.BotInfo = BotInfo;
// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk)|(Googlebot)|(Yammybot)|(Openbot)|(Slurp)|(MSNBot)|(Ask Jeeves\/Teoma)|(ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
    ['aol', /AOLShield\/([0-9\._]+)/],
    ['edge', /Edge\/([0-9\._]+)/],
    ['edge-ios', /EdgiOS\/([0-9\._]+)/],
    ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
    ['vivaldi', /Vivaldi\/([0-9\.]+)/],
    ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
    ['samsung', /SamsungBrowser\/([0-9\.]+)/],
    ['silk', /\bSilk\/([0-9._-]+)\b/],
    ['miui', /MiuiBrowser\/([0-9\.]+)$/],
    ['beaker', /BeakerBrowser\/([0-9\.]+)/],
    ['edge-chromium', /Edg\/([0-9\.]+)/],
    [
        'chromium-webview',
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
    ['fxios', /FxiOS\/([0-9\.]+)/],
    ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
    ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
    ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ['android', /Android\s([0-9\.]+)/],
    ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9\._]+).*Safari/],
    ['facebook', /FBAV\/([0-9\.]+)/],
    ['instagram', /Instagram\s([0-9\.]+)/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ['searchbot', SEARCHBOX_UA_REGEX],
];
var operatingSystemRules = [
    ['iOS', /iP(hone|od|ad)/],
    ['Android OS', /Android/],
    ['BlackBerry OS', /BlackBerry|BB10/],
    ['Windows Mobile', /IEMobile/],
    ['Amazon OS', /Kindle/],
    ['Windows 3.11', /Win16/],
    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
    ['Windows 98', /(Windows 98)|(Win98)/],
    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
    ['Windows Server 2003', /(Windows NT 5.2)/],
    ['Windows Vista', /(Windows NT 6.0)/],
    ['Windows 7', /(Windows NT 6.1)/],
    ['Windows 8', /(Windows NT 6.2)/],
    ['Windows 8.1', /(Windows NT 6.3)/],
    ['Windows 10', /(Windows NT 10.0)/],
    ['Windows ME', /Windows ME/],
    ['Open BSD', /OpenBSD/],
    ['Sun OS', /SunOS/],
    ['Chrome OS', /CrOS/],
    ['Linux', /(Linux)|(X11)/],
    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
    ['QNX', /QNX/],
    ['BeOS', /BeOS/],
    ['OS/2', /OS\/2/],
    ['Search Bot', SEARCHBOT_OS_REGEX],
];
function detect(userAgent) {
    if (!!userAgent) {
        return parseUserAgent(userAgent);
    }
    if (typeof navigator !== 'undefined') {
        return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
}
exports.detect = detect;
function parseUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    var matchedRule = ua !== '' &&
        userAgentRules.reduce(function (matched, _a) {
            var browser = _a[0], regex = _a[1];
            if (matched) {
                return matched;
            }
            var uaMatch = regex.exec(ua);
            return !!uaMatch && [browser, uaMatch];
        }, false);
    if (!matchedRule) {
        return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === 'searchbot') {
        return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
    if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
            versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
        }
    }
    else {
        versionParts = [];
    }
    return new BrowserInfo(name, versionParts.join('.'), detectOS(ua));
}
exports.parseUserAgent = parseUserAgent;
function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.test(ua);
        if (match) {
            return os;
        }
    }
    return null;
}
exports.detectOS = detectOS;
function getNodeVersion() {
    var isNode = typeof process !== 'undefined' && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
exports.getNodeVersion = getNodeVersion;
function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
        output.push('0');
    }
    return output;
}

}).call(this)}).call(this,require('_process'))

},{"_process":136}],13:[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? setTimeout(fn, 0) : fns.push(fn)
  }

});

},{}],14:[function(require,module,exports){
'use strict';

/**
 * @typedef {{ [key: string]: any }} Extensions
 * @typedef {Error} Err
 * @property {string} message
 */

/**
 *
 * @param {Error} obj
 * @param {Extensions} props
 * @returns {Error & Extensions}
 */
function assign(obj, props) {
    for (const key in props) {
        Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true,
        });
    }

    return obj;
}

/**
 *
 * @param {any} err - An Error
 * @param {string|Extensions} code - A string code or props to set on the error
 * @param {Extensions} [props] - Props to set on the error
 * @returns {Error & Extensions}
 */
function createError(err, code, props) {
    if (!err || typeof err === 'string') {
        throw new TypeError('Please pass an Error to err-code');
    }

    if (!props) {
        props = {};
    }

    if (typeof code === 'object') {
        props = code;
        code = '';
    }

    if (code) {
        props.code = code;
    }

    try {
        return assign(err, props);
    } catch (_) {
        props.message = err.message;
        props.stack = err.stack;

        const ErrClass = function () {};

        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));

        // @ts-ignore
        const output = assign(new ErrClass(), props);

        return output;
    }
}

module.exports = createError;

},{}],15:[function(require,module,exports){
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * @typedef {object} PrivateData
 * @property {EventTarget} eventTarget The event target.
 * @property {{type:string}} event The original event object.
 * @property {number} eventPhase The current event phase.
 * @property {EventTarget|null} currentTarget The current event target.
 * @property {boolean} canceled The flag to prevent default.
 * @property {boolean} stopped The flag to stop propagation immediately.
 * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.
 * @property {number} timeStamp The unix time.
 * @private
 */

/**
 * Private data for event wrappers.
 * @type {WeakMap<Event, PrivateData>}
 * @private
 */
const privateData = new WeakMap();

/**
 * Cache for wrapper classes.
 * @type {WeakMap<Object, Function>}
 * @private
 */
const wrappers = new WeakMap();

/**
 * Get private data.
 * @param {Event} event The event object to get private data.
 * @returns {PrivateData} The private data of the event.
 * @private
 */
function pd(event) {
    const retv = privateData.get(event);
    console.assert(retv != null, "'this' is expected an Event object, but got", event);
    return retv
}

/**
 * @see https://dom.spec.whatwg.org/#interface-event
 * @private
 */
/**
 * The event wrapper.
 * @constructor
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Event|{type:string}} event The original event to wrap.
 */
function Event(eventTarget, event) {
    privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now(),
    });

    // https://heycam.github.io/webidl/#Unforgeable
    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });

    // Define accessors
    const keys = Object.keys(event);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
            Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
    }
}

// Should be enumerable, but class methods are not enumerable.
Event.prototype = {
    /**
     * The type of this event.
     * @type {string}
     */
    get type() {
        return pd(this).event.type
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get target() {
        return pd(this).eventTarget
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get currentTarget() {
        return pd(this).currentTarget
    },

    /**
     * @returns {EventTarget[]} The composed path of this event.
     */
    composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
            return []
        }
        return [currentTarget]
    },

    /**
     * Constant of NONE.
     * @type {number}
     */
    get NONE() {
        return 0
    },

    /**
     * Constant of CAPTURING_PHASE.
     * @type {number}
     */
    get CAPTURING_PHASE() {
        return 1
    },

    /**
     * Constant of AT_TARGET.
     * @type {number}
     */
    get AT_TARGET() {
        return 2
    },

    /**
     * Constant of BUBBLING_PHASE.
     * @type {number}
     */
    get BUBBLING_PHASE() {
        return 3
    },

    /**
     * The target of this event.
     * @type {number}
     */
    get eventPhase() {
        return pd(this).eventPhase
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopPropagation() {
        const data = pd(this);
        if (typeof data.event.stopPropagation === "function") {
            data.event.stopPropagation();
        }
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopImmediatePropagation() {
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
            data.event.stopImmediatePropagation();
        }
    },

    /**
     * The flag to be bubbling.
     * @type {boolean}
     */
    get bubbles() {
        return Boolean(pd(this).event.bubbles)
    },

    /**
     * The flag to be cancelable.
     * @type {boolean}
     */
    get cancelable() {
        return Boolean(pd(this).event.cancelable)
    },

    /**
     * Cancel this event.
     * @returns {void}
     */
    preventDefault() {
        const data = pd(this);
        if (data.passiveListener != null) {
            console.warn("Event#preventDefault() was called from a passive listener:", data.passiveListener);
            return
        }
        if (!data.event.cancelable) {
            return
        }

        data.canceled = true;
        if (typeof data.event.preventDefault === "function") {
            data.event.preventDefault();
        }
    },

    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     */
    get defaultPrevented() {
        return pd(this).canceled
    },

    /**
     * The flag to be composed.
     * @type {boolean}
     */
    get composed() {
        return Boolean(pd(this).event.composed)
    },

    /**
     * The unix time of this event.
     * @type {number}
     */
    get timeStamp() {
        return pd(this).timeStamp
    },
};

// `constructor` is not enumerable.
Object.defineProperty(Event.prototype, "constructor", { value: Event, configurable: true, writable: true });

// Ensure `event instanceof window.Event` is `true`.
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);

    // Make association for wrappers.
    wrappers.set(window.Event.prototype, Event);
}

/**
 * Get the property descriptor to redirect a given property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to redirect the property.
 * @private
 */
function defineRedirectDescriptor(key) {
    return {
        get() {
            return pd(this).event[key]
        },
        set(value) {
            pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Get the property descriptor to call a given method property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to call the method property.
 * @private
 */
function defineCallDescriptor(key) {
    return {
        value() {
            const event = pd(this).event;
            return event[key].apply(event, arguments)
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define new wrapper class.
 * @param {Function} BaseEvent The base wrapper class.
 * @param {Object} proto The prototype of the original event.
 * @returns {Function} The defined wrapper class.
 * @private
 */
function defineWrapper(BaseEvent, proto) {
    const keys = Object.keys(proto);
    if (keys.length === 0) {
        return BaseEvent
    }

    /** CustomEvent */
    function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
    }

    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true },
    });

    // Define accessors.
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(proto, key);
            const isFunc = (typeof descriptor.value === "function");
            Object.defineProperty(
                CustomEvent.prototype,
                key,
                isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
            );
        }
    }

    return CustomEvent
}

/**
 * Get the wrapper class of a given prototype.
 * @param {Object} proto The prototype of the original event to get its wrapper.
 * @returns {Function} The wrapper class.
 * @private
 */
function getWrapper(proto) {
    if (proto == null || proto === Object.prototype) {
        return Event
    }

    let wrapper = wrappers.get(proto);
    if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
    }
    return wrapper
}

/**
 * Wrap a given event to management a dispatching.
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Object} event The event to wrap.
 * @returns {Event} The wrapper instance.
 * @private
 */
function wrapEvent(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event)
}

/**
 * Get the stopped flag of a given event.
 * @param {Event} event The event to get.
 * @returns {boolean} The flag to stop propagation immediately.
 * @private
 */
function isStopped(event) {
    return pd(event).stopped
}

/**
 * Set the current event phase of a given event.
 * @param {Event} event The event to set current target.
 * @param {number} eventPhase New event phase.
 * @returns {void}
 * @private
 */
function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
}

/**
 * Set the current target of a given event.
 * @param {Event} event The event to set current target.
 * @param {EventTarget|null} currentTarget New current target.
 * @returns {void}
 * @private
 */
function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
}

/**
 * Set a passive listener of a given event.
 * @param {Event} event The event to set current target.
 * @param {Function|null} passiveListener New passive listener.
 * @returns {void}
 * @private
 */
function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
}

/**
 * @typedef {object} ListenerNode
 * @property {Function} listener
 * @property {1|2|3} listenerType
 * @property {boolean} passive
 * @property {boolean} once
 * @property {ListenerNode|null} next
 * @private
 */

/**
 * @type {WeakMap<object, Map<string, ListenerNode>>}
 * @private
 */
const listenersMap = new WeakMap();

// Listener types
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;

/**
 * Check whether a given value is an object or not.
 * @param {any} x The value to check.
 * @returns {boolean} `true` if the value is an object.
 */
function isObject(x) {
    return x !== null && typeof x === "object" //eslint-disable-line no-restricted-syntax
}

/**
 * Get listeners.
 * @param {EventTarget} eventTarget The event target to get.
 * @returns {Map<string, ListenerNode>} The listeners.
 * @private
 */
function getListeners(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
        throw new TypeError("'this' is expected an EventTarget object, but got another value.")
    }
    return listeners
}

/**
 * Get the property descriptor for the event attribute of a given event.
 * @param {string} eventName The event name to get property descriptor.
 * @returns {PropertyDescriptor} The property descriptor.
 * @private
 */
function defineEventAttributeDescriptor(eventName) {
    return {
        get() {
            const listeners = getListeners(this);
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    return node.listener
                }
                node = node.next;
            }
            return null
        },

        set(listener) {
            if (typeof listener !== "function" && !isObject(listener)) {
                listener = null; // eslint-disable-line no-param-reassign
            }
            const listeners = getListeners(this);

            // Traverse to the tail while removing old value.
            let prev = null;
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    // Remove old value.
                    if (prev !== null) {
                        prev.next = node.next;
                    }
                    else if (node.next !== null) {
                        listeners.set(eventName, node.next);
                    }
                    else {
                        listeners.delete(eventName);
                    }
                }
                else {
                    prev = node;
                }

                node = node.next;
            }

            // Add new value.
            if (listener !== null) {
                const newNode = {
                    listener,
                    listenerType: ATTRIBUTE,
                    passive: false,
                    once: false,
                    next: null,
                };
                if (prev === null) {
                    listeners.set(eventName, newNode);
                }
                else {
                    prev.next = newNode;
                }
            }
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define an event attribute (e.g. `eventTarget.onclick`).
 * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.
 * @param {string} eventName The event name to define.
 * @returns {void}
 */
function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
}

/**
 * Define a custom EventTarget with event attributes.
 * @param {string[]} eventNames Event names for event attributes.
 * @returns {EventTarget} The custom EventTarget.
 * @private
 */
function defineCustomEventTarget(eventNames) {
    /** CustomEventTarget */
    function CustomEventTarget() {
        EventTarget.call(this);
    }

    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: { value: CustomEventTarget, configurable: true, writable: true },
    });

    for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    }

    return CustomEventTarget
}

/**
 * EventTarget.
 *
 * - This is constructor if no arguments.
 * - This is a function which returns a CustomEventTarget constructor if there are arguments.
 *
 * For example:
 *
 *     class A extends EventTarget {}
 *     class B extends EventTarget("message") {}
 *     class C extends EventTarget("message", "error") {}
 *     class D extends EventTarget(["message", "error"]) {}
 */
function EventTarget() {
    /*eslint-disable consistent-return */
    if (this instanceof EventTarget) {
        listenersMap.set(this, new Map());
        return
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0])
    }
    if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
            types[i] = arguments[i];
        }
        return defineCustomEventTarget(types)
    }
    throw new TypeError("Cannot call a class as a function")
    /*eslint-enable consistent-return */
}

// Should be enumerable, but class methods are not enumerable.
EventTarget.prototype = {
    /**
     * Add a given listener to this event target.
     * @param {string} eventName The event name to add.
     * @param {Function} listener The listener to add.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {boolean} `true` if the listener was added actually.
     */
    addEventListener(eventName, listener, options) {
        if (listener == null) {
            return false
        }
        if (typeof listener !== "function" && !isObject(listener)) {
            throw new TypeError("'listener' should be a function or an object.")
        }

        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = (capture ? CAPTURE : BUBBLE);
        const newNode = {
            listener,
            listenerType,
            passive: optionsIsObj && Boolean(options.passive),
            once: optionsIsObj && Boolean(options.once),
            next: null,
        };

        // Set it as the first node if the first node is null.
        let node = listeners.get(eventName);
        if (node === undefined) {
            listeners.set(eventName, newNode);
            return true
        }

        // Traverse to the tail while checking duplication..
        let prev = null;
        while (node != null) {
            if (node.listener === listener && node.listenerType === listenerType) {
                // Should ignore duplication.
                return false
            }
            prev = node;
            node = node.next;
        }

        // Add it.
        prev.next = newNode;
        return true
    },

    /**
     * Remove a given listener from this event target.
     * @param {string} eventName The event name to remove.
     * @param {Function} listener The listener to remove.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {boolean} `true` if the listener was removed actually.
     */
    removeEventListener(eventName, listener, options) {
        if (listener == null) {
            return false
        }

        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = (capture ? CAPTURE : BUBBLE);

        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
            if (node.listener === listener && node.listenerType === listenerType) {
                if (prev !== null) {
                    prev.next = node.next;
                }
                else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                }
                else {
                    listeners.delete(eventName);
                }
                return true
            }

            prev = node;
            node = node.next;
        }

        return false
    },

    /**
     * Dispatch a given event.
     * @param {Event|{type:string}} event The event to dispatch.
     * @returns {boolean} `false` if canceled.
     */
    dispatchEvent(event) { //eslint-disable-line complexity
        if (event == null || typeof event.type !== "string") {
            throw new TypeError("\"event.type\" should be a string.")
        }

        // If listeners aren't registered, terminate.
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
            return true
        }

        // Since we cannot rewrite several properties, so wrap object.
        const wrappedEvent = wrapEvent(this, event);

        // This doesn't process capturing phase and bubbling phase.
        // This isn't participating in a tree.
        let prev = null;
        while (node != null) {
            // Remove this listener if it's once
            if (node.once) {
                if (prev !== null) {
                    prev.next = node.next;
                }
                else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                }
                else {
                    listeners.delete(eventName);
                }
            }
            else {
                prev = node;
            }

            // Call this listener
            setPassiveListener(wrappedEvent, (node.passive ? node.listener : null));
            if (typeof node.listener === "function") {
                try {
                    node.listener.call(this, wrappedEvent);
                }
                catch (err) {
                    /*eslint-disable no-console */
                    if (typeof console !== "undefined" && typeof console.error === "function") {
                        console.error(err);
                    }
                    /*eslint-enable no-console */
                }
            }
            else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
                node.listener.handleEvent(wrappedEvent);
            }

            // Break if `event.stopImmediatePropagation` was called.
            if (isStopped(wrappedEvent)) {
                break
            }

            node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);

        return !wrappedEvent.defaultPrevented
    },
};

// `constructor` is not enumerable.
Object.defineProperty(EventTarget.prototype, "constructor", { value: EventTarget, configurable: true, writable: true });

// Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}

exports.defineEventAttribute = defineEventAttribute;
exports.EventTarget = EventTarget;
exports.default = EventTarget;

module.exports = EventTarget
module.exports.EventTarget = module.exports["default"] = EventTarget
module.exports.defineEventAttribute = defineEventAttribute


},{}],16:[function(require,module,exports){
// originally pulled out of simple-peer

module.exports = function getBrowserRTC () {
  if (typeof globalThis === 'undefined') return null
  var wrtc = {
    RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection ||
      globalThis.webkitRTCPeerConnection,
    RTCSessionDescription: globalThis.RTCSessionDescription ||
      globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
    RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate ||
      globalThis.webkitRTCIceCandidate
  }
  if (!wrtc.RTCPeerConnection) return null
  return wrtc
}

},{}],17:[function(require,module,exports){
module.exports = function(el){

    var ids = {};

    if('string' == typeof el) el = document.getElementById(el);

    if(!el) el = document;

    var children = el.getElementsByTagName('*');

    Array.prototype.forEach.call(children, function(e){

	if(e.id.length > 0){

	    ids[e.id] = e

	}

    })

    return ids

}

},{}],18:[function(require,module,exports){
// getUserMedia helper by @HenrikJoreteg used for navigator.getUserMedia shim
var adapter = require('webrtc-adapter');

module.exports = function (constraints, cb) {
    var error;
    var haveOpts = arguments.length === 2;
    var defaultOpts = {video: true, audio: true};

    var denied = 'PermissionDeniedError';
    var altDenied = 'PERMISSION_DENIED';
    var notSatisfied = 'ConstraintNotSatisfiedError';

    // make constraints optional
    if (!haveOpts) {
        cb = constraints;
        constraints = defaultOpts;
    }

    // treat lack of browser support like an error
    if (typeof navigator === 'undefined' || !navigator.mediaDevices){ //getUserMedia) {
        // throw proper error per spec
        error = new Error('MediaStreamError');
        error.name = 'NotSupportedError';

        // keep all callbacks async
        return setTimeout(function () {
            cb(error);
        }, 0);
    }

    // normalize error handling when no media types are requested
    if (!constraints.audio && !constraints.video) {
        error = new Error('MediaStreamError');
        error.name = 'NoMediaRequestedError';

        // keep all callbacks async
        return setTimeout(function () {
            cb(error);
        }, 0);
    }

    navigator.mediaDevices.getUserMedia(constraints)
    .then(function (stream) {
        cb(null, stream);
    }).catch(function (err) {
        var error;
        // coerce into an error object since FF gives us a string
        // there are only two valid names according to the spec
        // we coerce all non-denied to "constraint not satisfied".
        if (typeof err === 'string') {
            error = new Error('MediaStreamError');
            if (err === denied || err === altDenied) {
                error.name = denied;
            } else {
                error.name = notSatisfied;
            }
        } else {
            // if we get an error object make sure '.name' property is set
            // according to spec: http://dev.w3.org/2011/webrtc/editor/getusermedia.html#navigatorusermediaerror-and-navigatorusermediaerrorcallback
            error = err;
            if (!error.name) {
                // this is likely chrome which
                // sets a property called "ERROR_DENIED" on the error object
                // if so we make sure to set a name
                if (error[denied]) {
                    err.name = denied;
                } else {
                    err.name = notSatisfied;
                }
            }
        }

        cb(error);
    });
};

},{"webrtc-adapter":102}],19:[function(require,module,exports){
var split = require('browser-split')
var ClassList = require('class-list')

var w = typeof window === 'undefined' ? require('html-element') : window
var document = w.document
var Text = w.Text

function context () {

  var cleanupFuncs = []

  function h() {
    var args = [].slice.call(arguments), e = null
    function item (l) {
      var r
      function parseClass (string) {
        // Our minimal parser doesnt understand escaping CSS special
        // characters like `#`. Dont use them. More reading:
        // https://mathiasbynens.be/notes/css-escapes .

        var m = split(string, /([\.#]?[^\s#.]+)/)
        if(/^\.|#/.test(m[1]))
          e = document.createElement('div')
        forEach(m, function (v) {
          var s = v.substring(1,v.length)
          if(!v) return
          if(!e)
            e = document.createElement(v)
          else if (v[0] === '.')
            ClassList(e).add(s)
          else if (v[0] === '#')
            e.setAttribute('id', s)
        })
      }

      if(l == null)
        ;
      else if('string' === typeof l) {
        if(!e)
          parseClass(l)
        else
          e.appendChild(r = document.createTextNode(l))
      }
      else if('number' === typeof l
        || 'boolean' === typeof l
        || l instanceof Date
        || l instanceof RegExp ) {
          e.appendChild(r = document.createTextNode(l.toString()))
      }
      //there might be a better way to handle this...
      else if (isArray(l))
        forEach(l, item)
      else if(isNode(l))
        e.appendChild(r = l)
      else if(l instanceof Text)
        e.appendChild(r = l)
      else if ('object' === typeof l) {
        for (var k in l) {
          if('function' === typeof l[k]) {
            if(/^on\w+/.test(k)) {
              (function (k, l) { // capture k, l in the closure
                if (e.addEventListener){
                  e.addEventListener(k.substring(2), l[k], false)
                  cleanupFuncs.push(function(){
                    e.removeEventListener(k.substring(2), l[k], false)
                  })
                }else{
                  e.attachEvent(k, l[k])
                  cleanupFuncs.push(function(){
                    e.detachEvent(k, l[k])
                  })
                }
              })(k, l)
            } else {
              // observable
              e[k] = l[k]()
              cleanupFuncs.push(l[k](function (v) {
                e[k] = v
              }))
            }
          }
          else if(k === 'style') {
            if('string' === typeof l[k]) {
              e.style.cssText = l[k]
            }else{
              for (var s in l[k]) (function(s, v) {
                if('function' === typeof v) {
                  // observable
                  e.style.setProperty(s, v())
                  cleanupFuncs.push(v(function (val) {
                    e.style.setProperty(s, val)
                  }))
                } else
                  var match = l[k][s].match(/(.*)\W+!important\W*$/);
                  if (match) {
                    e.style.setProperty(s, match[1], 'important')
                  } else {
                    e.style.setProperty(s, l[k][s])
                  }
              })(s, l[k][s])
            }
          } else if(k === 'attrs') {
            for (var v in l[k]) {
              e.setAttribute(v, l[k][v])
            }
          }
          else if (k.substr(0, 5) === "data-") {
            e.setAttribute(k, l[k])
          } else {
            e[k] = l[k]
          }
        }
      } else if ('function' === typeof l) {
        //assume it's an observable!
        var v = l()
        e.appendChild(r = isNode(v) ? v : document.createTextNode(v))

        cleanupFuncs.push(l(function (v) {
          if(isNode(v) && r.parentElement)
            r.parentElement.replaceChild(v, r), r = v
          else
            r.textContent = v
        }))
      }

      return r
    }
    while(args.length)
      item(args.shift())

    return e
  }

  h.cleanup = function () {
    for (var i = 0; i < cleanupFuncs.length; i++){
      cleanupFuncs[i]()
    }
    cleanupFuncs.length = 0
  }

  return h
}

var h = module.exports = context()
h.context = context

function isNode (el) {
  return el && el.nodeName && el.nodeType
}

function forEach (arr, fn) {
  if (arr.forEach) return arr.forEach(fn)
  for (var i = 0; i < arr.length; i++) fn(arr[i], i)
}

function isArray (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}



},{"browser-split":7,"class-list":8,"html-element":116}],20:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],21:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],22:[function(require,module,exports){
module.exports = function (args, opts) {
    if (!opts) opts = {};
    
    var flags = { bools : {}, strings : {}, unknownFn: null };

    if (typeof opts['unknown'] === 'function') {
        flags.unknownFn = opts['unknown'];
    }

    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
      flags.allBools = true;
    } else {
      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
          flags.bools[key] = true;
      });
    }
    
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function (key) {
        aliases[key] = [].concat(opts.alias[key]);
        aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
                return x !== y;
            }));
        });
    });

    [].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true;
        if (aliases[key]) {
            flags.strings[aliases[key]] = true;
        }
     });

    var defaults = opts['default'] || {};
    
    var argv = { _ : [] };
    Object.keys(flags.bools).forEach(function (key) {
        setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });
    
    var notFlags = [];

    if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--')+1);
        args = args.slice(0, args.indexOf('--'));
    }

    function argDefined(key, arg) {
        return (flags.allBools && /^--[^=]+$/.test(arg)) ||
            flags.strings[key] || flags.bools[key] || aliases[key];
    }

    function setArg (key, val, arg) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg) === false) return;
        }

        var value = !flags.strings[key] && isNumber(val)
            ? Number(val) : val
        ;
        setKey(argv, key.split('.'), value);
        
        (aliases[key] || []).forEach(function (x) {
            setKey(argv, x.split('.'), value);
        });
    }

    function setKey (obj, keys, value) {
        var o = obj;
        for (var i = 0; i < keys.length-1; i++) {
            var key = keys[i];
            if (key === '__proto__') return;
            if (o[key] === undefined) o[key] = {};
            if (o[key] === Object.prototype || o[key] === Number.prototype
                || o[key] === String.prototype) o[key] = {};
            if (o[key] === Array.prototype) o[key] = [];
            o = o[key];
        }

        var key = keys[keys.length - 1];
        if (key === '__proto__') return;
        if (o === Object.prototype || o === Number.prototype
            || o === String.prototype) o = {};
        if (o === Array.prototype) o = [];
        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
            o[key] = value;
        }
        else if (Array.isArray(o[key])) {
            o[key].push(value);
        }
        else {
            o[key] = [ o[key], value ];
        }
    }
    
    function aliasIsBoolean(key) {
      return aliases[key].some(function (x) {
          return flags.bools[x];
      });
    }

    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        
        if (/^--.+=/.test(arg)) {
            // Using [\s\S] instead of . because js doesn't support the
            // 'dotall' regex modifier. See:
            // http://stackoverflow.com/a/1068308/13216
            var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
            var key = m[1];
            var value = m[2];
            if (flags.bools[key]) {
                value = value !== 'false';
            }
            setArg(key, value, arg);
        }
        else if (/^--no-.+/.test(arg)) {
            var key = arg.match(/^--no-(.+)/)[1];
            setArg(key, false, arg);
        }
        else if (/^--.+/.test(arg)) {
            var key = arg.match(/^--(.+)/)[1];
            var next = args[i + 1];
            if (next !== undefined && !/^-/.test(next)
            && !flags.bools[key]
            && !flags.allBools
            && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i++;
            }
            else if (/^(true|false)$/.test(next)) {
                setArg(key, next === 'true', arg);
                i++;
            }
            else {
                setArg(key, flags.strings[key] ? '' : true, arg);
            }
        }
        else if (/^-[^-]+/.test(arg)) {
            var letters = arg.slice(1,-1).split('');
            
            var broken = false;
            for (var j = 0; j < letters.length; j++) {
                var next = arg.slice(j+2);
                
                if (next === '-') {
                    setArg(letters[j], next, arg)
                    continue;
                }
                
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split('=')[1], arg);
                    broken = true;
                    break;
                }
                
                if (/[A-Za-z]/.test(letters[j])
                && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                
                if (letters[j+1] && letters[j+1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j+2), arg);
                    broken = true;
                    break;
                }
                else {
                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                }
            }
            
            var key = arg.slice(-1)[0];
            if (!broken && key !== '-') {
                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                && !flags.bools[key]
                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i+1], arg);
                    i++;
                }
                else if (args[i+1] && /^(true|false)$/.test(args[i+1])) {
                    setArg(key, args[i+1] === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
        }
        else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(
                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                );
            }
            if (opts.stopEarly) {
                argv._.push.apply(argv._, args.slice(i + 1));
                break;
            }
        }
    }
    
    Object.keys(defaults).forEach(function (key) {
        if (!hasKey(argv, key.split('.'))) {
            setKey(argv, key.split('.'), defaults[key]);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), defaults[key]);
            });
        }
    });
    
    if (opts['--']) {
        argv['--'] = new Array();
        notFlags.forEach(function(key) {
            argv['--'].push(key);
        });
    }
    else {
        notFlags.forEach(function(key) {
            argv._.push(key);
        });
    }

    return argv;
};

function hasKey (obj, keys) {
    var o = obj;
    keys.slice(0,-1).forEach(function (key) {
        o = (o[key] || {});
    });

    var key = keys[keys.length - 1];
    return key in o;
}

function isNumber (x) {
    if (typeof x === 'number') return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}


},{}],23:[function(require,module,exports){
(function (process){(function (){

'use strict'

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./mobx.cjs.production.min.js')
} else {
  module.exports = require('./mobx.cjs.development.js')
}

}).call(this)}).call(this,require('_process'))

},{"./mobx.cjs.development.js":24,"./mobx.cjs.production.min.js":25,"_process":136}],24:[function(require,module,exports){
(function (global){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var niceErrors = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function _(annotationType, key) {
    return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
  },

  /*
  2(prop) {
      return `invalid decorator for '${prop.toString()}'`
  },
  3(prop) {
      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
  },
  4(prop) {
      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
  },
  */
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function _(index, length) {
    return "[mobx.array] Index out of bounds, " + index + " is larger than " + length;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function _(other) {
    return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
  },
  20: function _(other) {
    return "Cannot initialize map from " + other;
  },
  21: function _(dataStructure) {
    return "Cannot convert to map from '" + dataStructure + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function _(thing) {
    return "Cannot obtain administration from " + thing;
  },
  25: function _(property, name) {
    return "the entry '" + property + "' does not exist in the observable map '" + name + "'";
  },
  26: "please specify a property",
  27: function _(property, name) {
    return "no observable property '" + property.toString() + "' found on the observable object '" + name + "'";
  },
  28: function _(thing) {
    return "Cannot obtain atom from " + thing;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function _(name, derivation) {
    return "Cycle detected in computation " + name + ": " + derivation;
  },
  33: function _(name) {
    return "The setter of computed value '" + name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function _(name) {
    return "[ComputedValue '" + name + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function _(method) {
    return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
  },
  38: "'ownKeys()' can only be used on observable objects",
  39: "'defineProperty()' can only be used on observable objects"
};
var errors =  niceErrors ;
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  {
    var e = typeof error === "string" ? error : errors[error];
    if (typeof e === "function") e = e.apply(null, args);
    throw new Error("[MobX] " + e);
  }
}

var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }

  if (typeof window !== "undefined") {
    return window;
  }

  if (typeof global !== "undefined") {
    return global;
  }

  if (typeof self !== "undefined") {
    return self;
  }

  return mockGlobal;
}

var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = /*#__PURE__*/Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die( "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" );
  }
}
function warnAboutProxyRequirement(msg) {
  if ( globalState.verifyProxies) {
    die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + msg);
  }
}
function getNextId() {
  return ++globalState.mobxGuid;
}
/**
 * Makes sure that the provided function is invoked at most once.
 */

function once(func) {
  var invoked = false;
  return function () {
    if (invoked) return;
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop = function noop() {};
function isFunction(fn) {
  return typeof fn === "function";
}
function isStringish(value) {
  var t = typeof value;

  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }

  return false;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  var _proto$constructor;

  if (!isObject(value)) return false;
  var proto = Object.getPrototypeOf(value);
  if (proto == null) return true;
  return ((_proto$constructor = proto.constructor) == null ? void 0 : _proto$constructor.toString()) === plainObjectString;
} // https://stackoverflow.com/a/37865170

function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) return false;
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) return true;
  return false;
}
function addHiddenProp(object, propName, value) {
  defineProperty(object, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value: value
  });
}
function addHiddenFinalProp(object, propName, value) {
  defineProperty(object, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value: value
  });
}
function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function (x) {
    return isObject(x) && x[propName] === true;
  };
}
function isES6Map(thing) {
  return thing instanceof Map;
}
function isES6Set(thing) {
  return thing instanceof Set;
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
/**
 * Returns the following: own enumerable keys and symbols.
 */

function getPlainObjectKeys(object) {
  var keys = Object.keys(object); // Not supported in IE, so there are not going to be symbol props anyway...

  if (!hasGetOwnPropertySymbols) return keys;
  var symbols = Object.getOwnPropertySymbols(object);
  if (!symbols.length) return keys;
  return [].concat(keys, symbols.filter(function (s) {
    return objectPrototype.propertyIsEnumerable.call(object, s);
  }));
} // From Immer utils
// Returns all own keys, including non-enumerable and symbolic

var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function (obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} :
/* istanbul ignore next */
Object.getOwnPropertyNames;
function stringifyKey(key) {
  if (typeof key === "string") return key;
  if (typeof key === "symbol") return key.toString();
  return new String(key).toString();
}
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
} // From Immer utils

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
  var res = {}; // Note: without polyfill for ownKeys, symbols won't be picked up

  ownKeys(target).forEach(function (key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var storedAnnotationsSymbol = /*#__PURE__*/Symbol("mobx-stored-annotations");
/**
 * Creates a function that acts as
 * - decorator
 * - annotation object
 */

function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    storeAnnotation(target, property, annotation);
  }

  return Object.assign(decorator, annotation);
}
/**
 * Stores annotation to prototype,
 * so it can be inspected later by `makeObservable` called from constructor
 */

function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
  } // @override must override something


  if ( isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    die("'" + fieldName + "' is decorated with 'override', " + "but no such decorated member was found on prototype.");
  } // Cannot re-decorate


  assertNotDecorated(prototype, annotation, key); // Ignore override

  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}

function assertNotDecorated(prototype, annotation, key) {
  if ( !isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed." + "\nUse '@override' decorator for methods overriden by subclass.");
  }
}
/**
 * Collects annotations from prototypes and stores them on target (instance)
 */


function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    if ( !target[storedAnnotationsSymbol]) {
      die("No annotations were passed to makeObservable, but no decorated members have been found either");
    } // We need a copy as we will remove annotation from the list once it's applied.


    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
  }

  return target[storedAnnotationsSymbol];
}

var $mobx = /*#__PURE__*/Symbol("mobx administration");
var Atom = /*#__PURE__*/function () {
  // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed

  /**
   * Create a new atom. For debugging purposes it is recommended to give it a name.
   * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
   */
  function Atom(name_) {
    if (name_ === void 0) {
      name_ =  "Atom@" + getNextId() ;
    }

    this.name_ = void 0;
    this.isPendingUnobservation_ = false;
    this.isBeingObserved_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
  } // onBecomeObservedListeners


  var _proto = Atom.prototype;

  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function (listener) {
        return listener();
      });
    }
  };

  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function (listener) {
        return listener();
      });
    }
  }
  /**
   * Invoke this method to notify mobx that your atom has been used somehow.
   * Returns true if there is currently a reactive context.
   */
  ;

  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  }
  /**
   * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
   */
  ;

  _proto.reportChanged = function reportChanged() {
    startBatch();
    propagateChanged(this);
    endBatch();
  };

  _proto.toString = function toString() {
    return this.name_;
  };

  return Atom;
}();
var isAtom = /*#__PURE__*/createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }

  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }

  var atom = new Atom(name); // default `noop` listener will not initialize the hook Set

  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }

  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }

  return atom;
}

function identityComparer(a, b) {
  return a === b;
}

function structuralComparer(a, b) {
  return deepEqual(a, b);
}

function shallowComparer(a, b) {
  return deepEqual(a, b, 1);
}

function defaultComparer(a, b) {
  if (Object.is) return Object.is(a, b);
  return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;
}

var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};

function deepEnhancer(v, _, name) {
  // it is an observable already, done
  if (isObservable(v)) return v; // something that can be converted and mutated?

  if (Array.isArray(v)) return observable.array(v, {
    name: name
  });
  if (isPlainObject(v)) return observable.object(v, undefined, {
    name: name
  });
  if (isES6Map(v)) return observable.map(v, {
    name: name
  });
  if (isES6Set(v)) return observable.set(v, {
    name: name
  });

  if (typeof v === "function" && !isAction(v) && !isFlow(v)) {
    if (isGenerator(v)) {
      return flow(v);
    } else {
      return autoAction(name, v);
    }
  }

  return v;
}
function shallowEnhancer(v, _, name) {
  if (v === undefined || v === null) return v;
  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) return v;
  if (Array.isArray(v)) return observable.array(v, {
    name: name,
    deep: false
  });
  if (isPlainObject(v)) return observable.object(v, undefined, {
    name: name,
    deep: false
  });
  if (isES6Map(v)) return observable.map(v, {
    name: name,
    deep: false
  });
  if (isES6Set(v)) return observable.set(v, {
    name: name,
    deep: false
  });
  die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function referenceEnhancer(newValue) {
  // never turn into an observable
  return newValue;
}
function refStructEnhancer(v, oldValue) {
  if ( isObservable(v)) die("observable.struct should not be used with observable values");
  if (deepEqual(v, oldValue)) return oldValue;
  return v;
}

var OVERRIDE = "override";
var override = /*#__PURE__*/createDecoratorAnnotation({
  annotationType_: OVERRIDE,
  make_: make_,
  extend_: extend_
});
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}

function make_(adm, key) {
  // Must not be plain object
  if ( adm.isPlainObject_) {
    die("Cannot apply '" + this.annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + this.annotationType_ + "' cannot be used on plain objects."));
  } // Must override something


  if ( !hasProp(adm.appliedAnnotations_, key)) {
    die("'" + adm.name_ + "." + key.toString() + "' is annotated with '" + this.annotationType_ + "', " + "but no such annotated member was found on prototype.");
  }

  return 0
  /* Cancel */
  ;
}

function extend_(adm, key, descriptor, proxyTrap) {
  die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}

function createActionAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$1,
    extend_: extend_$1
  };
}

function make_$1(adm, key, descriptor, source) {
  var _this$options_;

  // bound
  if ((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0
    /* Cancel */
    : 1
    /* Break */
    ;
  } // own


  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0
    /* Cancel */
    : 2
    /* Continue */
    ;
  } // prototype


  if (isAction(descriptor.value)) {
    // A prototype could have been annotated already by other constructor,
    // rest of the proto chain must be annotated already
    return 1
    /* Break */
    ;
  }

  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2
  /* Continue */
  ;
}

function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}

function assertActionDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;

  if ( !isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
  }
}

function createActionDescriptor(adm, annotation, key, descriptor, // provides ability to disable safeDescriptors for prototypes
safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3;

  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }

  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;

  if ((_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.bound) {
    var _adm$proxy_;

    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }

  return {
    value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}

function createFlowAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$2,
    extend_: extend_$2
  };
}

function make_$2(adm, key, descriptor, source) {
  var _this$options_;

  // own
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0
    /* Cancel */
    : 2
    /* Continue */
    ;
  } // prototype
  // bound - must annotate protos to support super.flow()


  if (((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) && !isFlow(adm.target_[key])) {
    if (this.extend_(adm, key, descriptor, false) === null) return 0
    /* Cancel */
    ;
  }

  if (isFlow(descriptor.value)) {
    // A prototype could have been annotated already by other constructor,
    // rest of the proto chain must be annotated already
    return 1
    /* Break */
    ;
  }

  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2
  /* Continue */
  ;
}

function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;

  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}

function assertFlowDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;

  if ( !isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
  }
}

function createFlowDescriptor(adm, annotation, key, descriptor, bound, // provides ability to disable safeDescriptors for prototypes
safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }

  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;

  if (bound) {
    var _adm$proxy_;

    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }

  return {
    value: flow(value),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}

function createComputedAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$3,
    extend_: extend_$3
  };
}

function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0
  /* Cancel */
  : 1
  /* Break */
  ;
}

function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}

function assertComputedDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var get = _ref2.get;

  if ( !get) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
  }
}

function createObservableAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$4,
    extend_: extend_$4
  };
}

function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0
  /* Cancel */
  : 1
  /* Break */
  ;
}

function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;

  assertObservableDescriptor(adm, this, key, descriptor);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}

function assertObservableDescriptor(adm, _ref, key, descriptor) {
  var annotationType_ = _ref.annotationType_;

  if ( !("value" in descriptor)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
  }
}

var AUTO = "true";
var autoAnnotation = /*#__PURE__*/createAutoAnnotation();
function createAutoAnnotation(options) {
  return {
    annotationType_: AUTO,
    options_: options,
    make_: make_$5,
    extend_: extend_$5
  };
}

function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;

  // getter -> computed
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  } // lone setter -> action setter


  if (descriptor.set) {
    // TODO make action applicable to setter and delegate to action.make_
    var set = createAction(key.toString(), descriptor.set); // own

    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set
      }) === null ? 0
      /* Cancel */
      : 2
      /* Continue */
      ;
    } // proto


    defineProperty(source, key, {
      configurable: true,
      set: set
    });
    return 2
    /* Continue */
    ;
  } // function on proto -> autoAction/flow


  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;

    if (isGenerator(descriptor.value)) {
      var _this$options_;

      var flowAnnotation = ((_this$options_ = this.options_) == null ? void 0 : _this$options_.autoBind) ? flow.bound : flow;
      return flowAnnotation.make_(adm, key, descriptor, source);
    }

    var actionAnnotation = ((_this$options_2 = this.options_) == null ? void 0 : _this$options_2.autoBind) ? autoAction.bound : autoAction;
    return actionAnnotation.make_(adm, key, descriptor, source);
  } // other -> observable
  // Copy props from proto as well, see test:
  // "decorate should work with Object.create"


  var observableAnnotation = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable; // if function respect autoBind option

  if (typeof descriptor.value === "function" && ((_this$options_4 = this.options_) == null ? void 0 : _this$options_4.autoBind)) {
    var _adm$proxy_;

    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }

  return observableAnnotation.make_(adm, key, descriptor, source);
}

function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;

  // getter -> computed
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  } // lone setter -> action setter


  if (descriptor.set) {
    // TODO make action applicable to setter and delegate to action.extend_
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  } // other -> observable
  // if function respect autoBind option


  if (typeof descriptor.value === "function" && ((_this$options_5 = this.options_) == null ? void 0 : _this$options_5.autoBind)) {
    var _adm$proxy_2;

    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }

  var observableAnnotation = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
  return observableAnnotation.extend_(adm, key, descriptor, proxyTrap);
}

var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct"; // Predefined bags of create observable options, to avoid allocating temporarily option objects
// in the majority of cases

var defaultCreateObservableOptions = {
  deep: true,
  name: undefined,
  defaultDecorator: undefined,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = /*#__PURE__*/createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options) {
  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
}
function getAnnotationFromOptions(options) {
  var _options$defaultDecor;

  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : undefined;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;

  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
/**
 * Turns an object, array or function into a reactive structure.
 * @param v the value which should become observable.
 */

function createObservable(v, arg2, arg3) {
  // @observable someProp;
  if (isStringish(arg2)) {
    storeAnnotation(v, arg2, observableAnnotation);
    return;
  } // already observable - ignore


  if (isObservable(v)) return v; // plain object

  if (isPlainObject(v)) return observable.object(v, arg2, arg3); // Array

  if (Array.isArray(v)) return observable.array(v, arg2); // Map

  if (isES6Map(v)) return observable.map(v, arg2); // Set

  if (isES6Set(v)) return observable.set(v, arg2); // other object - ignore

  if (typeof v === "object" && v !== null) return v; // anything else

  return observable.box(v, arg2);
}

Object.assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
  },
  array: function array(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
  },
  map: function map(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
  },
  set: function set(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
  },
  object: function object(props, decorators, options) {
    return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
  },
  ref: /*#__PURE__*/createDecoratorAnnotation(observableRefAnnotation),
  shallow: /*#__PURE__*/createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /*#__PURE__*/createDecoratorAnnotation(observableStructAnnotation)
}; // eslint-disable-next-line

var observable = /*#__PURE__*/assign(createObservable, observableFactories);

var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED);
var computedStructAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
/**
 * Decorator for class properties: @computed get value() { return expr; }.
 * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
 */

var computed = function computed(arg1, arg2) {
  if (isStringish(arg2)) {
    // @computed
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }

  if (isPlainObject(arg1)) {
    // @computed({ options })
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  } // computed(expr, options?)


  {
    if (!isFunction(arg1)) die("First argument to `computed` should be an expression.");
    if (isFunction(arg2)) die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
  }

  var opts = isPlainObject(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  /* for generated name */

  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = /*#__PURE__*/createDecoratorAnnotation(computedStructAnnotation);

var _getDescriptor$config, _getDescriptor;
// mobx versions

var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /*#__PURE__*/getDescriptor(function () {}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false; // we can safely recycle this object

var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn, autoAction, ref) {
  if (autoAction === void 0) {
    autoAction = false;
  }

  {
    if (!isFunction(fn)) die("`action` can only be invoked on functions");
    if (typeof actionName !== "string" || !actionName) die("actions should have valid names, got: '" + actionName + "'");
  }

  function res() {
    return executeAction(actionName, autoAction, fn, ref || this, arguments);
  }

  res.isMobxAction = true;

  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    Object.defineProperty(res, "name", tmpNameDescriptor);
  }

  return res;
}
function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);

  try {
    return fn.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, // true for autoAction
scope, args) {
  var notifySpy_ =  isSpyEnabled() && !!actionName;
  var startTime_ = 0;

  if ( notifySpy_) {
    startTime_ = Date.now();
    var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: actionName,
      object: scope,
      arguments: flattenedArgs
    });
  }

  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges; // by default preserve previous allow

  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }

  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_: prevDerivation_,
    prevAllowStateChanges_: prevAllowStateChanges_,
    prevAllowStateReads_: prevAllowStateReads_,
    notifySpy_: notifySpy_,
    startTime_: startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }

  currentActionId = runInfo.parentActionId_;

  if (runInfo.error_ !== undefined) {
    globalState.suppressReactionErrors = true;
  }

  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) untrackedEnd(runInfo.prevDerivation_);

  if ( runInfo.notifySpy_) {
    spyReportEnd({
      time: Date.now() - runInfo.startTime_
    });
  }

  globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges, func) {
  var prev = allowStateChangesStart(allowStateChanges);

  try {
    return func();
  } finally {
    allowStateChangesEnd(prev);
  }
}
function allowStateChangesStart(allowStateChanges) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}

var _Symbol$toPrimitive;
var CREATE = "create";
_Symbol$toPrimitive = Symbol.toPrimitive;
var ObservableValue = /*#__PURE__*/function (_Atom) {
  _inheritsLoose(ObservableValue, _Atom);

  function ObservableValue(value, enhancer, name_, notifySpy, equals) {
    var _this;

    if (name_ === void 0) {
      name_ =  "ObservableValue@" + getNextId() ;
    }

    if (notifySpy === void 0) {
      notifySpy = true;
    }

    if (equals === void 0) {
      equals = comparer["default"];
    }

    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, undefined, name_);

    if ( notifySpy && isSpyEnabled()) {
      // only notify spy if this is a stand-alone observable
      spyReport({
        type: CREATE,
        object: _assertThisInitialized(_this),
        observableKind: "value",
        debugObjectName: _this.name_,
        newValue: "" + _this.value_
      });
    }

    return _this;
  }

  var _proto = ObservableValue.prototype;

  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== undefined) return this.dehancer(value);
    return value;
  };

  _proto.set = function set(newValue) {
    var oldValue = this.value_;
    newValue = this.prepareNewValue_(newValue);

    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();

      if ( notifySpy) {
        spyReportStart({
          type: UPDATE,
          object: this,
          observableKind: "value",
          debugObjectName: this.name_,
          newValue: newValue,
          oldValue: oldValue
        });
      }

      this.setNewValue_(newValue);
      if ( notifySpy) spyReportEnd();
    }
  };

  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    checkIfStateModificationsAreAllowed(this);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue: newValue
      });
      if (!change) return globalState.UNCHANGED;
      newValue = change.newValue;
    } // apply modifier


    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };

  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();

    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue: newValue,
        oldValue: oldValue
      });
    }
  };

  _proto.get = function get() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately) listener({
      observableKind: "value",
      debugObjectName: this.name_,
      object: this,
      type: UPDATE,
      newValue: this.value_,
      oldValue: undefined
    });
    return registerListener(this, listener);
  };

  _proto.raw = function raw() {
    // used by MST ot get undehanced value
    return this.value_;
  };

  _proto.toJSON = function toJSON() {
    return this.get();
  };

  _proto.toString = function toString() {
    return this.name_ + "[" + this.value_ + "]";
  };

  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };

  _proto[_Symbol$toPrimitive] = function () {
    return this.valueOf();
  };

  return ObservableValue;
}(Atom);
var isObservableValue = /*#__PURE__*/createInstanceofPredicate("ObservableValue", ObservableValue);

var _Symbol$toPrimitive$1;
/**
 * A node in the state dependency root that observes other nodes, and can be observed itself.
 *
 * ComputedValue will remember the result of the computation for the duration of the batch, or
 * while being observed.
 *
 * During this time it will recompute only when one of its direct dependencies changed,
 * but only when it is being accessed with `ComputedValue.get()`.
 *
 * Implementation description:
 * 1. First time it's being accessed it will compute and remember result
 *    give back remembered result until 2. happens
 * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
 * 3. When it's being accessed, recompute if any shallow dependency changed.
 *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
 *    go to step 2. either way
 *
 * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
 */

_Symbol$toPrimitive$1 = Symbol.toPrimitive;
var ComputedValue = /*#__PURE__*/function () {
  // nodes we are looking at. Our value depends on these nodes
  // during tracking it's an array with new observed observers
  // to check for cycles
  // N.B: unminified as it is used by MST

  /**
   * Create a new computed value based on a function expression.
   *
   * The `name` property is for debug purposes only.
   *
   * The `equals` property specifies the comparer function to use to determine if a newly produced
   * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
   * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.
   * Structural comparison can be convenient if you always produce a new aggregated object and
   * don't want to notify observers if it is structurally the same.
   * This is useful for working with vectors, mouse coordinates etc.
   */
  function ComputedValue(options) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.isBeingObserved_ = false;
    this.isPendingUnobservation_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.isComputing_ = false;
    this.isRunningSetter_ = false;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options.get) die(31);
    this.derivation = options.get;
    this.name_ = options.name || ( "ComputedValue@" + getNextId() );

    if (options.set) {
      this.setter_ = createAction( this.name_ + "-setter" , options.set);
    }

    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options.context;
    this.requiresReaction_ = !!options.requiresReaction;
    this.keepAlive_ = !!options.keepAlive;
  }

  var _proto = ComputedValue.prototype;

  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };

  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function (listener) {
        return listener();
      });
    }
  };

  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function (listener) {
        return listener();
      });
    }
  }
  /**
   * Returns the current value of this computed value.
   * Will evaluate its computation first if needed.
   */
  ;

  _proto.get = function get() {
    if (this.isComputing_) die(32, this.name_, this.derivation);

    if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch(); // See perf test 'computed memoization'

        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);

      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext) globalState.trackingContext = this;
        if (this.trackAndCompute()) propagateChangeConfirmed(this);
        globalState.trackingContext = prevTrackingContext;
      }
    }

    var result = this.value_;
    if (isCaughtException(result)) throw result.cause;
    return result;
  };

  _proto.set = function set(value) {
    if (this.setter_) {
      if (this.isRunningSetter_) die(33, this.name_);
      this.isRunningSetter_ = true;

      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter_ = false;
      }
    } else die(34, this.name_);
  };

  _proto.trackAndCompute = function trackAndCompute() {
    // N.B: unminified as it is used by MST
    var oldValue = this.value_;
    var wasSuspended =
    /* see #1208 */
    this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;
    var newValue = this.computeValue_(true);

    if ( isSpyEnabled()) {
      spyReport({
        observableKind: "computed",
        debugObjectName: this.name_,
        object: this.scope_,
        type: "update",
        oldValue: this.value_,
        newValue: newValue
      });
    }

    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);

    if (changed) {
      this.value_ = newValue;
    }

    return changed;
  };

  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing_ = true; // don't allow state changes during computation

    var prev = allowStateChangesStart(false);
    var res;

    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e) {
          res = new CaughtException(e);
        }
      }
    }

    allowStateChangesEnd(prev);
    this.isComputing_ = false;
    return res;
  };

  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = undefined; // don't hold on to computed value!

      if ( this.isTracing_ !== TraceMode.NONE) {
        console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
      }
    }
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;

    var firstTime = true;
    var prevValue = undefined;
    return autorun(function () {
      // TODO: why is this in a different place than the spyReport() function? in all other observables it's called in the same place
      var newValue = _this.get();

      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue: newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }

      firstTime = false;
      prevValue = newValue;
    });
  };

  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {

    if (this.isTracing_ !== TraceMode.NONE) {
      console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }

    if (globalState.computedRequiresReaction || this.requiresReaction_) {
      console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
  };

  _proto.toString = function toString() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };

  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };

  _proto[_Symbol$toPrimitive$1] = function () {
    return this.valueOf();
  };

  return ComputedValue;
}();
var isComputedValue = /*#__PURE__*/createInstanceofPredicate("ComputedValue", ComputedValue);

var IDerivationState_;

(function (IDerivationState_) {
  // before being run or (outside batch and not being observed)
  // at this point derivation is not holding any data about dependency tree
  IDerivationState_[IDerivationState_["NOT_TRACKING_"] = -1] = "NOT_TRACKING_"; // no shallow dependency changed since last computation
  // won't recalculate derivation
  // this is what makes mobx fast

  IDerivationState_[IDerivationState_["UP_TO_DATE_"] = 0] = "UP_TO_DATE_"; // some deep dependency changed, but don't know if shallow dependency changed
  // will require to check first if UP_TO_DATE or POSSIBLY_STALE
  // currently only ComputedValue will propagate POSSIBLY_STALE
  //
  // having this state is second big optimization:
  // don't have to recompute on every dependency change, but only when it's needed

  IDerivationState_[IDerivationState_["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_"; // A shallow dependency has changed since last computation and the derivation
  // will need to recompute when it's needed next.

  IDerivationState_[IDerivationState_["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));

var TraceMode;

(function (TraceMode) {
  TraceMode[TraceMode["NONE"] = 0] = "NONE";
  TraceMode[TraceMode["LOG"] = 1] = "LOG";
  TraceMode[TraceMode["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));

var CaughtException = function CaughtException(cause) {
  this.cause = void 0;
  this.cause = cause; // Empty
};
function isCaughtException(e) {
  return e instanceof CaughtException;
}
/**
 * Finds out whether any dependency of the derivation has actually changed.
 * If dependenciesState is 1 then it will recalculate dependencies,
 * if any dependency changed it will propagate it by changing dependenciesState to 2.
 *
 * By iterating over the dependencies in the same order that they were reported and
 * stopping on the first change, all the recalculations are only called for ComputedValues
 * that will be tracked by derivation. That is because we assume that if the first x
 * dependencies of the derivation doesn't change then the derivation should run the same way
 * up until accessing x-th dependency.
 */

function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;

    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;

    case IDerivationState_.POSSIBLY_STALE_:
      {
        // state propagation can occur outside of action/reactive context #2195
        var prevAllowStateReads = allowStateReadsStart(true);
        var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.

        var obs = derivation.observing_,
            l = obs.length;

        for (var i = 0; i < l; i++) {
          var obj = obs[i];

          if (isComputedValue(obj)) {
            if (globalState.disableErrorBoundaries) {
              obj.get();
            } else {
              try {
                obj.get();
              } catch (e) {
                // we are not interested in the value *or* exception at this moment, but if there is one, notify all
                untrackedEnd(prevUntracked);
                allowStateReadsEnd(prevAllowStateReads);
                return true;
              }
            } // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.
            // and `derivation` is an observer of `obj`
            // invariantShouldCompute(derivation)


            if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
        }

        changeDependenciesStateTo0(derivation);
        untrackedEnd(prevUntracked);
        allowStateReadsEnd(prevAllowStateReads);
        return false;
      }
  }
}
function isComputingDerivation() {
  return globalState.trackingDerivation !== null; // filter out actions inside computations
}
function checkIfStateModificationsAreAllowed(atom) {

  var hasObservers = atom.observers_.size > 0; // Should not be possible to change observed state outside strict mode, except during initialization, see #563

  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "always")) console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
}
function checkIfStateReadsAreAllowed(observable) {
  if ( !globalState.allowStateReads && globalState.observableRequiresReaction) {
    console.warn("[mobx] Observable '" + observable.name_ + "' being read outside a reactive context.");
  }
}
/**
 * Executes the provided function `f` and tracks which observables are being accessed.
 * The tracking information is stored on the `derivation` object and the derivation is registered
 * as observer of any of the accessed observables.
 */

function trackDerivedFunction(derivation, f, context) {
  var prevAllowStateReads = allowStateReadsStart(true); // pre allocate array allocation + room for variation in deps
  // array will be trimmed by bindDependencies

  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(derivation.observing_.length + 100);
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;

  if (globalState.disableErrorBoundaries === true) {
    result = f.call(context);
  } else {
    try {
      result = f.call(context);
    } catch (e) {
      result = new CaughtException(e);
    }
  }

  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  warnAboutDerivationWithoutDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}

function warnAboutDerivationWithoutDependencies(derivation) {
  if (derivation.observing_.length !== 0) return;

  if (globalState.reactionRequiresObservable || derivation.requiresObservable_) {
    console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
  }
}
/**
 * diffs newObserving with observing.
 * update observing to be newObserving with unique observables
 * notify observers that become observed/unobserved
 */


function bindDependencies(derivation) {
  // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_; // Go through all new observables and check diffValue: (this list can contain duplicates):
  //   0: first occurrence, change to 1 and keep it
  //   1: extra occurrence, drop it

  var i0 = 0,
      l = derivation.unboundDepsCount_;

  for (var i = 0; i < l; i++) {
    var dep = observing[i];

    if (dep.diffValue_ === 0) {
      dep.diffValue_ = 1;
      if (i0 !== i) observing[i0] = dep;
      i0++;
    } // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
    // not hitting the condition


    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }

  observing.length = i0;
  derivation.newObserving_ = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)
  // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
  //   0: it's not in new observables, unobserve it
  //   1: it keeps being observed, don't want to notify it. change to 0

  l = prevObserving.length;

  while (l--) {
    var _dep = prevObserving[l];

    if (_dep.diffValue_ === 0) {
      removeObserver(_dep, derivation);
    }

    _dep.diffValue_ = 0;
  } // Go through all new observables and check diffValue: (now it should be unique)
  //   0: it was set to 0 in last loop. don't need to do anything.
  //   1: it wasn't observed, let's observe it. set back to 0


  while (i0--) {
    var _dep2 = observing[i0];

    if (_dep2.diffValue_ === 1) {
      _dep2.diffValue_ = 0;
      addObserver(_dep2, derivation);
    }
  } // Some new observed derivations may become stale during this derivation computation
  // so they have had no chance to propagate staleness (#916)


  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}

function clearObserving(derivation) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i = obs.length;

  while (i--) {
    removeObserver(obs[i], derivation);
  }

  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action) {
  var prev = untrackedStart();

  try {
    return action();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
/**
 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
 *
 */

function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) return;
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i = obs.length;

  while (i--) {
    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}

/**
 * These values will persist if global state is reset
 */

var persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"];
var MobXGlobals = function MobXGlobals() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
};
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = /*#__PURE__*/function () {
  var global = /*#__PURE__*/getGlobal();
  if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals) canMergeGlobalState = false;
  if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version) canMergeGlobalState = false;

  if (!canMergeGlobalState) {
    setTimeout(function () {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global.__mobxGlobals) {
    global.__mobxInstanceCount += 1;
    if (!global.__mobxGlobals.UNCHANGED) global.__mobxGlobals.UNCHANGED = {}; // make merge backward compatible

    return global.__mobxGlobals;
  } else {
    global.__mobxInstanceCount = 1;
    return global.__mobxGlobals = /*#__PURE__*/new MobXGlobals();
  }
}();
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) die(36);
  isolateCalled = true;

  if (canMergeGlobalState) {
    var global = getGlobal();
    if (--global.__mobxInstanceCount === 0) global.__mobxGlobals = undefined;
    globalState = new MobXGlobals();
  }
}
function getGlobalState() {
  return globalState;
}
/**
 * For testing purposes only; this will break the internal state of existing observables,
 * but can be used to get back at a stable state after throwing errors
 */

function resetGlobalState() {
  var defaultGlobals = new MobXGlobals();

  for (var key in defaultGlobals) {
    if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];
  }

  globalState.allowStateChanges = !globalState.enforceActions;
}

function hasObservers(observable) {
  return observable.observers_ && observable.observers_.size > 0;
}
function getObservers(observable) {
  return observable.observers_;
} // function invariantObservers(observable: IObservable) {
//     const list = observable.observers
//     const map = observable.observersIndexes
//     const l = list.length
//     for (let i = 0; i < l; i++) {
//         const id = list[i].__mapid
//         if (i) {
//             invariant(map[id] === i, "INTERNAL ERROR maps derivation.__mapid to index in list") // for performance
//         } else {
//             invariant(!(id in map), "INTERNAL ERROR observer on index 0 shouldn't be held in map.") // for performance
//         }
//     }
//     invariant(
//         list.length === 0 || Object.keys(map).length === list.length - 1,
//         "INTERNAL ERROR there is no junk in map"
//     )
// }

function addObserver(observable, node) {
  // invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");
  // invariantObservers(observable);
  observable.observers_.add(node);
  if (observable.lowestObserverState_ > node.dependenciesState_) observable.lowestObserverState_ = node.dependenciesState_; // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR didn't add node");
}
function removeObserver(observable, node) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");
  // invariantObservers(observable);
  observable.observers_["delete"](node);

  if (observable.observers_.size === 0) {
    // deleting last observer
    queueForUnobservation(observable);
  } // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR remove already removed node2");

}
function queueForUnobservation(observable) {
  if (observable.isPendingUnobservation_ === false) {
    // invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");
    observable.isPendingUnobservation_ = true;
    globalState.pendingUnobservations.push(observable);
  }
}
/**
 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
 * During a batch `onBecomeUnobserved` will be called at most once per observable.
 * Avoids unnecessary recalculations.
 */

function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions(); // the batch is actually about to finish, all unobserving should happen here.

    var list = globalState.pendingUnobservations;

    for (var i = 0; i < list.length; i++) {
      var observable = list[i];
      observable.isPendingUnobservation_ = false;

      if (observable.observers_.size === 0) {
        if (observable.isBeingObserved_) {
          // if this observable had reactive observers, trigger the hooks
          observable.isBeingObserved_ = false;
          observable.onBUO();
        }

        if (observable instanceof ComputedValue) {
          // computed values are automatically teared down when the last observer leaves
          // this process happens recursively, this computed might be the last observabe of another, etc..
          observable.suspend_();
        }
      }
    }

    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable) {
  checkIfStateReadsAreAllowed(observable);
  var derivation = globalState.trackingDerivation;

  if (derivation !== null) {
    /**
     * Simple optimization, give each derivation run an unique id (runId)
     * Check if last time this observable was accessed the same runId is used
     * if this is the case, the relation is already known
     */
    if (derivation.runId_ !== observable.lastAccessedBy_) {
      observable.lastAccessedBy_ = derivation.runId_; // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...

      derivation.newObserving_[derivation.unboundDepsCount_++] = observable;

      if (!observable.isBeingObserved_ && globalState.trackingContext) {
        observable.isBeingObserved_ = true;
        observable.onBO();
      }
    }

    return true;
  } else if (observable.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable);
  }

  return false;
} // function invariantLOS(observable: IObservable, msg: string) {
//     // it's expensive so better not run it in produciton. but temporarily helpful for testing
//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)
//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`
//     throw new Error(
//         "lowestObserverState is wrong for " +
//             msg +
//             " because " +
//             min +
//             " < " +
//             observable.lowestObserverState
//     )
// }

/**
 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
 * It will propagate changes to observers from previous run
 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
 * Hopefully self reruning autoruns aren't a feature people should depend on
 * Also most basic use cases should be ok
 */
// Called by Atom when its value changes

function propagateChanged(observable) {
  // invariantLOS(observable, "changed start");
  if (observable.lowestObserverState_ === IDerivationState_.STALE_) return;
  observable.lowestObserverState_ = IDerivationState_.STALE_; // Ideally we use for..of here, but the downcompiled version is really slow...

  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      if ( d.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d, observable);
      }

      d.onBecomeStale_();
    }

    d.dependenciesState_ = IDerivationState_.STALE_;
  }); // invariantLOS(observable, "changed end");
} // Called by ComputedValue when it recalculate and its value changed

function propagateChangeConfirmed(observable) {
  // invariantLOS(observable, "confirmed start");
  if (observable.lowestObserverState_ === IDerivationState_.STALE_) return;
  observable.lowestObserverState_ = IDerivationState_.STALE_;
  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d.dependenciesState_ = IDerivationState_.STALE_;

      if ( d.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d, observable);
      }
    } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ // this happens during computing of `d`, just keep lowestObserverState up to date.
    ) {
        observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
      }
  }); // invariantLOS(observable, "confirmed end");
} // Used by computed when its dependency changed, but we don't wan't to immediately recompute.

function propagateMaybeChanged(observable) {
  // invariantLOS(observable, "maybe start");
  if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) return;
  observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d.onBecomeStale_();
    }
  }); // invariantLOS(observable, "maybe end");
}

function logTraceInfo(derivation, observable) {
  console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable.name_ + "'");

  if (derivation.isTracing_ === TraceMode.BREAK) {
    var lines = [];
    printDepTree(getDependencyTree(derivation), lines, 1); // prettier-ignore

    new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
}

function printDepTree(tree, lines, depth) {
  if (lines.length >= 1000) {
    lines.push("(and many more)");
    return;
  }

  lines.push("" + new Array(depth).join("\t") + tree.name); // MWE: not the fastest, but the easiest way :)

  if (tree.dependencies) tree.dependencies.forEach(function (child) {
    return printDepTree(child, lines, depth + 1);
  });
}

var Reaction = /*#__PURE__*/function () {
  // nodes we are looking at. Our value depends on these nodes
  function Reaction(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ =  "Reaction@" + getNextId() ;
    }

    if (requiresObservable_ === void 0) {
      requiresObservable_ = false;
    }

    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.isDisposed_ = false;
    this.isScheduled_ = false;
    this.isTrackPending_ = false;
    this.isRunning_ = false;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }

  var _proto = Reaction.prototype;

  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };

  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled_) {
      this.isScheduled_ = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };

  _proto.isScheduled = function isScheduled() {
    return this.isScheduled_;
  }
  /**
   * internal, use schedule() if you intend to kick off a reaction
   */
  ;

  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed_) {
      startBatch();
      this.isScheduled_ = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;

      if (shouldCompute(this)) {
        this.isTrackPending_ = true;

        try {
          this.onInvalidate_();

          if ("development" !== "production" && this.isTrackPending_ && isSpyEnabled()) {
            // onInvalidate didn't trigger track right away..
            spyReport({
              name: this.name_,
              type: "scheduled-reaction"
            });
          }
        } catch (e) {
          this.reportExceptionInDerivation_(e);
        }
      }

      globalState.trackingContext = prev;
      endBatch();
    }
  };

  _proto.track = function track(fn) {
    if (this.isDisposed_) {
      return; // console.warn("Reaction already disposed") // Note: Not a warning / error in mobx 4 either
    }

    startBatch();
    var notify = isSpyEnabled();
    var startTime;

    if ( notify) {
      startTime = Date.now();
      spyReportStart({
        name: this.name_,
        type: "reaction"
      });
    }

    this.isRunning_ = true;
    var prevReaction = globalState.trackingContext; // reactions could create reactions...

    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn, undefined);
    globalState.trackingContext = prevReaction;
    this.isRunning_ = false;
    this.isTrackPending_ = false;

    if (this.isDisposed_) {
      // disposed during last run. Clean up everything that was bound after the dispose call.
      clearObserving(this);
    }

    if (isCaughtException(result)) this.reportExceptionInDerivation_(result.cause);

    if ( notify) {
      spyReportEnd({
        time: Date.now() - startTime
      });
    }

    endBatch();
  };

  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;

    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }

    if (globalState.disableErrorBoundaries) throw error;
    var message =  "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" ;

    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
      /** If debugging brought you here, please, read the above message :-). Tnx! */
    } else console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)"); // prettier-ignore


    if ( isSpyEnabled()) {
      spyReport({
        type: "error",
        name: this.name_,
        message: message,
        error: "" + error
      });
    }

    globalState.globalReactionErrorHandlers.forEach(function (f) {
      return f(error, _this);
    });
  };

  _proto.dispose = function dispose() {
    if (!this.isDisposed_) {
      this.isDisposed_ = true;

      if (!this.isRunning_) {
        // if disposed while running, clean up later. Maybe not optimal, but rare case
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };

  _proto.getDisposer_ = function getDisposer_() {
    var r = this.dispose.bind(this);
    r[$mobx] = this;
    return r;
  };

  _proto.toString = function toString() {
    return "Reaction[" + this.name_ + "]";
  };

  _proto.trace = function trace$1(enterBreakPoint) {
    if (enterBreakPoint === void 0) {
      enterBreakPoint = false;
    }

    trace(this, enterBreakPoint);
  };

  return Reaction;
}();
function onReactionError(handler) {
  globalState.globalReactionErrorHandlers.push(handler);
  return function () {
    var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
    if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);
  };
}
/**
 * Magic number alert!
 * Defines within how many times a reaction is allowed to re-trigger itself
 * until it is assumed that this is gonna be a never ending loop...
 */

var MAX_REACTION_ITERATIONS = 100;

var reactionScheduler = function reactionScheduler(f) {
  return f();
};

function runReactions() {
  // Trampolining, if runReactions are already running, new reactions will be picked up
  if (globalState.inBatch > 0 || globalState.isRunningReactions) return;
  reactionScheduler(runReactionsHelper);
}

function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0; // While running reactions, new reactions might be triggered.
  // Hence we work with two variables and check whether
  // we converge to no remaining reactions after a while.

  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error( "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) );
      allReactions.splice(0); // clear reactions
    }

    var remainingReactions = allReactions.splice(0);

    for (var i = 0, l = remainingReactions.length; i < l; i++) {
      remainingReactions[i].runReaction_();
    }
  }

  globalState.isRunningReactions = false;
}

var isReaction = /*#__PURE__*/createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;

  reactionScheduler = function reactionScheduler(f) {
    return fn(function () {
      return baseScheduler(f);
    });
  };
}

function isSpyEnabled() {
  return  !!globalState.spyListeners.length;
}
function spyReport(event) {

  if (!globalState.spyListeners.length) return;
  var listeners = globalState.spyListeners;

  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](event);
  }
}
function spyReportStart(event) {

  var change = _extends({}, event, {
    spyReportStart: true
  });

  spyReport(change);
}
var END_EVENT = {
  type: "report-end",
  spyReportEnd: true
};
function spyReportEnd(change) {
  if (change) spyReport(_extends({}, change, {
    type: "report-end",
    spyReportEnd: true
  }));else spyReport(END_EVENT);
}
function spy(listener) {
  {
    globalState.spyListeners.push(listener);
    return once(function () {
      globalState.spyListeners = globalState.spyListeners.filter(function (l) {
        return l !== listener;
      });
    });
  }
}

var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = /*#__PURE__*/createActionAnnotation(ACTION);
var actionBoundAnnotation = /*#__PURE__*/createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});

function createActionFactory(autoAction) {
  var res = function action(arg1, arg2) {
    // action(fn() {})
    if (isFunction(arg1)) return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction); // action("name", fn() {})

    if (isFunction(arg2)) return createAction(arg1, arg2, autoAction); // @action

    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation);
    } // action("name") & @action("name")


    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction
      }));
    }

    die("Invalid arguments for `action`");
  };

  return res;
}

var action = /*#__PURE__*/createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = /*#__PURE__*/createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /*#__PURE__*/createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /*#__PURE__*/createDecoratorAnnotation(autoActionBoundAnnotation);
function runInAction(fn) {
  return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined);
}
function isAction(thing) {
  return isFunction(thing) && thing.isMobxAction === true;
}

/**
 * Creates a named reactive view and keeps it alive, so that the view is always
 * updated if one of the dependencies changes, even when the view is not further used by something else.
 * @param view The reactive view
 * @returns disposer function, which can be used to stop the view from being updated in the future.
 */

function autorun(view, opts) {
  var _opts$name, _opts;

  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }

  {
    if (!isFunction(view)) die("Autorun expects a function as first argument");
    if (isAction(view)) die("Autorun does not accept actions since actions are untrackable");
  }

  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name :  view.name || "Autorun@" + getNextId() ;
  var runSync = !opts.scheduler && !opts.delay;
  var reaction;

  if (runSync) {
    // normal autorun
    reaction = new Reaction(name, function () {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts); // debounced autorun

    var isScheduled = false;
    reaction = new Reaction(name, function () {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function () {
          isScheduled = false;
          if (!reaction.isDisposed_) reaction.track(reactionRunner);
        });
      }
    }, opts.onError, opts.requiresObservable);
  }

  function reactionRunner() {
    view(reaction);
  }

  reaction.schedule_();
  return reaction.getDisposer_();
}

var run = function run(f) {
  return f();
};

function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function (f) {
    return setTimeout(f, opts.delay);
  } : run;
}

function reaction(expression, effect, opts) {
  var _opts$name2;

  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }

  {
    if (!isFunction(expression) || !isFunction(effect)) die("First and second argument to reaction should be functions");
    if (!isPlainObject(opts)) die("Third argument of reactions should be an object");
  }

  var name = (_opts$name2 = opts.name) != null ? _opts$name2 :  "Reaction@" + getNextId() ;
  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var oldValue = undefined; // only an issue with fireImmediately

  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
  var r = new Reaction(name, function () {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);

  function reactionRunner() {
    isScheduled = false;
    if (r.isDisposed_) return;
    var changed = false;
    r.track(function () {
      var nextValue = allowStateChanges(false, function () {
        return expression(r);
      });
      changed = firstTime || !equals(value, nextValue);
      oldValue = value;
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately) effectAction(value, oldValue, r);else if (!firstTime && changed) effectAction(value, oldValue, r);
    firstTime = false;
  }

  r.schedule_();
  return r.getDisposer_();
}

function wrapErrorHandler(errorHandler, baseFn) {
  return function () {
    try {
      return baseFn.apply(this, arguments);
    } catch (e) {
      errorHandler.call(this, e);
    }
  };
}

var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}

function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";

  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = new Set([cb]);
  }

  return function () {
    var hookListeners = atom[listenersKey];

    if (hookListeners) {
      hookListeners["delete"](cb);

      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}

var NEVER = "never";
var ALWAYS = "always";
var OBSERVED = "observed"; // const IF_AVAILABLE = "ifavailable"

function configure(options) {
  if (options.isolateGlobalState === true) {
    isolateGlobalState();
  }

  var useProxies = options.useProxies,
      enforceActions = options.enforceActions;

  if (useProxies !== undefined) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
  }

  if (useProxies === "ifavailable") globalState.verifyProxies = true;

  if (enforceActions !== undefined) {
    var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea;
    globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function (key) {
    if (key in options) globalState[key] = !!options[key];
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;

  if ( globalState.disableErrorBoundaries === true) {
    console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
  }

  if (options.reactionScheduler) {
    setReactionScheduler(options.reactionScheduler);
  }
}

function extendObservable(target, properties, annotations, options) {
  {
    if (arguments.length > 4) die("'extendObservable' expected 2-4 arguments");
    if (typeof target !== "object") die("'extendObservable' expects an object as first argument");
    if (isObservableMap(target)) die("'extendObservable' should not be used on maps, use map.merge instead");
    if (!isPlainObject(properties)) die("'extendObservabe' only accepts plain objects as second argument");
    if (isObservable(properties) || isObservable(annotations)) die("Extending an object with another observable (object) is not supported");
  } // Pull descriptors first, so we don't have to deal with props added by administration ($mobx)


  var descriptors = getOwnPropertyDescriptors(properties);
  var adm = asObservableObject(target, options)[$mobx];
  startBatch();

  try {
    ownKeys(descriptors).forEach(function (key) {
      adm.extend_(key, descriptors[key], // must pass "undefined" for { key: undefined }
      !annotations ? true : key in annotations ? annotations[key] : true);
    });
  } finally {
    endBatch();
  }

  return target;
}

function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}

function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0) result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  return result;
}

function getObserverTree(thing, property) {
  return nodeToObserverTree(getAtom(thing, property));
}

function nodeToObserverTree(node) {
  var result = {
    name: node.name_
  };
  if (hasObservers(node)) result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);
  return result;
}

function unique(list) {
  return Array.from(new Set(list));
}

var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /*#__PURE__*/Object.create(Error.prototype);
function isFlowCancellationError(error) {
  return error instanceof FlowCancellationError;
}
var flowAnnotation = /*#__PURE__*/createFlowAnnotation("flow");
var flowBoundAnnotation = /*#__PURE__*/createFlowAnnotation("flow.bound", {
  bound: true
});
var flow = /*#__PURE__*/Object.assign(function flow(arg1, arg2) {
  // @flow
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  } // flow(fn)


  if ( arguments.length !== 1) die("Flow expects single argument with generator function");
  var generator = arg1;
  var name = generator.name || "<unnamed flow>"; // Implementation based on https://github.com/tj/co/blob/master/index.js

  var res = function res() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = undefined;
    var promise = new Promise(function (resolve, reject) {
      var stepId = 0;
      rejector = reject;

      function onFulfilled(res) {
        pendingPromise = undefined;
        var ret;

        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res);
        } catch (e) {
          return reject(e);
        }

        next(ret);
      }

      function onRejected(err) {
        pendingPromise = undefined;
        var ret;

        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e) {
          return reject(e);
        }

        next(ret);
      }

      function next(ret) {
        if (isFunction(ret == null ? void 0 : ret.then)) {
          // an async iterator
          ret.then(next, reject);
          return;
        }

        if (ret.done) return resolve(ret.value);
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }

      onFulfilled(undefined); // kick off the process
    });
    promise.cancel = action(name + " - runid: " + runId + " - cancel", function () {
      try {
        if (pendingPromise) cancelPromise(pendingPromise); // Finally block can return (or yield) stuff..

        var _res = gen["return"](undefined); // eat anything that promise would do, it's cancelled!


        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop, noop);
        cancelPromise(yieldedPromise); // maybe it can be cancelled :)
        // reject our original promise

        rejector(new FlowCancellationError());
      } catch (e) {
        rejector(e); // there could be a throwing finally block
      }
    });
    return promise;
  };

  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow.bound = /*#__PURE__*/createDecoratorAnnotation(flowBoundAnnotation);

function cancelPromise(promise) {
  if (isFunction(promise.cancel)) promise.cancel();
}

function flowResult(result) {
  return result; // just tricking TypeScript :)
}
function isFlow(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}

function interceptReads(thing, propOrHandler, handler) {
  var target;

  if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
    target = getAdministration(thing);
  } else if (isObservableObject(thing)) {
    if ( !isStringish(propOrHandler)) return die("InterceptReads can only be used with a specific property, not with an object in general");
    target = getAdministration(thing, propOrHandler);
  } else {
    return die("Expected observable map, object or array as first array");
  }

  if ( target.dehancer !== undefined) return die("An intercept reader was already established");
  target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
  return function () {
    target.dehancer = undefined;
  };
}

function intercept(thing, propOrHandler, handler) {
  if (isFunction(handler)) return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);
}

function interceptInterceptable(thing, handler) {
  return getAdministration(thing).intercept_(handler);
}

function interceptProperty(thing, property, handler) {
  return getAdministration(thing, property).intercept_(handler);
}

function _isComputed(value, property) {
  if (property !== undefined) {
    if (isObservableObject(value) === false) return false;
    if (!value[$mobx].values_.has(property)) return false;
    var atom = getAtom(value, property);
    return isComputedValue(atom);
  }

  return isComputedValue(value);
}
function isComputed(value) {
  if ( arguments.length > 1) return die("isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property");
  return _isComputed(value);
}
function isComputedProp(value, propName) {
  if ( !isStringish(propName)) return die("isComputed expected a property name as second argument");
  return _isComputed(value, propName);
}

function _isObservable(value, property) {
  if (!value) return false;

  if (property !== undefined) {
    if ( (isObservableMap(value) || isObservableArray(value))) return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");

    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }

    return false;
  } // For first check, see #701


  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}

function isObservable(value) {
  if ( arguments.length !== 1) die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  return _isObservable(value);
}
function isObservableProp(value, propName) {
  if ( !isStringish(propName)) return die("expected a property name as second argument");
  return _isObservable(value, propName);
}

function keys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].keys_();
  }

  if (isObservableMap(obj) || isObservableSet(obj)) {
    return Array.from(obj.keys());
  }

  if (isObservableArray(obj)) {
    return obj.map(function (_, index) {
      return index;
    });
  }

  die(5);
}
function values(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return obj[key];
    });
  }

  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return obj.get(key);
    });
  }

  if (isObservableSet(obj)) {
    return Array.from(obj.values());
  }

  if (isObservableArray(obj)) {
    return obj.slice();
  }

  die(6);
}
function entries(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj[key]];
    });
  }

  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj.get(key)];
    });
  }

  if (isObservableSet(obj)) {
    return Array.from(obj.entries());
  }

  if (isObservableArray(obj)) {
    return obj.map(function (key, index) {
      return [index, key];
    });
  }

  die(7);
}
function set(obj, key, value) {
  if (arguments.length === 2 && !isObservableSet(obj)) {
    startBatch();
    var _values = key;

    try {
      for (var _key in _values) {
        set(obj, _key, _values[_key]);
      }
    } finally {
      endBatch();
    }

    return;
  }

  if (isObservableObject(obj)) {
    obj[$mobx].set_(key, value);
  } else if (isObservableMap(obj)) {
    obj.set(key, value);
  } else if (isObservableSet(obj)) {
    obj.add(key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") key = parseInt(key, 10);
    if (key < 0) die("Invalid index: '" + key + "'");
    startBatch();
    if (key >= obj.length) obj.length = key + 1;
    obj[key] = value;
    endBatch();
  } else die(8);
}
function remove(obj, key) {
  if (isObservableObject(obj)) {
    obj[$mobx].delete_(key);
  } else if (isObservableMap(obj)) {
    obj["delete"](key);
  } else if (isObservableSet(obj)) {
    obj["delete"](key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") key = parseInt(key, 10);
    obj.splice(key, 1);
  } else {
    die(9);
  }
}
function has(obj, key) {
  if (isObservableObject(obj)) {
    return obj[$mobx].has_(key);
  } else if (isObservableMap(obj)) {
    return obj.has(key);
  } else if (isObservableSet(obj)) {
    return obj.has(key);
  } else if (isObservableArray(obj)) {
    return key >= 0 && key < obj.length;
  }

  die(10);
}
function get(obj, key) {
  if (!has(obj, key)) return undefined;

  if (isObservableObject(obj)) {
    return obj[$mobx].get_(key);
  } else if (isObservableMap(obj)) {
    return obj.get(key);
  } else if (isObservableArray(obj)) {
    return obj[key];
  }

  die(11);
}
function apiDefineProperty(obj, key, descriptor) {
  if (isObservableObject(obj)) {
    return obj[$mobx].defineProperty_(key, descriptor);
  }

  die(39);
}
function apiOwnKeys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].ownKeys_();
  }

  die(38);
}

function observe(thing, propOrCb, cbOrFire, fireImmediately) {
  if (isFunction(cbOrFire)) return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);
}

function observeObservable(thing, listener, fireImmediately) {
  return getAdministration(thing).observe_(listener, fireImmediately);
}

function observeObservableProperty(thing, property, listener, fireImmediately) {
  return getAdministration(thing, property).observe_(listener, fireImmediately);
}

function cache(map, key, value) {
  map.set(key, value);
  return value;
}

function toJSHelper(source, __alreadySeen) {
  if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) return source;
  if (isObservableValue(source) || isComputedValue(source)) return toJSHelper(source.get(), __alreadySeen);

  if (__alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }

  if (isObservableArray(source)) {
    var res = cache(__alreadySeen, source, new Array(source.length));
    source.forEach(function (value, idx) {
      res[idx] = toJSHelper(value, __alreadySeen);
    });
    return res;
  }

  if (isObservableSet(source)) {
    var _res = cache(__alreadySeen, source, new Set());

    source.forEach(function (value) {
      _res.add(toJSHelper(value, __alreadySeen));
    });
    return _res;
  }

  if (isObservableMap(source)) {
    var _res2 = cache(__alreadySeen, source, new Map());

    source.forEach(function (value, key) {
      _res2.set(key, toJSHelper(value, __alreadySeen));
    });
    return _res2;
  } else {
    // must be observable object
    var _res3 = cache(__alreadySeen, source, {});

    apiOwnKeys(source).forEach(function (key) {
      if (objectPrototype.propertyIsEnumerable.call(source, key)) {
        _res3[key] = toJSHelper(source[key], __alreadySeen);
      }
    });
    return _res3;
  }
}
/**
 * Basically, a deep clone, so that no reactive property will exist anymore.
 */


function toJS(source, options) {
  if ( options) die("toJS no longer supports options");
  return toJSHelper(source, new Map());
}

function trace() {
  var enterBreakPoint = false;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (typeof args[args.length - 1] === "boolean") enterBreakPoint = args.pop();
  var derivation = getAtomFromArgs(args);

  if (!derivation) {
    return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }

  if (derivation.isTracing_ === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
  }

  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}

function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;

    case 1:
      return getAtom(args[0]);

    case 2:
      return getAtom(args[0], args[1]);
  }
}

/**
 * During a transaction no views are updated until the end of the transaction.
 * The transaction will be run synchronously nonetheless.
 *
 * @param action a function that updates some reactive state
 * @returns any value that was returned by the 'action' parameter.
 */

function transaction(action, thisArg) {
  if (thisArg === void 0) {
    thisArg = undefined;
  }

  startBatch();

  try {
    return action.apply(thisArg);
  } finally {
    endBatch();
  }
}

function when(predicate, arg1, arg2) {
  if (arguments.length === 1 || arg1 && typeof arg1 === "object") return whenPromise(predicate, arg1);
  return _when(predicate, arg1, arg2 || {});
}

function _when(predicate, effect, opts) {
  var timeoutHandle;

  if (typeof opts.timeout === "number") {
    var error = new Error("WHEN_TIMEOUT");
    timeoutHandle = setTimeout(function () {
      if (!disposer[$mobx].isDisposed_) {
        disposer();
        if (opts.onError) opts.onError(error);else throw error;
      }
    }, opts.timeout);
  }

  opts.name =  opts.name || "When@" + getNextId() ;
  var effectAction = createAction( opts.name + "-effect" , effect); // eslint-disable-next-line

  var disposer = autorun(function (r) {
    // predicate should not change state
    var cond = allowStateChanges(false, predicate);

    if (cond) {
      r.dispose();
      if (timeoutHandle) clearTimeout(timeoutHandle);
      effectAction();
    }
  }, opts);
  return disposer;
}

function whenPromise(predicate, opts) {
  if ( opts && opts.onError) return die("the options 'onError' and 'promise' cannot be combined");
  var cancel;
  var res = new Promise(function (resolve, reject) {
    var disposer = _when(predicate, resolve, _extends({}, opts, {
      onError: reject
    }));

    cancel = function cancel() {
      disposer();
      reject("WHEN_CANCELLED");
    };
  });
  res.cancel = cancel;
  return res;
}

function getAdm(target) {
  return target[$mobx];
} // Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,
// and skip either the internal values map, or the base object with its property descriptors!


var objectProxyTraps = {
  has: function has(target, name) {
    if ( globalState.trackingDerivation) warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
    return getAdm(target).has_(name);
  },
  get: function get(target, name) {
    return getAdm(target).get_(name);
  },
  set: function set(target, name, value) {
    var _getAdm$set_;

    if (!isStringish(name)) return false;

    if ( !getAdm(target).values_.has(name)) {
      warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
    } // null (intercepted) -> true (success)


    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name) {
    var _getAdm$delete_;

    {
      warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
    }

    if (!isStringish(name)) return false; // null (intercepted) -> true (success)

    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty(target, name, descriptor) {
    var _getAdm$definePropert;

    {
      warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
    } // null (intercepted) -> true (success)


    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys(target) {
    if ( globalState.trackingDerivation) warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options) {
  var _target$$mobx, _target$$mobx$proxy_;

  assertProxies();
  target = asObservableObject(target, options);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}

function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function () {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) interceptors.splice(idx, 1);
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();

  try {
    // Interceptor can modify the array, copy it to avoid concurrent modification, see #1950
    var interceptors = [].concat(interceptable.interceptors_ || []);

    for (var i = 0, l = interceptors.length; i < l; i++) {
      change = interceptors[i](change);
      if (change && !change.type) die(14);
      if (!change) break;
    }

    return change;
  } finally {
    untrackedEnd(prevU);
  }
}

function hasListeners(listenable) {
  return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function () {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) listeners.splice(idx, 1);
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) return;
  listeners = listeners.slice();

  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](change);
  }

  untrackedEnd(prevU);
}

function makeObservable(target, annotations, options) {
  var adm = asObservableObject(target, options)[$mobx];
  startBatch();

  try {
    var _annotations;

    // Default to decorators
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target); // Annotate

    ownKeys(annotations).forEach(function (key) {
      return adm.make_(key, annotations[key]);
    });
  } finally {
    endBatch();
  }

  return target;
} // proto[keysSymbol] = new Set<PropertyKey>()

var keysSymbol = /*#__PURE__*/Symbol("mobx-keys");
function makeAutoObservable(target, overrides, options) {
  {
    if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target))) die("'makeAutoObservable' can only be used for classes that don't have a superclass");
    if (isObservableObject(target)) die("makeAutoObservable can only be used on objects not already made observable");
  } // Optimization: avoid visiting protos
  // Assumes that annotation.make_/.extend_ works the same for plain objects


  if (isPlainObject(target)) {
    return extendObservable(target, target, overrides, options);
  }

  var adm = asObservableObject(target, options)[$mobx]; // Optimization: cache keys on proto
  // Assumes makeAutoObservable can be called only once per object and can't be used in subclass

  if (!target[keysSymbol]) {
    var proto = Object.getPrototypeOf(target);
    var keys = new Set([].concat(ownKeys(target), ownKeys(proto)));
    keys["delete"]("constructor");
    keys["delete"]($mobx);
    addHiddenProp(proto, keysSymbol, keys);
  }

  startBatch();

  try {
    target[keysSymbol].forEach(function (key) {
      return adm.make_(key, // must pass "undefined" for { key: undefined }
      !overrides ? true : key in overrides ? overrides[key] : true);
    });
  } finally {
    endBatch();
  }

  return target;
}

var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859

var arrayTraps = {
  get: function get(target, name) {
    var adm = target[$mobx];
    if (name === $mobx) return adm;
    if (name === "length") return adm.getArrayLength_();

    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }

    if (hasProp(arrayExtensions, name)) {
      return arrayExtensions[name];
    }

    return target[name];
  },
  set: function set(target, name, value) {
    var adm = target[$mobx];

    if (name === "length") {
      adm.setArrayLength_(value);
    }

    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      // numeric string
      adm.set_(parseInt(name), value);
    }

    return true;
  },
  preventExtensions: function preventExtensions() {
    die(15);
  }
};
var ObservableArrayAdministration = /*#__PURE__*/function () {
  // this is the prop that gets proxied, so can't replace it!
  function ObservableArrayAdministration(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name =  "ObservableArray@" + getNextId() ;
    }

    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name);

    this.enhancer_ = function (newV, oldV) {
      return enhancer(newV, oldV,  name + "[..]" );
    };
  }

  var _proto = ObservableArrayAdministration.prototype;

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) return this.dehancer(value);
    return value;
  };

  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== undefined && values.length > 0) return values.map(this.dehancer);
    return values;
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }

    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }

    return registerListener(this, listener);
  };

  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };

  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || newLength < 0) die("Out of range: " + newLength);
    var currentLength = this.values_.length;
    if (newLength === currentLength) return;else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);

      for (var i = 0; i < newLength - currentLength; i++) {
        newItems[i] = undefined;
      } // No Array.fill everywhere...


      this.spliceWithArray_(currentLength, 0, newItems);
    } else this.spliceWithArray_(newLength, currentLength - newLength);
  };

  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_) die(16);
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0) reserveArrayBuffer(oldLength + delta + 1);
  };

  _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {
    var _this = this;

    checkIfStateModificationsAreAllowed(this.atom_);
    var length = this.values_.length;
    if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);
    if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));
    if (newItems === undefined) newItems = EMPTY_ARRAY;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: index,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) return EMPTY_ARRAY;
      deleteCount = change.removedCount;
      newItems = change.added;
    }

    newItems = newItems.length === 0 ? newItems : newItems.map(function (v) {
      return _this.enhancer_(v, undefined);
    });

    if (this.legacyMode_ || "development" !== "production") {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length, lengthDelta); // checks if internal array wasn't modified
    }

    var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice_(index, newItems, res);
    return this.dehanceValues_(res);
  };

  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;

      return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index, index + deleteCount);
      var oldItems = this.values_.slice(index + deleteCount);
      this.values_.length = index + newItems.length - deleteCount;

      for (var i = 0; i < newItems.length; i++) {
        this.values_[index + i] = newItems[i];
      }

      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index + newItems.length + _i] = oldItems[_i];
      }

      return res;
    }
  };

  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: index,
      newValue: newValue,
      oldValue: oldValue
    } : null; // The reason why this is on right hand side here (and not above), is this way the uglifier will drop it, but it won't
    // cause any runtime overhead in development mode without NODE_ENV set, unless spying is enabled

    if ( notifySpy) spyReportStart(change);
    this.atom_.reportChanged();
    if (notify) notifyListeners(this, change);
    if ( notifySpy) spyReportEnd();
  };

  _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: index,
      removed: removed,
      added: added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    if ( notifySpy) spyReportStart(change);
    this.atom_.reportChanged(); // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe

    if (notify) notifyListeners(this, change);
    if ( notifySpy) spyReportEnd();
  };

  _proto.get_ = function get_(index) {
    if (index < this.values_.length) {
      this.atom_.reportObserved();
      return this.dehanceValue_(this.values_[index]);
    }

    console.warn( "[mobx] Out of bounds read: " + index );
  };

  _proto.set_ = function set_(index, newValue) {
    var values = this.values_;

    if (index < values.length) {
      // update at index in range
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values[index];

      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          index: index,
          newValue: newValue
        });
        if (!change) return;
        newValue = change.newValue;
      }

      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;

      if (changed) {
        values[index] = newValue;
        this.notifyArrayChildUpdate_(index, newValue, oldValue);
      }
    } else if (index === values.length) {
      // add a new item
      this.spliceWithArray_(index, 0, [newValue]);
    } else {
      // out of bounds
      die(17, index, values.length);
    }
  };

  return ObservableArrayAdministration;
}();
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name =  "ObservableArray@" + getNextId() ;
  }

  if (owned === void 0) {
    owned = false;
  }

  assertProxies();
  var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
  addHiddenFinalProp(adm.values_, $mobx, adm);
  var proxy = new Proxy(adm.values_, arrayTraps);
  adm.proxy_ = proxy;

  if (initialValues && initialValues.length) {
    var prev = allowStateChangesStart(true);
    adm.spliceWithArray_(0, 0, initialValues);
    allowStateChangesEnd(prev);
  }

  return proxy;
} // eslint-disable-next-line

var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  // Used by JSON.stringify
  toJSON: function toJSON() {
    return this.slice();
  },

  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function splice(index, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }

    var adm = this[$mobx];

    switch (arguments.length) {
      case 0:
        return [];

      case 1:
        return adm.spliceWithArray_(index);

      case 2:
        return adm.spliceWithArray_(index, deleteCount);
    }

    return adm.spliceWithArray_(index, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];

    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }

    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];

    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }

    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    // reverse by default mutates in place before returning the result
    // which makes it both a 'derivation' and a 'mutation'.
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }

    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    // sort by default mutates in place before returning the result
    // which goes against all good practices. Let's not change the array in place!
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }

    var copy = this.slice();
    copy.sort.apply(copy, arguments);
    this.replace(copy);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);

    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }

    return false;
  }
};
/**
 * Wrap function from prototype
 * Without this, everything works as well, but this works
 * faster as everything works on unproxied values
 */

addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc); // map

addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc); // reduce

addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);

function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
} // Report and delegate to dehanced array


function simpleFunc(funcName) {
  return function () {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
} // Make sure callbacks recieve correct array arg #2326


function mapLikeFunc(funcName) {
  return function (callback, thisArg) {
    var _this2 = this;

    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function (element, index) {
      return callback.call(thisArg, element, index, _this2);
    });
  };
} // Make sure callbacks recieve correct array arg #2326


function reduceLikeFunc(funcName) {
  return function () {
    var _this3 = this;

    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_); // #2432 - reduce behavior depends on arguments.length

    var callback = arguments[0];

    arguments[0] = function (accumulator, currentValue, index) {
      return callback(accumulator, currentValue, index, _this3);
    };

    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}

var isObservableArrayAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}

var _Symbol$iterator, _Symbol$toStringTag;
var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete"; // just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54
// But: https://github.com/mobxjs/mobx/issues/1556

_Symbol$iterator = Symbol.iterator;
_Symbol$toStringTag = Symbol.toStringTag;
var ObservableMap = /*#__PURE__*/function () {
  // hasMap, not hashMap >-).
  function ObservableMap(initialData, enhancer_, name_) {
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }

    if (name_ === void 0) {
      name_ =  "ObservableMap@" + getNextId() ;
    }

    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;

    if (!isFunction(Map)) {
      die(18);
    }

    this.keysAtom_ = createAtom( this.name_ + ".keys()" );
    this.data_ = new Map();
    this.hasMap_ = new Map();
    this.merge(initialData);
  }

  var _proto = ObservableMap.prototype;

  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };

  _proto.has = function has(key) {
    var _this = this;

    if (!globalState.trackingDerivation) return this.has_(key);
    var entry = this.hasMap_.get(key);

    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer,  this.name_ + "." + stringifyKey(key) + "?" , false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function () {
        return _this.hasMap_["delete"](key);
      });
    }

    return entry.get();
  };

  _proto.set = function set(key, value) {
    var hasKey = this.has_(key);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change) return this;
      value = change.newValue;
    }

    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }

    return this;
  };

  _proto["delete"] = function _delete(key) {
    var _this2 = this;

    checkIfStateModificationsAreAllowed(this.keysAtom_);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change) return false;
    }

    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);

      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;

      if ( notifySpy) spyReportStart(_change);
      transaction(function () {
        _this2.keysAtom_.reportChanged();

        _this2.updateHasMapEntry_(key, false);

        var observable = _this2.data_.get(key);

        observable.setNewValue_(undefined);

        _this2.data_["delete"](key);
      });
      if (notify) notifyListeners(this, _change);
      if ( notifySpy) spyReportEnd();
      return true;
    }

    return false;
  };

  _proto.updateHasMapEntry_ = function updateHasMapEntry_(key, value) {
    var entry = this.hasMap_.get(key);

    if (entry) {
      entry.setNewValue_(value);
    }
  };

  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable = this.data_.get(key);
    newValue = observable.prepareNewValue_(newValue);

    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable.value_,
        name: key,
        newValue: newValue
      } : null;
      if ( notifySpy) spyReportStart(change);
      observable.setNewValue_(newValue);
      if (notify) notifyListeners(this, change);
      if ( notifySpy) spyReportEnd();
    }
  };

  _proto.addValue_ = function addValue_(key, newValue) {
    var _this3 = this;

    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function () {
      var observable = new ObservableValue(newValue, _this3.enhancer_,  _this3.name_ + "." + stringifyKey(key) , false);

      _this3.data_.set(key, observable);

      newValue = observable.value_; // value might have been changed

      _this3.updateHasMapEntry_(key, true);

      _this3.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue: newValue
    } : null;
    if ( notifySpy) spyReportStart(change);
    if (notify) notifyListeners(this, change);
    if ( notifySpy) spyReportEnd();
  };

  _proto.get = function get(key) {
    if (this.has(key)) return this.dehanceValue_(this.data_.get(key).get());
    return this.dehanceValue_(undefined);
  };

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }

    return value;
  };

  _proto.keys = function keys() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };

  _proto.values = function values() {
    var self = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next = keys.next(),
            done = _keys$next.done,
            value = _keys$next.value;

        return {
          done: done,
          value: done ? undefined : self.get(value)
        };
      }
    });
  };

  _proto.entries = function entries() {
    var self = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next2 = keys.next(),
            done = _keys$next2.done,
            value = _keys$next2.value;

        return {
          done: done,
          value: done ? undefined : [value, self.get(value)]
        };
      }
    });
  };

  _proto[_Symbol$iterator] = function () {
    return this.entries();
  };

  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          key = _step$value[0],
          value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  }
  /** Merge another object into this object, returns this. */
  ;

  _proto.merge = function merge(other) {
    var _this4 = this;

    if (isObservableMap(other)) {
      other = new Map(other);
    }

    transaction(function () {
      if (isPlainObject(other)) getPlainObjectKeys(other).forEach(function (key) {
        return _this4.set(key, other[key]);
      });else if (Array.isArray(other)) other.forEach(function (_ref) {
        var key = _ref[0],
            value = _ref[1];
        return _this4.set(key, value);
      });else if (isES6Map(other)) {
        if (other.constructor !== Map) die(19, other);
        other.forEach(function (value, key) {
          return _this4.set(key, value);
        });
      } else if (other !== null && other !== undefined) die(20, other);
    });
    return this;
  };

  _proto.clear = function clear() {
    var _this5 = this;

    transaction(function () {
      untracked(function () {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this5.keys()), _step2; !(_step2 = _iterator2()).done;) {
          var key = _step2.value;

          _this5["delete"](key);
        }
      });
    });
  };

  _proto.replace = function replace(values) {
    var _this6 = this;

    // Implementation requirements:
    // - respect ordering of replacement map
    // - allow interceptors to run and potentially prevent individual operations
    // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)
    // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)
    // - note that result map may differ from replacement map due to the interceptors
    transaction(function () {
      // Convert to map so we can do quick key lookups
      var replacementMap = convertToMap(values);
      var orderedData = new Map(); // Used for optimization

      var keysReportChangedCalled = false; // Delete keys that don't exist in replacement map
      // if the key deletion is prevented by interceptor
      // add entry at the beginning of the result map

      for (var _iterator3 = _createForOfIteratorHelperLoose(_this6.data_.keys()), _step3; !(_step3 = _iterator3()).done;) {
        var key = _step3.value;

        // Concurrently iterating/deleting keys
        // iterator should handle this correctly
        if (!replacementMap.has(key)) {
          var deleted = _this6["delete"](key); // Was the key removed?


          if (deleted) {
            // _keysAtom.reportChanged() was already called
            keysReportChangedCalled = true;
          } else {
            // Delete prevented by interceptor
            var value = _this6.data_.get(key);

            orderedData.set(key, value);
          }
        }
      } // Merge entries


      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done;) {
        var _step4$value = _step4.value,
            _key = _step4$value[0],
            _value = _step4$value[1];

        // We will want to know whether a new key is added
        var keyExisted = _this6.data_.has(_key); // Add or update value


        _this6.set(_key, _value); // The addition could have been prevent by interceptor


        if (_this6.data_.has(_key)) {
          // The update could have been prevented by interceptor
          // and also we want to preserve existing values
          // so use value from _data map (instead of replacement map)
          var _value2 = _this6.data_.get(_key);

          orderedData.set(_key, _value2); // Was a new key added?

          if (!keyExisted) {
            // _keysAtom.reportChanged() was already called
            keysReportChangedCalled = true;
          }
        }
      } // Check for possible key order change


      if (!keysReportChangedCalled) {
        if (_this6.data_.size !== orderedData.size) {
          // If size differs, keys are definitely modified
          _this6.keysAtom_.reportChanged();
        } else {
          var iter1 = _this6.data_.keys();

          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();

          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this6.keysAtom_.reportChanged();

              break;
            }

            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      } // Use correctly ordered map


      _this6.data_ = orderedData;
    });
    return this;
  };

  _proto.toString = function toString() {
    return "[object ObservableMap]";
  };

  _proto.toJSON = function toJSON() {
    return Array.from(this);
  };

  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if ( fireImmediately === true) die("`observe` doesn't support fireImmediately=true in combination with maps.");
    return registerListener(this, listener);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _createClass(ObservableMap, [{
    key: "size",
    get: function get() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return "Map";
    }
  }]);

  return ObservableMap;
}(); // eslint-disable-next-line

var isObservableMap = /*#__PURE__*/createInstanceofPredicate("ObservableMap", ObservableMap);

function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map = new Map();

    for (var key in dataStructure) {
      map.set(key, dataStructure[key]);
    }

    return map;
  } else {
    return die(21, dataStructure);
  }
}

var _Symbol$iterator$1, _Symbol$toStringTag$1;
var ObservableSetMarker = {};
_Symbol$iterator$1 = Symbol.iterator;
_Symbol$toStringTag$1 = Symbol.toStringTag;
var ObservableSet = /*#__PURE__*/function () {
  function ObservableSet(initialData, enhancer, name_) {
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }

    if (name_ === void 0) {
      name_ =  "ObservableSet@" + getNextId() ;
    }

    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;

    if (!isFunction(Set)) {
      die(22);
    }

    this.atom_ = createAtom(this.name_);

    this.enhancer_ = function (newV, oldV) {
      return enhancer(newV, oldV, name_);
    };

    if (initialData) {
      this.replace(initialData);
    }
  }

  var _proto = ObservableSet.prototype;

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }

    return value;
  };

  _proto.clear = function clear() {
    var _this = this;

    transaction(function () {
      untracked(function () {
        for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done;) {
          var value = _step.value;

          _this["delete"](value);
        }
      });
    });
  };

  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done;) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };

  _proto.add = function add(value) {
    var _this2 = this;

    checkIfStateModificationsAreAllowed(this.atom_);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change) return this; // ideally, value = change.value would be done here, so that values can be
      // changed by interceptor. Same applies for other Set and Map api's.
    }

    if (!this.has(value)) {
      transaction(function () {
        _this2.data_.add(_this2.enhancer_(value, undefined));

        _this2.atom_.reportChanged();
      });
      var notifySpy =  isSpyEnabled();
      var notify = hasListeners(this);

      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;

      if (notifySpy && "development" !== "production") spyReportStart(_change);
      if (notify) notifyListeners(this, _change);
      if (notifySpy && "development" !== "production") spyReportEnd();
    }

    return this;
  };

  _proto["delete"] = function _delete(value) {
    var _this3 = this;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change) return false;
    }

    if (this.has(value)) {
      var notifySpy =  isSpyEnabled();
      var notify = hasListeners(this);

      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;

      if (notifySpy && "development" !== "production") spyReportStart(_change2);
      transaction(function () {
        _this3.atom_.reportChanged();

        _this3.data_["delete"](value);
      });
      if (notify) notifyListeners(this, _change2);
      if (notifySpy && "development" !== "production") spyReportEnd();
      return true;
    }

    return false;
  };

  _proto.has = function has(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };

  _proto.entries = function entries() {
    var nextIndex = 0;
    var keys = Array.from(this.keys());
    var values = Array.from(this.values());
    return makeIterable({
      next: function next() {
        var index = nextIndex;
        nextIndex += 1;
        return index < values.length ? {
          value: [keys[index], values[index]],
          done: false
        } : {
          done: true
        };
      }
    });
  };

  _proto.keys = function keys() {
    return this.values();
  };

  _proto.values = function values() {
    this.atom_.reportObserved();
    var self = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterable({
      next: function next() {
        return nextIndex < observableValues.length ? {
          value: self.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          done: true
        };
      }
    });
  };

  _proto.replace = function replace(other) {
    var _this4 = this;

    if (isObservableSet(other)) {
      other = new Set(other);
    }

    transaction(function () {
      if (Array.isArray(other)) {
        _this4.clear();

        other.forEach(function (value) {
          return _this4.add(value);
        });
      } else if (isES6Set(other)) {
        _this4.clear();

        other.forEach(function (value) {
          return _this4.add(value);
        });
      } else if (other !== null && other !== undefined) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    // ... 'fireImmediately' could also be true?
    if ( fireImmediately === true) die("`observe` doesn't support fireImmediately=true in combination with sets.");
    return registerListener(this, listener);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.toJSON = function toJSON() {
    return Array.from(this);
  };

  _proto.toString = function toString() {
    return "[object ObservableSet]";
  };

  _proto[_Symbol$iterator$1] = function () {
    return this.values();
  };

  _createClass(ObservableSet, [{
    key: "size",
    get: function get() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag$1,
    get: function get() {
      return "Set";
    }
  }]);

  return ObservableSet;
}(); // eslint-disable-next-line

var isObservableSet = /*#__PURE__*/createInstanceofPredicate("ObservableSet", ObservableSet);

var descriptorCache = /*#__PURE__*/Object.create(null);
var REMOVE = "remove";
var ObservableObjectAdministration = /*#__PURE__*/function () {
  function ObservableObjectAdministration(target_, values_, name_, // Used anytime annotation is not explicitely provided
  defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = new Map();
    }

    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }

    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom( this.name_ + ".keys" ); // Optimization: we use this frequently

    this.isPlainObject_ = isPlainObject(this.target_);

    if ( !isAnnotation(this.defaultAnnotation_)) {
      die("defaultAnnotation must be valid annotation");
    }

    {
      // Prepare structure for tracking which fields were already annotated
      this.appliedAnnotations_ = {};
    }
  }

  var _proto = ObservableObjectAdministration.prototype;

  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };

  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable = this.values_.get(key);

    if (observable instanceof ComputedValue) {
      observable.set(newValue);
      return true;
    } // intercept


    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: newValue
      });
      if (!change) return null;
      newValue = change.newValue;
    }

    newValue = observable.prepareNewValue_(newValue); // notify spy & observers

    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy =  isSpyEnabled();

      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable.value_,
        name: key,
        newValue: newValue
      } : null;

      if ( notifySpy) spyReportStart(_change);
      observable.setNewValue_(newValue);
      if (notify) notifyListeners(this, _change);
      if ( notifySpy) spyReportEnd();
    }

    return true;
  };

  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      // Key doesn't exist yet, subscribe for it in case it's added later
      this.has_(key);
    }

    return this.target_[key];
  }
  /**
   * @param {PropertyKey} key
   * @param {any} value
   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    // Don't use .has(key) - we care about own
    if (hasProp(this.target_, key)) {
      // Existing prop
      if (this.values_.has(key)) {
        // Observable (can be intercepted)
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        // Non-observable - proxy
        return Reflect.set(this.target_, key, value);
      } else {
        // Non-observable
        this.target_[key] = value;
        return true;
      }
    } else {
      // New prop
      return this.extend_(key, {
        value: value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  } // Trap for "in"
  ;

  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      // Skip key subscription outside derivation
      return key in this.target_;
    }

    this.pendingKeys_ || (this.pendingKeys_ = new Map());
    var entry = this.pendingKeys_.get(key);

    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer,  this.name_ + "." + stringifyKey(key) + "?" , false);
      this.pendingKeys_.set(key, entry);
    }

    return entry.get();
  }
  /**
   * @param {PropertyKey} key
   * @param {Annotation|boolean} annotation true - use default annotation, false - ignore prop
   */
  ;

  _proto.make_ = function make_(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }

    if (annotation === false) {
      return;
    }

    assertAnnotable(this, annotation, key);

    if (!(key in this.target_)) {
      var _this$target_$storedA;

      // Throw on missing key, except for decorators:
      // Decorator annotations are collected from whole prototype chain.
      // When called from super() some props may not exist yet.
      // However we don't have to worry about missing prop,
      // because the decorator must have been applied to something.
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) == null ? void 0 : _this$target_$storedA[key]) {
        return; // will be annotated by subclass constructor
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }

    var source = this.target_;

    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key);

      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0
        /* Cancel */
        ) return;
        if (outcome === 1
        /* Break */
        ) break;
      }

      source = Object.getPrototypeOf(source);
    }

    recordAnnotationApplied(this, annotation, key);
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }

    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }

    assertAnnotable(this, annotation, key);
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);

    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }

    return outcome;
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change) return null;
        var newValue = change.newValue;

        if (descriptor.value !== newValue) {
          descriptor = _extends({}, descriptor, {
            value: newValue
          });
        }
      } // Define


      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      } // Notify


      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }

    return true;
  } // If original descriptor becomes relevant, move this to annotation directly
  ;

  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change) return null;
        value = change.newValue;
      }

      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      }; // Define

      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }

      var observable = new ObservableValue(value, enhancer, "development" !== "production" ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
      this.values_.set(key, observable); // Notify (value possibly changed by ObservableValue)

      this.notifyPropertyAddition_(key, observable.value_);
    } finally {
      endBatch();
    }

    return true;
  } // If original descriptor becomes relevant, move this to annotation directly
  ;

  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: undefined
        });
        if (!change) return null;
      }

      options.name || (options.name = "development" !== "production" ? this.name_ + "." + key.toString() : "ObservableObject.key");
      options.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      }; // Define

      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }

      this.values_.set(key, new ComputedValue(options)); // Notify

      this.notifyPropertyAddition_(key, undefined);
    } finally {
      endBatch();
    }

    return true;
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    // No such prop
    if (!hasProp(this.target_, key)) {
      return true;
    } // Intercept


    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      }); // Cancelled

      if (!change) return null;
    } // Delete


    try {
      var _this$pendingKeys_, _this$pendingKeys_$ge;

      startBatch();
      var notify = hasListeners(this);
      var notifySpy = "development" !== "production" && isSpyEnabled();
      var observable = this.values_.get(key); // Value needed for spies/listeners

      var value = undefined; // Optimization: don't pull the value unless we will need it

      if (!observable && (notify || notifySpy)) {
        var _getDescriptor;

        value = (_getDescriptor = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor.value;
      } // delete prop (do first, may fail)


      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      } // Allow re-annotating this field


      if ("development" !== "production") {
        delete this.appliedAnnotations_[key];
      } // Clear observable


      if (observable) {
        this.values_["delete"](key); // for computed, value is undefined

        if (observable instanceof ObservableValue) {
          value = observable.value_;
        } // Notify: autorun(() => obj[key]), see #1796


        propagateChanged(observable);
      } // Notify "keys/entries/values" observers


      this.keysAtom_.reportChanged(); // Notify "has" observers
      // "in" as it may still exist in proto

      (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_); // Notify spies/listeners

      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if ("development" !== "production" && notifySpy) spyReportStart(_change2);
        if (notify) notifyListeners(this, _change2);
        if ("development" !== "production" && notifySpy) spyReportEnd();
      }
    } finally {
      endBatch();
    }

    return true;
  }
  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */
  ;

  _proto.observe_ = function observe_(callback, fireImmediately) {
    if ( fireImmediately === true) die("`observe` doesn't support the fire immediately property for observable objects.");
    return registerListener(this, callback);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2, _this$pendingKeys_2$g;

    var notify = hasListeners(this);
    var notifySpy =  isSpyEnabled();

    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if ( notifySpy) spyReportStart(change);
      if (notify) notifyListeners(this, change);
      if ( notifySpy) spyReportEnd();
    }

    (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true); // Notify "keys/entries/values" observers

    this.keysAtom_.reportChanged();
  };

  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };

  _proto.keys_ = function keys_() {
    // Returns enumerable && own, but unfortunately keysAtom will report on ANY key change.
    // There is no way to distinguish between Object.keys(object) and Reflect.ownKeys(object) - both are handled by ownKeys trap.
    // We can either over-report in Object.keys(object) or under-report in Reflect.ownKeys(object)
    // We choose to over-report in Object.keys(object), because:
    // - typically it's used with simple data objects
    // - when symbolic/non-enumerable keys are relevant Reflect.ownKeys works as expected
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };

  return ObservableObjectAdministration;
}();
function asObservableObject(target, options) {
  var _options$name;

  if ( options && isObservableObject(target)) {
    die("Options can't be provided for already observable objects.");
  }

  if (hasProp(target, $mobx)) {
    if ( !(getAdministration(target) instanceof ObservableObjectAdministration)) {
      die("Cannot convert '" + getDebugName(target) + "' into observable object:" + "\nThe target is already observable of different type." + "\nExtending builtins is not supported.");
    }

    return target;
  }

  if ( !Object.isExtensible(target)) die("Cannot make the designated object observable; it is not extensible");
  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name :  (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() ;
  var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options));
  addHiddenProp(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);

function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}

function isObservableObject(thing) {
  if (isObject(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }

  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;

  {
    adm.appliedAnnotations_[key] = annotation;
  } // Remove applied decorator annotation so we don't try to apply it again in subclass constructor


  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];
}

function assertAnnotable(adm, annotation, key) {
  // Valid annotation
  if ( !isAnnotation(annotation)) {
    die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
  }
  /*
  // Configurable, not sealed, not frozen
  // Possibly not needed, just a little better error then the one thrown by engine.
  // Cases where this would be useful the most (subclass field initializer) are not interceptable by this.
  if (__DEV__) {
      const configurable = getDescriptor(adm.target_, key)?.configurable
      const frozen = Object.isFrozen(adm.target_)
      const sealed = Object.isSealed(adm.target_)
      if (!configurable || frozen || sealed) {
          const fieldName = `${adm.name_}.${key.toString()}`
          const requestedAnnotationType = annotation.annotationType_
          let error = `Cannot apply '${requestedAnnotationType}' to '${fieldName}':`
          if (frozen) {
              error += `\nObject is frozen.`
          }
          if (sealed) {
              error += `\nObject is sealed.`
          }
          if (!configurable) {
              error += `\nproperty is not configurable.`
              // Mention only if caused by us to avoid confusion
              if (hasProp(adm.appliedAnnotations!, key)) {
                  error += `\nTo prevent accidental re-definition of a field by a subclass, `
                  error += `all annotated fields of non-plain objects (classes) are not configurable.`
              }
          }
          die(error)
      }
  }
  */
  // Not annotated


  if ( !isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {
    var fieldName = adm.name_ + "." + key.toString();
    var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed." + "\nUse 'override' annotation for methods overriden by subclass.");
  }
}

/**
 * This array buffer contains two lists of properties, so that all arrays
 * can recycle their property definitions, which significantly improves performance of creating
 * properties on the fly.
 */

var OBSERVABLE_ARRAY_BUFFER_SIZE = 0; // Typescript workaround to make sure ObservableArray extends Array

var StubArray = function StubArray() {};

function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== undefined) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}

inherit(StubArray, Array.prototype); // Weex proto freeze protection was here,
// but it is unclear why the hack is need as MobX never changed the prototype
// anyway, so removed it in V6

var LegacyObservableArray = /*#__PURE__*/function (_StubArray) {
  _inheritsLoose(LegacyObservableArray, _StubArray);

  function LegacyObservableArray(initialValues, enhancer, name, owned) {
    var _this;

    if (name === void 0) {
      name =  "ObservableArray@" + getNextId() ;
    }

    if (owned === void 0) {
      owned = false;
    }

    _this = _StubArray.call(this) || this;
    var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
    adm.proxy_ = _assertThisInitialized(_this);
    addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);

    if (initialValues && initialValues.length) {
      var prev = allowStateChangesStart(true); // @ts-ignore

      _this.spliceWithArray(0, 0, initialValues);

      allowStateChangesEnd(prev);
    }

    return _this;
  }

  var _proto = LegacyObservableArray.prototype;

  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();

    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }

    return Array.prototype.concat.apply(this.slice(), //@ts-ignore
    arrays.map(function (a) {
      return isObservableArray(a) ? a.slice() : a;
    }));
  };

  _proto[Symbol.iterator] = function () {
    var self = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        // @ts-ignore
        return nextIndex < self.length ? {
          value: self[nextIndex++],
          done: false
        } : {
          done: true,
          value: undefined
        };
      }
    });
  };

  _createClass(LegacyObservableArray, [{
    key: "length",
    get: function get() {
      return this[$mobx].getArrayLength_();
    },
    set: function set(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return "Array";
    }
  }]);

  return LegacyObservableArray;
}(StubArray);

Object.entries(arrayExtensions).forEach(function (_ref) {
  var prop = _ref[0],
      fn = _ref[1];
  if (prop !== "concat") addHiddenProp(LegacyObservableArray.prototype, prop, fn);
});

function createArrayEntryDescriptor(index) {
  return {
    enumerable: false,
    configurable: true,
    get: function get() {
      return this[$mobx].get_(index);
    },
    set: function set(value) {
      this[$mobx].set_(index, value);
    }
  };
}

function createArrayBufferItem(index) {
  defineProperty(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
}

function reserveArrayBuffer(max) {
  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {
      createArrayBufferItem(index);
    }

    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
  }
}
reserveArrayBuffer(1000);
function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}

function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== undefined) die(23);
      return thing[$mobx].atom_;
    }

    if (isObservableSet(thing)) {
      return thing[$mobx];
    }

    if (isObservableMap(thing)) {
      if (property === undefined) return thing.keysAtom_;
      var observable = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable) die(25, property, getDebugName(thing));
      return observable;
    }

    if (isObservableObject(thing)) {
      if (!property) return die(26);

      var _observable = thing[$mobx].values_.get(property);

      if (!_observable) die(27, property, getDebugName(thing));
      return _observable;
    }

    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction(thing)) {
    if (isReaction(thing[$mobx])) {
      // disposer function
      return thing[$mobx];
    }
  }

  die(28);
}
function getAdministration(thing, property) {
  if (!thing) die(29);
  if (property !== undefined) return getAdministration(getAtom(thing, property));
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;
  if (isObservableMap(thing) || isObservableSet(thing)) return thing;
  if (thing[$mobx]) return thing[$mobx];
  die(24, thing);
}
function getDebugName(thing, property) {
  var named;

  if (property !== undefined) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    // valid for arrays as well
    named = getAtom(thing);
  }

  return named.name_;
}

var toString = objectPrototype.toString;
function deepEqual(a, b, depth) {
  if (depth === void 0) {
    depth = -1;
  }

  return eq(a, b, depth);
} // Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289
// Internal recursive comparison function for `isEqual`.

function eq(a, b, depth, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) return a !== 0 || 1 / a === 1 / b; // `null` or `undefined` only equal to itself (strict comparison).

  if (a == null || b == null) return false; // `NaN`s are equivalent, but non-reflexive.

  if (a !== a) return b !== b; // Exhaust primitive checks

  var type = typeof a;
  if (!isFunction(type) && type !== "object" && typeof b != "object") return false; // Compare `[[Class]]` names.

  var className = toString.call(a);
  if (className !== toString.call(b)) return false;

  switch (className) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case "[object RegExp]": // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')

    case "[object String]":
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return "" + a === "" + b;

    case "[object Number]":
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values.

      return +a === 0 ? 1 / +a === 1 / b : +a === +b;

    case "[object Date]":
    case "[object Boolean]":
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;

    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);

    case "[object Map]":
    case "[object Set]":
      // Maps and Sets are unwrapped to arrays of entry-pairs, adding an incidental level.
      // Hide this extra level by increasing the depth.
      if (depth >= 0) {
        depth++;
      }

      break;
  } // Unwrap any wrapped objects.


  a = unwrap(a);
  b = unwrap(b);
  var areArrays = className === "[object Array]";

  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.

    var aCtor = a.constructor,
        bCtor = b.constructor;

    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
      return false;
    }
  }

  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  } // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.


  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;

  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) return bStack[length] === b;
  } // Add the first object to the stack of traversed objects.


  aStack.push(a);
  bStack.push(b); // Recursively compare objects and arrays.

  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties.

    while (length--) {
      if (!eq(a[length], b[length], depth - 1, aStack, bStack)) return false;
    }
  } else {
    // Deep compare objects.
    var keys = Object.keys(a);
    var key;
    length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality.

    if (Object.keys(b).length !== length) return false;

    while (length--) {
      // Deep compare each member
      key = keys[length];
      if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) return false;
    }
  } // Remove the first object from the stack of traversed objects.


  aStack.pop();
  bStack.pop();
  return true;
}

function unwrap(a) {
  if (isObservableArray(a)) return a.slice();
  if (isES6Map(a) || isObservableMap(a)) return Array.from(a.entries());
  if (isES6Set(a) || isObservableSet(a)) return Array.from(a.entries());
  return a;
}

function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return iterator;
}

function getSelf() {
  return this;
}

function isAnnotation(thing) {
  return (// Can be function
    thing instanceof Object && typeof thing.annotationType_ === "string" && isFunction(thing.make_) && isFunction(thing.extend_)
  );
}

/**
 * (c) Michel Weststrate 2015 - 2020
 * MIT Licensed
 *
 * Welcome to the mobx sources! To get an global overview of how MobX internally works,
 * this is a good place to start:
 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 *
 * Source folders:
 * ===============
 *
 * - api/     Most of the public static methods exposed by the module can be found here.
 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
 * - utils/   Utility stuff.
 *
 */
["Symbol", "Map", "Set"].forEach(function (m) {
  var g = getGlobal();

  if (typeof g[m] === "undefined") {
    die("MobX requires global '" + m + "' to be available or polyfilled");
  }
});

if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  // See: https://github.com/andykog/mobx-devtools/
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy: spy,
    extras: {
      getDebugName: getDebugName
    },
    $mobx: $mobx
  });
}

exports.$mobx = $mobx;
exports.FlowCancellationError = FlowCancellationError;
exports.ObservableMap = ObservableMap;
exports.ObservableSet = ObservableSet;
exports.Reaction = Reaction;
exports._allowStateChanges = allowStateChanges;
exports._allowStateChangesInsideComputed = runInAction;
exports._allowStateReadsEnd = allowStateReadsEnd;
exports._allowStateReadsStart = allowStateReadsStart;
exports._autoAction = autoAction;
exports._endAction = _endAction;
exports._getAdministration = getAdministration;
exports._getGlobalState = getGlobalState;
exports._interceptReads = interceptReads;
exports._isComputingDerivation = isComputingDerivation;
exports._resetGlobalState = resetGlobalState;
exports._startAction = _startAction;
exports.action = action;
exports.autorun = autorun;
exports.comparer = comparer;
exports.computed = computed;
exports.configure = configure;
exports.createAtom = createAtom;
exports.defineProperty = apiDefineProperty;
exports.entries = entries;
exports.extendObservable = extendObservable;
exports.flow = flow;
exports.flowResult = flowResult;
exports.get = get;
exports.getAtom = getAtom;
exports.getDebugName = getDebugName;
exports.getDependencyTree = getDependencyTree;
exports.getObserverTree = getObserverTree;
exports.has = has;
exports.intercept = intercept;
exports.isAction = isAction;
exports.isBoxedObservable = isObservableValue;
exports.isComputed = isComputed;
exports.isComputedProp = isComputedProp;
exports.isFlow = isFlow;
exports.isFlowCancellationError = isFlowCancellationError;
exports.isObservable = isObservable;
exports.isObservableArray = isObservableArray;
exports.isObservableMap = isObservableMap;
exports.isObservableObject = isObservableObject;
exports.isObservableProp = isObservableProp;
exports.isObservableSet = isObservableSet;
exports.keys = keys;
exports.makeAutoObservable = makeAutoObservable;
exports.makeObservable = makeObservable;
exports.observable = observable;
exports.observe = observe;
exports.onBecomeObserved = onBecomeObserved;
exports.onBecomeUnobserved = onBecomeUnobserved;
exports.onReactionError = onReactionError;
exports.override = override;
exports.ownKeys = apiOwnKeys;
exports.reaction = reaction;
exports.remove = remove;
exports.runInAction = runInAction;
exports.set = set;
exports.spy = spy;
exports.toJS = toJS;
exports.trace = trace;
exports.transaction = transaction;
exports.untracked = untracked;
exports.values = values;
exports.when = when;


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],25:[function(require,module,exports){
(function (global){(function (){
function t(t){for(var n=arguments.length,i=new Array(n>1?n-1:0),r=1;r<n;r++)i[r-1]=arguments[r];throw new Error("number"==typeof t?"[MobX] minified error nr: "+t+(i.length?" "+i.map(String).join(","):"")+". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts":"[MobX] "+t)}function n(){return"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:xn}function i(){Vn||t("Proxy not available")}function r(t){var n=!1;return function(){if(!n)return n=!0,t.apply(this,arguments)}}function e(t){return"function"==typeof t}function o(t){switch(typeof t){case"string":case"symbol":case"number":return!0}return!1}function u(t){return null!==t&&"object"==typeof t}function s(t){var n;if(!u(t))return!1;var i=Object.getPrototypeOf(t);return null==i||(null==(n=i.constructor)?void 0:n.toString())===Nn}function f(t){var n=null==t?void 0:t.constructor;return!!n&&("GeneratorFunction"===n.name||"GeneratorFunction"===n.displayName)}function a(t,n,i){gn(t,n,{enumerable:!1,writable:!0,configurable:!0,value:i})}function c(t,n,i){gn(t,n,{enumerable:!1,writable:!1,configurable:!0,value:i})}function h(t,n){var i="isMobX"+t;return n.prototype[i]=!0,function(t){return u(t)&&!0===t[i]}}function v(t){return t instanceof Map}function l(t){return t instanceof Set}function d(t){return null===t?null:"object"==typeof t?""+t:t}function b(t,n){return _n.hasOwnProperty.call(t,n)}function p(t,n){for(var i=0;i<n.length;i++){var r=n[i];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function y(t,n,i){return n&&p(t.prototype,n),i&&p(t,i),t}function m(){return(m=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var i=arguments[n];for(var r in i)Object.prototype.hasOwnProperty.call(i,r)&&(t[r]=i[r])}return t}).apply(this,arguments)}function w(t,n){t.prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n}function j(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function x(t,n){(null==n||n>t.length)&&(n=t.length);for(var i=0,r=new Array(n);i<n;i++)r[i]=t[i];return r}function O(t,n){var i;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(i=function(t){if(t){if("string"==typeof t)return x(t,void 0);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?x(t,void 0):void 0}}(t))||n&&t&&"number"==typeof t.length){i&&(t=i);var r=0;return function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}return(i=t[Symbol.iterator]()).next.bind(i)}function A(t){return Object.assign((function(n,i){g(n,i,t)}),t)}function g(t,n,i){b(t,Cn)||a(t,Cn,m({},t[Cn])),function(t){return"override"===t.t}(i)||(t[Cn][n]=i)}function _(t,n,i){void 0===n&&(n=Rn),void 0===i&&(i=Rn);var r=new Ln(t);return n!==Rn&&St(r,n),i!==Rn&&Mt(r,i),r}function S(t,n,i){return It(t)?t:Array.isArray(t)?$n.array(t,{name:i}):s(t)?$n.object(t,void 0,{name:i}):v(t)?$n.map(t,{name:i}):l(t)?$n.set(t,{name:i}):"function"!=typeof t||At(t)||Ct(t)?t:f(t)?Ri(t):_i(i,t)}function M(t){return t}function V(t,n){return{t:t,i:n,o:N,u:R}}function N(t,n,i,r){var e;if(null==(e=this.i)?void 0:e.bound)return null===this.u(t,n,i,!1)?0:1;if(r===t.s)return null===this.u(t,n,i,!1)?0:2;if(At(i.value))return 1;var o=k(t,this,n,i,!1);return gn(r,n,o),2}function R(t,n,i,r){var e=k(t,this,n,i);return t.h(n,e,r)}function k(t,n,i,r,e){var o,u,s,f,a;void 0===e&&(e=pi.safeDescriptors);var c,h=r.value;return(null==(o=n.i)?void 0:o.bound)&&(h=h.bind(null!=(c=t.v)?c:t.s)),{value:z(null!=(u=null==(s=n.i)?void 0:s.name)?u:i.toString(),h,null!=(f=null==(a=n.i)?void 0:a.autoAction)&&f),configurable:!e||t.l,enumerable:!1,writable:!e}}function E(t,n){return{t:t,i:n,o:T,u:C}}function T(t,n,i,r){var e;if(r===t.s)return null===this.u(t,n,i,!1)?0:2;if((null==(e=this.i)?void 0:e.bound)&&!Ct(t.s[n])&&null===this.u(t,n,i,!1))return 0;if(Ct(i.value))return 1;var o=K(t,0,0,i,!1,!1);return gn(r,n,o),2}function C(t,n,i,r){var e,o=K(t,0,0,i,null==(e=this.i)?void 0:e.bound);return t.h(n,o,r)}function K(t,n,i,r,e,o){void 0===o&&(o=pi.safeDescriptors);var u,s=r.value;return e&&(s=s.bind(null!=(u=t.v)?u:t.s)),{value:Ri(s),configurable:!o||t.l,enumerable:!1,writable:!o}}function L(t,n){return{t:t,i:n,o:I,u:P}}function I(t,n,i){return null===this.u(t,n,i,!1)?0:1}function P(t,n,i,r){return t.p(n,m({},this.i,{get:i.get,set:i.set}),r)}function D(t,n){return{t:t,i:n,o:B,u:q}}function B(t,n,i){return null===this.u(t,n,i,!1)?0:1}function q(t,n,i,r){var e,o;return t.m(n,i.value,null!=(e=null==(o=this.i)?void 0:o.enhancer)?e:S,r)}function G(t){return{t:"true",i:t,o:X,u:W}}function X(t,n,i,r){var e,o,u,s;if(i.get)return Qn.o(t,n,i,r);if(i.set){var a=z(n.toString(),i.set);return r===t.s?null===t.h(n,{configurable:!pi.safeDescriptors||t.l,set:a})?0:2:(gn(r,n,{configurable:!0,set:a}),2)}if(r!==t.s&&"function"==typeof i.value)return f(i.value)?((null==(s=this.i)?void 0:s.autoBind)?Ri.bound:Ri).o(t,n,i,r):((null==(u=this.i)?void 0:u.autoBind)?_i.bound:_i).o(t,n,i,r);var c,h=!1===(null==(e=this.i)?void 0:e.deep)?$n.ref:$n;return"function"==typeof i.value&&(null==(o=this.i)?void 0:o.autoBind)&&(i.value=i.value.bind(null!=(c=t.v)?c:t.s)),h.o(t,n,i,r)}function W(t,n,i,r){var e,o,u;return i.get?Qn.u(t,n,i,r):i.set?t.h(n,{configurable:!pi.safeDescriptors||t.l,set:z(n.toString(),i.set)},r):("function"==typeof i.value&&(null==(e=this.i)?void 0:e.autoBind)&&(i.value=i.value.bind(null!=(u=t.v)?u:t.s)),(!1===(null==(o=this.i)?void 0:o.deep)?$n.ref:$n).u(t,n,i,r))}function H(t){return t||qn}function U(t){return!0===t.deep?S:!1===t.deep?M:(n=t.defaultDecorator)&&null!=(i=null==(r=n.i)?void 0:r.enhancer)?i:S;var n,i,r}function F(t,n,i){if(!o(n))return It(t)?t:s(t)?$n.object(t,n,i):Array.isArray(t)?$n.array(t,n):v(t)?$n.map(t,n):l(t)?$n.set(t,n):"object"==typeof t&&null!==t?t:$n.box(t,n);g(t,n,Gn)}function z(t,n,i,r){function e(){return $(0,i,n,r||this,arguments)}return void 0===i&&(i=!1),e.isMobxAction=!0,ii&&(ri.value=t,Object.defineProperty(e,"name",ri)),e}function $(t,n,i,r,e){var o=J(0,n);try{return i.apply(r,e)}catch(t){throw o.j=t,t}finally{Y(o)}}function J(t,n){var i=pi.trackingDerivation,r=!n||!i;dt();var e=pi.allowStateChanges;r&&(ut(),e=Z(!0));var o={O:r,A:i,g:e,_:ft(!0),S:!1,M:0,V:ni++,N:ti};return ti=o.V,o}function Y(n){ti!==n.V&&t(30),ti=n.N,void 0!==n.j&&(pi.suppressReactionErrors=!0),tt(n.g),at(n._),bt(),n.O&&st(n.A),pi.suppressReactionErrors=!1}function Q(t,n){var i=Z(t);try{return n()}finally{tt(i)}}function Z(t){var n=pi.allowStateChanges;return pi.allowStateChanges=t,n}function tt(t){pi.allowStateChanges=t}function nt(t){return t instanceof hi}function it(t){switch(t.R){case si.k:return!1;case si.T:case si.C:return!0;case si.K:for(var n=ft(!0),i=ut(),r=t.L,e=r.length,o=0;o<e;o++){var u=r[o];if(ci(u)){if(pi.disableErrorBoundaries)u.get();else try{u.get()}catch(t){return st(i),at(n),!0}if(t.R===si.C)return st(i),at(n),!0}}return ct(t),st(i),at(n),!1}}function rt(t,n,i){var r=ft(!0);ct(t),t.I=new Array(t.L.length+100),t.P=0,t.D=++pi.runId;var e,o=pi.trackingDerivation;if(pi.trackingDerivation=t,pi.inBatch++,!0===pi.disableErrorBoundaries)e=n.call(i);else try{e=n.call(i)}catch(t){e=new hi(t)}return pi.inBatch--,pi.trackingDerivation=o,function(t){for(var n=t.L,i=t.L=t.I,r=si.k,e=0,o=t.P,u=0;u<o;u++){var s=i[u];0===s.B&&(s.B=1,e!==u&&(i[e]=s),e++),s.R>r&&(r=s.R)}for(i.length=e,t.I=null,o=n.length;o--;){var f=n[o];0===f.B&&vt(f,t),f.B=0}for(;e--;){var a=i[e];1===a.B&&(a.B=0,ht(a,t))}r!==si.k&&(t.R=r,t.q())}(t),at(r),e}function et(t){var n=t.L;t.L=[];for(var i=n.length;i--;)vt(n[i],t);t.R=si.T}function ot(t){var n=ut();try{return t()}finally{st(n)}}function ut(){var t=pi.trackingDerivation;return pi.trackingDerivation=null,t}function st(t){pi.trackingDerivation=t}function ft(t){var n=pi.allowStateReads;return pi.allowStateReads=t,n}function at(t){pi.allowStateReads=t}function ct(t){if(t.R!==si.k){t.R=si.k;for(var n=t.L,i=n.length;i--;)n[i].G=si.k}}function ht(t,n){t.X.add(n),t.G>n.R&&(t.G=n.R)}function vt(t,n){t.X.delete(n),0===t.X.size&&lt(t)}function lt(t){!1===t.W&&(t.W=!0,pi.pendingUnobservations.push(t))}function dt(){pi.inBatch++}function bt(){if(0==--pi.inBatch){mt();for(var t=pi.pendingUnobservations,n=0;n<t.length;n++){var i=t[n];i.W=!1,0===i.X.size&&(i.H&&(i.H=!1,i.onBUO()),i instanceof ai&&i.U())}pi.pendingUnobservations=[]}}function pt(t){var n=pi.trackingDerivation;return null!==n?(n.D!==t.F&&(t.F=n.D,n.I[n.P++]=t,!t.H&&pi.trackingContext&&(t.H=!0,t.onBO())),!0):(0===t.X.size&&pi.inBatch>0&&lt(t),!1)}function yt(t){t.G!==si.C&&(t.G=si.C,t.X.forEach((function(t){t.R===si.k&&t.q(),t.R=si.C})))}function mt(){pi.inBatch>0||pi.isRunningReactions||mi(wt)}function wt(){pi.isRunningReactions=!0;for(var t=pi.pendingReactions,n=0;t.length>0;){100==++n&&(console.error("[mobx] cycle in reaction: "+t[0]),t.splice(0));for(var i=t.splice(0),r=0,e=i.length;r<e;r++)i[r].$()}pi.isRunningReactions=!1}function jt(){return console.warn("[mobx.spy] Is a no-op in production builds"),function(){}}function xt(t){return function(n,i){return e(n)?z(n.name||"<unnamed action>",n,t):e(i)?z(n,i,t):o(i)?g(n,i,t?Oi:ji):o(n)?A(V(t?"autoAction":"action",{name:n,autoAction:t})):void 0}}function Ot(t){return $(0,!1,t,this,void 0)}function At(t){return e(t)&&!0===t.isMobxAction}function gt(t,n){function i(){t(o)}var r,e;void 0===n&&(n=Mn);var o,u=null!=(r=null==(e=n)?void 0:e.name)?r:"Autorun";if(n.scheduler||n.delay){var s=_t(n),f=!1;o=new yi(u,(function(){f||(f=!0,s((function(){f=!1,o.J||o.track(i)})))}),n.onError,n.requiresObservable)}else o=new yi(u,(function(){this.track(i)}),n.onError,n.requiresObservable);return o.Y(),o.Z()}function _t(t){return t.scheduler?t.scheduler:t.delay?function(n){return setTimeout(n,t.delay)}:Si}function St(t,n,i){return Vt("onBO",t,n,i)}function Mt(t,n,i){return Vt("onBUO",t,n,i)}function Vt(t,n,i,r){var o="function"==typeof r?dn(n,i):dn(n),u=e(r)?r:i,s=t+"L";return o[s]?o[s].add(u):o[s]=new Set([u]),function(){var t=o[s];t&&(t.delete(u),0===t.size&&delete o[s])}}function Nt(t,n,i,r){var e=Tn(n),o=sn(t,r)[Kn];dt();try{En(e).forEach((function(t){o.u(t,e[t],!i||!(t in i)||i[t])}))}finally{bt()}return t}function Rt(t){var n,i={name:t.tt};return t.L&&t.L.length>0&&(i.dependencies=(n=t.L,Array.from(new Set(n))).map(Rt)),i}function kt(t){var n={name:t.tt};return function(t){return t.X&&t.X.size>0}(t)&&(n.observers=Array.from(function(t){return t.X}(t)).map(kt)),n}function Et(){this.message="FLOW_CANCELLED"}function Tt(t){e(t.cancel)&&t.cancel()}function Ct(t){return!0===(null==t?void 0:t.isMobXFlow)}function Kt(t,n){if(void 0!==n){if(!1===an(t))return!1;if(!t[Kn].nt.has(n))return!1;var i=dn(t,n);return ci(i)}return ci(t)}function Lt(t,n){return!!t&&(void 0!==n?!!an(t)&&t[Kn].nt.has(n):an(t)||!!t[Kn]||In(t)||wi(t)||ci(t))}function It(t){return Lt(t)}function Pt(n){return an(n)?n[Kn].it():Hi(n)||Ji(n)?Array.from(n.keys()):un(n)?n.map((function(t,n){return n})):void t(5)}function Dt(n,i){return an(n)?n[Kn].rt(i):Hi(n)||Ji(n)?n.has(i):un(n)?i>=0&&i<n.length:void t(10)}function Bt(n){if(an(n))return n[Kn].et();t(38)}function qt(t,n,i){return t.set(n,i),i}function Gt(){t("trace() is not available in production builds");for(var n=!1,i=arguments.length,r=new Array(i),e=0;e<i;e++)r[e]=arguments[e];"boolean"==typeof r[r.length-1]&&(n=r.pop());var o=Xt(r);if(!o)return t("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");o.ot===fi.NONE&&console.log("[mobx.trace] '"+o.tt+"' tracing enabled"),o.ot=n?fi.BREAK:fi.LOG}function Xt(t){switch(t.length){case 0:return pi.trackingDerivation;case 1:return dn(t[0]);case 2:return dn(t[0],t[1])}}function Wt(t,n){void 0===n&&(n=void 0),dt();try{return t.apply(n)}finally{bt()}}function Ht(t,n,i){var r;if("number"==typeof i.timeout){var e=new Error("WHEN_TIMEOUT");r=setTimeout((function(){if(!u[Kn].J){if(u(),!i.onError)throw e;i.onError(e)}}),i.timeout)}i.name="When";var o=z("When-effect",n),u=gt((function(n){Q(!1,t)&&(n.dispose(),r&&clearTimeout(r),o())}),i);return u}function Ut(t,n){var i,r=new Promise((function(r,e){var o=Ht(t,r,m({},n,{onError:e}));i=function(){o(),e("WHEN_CANCELLED")}}));return r.cancel=i,r}function Ft(t){return t[Kn]}function zt(t){return void 0!==t.ut&&t.ut.length>0}function $t(t,n){var i=t.ut||(t.ut=[]);return i.push(n),r((function(){var t=i.indexOf(n);-1!==t&&i.splice(t,1)}))}function Jt(n,i){var r=ut();try{for(var e=[].concat(n.ut||[]),o=0,u=e.length;o<u&&((i=e[o](i))&&!i.type&&t(14),i);o++);return i}finally{st(r)}}function Yt(t){return void 0!==t.st&&t.st.length>0}function Qt(t,n){var i=t.st||(t.st=[]);return i.push(n),r((function(){var t=i.indexOf(n);-1!==t&&i.splice(t,1)}))}function Zt(t,n){var i=ut(),r=t.st;if(r){for(var e=0,o=(r=r.slice()).length;e<o;e++)r[e](n);st(i)}}function tn(t,n,r,e){void 0===r&&(r="ObservableArray"),void 0===e&&(e=!1),i();var o=new Ki(r,n,e,!1);c(o.nt,Kn,o);var u=new Proxy(o.nt,Ci);if(o.v=u,t&&t.length){var s=Z(!0);o.ft(0,0,t),tt(s)}return u}function nn(t,n){"function"==typeof Array.prototype[t]&&(Li[t]=n(t))}function rn(t){return function(){var n=this[Kn];n.at.reportObserved();var i=n.ct(n.nt);return i[t].apply(i,arguments)}}function en(t){return function(n,i){var r=this,e=this[Kn];return e.at.reportObserved(),e.ct(e.nt)[t]((function(t,e){return n.call(i,t,e,r)}))}}function on(t){return function(){var n=this,i=this[Kn];i.at.reportObserved();var r=i.ct(i.nt),e=arguments[0];return arguments[0]=function(t,i,r){return e(t,i,r,n)},r[t].apply(r,arguments)}}function un(t){return u(t)&&Di(t[Kn])}function sn(t,n){var i;if(b(t,Kn))return t;var r=null!=(i=null==n?void 0:n.name)?i:"ObservableObject",e=new Qi(t,new Map,String(r),function(t){var n;return t?null!=(n=t.defaultDecorator)?n:G(t):void 0}(n));return a(t,Kn,e),t}function fn(t){return Yi[t]||(Yi[t]={get:function(){return this[Kn].ht(t)},set:function(n){return this[Kn].vt(t,n)}})}function an(t){return!!u(t)&&Zi(t[Kn])}function cn(t,n,i){var r;null==(r=t.s[Cn])||delete r[i]}function hn(t){gn(ir.prototype,""+t,function(t){return{enumerable:!1,configurable:!0,get:function(){return this[Kn].lt(t)},set:function(n){this[Kn].dt(t,n)}}}(t))}function vn(t){if(t>tr){for(var n=tr;n<t+100;n++)hn(n);tr=t}}function ln(t,n,i){return new ir(t,n,i)}function dn(n,i){if("object"==typeof n&&null!==n){if(un(n))return void 0!==i&&t(23),n[Kn].at;if(Ji(n))return n[Kn];if(Hi(n)){if(void 0===i)return n.bt;var r=n.pt.get(i)||n.yt.get(i);return r||t(25,i,pn(n)),r}if(an(n)){if(!i)return t(26);var o=n[Kn].nt.get(i);return o||t(27,i,pn(n)),o}if(In(n)||ci(n)||wi(n))return n}else if(e(n)&&wi(n[Kn]))return n[Kn];t(28)}function bn(n,i){return n||t(29),void 0!==i?bn(dn(n,i)):In(n)||ci(n)||wi(n)||Hi(n)||Ji(n)?n:n[Kn]?n[Kn]:void t(24,n)}function pn(t,n){var i;if(void 0!==n)i=dn(t,n);else{if(At(t))return t.name;i=an(t)||Hi(t)||Ji(t)?bn(t):dn(t)}return i.tt}function yn(t,n,i){return void 0===i&&(i=-1),function t(n,i,r,o,u){if(n===i)return 0!==n||1/n==1/i;if(null==n||null==i)return!1;if(n!=n)return i!=i;var s=typeof n;if(!e(s)&&"object"!==s&&"object"!=typeof i)return!1;var f=rr.call(n);if(f!==rr.call(i))return!1;switch(f){case"[object RegExp]":case"[object String]":return""+n==""+i;case"[object Number]":return+n!=+n?+i!=+i:0==+n?1/+n==1/i:+n==+i;case"[object Date]":case"[object Boolean]":return+n==+i;case"[object Symbol]":return"undefined"!=typeof Symbol&&Symbol.valueOf.call(n)===Symbol.valueOf.call(i);case"[object Map]":case"[object Set]":r>=0&&r++}n=mn(n),i=mn(i);var a="[object Array]"===f;if(!a){if("object"!=typeof n||"object"!=typeof i)return!1;var c=n.constructor,h=i.constructor;if(c!==h&&!(e(c)&&c instanceof c&&e(h)&&h instanceof h)&&"constructor"in n&&"constructor"in i)return!1}if(0===r)return!1;r<0&&(r=-1),u=u||[];for(var v=(o=o||[]).length;v--;)if(o[v]===n)return u[v]===i;if(o.push(n),u.push(i),a){if((v=n.length)!==i.length)return!1;for(;v--;)if(!t(n[v],i[v],r-1,o,u))return!1}else{var l,d=Object.keys(n);if(v=d.length,Object.keys(i).length!==v)return!1;for(;v--;)if(!b(i,l=d[v])||!t(n[l],i[l],r-1,o,u))return!1}return o.pop(),u.pop(),!0}(t,n,i)}function mn(t){return un(t)?t.slice():v(t)||Hi(t)||l(t)||Ji(t)?Array.from(t.entries()):t}function wn(t){return t[Symbol.iterator]=jn,t}function jn(){return this}Object.defineProperty(exports,"__esModule",{value:!0});var xn={},On=Object.assign,An=Object.getOwnPropertyDescriptor,gn=Object.defineProperty,_n=Object.prototype,Sn=[];Object.freeze(Sn);var Mn={};Object.freeze(Mn);var Vn="undefined"!=typeof Proxy,Nn=Object.toString(),Rn=function(){},kn=void 0!==Object.getOwnPropertySymbols,En="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:kn?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:Object.getOwnPropertyNames,Tn=Object.getOwnPropertyDescriptors||function(t){var n={};return En(t).forEach((function(i){n[i]=An(t,i)})),n},Cn=Symbol("mobx-stored-annotations"),Kn=Symbol("mobx administration"),Ln=function(){function t(t){void 0===t&&(t="Atom"),this.tt=void 0,this.W=!1,this.H=!1,this.X=new Set,this.B=0,this.F=0,this.G=si.T,this.onBOL=void 0,this.onBUOL=void 0,this.tt=t}var n=t.prototype;return n.onBO=function(){this.onBOL&&this.onBOL.forEach((function(t){return t()}))},n.onBUO=function(){this.onBUOL&&this.onBUOL.forEach((function(t){return t()}))},n.reportObserved=function(){return pt(this)},n.reportChanged=function(){dt(),yt(this),bt()},n.toString=function(){return this.tt},t}(),In=h("Atom",Ln),Pn={identity:function(t,n){return t===n},structural:function(t,n){return yn(t,n)},default:function(t,n){return Object.is?Object.is(t,n):t===n?0!==t||1/t==1/n:t!=t&&n!=n},shallow:function(t,n){return yn(t,n,1)}},Dn=A({t:"override",o:function(){return 0},u:function(){t("'"+this.t+"' can only be used with 'makeObservable'")}}),Bn=G(),qn={deep:!0,name:void 0,defaultDecorator:void 0,proxy:!0};Object.freeze(qn);var Gn=D("observable"),Xn=D("observable.ref",{enhancer:M}),Wn=D("observable.shallow",{enhancer:function(t,n,i){return null==t||an(t)||un(t)||Hi(t)||Ji(t)?t:Array.isArray(t)?$n.array(t,{name:i,deep:!1}):s(t)?$n.object(t,void 0,{name:i,deep:!1}):v(t)?$n.map(t,{name:i,deep:!1}):l(t)?$n.set(t,{name:i,deep:!1}):void 0}}),Hn=D("observable.struct",{enhancer:function(t,n){return yn(t,n)?n:t}}),Un=A(Gn);Object.assign(F,Un);var Fn,zn,$n=On(F,{box:function(t,n){var i=H(n);return new oi(t,U(i),i.name,!0,i.equals)},array:function(t,n){var i=H(n);return(!1===pi.useProxies||!1===i.proxy?ln:tn)(t,U(i),i.name)},map:function(t,n){var i=H(n);return new Wi(t,U(i),i.name)},set:function(t,n){var i=H(n);return new $i(t,U(i),i.name)},object:function(t,n,r){return Nt(!1===pi.useProxies||!1===(null==r?void 0:r.proxy)?sn({},r):function(t,n){var r,e;return i(),null!=(e=(r=(t=sn(t,n))[Kn]).v)?e:r.v=new Proxy(t,ki)}({},r),t,n)},ref:A(Xn),shallow:A(Wn),deep:Un,struct:A(Hn)}),Jn=L("computed"),Yn=L("computed.struct",{equals:Pn.structural}),Qn=function(t,n){if(o(n))return g(t,n,Jn);if(s(t))return A(L("computed",t));var i=s(n)?n:{};return i.get=t,i.name||(i.name=t.name||""),new ai(i)};Object.assign(Qn,Jn),Qn.struct=A(Yn);var Zn,ti=0,ni=1,ii=null!=(Fn=null==(zn=An((function(){}),"name"))?void 0:zn.configurable)&&Fn,ri={value:"action",configurable:!0,writable:!1,enumerable:!1};Zn=Symbol.toPrimitive;var ei,oi=function(t){function n(n,i,r,e,o){var u;return void 0===r&&(r="ObservableValue"),void 0===o&&(o=Pn.default),(u=t.call(this,r)||this).enhancer=void 0,u.tt=void 0,u.equals=void 0,u.wt=!1,u.ut=void 0,u.st=void 0,u.jt=void 0,u.dehancer=void 0,u.enhancer=i,u.tt=r,u.equals=o,u.jt=i(n,void 0,r),u}w(n,t);var i=n.prototype;return i.dehanceValue=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.set=function(t){(t=this.xt(t))!==pi.UNCHANGED&&this.Ot(t)},i.xt=function(t){if(zt(this)){var n=Jt(this,{object:this,type:Ti,newValue:t});if(!n)return pi.UNCHANGED;t=n.newValue}return t=this.enhancer(t,this.jt,this.tt),this.equals(this.jt,t)?pi.UNCHANGED:t},i.Ot=function(t){var n=this.jt;this.jt=t,this.reportChanged(),Yt(this)&&Zt(this,{type:Ti,object:this,newValue:t,oldValue:n})},i.get=function(){return this.reportObserved(),this.dehanceValue(this.jt)},i.At=function(t){return $t(this,t)},i.gt=function(t,n){return n&&t({observableKind:"value",debugObjectName:this.tt,object:this,type:Ti,newValue:this.jt,oldValue:void 0}),Qt(this,t)},i.raw=function(){return this.jt},i.toJSON=function(){return this.get()},i.toString=function(){return this.tt+"["+this.jt+"]"},i.valueOf=function(){return d(this.get())},i[Zn]=function(){return this.valueOf()},n}(Ln),ui=h("ObservableValue",oi);ei=Symbol.toPrimitive;var si,fi,ai=function(){function n(n){this.R=si.T,this.L=[],this.I=null,this.H=!1,this.W=!1,this.X=new Set,this.B=0,this.D=0,this.F=0,this.G=si.k,this.P=0,this.jt=new hi(null),this.tt=void 0,this._t=void 0,this.St=!1,this.Mt=!1,this.derivation=void 0,this.Vt=void 0,this.ot=fi.NONE,this.Nt=void 0,this.Rt=void 0,this.kt=void 0,this.Et=void 0,this.onBOL=void 0,this.onBUOL=void 0,n.get||t(31),this.derivation=n.get,this.tt=n.name||"ComputedValue",n.set&&(this.Vt=z("ComputedValue-setter",n.set)),this.Rt=n.equals||(n.compareStructural||n.struct?Pn.structural:Pn.default),this.Nt=n.context,this.kt=!!n.requiresReaction,this.Et=!!n.keepAlive}var i=n.prototype;return i.q=function(){!function(t){t.G===si.k&&(t.G=si.K,t.X.forEach((function(t){t.R===si.k&&(t.R=si.K,t.q())})))}(this)},i.onBO=function(){this.onBOL&&this.onBOL.forEach((function(t){return t()}))},i.onBUO=function(){this.onBUOL&&this.onBUOL.forEach((function(t){return t()}))},i.get=function(){if(this.St&&t(32,this.tt,this.derivation),0!==pi.inBatch||0!==this.X.size||this.Et){if(pt(this),it(this)){var n=pi.trackingContext;this.Et&&!n&&(pi.trackingContext=this),this.trackAndCompute()&&function(t){t.G!==si.C&&(t.G=si.C,t.X.forEach((function(n){n.R===si.K?n.R=si.C:n.R===si.k&&(t.G=si.k)})))}(this),pi.trackingContext=n}}else it(this)&&(this.Tt(),dt(),this.jt=this.Ct(!1),bt());var i=this.jt;if(nt(i))throw i.cause;return i},i.set=function(n){if(this.Vt){this.Mt&&t(33,this.tt),this.Mt=!0;try{this.Vt.call(this.Nt,n)}finally{this.Mt=!1}}else t(34,this.tt)},i.trackAndCompute=function(){var t=this.jt,n=this.R===si.T,i=this.Ct(!0),r=n||nt(t)||nt(i)||!this.Rt(t,i);return r&&(this.jt=i),r},i.Ct=function(t){this.St=!0;var n,i=Z(!1);if(t)n=rt(this,this.derivation,this.Nt);else if(!0===pi.disableErrorBoundaries)n=this.derivation.call(this.Nt);else try{n=this.derivation.call(this.Nt)}catch(t){n=new hi(t)}return tt(i),this.St=!1,n},i.U=function(){this.Et||(et(this),this.jt=void 0)},i.gt=function(t,n){var i=this,r=!0,e=void 0;return gt((function(){var o=i.get();if(!r||n){var u=ut();t({observableKind:"computed",debugObjectName:i.tt,type:Ti,object:i,newValue:o,oldValue:e}),st(u)}r=!1,e=o}))},i.Tt=function(){},i.toString=function(){return this.tt+"["+this.derivation.toString()+"]"},i.valueOf=function(){return d(this.get())},i[ei]=function(){return this.valueOf()},n}(),ci=h("ComputedValue",ai);!function(t){t[t.T=-1]="NOT_TRACKING_",t[t.k=0]="UP_TO_DATE_",t[t.K=1]="POSSIBLY_STALE_",t[t.C=2]="STALE_"}(si||(si={})),function(t){t[t.NONE=0]="NONE",t[t.LOG=1]="LOG",t[t.BREAK=2]="BREAK"}(fi||(fi={}));var hi=function(t){this.cause=void 0,this.cause=t},vi=["mobxGuid","spyListeners","enforceActions","computedRequiresReaction","reactionRequiresObservable","observableRequiresReaction","allowStateReads","disableErrorBoundaries","runId","UNCHANGED","useProxies"],li=function(){this.version=6,this.UNCHANGED={},this.trackingDerivation=null,this.trackingContext=null,this.runId=0,this.mobxGuid=0,this.inBatch=0,this.pendingUnobservations=[],this.pendingReactions=[],this.isRunningReactions=!1,this.allowStateChanges=!1,this.allowStateReads=!0,this.enforceActions=!0,this.spyListeners=[],this.globalReactionErrorHandlers=[],this.computedRequiresReaction=!1,this.reactionRequiresObservable=!1,this.observableRequiresReaction=!1,this.disableErrorBoundaries=!1,this.suppressReactionErrors=!1,this.useProxies=!0,this.verifyProxies=!1,this.safeDescriptors=!0},di=!0,bi=!1,pi=function(){var i=n();return i.__mobxInstanceCount>0&&!i.__mobxGlobals&&(di=!1),i.__mobxGlobals&&i.__mobxGlobals.version!==(new li).version&&(di=!1),di?i.__mobxGlobals?(i.__mobxInstanceCount+=1,i.__mobxGlobals.UNCHANGED||(i.__mobxGlobals.UNCHANGED={}),i.__mobxGlobals):(i.__mobxInstanceCount=1,i.__mobxGlobals=new li):(setTimeout((function(){bi||t(35)}),1),new li)}(),yi=function(){function t(t,n,i,r){void 0===t&&(t="Reaction"),void 0===r&&(r=!1),this.tt=void 0,this.Kt=void 0,this.Lt=void 0,this.It=void 0,this.L=[],this.I=[],this.R=si.T,this.B=0,this.D=0,this.P=0,this.J=!1,this.Pt=!1,this.Dt=!1,this.Bt=!1,this.ot=fi.NONE,this.tt=t,this.Kt=n,this.Lt=i,this.It=r}var n=t.prototype;return n.q=function(){this.Y()},n.Y=function(){this.Pt||(this.Pt=!0,pi.pendingReactions.push(this),mt())},n.isScheduled=function(){return this.Pt},n.$=function(){if(!this.J){dt(),this.Pt=!1;var t=pi.trackingContext;if(pi.trackingContext=this,it(this)){this.Dt=!0;try{this.Kt()}catch(t){this.qt(t)}}pi.trackingContext=t,bt()}},n.track=function(t){if(!this.J){dt(),this.Bt=!0;var n=pi.trackingContext;pi.trackingContext=this;var i=rt(this,t,void 0);pi.trackingContext=n,this.Bt=!1,this.Dt=!1,this.J&&et(this),nt(i)&&this.qt(i.cause),bt()}},n.qt=function(t){var n=this;if(this.Lt)this.Lt(t,this);else{if(pi.disableErrorBoundaries)throw t;pi.suppressReactionErrors||console.error("[mobx] uncaught error in '"+this+"'",t),pi.globalReactionErrorHandlers.forEach((function(i){return i(t,n)}))}},n.dispose=function(){this.J||(this.J=!0,this.Bt||(dt(),et(this),bt()))},n.Z=function(){var t=this.dispose.bind(this);return t[Kn]=this,t},n.toString=function(){return"Reaction["+this.tt+"]"},n.trace=function(t){void 0===t&&(t=!1),Gt(this,t)},t}(),mi=function(t){return t()},wi=h("Reaction",yi),ji=V("action"),xi=V("action.bound",{bound:!0}),Oi=V("autoAction",{autoAction:!0}),Ai=V("autoAction.bound",{autoAction:!0,bound:!0}),gi=xt(!1);Object.assign(gi,ji);var _i=xt(!0);Object.assign(_i,Oi),gi.bound=A(xi),_i.bound=A(Ai);var Si=function(t){return t()},Mi=0;Et.prototype=Object.create(Error.prototype);var Vi=E("flow"),Ni=E("flow.bound",{bound:!0}),Ri=Object.assign((function(t,n){if(o(n))return g(t,n,Vi);var i=t,r=i.name||"<unnamed flow>",u=function(){var t,n=this,o=arguments,u=++Mi,s=gi(r+" - runid: "+u+" - init",i).apply(n,o),f=void 0,a=new Promise((function(n,i){function o(t){var n;f=void 0;try{n=gi(r+" - runid: "+u+" - yield "+h++,s.next).call(s,t)}catch(t){return i(t)}c(n)}function a(t){var n;f=void 0;try{n=gi(r+" - runid: "+u+" - yield "+h++,s.throw).call(s,t)}catch(t){return i(t)}c(n)}function c(t){if(!e(null==t?void 0:t.then))return t.done?n(t.value):(f=Promise.resolve(t.value)).then(o,a);t.then(c,i)}var h=0;t=i,o(void 0)}));return a.cancel=gi(r+" - runid: "+u+" - cancel",(function(){try{f&&Tt(f);var n=s.return(void 0),i=Promise.resolve(n.value);i.then(Rn,Rn),Tt(i),t(new Et)}catch(n){t(n)}})),a};return u.isMobXFlow=!0,u}),Vi);Ri.bound=A(Ni);var ki={has:function(t,n){return Ft(t).rt(n)},get:function(t,n){return Ft(t).lt(n)},set:function(t,n,i){var r;return!!o(n)&&(null==(r=Ft(t).dt(n,i,!0))||r)},deleteProperty:function(t,n){var i;return!!o(n)&&(null==(i=Ft(t).Gt(n,!0))||i)},defineProperty:function(t,n,i){var r;return null==(r=Ft(t).h(n,i))||r},ownKeys:function(t){return Ft(t).et()},preventExtensions:function(){t(13)}},Ei=Symbol("mobx-keys"),Ti="update",Ci={get:function(t,n){var i=t[Kn];return n===Kn?i:"length"===n?i.Xt():"string"!=typeof n||isNaN(n)?b(Li,n)?Li[n]:t[n]:i.lt(parseInt(n))},set:function(t,n,i){var r=t[Kn];return"length"===n&&r.Wt(i),"symbol"==typeof n||isNaN(n)?t[n]=i:r.dt(parseInt(n),i),!0},preventExtensions:function(){t(15)}},Ki=function(){function n(t,n,i,r){void 0===t&&(t="ObservableArray"),this.Ht=void 0,this.Ut=void 0,this.at=void 0,this.nt=[],this.ut=void 0,this.st=void 0,this.Ft=void 0,this.dehancer=void 0,this.v=void 0,this.zt=0,this.Ht=i,this.Ut=r,this.at=new Ln(t),this.Ft=function(t,i){return n(t,i,"ObservableArray[..]")}}var i=n.prototype;return i.$t=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.ct=function(t){return void 0!==this.dehancer&&t.length>0?t.map(this.dehancer):t},i.At=function(t){return $t(this,t)},i.gt=function(t,n){return void 0===n&&(n=!1),n&&t({observableKind:"array",object:this.v,debugObjectName:this.at.tt,type:"splice",index:0,added:this.nt.slice(),addedCount:this.nt.length,removed:[],removedCount:0}),Qt(this,t)},i.Xt=function(){return this.at.reportObserved(),this.nt.length},i.Wt=function(n){("number"!=typeof n||n<0)&&t("Out of range: "+n);var i=this.nt.length;if(n!==i)if(n>i){for(var r=new Array(n-i),e=0;e<n-i;e++)r[e]=void 0;this.ft(i,0,r)}else this.ft(n,i-n)},i.Jt=function(n,i){n!==this.zt&&t(16),this.zt+=i,this.Ut&&i>0&&vn(n+i+1)},i.ft=function(t,n,i){var r=this,e=this.nt.length;if(void 0===t?t=0:t>e?t=e:t<0&&(t=Math.max(0,e+t)),n=1===arguments.length?e-t:null==n?0:Math.max(0,Math.min(n,e-t)),void 0===i&&(i=Sn),zt(this)){var o=Jt(this,{object:this.v,type:"splice",index:t,removedCount:n,added:i});if(!o)return Sn;n=o.removedCount,i=o.added}if(i=0===i.length?i:i.map((function(t){return r.Ft(t,void 0)})),this.Ut){var u=i.length-n;this.Jt(e,u)}var s=this.Yt(t,n,i);return 0===n&&0===i.length||this.Qt(t,i,s),this.ct(s)},i.Yt=function(t,n,i){var r;if(i.length<1e4)return(r=this.nt).splice.apply(r,[t,n].concat(i));var e=this.nt.slice(t,t+n),o=this.nt.slice(t+n);this.nt.length=t+i.length-n;for(var u=0;u<i.length;u++)this.nt[t+u]=i[u];for(var s=0;s<o.length;s++)this.nt[t+i.length+s]=o[s];return e},i.Zt=function(t,n,i){var r=!this.Ht&&!1,e=Yt(this),o=e||r?{observableKind:"array",object:this.v,type:Ti,debugObjectName:this.at.tt,index:t,newValue:n,oldValue:i}:null;this.at.reportChanged(),e&&Zt(this,o)},i.Qt=function(t,n,i){var r=!this.Ht&&!1,e=Yt(this),o=e||r?{observableKind:"array",object:this.v,debugObjectName:this.at.tt,type:"splice",index:t,removed:i,added:n,removedCount:i.length,addedCount:n.length}:null;this.at.reportChanged(),e&&Zt(this,o)},i.lt=function(t){if(t<this.nt.length)return this.at.reportObserved(),this.$t(this.nt[t]);console.warn("[mobx.array] Attempt to read an array index ("+t+") that is out of bounds ("+this.nt.length+"). Please check length first. Out of bound indices will not be tracked by MobX")},i.dt=function(n,i){var r=this.nt;if(n<r.length){var e=r[n];if(zt(this)){var o=Jt(this,{type:Ti,object:this.v,index:n,newValue:i});if(!o)return;i=o.newValue}(i=this.Ft(i,e))!==e&&(r[n]=i,this.Zt(n,i,e))}else n===r.length?this.ft(n,0,[i]):t(17,n,r.length)},n}(),Li={clear:function(){return this.splice(0)},replace:function(t){var n=this[Kn];return n.ft(0,n.nt.length,t)},toJSON:function(){return this.slice()},splice:function(t,n){for(var i=arguments.length,r=new Array(i>2?i-2:0),e=2;e<i;e++)r[e-2]=arguments[e];var o=this[Kn];switch(arguments.length){case 0:return[];case 1:return o.ft(t);case 2:return o.ft(t,n)}return o.ft(t,n,r)},spliceWithArray:function(t,n,i){return this[Kn].ft(t,n,i)},push:function(){for(var t=this[Kn],n=arguments.length,i=new Array(n),r=0;r<n;r++)i[r]=arguments[r];return t.ft(t.nt.length,0,i),t.nt.length},pop:function(){return this.splice(Math.max(this[Kn].nt.length-1,0),1)[0]},shift:function(){return this.splice(0,1)[0]},unshift:function(){for(var t=this[Kn],n=arguments.length,i=new Array(n),r=0;r<n;r++)i[r]=arguments[r];return t.ft(0,0,i),t.nt.length},reverse:function(){return pi.trackingDerivation&&t(37,"reverse"),this.replace(this.slice().reverse()),this},sort:function(){pi.trackingDerivation&&t(37,"sort");var n=this.slice();return n.sort.apply(n,arguments),this.replace(n),this},remove:function(t){var n=this[Kn],i=n.ct(n.nt).indexOf(t);return i>-1&&(this.splice(i,1),!0)}};nn("concat",rn),nn("flat",rn),nn("includes",rn),nn("indexOf",rn),nn("join",rn),nn("lastIndexOf",rn),nn("slice",rn),nn("toString",rn),nn("toLocaleString",rn),nn("every",en),nn("filter",en),nn("find",en),nn("findIndex",en),nn("flatMap",en),nn("forEach",en),nn("map",en),nn("some",en),nn("reduce",on),nn("reduceRight",on);var Ii,Pi,Di=h("ObservableArrayAdministration",Ki),Bi={},qi="add";Ii=Symbol.iterator,Pi=Symbol.toStringTag;var Gi,Xi,Wi=function(){function n(n,i,r){void 0===i&&(i=S),void 0===r&&(r="ObservableMap"),this.Ft=void 0,this.tt=void 0,this[Kn]=Bi,this.pt=void 0,this.yt=void 0,this.bt=void 0,this.ut=void 0,this.st=void 0,this.dehancer=void 0,this.Ft=i,this.tt=r,e(Map)||t(18),this.bt=_("ObservableMap.keys()"),this.pt=new Map,this.yt=new Map,this.merge(n)}var i=n.prototype;return i.rt=function(t){return this.pt.has(t)},i.has=function(t){var n=this;if(!pi.trackingDerivation)return this.rt(t);var i=this.yt.get(t);if(!i){var r=i=new oi(this.rt(t),M,"ObservableMap.key?",!1);this.yt.set(t,r),Mt(r,(function(){return n.yt.delete(t)}))}return i.get()},i.set=function(t,n){var i=this.rt(t);if(zt(this)){var r=Jt(this,{type:i?Ti:qi,object:this,newValue:n,name:t});if(!r)return this;n=r.newValue}return i?this.tn(t,n):this.nn(t,n),this},i.delete=function(t){var n=this;if(zt(this)&&!Jt(this,{type:"delete",object:this,name:t}))return!1;if(this.rt(t)){var i=Yt(this),r=i?{observableKind:"map",debugObjectName:this.tt,type:"delete",object:this,oldValue:this.pt.get(t).jt,name:t}:null;return Wt((function(){n.bt.reportChanged(),n.in(t,!1),n.pt.get(t).Ot(void 0),n.pt.delete(t)})),i&&Zt(this,r),!0}return!1},i.in=function(t,n){var i=this.yt.get(t);i&&i.Ot(n)},i.tn=function(t,n){var i=this.pt.get(t);if((n=i.xt(n))!==pi.UNCHANGED){var r=Yt(this),e=r?{observableKind:"map",debugObjectName:this.tt,type:Ti,object:this,oldValue:i.jt,name:t,newValue:n}:null;i.Ot(n),r&&Zt(this,e)}},i.nn=function(t,n){var i=this;Wt((function(){var r=new oi(n,i.Ft,"ObservableMap.key",!1);i.pt.set(t,r),n=r.jt,i.in(t,!0),i.bt.reportChanged()}));var r=Yt(this);r&&Zt(this,r?{observableKind:"map",debugObjectName:this.tt,type:qi,object:this,name:t,newValue:n}:null)},i.get=function(t){return this.has(t)?this.$t(this.pt.get(t).get()):this.$t(void 0)},i.$t=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.keys=function(){return this.bt.reportObserved(),this.pt.keys()},i.values=function(){var t=this,n=this.keys();return wn({next:function(){var i=n.next(),r=i.done;return{done:r,value:r?void 0:t.get(i.value)}}})},i.entries=function(){var t=this,n=this.keys();return wn({next:function(){var i=n.next(),r=i.done,e=i.value;return{done:r,value:r?void 0:[e,t.get(e)]}}})},i[Ii]=function(){return this.entries()},i.forEach=function(t,n){for(var i,r=O(this);!(i=r()).done;){var e=i.value;t.call(n,e[1],e[0],this)}},i.merge=function(n){var i=this;return Hi(n)&&(n=new Map(n)),Wt((function(){s(n)?function(t){var n=Object.keys(t);if(!kn)return n;var i=Object.getOwnPropertySymbols(t);return i.length?[].concat(n,i.filter((function(n){return _n.propertyIsEnumerable.call(t,n)}))):n}(n).forEach((function(t){return i.set(t,n[t])})):Array.isArray(n)?n.forEach((function(t){return i.set(t[0],t[1])})):v(n)?(n.constructor!==Map&&t(19,n),n.forEach((function(t,n){return i.set(n,t)}))):null!=n&&t(20,n)})),this},i.clear=function(){var t=this;Wt((function(){ot((function(){for(var n,i=O(t.keys());!(n=i()).done;)t.delete(n.value)}))}))},i.replace=function(n){var i=this;return Wt((function(){for(var r,e=function(n){if(v(n)||Hi(n))return n;if(Array.isArray(n))return new Map(n);if(s(n)){var i=new Map;for(var r in n)i.set(r,n[r]);return i}return t(21,n)}(n),o=new Map,u=!1,f=O(i.pt.keys());!(r=f()).done;){var a=r.value;if(!e.has(a))if(i.delete(a))u=!0;else{var c=i.pt.get(a);o.set(a,c)}}for(var h,l=O(e.entries());!(h=l()).done;){var d=h.value,b=d[0],p=d[1],y=i.pt.has(b);if(i.set(b,p),i.pt.has(b)){var m=i.pt.get(b);o.set(b,m),y||(u=!0)}}if(!u)if(i.pt.size!==o.size)i.bt.reportChanged();else for(var w=i.pt.keys(),j=o.keys(),x=w.next(),A=j.next();!x.done;){if(x.value!==A.value){i.bt.reportChanged();break}x=w.next(),A=j.next()}i.pt=o})),this},i.toString=function(){return"[object ObservableMap]"},i.toJSON=function(){return Array.from(this)},i.gt=function(t){return Qt(this,t)},i.At=function(t){return $t(this,t)},y(n,[{key:"size",get:function(){return this.bt.reportObserved(),this.pt.size}},{key:Pi,get:function(){return"Map"}}]),n}(),Hi=h("ObservableMap",Wi),Ui={};Gi=Symbol.iterator,Xi=Symbol.toStringTag;var Fi,zi,$i=function(){function n(n,i,r){void 0===i&&(i=S),void 0===r&&(r="ObservableSet"),this.tt=void 0,this[Kn]=Ui,this.pt=new Set,this.at=void 0,this.st=void 0,this.ut=void 0,this.dehancer=void 0,this.Ft=void 0,this.tt=r,e(Set)||t(22),this.at=_(this.tt),this.Ft=function(t,n){return i(t,n,r)},n&&this.replace(n)}var i=n.prototype;return i.$t=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.clear=function(){var t=this;Wt((function(){ot((function(){for(var n,i=O(t.pt.values());!(n=i()).done;)t.delete(n.value)}))}))},i.forEach=function(t,n){for(var i,r=O(this);!(i=r()).done;){var e=i.value;t.call(n,e,e,this)}},i.add=function(t){var n=this;if(zt(this)&&!Jt(this,{type:qi,object:this,newValue:t}))return this;if(!this.has(t)){Wt((function(){n.pt.add(n.Ft(t,void 0)),n.at.reportChanged()}));var i=Yt(this);i&&Zt(this,i?{observableKind:"set",debugObjectName:this.tt,type:qi,object:this,newValue:t}:null)}return this},i.delete=function(t){var n=this;if(zt(this)&&!Jt(this,{type:"delete",object:this,oldValue:t}))return!1;if(this.has(t)){var i=Yt(this),r=i?{observableKind:"set",debugObjectName:this.tt,type:"delete",object:this,oldValue:t}:null;return Wt((function(){n.at.reportChanged(),n.pt.delete(t)})),i&&Zt(this,r),!0}return!1},i.has=function(t){return this.at.reportObserved(),this.pt.has(this.$t(t))},i.entries=function(){var t=0,n=Array.from(this.keys()),i=Array.from(this.values());return wn({next:function(){var r=t;return t+=1,r<i.length?{value:[n[r],i[r]],done:!1}:{done:!0}}})},i.keys=function(){return this.values()},i.values=function(){this.at.reportObserved();var t=this,n=0,i=Array.from(this.pt.values());return wn({next:function(){return n<i.length?{value:t.$t(i[n++]),done:!1}:{done:!0}}})},i.replace=function(n){var i=this;return Ji(n)&&(n=new Set(n)),Wt((function(){Array.isArray(n)||l(n)?(i.clear(),n.forEach((function(t){return i.add(t)}))):null!=n&&t("Cannot initialize set from "+n)})),this},i.gt=function(t){return Qt(this,t)},i.At=function(t){return $t(this,t)},i.toJSON=function(){return Array.from(this)},i.toString=function(){return"[object ObservableSet]"},i[Gi]=function(){return this.values()},y(n,[{key:"size",get:function(){return this.at.reportObserved(),this.pt.size}},{key:Xi,get:function(){return"Set"}}]),n}(),Ji=h("ObservableSet",$i),Yi=Object.create(null),Qi=function(){function n(t,n,i,r){void 0===n&&(n=new Map),void 0===r&&(r=Bn),this.s=void 0,this.nt=void 0,this.tt=void 0,this.rn=void 0,this.bt=void 0,this.st=void 0,this.ut=void 0,this.v=void 0,this.l=void 0,this.en=void 0,this.on=void 0,this.s=t,this.nt=n,this.tt=i,this.rn=r,this.bt=new Ln("ObservableObject.keys"),this.l=s(this.s)}var i=n.prototype;return i.ht=function(t){return this.nt.get(t).get()},i.vt=function(t,n){var i=this.nt.get(t);if(i instanceof ai)return i.set(n),!0;if(zt(this)){var r=Jt(this,{type:Ti,object:this.v||this.s,name:t,newValue:n});if(!r)return null;n=r.newValue}if((n=i.xt(n))!==pi.UNCHANGED){var e=Yt(this),o=e?{type:Ti,observableKind:"object",debugObjectName:this.tt,object:this.v||this.s,oldValue:i.jt,name:t,newValue:n}:null;i.Ot(n),e&&Zt(this,o)}return!0},i.lt=function(t){return pi.trackingDerivation&&!b(this.s,t)&&this.rt(t),this.s[t]},i.dt=function(t,n,i){return void 0===i&&(i=!1),b(this.s,t)?this.nt.has(t)?this.vt(t,n):i?Reflect.set(this.s,t,n):(this.s[t]=n,!0):this.u(t,{value:n,enumerable:!0,writable:!0,configurable:!0},this.rn,i)},i.rt=function(t){if(!pi.trackingDerivation)return t in this.s;this.on||(this.on=new Map);var n=this.on.get(t);return n||(n=new oi(t in this.s,M,"ObservableObject.key?",!1),this.on.set(t,n)),n.get()},i.o=function(n,i){if(!0===i&&(i=this.rn),!1!==i){if(!(n in this.s)){var r;if(null==(r=this.s[Cn])?void 0:r[n])return;t(1,i.t,this.tt+"."+n.toString())}for(var e=this.s;e&&e!==_n;){var o=An(e,n);if(o){var u=i.o(this,n,o,e);if(0===u)return;if(1===u)break}e=Object.getPrototypeOf(e)}cn(this,0,n)}},i.u=function(t,n,i,r){if(void 0===r&&(r=!1),!0===i&&(i=this.rn),!1===i)return this.h(t,n,r);var e=i.u(this,t,n,r);return e&&cn(this,0,t),e},i.h=function(t,n,i){void 0===i&&(i=!1);try{dt();var r=this.Gt(t);if(!r)return r;if(zt(this)){var e=Jt(this,{object:this.v||this.s,name:t,type:qi,newValue:n.value});if(!e)return null;var o=e.newValue;n.value!==o&&(n=m({},n,{value:o}))}if(i){if(!Reflect.defineProperty(this.s,t,n))return!1}else gn(this.s,t,n);this.un(t,n.value)}finally{bt()}return!0},i.m=function(t,n,i,r){void 0===r&&(r=!1);try{dt();var e=this.Gt(t);if(!e)return e;if(zt(this)){var o=Jt(this,{object:this.v||this.s,name:t,type:qi,newValue:n});if(!o)return null;n=o.newValue}var u=fn(t),s={configurable:!pi.safeDescriptors||this.l,enumerable:!0,get:u.get,set:u.set};if(r){if(!Reflect.defineProperty(this.s,t,s))return!1}else gn(this.s,t,s);var f=new oi(n,i,"ObservableObject.key",!1);this.nt.set(t,f),this.un(t,f.jt)}finally{bt()}return!0},i.p=function(t,n,i){void 0===i&&(i=!1);try{dt();var r=this.Gt(t);if(!r)return r;if(zt(this)&&!Jt(this,{object:this.v||this.s,name:t,type:qi,newValue:void 0}))return null;n.name||(n.name="ObservableObject.key"),n.context=this.v||this.s;var e=fn(t),o={configurable:!pi.safeDescriptors||this.l,enumerable:!1,get:e.get,set:e.set};if(i){if(!Reflect.defineProperty(this.s,t,o))return!1}else gn(this.s,t,o);this.nt.set(t,new ai(n)),this.un(t,void 0)}finally{bt()}return!0},i.Gt=function(t,n){if(void 0===n&&(n=!1),!b(this.s,t))return!0;if(zt(this)&&!Jt(this,{object:this.v||this.s,name:t,type:"remove"}))return null;try{var i,r;dt();var e,o=Yt(this),u=this.nt.get(t),s=void 0;if(!u&&o&&(s=null==(e=An(this.s,t))?void 0:e.value),n){if(!Reflect.deleteProperty(this.s,t))return!1}else delete this.s[t];u&&(this.nt.delete(t),u instanceof oi&&(s=u.jt),yt(u)),this.bt.reportChanged(),null==(i=this.on)||null==(r=i.get(t))||r.set(t in this.s),o&&o&&Zt(this,{type:"remove",observableKind:"object",object:this.v||this.s,debugObjectName:this.tt,oldValue:s,name:t})}finally{bt()}return!0},i.gt=function(t){return Qt(this,t)},i.At=function(t){return $t(this,t)},i.un=function(t,n){var i,r,e=Yt(this);e&&e&&Zt(this,e?{type:qi,observableKind:"object",debugObjectName:this.tt,object:this.v||this.s,name:t,newValue:n}:null),null==(i=this.on)||null==(r=i.get(t))||r.set(!0),this.bt.reportChanged()},i.et=function(){return this.bt.reportObserved(),En(this.s)},i.it=function(){return this.bt.reportObserved(),Object.keys(this.s)},n}(),Zi=h("ObservableObjectAdministration",Qi),tr=0,nr=function(){};Fi=nr,zi=Array.prototype,Object.setPrototypeOf?Object.setPrototypeOf(Fi.prototype,zi):void 0!==Fi.prototype.__proto__?Fi.prototype.__proto__=zi:Fi.prototype=zi;var ir=function(t){function n(n,i,r,e){var o;void 0===r&&(r="ObservableArray"),void 0===e&&(e=!1),o=t.call(this)||this;var u=new Ki(r,i,e,!0);if(u.v=j(o),c(j(o),Kn,u),n&&n.length){var s=Z(!0);o.spliceWithArray(0,0,n),tt(s)}return o}w(n,t);var i=n.prototype;return i.concat=function(){this[Kn].at.reportObserved();for(var t=arguments.length,n=new Array(t),i=0;i<t;i++)n[i]=arguments[i];return Array.prototype.concat.apply(this.slice(),n.map((function(t){return un(t)?t.slice():t})))},i[Symbol.iterator]=function(){var t=this,n=0;return wn({next:function(){return n<t.length?{value:t[n++],done:!1}:{done:!0,value:void 0}}})},y(n,[{key:"length",get:function(){return this[Kn].Xt()},set:function(t){this[Kn].Wt(t)}},{key:Symbol.toStringTag,get:function(){return"Array"}}]),n}(nr);Object.entries(Li).forEach((function(t){var n=t[0];"concat"!==n&&a(ir.prototype,n,t[1])})),vn(1e3);var rr=_n.toString;["Symbol","Map","Set"].forEach((function(i){void 0===n()[i]&&t("MobX requires global '"+i+"' to be available or polyfilled")})),"object"==typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__&&__MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({spy:jt,extras:{getDebugName:pn},$mobx:Kn}),exports.$mobx=Kn,exports.FlowCancellationError=Et,exports.ObservableMap=Wi,exports.ObservableSet=$i,exports.Reaction=yi,exports._allowStateChanges=Q,exports._allowStateChangesInsideComputed=Ot,exports._allowStateReadsEnd=at,exports._allowStateReadsStart=ft,exports._autoAction=_i,exports._endAction=Y,exports._getAdministration=bn,exports._getGlobalState=function(){return pi},exports._interceptReads=function(t,n,i){var r;return Hi(t)||un(t)||ui(t)?r=bn(t):an(t)&&(r=bn(t,n)),r.dehancer="function"==typeof n?n:i,function(){r.dehancer=void 0}},exports._isComputingDerivation=function(){return null!==pi.trackingDerivation},exports._resetGlobalState=function(){var t=new li;for(var n in t)-1===vi.indexOf(n)&&(pi[n]=t[n]);pi.allowStateChanges=!pi.enforceActions},exports._startAction=J,exports.action=gi,exports.autorun=gt,exports.comparer=Pn,exports.computed=Qn,exports.configure=function(i){!0===i.isolateGlobalState&&function(){if((pi.pendingReactions.length||pi.inBatch||pi.isRunningReactions)&&t(36),bi=!0,di){var i=n();0==--i.__mobxInstanceCount&&(i.__mobxGlobals=void 0),pi=new li}}();var r,e,o=i.useProxies,u=i.enforceActions;if(void 0!==o&&(pi.useProxies="always"===o||"never"!==o&&"undefined"!=typeof Proxy),"ifavailable"===o&&(pi.verifyProxies=!0),void 0!==u){var s="always"===u?"always":"observed"===u;pi.enforceActions=s,pi.allowStateChanges=!0!==s&&"always"!==s}["computedRequiresReaction","reactionRequiresObservable","observableRequiresReaction","disableErrorBoundaries","safeDescriptors"].forEach((function(t){t in i&&(pi[t]=!!i[t])})),pi.allowStateReads=!pi.observableRequiresReaction,i.reactionScheduler&&(r=i.reactionScheduler,e=mi,mi=function(t){return r((function(){return e(t)}))})},exports.createAtom=_,exports.defineProperty=function(n,i,r){if(an(n))return n[Kn].h(i,r);t(39)},exports.entries=function(n){return an(n)?Pt(n).map((function(t){return[t,n[t]]})):Hi(n)?Pt(n).map((function(t){return[t,n.get(t)]})):Ji(n)?Array.from(n.entries()):un(n)?n.map((function(t,n){return[n,t]})):void t(7)},exports.extendObservable=Nt,exports.flow=Ri,exports.flowResult=function(t){return t},exports.get=function(n,i){if(Dt(n,i))return an(n)?n[Kn].lt(i):Hi(n)?n.get(i):un(n)?n[i]:void t(11)},exports.getAtom=dn,exports.getDebugName=pn,exports.getDependencyTree=function(t,n){return Rt(dn(t,n))},exports.getObserverTree=function(t,n){return kt(dn(t,n))},exports.has=Dt,exports.intercept=function(t,n,i){return e(i)?function(t,n,i){return bn(t,n).At(i)}(t,n,i):function(t,n){return bn(t).At(n)}(t,n)},exports.isAction=At,exports.isBoxedObservable=ui,exports.isComputed=function(t){return Kt(t)},exports.isComputedProp=function(t,n){return Kt(t,n)},exports.isFlow=Ct,exports.isFlowCancellationError=function(t){return t instanceof Et},exports.isObservable=It,exports.isObservableArray=un,exports.isObservableMap=Hi,exports.isObservableObject=an,exports.isObservableProp=function(t,n){return Lt(t,n)},exports.isObservableSet=Ji,exports.keys=Pt,exports.makeAutoObservable=function(t,n,i){if(s(t))return Nt(t,t,n,i);var r=sn(t,i)[Kn];if(!t[Ei]){var e=Object.getPrototypeOf(t),o=new Set([].concat(En(t),En(e)));o.delete("constructor"),o.delete(Kn),a(e,Ei,o)}dt();try{t[Ei].forEach((function(t){return r.o(t,!n||!(t in n)||n[t])}))}finally{bt()}return t},exports.makeObservable=function(t,n,i){var r=sn(t,i)[Kn];dt();try{null!=n||(n=function(t){return b(t,Cn)||a(t,Cn,m({},t[Cn])),t[Cn]}(t)),En(n).forEach((function(t){return r.o(t,n[t])}))}finally{bt()}return t},exports.observable=$n,exports.observe=function(t,n,i,r){return e(i)?function(t,n,i,r){return bn(t,n).gt(i,r)}(t,n,i,r):function(t,n,i){return bn(t).gt(n,i)}(t,n,i)},exports.onBecomeObserved=St,exports.onBecomeUnobserved=Mt,exports.onReactionError=function(t){return pi.globalReactionErrorHandlers.push(t),function(){var n=pi.globalReactionErrorHandlers.indexOf(t);n>=0&&pi.globalReactionErrorHandlers.splice(n,1)}},exports.override=Dn,exports.ownKeys=Bt,exports.reaction=function(t,n,i){function r(){if(l=!1,!p.J){var n=!1;p.track((function(){var i=Q(!1,(function(){return t(p)}));n=v||!b(s,i),d=s,s=i})),(v&&i.fireImmediately||!v&&n)&&a(s,d,p),v=!1}}var e;void 0===i&&(i=Mn);var o,u,s,f=null!=(e=i.name)?e:"Reaction",a=gi(f,i.onError?(o=i.onError,u=n,function(){try{return u.apply(this,arguments)}catch(t){o.call(this,t)}}):n),c=!i.scheduler&&!i.delay,h=_t(i),v=!0,l=!1,d=void 0,b=i.compareStructural?Pn.structural:i.equals||Pn.default,p=new yi(f,(function(){v||c?r():l||(l=!0,h(r))}),i.onError,i.requiresObservable);return p.Y(),p.Z()},exports.remove=function(n,i){an(n)?n[Kn].Gt(i):Hi(n)||Ji(n)?n.delete(i):un(n)?("number"!=typeof i&&(i=parseInt(i,10)),n.splice(i,1)):t(9)},exports.runInAction=Ot,exports.set=function n(i,r,e){if(2!==arguments.length||Ji(i))an(i)?i[Kn].dt(r,e):Hi(i)?i.set(r,e):Ji(i)?i.add(r):un(i)?("number"!=typeof r&&(r=parseInt(r,10)),r<0&&t("Invalid index: '"+r+"'"),dt(),r>=i.length&&(i.length=r+1),i[r]=e,bt()):t(8);else{dt();var o=r;try{for(var u in o)n(i,u,o[u])}finally{bt()}}},exports.spy=jt,exports.toJS=function(t){return function t(n,i){if(null==n||"object"!=typeof n||n instanceof Date||!It(n))return n;if(ui(n)||ci(n))return t(n.get(),i);if(i.has(n))return i.get(n);if(un(n)){var r=qt(i,n,new Array(n.length));return n.forEach((function(n,e){r[e]=t(n,i)})),r}if(Ji(n)){var e=qt(i,n,new Set);return n.forEach((function(n){e.add(t(n,i))})),e}if(Hi(n)){var o=qt(i,n,new Map);return n.forEach((function(n,r){o.set(r,t(n,i))})),o}var u=qt(i,n,{});return Bt(n).forEach((function(r){_n.propertyIsEnumerable.call(n,r)&&(u[r]=t(n[r],i))})),u}(t,new Map)},exports.trace=Gt,exports.transaction=Wt,exports.untracked=ot,exports.values=function(n){return an(n)?Pt(n).map((function(t){return n[t]})):Hi(n)?Pt(n).map((function(t){return n.get(t)})):Ji(n)?Array.from(n.values()):un(n)?n.slice():void t(6)},exports.when=function(t,n,i){return 1===arguments.length||n&&"object"==typeof n?Ut(t,n):Ht(t,n,i||{})};


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],26:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],27:[function(require,module,exports){
assert.notEqual = notEqual
assert.notOk = notOk
assert.equal = equal
assert.ok = assert

module.exports = assert

function equal (a, b, m) {
  assert(a == b, m) // eslint-disable-line eqeqeq
}

function notEqual (a, b, m) {
  assert(a != b, m) // eslint-disable-line eqeqeq
}

function notOk (t, m) {
  assert(!t, m)
}

function assert (t, m) {
  if (!t) throw new Error(m || 'AssertionError')
}

},{}],28:[function(require,module,exports){
var assert = require('assert')

var safeExternalLink = /(noopener|noreferrer) (noopener|noreferrer)/
var protocolLink = /^[\w-_]+:/

module.exports = href

function href (cb, root) {
  assert.notEqual(typeof window, 'undefined', 'nanohref: expected window to exist')

  root = root || window.document

  assert.equal(typeof cb, 'function', 'nanohref: cb should be type function')
  assert.equal(typeof root, 'object', 'nanohref: root should be type object')

  window.addEventListener('click', function (e) {
    if ((e.button && e.button !== 0) ||
      e.ctrlKey || e.metaKey || e.altKey || e.shiftKey ||
      e.defaultPrevented) return

    var anchor = (function traverse (node) {
      if (!node || node === root) return
      if (node.localName !== 'a' || node.href === undefined) {
        return traverse(node.parentNode)
      }
      return node
    })(e.target)

    if (!anchor) return

    if (window.location.protocol !== anchor.protocol ||
        window.location.hostname !== anchor.hostname ||
        window.location.port !== anchor.port ||
      anchor.hasAttribute('data-nanohref-ignore') ||
      anchor.hasAttribute('download') ||
      (anchor.getAttribute('target') === '_blank' &&
        safeExternalLink.test(anchor.getAttribute('rel'))) ||
      protocolLink.test(anchor.getAttribute('href'))) return

    e.preventDefault()
    cb(anchor)
  })
}

},{"assert":27}],29:[function(require,module,exports){
(function (global){(function (){
!function(){function t(){this.table=new Uint16Array(16),this.t=new Uint16Array(288)}function f(f,v){this.source=f,this.sourceIndex=0,this.tag=0,this.v=0,this.M=v,this.J=0,this.o=new t,this.u=new t}var v=new t,b=new t,M=new Uint8Array(30),J=new Uint16Array(30),r=new Uint8Array(30),e=new Uint16Array(30),a=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),n=new t,i=new Uint8Array(320);function o(t,f,v,b){var M,J;for(M=0;M<v;++M)t[M]=0;for(M=0;M<30-v;++M)t[M+v]=M/v|0;for(J=b,M=0;M<30;++M)f[M]=J,J+=1<<t[M]}var s=new Uint16Array(16);function u(t,f,v,b){var M,J;for(M=0;M<16;++M)t.table[M]=0;for(M=0;M<b;++M)t.table[f[v+M]]++;for(t.table[0]=0,J=0,M=0;M<16;++M)s[M]=J,J+=t.table[M];for(M=0;M<b;++M)f[v+M]&&(t.t[s[f[v+M]]++]=M)}function c(t){t.v--||(t.tag=t.source[t.sourceIndex++],t.v=7);var f=1&t.tag;return t.tag>>>=1,f}function h(t,f,v){if(!f)return v;for(;t.v<24;)t.tag|=t.source[t.sourceIndex++]<<t.v,t.v+=8;var b=t.tag&65535>>>16-f;return t.tag>>>=f,t.v-=f,b+v}function d(t,f){for(;t.v<24;)t.tag|=t.source[t.sourceIndex++]<<t.v,t.v+=8;var v=0,b=0,M=0,J=t.tag;do{b=2*b+(1&J),J>>>=1,++M,v+=f.table[M],b-=f.table[M]}while(b>=0);return t.tag=J,t.v-=M,f.t[v+b]}function w(t,f,v){var b,M,J,r,e,o;for(b=h(t,5,257),M=h(t,5,1),J=h(t,4,4),r=0;r<19;++r)i[r]=0;for(r=0;r<J;++r){var s=h(t,3,0);i[a[r]]=s}for(u(n,i,0,19),e=0;e<b+M;){var c=d(t,n);switch(c){case 16:var w=i[e-1];for(o=h(t,2,3);o;--o)i[e++]=w;break;case 17:for(o=h(t,3,3);o;--o)i[e++]=0;break;case 18:for(o=h(t,7,11);o;--o)i[e++]=0;break;default:i[e++]=c}}u(f,i,0,b),u(v,i,b,M)}function l(t,f,v){for(;;){var b,a,n,i,o=d(t,f);if(256===o)return 0;if(o<256)t.M[t.J++]=o;else for(b=h(t,M[o-=257],J[o]),a=d(t,v),i=n=t.J-h(t,r[a],e[a]);i<n+b;++i)t.M[t.J++]=t.M[i]}}function y(t){for(var f,v;t.v>8;)t.sourceIndex--,t.v-=8;if((f=256*(f=t.source[t.sourceIndex+1])+t.source[t.sourceIndex])!==(65535&~(256*t.source[t.sourceIndex+3]+t.source[t.sourceIndex+2])))return-3;for(t.sourceIndex+=4,v=f;v;--v)t.M[t.J++]=t.source[t.sourceIndex++];return t.v=0,0}!function(t,f){var v;for(v=0;v<7;++v)t.table[v]=0;for(t.table[7]=24,t.table[8]=152,t.table[9]=112,v=0;v<24;++v)t.t[v]=256+v;for(v=0;v<144;++v)t.t[24+v]=v;for(v=0;v<8;++v)t.t[168+v]=280+v;for(v=0;v<112;++v)t.t[176+v]=144+v;for(v=0;v<5;++v)f.table[v]=0;for(f.table[5]=32,v=0;v<32;++v)f.t[v]=v}(v,b),o(M,J,4,3),o(r,e,2,1),M[28]=0,J[28]=258;var p,Q,O=O;function g(){}O=module;for(var A=new Uint8Array(123),S=25;S>=0;--S)A[48+S]=52+S,A[65+S]=S,A[97+S]=26+S;A[43]=62,A[47]=63,O.wasm=function(t,M){var J,r,e=new f(t,new Uint8Array(116210));do{switch(J=c(e),h(e,2,0)){case 0:r=y(e);break;case 1:r=l(e,v,b);break;case 2:w(e,e.o,e.u),r=l(e,e.o,e.u);break;default:r=-3}if(0!==r)throw Error("Data error")}while(!J);return e.J<e.M.length?"function"==typeof e.M.slice?e.M.slice(0,e.J):e.M.subarray(0,e.J):e.M}((t=>{const f=new Uint8Array(72374);let v,b=!1,M=0;for(let J=0;J<72374;J++)v=t.charCodeAt(J),13!==v&&10!==v&&(61!==v||b?(b&&(b=!1,v-=64),f[M++]=v<42&&v>0?v+214:v-42):b=!0);return f.subarray(0,M)})("5GQ0]-\f-.N2L^\",DJow@1+8z\b?mu[?||<~t\\?&(\t$GVv!h'[Wss^~^H|{sr,AX!{|kz}5?\\~]o(, v:ydXoIWtat=@\t!]p'QsWp|^#la\b=}u N_re__)]\\{e=@^WMwPiSu \b&&^yYN\tt3u\tQ\\O\"^h)DsUQDmWNKzMGh=@bIAyvx)\f|iH~6|bz=@\vvR:Dk6S!\by+l\v=M'#&du\tA=@=J%'#\tGy9%\tGy$\"+Yao$3yvPey*=JSR1;su(u4d7=Mfq[}/w{C:Wpr0^?EWL4P/:K7oWg5+&l$\"-dW[(!:,\"1BA-D>v9?_X7sI?gT2H,,``iDw3]h.$\"ndGl*Xfz?-uUd^[>'A!-{U<\fD<7-Sl/Un,Im:0rd*\v6wo\b>l]!Ia/mygN=MT)7(\b\by=@n_k}w%\tBYgUJw9#`!`8_0j{'Q(aouz:B#Lr[a2Y\\uK[aP`qp$=@&uoK5hy})&pTt|xJ&@@BD>9QQ%Do%=}ipqWi=@vH'=@\v`UzE`?A7\v[7tcR6=@Zs5/)V0^jl[B~E7=@gK4!.x\fl8uX'Y2~%nx\\i>*Zmu+wt_\b'$*d/(|.1aByUk{_L7j!^'\v+B,LS@W1Z:iFX\"\faT)|\bxY=@\vv9Z:ECFZP:eg\byYTXHb/r(e\f(&h{%[Q$$H4=J+3=@Ufl.S.V7%-s;!MwO;99VQ}o0Qf'uH 7%ADq#L,dSt9dQ=Jo:a\\+:=@]]s7_O2.bD=@ka.kU_EU!jfB\\@H^`lwu{\"s1NvlR`B8o2GK?Wna0G9l?6~1k#Rj_\v\".*z@<}@/3{w^|iMi$}n'>y$MyK?($x\t\\rD~@VQg.g}p\bOn0F!S)])=J8)_(;x-Ng1OFi_eN<N_?S_y\bXhv-H(\"e!qi[\\cf*km&s sk*wZjCfhq=}qw3RE\fgQ~7Y1dW.hgI'IL'jv:i%6=}=J=@5m9 _7*xdeCD\tw!5l]u +]% -/z(wKTp\"9+Mpb3EJD:P`C=@'Z8]$_D^KxibTC:9')*sISw|RoY//lBD@EXlPr1[N].EsI$'8l_7^n;gIP^n!bw.WYS)BMvP~zRQ|s\bgBW('L{iTI8rnp\tvxX[@h\f;0GlB6g^NGLX-;]N?AQ>_({=JVc$^=@=}-g)prks=M6}c}t=}tn\vK=M,9*N0[=@VP=}RuR)\t$=}Q(&f>@7qXrH?1=}pU-wj_k!#Nx?\f{gqVKF;_7aoN&)/l}C3\\RF_k3}roXkRV^No;2@6ql8J%pibIlFDW[K\t?1(%N3>#?&lao;UACrtf-O\fpm2=}M7}rizfx7!V)#)\f$\"6(&CU\bj[+\\>lFRl5&VE w1o*Tx=M6tz~Z+=@t`iwS[|\v$]QK\t#qYA4j^v\f|@Y!=Jab8hZ`.\t=}$\bpft+t[ZwY=}|Z`=JSZo*;HYQ\tY~tomWp<sy.KfVo-)\"cv,m71@Tt<!5~Xt\boS9_VN=MY{M&WA>uelA{[A1~Yb\bAvQ#K-=@n,{`R^9Xuvb$n}o7~K?b\"N[ZLsIEG#!}F\bv%5Qks;<A=MDct_H\v<JB)=@RPM\b$C'pJ0;m3B70t:QwvPvO(am_FloprqJ\\v=@Rt=}W=}]pY\fs]M$|x4>\vd5`\bdvPV3zn#58_gHzZ]ch gxe?k:QaVo\v=Mn7S\\g8/}Dd.g>V=}:9uoJ -Z74|=}=}@~=})FvdSIlc-=JwHpZM14,W<vI(Eh\\GSzsD-y; >=Mcw,Oh?Ns@DR0\"fV}{Up_\"Lw{qxH@t1Jyu:WLC*D;<b({5=@ZI=}a#hX\fUP`)K348\faI?hYYQ,.2G6nCN#@|\"^gWoS8>6aG@Y4=Jpl=J?9^R}dPv=}NUt7YZKV`#Y@_Fv{.Dc *A}G#}TV`\v jgAU+#4WEsxIPjld?BFC,rX/{@7qA=Mo{v5\b^5;9d0#WJwsg1=}-~U=MD@_fi=}=@axqjT36>Cvw8+\\I+Aed]yE*.[2vf/B]%-0 Q,^?E'i\b(0e]j5~=@H=}?XPRm!=MUPIH6?0;]TB;]!L5Y\\ex/+#|7(LkIZ\\6=}s[=}K=@\vp\vj=Md2E]H52l\f>=M:\"7A?Dz2V8$`H]#/O30Al\fpk4kM0.dwcMz=Jstse#=J@s.`g{YJfc\fm)a)c$'fZV.+1)=@}&X.Nc#Dl>'j8B<=M{ak8Y#lL{Vr!caFHO]S{pZ_\tO$i24U\\l|a=}e)$Q2,YOoM1qxAav|]9x8^CX#U$\b!`;q\tII+v[FqjFY7[A%kq\b:7mTQ\\fjm=@DoN+[T6=J<H7j4TpI-%vK\fl\")d[F@:7ZO't-}=MCp=@bH-wwz>p(;D*2S,\tV&\\r0Z3P{9R`gVR2e02*o,]G7\f1&=@+Y_F>T\feKC=M`e.N\bZb7;Mx@b\v9aU=}|9\vv&K#q+L5aj\t'\tO$t>Q4{>;`,ZV.\tHH|W.]b1GG@lzeU)W9\tI`?1a?\"aY}k9x:J1ph+l.d\t$=}.F@ex7skBR9@>S'R1g'LHtP&0Y`L|Smr\\\\Emz^aR\t1-6B#oyX\f(P9_IC=J+\t]$dW94hxc ''\b&0sS\"\\:u*`=@oiA`Hgwa0V*\vuYDuQ{*;_t=M'od9WXE=Ji>2S.\\O+2/xuX\\EwLx\taZ3#k!U=@E=@8\tL\f=MFX)gf`qVFX)bzWeqEJf0{k g9=@$,Q\fY\bfCQHs=J=}t}Y$wYVg''=@A-'Yxee|,U\\F[SKKPosPNT6xzN^QM`\vGQ&$c\\=JSc+7Bd|\t4J#q=MqY\bQ_/7SgeZ}\\\"ae2N-mA\te6cR^]OLH`Z[xENii\tW6mr];^IznY-d0&[{XjM=MN.X=JM+-!)q0b&]S?+[t.BKLXvjXa1\fP~MJX=MmzZ i:pN7Us9WMERv$<D\"REZmE&#@=J1^+G3@OvIt\bd>';G/P`YX{\t]Nk)4a-p|0EpOp7E>IAaL-\v9Jj['Ti;.k6Ov30#pH;7x>tb[D)\b3W99#0z5%$tFO[X&;xzLdT#8ra;rTZQHW=}}=@4]NR9-RlD#cT%B=JY]Nt%CcR[/n_cc^S!KAMe1}'/D@u\fu,uR6~CRy\f!C>DI1WZG&T\tuHK)!{Fi4R\tp{W*=JQV #=}.I=@0{. 8a c^!$p\vG9YK.P(WV]>\v9uTZ}V2xzW=Jtki*9D#\"!:_,Y7{z;aj.kb-l%+qC3Tvt}9h+5/U3MmuS\b3Rj)L\f2B =M.BY1/x3G$XK33=J5KYx|u=Mg'^-keKTl@*a?w=}HMFcz=};I/BTw=}9c:MFH(O\bA@*q\f=M=}C9Z{P,~UiB%kJ#j=@*=}X\tVL\"4iq_a530dw=}A@t/&pQ&%b^.~C\vca5wg\vt6=@XB|S/}lf5Dw<kW]xZ:m%51=}H^Lt\t+1?/s\tK AnPA$c\v[T`%29bU( <Hw*O=MUGPewr>hE=MKWR%qH<G`OseJ#n}\t\\043i=}@$@6l\t^@VM:PmD\feGW?VSPBsGbtU3[Sky=}j\f*cDcEG01kMM?wJ5Tp=}d?x&5d,PhhR`pLxeRZ\t&A\f3:>'q/NoVC/ U''9\b>\baj=}&=@JK|>S{V%KB\"xqFkb|SZ$w/%\t4A~t8[&7DDq\f=}S{J)tsBU\t;<yZw&4/<!l,3>>(_FVP?H#()'#,fK3IC`&i?JZye%]S=M(=JfB8*#C6{Kd<yCdK\"kwJ4?# \fgW#=@do{nISvUO[JR@A3S=}T(~G+tzNCo8/@Za4@}\"lKJ{;>?`=MFxqb}=M6REQ \bs\vf\b;\fgoE\v:hZDKDfJ~y\f/M?!+}{m/@@; *cY\v=}=M=MK\v=};3jqApJ4_\t4N7l\vC|y;Y\t~UZ/2M1YG3HCHn\"%=};9l=@Ql0m7/<b_4)`8oSH~c%$=JfEn=Mw/@bB*%BF=JZB@-Htt|os-^Ew->\t+94=}6V>*`|I'm\\@OB838_*u-XF/[V|}\\SeHg2X'cWvbA[o(b.5$in5x]gU}~V:;R)ZR0\t|X#q9\\\tuiu&d#[#'^1s1M`hi? Sp=@k=@;=@1a^`k9$&LHAQ/@T|Q~yI=J^Hi:Qb\b'rgh`|S'H#.[=M\v$e\f]epI5'ZH!q\fWUGa\bp#>?\bKjm[Zbpt45r<\vfX4l\f=M{[]Bho;=}2uCaR+q#[J\bo:!\bw99Sm;=@48s%J[o6JZWun7-^<.O4Nk):q{pB}\"AG;K\"'getUEGJ9`ms  \ftY[C?1n@Rk=}HAE0{&p&#$7h[|n WP2aRA#7;>?\bm<%[Z~M5*8[\to)SVUb=M<f7eAVdQ*{UV3/BiM=Mvl+=@Z5tPI[0/&4}\fb>\\t|Kr[I=J;Rd#KWe]\\~}p!,{yw Z&K9#5lQFPy(R;F^0Uv#s}_{Ra=JRqGH`[r2ucQ/}\fTUW=MU\vwgME:wnliBMXQ*A=@bXV1nqG=JLu>(dX'&@Pz-:#X7nh>TuM9Y=Mz1O<=@VsE\vvl2<>A{!xuB8z{8{\"XK_.22DXO5C34bA8ebP@n{'<JJi$tv}MK!=@^Ye'>%\tE%>'A\fH}kO9TPL4=}|3m7o}\bm3%UI$^'hQj`fY8 2``V NpO6 <Toc!i6g?Hxe|=@R%=}gfA\b^=JJ'g`NWClEJr\fOdq[5Q2wx9&e886j=JiB9\fW}rSmyv['RM$O l=M~DxZn=M!_=}^y]ex++diTK`*=M7=J%omN\\_ye%oNTRtL 7gt2=J?@G\tF_Q0uG`2U1\b5\v(\b@z?I.3b3Cm$iFs%14<cv'xm>D=@KC<=}$D0D,j:A.P_2>^ J$,k: \f0+h.z[Nlxz}Hx=MG#8K W}$}S%?^M&,^DRzxoQ6V%0\bNkIeHnld*4V+F\vp`D:3k}P\\M]@l(K>=}3,:=@k?/\f!=}k=}a$J=MqXWmF4BMLvP!Ly^\vwQLC$?\bnbPqvmpWZ=@i6ftAkaAaRoRln6\b%=Jb,>t=}w}z73bJ \b,c(1.EgIG:0{M1f7W/G*+/[4z<\"J,(N2)AUT`Z&H/$C1<%#e.|v?TI7A`}oz^uknl3\"?W^h0NNl!?ovS>5i>=M}7f}QvX]85I``!|_dSC=}(mXk^3JF'\fD}4b+'m26!bPF |CD(%=@Z<As: _\vd&[aX?fV=J=}rW\"Zb/8Gu}&C[${`(El\v=@c|L]S25 p1B\"oQ[=JRwqJ#'r.gf=}=J$\bpo2I=@8HZdlnar~y1Xk#0j>Ncob[N8=@\b(U4cGd'Z\vk'S##7E:ZrdYW~PSq%Fqe^G6*|,x_;M;LZJKp:lV*`\b%]\"xrI\"eQ;=}CF=M\v &(=}(=@i?un9;M{x>\bq<KBf=}=@(=Jgf}]F{#,w~y#fVN3@\t;}Q\foOx9}>I Fv3M{b.FBoTwI=M<iZ`$XVOa7Sk\t4>?4\\=J+{o#<si=JZ|=MmSFZTfQK\tKEjtWv#rtUV#x]b}U}s!|=}nv44'xQ(r&NwWG\f> \ts\\j*@Ul%g\v?qcI}z=M$0r}9\fVvU_\"?~=M%}tWUNum[!smQk\fu&&TYZsLA%g% F<P{a6x\\5~u.}SU_\b7\b4eLWy=@-7AOVXtSJgr${^=J#*S\"f$6 cJp5tMONSVErlEUoV<\bHWHQIDegEo]O?0fy}(s/`V-7B`1Q}cwqtiPPEr0RtXn=}]$\"*v@{B~F[D?.v,A#=M-7|sgQzp\b=Jq\f(\f99__?=JKI=J^=JrG=}{SSV9#s=}\f>qY6hfa5O!_rhYs<\bU#y'iX!S%qT,Cps[Mr>E<- --$+%\bvk/of=}\tm7B GV1J=}`xju87.\f0nYF!SaARi]Gbiu61=MDu/Y,\t<l.^[<|^L4Nu=MO}$GULo\\aFbM>H=@;SMFgft~b471M1Ph\":`=M2>v\t'&lU)K&u( hY`T!=JK(li9j\t\"N\fQP`\\0O3[SG94t+AlsdJSaDf;y+pINuW_h_1qvX\\\";IbG+bn,3Hv8ZZYAbd0|W+=}2\\O>%.k3C6E4c)_tEY7=Jdxn.rUm{{nrD=}AuL!T\\k&pFiV%b0r=Js,WRJJyZkFOu-YM\bR@OQosJu4Y7 iH\v=M\"sP/|*t@JS](Lm\v=JD40_4'\\/O$c8ebDtio7%8R8$OJz0Sk>8f$^~$Ue:90ufDg4no6/Gq%\fny$Rhh0N[vJH[:4&{4K YR?gZ.f\f=J7q)!r>!&\v)`wTCsObE#XW>EZAhqw=@,PF{6 k%8v#V|QTL.&XDX\bn4!8Cia3yE(F/su-\"eC7zXG~bP\"__#,\"mufudi$V'=}K=M\va>xjLISt+6~c0GyW*OHj:hWK<U<L=}iQKHC\tqq>=}I7-k+&V)m?4.rMM&RumVq;'V}DJcmQ\"RH9Qh\fc7[O#iJJ?\b~wxe3c(TgEP^T2;6\\mY6V]d=@^J0W0\b^}9F[cn7e=MHpSjkvf5a=M[AoUW`sKv@=@bc,7&YX=}zW'C.t'9B.(j24h.2?=@].?hU=@m\"1^H0BvH!&'znK'Vw#i[\"Qbm?f]\fl/($\bYHCa H#!#?I)d#y||HC#39y88y8y]Q\vQ5)3Q=}#}\v&b\"=}Blscv/U}\"7-f$$h}uY ^')y&ZQbK(\tv^r#9sc&\tawa bi'$)w=}28J+x|a#fLg~9=@HAD'Cp^44`C?n(MP}|\bI-=M2`5i=@=@%Q=Jl~\tCE+d3[)m#@F0B \v\b\b^+@(\v|%K\f6~a{C^9hRx&&a~-ptk-\fTTzDpu=}25+zG|-#{\t\v]_RrJuF\fSaX]p#:t\f)$$d&+g\vX eP|f(LP%v;+&4p=}\f=}/mz8%:8#1m&}C=@b>34Q4@QQ'=}$88CDH\"7]ih=M=@xi CE-l9:<th6|NVw`^V{\\r=M=}*G=Moqa,uQFgZ+td,f'NF#'Oox=@ lv=M$!jl/|F8@%u<=@!,uNURB2V=}qoQUKg$SbT@6k\t1e;W],!5CSJ]`7n\"A?buDc@/Mq\b-`cXQc;-xg;[Bw6@0qo7k4=}*\"6j=J=},H\fa(]qo[f!'Afo{\"y4m7k7~?$G1l&rdwtww=}0-_.]O8+Q9?p_9;@ULB7cf#%P)>$=@jC'cI2\\8(.=M\bkdvF}H=}z\"6C\v1D=M+}3P%*;!t\bTho>%p9a1<\f\fL=Md:~\t[#08U1P82vd{l.@#NQ)]fqBlin\t;,1?O~f.H0!8^v\v\"\f0]$=M4T}YE]hy@=MRo[\\J+Jb\\d\bL2v%jChr\tQ1jcV]=@_GR\f_\ti>=}b-fMK=}\tD?\t\tj54Csdy#i^X}!@*)=}a#l8-\fq+9JLS_=@)K/e=}$_]]B+$M\\v\f/c Z;iJ!cLA/r<T\tlOnwBBq\\=J JHy~R)a1R8q*gJR&uF1z&Y#*}lC_=}fn:yv88`|<1N:i\v]l&DMWDg2u 0&JPONG`+EpA<a7(\bN=}Hhb>\\4KZ<GJqh|5O|.1{H^s%RX33yjvhc)\fQ\"&@s8h'*sr;sK=MQy^\\f9hM=MPPFZW\tKs)c;\f`\t$u~YTD,I\tX=MJ'\vse\tC5E\f)=MPH9bL~GPal1@*8Ot;5U}=@E2;6i=JT$7fdI=}6ucc*\\R+D\b*\v2G9BSUu&z9Uh`D=MHS]dd;=}uWOn=}<02eeWu76#,PWYc{%NP,hBx0(2'<zh=}bVht|2\tU6r4]I\tMMG=@X=M_Z\t?aRH-u S\vR77c#_DHvT.TE(6O[e0=}=Ms8C@dJ0R\b=MtlJv7u8w\bs\"XqN52GzWgP*0x(UX^GDS8sERr9pSHk(?6YX*GgNZB?O.E\\3c9iQq=} RH\\Y3\"iNl/LQ9~\b9gbI\v@\vs\\spw{ym*~\bH{MsVdr\t[ }o9Kw/D1(@^=}(xUcnhKT5=@y3c=}yu82{J=@=M4!ZF9,K_-fThF#1<Ba@tDh`\\]x~~I\f=J:*;K:& Q/C6Qv0o\fe?bBN&|s3O<6341K1mCmCiQM=J<:z3s1:g.<gS8?%AmU>S\vJ5`la-B$Q=J(L;?gle7cm`V;rF%+hG\b:Nc6U|L2Aq'CFfQi>nRc%=@[lxCi8~sW'L*5$2/Hh\b5r$RQ,egF=M,-9>-e8K2l6EzXb;~jZ,,~=}[R\v`y.o)a)f\t_`,@8K)\bmal08c,>|vh9w*Ap^\"Z&~ u?=MY3}6r\vktgKn\\LA]I5Uq{c\f~/9_-q\"`6{_\tLO0\\\\+:(\vt;r\"&#\\_oc1=Mpf\"8L\bswRZl=JKtG|^ZYZT4N;6&ZM1.sA=J+\vJ@]8,76)M0|CV\vcj=M)g\\F7(_\\6{PEDi{i?yGj6tY[-k/\vBR[sp7`;?8Ax!|k]X\\6=}Ze:\b\tDi_u/b}P=@X!l%H&uC5\"A+tDD\v62dlffd,>=@\\\"{y\\Tzq>F6a(;W/e,bu^K17m\"=}5eAQN\tjfGE>9slN*p7Y|^z?NlOd>2=@tS\\V~%oQ9 u\bO? <=@;o4.rS&I=@V#8GYFStv'{>\v&>OEi:&;r&Rwn7ZdnOisPxu=J&=}*O^ExzbWI-lV[TC^;Q|Lg=}7>C)\f1K/Lj':#-wfA8\f~c,C'5a\ta=Mf \":8xl<v2swGQ+l2|,/FboX;n7=M@KO@uEplU`<t%)!=MKLX\b)'q0^ZKN8?\vrWzl(j$qaS\fWl)J&o4};0HSV'\"Ju'p^[fcwlkqFMjVNiU;=@DsJ~'wf7h\t,wJ]8gCakWAAV?+gu<5y4|9Wp|D`S7e9>XzR+U2Y7vduwb=}|ev5BMMrO~2+k}=Jbs(z7T+{Ro;?#?Qn+ya|b:kG[M*.U\f_[[r]=@*\"p-=J+Rl~=JT@mLao@q 8yP!4HzC$0jFko:_GK0x<F% g =@_T8=J>D!Knk7?8#-/c\\AI%\"@b)T$T8UW^2OwUMqo~qQ)v7HS[qk|A WD=JWb`dw\\,Nk'TjdB5X|X+6hZ#^@:).tyV/=M7RUOS|vk\vo!ub1=M&oR)E\v@1\\a{d\"${Ac_U+zCtb?d\v=}TJ4H4\\p=}> J'iLBu6=}~v}=}&$+lopHRM|~>}%w0.FAa\\n=@;X8x ?u=J\f2\\G=}3QQ&tkvNd<N\vX4U]$r!;lN/RF7@c.Ti!*F\b1>=}A!~g?55.\"i)O%Ohd(*\\ZIsP3Sj\vR3?a&vG8k}1\"'\"=JJLh@ *~=JQ-,Ur\b)!\tZ0#\\Hm'oQ1X\v\v+N!xcbk[?F\v=J3#d.Cb!|SAKH<)?f*&-B[D?OdXBK\tr2\tWkVdEEges>M`tf>;Bh3J\\NR4Yk'+1R&-,4I}m:`gw'P^tRc9\t=@14FtcI*Ufn\";Z\b1?&4>\vIm=MK\\jMGN;.Avq>=M_9Q&mGKL/{.W`5(-g=}d}sX=@%I['\v,Tn:1?^k+I!'6OIMQ3Z/R66ooF<Yy=MS53u[\\[To+Vi-`#XZ!SZZl SS|7S!;G)hK2\"i8xx=@EAAqezN=}(Du -=}^|m}t+rm+^?`a094vS-ExVR?&j`*kn)NCM =@K>-e~{abXW)pC\\R`'HR6iS&Q?X{=M\t|\fp?rMe7\vq48%2y'Qcj\bB=}\"RDq#!f1dIK4IHIW\v=McGUMbS9\bFU|EN4;H7B=J{SL?sGBKM6P{OmX&\\3B4m\tXHi-!%\"/G\b=M\fIQGaUy\"*\"Z$nTd^@Im{\bR f=JQc>S_,1rOQ^_?g1BHO{K\be;8Hp\"`dJw`*5}u%=McpQJ=}=JKzFJgR;Cj\"~e|;\f2\"=MnV]b/?H p\\\t6qP4j2da-{\t#*p o=JuOpklMbcToXc_/D;3cp!He`jp~.`loI>Y!?vWJ|nCV$;prHP<t'-o;WI!w~aOynsg}E$O6S\tPn;*_bDE*T.f/K~\f\v*&Xc=}a0>+\f|xbZ=}BIobQ!4FkQA=}NA\v~4GgN=@w\b.}LWWFr`*0)-|}%K')f\"!X+.M\bQ+#7u@s0Odnp5HZSL1\t\"'#Qn=MMe*z5x5'\b8~^5Zbu 3?IF2y#5i]LPwSimf\\f=M9Q:=M7`],Pe%d%&6Ms'u2'7w\vR{lvl7{mA5nY*i[\tfv\t\"[Z/ac=}>K,YUF_)}@<F1~[H=Jq^p#.Vt3[+=Jfc^8h6E^+:\\;'A[3Ow&+rV,maEbK `{@mM=}XX(V!s8K;.!*=MEm=M<aQr\v=}$Aof;rX8FR<:9!=J9.y\bW*vo]\t=Jjf!JpIqS<0RYb)[.f02b)=@q+^H7ehO~\\^$NF=J(;'\b\\!cO^N`}!8i\t-q\\KI'\vgiYQQf\"Z\\}c9#'b\"nH%-Igc`k'dHm&)M\tS8&Wh>=MeS9Nuk,w=}r+eFZv*!GX\\s~J1N5i]\v.Q+HzjJ?l)TpY9D3-3ouP%[5z^5i\t2\\6*\\*^\tnKR7k1sona0m=JJ-.uko:\\Z\\ \bo_#w\fI!Nuoe2G\b-q.<lp@/9!5}D\fl8n1G~,tsV\b@k=M+bEzqHsV2U!tsyRk?jK-K24NlEB>TR3LgZqL\\gnlk8B:Bi\vT1F/>3Qc76@FCz4sEP~l[y.=JISdjLE}W! HfC?BZnR^0{\\=MT1=@m6/uFmQ\\fT2Rih8m6j6\b\tJ>L{$[#0E]kD\v\v=M/m2qN*d2=@Ax\td?PK*M!esiUoOuZhu)Xk2*oq(U-jc+\fL50h>vl#*o=J9=MZ(jZm;{P3nWI'wEzi?|h\v$6sFyKH8\b+\\OGp7Gpbhq=J1ok\b;OhlI.E_S,7ssK3SknUUo`r&U[?8T95@?0}VW4o[KvRT4EJrWCSryePVhqfv0\"j=}Z/D,Dgq:p+ x{zJ;kS*INf@QP\"SS1\blSZb\t,4:i/\fv*bd8)_a~qcRO*Zl=J\"Z.r2g=@/(67P=M8Kv44\tQ1mU=J2bBJ:Z0*qC5~`1?'.9X$B\\\\*~~1L~k'XO-v1o=Mz2>(h=JFq)\b%nWe.RD \f-=@WFR\tw|=@;\f5.pPE`jT}jax*{kd3Q=J\bry=M3t{5N,X@!WMx%O>\v.X$E=}oMLM)(:F{~_ByixhITIzC^\"2;mco%^>\fQ\\8:&QK\b.O}R]lI,'&f!/U7]]U>ok7aJk/MDlc/4CuP:u:od}:Q2E$nhrJ$nhi3hd|g%U3<iZg&m(D^sB_yo\v6RX$NCS([aj{43[}%=M Vv8~g:Y7wkT 5\\xpB'Ejd<7'tF#,=@\b[eF>qI]#-$5U*pie\fqJYMld=M\\D\fZmkA*4]:!}e7W=}Jq#\bo}A0|v\bze{.evIz#d?\"8Qg?DEhxEz~Ihw<>\brVjc$GfSpQr~a1pcoeB&vaJI`Pb\\=}}@_M>OU1w/8t(7F||\tjMG((dj&YP?5.r_hf=}L^Bx&C:'.OWT/-GUy>=Jru/4\\H ldke7=@XCt@&z^V_mex]P9'r}%@f6%r}g+$uh\\&o5AL?G0n?gZu@n9O'3r>6g}jZv{g]\bI%\bwov\\\\8r>@,F)rEBw$jJ \b;A\vJ\vBRi\"p y`CMK3w#I6KJCy9\"%9k]\t*>2l(ZY*&Z#@t=MKWgAlx?=JdG2{a&Ec&LBO9\fOp=@=@wE]~5@bsBa~\bYY[fsO[p}-i uf#e\tkCw|E ldSZtGD6\fq0-2=}zjO$6/tHC?]*>VzXE\\_C]f$\tQ=@R3n=JcNl{dM!F[3=@Mq'o\"zcXsh~\b!'t%66Uu`Fps|u\t\\p0p'A1rK8N/oYFh.%=J*3TB=@^Rk~+9:=@~x51C_^jx%gH#AL|r{FY}\f.gPkd)p!b\vAau~+00\t%rWCD=J.\tXC|QgK\b3bB&0+L]YObn\fy- iIqfW=M%HcyF\tGW)uGpUOc\b2#v/8znJqoJk|0<JhdoYTBo\bBnT]=Jw8Q^@JJX\\%{<\b{MSxV4x94XdK _H6];b.v/7\vLydlL=}%DIv3\vYd8~j/.7S3% &/_ ;!A[)Y&PU=@o7<>r'=MHi?B{L%%#q8sxh`gmb\fNC!wD_\t/\veE^7^(_eyI\ta4H~3Ea(Y6=J9=MuOx\b8\"qL'Pk\boDV++M.U\"yuG8\fV4W2PAS'GHi5ma~bq#\vna;+SvAW)S}7B|N`pV\\/1h,\tQ7>=@C{t@lw&X{G\\;SB^p\tR'}5y=MxmP9dOvp6.7I5Fy5|XMN[/i^O&3ND-=@s=@gXbdXw`Jtj1aiE3x%+*awlC-L6-!>=MfvX73QwR(e`D\b5@KePQFl[T&q >eomY{HtyY~p:4`wP.Oc!}_fr=M\fK~z8vcy-o\b/%a=J\\\fuvxu5=JC9g+vkue'F9`(=Mgza~fTvAC_|x:Pw)peoeq6bd]%@Fs>/\"6A\\#`D=@kcStiM[mj)\t'b=}:nb4fc{24[N)]@EXqouaTyHe\"K<{0@\fs'#s*!{M%f=MQvx)h,|XixpRo^w\"c,uw`Sr-P/FnEq\bukj1_ajw]=M;L?x/rt\"PhQ^A$D< oWe\"<].OJ[|w=J|}(hy8\vx/AFO1LMZP/\\N\t|lcWmLs*mwBXDd;z2+=@\tRU=}N,W>W\b#GY=@LGb(tQ{|i4MMND+&Ay`HI#=@\\mV\v=@M%nIc=@t`E8'+M9{O=}NS\bixWeC (*LG}\"<B\v33m>vH6Y^^lG?\"?\"?\"?\"?\"=MuE@uE@6g&@e_S/nNWT'1>r=@7Jq!|q\\#x=M.Nr.=MPp..=M.3Y0r.*U/0TLJ&=Jq=@vj6e\f3d3.&r.=M3PM_=}hG`fy%D\t`3@_+t9JAtZuM/WON}C_O?t'KF9>Z=}^A3!c31>@%2~[L0n\b/v8\v}4-y@8qeyX)h_Bc >9hap\bNB_{>LWqg;_ .enUF@,uM'.Eo%w\t+Ah]9PA9=}!&**<r=}(\\6*%BRdH{c:<5I/aeq\bm(&:@bT&(\v)I(RU/Sgcz|dY79.Ehh|7w[01dvQ!=@V\f^[}*va=}B5x\b5>7qc~Z!ppS8JDw~q9Ev.SD/L;P=}9rRRW=@&/id<pi<1ld5+LR<f\b(\b(&#)]qBWR^#3FQ#*eZfIEN+Zbq40WTOQ~VNRLaMaN\b&5E}&6D1Njbq;7]+aB=J}<\"\\YqE|fmSA\\i2~.V2gAjse3BOfO=}Bl,\t[X;U:d^l\b@=@O/}u[/OV$[3W6h{[@0vC|;'g52~^'#u1<=MaHXXc_Y_N$'E}l:EG&Yf]u%QDa\"'\t#,J`OwKN9=@i\t\bz8E~\vvbe\t=@n&zup>+5%y$SwC9\\LcIOU@8:U=J*k=M{5=Jsj=JBlg3xo{>XZ+*wEe*z5pEuUq+z=MR'%/z`~=M,<\fo\"v=J\bVz&*@\\.s04BE&Laf?4g--ZAh[yZJ<aJ!` %B\tNFz\t3W#'rXqlwEAy.d.6fd{go4P=}%gR+!6ww$;W3_I=@/D4v#wI+jt!XZM]J/f3|jc(#`mjL!'zdj {gGq=ME9ZdLz6k0nZ9 parsH4[8w 9w}VQ~kf\b=J4*I.qO;DLucP:4brd_9Am&Ishjm\b<hO2s:=}\v=Jqofr\t\v(Pf|e$;&qTnV\"&J_VLskYw7\bnj?5M\"mT1w=M2p95&4hYbRFq;F5X|GfIxGJnlI`e9L;{c\"7b>^e3\bt- F0O\f}(Q\vboUME;r6n74[W+Q,?$z)(QmvUK\tn\vrUWXZlPy'Z;[ysf\b-rmo\v[V6dVAw\"y[<Rh!sL@fuBGoEO\\v1DO\b<=@noH\bzP8L9`nBVDb'C&.^su:o\v:\fonHOFh|@ l>dl6[>=@4OdvS885h5#>Sl\"^x}XZW0dO\\EF]YAj~^:&$x@rl9\v\\Gbyhfx<C@E'&M-=}jB9''4)4/[/\v/zb--~dSL0.ya'4x\\/25/X*\v(AE=M#Q1rCF`whuJS)pqX0`\b=@AcUOj+FE<m z`\t#mUW&::zo*vh#3c2'pt\tRoQ%&<&J\"lu(,2+O4S1w.\tI7rRVcxJtt(%VLIbiA$,|xD!![xMorLtYQqw85S3tuz,T\"dF>F8QzrlYscOX=}BF<=@-+@|EjyN|9*\tm<9{.c(\t,iIHr^'KC:`*U;gM=MHf.UIwrqhTPf',HOA\tB=@M\\0=J8]:;|LI_>au(@WdlY>;X@UaI.71@;WeXRu,S4{!R-_n0H6`XvMz=@ftdUEq/KPL=M=Jg2ZE?T\tA:L\fLY)gt?}-%QI$~N5=}nry`/H;1WH(T9Y#rRg'Yx5|RFGy~;v\b~YF=}\f:/KP+xb%]Qr0,Nw.*:{ {ZD,h`vfFcFL=J,lFx|]D\\l;Z@i*q@Qmpu<nq\\|Z\v/ :~JNAN;rNY1w:R\fw3en}T#G1L_Q]\"8jTnT\bABldFKr|0TMr7~?l>t\\=M=}bz~{5t#1Thy>>JyB+>$W},#U,9UTp3g=Jyw=@~_z<#lIfuSgQ\vFaoJVwUfBdh*%eX5Dlvl$?t2jlSUoYy<+{qkwYAbE cXr;L{ ?,{]nT&d}#U3]vjhc\bjk0V0iLB@St];i57>7?]0W=}=JRQd[Tnk^5<'BzR X_RTm[P &X\vH!y0yAsg@~#{+JK\tU=Mn=@HuNwc`4>XM<[72w!&atHt=}e:3$ap'?r~)'z7~i~r*~WjO/CA;^TZ;j=}w$|\b:5em\\s-CfFE>,6?=}4$\\7flOVz7D=JdM6TH8=M=@VTzN,{)Uf<H7=}?%8y@X:V\b*&?-X{Wgnf9fw5^Wf->\f%\\\fGe=MG[9vlK3YCYs_{VX15y=}bI,N]]e/o&.(<)YP#.GSI5--@'Mm~9QSLt&h [A.2-Mp&=}fRl0G<=MJ)]I~5i#3+!Tr<VQujn2=MWs]ltSGY[T/sV 9O[_ 0f'q^SV>W3\t`z\v^\"@#q:st,><g_Th\\BUi]2&<=}f${Dx;c2=}dZh` |8^LNB6wMn-d\vE0/N>%838?L$$ck=JouE-j1p=}b$;>SzZwv\b$zX[Ep/M|hs4{_'n`oph5Rc9p7O9R(5yq}*n6~vQFc\\Dtngo=@;gp^*?uEKsMn#3L=MJ<\tE[qdLfTq|VK-=}\b}OTLIy1pe_V>MUwW5bV+Cwr+\\t\f<{SyxT}qzPbM'ya9?u>+gNRb04~OYy*e3|nwP/!1k(m.S\"*q>r(\v=J0h*It%lB#ZLwkD}ELQgTakC6Q_v n#z9ks)q^2iH8wj6z4F7(^0C5?S\v^\\t\bycQzYrE\t4%am\t%;T}!R=M?\"KU-Jjp&6=MaXD34XQD {{-dOGt-y;0wp#T7cga;\\RL=M=Jw2E/6HJ2Qj)LX<fE-!u*O 5TfOvU&=J!TMEy=@Sr{L1e\\C\"}WsHL}-t5SwFDXQ}8:n8*t2p+=MxW &19J=@-N00e+{\fdxtR/.=J?AiW$,.g0uTJjFk,lxrt8YEI\\uSz+?n5}1E915p[&W.c@@J7U);=JH.T-b$UEJyET=ME=M+#%h//29;!l~{#Y\f2]M!s%N)m[zC9HeoRi^+nhI_RBS^a^E2lD<xiwf!i1=MRK=}oO>oe(%{5-\"q\v\"N-N#_xH6>8)aK\vzcH?m2[e5KSdr1EX}f`!=JG<k9\v}mrT_&!jO5!&Ky-{K$uhzW$q[Xc1_!\\z#UC\f;P\",=@p'6pDa)G&}+|aDt)XU4q8{4k\b\t ej\"h>A(b ib<=M[P=J.][yd3jp+bsp)ud:wjhaCg82{s6\f\\Jxe\"[41CJ_~$\"}O$R:h\b0Cm=J:=}4&'%] RY~kFg-j1MN9=@-fO?=@j/j3T-P}2OAX-MxLi{6.xSMsv]:r-5Dvjs\\\\x>4k\b]5O=}SS*E>TPanSS\"W =@na^36M|MI}~SO\f^cQJEzq3GC\\5l=M26>SE0jMD?+{F}x=M3p;Z7=@o=J=Jt@*Rl=@^/=}\f\bHPD=@)TjY=}|k@W0<oNv$X><pdCwxt4y1\t=}1@Y]N'D]Rg]9)^qf(t>IJJNl,@-No)_z=ML=JJP:8ky\"Y:vT!Hzk!=MgJQB^o[w=}4SL7`~,;&^Ca`TYkQyPxjs\v-9k^<mPo0=}t=J(h-gjR88q\f0L\f]jz\\#v^oar**#S\b\bJ!c3lmuT{Ot4f<O\f\t 5h[`1|x%w{p=}kVPS=J,BvU=@t:UJCzkx\bXr\f\f\v83{:\bM1W\vu:;ouR)\fZ&?\tVX.AavB5r\fG:A6~Sz\f=}ON3~4A\f3hbV<A7@BSzz,+g=@2T<0`/RHJ=}k~8Z=}5dNwl\f=@r}o|f5(*OyUYM.\fM$]es7ZbIe2&7,lNAenWJHtugYkW'R,sz/<\bsfLNm58v'd&\bS^Y`\v\vmz`g.\"_nB5[=}`FK(Y^w5)4N\b^[nGi}Q<:6n/J,B+h8\fZ=MFHb~D,T5\v1cmJ+Jc(^fsR0fx.=}9nC=M{EC.S}!8I@0Qy4\bH&&@+xpnz@U]\fxizE, BX1y\fo-qMOZ6?-%bK;m4c2974con=@#s+S\"a/'v%&\tYH5+\\crc2dC\\W|+(wSIq8f2%aE:3;NJ8G{n1*i11}Lv7N2Q!J%#Fo G4};4dE\"im_UPeh/R[7#S&pmM=@*z4`JSQ\vDYH-Zj6o])\t~{EGC|{bU6D\brgdu%<\"eL\f~Pv@. Lsf-j=@-B57<=}*6\v1-0-$\vO8WJ3=@7JO1]O~[D\tF1<`FC,A]/B>(>rO=J\b0S=JzSuFsJ;9cFJa$8(,v1}[\v?K|f1qj8L/9=@ B^%S#o^jLS,FL;3hf=@%w|E}0Q`L#-_`)=JI\fa3m5D=@u&?]R\tN[xyM$)!{.IZdm\bcMN.??kzj<N2OVRl[1~@0=}?Jc)%\b9!$WKO\\.k_KE3B19pk\vlqWfj'07;xT*U/X$-FsVI251@ux=Jew &jSy|%EXZ\"!Oe[%&Tsol\b zZ2?N^plvQ90B>:5{RWf3~cx+.sr@`J<bY`TvB1isd.VRfQGrj$l:im:av8J\tR<!M?H7sM9dK|>2C`J=}\v)])}xEYL=J6[#(Fb_Aq<,\b/Csq_\\vcUq~Q5=J`fOn-C5<05\vNvs0D<6(:C1[\f=@3@bQ/dtogy#&U8':<o\fM+\f`N>{jYc>u/g+>HFp!L\t0U=ME+QH5J!N|C0}TR1w.?\vbNE/tTve8GX~;fJzer2&\"O7y=}Sau8 X-V)d\f/]kCEUKt6E(_W_=M\\}OCVv=@$[0p=}\bKh9s*T<\\1s(OP\v~3[NO`5JgsVz:y6\bp&)Z{!\\8|Na+EY=}0uAV\f.uVLV)yMQuZxLU2gN 5xzgLGNv6{Z\"{)><t*\fO&)\b\firE')9h6MxPJ&byAoq}')\"t(-2\\=Jk=}UwW+*ckBriLhH[N_S4Tzn\"M\vOM=JmI[=J)k\f@V1+|5'Al+)N*M;xLV6GDSW@zJtx,t@LTinU9uOmQ!~)P'sfDvUZf&ZLi)@@S\f[cQ:tbM\\6TnD)D`O6~g|\\7=}^faGL3$A}>OL<F$=JsQ!=MIQC\f4%=MN)QP)y6pjiHl=Jr,=@`AZX0L)#Jv&w)Pk$N)E42]1\\+g_\f3N=}KGB#.SNcc1:T&_ T7[>s=M\f?Hb::G<\\S+5/K;7f1/r|1+6X+AT=}qQCN}_@\fq05/mr|}J<=}2Y,u-6h</W-3Fa9RS\"{i0KH.\fNrOXBW=@:|}r$i0u.))zKs))]m=MUT9m[]#v>A/ MRR,J5r1@ge,r][/]IpzOdp6a<DTn@.;BP)WQ=MXsmoLk~DnQprQ~5PPmca\v4SHk|-u?uf6O\f(\\`Y9R7VB-=JT\fZ^1}tbP:aw=MJKSC[/Q1v5=J&`:V~~3;9G{@b7?%V\f[MPMa8dY=@?~YcL{KWNxP&ZT.].l=J=}SqjM10/e|OGk8,=Mx/G#Q-CFw+J'vFc=J=}kRE6s?*x/4\vE =};eO`WyuG<e@r!+w26CR4/{Ojz1^2PPx\\F}gq\\kKrr\f9rIns:Q5bzuwi\\wWP4+P&;?~=MsB5L~_\f.(LFmj+=J5,j.'cu,s*JkT<n\tr_JB~jr\fEJHmLGK^gmHwAB<YFkF+ZbKOIB.[sNN5!;@U]q`|?L\f\fY)L\bvz\vW$kquY}8'BnAkjI0E3j)k^2RkDCo2VNI\vF&\\Zqn&=}8>wFjM07+_i9Y,N2MoQs+tf,p1N:{[C|`:d|Or_\v7NfEKjvb,S0;&zX3|=M,-rIa~8J\\=J+}X$LO5$z>BK\vo73be{8s5kw}{,7^Ta1 xLAiJoo ]L7=}|{9-\\iDN7r{j=@j _d%_>~-$lHH>z8[\ffycJ;$R=J<X'yd@<)\t\\ZT,MNuw+).5[(q'=@n'n/n5@z(Yt<l*16][:pxO$)D*Uz8M=@u,E}194kd&M(7l.q]-m\t1vG\f,jb}{E?M7=}a9&K0O\fC2YLEFDu1pe0VBR[xvhVxV0]@9X1\fsV.OhXO<\\^h)4H1t/)aM3CQ>5)[\fK=MPY:y=}q{8m10q0=@c\tTCI=Mp@\vPZkQmfp\v=J@TneGi>.{T4\\:#Y=MS>yxpi|st4f6:3t%%h|\vFF9(}/c5>7AN9&!{>mb_.)tts! r!&(MOQY-/n4H\"-!pFsOLC(%ApXQ/'%pqqx l!XHVk+SRo:=MH'A%R_TY'QqzRG9%|$H/?M{\voIa:obxw]![zW\"^S5i%=@;\t\\\\w]\thOuguo}i|x-#?)!Lt ^m\thSt,e5sygL%(OC=}*$!1&Y7atrw#)l]aTtqKJ ]iywSiHx=J\"Uh.WeYgt$'h&$U_92RPiw\b_cs3\td=Mn=Mp5&hCX]\\Z\t)\b3md'=@FqmM'c?t?>/A\"(z\bV|h|uzlI!!\"]%~\t\t5G$#QSE'hi%9h%C$7(\\#Ab!HiD) G7GGe888~1i4Z=@|Nz?I;Na{{f(\"wUxsIeTLydRy{Qf2E~x\\'%4p) yt`dh01_VIm1'$h&lHz+^u!(%~7`i$(^PB'>>h)0>nI'\bSez\v/i4>(GR}O%uvCbMuSUB#w\\-|i(A%HG!=@Iawj\f\f}jjyefY~vmQY\t\tSE<zQ$'ny=J}OkPw=J5?hxX`C%pbflEBbh(935;BeQ3/5\fIqP/=JG#_71XC0pwT'gkh\v/Uf_Z!\t=M|XfZ:Bidp3`(50[=JFd)ePW\t\vq]\vOD7%-MYuUY4=}\v,-q,w^94\fLfu\"OqYh%vs_e:Y?X>\fUzFr\b;&>RP/afo=@};>a?'t\"=JKA5Yc%=My=J1\bmSF|V9!4M?\f5@(y(Jy.m(TU_#>P\"&|f*#'`|KA>=JC!#6'ta>#c&Ri4tt/H0#P3UUR\",|4IS_Q.yb\b<!058QkiUFFw8{UA-f5[:VR,(UC5Hf%SR~ojA,\vk+Obi\vKwpe\vHH\b\t^>$z\v\v\bT/M6%~Cg\\~b3~%'!Xdttv!j15mw7oV=@O[\t=J=J\f=J_tNiuuu9F<B:QOJvj(?IiS++%Ig'%=Mi&$Mq9'hi(%9ii$=J>I\twi)\t\t\by'KhEVG&f?Q1gI8=J8\bIM1eNBh^msmQOZWI1H7KE=J%po=}FV9 01mfEt-r6h0|8\b\fhZ\")q{c.mp+,#R},JGKY\bOge!K\vcF&4;Tx5DC[w}qI^1B{G?})\"7wHzG[(U;{g#17}u[]b\vq`IbAc(\b]taHg\t(~=}R'Dp'gPAY&d@'glQ=@jf(b27Ed{;^`id8tY%I>PqI63Gb M]&yh#fCC{~X !D\v[OiSb9RUhRb646y\\S)\vq_5;=Mi}kifS$LtKUfA_gt{DP-5V\"66Bz[Npx\v=JgZN\\K!iR3(i@QuVDxSm<tBh\"~@T=@T@g,A0\bzf3xRU<RQ(wbDItRSV~fIWz7Ed\t7O@(WYmr(f/i#\t-1/>5\\^=JE??`5rX4\vSh_YvDR\fj\vR0\"Y#fs@\b,N4KNgTgZYs(\\:\by|~|N@^#TTptQ;c/f26z-wTt3[tts\\WO9k1JlN1i&g)zZitwF/,ls]*bD0y,=JL4aE]f6)03MQVrJyDt\tNN\t3&M);)n>P6JcOIc&kw:W&Z!,z$vb)bqD?TY$\f;(Tw~+rA/k>)* MLnfF+dm3$N,xi.S}\\\fNoU\tMmb`TLR?4nM/1Zs\fi\v7=@@OO6B\f$(\fmhVeWK,cC! _mxH4&5nAh!=J>,&1xwU=@r|{M\\x<\"^Rrjtz_q8!#OC-=J!u=@N=@GthPcZJ*u=J$=@CC{S9=@?yu\t[}%#q^AWS4P@wo&=@2S\fL\"!1!:e9(!>8\ty9\v8(c<Kf@G\bAVu_=J6S28T<G87(j87amdIIk8u'&\\x;iz#i;/20tChbL7gaHkBz|U=@3,,`qxi?|Iy1[R'/\tIX1BCD2E/zY <!T(Z%_DSpmw'`7$!aXH's\\9CNGd>5\b^qQ9le\\[d3tF=MjC9( \bG`bev!*}g7?OWuEdj}YQmV\"pi=}6f$BTU?y=J`A<dj,=JroFU(9e)\t]a9ZEx$f)\b'n<'U}'0ST6A\t#K^tqUI\bV4{9ava~Lk.{mQWv{QT=M~g|$Nj'ihty$\v^'@T~!T8hgN]' &y=}O8Y4hc1~2{ (.yigd\\=@leR\\;\\+9F'[j$ ^p}(Xs732\tKNF8'GCx/<D&syj ((\"=J0r?c|5EEt$Ny\t\b^ot}Af~\b!`wJ-pv&)[xDMgdJt-=@\\eI`Y~OYMO 1hB^AhrLh+ SH|JqQRjg8aaNc:X&# =}Dg&(\td.k]7I0,_#\v <%hAr_7V$#p?g.-&mqydQz_aLlgwrU&gS) ^VNW'\fx#bi9ExsF)C3JrgTpOj6'=MF!FJ7\t*um6!@imp+oR36|Tib~VtyqRU=JdJH;Ny'N\tZ..r}?K2{jRuiQ->5`89jj\f/\t]QSGC)$))Y<+R+Z+V+P+U+P+D0:tZo;oC*+R=}\\?o+REJeJ:31*i.]UJJJyj.Z/L*/+*7-4/D3>0>8^0R4Fz6jIR8Rb\bP,,-*+w0/u4;2.MjLTj]FzGj@,W04FOzgDj`,04r_Pj -G.d6>ba~0M,*0duX,044GPej!H*g,,>cuj\b-.$6/E9JBe(*+~G*#-k-pk=}u:oJJ_J7JWJGJgJ-JMJ=}J]J|++*+c*c,Tl*JkjB3.KIAI2z:z2Zzjj\vj+;fzFnQ\b;Llxpx\"nn\b/CSad=}l*.*kuAr5j{8@F*re5>418WY|**-2jO*Pq.9tz1+h,G(rG*fk0+kj$}**C*T*\"l=M<*2*\v@06C9,BJR*Q^3*XA*M*72=J^,@41+-u/-r#k-*~*uZR.d8$.>6$U+JI=J[3je;j02r0k\f0\\.,=JH.=JX.=J:**e*H*3U5+l|*O*H*8U.=J+=J,A,F.=Jh,=JeeE=JJ9**P*A`QA9G*Aq2B.;?d6'F*@D70f, ,r\b/\b+j\f?*y+A+O**\fg.O.5w$h0g,;vH[00C0KW\v=JH3\vd5\"+m(\vz{~kOt*2Ew}#uW*=MQ&v}\tk15$(|~StBP8Zt{>TwIu}D\\RnIkiVoA|Zjql~VcWcvlcZ,jw|$>RmHq\v{Lyhy?tYuj\v,8|ItFRS}=}W}\t~DnmS#\b>743^jW@}Hd~5Gt3g,H$hj0D|7S#p\b4]N_Yp\vM~5*un\v=@~7$F\v1t\bI\vr(~=}dTDj0AA%1|~\ta\fovNKO:$|iIN2JE69R{Qh8$2t(Btn>h@p}&=MSPv*(Q{S^\tNJ<MS9m:95D9puG=J1,kpJ\t^t}Z86=}>Yx},dsjU|#~Tx_|~XjpI]zeGR\bpQU_\f3Se'q7\fmrFm=M+>Y\\n#?{|@| z=MTPk_x%rt(zWhq/^IucyoG^yl}|GP|]|5MlDRO)6ykXDKwv_V%V(< m{0QY=MVk{r'2mfW=MK!F#3?,<>=ME?D'S\" \\O9qhy!d4d..h=@TU=}R7~fCT\\?5~szY9FWs!G?6p(\tO\bdq$fK>m\tp.\"1`=@xeg7?\t[kq~\\06r1l30pU\\peMSEAzA)T}G;_OQI8!|k(>@{zXz`A{BQrdd]&8Pbv#bm=MHrQ.)lR=@`)V&s4'=M#I\tK#)SxTc\bj]\b0yp5fBh!K, gy=M=@k87=M#3:A$c`4S!GS!\bLh2-@lEw}=}?o7J<0$Tk58}S\t&+T$GI'pCg=M$\f[|qGu8o'XL8I<w{ |s-l_G#s=M|FG\vf3m=@b\"s?x=@10cr}DRr2#VYg~6o~4}pW9~=M_4m\v4!NpiTwi<mxmw5i7!?e\\s'n^RthL3\t#=J%A5\v-A`n/Co`@<C|PRpfvE`wW!Xg\"d!dwt3|l\\1ys9^W2{H??u%gk\tP-!r{} ^87y;uP9WC|].d\\W}hU].4NnDQ AdO'}\fzL!SIt}-WP1LOESVbKhbj6?}M/OkqD`.6_a~QTYecdn\"{,19_{KHYRQW\"iaQE}g_otlBe5MGh1$l$Tu5PQpDYI=Js\\NY]OhdL^2\b\t\b&cQnve&c7U~k!<Stq%qAd 3>\tNHESi [ \b9g9Zo\bEEg''8$~Z&z\vMlYoB%z=@Yfd=}as=Mb8nZbRX\f]UXtH^ZcZ7]\f9][=}cSVc({6f(\"%|N8{0GPCP57YjR3k\"+r?_MZO],lK_+ujN=}{~KG=MR%&Ft4Hv=@M*oRn@aGOR~}ToPk#~c[jT?/=}[Lx?Uoh;fYln;k8=}oI;?K#h;60A-^\\Pu-VJf>+9*.L*l-+w$UlJy;(.\t=J!]b):\t<UL^)^2_@n22;;Tv<;LGJlo2~?\b4/X~?)4>Xj|Uz4,`jUT&F/XTq##F=@Xq\bi\\>6Vm9C&-u|zfu^|Nc?/I`l=}\v~nTOr3?-n[5Wpo};TTl2?zK5Fl'*#Yj4+'q%~%W9zHa/=}J\v>NXk8JFN<wpPM}$q`l{`dSp_QVhn0OP\\R6h3Qka\f>YcDf?~^4Ghvnxn{'Qq\\Ns)rLGsjo\v3R f~=}pb,d+wjE=MlVD!g0d[MDZ8nmYDpKR^}Nnk(U;n.ZF\v2E\bpB$a4xIqEM{NZ.f,\bN^F7g6gB6oL{o2$?J[W2g5n!-;2Id.3jXH+i\vm?'t)1vk!:c>K=}6k5DoKu{izy=Jfz]e7&k!jNIg:WoA!*Eg*]g3#I cwq}9jH8 4$8m8LAW_pO=@R<_jC4]m[!=}DM~zKh7hxZg`sA=@kWdR_sEf4o0<'m{T_$T=M\\$\"Ln,-IO\fDyH4jeRL{8oJ?6<pTz>Im7=JQ\bG){%6]WTZP\t\\789h]51@F'p\ta=@=})l)v8=}C&e%8SaY{Y]U\t\fYZ[m\\y]Iy[`[dsii3cbGgcbW\bHa[m\\x]5D\\hX^Z+a[5\\]uBEB%lha3ubap{HD\\}CQ,p}`E[!au=}=@{=}Bk6v>f54J*&9~[[=M\\mCiS\t\"O]5VPlmH6~g=}ZARZ;Vgd!4'>h%VUF-\vk\v\f58;v$P@\v4UtA3W>B:=@\bS=}0@x@v>:HG;N~SyLPAOMf\"&wq/yC'|\t\f=J19\bpGI\t\\n\"=}y=}x\b\fmY)Qdi[cDGx+`\v(c`#xo^Q\t#1Y(%~ oAY2M\ba9=JA=M\\uM\t)H|{P[/ b7 H`7hDwq *=@j =J{R!0'(;(9b=@J_[_# yM8wQ'TnT\b \vv7eW%kG\t`8SHYK%[3RCOOWrQe=M^k0e{GI w%c1m]A |=}#@=@SC\v!}Au p& =J`=@!=@{X\b%I=MivHaWEY=Mu #=@'E\\'x$-i!&)k\f=M>{q=M|>HD)N\"g&F 2pg/hBUIX?DOctCr=Ja%n}40\b-Y=@t@ZyEU=Jq|FI\\Usi-*X]shpb;(B=JywoS\\c6u4L_`@5\fhGXay1\t6c\f'=}h37c{*/f\tj&p:p1ja'79\f=JH\"Q=}%\b\v\"a%:aQ6H#=JGA'i&m*(#f*F6Q,EJaU2{7k2`.yB6_G=MfV>\f(M2\vZ<`q\vEp\vAZ_DI\veFI<\to=JQ$[rO<o> ]DiI)=M\bbfbKLDS[\"$BO@\v\"C%w{P=J3YW8bf(PPE3W;UQ\fl<d3!t_\f\\9qt=J3S\"TQB\f~pT8v^f]G\b=M<Wu\\OC6fPaa=}9qd\vVfW5A=MQ'\\i\\(\\`\"ZCYcFDb4a4hf/AP9Iux\v]#bNJI=M{7*m/\"p+H*'Rm5lf}K\b:A\vo\";d>Mf_BU8W&[`TOb.gRD}TbYTT=@he?i#f?)=@U3(i>YS}q6d\v\\6V_qbC[=M\"V8=Ma\f?b,i~=J?p/tU1?4ztn_fnZ2A;]LFyyLf=M2qLf(25\tL&&2a(<\v=M2#5L7y%`k?$\tJl=MXz;;RloPqq:HJlo7/XN4pRqMdR^6ToHG8xo)<.Rp9@\vr;V^5l+$c*?q+#\f%fi_9d/De/of0k%^~`Y5P|8/z2\"`f{'^^yTd e/[Srn^#~\\nONJ;7\tFg+sF>[Aqi=MzL4Dks;'^d6?lOpgM\t\vZ^!z)Dp7p=}I1y:~Q*v'^9nhM'QOaN%JTt+ryCIDF{i>/E%3`RDnd5Yr3[B*gqaSgw1G2p\bD\tjTD&q\b\v4WWt0sIl?+^\\I[d\\YhdCyvm7{=MO}4H\\[ wIZI\\pI=Jy]}x\\6c^)ZedU=}Q\\fBnD]I\\zS=M1}z.y]3;N5,=MBOU3=MX}/6u[;x{$Ve~ubl'z\v{\voA4-}5C9\v,MS\vr\b3K\bHIVDA\"$=}g\v#5vm=M\tw=@ Km{^\f<' ['e-EDCioZa6EcN=@o9Q\\`?xs8T'=@hf8`AgDFGC@=@C`P'fzg F\bK8\f=ME# yY&&`i{D'dfHk+ET+6R\v>s/e }e=M/_WsE(QMh8\\B\b#3<5-5Qg`#WHF&'Z$3*5=@9\v1=MA}Q<Cf<\vhbYh9&*VWA0\vrK.iG8[9\f*.@8He1'f~aF\fo=JMNc<E\f=M\"=J,%U@`HYb+@vM+\to=}<B*L8tY}q{DX7r=MPC\"6&Px \vob\\xhCFM1\tx[4]kh4p+\t}SURLL[BITO\"\b<TuXwxP\\>gYT\v\\F6ye{lc8}q=M?,DT=M4&=Mu/X;eY;@L;XR ;\tTIq}Ib`\"GY2c>L^}tFo\t4/<bJ|p9WqA=J\\mST.C\tTpf\vz,-5,^L`In_4o4c\v`]{J-uqMS$nsl=}RP8q6>Hf@VnpJ$R\v2&bR:1(,I`1\"SZunwrjJxr;wq/d\b>_p6`yjwGt~mf>zVUF-%X#=@C'y\vI)`MY\\yy]cyZ!I(]X\\=@ZAZG[q9vy[bD(yeZD]kv~^{#;\v=M_iU3yFSYu%[=}{Bn=@wM.\txU^x@`|2EdUXG8TEXf@Sf]\t8`Y: 19dXm/Yls(9(a]Hh\"F)5obDH=MK=@8Cu_aG(\"\"6'/IH_2)m=MD0If%]=M=J,J2H=Ml(37[r LD\f=Mb=M}yP\fK\"\"Z?i\tP\"6F]=}}P=M&d4@/:YuVdBe=JOTXIW~,U\v4/8n~;hmA)9L*Z/.Uu;!M6Yo\tt;$9m4`n5(>>b3Y=Jr%bNnL\f;tpJ3Q|De ?l#R*O=@ltM{{h:((\\\bFvf=@x<[G[|vO&=}V^%{\v=}yP_\t&$,Q1@F=@M_ x=@Rc$;e &IZ!n8S\f8h=@1FCH9C]IR3NYFsc=M3ch+vw]|&sPF`C/2)^XulI>X4IRTo\"Q;()@&S`{A/W1=}dShj&)>9-8q)&\ted [#Z=M>d()\b[*yF/g$@F))o\bQ+X-17 @\\2#$#16364^HSE<>\\\"{n:b[_gM]etk{so33SC4uTa5+MOvSc\va=J\b\"i(vSmY\b((I_5>c =@(\"g=}![/@e&eXg!a^#x'hEh)=}~Y$'&d& t$RaZQ8\f=MG\b'm2rL^O=J% ;'e3G=Ju\vGWmA#M$eN\f=}$t=J(xdrEe!FimMWbAy<^C9/=}$Nj+>wv7?6}W/d*z]*A!gTmZIXkg?VH5u(\b(CA~*8*Cz'ci8Dx}e[v$4s}<J$xo12*smr_mQ.2}fIlbk,^ZY4=}ZWgCNW^9\f]XljG8?lpd.Pd%+5+Z)5'\tuk.DuJ=MH=Msl>pAn,FkfHl\tK,VnKJ=MO=}j~VghuUkfs5}lnRV@4[Dt@=@:H.HiJ=@=JJg01,$`.LJ7Wfm&;V 2 |tx]-V\\+l<}^ng_q7mzwYEAXLU_\bq {z1o{$BGwGt{=@7wjbJ8zzDq!{;X.|`r,aC9KtX,TC+PVgS?I:DLh@:aFa`(:+MwQ+\b\"-nrGZ;C-Ll^?kdF^f$P* -71mIbxj+tiKfn`:Dok:My,T:4PQ#6M:lyG&-Q\v#/NRe3+g^hTFL$3kpP^A: ;\fRTl`e;K3nr=MkL$4d4N\b,GHY=MR=@w7WmiG?.!|:%VT$TSk(P\bI{\fBS\t/@yl4aK\t@7S\fw!{rF_p@0Zg=}hHHEIYumTm`ngCuOar\fQ=@eH\"m5$ Q&T|=J>ABx\fT/i<?31;\\(_DT<=@0M`(Fd\ve0Pi.S]&6;,!=J=JuC6pd 5\f7X\"J.\vBc6:\v.@kDBlP;-:=};+m:3m\b:;m;Cm\b;+m:3reDm;Cm;*-Y:.-:2-:K=JK0\\}6B*[+C/-\\JE0k66BK0\\J}6jB[+G56.0jq+e6:0jZ@-dkBc68o0<\\B+6Z0j[`-dkC6*0Z+v0-B?K0-K6<,Zu2B_K8- k6>,P[EZ+\bvc!3QO!=}3s.NhIi|H|h||9IYiyL9LILYLiLyLLL9.ni2:<'KO$nuEXi.ni3c/<'OO$vueX19AIQYa8qylMg6kLeesHrrr\brHsss\bsCrrrrCsss392Y2y22222293Y3y333336Vv6Vv8:Jdk2?]n8;LdoB_n!8<NdsRn8=}Pdwbn!302@2P2`2p222222222=@22 203@3P3`3p333\tF3O!QNgJk:s&7N#L|QsrP\v9dyiXNsv3)<#WO=M|QusX9Qn3<'\f4rurLyKns<'TsrP1=@`yIWN.sv3(<WO\"Pu=JsXI#$/wJb6$OwKbF$owL\tbV$wMIcf$wNcv$wOc$wP\tc$wQIb /wRb OwSb owT\tb wUIc wVc&@v=}6%swQBP;63%2%3s2s(juZvyZvmZvqZvuZvyZv\"kZv\"mZv\"oZv\"qZv\"sZv\"uZv\"wZv\"yZvkZvmZvoZvqZvsZvuZvwZvyZv1ZAi.n2;6=}MBP$qi.ni3<6=}'OBP$vZveZ19AIQYaiqyN ^MsD<umP\brHO h|0sUESj=JmNMfqb\b<Hu$UF6N'Cx`np(8QeLmsWi0;sGm(BnN'_x!8t$<G!bOdV9wjkZLKBqc;s$F 20O'@r/=J|o0kL1\\j]W+yP?*w=JaL=M*x41\"u40`|.:3HU:_Fte/3rr,/<51C0|/(:_2&gu=M/U>`j\\0fi1!pq;2+{M\"d@?M=J7-(JMFj=JA0>,Ho=J{'Q0.n0\th{=J0AT:Rwo1:\"\"z)N\"!e\"c(=J1[6DY6?=JvP/9^.i\"s`,h8(:8(=J+|1,y2o6A1\"{F=Jg9J/)3L,=}O8&NBfO>+aP-6#z9afVl/|yZ,1kD5[@m0Nc:6.p_k+Jry9D,|NgkJebVr:L4N^0/C,S*\"J7YNgrRDN1F-*=JJ:t*G0?*q1-y]8B=JfG\"4+xo+J\fAF1P;]TOk)3E}3[e%=Jl\vT@*FZ/H=}t5-JO_RG1^|lzpRFB0 tm6J7-*#80x\\@=Moacx5 jnNzX*G+8+?,cj+W,Q#.=@)m#GT}*#~GCeL>''?!!4!eH~=M[bOZyH|eTu\"Lp/oId>,,#5Az\tQ\tVTmSm53C[X~\t\b\b/-u%GRHZ}0t#?xEG>cvn\t=JC-~X];<Z=@?7_H{d^oI\\n~Phb\brp\v-51[@4jup@g^P-Cj%/vLc4L<|=J3*Ab\t\vl=Mmpq IP(=J+W\foP^\bg\\DCC =@4\\h{%VF?1dr15`fPbgxWHZe/asL~}_t`h3#GVn\b5gAYh] q)f[8\fE9(\"xk/X'R\v0)'d=J|Ot&#C&Yt$)$aI04=@EPM?=@^Em-l)>@%=@_Uq\t&%>>XRm5I=J\fQIRW/1:]K${~t&N$Kt,kMdIgi_\f cc^\vc$yy\ta6sPO840)$bbc@$hDfOi`g!8TIia\\CY`{.2t4}`PMUekp=}'lHn9#&ruA`|$Iw Z`{\"3!,=My{\\i)h(#\fxFi't`W)oP/`3}c/!eG4;hXD\bp8B$\f'oM-S4/_m\\AeNd\"Fgx]<Z<%=MD_Mw\"Wdp8=@{XHH=My9XH)ehC_X#w$\bMq9(~\t\f=Mw!W=M^E|8n-h@ET7irk#@(o%)=JG)\v\t<]`@BU=@9}8hR]<GUB| q$0E\t=@{M,\tW'$wj9u`)d =JQaFUbEE%-u\t}Io5<~@C#%&Y3 l#yG=}7Wp5486>)PSPalQh%Cq@F=@=}!uQ{Y=@(+St1\fHY2sah\f\ve.v/IPovb~\t\fCDuVw'%A97IBq/7t'|=}IFv_V5KxjoyT<r=Mjg#^~#'rl=MHUU@4-)sx)=J$]4z`|'=M,^)Ic_Zyzgu7q\"? \t7P%!icrrT`V$S=@c%K&p=MX\"7YgS=};'|U{.&pAHp-xU>~N)\b#y_Mov;BN%$$9\t\"w1i`7}A\b(cc,<@_or/b(\\w=}7xu\b\tij5`w:g[uYf[\v+m\t]?Pf\"P  |u=J9muy'x$GQvAYYYhV=@WY76Hq\vn#=MV7<NA~#tA~\tbi\tw?51E3x)J\b#eq|-&C@\t9d\b1V,5fQ AW&8?[E>a}B'v=JhA)Yr92)=@d\tD(wiW_=}.xi=@`/v(f9Q(=}c^R6%#9AcaX'\\P^!yOi7=Mt!xRSP\fXg9S{w^]Y7|}Pgn?=}_tu\fs|8QBF3)aq^0nGZK184=@' h5wA#627]~{wZ7a\vXTq$Wtb=J[p=}hu3bc(E&D=MsHe\b[(Ii%by)\bK7a\\=M\tH&6H &z#+ae`W' UhF=M'uv\tEuT8%=J(\t\"\bD$e&%\\(\t\bG){ \b\tXuZ%$>/aV3[ Q0=}p*AyaiCDe97X=@z\b?x']y>#PE_%(mfcK\t\f&M0`_9H\v\vMu$YW=MW)$-!Ai^%Ad)#@^pie8%x\t&_#Wh{@dcG!`Ey\"6(h=M1Gv=}7OPg}8ge;#|bHd\\\"ZxIr#P&)U#=}'h8I&IdT\vg'=}%\f)RQ](x]Vy%_Ub\\ HEG_HXTf<%]Qt>'E9(`M3BNT\\Y\t/h(@ (5dd\v+iY%:$'`h\\d/W'!afpKf?quodYhy^=@af\f&W(Hj=M$]Mqgd!H_P\vbXa[+;IIQ'=JiPeW_lOQ+CQo\vM?vvi}!\v)fa'TJT=@M~yTaXt\vsmO\f>%h@g)s9}9=@ts\\_X\bB/YK\"=J\t)r}N%=@}xa=M(!?W=MS<'n>[&#=MPsa%}x5=@s\b!P~T\" 9TPXB>c=}`}eH6UX!W'k&pMM7)|a#(7@Y&p''D\\YUEyaKq{%G5)vmz@@Uz\f@Le>/Ny\\&3gCO5,Rl\t'uDP|;KNk=J8f(=J;ZWJ*Du>QFfsS@=J/CImh(kOe\"E=}Ax9P<L@!Je\vS&\v&+ReL%h1*\v1*[iT|j(x=}E($bE`,sAJ\vuOB563||/cghGLH2vfhz;DlwM#eb?2QUX*i=MG71TzygYBlH]d&{yCq|DB]btuI=M(3&k3~=@=Ja\fp7Sz9=MPc=M@,*=@\vTG-gk3P7L'1ksLc\f~ uGhF.z\\c*rZv'\vk53U\"nO=@|\"L,D{Hj;(Lg\v2y y-\t|)(`N[\\a[4_2h#41i|-_Wjw642Bq:TFQ0{-=Mx/#g\tekaq2=}=M9QsBFpcvV^VZ42=M@UV=@,k\tl>h]aLub99<,FZr4A|?`v2'R=@chV*#}U=MK'`)\\?|g=}It;Oy=@#k_+F~<=}tE*!6TP9jVL]U4]vv>:=}\\_B4gI6+H, ,'ZB\"=@;FJpv<U=@ wPcU#Y3@<=@%t~ta6D;PASn/;HQz!9)G70$\"Ad=MOdb?\vvkpR\\@UQO=@\v8{GG$}b>jOn(\"H1HiQ~Nzhp<\"r\"]8.:w@+$Y !5jHE1HBy~M*HVf&;WSk`5gxQ\\h&A$iQOu\"JpksQa$HmO5y)pyj|Hmfc55\fK=@B\f5t3J?C6pQa\v3#{-R1x<UStv'D\b/\b=JqZF3NwDE\f?xf{K7p;qJ|^gNnF:(\vk3N_mYI/2abmeQHN\\59sTB=MNz/U\ved$xIo!o\v}{mIh6`=M>0PVQ_&7ac%n'J\tq_ z+tBP_kV)q`]=Mhuvy/a7Vw\b=M{>RhiIvt\"[AS}Mo?EG~DLO!<2g'4 Whga0#{Afq\tc-!]$%6p)}j}=@w1pA?A/`nc(U5T&I2Ov_xz9=Mj.SQ.Bf=@jP,t#)h8uCS(.>^#Sh5h=JpJQL[c<sZzO`y=JL-/<I=}\b\f6dKXR`Z5.3Wg7EHHA\tDIa=@YHt1/nR=}GQ[=@8g^{M\\aOd6=@B{*n&Lhe' \b>Dr7Q=J:=@)Qq'v\\6]Idg0_,209~]Y}8ViS}x_\t(d<C%WDLUr8$6W^ 8w[IQZTUufsB2'6BWVspY[cG1eH,3NP&&=M[_bf~\fjIJ:w`97.w=@]eB Q2*@NE+.i1g&&-Se?v)${pNNXZXNO=@#Br!uf/ohO.wy(`<kb2ZXi+\\^5Ns3dPbhy%[\b*G\b<Bp]?5p GL`glm}R)n8\by@/1\\:XOFjG6i'Tt$v%>}#@cROV\"-k}\vho+i!=JI'$9Gb|I=MFWRO\fE2qXmI]hA,qg\f1]{q@,~\fVHY4Wqi@(SG@'^JHo{[:'{pHA=@YJ6X_\"l:'I(_.wAtIFBdd\vFu7kwv0HY5#dwU.7x(\vfQ?fDY[r!A0pHRmlW\fvfs:# $'.tR/hx[vj\tQT\\J PN2_SUo5Vap/<#!v1~iY>Z7i]7Obw@fWyx|n$$G8cZ=J/6ug-1_<4^Rq:[gwJ\vSs5BJvG|Wdz^b'/)=MYmW[_wVHfa3>0.jL_lZ YuCz&>8Hz|[gv}$ONnS8j?,]+y>.~+\fG;H,>\fr^=JW|W=JDsIy[Xt\f7*=ME;}NFi6s\v#\feiikL=M\\wU\t13VG!\\;v\fF}L[>#9@vf 0kt5g|7=J_3Et> *-)E_/39KSTf\vm=Jkjd|7shVcBy>]\t\v9lRfYDtJ|i1Om0.:7LGqcg=M]w}/#WeX{.0^\b*D9k=@_XM{\vLcY'7=JtzZxT\"4JlipU`=@NO\"\b#8=MlSB1|jbl&BD$',GOY>(u09f$%J/ij\\/svc<rn)Nk\\uby\fntew8=@=}wZDaQdLw\bK=JGt2c{@_\bw)<z]4SyMFBgmYstRP!MR1&E^)%A%]Cl]N=}qHGW\t+\bD0ht!]=@mlI+Z@mS2m_W$\f\v=JE;D\"jr0) \\Qi(.,g\vj\b*\bm@*\vo*C=J5Y$#WFO=}\"b!/:5YA8d6o)Yyx0\bOZ$A'\t)=J6(1"));var $,m,H,I,q,R,k={a:{b:function(t){return Math.cos(t)},a:function(t){return Math.exp(t)},c:function(t,f,v){p.copyWithin(t,f,f+v)},d:function(t){p.length,function(t){throw"OOM"}()}}};WebAssembly.instantiate(O.wasm,k).then((function(t){var f,v=t.instance.exports;$=v.g,m=v.h,H=v.i,I=v.j,q=v.k,R=v.l,v.m,f=v.e.buffer,new Int8Array(f),new Int16Array(f),new Int32Array(f),p=new Uint8Array(f),new Uint16Array(f),new Uint32Array(f),Q=new Float32Array(f),new Float64Array(f),function(t){t.f()}(v),g()}));const T=new Promise((t=>{g=t})),Y=(t,f)=>{const v=new Float32Array(f);let b=0;for(const M of t)v.set(M,b),b+=M.length;return v};class Z{constructor(t,f){this.channelData=t,this.samplesDecoded=f,this.sampleRate=48e3}}class N{constructor(t){this.ready=T,this.onDecode=t.onDecode,this.onDecodeAll=t.onDecodeAll}p(t){const f=I(Float32Array.BYTES_PER_ELEMENT*t);return[f,new Float32Array(Q.buffer,f,t)]}decode(t){if(!(t instanceof Uint8Array))throw Error("Data to decode must be Uint8Array");this.O||(this.O=H());let f,v,b,M,J,r,e,a=[],n=[],i=0;try{const o=11520;[v,b]=this.p(o),[M,J]=this.p(o/2),[r,e]=this.p(o/2);let s,u=65536,c=0;const h=t.byteLength;for(f=I(t.BYTES_PER_ELEMENT*u);c<h;){if(s=Math.min(u,h-c),p.set(t.subarray(c,c+s),f),c+=s,!$(this.O,f,s))throw Error("Could not enqueue bytes for decoding.  You may also have invalid Ogg Opus file.");let b;for(;(b=m(this.O,v,o,M,r))>0;){const t=J.slice(0,b),f=e.slice(0,b);this.onDecode&&this.onDecode(new Z([t,f],b)),this.onDecodeAll&&(a.push(t),n.push(f),i+=b)}if(b<0)throw Error(`libopusfile ${b}: ${{[-1]:"A request did not succeed.",[-3]:"There was a hole in the page sequence numbers (e.g., a page was corrupt or missing).",[-128]:"An underlying read, seek, or tell operation failed when it should have succeeded.",[-129]:"A NULL pointer was passed where one was unexpected, or an internal memory allocation failed, or an internal library error was encountered.",[-130]:"The stream used a feature that is not implemented, such as an unsupported channel family.",[-131]:"One or more parameters to a function were invalid.",[-132]:'A purported Ogg Opus stream did not begin with an Ogg page, a purported header packet did not start with one of the required strings, "OpusHead" or "OpusTags", or a link in a chained file was encountered that did not contain any logical Opus streams.',[-133]:"A required header packet was not properly formatted, contained illegal values, or was missing altogether.",[-134]:"The ID header contained an unrecognized version number.",[-136]:"An audio packet failed to decode properly. This is usually caused by a multistream Ogg packet where the durations of the individual Opus packets contained in it are not all the same.",[-137]:"We failed to find data we had seen before, or the bitstream structure was sufficiently malformed that seeking to the target destination was impossible.",[-138]:"An operation that requires seeking was requested on an unseekable stream.",[-139]:"The first or last granule position of a link failed basic validity checks."}[b]||"Unknown Error"}`)}this.onDecodeAll&&i&&this.onDecodeAll(new Z([Y(a,i),Y(n,i)],i))}catch(o){throw o}finally{R(f),R(v),R(M),R(r)}}free(){this.O&&q(this.O)}}O.OggOpusDecoder=N,"undefined"!=typeof global&&exports&&(module.exports.OggOpusDecoder=N)}();

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],30:[function(require,module,exports){
(function (global){(function (){
const { EventTarget, defineEventAttribute } = require('event-target-shim');
const { detect } = require('detect-browser');
const browser = detect();

const AudioContext = global.AudioContext || global.webkitAudioContext;
const BUFFER_SIZE = 4096;

/**
 * Reference: https://w3c.github.io/mediacapture-record/#mediarecorder-api
 * @extends EventTarget
 */
class OpusMediaRecorder extends EventTarget {
  /**
   * A function that returns the encoder web worker
   * @name workerFactory
   * @function
   * @returns {worker} An instance of ./encoderWorker.js web worker.
   */

  /**
   *
   * @param {MediaStream} stream - The MediaStream to be recorded. This will
   *          be the value of the stream attribute.
   * @param {MediaRecorderOptions} [options] - A dictionary of options to for
   *          the UA instructing how the recording will take part.
   *          options.mimeType, if present, will become the value of mimeType
   *          attribute.
   * @param {Object} [workerOptions] This is a NON-STANDARD options to
   *          configure how to import the web worker .wasm compiled binaries
   *          used for encoding.
   * @param {workerFactory} [workerOptions.encoderWorkerFactory] A factory
   *          function that create a web worker instance of ./encoderWorker.js
   *          and returns it. function(){return new Worker('./encoderWorker.umd.js')}
   *          is used by default. This is NON-STANDARD.
   * @param {string} [workerOptions.OggOpusEncoderWasmPath]
   *          Path of ./OggOpusEncoder.wasm which is used for OGG Opus encoding
   *          by the encoder worker. This is NON-STANDARD.
   * @param {string} [workerOptions.WebMOpusEncoderWasmPath]
   *          Path of ./WebMOpusEncoder.wasm which is used for WebM Opus encoding
   *          by the encoder worker. This is NON-STANDARD.
   */
  constructor (stream, options = {}, workerOptions = {}) {
    const { mimeType, audioBitsPerSecond, videoBitsPerSecond, bitsPerSecond } = options; // eslint-disable-line
    // NON-STANDARD options
    const { encoderWorkerFactory, OggOpusEncoderWasmPath, WebMOpusEncoderWasmPath } = workerOptions;

    super();
    // Attributes for the specification conformance. These have their own getters.
    this._stream = stream;
    this._state = 'inactive';
    this._mimeType = mimeType || '';
    this._audioBitsPerSecond = audioBitsPerSecond || bitsPerSecond;
    /** @type {'inactive'|'readyToInit'|'encoding'|'closed'} */
    this.workerState = 'inactive';

    // Parse MIME Type
    if (!OpusMediaRecorder.isTypeSupported(this._mimeType)) {
      throw new TypeError('invalid arguments, a MIME Type is not supported');
    }
    switch (OpusMediaRecorder._parseType(this._mimeType).subtype) {
      case 'wave':
      case 'wav':
        this._mimeType = 'audio/wave';
        break;

      case 'webm':
        this._mimeType = 'audio/webm';
        break;

      case 'ogg':
        this._mimeType = 'audio/ogg';
        break;

      default:
        // Select a type depending on OS.
        switch (browser && browser.name) {
          case 'chrome':
            this._mimeType = 'audio/webm';
            break;

          case 'firefox':
            this._mimeType = 'audio/ogg';
            break;

          case 'edge':
            this._mimeType = 'audio/webm';
            break;

          case 'ios':
          case 'safari':
            this._mimeType = 'audio/wave';
            break;

          default:
            this._mimeType = 'audio/webm';
        }
    }
    switch (this._mimeType) {
      case 'audio/wave':
        this._wasmPath = ''; // wasm is not used
        break;

      case 'audio/webm':
        this._wasmPath = WebMOpusEncoderWasmPath || '';
        break;

      case 'audio/ogg':
        this._wasmPath = OggOpusEncoderWasmPath || '';
        break;

      default:
        throw new Error(`Internal Error: Unexpected MIME Type: ${this._mimeType}`);
    }

    // Get current directory for worker
    let workerDir = '';
    if (document.currentScript) {
      workerDir = document.currentScript.src;
    } else if (self.location) {
      workerDir = self.location.href;
    }
    workerDir = workerDir.substr(0, workerDir.lastIndexOf('/')) +
                '/encoderWorker.umd.js';
    // If worker function is imported via <script> tag, make it blob to get URL.
    if (typeof OpusMediaRecorder.encoderWorker === 'function') {
      workerDir = URL.createObjectURL(new Blob([`(${OpusMediaRecorder.encoderWorker})()`]));
    }

    // Spawn a encoder worker
    this._workerFactory = typeof encoderWorkerFactory === 'function'
                            ? encoderWorkerFactory
                            : _ => new Worker(workerDir);
    this._spawnWorker();
  }

  /**
   * The MediaStream [GETUSERMEDIA] to be recorded.
   * @return {MediaStream}
   */
  get stream () {
    return this._stream;
  }

  /**
   * The MIME type [RFC2046] that has been selected as the container for
   * recording. This entry includes all the parameters to the base
   * mimeType. The UA should be able to play back any of the MIME types
   * it supports for recording. For example, it should be able to display
   * a video recording in the HTML <video> tag. The default value for
   * this property is platform-specific.
   * @return {string}
   */
  get mimeType () {
    return this._mimeType;
  }

  /**
   * The current state of the OpusMediaRecorder object. When the OpusMediaRecorder
   * is created, the UA MUST set this attribute to inactive.
   * @return {"inactive"|"recording"|"paused"}
   */
  get state () {
    return this._state;
  }

  /**
   * The value of the Video encoding. Unsupported.
   * @return {undefined}
   */
  get videoBitsPerSecond () {
    // Video encoding is not supported
    return undefined;
  }

  /**
   * The value of the Audio encoding target bit rate that was passed to
   * the Platform (potentially truncated, rounded, etc), or the calculated one
   * if the user has specified bitsPerSecond.
   * @return {number|undefined}
   */
  get audioBitsPerSecond () {
    return this._audioBitsPerSecond;
  }

  /**
   * Initialize worker
   */
  _spawnWorker () {
    this.worker = this._workerFactory();
    this.worker.onmessage = (e) => this._onmessageFromWorker(e);
    this.worker.onerror = (e) => this._onerrorFromWorker(e);

    this._postMessageToWorker('loadEncoder',
                              { mimeType: this._mimeType,
                                wasmPath: this._wasmPath });
  }

  /**
   * Post message to the encoder web worker.
   * @param {"init"|"pushInputData"|"getEncodedData"|"done"} command - Type of message to send to the worker
   * @param {object} message - Payload to the worker
   */
  _postMessageToWorker (command, message = {}) {
    switch (command) {
      case 'loadEncoder':
        let { mimeType, wasmPath } = message;
        this.worker.postMessage({ command, mimeType, wasmPath });
        break;

      case 'init':
        // Initialize the worker
        let { sampleRate, channelCount, bitsPerSecond } = message;
        this.worker.postMessage({ command, sampleRate, channelCount, bitsPerSecond });
        this.workerState = 'encoding';

        // Start streaming
        this.source.connect(this.processor);
        this.processor.connect(this.context.destination);
        let eventToPush = new global.Event('start');
        this.dispatchEvent(eventToPush);
        break;

      case 'pushInputData':
        // Pass input audio buffer to the encoder to encode.
        // The worker MAY trigger 'encodedData'.
        let { channelBuffers, length, duration } = message;
        this.worker.postMessage({
          command, channelBuffers, length, duration
        });
        break;

      case 'getEncodedData':
        // Request encoded result.
        // Expected 'encodedData' event from the worker
        this.worker.postMessage({ command });
        break;

      case 'done':
        // Tell encoder finallize the job and destory itself.
        // Expected 'lastEncodedData' event from the worker.
        this.worker.postMessage({ command });
        break;

      default:
        // This is an error case
        throw new Error('Internal Error: Incorrect postMessage requested.');
    }
  }

  /**
   * onmessage() callback from the worker.
   * @param {message} event - message from the worker
   */
  _onmessageFromWorker (event) {
    const { command, buffers } = event.data;
    let eventToPush;
    switch (command) {
      case 'readyToInit':
        const { sampleRate, channelCount } = this;
        this.workerState = 'readyToInit';

        // If start() is already called initialize worker
        if (this.state === 'recording') {
          this._postMessageToWorker('init',
                                    { sampleRate,
                                      channelCount,
                                      bitsPerSecond: this.audioBitsPerSecond});
        }
        break;

      case 'encodedData':
      case 'lastEncodedData':
        let data = new Blob(buffers, {'type': this._mimeType});
        eventToPush = new global.Event('dataavailable');
        eventToPush.data = data;
        this.dispatchEvent(eventToPush);

        // Detect of stop() called before
        if (command === 'lastEncodedData') {
          eventToPush = new global.Event('stop');
          this.dispatchEvent(eventToPush);

          this.workerState = 'closed';
        }
        break;

      default:
        break; // Ignore
    }
  }

  /**
   * onerror() callback from the worker.
   * @param {ErrorEvent} error - error object from the worker
   */
  _onerrorFromWorker (error) {
    // Stop stream first
    this.source.disconnect();
    this.processor.disconnect();

    this.worker.terminate();
    this.workerState = 'closed';

    // Send message to host
    let message = [
      'FileName: ' + error.filename,
      'LineNumber: ' + error.lineno,
      'Message: ' + error.message
    ].join(' - ');
    let errorToPush = new global.Event('error');
    errorToPush.name = 'UnknownError';
    errorToPush.message = message;
    this.dispatchEvent(errorToPush);
  }

  /**
   * Enable onaudioprocess() callback.
   * @param {number} timeslice - In seconds. OpusMediaRecorder should request data
   *                              from the worker every timeslice seconds.
   */
  _enableAudioProcessCallback (timeslice) {
    // pass frame buffers to the worker
    let elapsedTime = 0;
    this.processor.onaudioprocess = (e) => {
      const { inputBuffer, playbackTime } = e; // eslint-disable-line
      const { sampleRate, length, duration, numberOfChannels } = inputBuffer; // eslint-disable-line

      // Create channel buffers to pass to the worker
      const channelBuffers = new Array(numberOfChannels);
      for (let i = 0; i < numberOfChannels; i++) {
        channelBuffers[i] = inputBuffer.getChannelData(i);
      }

      // Pass data to the worker
      const message = { channelBuffers, length, duration };
      this._postMessageToWorker('pushInputData', message);

      // Calculate time
      elapsedTime += duration;
      if (elapsedTime >= timeslice) {
        this._postMessageToWorker('getEncodedData');
        elapsedTime = 0;
      }
    };
  }

  /**
   * Begins recording media; this method can optionally be passed a timeslice
   * argument with a value in milliseconds.
   * @param {number} timeslice - If this is specified, the media will be captured
   *        in separate chunks of that duration, rather than the default behavior
   *        of recording the media in a single large chunk. In other words, an
   *        undefined value of timeslice will be understood as the largest long value.
   */
  start (timeslice = Number.MAX_SAFE_INTEGER) {
    if (this.state !== 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must be inactive.');
    }
    if (timeslice < 0) {
      throw new TypeError('invalid arguments, timeslice should be 0 or higher.');
    }
    timeslice /= 1000; // Convert milliseconds to seconds

    // Check worker is closed (usually by stop()) and init.
    if (this.workerState === 'closed') {
      this._spawnWorker();
    }

    // Get channel count and sampling rate
    // channelCount: https://www.w3.org/TR/mediacapture-streams/#media-track-settings
    // sampleRate: https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/sampleRate
    this.context = new AudioContext();
    let tracks = this.stream.getAudioTracks();
    if (!tracks[0]) {
      throw new Error('DOMException: UnkownError, media track not found.');
    }
    this.channelCount = tracks[0].getSettings().channelCount || 1;
    this.sampleRate = this.context.sampleRate;

    /** @type {MediaStreamAudioSourceNode} */
    this.source = this.context.createMediaStreamSource(this.stream);
    /** @type {ScriptProcessorNode} */
    this.processor = this.context.createScriptProcessor(BUFFER_SIZE, this.channelCount, this.channelCount);

    // Start recording
    this._state = 'recording';
    this._enableAudioProcessCallback(timeslice);

    // If the worker is already loaded then start
    if (this.workerState === 'readyToInit') {
      const { sampleRate, channelCount } = this;
      this._postMessageToWorker('init',
                                { sampleRate,
                                  channelCount,
                                  bitsPerSecond: this.audioBitsPerSecond });
    }
  }

  /**
   * Stops recording, at which point a dataavailable event containing
   * the final Blob of saved data is fired. No more recording occurs.
   */
  stop () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // Stop stream first
    this.source.disconnect();
    this.processor.disconnect();
    this.context.close();

    // Stop event will be triggered at _onmessageFromWorker(),
    this._postMessageToWorker('done');

    this._state = 'inactive';
  }

  /**
   * Pauses the recording of media.
   */
  pause () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // Stop stream first
    this.source.disconnect();
    this.processor.disconnect();

    let event = new global.Event('pause');
    this.dispatchEvent(event);
    this._state = 'paused';
  }

  /**
   * Resumes recording of media after having been paused.
   */
  resume () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // Restart streaming data
    this.source.connect(this.processor);
    this.processor.connect(this.context.destination);

    let event = new global.Event('resume');
    this.dispatchEvent(event);
    this._state = 'recording';
  }

  /**
   * Requests a Blob containing the saved data received thus far (or since
   * the last time requestData() was called. After calling this method,
   * recording continues, but in a new Blob.
   */
  requestData () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // dataavailable event will be triggerd at _onmessageFromWorker()
    this._postMessageToWorker('getEncodedData');
  }

  /**
   * Returns a Boolean value indicating if the given MIME type is supported
   * by the current user agent .
   * @param {string} typeType - A MIME Type, including parameters when needed,
   *          specifying a container and/or codec formats for recording.
   * @return {boolean}
   */
  static isTypeSupported (mimeType) {
    // See: https://w3c.github.io/mediacapture-record/#dom-mediarecorder-istypesupported

    // 1. If empty string, return true.
    if (typeof mimeType === 'string' && !mimeType) {
      return true;
    }
    try {
      var {type, subtype, codec} = OpusMediaRecorder._parseType(mimeType);
    } catch (error) {
      // 2. If not a valid string, return false.
      return false;
    }
    if (type !== 'audio' ||
      !(subtype === 'ogg' || subtype === 'webm' ||
        subtype === 'wave' || subtype === 'wav')) {
      // 3,4. If type and subtype are unsupported the return false.
      return false;
    }
    // 5. If codec is unsupported then return false.
    // 6. If the specified combination of all is not supported than return false.
    switch (subtype) {
      case 'ogg':
        if (codec !== 'opus' && codec) {
          return false;
        }
        break;
      case 'webm':
        if (codec !== 'opus' && codec) {
          return false;
        }
        break;
      case 'wave':
      case 'wav':
        if (codec) {
          return false; // Currently only supports signed 16 bits
        }
        break;
    }
    // 7. return true.
    return true;
  }

  /**
   * Parse MIME. A helper function for isTypeSupported() and etc.
   * @param {string} mimeType - typeType - A MIME Type, including parameters when needed,
   *          specifying a container and/or codec formats for recording.
   * @return {?object} - An object with type, subtype, codec attributes
   *          if parsed correctly. null is returned if parsing failed.
   *          If mimeType is an empty string then return an object with attributes
   *          are empty strings
   */
  static _parseType (mimeType) {
    try {
      const regex = /^(\w+)\/(\w+)(;\s*codecs=(\w+))?$/;
      var [, type, subtype, , codec] = mimeType.match(regex);
    } catch (error) {
      if (typeof mimeType === 'string' && !mimeType) {
        return {type: '', subtype: '', codec: ''};
      }
      return null;
    }
    return {type, subtype, codec};
  }
}

// EventHandler attributes.
// This code is a non-standard EventTarget but required by event-target-shim.
[
  'start', // Called to handle the {@link MediaRecorder#start} event.
  'stop', // Called to handle the stop event.
  'dataavailable', /* Called to handle the dataavailable event. The Blob of
                        recorded data is contained in this event and can be
                        accessed via its data attribute. */
  'pause', // Called to handle the pause event.
  'resume', // Called to handle the resume event.
  'error' // Called to handle a MediaRecorderErrorEvent.
].forEach(name => defineEventAttribute(OpusMediaRecorder.prototype, name));

// MS Edge specific monkey patching:
// onaudioprocess callback cannot be triggered more than twice when postMessage
// uses the seconde transfer argument. So disable the transfer argument only in Edge.
if (browser && browser.name === 'edge') {
  (function () {
    var original = Worker.prototype.postMessage;
    Worker.prototype.postMessage = function (message, transfer = null) {
      original.apply(this, [message]);
    };
  })();
}

module.exports = OpusMediaRecorder;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"detect-browser":12,"event-target-shim":15}],31:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');

module.exports = PageBus;
inherits(PageBus, EventEmitter);

var emit = EventEmitter.prototype.emit;
var on = EventEmitter.prototype.on;
var once = EventEmitter.prototype.once;

function PageBus (opts) {
    if (!(this instanceof PageBus)) return new PageBus(opts);
    if (!opts) opts = {};
    var self = this;
    EventEmitter.call(this);
    if (typeof opts === 'string') opts = { key: opts };
    this._key = opts.key || 'page-bus';
    localStorage.setItem(this._key, JSON.stringify([]));
    window.addEventListener('storage', function (ev) {
        if (ev.key === self._key) {
            try { var value = JSON.parse(ev.newValue) }
            catch (err) { return }
            if (Array.isArray(value)) emit.apply(self, value);
        }
    });
}


PageBus.prototype.emit = function (name) {
    emit.apply(this, arguments);
    var args = [].slice.call(arguments);
    localStorage.setItem(this._key, JSON.stringify(args));
    return this;
};

},{"events":121,"inherits":21}],32:[function(require,module,exports){
(function (global){(function (){
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise

module.exports = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0))

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],33:[function(require,module,exports){
(function (process,global){(function (){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":136,"safe-buffer":50}],34:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],35:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":37,"./_stream_writable":39,"_process":136,"inherits":21}],36:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":38,"inherits":21}],37:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":34,"./_stream_duplex":35,"./internal/streams/async_iterator":40,"./internal/streams/buffer_list":41,"./internal/streams/destroy":42,"./internal/streams/from":44,"./internal/streams/state":46,"./internal/streams/stream":47,"_process":136,"buffer":117,"events":121,"inherits":21,"string_decoder/":76,"util":116}],38:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":34,"./_stream_duplex":35,"inherits":21}],39:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":34,"./_stream_duplex":35,"./internal/streams/destroy":42,"./internal/streams/state":46,"./internal/streams/stream":47,"_process":136,"buffer":117,"inherits":21,"util-deprecate":86}],40:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

},{"./end-of-stream":43,"_process":136}],41:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":117,"util":116}],42:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

},{"_process":136}],43:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":34}],44:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],45:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":34,"./end-of-stream":43}],46:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":34}],47:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":121}],48:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":35,"./lib/_stream_passthrough.js":36,"./lib/_stream_readable.js":37,"./lib/_stream_transform.js":38,"./lib/_stream_writable.js":39,"./lib/internal/streams/end-of-stream.js":43,"./lib/internal/streams/pipeline.js":45}],49:[function(require,module,exports){
(function (process){(function (){
/*! run-waterfall. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = runWaterfall

function runWaterfall (tasks, cb) {
  var current = 0
  var isSync = true

  function done (err, args) {
    function end () {
      args = args ? [].concat(err, args) : [err]
      if (cb) cb.apply(undefined, args)
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (err) {
    var args = Array.prototype.slice.call(arguments, 1)
    if (++current >= tasks.length || err) {
      done(err, args)
    } else {
      tasks[current].apply(undefined, [].concat(args, each))
    }
  }

  if (tasks.length) {
    tasks[0](each)
  } else {
    done(null)
  }

  isSync = false
}

}).call(this)}).call(this,require('_process'))

},{"_process":136}],50:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":117}],51:[function(require,module,exports){
 /* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parts[1],
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress); // was: relAddr
    sdp.push('rport');
    sdp.push(candidate.relatedPort); // was: relPort
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
}

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  // was: channels
  parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      params.push(param + '=' + codec.parameters[param]);
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
}

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  caps.headerExtensions.forEach(function(extension) {
    sdp += SDPUtils.writeExtmap(extension);
  });
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.split(' ');
    parts.shift();
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
        rtx: {
          ssrc: secondarySsrc
        }
      };
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: secondarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(5), 10);
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  var cname;
  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

SDPUtils.writeSessionBoilerplate = function() {
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

// Expose public methods.
module.exports = SDPUtils;

},{}],52:[function(require,module,exports){
/**
 * Created by Samuel on 6/4/2016.
 * Simple wrapper functions to produce shorter UUIDs for cookies, maybe everything?
 */

const { v4: uuidv4 } = require('uuid');
const anyBase = require('any-base');

const flickrBase58 = '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ';
const cookieBase90 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&'()*+-./:<=>?@[]^_`{|}~";

const baseOptions = {
  consistentLength: true,
};

// A default generator, instantiated only if used.
let toFlickr;

/**
 * Takes a UUID, strips the dashes, and translates.
 * @param {string} longId
 * @param {function(string)} translator
 * @param {Object} [paddingParams]
 * @returns {string}
 */
const shortenUUID = (longId, translator, paddingParams) => {
  const translated = translator(longId.toLowerCase().replace(/-/g, ''));

  if (!paddingParams || !paddingParams.consistentLength) return translated;

  return translated.padStart(
    paddingParams.shortIdLength,
    paddingParams.paddingChar,
  );
};

/**
 * Translate back to hex and turn back into UUID format, with dashes
 * @param {string} shortId
 * @param {function(string)} translator
 * @returns {string}
 */
const enlargeUUID = (shortId, translator) => {
  const uu1 = translator(shortId).padStart(32, '0');

  // Join the zero padding and the UUID and then slice it up with match
  const m = uu1.match(/(\w{8})(\w{4})(\w{4})(\w{4})(\w{12})/);

  // Accumulate the matches and join them.
  return [m[1], m[2], m[3], m[4], m[5]].join('-');
};

// Calculate length for the shortened ID
const getShortIdLength = (alphabetLength) => (
  Math.ceil(Math.log(2 ** 128) / Math.log(alphabetLength)));

module.exports = (() => {
  /**
   * @param {string} toAlphabet - Defaults to flickrBase58 if not provided
   * @param {Object} [options]
   *
   * @returns {{new: (function()),
   *  uuid: (function()),
   *  fromUUID: (function(string)),
   *  toUUID: (function(string)),
   *  alphabet: (string)}}
   */
  const makeConvertor = (toAlphabet, options) => {
    // Default to Flickr 58
    const useAlphabet = toAlphabet || flickrBase58;

    // Default to baseOptions
    const selectedOptions = { ...baseOptions, ...options };

    // Check alphabet for duplicate entries
    if ([...new Set(Array.from(useAlphabet))].length !== useAlphabet.length) {
      throw new Error('The provided Alphabet has duplicate characters resulting in unreliable results');
    }

    const shortIdLength = getShortIdLength(useAlphabet.length);

    // Padding Params
    const paddingParams = {
      shortIdLength,
      consistentLength: selectedOptions.consistentLength,
      paddingChar: useAlphabet[0],
    };

    // UUIDs are in hex, so we translate to and from.
    const fromHex = anyBase(anyBase.HEX, useAlphabet);
    const toHex = anyBase(useAlphabet, anyBase.HEX);
    const generate = () => shortenUUID(uuidv4(), fromHex, paddingParams);

    const translator = {
      new: generate,
      generate,
      uuid: uuidv4,
      fromUUID: (uuid) => shortenUUID(uuid, fromHex, paddingParams),
      toUUID: (shortUuid) => enlargeUUID(shortUuid, toHex),
      alphabet: useAlphabet,
      maxLength: shortIdLength,
    };

    Object.freeze(translator);

    return translator;
  };

  // Expose the constants for other purposes.
  makeConvertor.constants = {
    flickrBase58,
    cookieBase90,
  };

  // Expose the generic v4 UUID generator for convenience
  makeConvertor.uuid = uuidv4;

  // Provide a generic generator
  makeConvertor.generate = () => {
    if (!toFlickr) {
      // Generate on first use;
      toFlickr = makeConvertor(flickrBase58).generate;
    }
    return toFlickr();
  };

  return makeConvertor;
})();

},{"any-base":4,"uuid":87}],53:[function(require,module,exports){
var ess = require('event-source-stream')
var nets = require('nets')

var noop = function () {}

module.exports = function (url, app) {
  if (!url) throw new Error('signalhub url required')
  if (!app) throw new Error('app name required as 2nd argument')
  var that = {}

  if (url.indexOf('://') === -1) url = 'http://' + url

  that.subscribe = function (channel) {
    return ess(url + '/v1/' + app + '/' + channel, {json: true})
  }

  that.broadcast = function (channel, message, cb) {
    if (!cb) cb = noop
    nets({
      method: 'POST',
      json: message,
      url: url + '/v1/' + app + '/' + channel
    }, function (err, res) {
      if (err) return cb(err)
      if (res.statusCode !== 200) return cb(new Error('Bad status: ' + res.statusCode))
      cb()
    })
  }

  return that
}

},{"event-source-stream":54,"nets":55}],54:[function(require,module,exports){
var stream = require('stream')

module.exports = function(url, opts) {
  if (!opts) opts = {}

  var es = new EventSource(url)
  var rs = new stream.Readable({objectMode:true})

  var json = !!opts.json
  var decode = function (data) {
    try {
      if (json) return JSON.parse(data)
      return data
    } catch (err) {
      return undefined
    }
  }

  rs._read = function() {}

  es.onmessage = function(e) {
    rs.push(decode(e.data))
  }

  es.onerror = function(err) {
    if (rs.listeners('error').length) rs.emit('error', err)
  }

  var destroyed = false
  rs.destroy = function() {
    if (destroyed) return
    destroyed = true
    es.close()
    parse.emit('close')
  }

  return rs
}
},{"stream":141}],55:[function(require,module,exports){
(function (process,Buffer){(function (){
var req = require('request')

module.exports = Nets

function Nets (opts, cb) {
  if (typeof opts === 'string') opts = { uri: opts }

  // in node, if encoding === null then response will be a Buffer. we want this to be the default
  if (!opts.hasOwnProperty('encoding')) opts.encoding = null

  // in browser, we should by default convert the arraybuffer into a Buffer
  if (process.browser && !opts.hasOwnProperty('json') && opts.encoding === null) {
    opts.responseType = 'arraybuffer'
    var originalCb = cb
    cb = bufferify
  }

  function bufferify (err, resp, body) {
    if (body) body = new Buffer(new Uint8Array(body))
    originalCb(err, resp, body)
  }

  return req(opts, cb)
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":136,"buffer":117,"request":56}],56:[function(require,module,exports){
"use strict";
var window = require("global/window")
var once = require("once")
var parseHeaders = require("parse-headers")


var XHR = window.XMLHttpRequest || noop
var XDR = "withCredentials" in (new XHR()) ? XHR : window.XDomainRequest

module.exports = createXHR

function createXHR(options, callback) {
    function readystatechange() {
        if (xhr.readyState === 4) {
            loadFunc()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === "text" || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }
    
    var failureResponse = {
                body: undefined,
                headers: {},
                statusCode: 0,
                method: method,
                url: uri,
                rawRequest: xhr
            }
    
    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "unknown") )
        }
        evt.statusCode = 0
        callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        clearTimeout(timeoutTimer)
        
        var status = (xhr.status === 1223 ? 204 : xhr.status)
        var response = failureResponse
        var err = null
        
        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        callback(err, response, response.body)
        
    }
    
    if (typeof options === "string") {
        options = { uri: options }
    }

    options = options || {}
    if(typeof callback === "undefined"){
        throw new Error("callback argument missing")
    }
    callback = once(callback)

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new XDR()
        }else{
            xhr = new XHR()
        }
    }

    var key
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer

    if ("json" in options) {
        isJson = true
        headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["Content-Type"] = "application/json"
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync)
    //has to be after open
    xhr.withCredentials = !!options.withCredentials
    
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            xhr.abort("timeout");
        }, options.timeout+2 );
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }
    
    if ("beforeSend" in options && 
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr


}


function noop() {}

},{"global/window":57,"once":58,"parse-headers":62}],57:[function(require,module,exports){
(function (global){(function (){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],58:[function(require,module,exports){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

},{}],59:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":60}],60:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],61:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],62:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":59,"trim":61}],63:[function(require,module,exports){
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
const debug = require('debug')('simple-peer')
const getBrowserRTC = require('get-browser-rtc')
const randombytes = require('randombytes')
const stream = require('readable-stream')
const queueMicrotask = require('queue-microtask') // TODO: remove when Node 10 is not supported
const errCode = require('err-code')
const { Buffer } = require('buffer')

const MAX_BUFFERED_AMOUNT = 64 * 1024
const ICECOMPLETE_TIMEOUT = 5 * 1000
const CHANNEL_CLOSING_TIMEOUT = 5 * 1000

// HACK: Filter trickle lines when trickle is disabled #354
function filterTrickle (sdp) {
  return sdp.replace(/a=ice-options:trickle\s\n/g, '')
}

function warn (message) {
  console.warn(message)
}

/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */
class Peer extends stream.Duplex {
  constructor (opts) {
    opts = Object.assign({
      allowHalfOpen: false
    }, opts)

    super(opts)

    this._id = randombytes(4).toString('hex').slice(0, 7)
    this._debug('new peer %o', opts)

    this.channelName = opts.initiator
      ? opts.channelName || randombytes(20).toString('hex')
      : null

    this.initiator = opts.initiator || false
    this.channelConfig = opts.channelConfig || Peer.channelConfig
    this.channelNegotiated = this.channelConfig.negotiated
    this.config = Object.assign({}, Peer.config, opts.config)
    this.offerOptions = opts.offerOptions || {}
    this.answerOptions = opts.answerOptions || {}
    this.sdpTransform = opts.sdpTransform || (sdp => sdp)
    this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old "stream" option
    this.trickle = opts.trickle !== undefined ? opts.trickle : true
    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false
    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT

    this.destroyed = false
    this.destroying = false
    this._connected = false

    this.remoteAddress = undefined
    this.remoteFamily = undefined
    this.remotePort = undefined
    this.localAddress = undefined
    this.localFamily = undefined
    this.localPort = undefined

    this._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')
      ? opts.wrtc
      : getBrowserRTC()

    if (!this._wrtc) {
      if (typeof window === 'undefined') {
        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')
      } else {
        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')
      }
    }

    this._pcReady = false
    this._channelReady = false
    this._iceComplete = false // ice candidate trickle done (got null candidate)
    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout
    this._channel = null
    this._pendingCandidates = []

    this._isNegotiating = false // is this peer waiting for negotiation to complete?
    this._firstNegotiation = true
    this._batchedNegotiation = false // batch synchronous negotiations
    this._queuedNegotiation = false // is there a queued negotiation request?
    this._sendersAwaitingStable = []
    this._senderMap = new Map()
    this._closingInterval = null

    this._remoteTracks = []
    this._remoteStreams = []

    this._chunk = null
    this._cb = null
    this._interval = null

    try {
      this._pc = new (this._wrtc.RTCPeerConnection)(this.config)
    } catch (err) {
      this.destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))
      return
    }

    // We prefer feature detection whenever possible, but sometimes that's not
    // possible for certain implementations.
    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'

    this._pc.oniceconnectionstatechange = () => {
      this._onIceStateChange()
    }
    this._pc.onicegatheringstatechange = () => {
      this._onIceStateChange()
    }
    this._pc.onconnectionstatechange = () => {
      this._onConnectionStateChange()
    }
    this._pc.onsignalingstatechange = () => {
      this._onSignalingStateChange()
    }
    this._pc.onicecandidate = event => {
      this._onIceCandidate(event)
    }

    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783
    if (typeof this._pc.peerIdentity === 'object') {
      this._pc.peerIdentity.catch(err => {
        this.destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))
      })
    }

    // Other spec events, unused by this implementation:
    // - onconnectionstatechange
    // - onicecandidateerror
    // - onfingerprintfailure
    // - onnegotiationneeded

    if (this.initiator || this.channelNegotiated) {
      this._setupData({
        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
      })
    } else {
      this._pc.ondatachannel = event => {
        this._setupData(event)
      }
    }

    if (this.streams) {
      this.streams.forEach(stream => {
        this.addStream(stream)
      })
    }
    this._pc.ontrack = event => {
      this._onTrack(event)
    }

    this._debug('initial negotiation')
    this._needsNegotiation()

    this._onFinishBound = () => {
      this._onFinish()
    }
    this.once('finish', this._onFinishBound)
  }

  get bufferSize () {
    return (this._channel && this._channel.bufferedAmount) || 0
  }

  // HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
  get connected () {
    return (this._connected && this._channel.readyState === 'open')
  }

  address () {
    return { port: this.localPort, family: this.localFamily, address: this.localAddress }
  }

  signal (data) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data)
      } catch (err) {
        data = {}
      }
    }
    this._debug('signal()')

    if (data.renegotiate && this.initiator) {
      this._debug('got request to renegotiate')
      this._needsNegotiation()
    }
    if (data.transceiverRequest && this.initiator) {
      this._debug('got request for transceiver')
      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)
    }
    if (data.candidate) {
      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
        this._addIceCandidate(data.candidate)
      } else {
        this._pendingCandidates.push(data.candidate)
      }
    }
    if (data.sdp) {
      this._pc.setRemoteDescription(new (this._wrtc.RTCSessionDescription)(data))
        .then(() => {
          if (this.destroyed) return

          this._pendingCandidates.forEach(candidate => {
            this._addIceCandidate(candidate)
          })
          this._pendingCandidates = []

          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()
        })
        .catch(err => {
          this.destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))
        })
    }
    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
      this.destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))
    }
  }

  _addIceCandidate (candidate) {
    const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate)
    this._pc.addIceCandidate(iceCandidateObj)
      .catch(err => {
        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {
          warn('Ignoring unsupported ICE candidate.')
        } else {
          this.destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))
        }
      })
  }

  /**
   * Send text/binary data to the remote peer.
   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
   */
  send (chunk) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')
    this._channel.send(chunk)
  }

  /**
   * Add a Transceiver to the connection.
   * @param {String} kind
   * @param {Object} init
   */
  addTransceiver (kind, init) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot addTransceiver after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('addTransceiver()')

    if (this.initiator) {
      try {
        this._pc.addTransceiver(kind, init)
        this._needsNegotiation()
      } catch (err) {
        this.destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'))
      }
    } else {
      this.emit('signal', { // request initiator to renegotiate
        type: 'transceiverRequest',
        transceiverRequest: { kind, init }
      })
    }
  }

  /**
   * Add a MediaStream to the connection.
   * @param {MediaStream} stream
   */
  addStream (stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot addStream after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('addStream()')

    stream.getTracks().forEach(track => {
      this.addTrack(track, stream)
    })
  }

  /**
   * Add a MediaStreamTrack to the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */
  addTrack (track, stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot addTrack after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('addTrack()')

    const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender
    let sender = submap.get(stream)
    if (!sender) {
      sender = this._pc.addTrack(track, stream)
      submap.set(stream, sender)
      this._senderMap.set(track, submap)
      this._needsNegotiation()
    } else if (sender.removed) {
      throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED')
    } else {
      throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED')
    }
  }

  /**
   * Replace a MediaStreamTrack by another in the connection.
   * @param {MediaStreamTrack} oldTrack
   * @param {MediaStreamTrack} newTrack
   * @param {MediaStream} stream
   */
  replaceTrack (oldTrack, newTrack, stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot replaceTrack after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('replaceTrack()')

    const submap = this._senderMap.get(oldTrack)
    const sender = submap ? submap.get(stream) : null
    if (!sender) {
      throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED')
    }
    if (newTrack) this._senderMap.set(newTrack, submap)

    if (sender.replaceTrack != null) {
      sender.replaceTrack(newTrack)
    } else {
      this.destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'))
    }
  }

  /**
   * Remove a MediaStreamTrack from the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */
  removeTrack (track, stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot removeTrack after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('removeSender()')

    const submap = this._senderMap.get(track)
    const sender = submap ? submap.get(stream) : null
    if (!sender) {
      throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED')
    }
    try {
      sender.removed = true
      this._pc.removeTrack(sender)
    } catch (err) {
      if (err.name === 'NS_ERROR_UNEXPECTED') {
        this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874
      } else {
        this.destroy(errCode(err, 'ERR_REMOVE_TRACK'))
      }
    }
    this._needsNegotiation()
  }

  /**
   * Remove a MediaStream from the connection.
   * @param {MediaStream} stream
   */
  removeStream (stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot removeStream after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('removeSenders()')

    stream.getTracks().forEach(track => {
      this.removeTrack(track, stream)
    })
  }

  _needsNegotiation () {
    this._debug('_needsNegotiation')
    if (this._batchedNegotiation) return // batch synchronous renegotiations
    this._batchedNegotiation = true
    queueMicrotask(() => {
      this._batchedNegotiation = false
      if (this.initiator || !this._firstNegotiation) {
        this._debug('starting batched negotiation')
        this.negotiate()
      } else {
        this._debug('non-initiator initial negotiation request discarded')
      }
      this._firstNegotiation = false
    })
  }

  negotiate () {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')

    if (this.initiator) {
      if (this._isNegotiating) {
        this._queuedNegotiation = true
        this._debug('already negotiating, queueing')
      } else {
        this._debug('start negotiation')
        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer
          this._createOffer()
        }, 0)
      }
    } else {
      if (this._isNegotiating) {
        this._queuedNegotiation = true
        this._debug('already negotiating, queueing')
      } else {
        this._debug('requesting negotiation from initiator')
        this.emit('signal', { // request initiator to renegotiate
          type: 'renegotiate',
          renegotiate: true
        })
      }
    }
    this._isNegotiating = true
  }

  // TODO: Delete this method once readable-stream is updated to contain a default
  // implementation of destroy() that automatically calls _destroy()
  // See: https://github.com/nodejs/readable-stream/issues/283
  destroy (err) {
    this._destroy(err, () => {})
  }

  _destroy (err, cb) {
    if (this.destroyed || this.destroying) return
    this.destroying = true

    this._debug('destroying (error: %s)', err && (err.message || err))

    queueMicrotask(() => { // allow events concurrent with the call to _destroy() to fire (see #692)
      this.destroyed = true
      this.destroying = false

      this._debug('destroy (error: %s)', err && (err.message || err))

      this.readable = this.writable = false

      if (!this._readableState.ended) this.push(null)
      if (!this._writableState.finished) this.end()

      this._connected = false
      this._pcReady = false
      this._channelReady = false
      this._remoteTracks = null
      this._remoteStreams = null
      this._senderMap = null

      clearInterval(this._closingInterval)
      this._closingInterval = null

      clearInterval(this._interval)
      this._interval = null
      this._chunk = null
      this._cb = null

      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)
      this._onFinishBound = null

      if (this._channel) {
        try {
          this._channel.close()
        } catch (err) {}

        // allow events concurrent with destruction to be handled
        this._channel.onmessage = null
        this._channel.onopen = null
        this._channel.onclose = null
        this._channel.onerror = null
      }
      if (this._pc) {
        try {
          this._pc.close()
        } catch (err) {}

        // allow events concurrent with destruction to be handled
        this._pc.oniceconnectionstatechange = null
        this._pc.onicegatheringstatechange = null
        this._pc.onsignalingstatechange = null
        this._pc.onicecandidate = null
        this._pc.ontrack = null
        this._pc.ondatachannel = null
      }
      this._pc = null
      this._channel = null

      if (err) this.emit('error', err)
      this.emit('close')
      cb()
    })
  }

  _setupData (event) {
    if (!event.channel) {
      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),
      // which is invalid behavior. Handle it gracefully.
      // See: https://github.com/feross/simple-peer/issues/163
      return this.destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))
    }

    this._channel = event.channel
    this._channel.binaryType = 'arraybuffer'

    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {
      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT
    }

    this.channelName = this._channel.label

    this._channel.onmessage = event => {
      this._onChannelMessage(event)
    }
    this._channel.onbufferedamountlow = () => {
      this._onChannelBufferedAmountLow()
    }
    this._channel.onopen = () => {
      this._onChannelOpen()
    }
    this._channel.onclose = () => {
      this._onChannelClose()
    }
    this._channel.onerror = event => {
      const err = event.error instanceof Error
        ? event.error
        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)
      this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
    }

    // HACK: Chrome will sometimes get stuck in readyState "closing", let's check for this condition
    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
    let isClosing = false
    this._closingInterval = setInterval(() => { // No "onclosing" event
      if (this._channel && this._channel.readyState === 'closing') {
        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing
        isClosing = true
      } else {
        isClosing = false
      }
    }, CHANNEL_CLOSING_TIMEOUT)
  }

  _read () {}

  _write (chunk, encoding, cb) {
    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))

    if (this._connected) {
      try {
        this.send(chunk)
      } catch (err) {
        return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
      }
      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)
        this._cb = cb
      } else {
        cb(null)
      }
    } else {
      this._debug('write before connect')
      this._chunk = chunk
      this._cb = cb
    }
  }

  // When stream finishes writing, close socket. Half open connections are not
  // supported.
  _onFinish () {
    if (this.destroyed) return

    // Wait a bit before destroying so the socket flushes.
    // TODO: is there a more reliable way to accomplish this?
    const destroySoon = () => {
      setTimeout(() => this.destroy(), 1000)
    }

    if (this._connected) {
      destroySoon()
    } else {
      this.once('connect', destroySoon)
    }
  }

  _startIceCompleteTimeout () {
    if (this.destroyed) return
    if (this._iceCompleteTimer) return
    this._debug('started iceComplete timeout')
    this._iceCompleteTimer = setTimeout(() => {
      if (!this._iceComplete) {
        this._iceComplete = true
        this._debug('iceComplete timeout completed')
        this.emit('iceTimeout')
        this.emit('_iceComplete')
      }
    }, this.iceCompleteTimeout)
  }

  _createOffer () {
    if (this.destroyed) return

    this._pc.createOffer(this.offerOptions)
      .then(offer => {
        if (this.destroyed) return
        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)
        offer.sdp = this.sdpTransform(offer.sdp)

        const sendOffer = () => {
          if (this.destroyed) return
          const signal = this._pc.localDescription || offer
          this._debug('signal')
          this.emit('signal', {
            type: signal.type,
            sdp: signal.sdp
          })
        }

        const onSuccess = () => {
          this._debug('createOffer success')
          if (this.destroyed) return
          if (this.trickle || this._iceComplete) sendOffer()
          else this.once('_iceComplete', sendOffer) // wait for candidates
        }

        const onError = err => {
          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))
        }

        this._pc.setLocalDescription(offer)
          .then(onSuccess)
          .catch(onError)
      })
      .catch(err => {
        this.destroy(errCode(err, 'ERR_CREATE_OFFER'))
      })
  }

  _requestMissingTransceivers () {
    if (this._pc.getTransceivers) {
      this._pc.getTransceivers().forEach(transceiver => {
        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
          transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid
          this.addTransceiver(transceiver.sender.track.kind)
        }
      })
    }
  }

  _createAnswer () {
    if (this.destroyed) return

    this._pc.createAnswer(this.answerOptions)
      .then(answer => {
        if (this.destroyed) return
        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)
        answer.sdp = this.sdpTransform(answer.sdp)

        const sendAnswer = () => {
          if (this.destroyed) return
          const signal = this._pc.localDescription || answer
          this._debug('signal')
          this.emit('signal', {
            type: signal.type,
            sdp: signal.sdp
          })
          if (!this.initiator) this._requestMissingTransceivers()
        }

        const onSuccess = () => {
          if (this.destroyed) return
          if (this.trickle || this._iceComplete) sendAnswer()
          else this.once('_iceComplete', sendAnswer)
        }

        const onError = err => {
          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))
        }

        this._pc.setLocalDescription(answer)
          .then(onSuccess)
          .catch(onError)
      })
      .catch(err => {
        this.destroy(errCode(err, 'ERR_CREATE_ANSWER'))
      })
  }

  _onConnectionStateChange () {
    if (this.destroyed) return
    if (this._pc.connectionState === 'failed') {
      this.destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))
    }
  }

  _onIceStateChange () {
    if (this.destroyed) return
    const iceConnectionState = this._pc.iceConnectionState
    const iceGatheringState = this._pc.iceGatheringState

    this._debug(
      'iceStateChange (connection: %s) (gathering: %s)',
      iceConnectionState,
      iceGatheringState
    )
    this.emit('iceStateChange', iceConnectionState, iceGatheringState)

    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
      this._pcReady = true
      this._maybeReady()
    }
    if (iceConnectionState === 'failed') {
      this.destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))
    }
    if (iceConnectionState === 'closed') {
      this.destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))
    }
  }

  getStats (cb) {
    // statreports can come with a value array instead of properties
    const flattenValues = report => {
      if (Object.prototype.toString.call(report.values) === '[object Array]') {
        report.values.forEach(value => {
          Object.assign(report, value)
        })
      }
      return report
    }

    // Promise-based getStats() (standard)
    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
      this._pc.getStats()
        .then(res => {
          const reports = []
          res.forEach(report => {
            reports.push(flattenValues(report))
          })
          cb(null, reports)
        }, err => cb(err))

    // Single-parameter callback-based getStats() (non-standard)
    } else if (this._pc.getStats.length > 0) {
      this._pc.getStats(res => {
        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed
        if (this.destroyed) return

        const reports = []
        res.result().forEach(result => {
          const report = {}
          result.names().forEach(name => {
            report[name] = result.stat(name)
          })
          report.id = result.id
          report.type = result.type
          report.timestamp = result.timestamp
          reports.push(flattenValues(report))
        })
        cb(null, reports)
      }, err => cb(err))

    // Unknown browser, skip getStats() since it's anyone's guess which style of
    // getStats() they implement.
    } else {
      cb(null, [])
    }
  }

  _maybeReady () {
    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)
    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return

    this._connecting = true

    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339
    const findCandidatePair = () => {
      if (this.destroyed) return

      this.getStats((err, items) => {
        if (this.destroyed) return

        // Treat getStats error as non-fatal. It's not essential.
        if (err) items = []

        const remoteCandidates = {}
        const localCandidates = {}
        const candidatePairs = {}
        let foundSelectedCandidatePair = false

        items.forEach(item => {
          // TODO: Once all browsers support the hyphenated stats report types, remove
          // the non-hypenated ones
          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {
            remoteCandidates[item.id] = item
          }
          if (item.type === 'localcandidate' || item.type === 'local-candidate') {
            localCandidates[item.id] = item
          }
          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {
            candidatePairs[item.id] = item
          }
        })

        const setSelectedCandidatePair = selectedCandidatePair => {
          foundSelectedCandidatePair = true

          let local = localCandidates[selectedCandidatePair.localCandidateId]

          if (local && (local.ip || local.address)) {
            // Spec
            this.localAddress = local.ip || local.address
            this.localPort = Number(local.port)
          } else if (local && local.ipAddress) {
            // Firefox
            this.localAddress = local.ipAddress
            this.localPort = Number(local.portNumber)
          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {
            // TODO: remove this once Chrome 58 is released
            local = selectedCandidatePair.googLocalAddress.split(':')
            this.localAddress = local[0]
            this.localPort = Number(local[1])
          }
          if (this.localAddress) {
            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'
          }

          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]

          if (remote && (remote.ip || remote.address)) {
            // Spec
            this.remoteAddress = remote.ip || remote.address
            this.remotePort = Number(remote.port)
          } else if (remote && remote.ipAddress) {
            // Firefox
            this.remoteAddress = remote.ipAddress
            this.remotePort = Number(remote.portNumber)
          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {
            // TODO: remove this once Chrome 58 is released
            remote = selectedCandidatePair.googRemoteAddress.split(':')
            this.remoteAddress = remote[0]
            this.remotePort = Number(remote[1])
          }
          if (this.remoteAddress) {
            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'
          }

          this._debug(
            'connect local: %s:%s remote: %s:%s',
            this.localAddress,
            this.localPort,
            this.remoteAddress,
            this.remotePort
          )
        }

        items.forEach(item => {
          // Spec-compliant
          if (item.type === 'transport' && item.selectedCandidatePairId) {
            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])
          }

          // Old implementations
          if (
            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||
            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)
          ) {
            setSelectedCandidatePair(item)
          }
        })

        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates
        // But wait until at least 1 candidate pair is available
        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
          setTimeout(findCandidatePair, 100)
          return
        } else {
          this._connecting = false
          this._connected = true
        }

        if (this._chunk) {
          try {
            this.send(this._chunk)
          } catch (err) {
            return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
          }
          this._chunk = null
          this._debug('sent chunk from "write before connect"')

          const cb = this._cb
          this._cb = null
          cb(null)
        }

        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,
        // fallback to using setInterval to implement backpressure.
        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {
          this._interval = setInterval(() => this._onInterval(), 150)
          if (this._interval.unref) this._interval.unref()
        }

        this._debug('connect')
        this.emit('connect')
      })
    }
    findCandidatePair()
  }

  _onInterval () {
    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      return
    }
    this._onChannelBufferedAmountLow()
  }

  _onSignalingStateChange () {
    if (this.destroyed) return

    if (this._pc.signalingState === 'stable') {
      this._isNegotiating = false

      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'
      this._debug('flushing sender queue', this._sendersAwaitingStable)
      this._sendersAwaitingStable.forEach(sender => {
        this._pc.removeTrack(sender)
        this._queuedNegotiation = true
      })
      this._sendersAwaitingStable = []

      if (this._queuedNegotiation) {
        this._debug('flushing negotiation queue')
        this._queuedNegotiation = false
        this._needsNegotiation() // negotiate again
      } else {
        this._debug('negotiated')
        this.emit('negotiated')
      }
    }

    this._debug('signalingStateChange %s', this._pc.signalingState)
    this.emit('signalingStateChange', this._pc.signalingState)
  }

  _onIceCandidate (event) {
    if (this.destroyed) return
    if (event.candidate && this.trickle) {
      this.emit('signal', {
        type: 'candidate',
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      })
    } else if (!event.candidate && !this._iceComplete) {
      this._iceComplete = true
      this.emit('_iceComplete')
    }
    // as soon as we've received one valid candidate start timeout
    if (event.candidate) {
      this._startIceCompleteTimeout()
    }
  }

  _onChannelMessage (event) {
    if (this.destroyed) return
    let data = event.data
    if (data instanceof ArrayBuffer) data = Buffer.from(data)
    this.push(data)
  }

  _onChannelBufferedAmountLow () {
    if (this.destroyed || !this._cb) return
    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)
    const cb = this._cb
    this._cb = null
    cb(null)
  }

  _onChannelOpen () {
    if (this._connected || this.destroyed) return
    this._debug('on channel open')
    this._channelReady = true
    this._maybeReady()
  }

  _onChannelClose () {
    if (this.destroyed) return
    this._debug('on channel close')
    this.destroy()
  }

  _onTrack (event) {
    if (this.destroyed) return

    event.streams.forEach(eventStream => {
      this._debug('on track')
      this.emit('track', event.track, eventStream)

      this._remoteTracks.push({
        track: event.track,
        stream: eventStream
      })

      if (this._remoteStreams.some(remoteStream => {
        return remoteStream.id === eventStream.id
      })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream

      this._remoteStreams.push(eventStream)
      queueMicrotask(() => {
        this._debug('on stream')
        this.emit('stream', eventStream) // ensure all tracks have been added
      })
    })
  }

  _debug () {
    const args = [].slice.call(arguments)
    args[0] = '[' + this._id + '] ' + args[0]
    debug.apply(null, args)
  }
}

Peer.WEBRTC_SUPPORT = !!getBrowserRTC()

/**
 * Expose peer and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config or opts.channelConfig
 * when constructing a Peer.
 */
Peer.config = {
  iceServers: [
    {
      urls: [
        'stun:stun.l.google.com:19302',
        'stun:global.stun.twilio.com:3478'
      ]
    }
  ],
  sdpSemantics: 'unified-plan'
}

Peer.channelConfig = {}

module.exports = Peer

},{"buffer":117,"debug":10,"err-code":14,"get-browser-rtc":16,"queue-microtask":32,"randombytes":33,"readable-stream":48}],64:[function(require,module,exports){
var engine = require('../src/store-engine')

var storages = require('../storages/all')
var plugins = [require('../plugins/json2')]

module.exports = engine.createStore(storages, plugins)

},{"../plugins/json2":65,"../src/store-engine":67,"../storages/all":69}],65:[function(require,module,exports){
module.exports = json2Plugin

function json2Plugin() {
	require('./lib/json2')
	return {}
}

},{"./lib/json2":66}],66:[function(require,module,exports){
/* eslint-disable */

//  json2.js
//  2016-10-28
//  Public Domain.
//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
//  See http://www.JSON.org/js.html
//  This code should be minified before deployment.
//  See http://javascript.crockford.com/jsmin.html

//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
//  NOT CONTROL.

//  This file creates a global JSON object containing two methods: stringify
//  and parse. This file provides the ES5 JSON capability to ES3 systems.
//  If a project might run on IE8 or earlier, then this file should be included.
//  This file does nothing on ES5 systems.

//      JSON.stringify(value, replacer, space)
//          value       any JavaScript value, usually an object or array.
//          replacer    an optional parameter that determines how object
//                      values are stringified for objects. It can be a
//                      function or an array of strings.
//          space       an optional parameter that specifies the indentation
//                      of nested structures. If it is omitted, the text will
//                      be packed without extra whitespace. If it is a number,
//                      it will specify the number of spaces to indent at each
//                      level. If it is a string (such as "\t" or "&nbsp;"),
//                      it contains the characters used to indent at each level.
//          This method produces a JSON text from a JavaScript value.
//          When an object value is found, if the object contains a toJSON
//          method, its toJSON method will be called and the result will be
//          stringified. A toJSON method does not serialize: it returns the
//          value represented by the name/value pair that should be serialized,
//          or undefined if nothing should be serialized. The toJSON method
//          will be passed the key associated with the value, and this will be
//          bound to the value.

//          For example, this would serialize Dates as ISO strings.

//              Date.prototype.toJSON = function (key) {
//                  function f(n) {
//                      // Format integers to have at least two digits.
//                      return (n < 10)
//                          ? "0" + n
//                          : n;
//                  }
//                  return this.getUTCFullYear()   + "-" +
//                       f(this.getUTCMonth() + 1) + "-" +
//                       f(this.getUTCDate())      + "T" +
//                       f(this.getUTCHours())     + ":" +
//                       f(this.getUTCMinutes())   + ":" +
//                       f(this.getUTCSeconds())   + "Z";
//              };

//          You can provide an optional replacer method. It will be passed the
//          key and value of each member, with this bound to the containing
//          object. The value that is returned from your method will be
//          serialized. If your method returns undefined, then the member will
//          be excluded from the serialization.

//          If the replacer parameter is an array of strings, then it will be
//          used to select the members to be serialized. It filters the results
//          such that only members with keys listed in the replacer array are
//          stringified.

//          Values that do not have JSON representations, such as undefined or
//          functions, will not be serialized. Such values in objects will be
//          dropped; in arrays they will be replaced with null. You can use
//          a replacer function to replace those with JSON values.

//          JSON.stringify(undefined) returns undefined.

//          The optional space parameter produces a stringification of the
//          value that is filled with line breaks and indentation to make it
//          easier to read.

//          If the space parameter is a non-empty string, then that string will
//          be used for indentation. If the space parameter is a number, then
//          the indentation will be that many spaces.

//          Example:

//          text = JSON.stringify(["e", {pluribus: "unum"}]);
//          // text is '["e",{"pluribus":"unum"}]'

//          text = JSON.stringify(["e", {pluribus: "unum"}], null, "\t");
//          // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

//          text = JSON.stringify([new Date()], function (key, value) {
//              return this[key] instanceof Date
//                  ? "Date(" + this[key] + ")"
//                  : value;
//          });
//          // text is '["Date(---current time---)"]'

//      JSON.parse(text, reviver)
//          This method parses a JSON text to produce an object or array.
//          It can throw a SyntaxError exception.

//          The optional reviver parameter is a function that can filter and
//          transform the results. It receives each of the keys and values,
//          and its return value is used instead of the original value.
//          If it returns what it received, then the structure is not modified.
//          If it returns undefined then the member is deleted.

//          Example:

//          // Parse the text. Values that look like ISO date strings will
//          // be converted to Date objects.

//          myData = JSON.parse(text, function (key, value) {
//              var a;
//              if (typeof value === "string") {
//                  a =
//   /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
//                  if (a) {
//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
//                          +a[5], +a[6]));
//                  }
//              }
//              return value;
//          });

//          myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
//              var d;
//              if (typeof value === "string" &&
//                      value.slice(0, 5) === "Date(" &&
//                      value.slice(-1) === ")") {
//                  d = new Date(value.slice(5, -1));
//                  if (d) {
//                      return d;
//                  }
//              }
//              return value;
//          });

//  This is a reference implementation. You are free to copy, modify, or
//  redistribute.

/*jslint
    eval, for, this
*/

/*property
    JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== "object") {
    JSON = {};
}

(function () {
    "use strict";

    var rx_one = /^[\],:{}\s]*$/;
    var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
    var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
    var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10
            ? "0" + n
            : n;
    }

    function this_value() {
        return this.valueOf();
    }

    if (typeof Date.prototype.toJSON !== "function") {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear() + "-" +
                        f(this.getUTCMonth() + 1) + "-" +
                        f(this.getUTCDate()) + "T" +
                        f(this.getUTCHours()) + ":" +
                        f(this.getUTCMinutes()) + ":" +
                        f(this.getUTCSeconds()) + "Z"
                : null;
        };

        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
    }

    var gap;
    var indent;
    var meta;
    var rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string)
            ? "\"" + string.replace(rx_escapable, function (a) {
                var c = meta[a];
                return typeof c === "string"
                    ? c
                    : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }) + "\""
            : "\"" + string + "\"";
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i;          // The loop counter.
        var k;          // The member key.
        var v;          // The member value.
        var length;
        var mind = gap;
        var partial;
        var value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === "object" &&
                typeof value.toJSON === "function") {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === "function") {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case "string":
            return quote(value);

        case "number":

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value)
                ? String(value)
                : "null";

        case "boolean":
        case "null":

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce "null". The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is "object", we might be dealing with an object or an array or
// null.

        case "object":

// Due to a specification blunder in ECMAScript, typeof null is "object",
// so watch out for that case.

            if (!value) {
                return "null";
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === "[object Array]") {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || "null";
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? "[]"
                    : gap
                        ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
                        : "[" + partial.join(",") + "]";
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === "object") {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === "string") {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? "{}"
                : gap
                    ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                    : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== "function") {
        meta = {    // table of character substitutions
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\"": "\\\"",
            "\\": "\\\\"
        };
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = "";
            indent = "";

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === "number") {
                for (i = 0; i < space; i += 1) {
                    indent += " ";
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === "string") {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== "function" &&
                    (typeof replacer !== "object" ||
                    typeof replacer.length !== "number")) {
                throw new Error("JSON.stringify");
            }

// Make a fake root object containing our value under the key of "".
// Return the result of stringifying the value.

            return str("", {"": value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== "function") {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k;
                var v;
                var value = holder[key];
                if (value && typeof value === "object") {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return "\\u" +
                            ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with "()" and "new"
// because they can cause invocation, and "=" because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with "@" (a non-JSON character). Second, we
// replace all simple value tokens with "]" characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or "]" or
// "," or ":" or "{" or "}". If that is so, then the text is safe for eval.

            if (
                rx_one.test(
                    text
                        .replace(rx_two, "@")
                        .replace(rx_three, "]")
                        .replace(rx_four, "")
                )
            ) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The "{" operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval("(" + text + ")");

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return (typeof reviver === "function")
                    ? walk({"": j}, "")
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError("JSON.parse");
        };
    }
}());
},{}],67:[function(require,module,exports){
var util = require('./util')
var slice = util.slice
var pluck = util.pluck
var each = util.each
var bind = util.bind
var create = util.create
var isList = util.isList
var isFunction = util.isFunction
var isObject = util.isObject

module.exports = {
	createStore: createStore
}

var storeAPI = {
	version: '2.0.12',
	enabled: false,
	
	// get returns the value of the given key. If that value
	// is undefined, it returns optionalDefaultValue instead.
	get: function(key, optionalDefaultValue) {
		var data = this.storage.read(this._namespacePrefix + key)
		return this._deserialize(data, optionalDefaultValue)
	},

	// set will store the given value at key and returns value.
	// Calling set with value === undefined is equivalent to calling remove.
	set: function(key, value) {
		if (value === undefined) {
			return this.remove(key)
		}
		this.storage.write(this._namespacePrefix + key, this._serialize(value))
		return value
	},

	// remove deletes the key and value stored at the given key.
	remove: function(key) {
		this.storage.remove(this._namespacePrefix + key)
	},

	// each will call the given callback once for each key-value pair
	// in this store.
	each: function(callback) {
		var self = this
		this.storage.each(function(val, namespacedKey) {
			callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''))
		})
	},

	// clearAll will remove all the stored key-value pairs in this store.
	clearAll: function() {
		this.storage.clearAll()
	},

	// additional functionality that can't live in plugins
	// ---------------------------------------------------

	// hasNamespace returns true if this store instance has the given namespace.
	hasNamespace: function(namespace) {
		return (this._namespacePrefix == '__storejs_'+namespace+'_')
	},

	// createStore creates a store.js instance with the first
	// functioning storage in the list of storage candidates,
	// and applies the the given mixins to the instance.
	createStore: function() {
		return createStore.apply(this, arguments)
	},
	
	addPlugin: function(plugin) {
		this._addPlugin(plugin)
	},
	
	namespace: function(namespace) {
		return createStore(this.storage, this.plugins, namespace)
	}
}

function _warn() {
	var _console = (typeof console == 'undefined' ? null : console)
	if (!_console) { return }
	var fn = (_console.warn ? _console.warn : _console.log)
	fn.apply(_console, arguments)
}

function createStore(storages, plugins, namespace) {
	if (!namespace) {
		namespace = ''
	}
	if (storages && !isList(storages)) {
		storages = [storages]
	}
	if (plugins && !isList(plugins)) {
		plugins = [plugins]
	}

	var namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '')
	var namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null)
	var legalNamespaces = /^[a-zA-Z0-9_\-]*$/ // alpha-numeric + underscore and dash
	if (!legalNamespaces.test(namespace)) {
		throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes')
	}
	
	var _privateStoreProps = {
		_namespacePrefix: namespacePrefix,
		_namespaceRegexp: namespaceRegexp,

		_testStorage: function(storage) {
			try {
				var testStr = '__storejs__test__'
				storage.write(testStr, testStr)
				var ok = (storage.read(testStr) === testStr)
				storage.remove(testStr)
				return ok
			} catch(e) {
				return false
			}
		},

		_assignPluginFnProp: function(pluginFnProp, propName) {
			var oldFn = this[propName]
			this[propName] = function pluginFn() {
				var args = slice(arguments, 0)
				var self = this

				// super_fn calls the old function which was overwritten by
				// this mixin.
				function super_fn() {
					if (!oldFn) { return }
					each(arguments, function(arg, i) {
						args[i] = arg
					})
					return oldFn.apply(self, args)
				}

				// Give mixing function access to super_fn by prefixing all mixin function
				// arguments with super_fn.
				var newFnArgs = [super_fn].concat(args)

				return pluginFnProp.apply(self, newFnArgs)
			}
		},

		_serialize: function(obj) {
			return JSON.stringify(obj)
		},

		_deserialize: function(strVal, defaultVal) {
			if (!strVal) { return defaultVal }
			// It is possible that a raw string value has been previously stored
			// in a storage without using store.js, meaning it will be a raw
			// string value instead of a JSON serialized string. By defaulting
			// to the raw string value in case of a JSON parse error, we allow
			// for past stored values to be forwards-compatible with store.js
			var val = ''
			try { val = JSON.parse(strVal) }
			catch(e) { val = strVal }

			return (val !== undefined ? val : defaultVal)
		},
		
		_addStorage: function(storage) {
			if (this.enabled) { return }
			if (this._testStorage(storage)) {
				this.storage = storage
				this.enabled = true
			}
		},

		_addPlugin: function(plugin) {
			var self = this

			// If the plugin is an array, then add all plugins in the array.
			// This allows for a plugin to depend on other plugins.
			if (isList(plugin)) {
				each(plugin, function(plugin) {
					self._addPlugin(plugin)
				})
				return
			}

			// Keep track of all plugins we've seen so far, so that we
			// don't add any of them twice.
			var seenPlugin = pluck(this.plugins, function(seenPlugin) {
				return (plugin === seenPlugin)
			})
			if (seenPlugin) {
				return
			}
			this.plugins.push(plugin)

			// Check that the plugin is properly formed
			if (!isFunction(plugin)) {
				throw new Error('Plugins must be function values that return objects')
			}

			var pluginProperties = plugin.call(this)
			if (!isObject(pluginProperties)) {
				throw new Error('Plugins must return an object of function properties')
			}

			// Add the plugin function properties to this store instance.
			each(pluginProperties, function(pluginFnProp, propName) {
				if (!isFunction(pluginFnProp)) {
					throw new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')
				}
				self._assignPluginFnProp(pluginFnProp, propName)
			})
		},
		
		// Put deprecated properties in the private API, so as to not expose it to accidential
		// discovery through inspection of the store object.
		
		// Deprecated: addStorage
		addStorage: function(storage) {
			_warn('store.addStorage(storage) is deprecated. Use createStore([storages])')
			this._addStorage(storage)
		}
	}

	var store = create(_privateStoreProps, storeAPI, {
		plugins: []
	})
	store.raw = {}
	each(store, function(prop, propName) {
		if (isFunction(prop)) {
			store.raw[propName] = bind(store, prop)			
		}
	})
	each(storages, function(storage) {
		store._addStorage(storage)
	})
	each(plugins, function(plugin) {
		store._addPlugin(plugin)
	})
	return store
}

},{"./util":68}],68:[function(require,module,exports){
(function (global){(function (){
var assign = make_assign()
var create = make_create()
var trim = make_trim()
var Global = (typeof window !== 'undefined' ? window : global)

module.exports = {
	assign: assign,
	create: create,
	trim: trim,
	bind: bind,
	slice: slice,
	each: each,
	map: map,
	pluck: pluck,
	isList: isList,
	isFunction: isFunction,
	isObject: isObject,
	Global: Global
}

function make_assign() {
	if (Object.assign) {
		return Object.assign
	} else {
		return function shimAssign(obj, props1, props2, etc) {
			for (var i = 1; i < arguments.length; i++) {
				each(Object(arguments[i]), function(val, key) {
					obj[key] = val
				})
			}			
			return obj
		}
	}
}

function make_create() {
	if (Object.create) {
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1)
			return assign.apply(this, [Object.create(obj)].concat(assignArgsList))
		}
	} else {
		function F() {} // eslint-disable-line no-inner-declarations
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1)
			F.prototype = obj
			return assign.apply(this, [new F()].concat(assignArgsList))
		}
	}
}

function make_trim() {
	if (String.prototype.trim) {
		return function trim(str) {
			return String.prototype.trim.call(str)
		}
	} else {
		return function trim(str) {
			return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
		}
	}
}

function bind(obj, fn) {
	return function() {
		return fn.apply(obj, Array.prototype.slice.call(arguments, 0))
	}
}

function slice(arr, index) {
	return Array.prototype.slice.call(arr, index || 0)
}

function each(obj, fn) {
	pluck(obj, function(val, key) {
		fn(val, key)
		return false
	})
}

function map(obj, fn) {
	var res = (isList(obj) ? [] : {})
	pluck(obj, function(v, k) {
		res[k] = fn(v, k)
		return false
	})
	return res
}

function pluck(obj, fn) {
	if (isList(obj)) {
		for (var i=0; i<obj.length; i++) {
			if (fn(obj[i], i)) {
				return obj[i]
			}
		}
	} else {
		for (var key in obj) {
			if (obj.hasOwnProperty(key)) {
				if (fn(obj[key], key)) {
					return obj[key]
				}
			}
		}
	}
}

function isList(val) {
	return (val != null && typeof val != 'function' && typeof val.length == 'number')
}

function isFunction(val) {
	return val && {}.toString.call(val) === '[object Function]'
}

function isObject(val) {
	return val && {}.toString.call(val) === '[object Object]'
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],69:[function(require,module,exports){
module.exports = [
	// Listed in order of usage preference
	require('./localStorage'),
	require('./oldFF-globalStorage'),
	require('./oldIE-userDataStorage'),
	require('./cookieStorage'),
	require('./sessionStorage'),
	require('./memoryStorage')
]

},{"./cookieStorage":70,"./localStorage":71,"./memoryStorage":72,"./oldFF-globalStorage":73,"./oldIE-userDataStorage":74,"./sessionStorage":75}],70:[function(require,module,exports){
// cookieStorage is useful Safari private browser mode, where localStorage
// doesn't work but cookies do. This implementation is adopted from
// https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage

var util = require('../src/util')
var Global = util.Global
var trim = util.trim

module.exports = {
	name: 'cookieStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var doc = Global.document

function read(key) {
	if (!key || !_has(key)) { return null }
	var regexpStr = "(?:^|.*;\\s*)" +
		escape(key).replace(/[\-\.\+\*]/g, "\\$&") +
		"\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"
	return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"))
}

function each(callback) {
	var cookies = doc.cookie.split(/; ?/g)
	for (var i = cookies.length - 1; i >= 0; i--) {
		if (!trim(cookies[i])) {
			continue
		}
		var kvp = cookies[i].split('=')
		var key = unescape(kvp[0])
		var val = unescape(kvp[1])
		callback(val, key)
	}
}

function write(key, data) {
	if(!key) { return }
	doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/"
}

function remove(key) {
	if (!key || !_has(key)) {
		return
	}
	doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/"
}

function clearAll() {
	each(function(_, key) {
		remove(key)
	})
}

function _has(key) {
	return (new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(doc.cookie)
}

},{"../src/util":68}],71:[function(require,module,exports){
var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'localStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

function localStorage() {
	return Global.localStorage
}

function read(key) {
	return localStorage().getItem(key)
}

function write(key, data) {
	return localStorage().setItem(key, data)
}

function each(fn) {
	for (var i = localStorage().length - 1; i >= 0; i--) {
		var key = localStorage().key(i)
		fn(read(key), key)
	}
}

function remove(key) {
	return localStorage().removeItem(key)
}

function clearAll() {
	return localStorage().clear()
}

},{"../src/util":68}],72:[function(require,module,exports){
// memoryStorage is a useful last fallback to ensure that the store
// is functions (meaning store.get(), store.set(), etc will all function).
// However, stored values will not persist when the browser navigates to
// a new page or reloads the current page.

module.exports = {
	name: 'memoryStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var memoryStorage = {}

function read(key) {
	return memoryStorage[key]
}

function write(key, data) {
	memoryStorage[key] = data
}

function each(callback) {
	for (var key in memoryStorage) {
		if (memoryStorage.hasOwnProperty(key)) {
			callback(memoryStorage[key], key)
		}
	}
}

function remove(key) {
	delete memoryStorage[key]
}

function clearAll(key) {
	memoryStorage = {}
}

},{}],73:[function(require,module,exports){
// oldFF-globalStorage provides storage for Firefox
// versions 6 and 7, where no localStorage, etc
// is available.

var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'oldFF-globalStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var globalStorage = Global.globalStorage

function read(key) {
	return globalStorage[key]
}

function write(key, data) {
	globalStorage[key] = data
}

function each(fn) {
	for (var i = globalStorage.length - 1; i >= 0; i--) {
		var key = globalStorage.key(i)
		fn(globalStorage[key], key)
	}
}

function remove(key) {
	return globalStorage.removeItem(key)
}

function clearAll() {
	each(function(key, _) {
		delete globalStorage[key]
	})
}

},{"../src/util":68}],74:[function(require,module,exports){
// oldIE-userDataStorage provides storage for Internet Explorer
// versions 6 and 7, where no localStorage, sessionStorage, etc
// is available.

var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'oldIE-userDataStorage',
	write: write,
	read: read,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var storageName = 'storejs'
var doc = Global.document
var _withStorageEl = _makeIEStorageElFunction()
var disable = (Global.navigator ? Global.navigator.userAgent : '').match(/ (MSIE 8|MSIE 9|MSIE 10)\./) // MSIE 9.x, MSIE 10.x

function write(unfixedKey, data) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey)
	_withStorageEl(function(storageEl) {
		storageEl.setAttribute(fixedKey, data)
		storageEl.save(storageName)
	})
}

function read(unfixedKey) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey)
	var res = null
	_withStorageEl(function(storageEl) {
		res = storageEl.getAttribute(fixedKey)
	})
	return res
}

function each(callback) {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes
		for (var i=attributes.length-1; i>=0; i--) {
			var attr = attributes[i]
			callback(storageEl.getAttribute(attr.name), attr.name)
		}
	})
}

function remove(unfixedKey) {
	var fixedKey = fixKey(unfixedKey)
	_withStorageEl(function(storageEl) {
		storageEl.removeAttribute(fixedKey)
		storageEl.save(storageName)
	})
}

function clearAll() {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes
		storageEl.load(storageName)
		for (var i=attributes.length-1; i>=0; i--) {
			storageEl.removeAttribute(attributes[i].name)
		}
		storageEl.save(storageName)
	})
}

// Helpers
//////////

// In IE7, keys cannot start with a digit or contain certain chars.
// See https://github.com/marcuswestin/store.js/issues/40
// See https://github.com/marcuswestin/store.js/issues/83
var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g")
function fixKey(key) {
	return key.replace(/^\d/, '___$&').replace(forbiddenCharsRegex, '___')
}

function _makeIEStorageElFunction() {
	if (!doc || !doc.documentElement || !doc.documentElement.addBehavior) {
		return null
	}
	var scriptTag = 'script',
		storageOwner,
		storageContainer,
		storageEl

	// Since #userData storage applies only to specific paths, we need to
	// somehow link our data to a specific path.  We choose /favicon.ico
	// as a pretty safe option, since all browsers already make a request to
	// this URL anyway and being a 404 will not hurt us here.  We wrap an
	// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
	// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
	// since the iframe access rules appear to allow direct access and
	// manipulation of the document element, even for a 404 page.  This
	// document can be used instead of the current document (which would
	// have been limited to the current path) to perform #userData storage.
	try {
		/* global ActiveXObject */
		storageContainer = new ActiveXObject('htmlfile')
		storageContainer.open()
		storageContainer.write('<'+scriptTag+'>document.w=window</'+scriptTag+'><iframe src="/favicon.ico"></iframe>')
		storageContainer.close()
		storageOwner = storageContainer.w.frames[0].document
		storageEl = storageOwner.createElement('div')
	} catch(e) {
		// somehow ActiveXObject instantiation failed (perhaps some special
		// security settings or otherwse), fall back to per-path storage
		storageEl = doc.createElement('div')
		storageOwner = doc.body
	}

	return function(storeFunction) {
		var args = [].slice.call(arguments, 0)
		args.unshift(storageEl)
		// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
		// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
		storageOwner.appendChild(storageEl)
		storageEl.addBehavior('#default#userData')
		storageEl.load(storageName)
		storeFunction.apply(this, args)
		storageOwner.removeChild(storageEl)
		return
	}
}

},{"../src/util":68}],75:[function(require,module,exports){
var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'sessionStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll
}

function sessionStorage() {
	return Global.sessionStorage
}

function read(key) {
	return sessionStorage().getItem(key)
}

function write(key, data) {
	return sessionStorage().setItem(key, data)
}

function each(fn) {
	for (var i = sessionStorage().length - 1; i >= 0; i--) {
		var key = sessionStorage().key(i)
		fn(read(key), key)
	}
}

function remove(key) {
	return sessionStorage().removeItem(key)
}

function clearAll() {
	return sessionStorage().clear()
}

},{"../src/util":68}],76:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":50}],77:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":78,"./_stream_writable":80,"_process":136,"core-util-is":9,"inherits":21}],78:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;
  var ret;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    ret = null;

    // In cases where the decoder did not receive enough data
    // to produce a full chunk, then immediately received an
    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
    // howMuchToRead will see this and coerce the amount to
    // read to zero (because it's looking at the length of the
    // first <Buffer > in state.buffer), and we'll end up here.
    //
    // This can only happen via state.decoder -- no other venue
    // exists for pushing a zero-length chunk into state.buffer
    // and triggering this behavior. In this case, we return our
    // remaining data and end the stream, if appropriate.
    if (state.length > 0 && state.decoder) {
      ret = fromList(n, state);
      state.length -= ret.length;
    }

    if (state.length === 0)
      endReadable(this);

    return ret;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    //if (state.objectMode && util.isNullOrUndefined(chunk))
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this)}).call(this,require('_process'))

},{"_process":136,"buffer":117,"core-util-is":9,"events":121,"inherits":21,"isarray":81,"stream":141,"string_decoder/":82}],79:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":77,"core-util-is":9,"inherits":21}],80:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this)}).call(this,require('_process'))

},{"./_stream_duplex":77,"_process":136,"buffer":117,"core-util-is":9,"inherits":21,"stream":141}],81:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],82:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":117}],83:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":79}],84:[function(require,module,exports){
(function (process){(function (){
var Transform = require('readable-stream/transform')
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

},{"_process":136,"readable-stream/transform":83,"util":161,"xtend":111}],85:[function(require,module,exports){
var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":117}],86:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./nil.js":89,"./parse.js":90,"./stringify.js":94,"./v1.js":95,"./v3.js":96,"./v4.js":98,"./v5.js":99,"./validate.js":100,"./version.js":101}],88:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
},{}],89:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
},{}],90:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
},{"./validate.js":100}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
},{}],92:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
},{}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
},{}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
},{"./validate.js":100}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;
},{"./rng.js":92,"./stringify.js":94}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
},{"./md5.js":88,"./v35.js":97}],97:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
},{"./parse.js":90,"./stringify.js":94}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;
},{"./rng.js":92,"./stringify.js":94}],99:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
},{"./sha1.js":93,"./v35.js":97}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
},{"./regex.js":91}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
},{"./validate.js":100}],102:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

// Shimming starts here.
(function() {
  // Utils.
  var logging = require('./utils').log;
  var browserDetails = require('./utils').browserDetails;
  // Export to the adapter global object visible in the browser.
  module.exports.browserDetails = browserDetails;
  module.exports.extractVersion = require('./utils').extractVersion;
  module.exports.disableLog = require('./utils').disableLog;

  // Uncomment the line below if you want logging to occur, including logging
  // for the switch statement below. Can also be turned on in the browser via
  // adapter.disableLog(false), but then logging from the switch statement below
  // will not appear.
  // require('./utils').disableLog(false);

  // Browser shims.
  var chromeShim = require('./chrome/chrome_shim') || null;
  var edgeShim = require('./edge/edge_shim') || null;
  var firefoxShim = require('./firefox/firefox_shim') || null;
  var safariShim = require('./safari/safari_shim') || null;

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'opera': // fallthrough as it uses chrome shims
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection) {
        logging('Chrome shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = chromeShim;

      chromeShim.shimGetUserMedia();
      chromeShim.shimMediaStream();
      chromeShim.shimSourceObject();
      chromeShim.shimPeerConnection();
      chromeShim.shimOnTrack();
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection) {
        logging('Firefox shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = firefoxShim;

      firefoxShim.shimGetUserMedia();
      firefoxShim.shimSourceObject();
      firefoxShim.shimPeerConnection();
      firefoxShim.shimOnTrack();
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection) {
        logging('MS edge shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = edgeShim;

      edgeShim.shimGetUserMedia();
      edgeShim.shimPeerConnection();
      break;
    case 'safari':
      if (!safariShim) {
        logging('Safari shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = safariShim;

      safariShim.shimGetUserMedia();
      break;
    default:
      logging('Unsupported browser!');
  }
})();

},{"./chrome/chrome_shim":103,"./edge/edge_shim":105,"./firefox/firefox_shim":107,"./safari/safari_shim":109,"./utils":110}],103:[function(require,module,exports){

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var logging = require('../utils.js').log;
var browserDetails = require('../utils.js').browserDetails;

var chromeShim = {
  shimMediaStream: function() {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  },

  shimOnTrack: function() {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          var self = this;
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function(te) {
              var event = new Event('track');
              event.track = te.track;
              event.receiver = {track: te.track};
              event.streams = [e.stream];
              self.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        }
      });
    }
  },

  shimSourceObject: function() {
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this._srcObject;
          },
          set: function(stream) {
            var self = this;
            // Use _srcObject as a private property for this shim
            this._srcObject = stream;
            if (this.src) {
              URL.revokeObjectURL(this.src);
            }

            if (!stream) {
              this.src = '';
              return;
            }
            this.src = URL.createObjectURL(stream);
            // We need to recreate the blob url when a track is added or
            // removed. Doing it manually since we want to avoid a recursion.
            stream.addEventListener('addtrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
            stream.addEventListener('removetrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
          }
        });
      }
    }
  },

  shimPeerConnection: function() {
    // The RTCPeerConnection object.
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      // Translate iceTransportPolicy to iceTransports,
      // see https://code.google.com/p/webrtc/issues/detail?id=4869
      logging('PeerConnection');
      if (pcConfig && pcConfig.iceTransportPolicy) {
        pcConfig.iceTransports = pcConfig.iceTransportPolicy;
      }

      var pc = new webkitRTCPeerConnection(pcConfig, pcConstraints);
      var origGetStats = pc.getStats.bind(pc);
      pc.getStats = function(selector, successCallback, errorCallback) {
        var self = this;
        var args = arguments;

        // If selector is a function then we are in the old style stats so just
        // pass back the original getStats format to avoid breaking old users.
        if (arguments.length > 0 && typeof selector === 'function') {
          return origGetStats(selector, successCallback);
        }

        var fixChromeStats_ = function(response) {
          var standardReport = {};
          var reports = response.result();
          reports.forEach(function(report) {
            var standardStats = {
              id: report.id,
              timestamp: report.timestamp,
              type: report.type
            };
            report.names().forEach(function(name) {
              standardStats[name] = report.stat(name);
            });
            standardReport[standardStats.id] = standardStats;
          });

          return standardReport;
        };

        // shim getStats with maplike support
        var makeMapStats = function(stats, legacyStats) {
          var map = new Map(Object.keys(stats).map(function(key) {
            return[key, stats[key]];
          }));
          legacyStats = legacyStats || stats;
          Object.keys(legacyStats).forEach(function(key) {
            map[key] = legacyStats[key];
          });
          return map;
        };

        if (arguments.length >= 2) {
          var successCallbackWrapper_ = function(response) {
            args[1](makeMapStats(fixChromeStats_(response)));
          };

          return origGetStats.apply(this, [successCallbackWrapper_,
              arguments[0]]);
        }

        // promise-support
        return new Promise(function(resolve, reject) {
          if (args.length === 1 && typeof selector === 'object') {
            origGetStats.apply(self, [
              function(response) {
                resolve(makeMapStats(fixChromeStats_(response)));
              }, reject]);
          } else {
            // Preserve legacy chrome stats only on legacy access of stats obj
            origGetStats.apply(self, [
              function(response) {
                resolve(makeMapStats(fixChromeStats_(response),
                    response.result()));
              }, reject]);
          }
        }).then(successCallback, errorCallback);
      };

      return pc;
    };
    window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype;

    // wrap static methods. Currently just generateCertificate.
    if (webkitRTCPeerConnection.generateCertificate) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return webkitRTCPeerConnection.generateCertificate;
        }
      });
    }

    ['createOffer', 'createAnswer'].forEach(function(method) {
      var nativeMethod = webkitRTCPeerConnection.prototype[method];
      webkitRTCPeerConnection.prototype[method] = function() {
        var self = this;
        if (arguments.length < 1 || (arguments.length === 1 &&
            typeof arguments[0] === 'object')) {
          var opts = arguments.length === 1 ? arguments[0] : undefined;
          return new Promise(function(resolve, reject) {
            nativeMethod.apply(self, [resolve, reject, opts]);
          });
        }
        return nativeMethod.apply(this, arguments);
      };
    });

    // add promise support -- natively available in Chrome 51
    if (browserDetails.version < 51) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
          .forEach(function(method) {
            var nativeMethod = webkitRTCPeerConnection.prototype[method];
            webkitRTCPeerConnection.prototype[method] = function() {
              var args = arguments;
              var self = this;
              var promise = new Promise(function(resolve, reject) {
                nativeMethod.apply(self, [args[0], resolve, reject]);
              });
              if (args.length < 2) {
                return promise;
              }
              return promise.then(function() {
                args[1].apply(null, []);
              },
              function(err) {
                if (args.length >= 3) {
                  args[2].apply(null, [err]);
                }
              });
            };
          });
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = webkitRTCPeerConnection.prototype[method];
          webkitRTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                RTCIceCandidate : RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        RTCPeerConnection.prototype.addIceCandidate;
    RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }
};


// Expose public methods.
module.exports = {
  shimMediaStream: chromeShim.shimMediaStream,
  shimOnTrack: chromeShim.shimOnTrack,
  shimSourceObject: chromeShim.shimSourceObject,
  shimPeerConnection: chromeShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils.js":110,"./getusermedia":104}],104:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var logging = require('../utils.js').log;

// Expose public methods.
module.exports = function() {
  var constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function(mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function(constraints, func) {
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && constraints.audio) {
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile, where it defaults to "user".
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode)) {
        delete constraints.video.facingMode;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          // Look for "back" in label, or use last cam (typically back cam).
          return navigator.mediaDevices.enumerateDevices()
          .then(function(devices) {
            devices = devices.filter(function(d) {
              return d.kind === 'videoinput';
            });
            var back = devices.find(function(d) {
              return d.label.toLowerCase().indexOf('back') !== -1;
            }) || (devices.length && devices[devices.length - 1]);
            if (back) {
              constraints.video.deviceId = face.exact ? {exact: back.deviceId} :
                                                        {ideal: back.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function(e) {
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        ConstraintNotSatisfiedError: 'OverconstrainedError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraintName,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function(c) {
      navigator.webkitGetUserMedia(c, onSuccess, function(e) {
        onError(shimError_(e));
      });
    });
  };

  navigator.getUserMedia = getUserMedia_;

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      navigator.getUserMedia(constraints, resolve, reject);
    });
  };

  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {
      getUserMedia: getUserMediaPromise_,
      enumerateDevices: function() {
        return new Promise(function(resolve) {
          var kinds = {audio: 'audioinput', video: 'videoinput'};
          return MediaStreamTrack.getSources(function(devices) {
            resolve(devices.map(function(device) {
              return {label: device.label,
                      kind: kinds[device.kind],
                      deviceId: device.id,
                      groupId: ''};
            }));
          });
        });
      }
    };
  }

  // A shim for getUserMedia method on the mediaDevices object.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (!navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      return getUserMediaPromise_(constraints);
    };
  } else {
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, function(c) {
        return origGetUserMedia(c).then(function(stream) {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function(e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }

  // Dummy devicechange event methods.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
    navigator.mediaDevices.addEventListener = function() {
      logging('Dummy mediaDevices.addEventListener called.');
    };
  }
  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
    navigator.mediaDevices.removeEventListener = function() {
      logging('Dummy mediaDevices.removeEventListener called.');
    };
  }
};

},{"../utils.js":110}],105:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');
var browserDetails = require('../utils').browserDetails;

var edgeShim = {
  shimPeerConnection: function() {
    if (window.RTCIceGatherer) {
      // ORTC defines an RTCIceCandidate object but no constructor.
      // Not implemented in Edge.
      if (!window.RTCIceCandidate) {
        window.RTCIceCandidate = function(args) {
          return args;
        };
      }
      // ORTC does not have a session description object but
      // other browsers (i.e. Chrome) that will support both PC and ORTC
      // in the future might have this defined already.
      if (!window.RTCSessionDescription) {
        window.RTCSessionDescription = function(args) {
          return args;
        };
      }
      // this adds an additional event listener to MediaStrackTrack that signals
      // when a tracks enabled property was changed.
      var origMSTEnabled = Object.getOwnPropertyDescriptor(
          MediaStreamTrack.prototype, 'enabled');
      Object.defineProperty(MediaStreamTrack.prototype, 'enabled', {
        set: function(value) {
          origMSTEnabled.set.call(this, value);
          var ev = new Event('enabled');
          ev.enabled = value;
          this.dispatchEvent(ev);
        }
      });
    }

    window.RTCPeerConnection = function(config) {
      var self = this;

      var _eventTarget = document.createDocumentFragment();
      ['addEventListener', 'removeEventListener', 'dispatchEvent']
          .forEach(function(method) {
            self[method] = _eventTarget[method].bind(_eventTarget);
          });

      this.onicecandidate = null;
      this.onaddstream = null;
      this.ontrack = null;
      this.onremovestream = null;
      this.onsignalingstatechange = null;
      this.oniceconnectionstatechange = null;
      this.onnegotiationneeded = null;
      this.ondatachannel = null;

      this.localStreams = [];
      this.remoteStreams = [];
      this.getLocalStreams = function() {
        return self.localStreams;
      };
      this.getRemoteStreams = function() {
        return self.remoteStreams;
      };

      this.localDescription = new RTCSessionDescription({
        type: '',
        sdp: ''
      });
      this.remoteDescription = new RTCSessionDescription({
        type: '',
        sdp: ''
      });
      this.signalingState = 'stable';
      this.iceConnectionState = 'new';
      this.iceGatheringState = 'new';

      this.iceOptions = {
        gatherPolicy: 'all',
        iceServers: []
      };
      if (config && config.iceTransportPolicy) {
        switch (config.iceTransportPolicy) {
          case 'all':
          case 'relay':
            this.iceOptions.gatherPolicy = config.iceTransportPolicy;
            break;
          case 'none':
            // FIXME: remove once implementation and spec have added this.
            throw new TypeError('iceTransportPolicy "none" not supported');
          default:
            // don't set iceTransportPolicy.
            break;
        }
      }
      this.usingBundle = config && config.bundlePolicy === 'max-bundle';

      if (config && config.iceServers) {
        // Edge does not like
        // 1) stun:
        // 2) turn: that does not have all of turn:host:port?transport=udp
        // 3) turn: with ipv6 addresses
        var iceServers = JSON.parse(JSON.stringify(config.iceServers));
        this.iceOptions.iceServers = iceServers.filter(function(server) {
          if (server && server.urls) {
            var urls = server.urls;
            if (typeof urls === 'string') {
              urls = [urls];
            }
            urls = urls.filter(function(url) {
              return (url.indexOf('turn:') === 0 &&
                  url.indexOf('transport=udp') !== -1 &&
                  url.indexOf('turn:[') === -1) ||
                  (url.indexOf('stun:') === 0 &&
                    browserDetails.version >= 14393);
            })[0];
            return !!urls;
          }
          return false;
        });
      }
      this._config = config;

      // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
      // everything that is needed to describe a SDP m-line.
      this.transceivers = [];

      // since the iceGatherer is currently created in createOffer but we
      // must not emit candidates until after setLocalDescription we buffer
      // them in this array.
      this._localIceCandidatesBuffer = [];
    };

    window.RTCPeerConnection.prototype._emitBufferedCandidates = function() {
      var self = this;
      var sections = SDPUtils.splitSections(self.localDescription.sdp);
      // FIXME: need to apply ice candidates in a way which is async but
      // in-order
      this._localIceCandidatesBuffer.forEach(function(event) {
        var end = !event.candidate || Object.keys(event.candidate).length === 0;
        if (end) {
          for (var j = 1; j < sections.length; j++) {
            if (sections[j].indexOf('\r\na=end-of-candidates\r\n') === -1) {
              sections[j] += 'a=end-of-candidates\r\n';
            }
          }
        } else if (event.candidate.candidate.indexOf('typ endOfCandidates')
            === -1) {
          sections[event.candidate.sdpMLineIndex + 1] +=
              'a=' + event.candidate.candidate + '\r\n';
        }
        self.localDescription.sdp = sections.join('');
        self.dispatchEvent(event);
        if (self.onicecandidate !== null) {
          self.onicecandidate(event);
        }
        if (!event.candidate && self.iceGatheringState !== 'complete') {
          var complete = self.transceivers.every(function(transceiver) {
            return transceiver.iceGatherer &&
                transceiver.iceGatherer.state === 'completed';
          });
          if (complete) {
            self.iceGatheringState = 'complete';
          }
        }
      });
      this._localIceCandidatesBuffer = [];
    };

    window.RTCPeerConnection.prototype.getConfiguration = function() {
      return this._config;
    };

    window.RTCPeerConnection.prototype.addStream = function(stream) {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      this.localStreams.push(clonedStream);
      this._maybeFireNegotiationNeeded();
    };

    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var idx = this.localStreams.indexOf(stream);
      if (idx > -1) {
        this.localStreams.splice(idx, 1);
        this._maybeFireNegotiationNeeded();
      }
    };

    window.RTCPeerConnection.prototype.getSenders = function() {
      return this.transceivers.filter(function(transceiver) {
        return !!transceiver.rtpSender;
      })
      .map(function(transceiver) {
        return transceiver.rtpSender;
      });
    };

    window.RTCPeerConnection.prototype.getReceivers = function() {
      return this.transceivers.filter(function(transceiver) {
        return !!transceiver.rtpReceiver;
      })
      .map(function(transceiver) {
        return transceiver.rtpReceiver;
      });
    };

    // Determines the intersection of local and remote capabilities.
    window.RTCPeerConnection.prototype._getCommonCapabilities =
        function(localCapabilities, remoteCapabilities) {
          var commonCapabilities = {
            codecs: [],
            headerExtensions: [],
            fecMechanisms: []
          };
          localCapabilities.codecs.forEach(function(lCodec) {
            for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
              var rCodec = remoteCapabilities.codecs[i];
              if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
                  lCodec.clockRate === rCodec.clockRate) {
                // number of channels is the highest common number of channels
                rCodec.numChannels = Math.min(lCodec.numChannels,
                    rCodec.numChannels);
                // push rCodec so we reply with offerer payload type
                commonCapabilities.codecs.push(rCodec);

                // determine common feedback mechanisms
                rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
                  for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
                    if (lCodec.rtcpFeedback[j].type === fb.type &&
                        lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                      return true;
                    }
                  }
                  return false;
                });
                // FIXME: also need to determine .parameters
                //  see https://github.com/openpeer/ortc/issues/569
                break;
              }
            }
          });

          localCapabilities.headerExtensions
              .forEach(function(lHeaderExtension) {
                for (var i = 0; i < remoteCapabilities.headerExtensions.length;
                     i++) {
                  var rHeaderExtension = remoteCapabilities.headerExtensions[i];
                  if (lHeaderExtension.uri === rHeaderExtension.uri) {
                    commonCapabilities.headerExtensions.push(rHeaderExtension);
                    break;
                  }
                }
              });

          // FIXME: fecMechanisms
          return commonCapabilities;
        };

    // Create ICE gatherer, ICE transport and DTLS transport.
    window.RTCPeerConnection.prototype._createIceAndDtlsTransports =
        function(mid, sdpMLineIndex) {
          var self = this;
          var iceGatherer = new RTCIceGatherer(self.iceOptions);
          var iceTransport = new RTCIceTransport(iceGatherer);
          iceGatherer.onlocalcandidate = function(evt) {
            var event = new Event('icecandidate');
            event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

            var cand = evt.candidate;
            var end = !cand || Object.keys(cand).length === 0;
            // Edge emits an empty object for RTCIceCandidateComplete
            if (end) {
              // polyfill since RTCIceGatherer.state is not implemented in
              // Edge 10547 yet.
              if (iceGatherer.state === undefined) {
                iceGatherer.state = 'completed';
              }

              // Emit a candidate with type endOfCandidates to make the samples
              // work. Edge requires addIceCandidate with this empty candidate
              // to start checking. The real solution is to signal
              // end-of-candidates to the other side when getting the null
              // candidate but some apps (like the samples) don't do that.
              event.candidate.candidate =
                  'candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates';
            } else {
              // RTCIceCandidate doesn't have a component, needs to be added
              cand.component = iceTransport.component === 'RTCP' ? 2 : 1;
              event.candidate.candidate = SDPUtils.writeCandidate(cand);
            }

            // update local description.
            var sections = SDPUtils.splitSections(self.localDescription.sdp);
            if (event.candidate.candidate.indexOf('typ endOfCandidates')
                === -1) {
              sections[event.candidate.sdpMLineIndex + 1] +=
                  'a=' + event.candidate.candidate + '\r\n';
            } else {
              sections[event.candidate.sdpMLineIndex + 1] +=
                  'a=end-of-candidates\r\n';
            }
            self.localDescription.sdp = sections.join('');

            var complete = self.transceivers.every(function(transceiver) {
              return transceiver.iceGatherer &&
                  transceiver.iceGatherer.state === 'completed';
            });

            // Emit candidate if localDescription is set.
            // Also emits null candidate when all gatherers are complete.
            switch (self.iceGatheringState) {
              case 'new':
                self._localIceCandidatesBuffer.push(event);
                if (end && complete) {
                  self._localIceCandidatesBuffer.push(
                      new Event('icecandidate'));
                }
                break;
              case 'gathering':
                self._emitBufferedCandidates();
                self.dispatchEvent(event);
                if (self.onicecandidate !== null) {
                  self.onicecandidate(event);
                }
                if (complete) {
                  self.dispatchEvent(new Event('icecandidate'));
                  if (self.onicecandidate !== null) {
                    self.onicecandidate(new Event('icecandidate'));
                  }
                  self.iceGatheringState = 'complete';
                }
                break;
              case 'complete':
                // should not happen... currently!
                break;
              default: // no-op.
                break;
            }
          };
          iceTransport.onicestatechange = function() {
            self._updateConnectionState();
          };

          var dtlsTransport = new RTCDtlsTransport(iceTransport);
          dtlsTransport.ondtlsstatechange = function() {
            self._updateConnectionState();
          };
          dtlsTransport.onerror = function() {
            // onerror does not set state to failed by itself.
            dtlsTransport.state = 'failed';
            self._updateConnectionState();
          };

          return {
            iceGatherer: iceGatherer,
            iceTransport: iceTransport,
            dtlsTransport: dtlsTransport
          };
        };

    // Start the RTP Sender and Receiver for a transceiver.
    window.RTCPeerConnection.prototype._transceive = function(transceiver,
        send, recv) {
      var params = this._getCommonCapabilities(transceiver.localCapabilities,
          transceiver.remoteCapabilities);
      if (send && transceiver.rtpSender) {
        params.encodings = transceiver.sendEncodingParameters;
        params.rtcp = {
          cname: SDPUtils.localCName
        };
        if (transceiver.recvEncodingParameters.length) {
          params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
        }
        transceiver.rtpSender.send(params);
      }
      if (recv && transceiver.rtpReceiver) {
        // remove RTX field in Edge 14942
        if (transceiver.kind === 'video'
            && transceiver.recvEncodingParameters) {
          transceiver.recvEncodingParameters.forEach(function(p) {
            delete p.rtx;
          });
        }
        params.encodings = transceiver.recvEncodingParameters;
        params.rtcp = {
          cname: transceiver.cname
        };
        if (transceiver.sendEncodingParameters.length) {
          params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
        }
        transceiver.rtpReceiver.receive(params);
      }
    };

    window.RTCPeerConnection.prototype.setLocalDescription =
        function(description) {
          var self = this;
          var sections;
          var sessionpart;
          if (description.type === 'offer') {
            // FIXME: What was the purpose of this empty if statement?
            // if (!this._pendingOffer) {
            // } else {
            if (this._pendingOffer) {
              // VERY limited support for SDP munging. Limited to:
              // * changing the order of codecs
              sections = SDPUtils.splitSections(description.sdp);
              sessionpart = sections.shift();
              sections.forEach(function(mediaSection, sdpMLineIndex) {
                var caps = SDPUtils.parseRtpParameters(mediaSection);
                self._pendingOffer[sdpMLineIndex].localCapabilities = caps;
              });
              this.transceivers = this._pendingOffer;
              delete this._pendingOffer;
            }
          } else if (description.type === 'answer') {
            sections = SDPUtils.splitSections(self.remoteDescription.sdp);
            sessionpart = sections.shift();
            var isIceLite = SDPUtils.matchPrefix(sessionpart,
                'a=ice-lite').length > 0;
            sections.forEach(function(mediaSection, sdpMLineIndex) {
              var transceiver = self.transceivers[sdpMLineIndex];
              var iceGatherer = transceiver.iceGatherer;
              var iceTransport = transceiver.iceTransport;
              var dtlsTransport = transceiver.dtlsTransport;
              var localCapabilities = transceiver.localCapabilities;
              var remoteCapabilities = transceiver.remoteCapabilities;

              var rejected = mediaSection.split('\n', 1)[0]
                  .split(' ', 2)[1] === '0';

              if (!rejected && !transceiver.isDatachannel) {
                var remoteIceParameters = SDPUtils.getIceParameters(
                    mediaSection, sessionpart);
                if (isIceLite) {
                  var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
                  .map(function(cand) {
                    return SDPUtils.parseCandidate(cand);
                  })
                  .filter(function(cand) {
                    return cand.component === '1';
                  });
                  // ice-lite only includes host candidates in the SDP so we can
                  // use setRemoteCandidates (which implies an
                  // RTCIceCandidateComplete)
                  if (cands.length) {
                    iceTransport.setRemoteCandidates(cands);
                  }
                }
                var remoteDtlsParameters = SDPUtils.getDtlsParameters(
                    mediaSection, sessionpart);
                if (isIceLite) {
                  remoteDtlsParameters.role = 'server';
                }

                if (!self.usingBundle || sdpMLineIndex === 0) {
                  iceTransport.start(iceGatherer, remoteIceParameters,
                      isIceLite ? 'controlling' : 'controlled');
                  dtlsTransport.start(remoteDtlsParameters);
                }

                // Calculate intersection of capabilities.
                var params = self._getCommonCapabilities(localCapabilities,
                    remoteCapabilities);

                // Start the RTCRtpSender. The RTCRtpReceiver for this
                // transceiver has already been started in setRemoteDescription.
                self._transceive(transceiver,
                    params.codecs.length > 0,
                    false);
              }
            });
          }

          this.localDescription = {
            type: description.type,
            sdp: description.sdp
          };
          switch (description.type) {
            case 'offer':
              this._updateSignalingState('have-local-offer');
              break;
            case 'answer':
              this._updateSignalingState('stable');
              break;
            default:
              throw new TypeError('unsupported type "' + description.type +
                  '"');
          }

          // If a success callback was provided, emit ICE candidates after it
          // has been executed. Otherwise, emit callback after the Promise is
          // resolved.
          var hasCallback = arguments.length > 1 &&
            typeof arguments[1] === 'function';
          if (hasCallback) {
            var cb = arguments[1];
            window.setTimeout(function() {
              cb();
              if (self.iceGatheringState === 'new') {
                self.iceGatheringState = 'gathering';
              }
              self._emitBufferedCandidates();
            }, 0);
          }
          var p = Promise.resolve();
          p.then(function() {
            if (!hasCallback) {
              if (self.iceGatheringState === 'new') {
                self.iceGatheringState = 'gathering';
              }
              // Usually candidates will be emitted earlier.
              window.setTimeout(self._emitBufferedCandidates.bind(self), 500);
            }
          });
          return p;
        };

    window.RTCPeerConnection.prototype.setRemoteDescription =
        function(description) {
          var self = this;
          var stream = new MediaStream();
          var receiverList = [];
          var sections = SDPUtils.splitSections(description.sdp);
          var sessionpart = sections.shift();
          var isIceLite = SDPUtils.matchPrefix(sessionpart,
              'a=ice-lite').length > 0;
          this.usingBundle = SDPUtils.matchPrefix(sessionpart,
              'a=group:BUNDLE ').length > 0;
          sections.forEach(function(mediaSection, sdpMLineIndex) {
            var lines = SDPUtils.splitLines(mediaSection);
            var mline = lines[0].substr(2).split(' ');
            var kind = mline[0];
            var rejected = mline[1] === '0';
            var direction = SDPUtils.getDirection(mediaSection, sessionpart);

            var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:');
            if (mid.length) {
              mid = mid[0].substr(6);
            } else {
              mid = SDPUtils.generateIdentifier();
            }

            // Reject datachannels which are not implemented yet.
            if (kind === 'application' && mline[2] === 'DTLS/SCTP') {
              self.transceivers[sdpMLineIndex] = {
                mid: mid,
                isDatachannel: true
              };
              return;
            }

            var transceiver;
            var iceGatherer;
            var iceTransport;
            var dtlsTransport;
            var rtpSender;
            var rtpReceiver;
            var sendEncodingParameters;
            var recvEncodingParameters;
            var localCapabilities;

            var track;
            // FIXME: ensure the mediaSection has rtcp-mux set.
            var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
            var remoteIceParameters;
            var remoteDtlsParameters;
            if (!rejected) {
              remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
                  sessionpart);
              remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
                  sessionpart);
              remoteDtlsParameters.role = 'client';
            }
            recvEncodingParameters =
                SDPUtils.parseRtpEncodingParameters(mediaSection);

            var cname;
            // Gets the first SSRC. Note that with RTX there might be multiple
            // SSRCs.
            var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
                .map(function(line) {
                  return SDPUtils.parseSsrcMedia(line);
                })
                .filter(function(obj) {
                  return obj.attribute === 'cname';
                })[0];
            if (remoteSsrc) {
              cname = remoteSsrc.value;
            }

            var isComplete = SDPUtils.matchPrefix(mediaSection,
                'a=end-of-candidates', sessionpart).length > 0;
            var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
                .map(function(cand) {
                  return SDPUtils.parseCandidate(cand);
                })
                .filter(function(cand) {
                  return cand.component === '1';
                });
            if (description.type === 'offer' && !rejected) {
              var transports = self.usingBundle && sdpMLineIndex > 0 ? {
                iceGatherer: self.transceivers[0].iceGatherer,
                iceTransport: self.transceivers[0].iceTransport,
                dtlsTransport: self.transceivers[0].dtlsTransport
              } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);

              if (isComplete) {
                transports.iceTransport.setRemoteCandidates(cands);
              }

              localCapabilities = RTCRtpReceiver.getCapabilities(kind);

              // filter RTX until additional stuff needed for RTX is implemented
              // in adapter.js
              localCapabilities.codecs = localCapabilities.codecs.filter(
                  function(codec) {
                    return codec.name !== 'rtx';
                  });

              sendEncodingParameters = [{
                ssrc: (2 * sdpMLineIndex + 2) * 1001
              }];

              rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);

              track = rtpReceiver.track;
              receiverList.push([track, rtpReceiver]);
              // FIXME: not correct when there are multiple streams but that is
              // not currently supported in this shim.
              stream.addTrack(track);

              // FIXME: look at direction.
              if (self.localStreams.length > 0 &&
                  self.localStreams[0].getTracks().length >= sdpMLineIndex) {
                var localTrack;
                if (kind === 'audio') {
                  localTrack = self.localStreams[0].getAudioTracks()[0];
                } else if (kind === 'video') {
                  localTrack = self.localStreams[0].getVideoTracks()[0];
                }
                if (localTrack) {
                  rtpSender = new RTCRtpSender(localTrack,
                      transports.dtlsTransport);
                }
              }

              self.transceivers[sdpMLineIndex] = {
                iceGatherer: transports.iceGatherer,
                iceTransport: transports.iceTransport,
                dtlsTransport: transports.dtlsTransport,
                localCapabilities: localCapabilities,
                remoteCapabilities: remoteCapabilities,
                rtpSender: rtpSender,
                rtpReceiver: rtpReceiver,
                kind: kind,
                mid: mid,
                cname: cname,
                sendEncodingParameters: sendEncodingParameters,
                recvEncodingParameters: recvEncodingParameters
              };
              // Start the RTCRtpReceiver now. The RTPSender is started in
              // setLocalDescription.
              self._transceive(self.transceivers[sdpMLineIndex],
                  false,
                  direction === 'sendrecv' || direction === 'sendonly');
            } else if (description.type === 'answer' && !rejected) {
              transceiver = self.transceivers[sdpMLineIndex];
              iceGatherer = transceiver.iceGatherer;
              iceTransport = transceiver.iceTransport;
              dtlsTransport = transceiver.dtlsTransport;
              rtpSender = transceiver.rtpSender;
              rtpReceiver = transceiver.rtpReceiver;
              sendEncodingParameters = transceiver.sendEncodingParameters;
              localCapabilities = transceiver.localCapabilities;

              self.transceivers[sdpMLineIndex].recvEncodingParameters =
                  recvEncodingParameters;
              self.transceivers[sdpMLineIndex].remoteCapabilities =
                  remoteCapabilities;
              self.transceivers[sdpMLineIndex].cname = cname;

              if ((isIceLite || isComplete) && cands.length) {
                iceTransport.setRemoteCandidates(cands);
              }
              if (!self.usingBundle || sdpMLineIndex === 0) {
                iceTransport.start(iceGatherer, remoteIceParameters,
                    'controlling');
                dtlsTransport.start(remoteDtlsParameters);
              }

              self._transceive(transceiver,
                  direction === 'sendrecv' || direction === 'recvonly',
                  direction === 'sendrecv' || direction === 'sendonly');

              if (rtpReceiver &&
                  (direction === 'sendrecv' || direction === 'sendonly')) {
                track = rtpReceiver.track;
                receiverList.push([track, rtpReceiver]);
                stream.addTrack(track);
              } else {
                // FIXME: actually the receiver should be created later.
                delete transceiver.rtpReceiver;
              }
            }
          });

          this.remoteDescription = {
            type: description.type,
            sdp: description.sdp
          };
          switch (description.type) {
            case 'offer':
              this._updateSignalingState('have-remote-offer');
              break;
            case 'answer':
              this._updateSignalingState('stable');
              break;
            default:
              throw new TypeError('unsupported type "' + description.type +
                  '"');
          }
          if (stream.getTracks().length) {
            self.remoteStreams.push(stream);
            window.setTimeout(function() {
              var event = new Event('addstream');
              event.stream = stream;
              self.dispatchEvent(event);
              if (self.onaddstream !== null) {
                window.setTimeout(function() {
                  self.onaddstream(event);
                }, 0);
              }

              receiverList.forEach(function(item) {
                var track = item[0];
                var receiver = item[1];
                var trackEvent = new Event('track');
                trackEvent.track = track;
                trackEvent.receiver = receiver;
                trackEvent.streams = [stream];
                self.dispatchEvent(event);
                if (self.ontrack !== null) {
                  window.setTimeout(function() {
                    self.ontrack(trackEvent);
                  }, 0);
                }
              });
            }, 0);
          }
          if (arguments.length > 1 && typeof arguments[1] === 'function') {
            window.setTimeout(arguments[1], 0);
          }
          return Promise.resolve();
        };

    window.RTCPeerConnection.prototype.close = function() {
      this.transceivers.forEach(function(transceiver) {
        /* not yet
        if (transceiver.iceGatherer) {
          transceiver.iceGatherer.close();
        }
        */
        if (transceiver.iceTransport) {
          transceiver.iceTransport.stop();
        }
        if (transceiver.dtlsTransport) {
          transceiver.dtlsTransport.stop();
        }
        if (transceiver.rtpSender) {
          transceiver.rtpSender.stop();
        }
        if (transceiver.rtpReceiver) {
          transceiver.rtpReceiver.stop();
        }
      });
      // FIXME: clean up tracks, local streams, remote streams, etc
      this._updateSignalingState('closed');
    };

    // Update the signaling state.
    window.RTCPeerConnection.prototype._updateSignalingState =
        function(newState) {
          this.signalingState = newState;
          var event = new Event('signalingstatechange');
          this.dispatchEvent(event);
          if (this.onsignalingstatechange !== null) {
            this.onsignalingstatechange(event);
          }
        };

    // Determine whether to fire the negotiationneeded event.
    window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded =
        function() {
          // Fire away (for now).
          var event = new Event('negotiationneeded');
          this.dispatchEvent(event);
          if (this.onnegotiationneeded !== null) {
            this.onnegotiationneeded(event);
          }
        };

    // Update the connection state.
    window.RTCPeerConnection.prototype._updateConnectionState = function() {
      var self = this;
      var newState;
      var states = {
        'new': 0,
        closed: 0,
        connecting: 0,
        checking: 0,
        connected: 0,
        completed: 0,
        failed: 0
      };
      this.transceivers.forEach(function(transceiver) {
        states[transceiver.iceTransport.state]++;
        states[transceiver.dtlsTransport.state]++;
      });
      // ICETransport.completed and connected are the same for this purpose.
      states.connected += states.completed;

      newState = 'new';
      if (states.failed > 0) {
        newState = 'failed';
      } else if (states.connecting > 0 || states.checking > 0) {
        newState = 'connecting';
      } else if (states.disconnected > 0) {
        newState = 'disconnected';
      } else if (states.new > 0) {
        newState = 'new';
      } else if (states.connected > 0 || states.completed > 0) {
        newState = 'connected';
      }

      if (newState !== self.iceConnectionState) {
        self.iceConnectionState = newState;
        var event = new Event('iceconnectionstatechange');
        this.dispatchEvent(event);
        if (this.oniceconnectionstatechange !== null) {
          this.oniceconnectionstatechange(event);
        }
      }
    };

    window.RTCPeerConnection.prototype.createOffer = function() {
      var self = this;
      if (this._pendingOffer) {
        throw new Error('createOffer called while there is a pending offer.');
      }
      var offerOptions;
      if (arguments.length === 1 && typeof arguments[0] !== 'function') {
        offerOptions = arguments[0];
      } else if (arguments.length === 3) {
        offerOptions = arguments[2];
      }

      var tracks = [];
      var numAudioTracks = 0;
      var numVideoTracks = 0;
      // Default to sendrecv.
      if (this.localStreams.length) {
        numAudioTracks = this.localStreams[0].getAudioTracks().length;
        numVideoTracks = this.localStreams[0].getVideoTracks().length;
      }
      // Determine number of audio and video tracks we need to send/recv.
      if (offerOptions) {
        // Reject Chrome legacy constraints.
        if (offerOptions.mandatory || offerOptions.optional) {
          throw new TypeError(
              'Legacy mandatory/optional constraints not supported.');
        }
        if (offerOptions.offerToReceiveAudio !== undefined) {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
        if (offerOptions.offerToReceiveVideo !== undefined) {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
      if (this.localStreams.length) {
        // Push local streams.
        this.localStreams[0].getTracks().forEach(function(track) {
          tracks.push({
            kind: track.kind,
            track: track,
            wantReceive: track.kind === 'audio' ?
                numAudioTracks > 0 : numVideoTracks > 0
          });
          if (track.kind === 'audio') {
            numAudioTracks--;
          } else if (track.kind === 'video') {
            numVideoTracks--;
          }
        });
      }
      // Create M-lines for recvonly streams.
      while (numAudioTracks > 0 || numVideoTracks > 0) {
        if (numAudioTracks > 0) {
          tracks.push({
            kind: 'audio',
            wantReceive: true
          });
          numAudioTracks--;
        }
        if (numVideoTracks > 0) {
          tracks.push({
            kind: 'video',
            wantReceive: true
          });
          numVideoTracks--;
        }
      }

      var sdp = SDPUtils.writeSessionBoilerplate();
      var transceivers = [];
      tracks.forEach(function(mline, sdpMLineIndex) {
        // For each track, create an ice gatherer, ice transport,
        // dtls transport, potentially rtpsender and rtpreceiver.
        var track = mline.track;
        var kind = mline.kind;
        var mid = SDPUtils.generateIdentifier();

        var transports = self.usingBundle && sdpMLineIndex > 0 ? {
          iceGatherer: transceivers[0].iceGatherer,
          iceTransport: transceivers[0].iceTransport,
          dtlsTransport: transceivers[0].dtlsTransport
        } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);

        var localCapabilities = RTCRtpSender.getCapabilities(kind);
        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
        localCapabilities.codecs.forEach(function(codec) {
          // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
          // by adding level-asymmetry-allowed=1
          if (codec.name === 'H264' &&
              codec.parameters['level-asymmetry-allowed'] === undefined) {
            codec.parameters['level-asymmetry-allowed'] = '1';
          }
        });

        var rtpSender;
        var rtpReceiver;

        // generate an ssrc now, to be used later in rtpSender.send
        var sendEncodingParameters = [{
          ssrc: (2 * sdpMLineIndex + 1) * 1001
        }];
        if (track) {
          rtpSender = new RTCRtpSender(track, transports.dtlsTransport);
        }

        if (mline.wantReceive) {
          rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);
        }

        transceivers[sdpMLineIndex] = {
          iceGatherer: transports.iceGatherer,
          iceTransport: transports.iceTransport,
          dtlsTransport: transports.dtlsTransport,
          localCapabilities: localCapabilities,
          remoteCapabilities: null,
          rtpSender: rtpSender,
          rtpReceiver: rtpReceiver,
          kind: kind,
          mid: mid,
          sendEncodingParameters: sendEncodingParameters,
          recvEncodingParameters: null
        };
      });
      if (this.usingBundle) {
        sdp += 'a=group:BUNDLE ' + transceivers.map(function(t) {
          return t.mid;
        }).join(' ') + '\r\n';
      }
      tracks.forEach(function(mline, sdpMLineIndex) {
        var transceiver = transceivers[sdpMLineIndex];
        sdp += SDPUtils.writeMediaSection(transceiver,
            transceiver.localCapabilities, 'offer', self.localStreams[0]);
      });

      this._pendingOffer = transceivers;
      var desc = new RTCSessionDescription({
        type: 'offer',
        sdp: sdp
      });
      if (arguments.length && typeof arguments[0] === 'function') {
        window.setTimeout(arguments[0], 0, desc);
      }
      return Promise.resolve(desc);
    };

    window.RTCPeerConnection.prototype.createAnswer = function() {
      var self = this;

      var sdp = SDPUtils.writeSessionBoilerplate();
      if (this.usingBundle) {
        sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {
          return t.mid;
        }).join(' ') + '\r\n';
      }
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.isDatachannel) {
          sdp += 'm=application 0 DTLS/SCTP 5000\r\n' +
              'c=IN IP4 0.0.0.0\r\n' +
              'a=mid:' + transceiver.mid + '\r\n';
          return;
        }
        // Calculate intersection of capabilities.
        var commonCapabilities = self._getCommonCapabilities(
            transceiver.localCapabilities,
            transceiver.remoteCapabilities);

        sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,
            'answer', self.localStreams[0]);
      });

      var desc = new RTCSessionDescription({
        type: 'answer',
        sdp: sdp
      });
      if (arguments.length && typeof arguments[0] === 'function') {
        window.setTimeout(arguments[0], 0, desc);
      }
      return Promise.resolve(desc);
    };

    window.RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
      if (!candidate) {
        this.transceivers.forEach(function(transceiver) {
          transceiver.iceTransport.addRemoteCandidate({});
        });
      } else {
        var mLineIndex = candidate.sdpMLineIndex;
        if (candidate.sdpMid) {
          for (var i = 0; i < this.transceivers.length; i++) {
            if (this.transceivers[i].mid === candidate.sdpMid) {
              mLineIndex = i;
              break;
            }
          }
        }
        var transceiver = this.transceivers[mLineIndex];
        if (transceiver) {
          var cand = Object.keys(candidate.candidate).length > 0 ?
              SDPUtils.parseCandidate(candidate.candidate) : {};
          // Ignore Chrome's invalid candidates since Edge does not like them.
          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
            return;
          }
          // Ignore RTCP candidates, we assume RTCP-MUX.
          if (cand.component !== '1') {
            return;
          }
          // A dirty hack to make samples work.
          if (cand.type === 'endOfCandidates') {
            cand = {};
          }
          transceiver.iceTransport.addRemoteCandidate(cand);

          // update the remoteDescription.
          var sections = SDPUtils.splitSections(this.remoteDescription.sdp);
          sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim()
              : 'a=end-of-candidates') + '\r\n';
          this.remoteDescription.sdp = sections.join('');
        }
      }
      if (arguments.length > 1 && typeof arguments[1] === 'function') {
        window.setTimeout(arguments[1], 0);
      }
      return Promise.resolve();
    };

    window.RTCPeerConnection.prototype.getStats = function() {
      var promises = [];
      this.transceivers.forEach(function(transceiver) {
        ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
            'dtlsTransport'].forEach(function(method) {
              if (transceiver[method]) {
                promises.push(transceiver[method].getStats());
              }
            });
      });
      var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&
          arguments[1];
      return new Promise(function(resolve) {
        // shim getStats with maplike support
        var results = new Map();
        Promise.all(promises).then(function(res) {
          res.forEach(function(result) {
            Object.keys(result).forEach(function(id) {
              results.set(id, result[id]);
              results[id] = result[id];
            });
          });
          if (cb) {
            window.setTimeout(cb, 0, results);
          }
          resolve(results);
        });
      });
    };
  }
};

// Expose public methods.
module.exports = {
  shimPeerConnection: edgeShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils":110,"./getusermedia":106,"sdp":51}],106:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

// Expose public methods.
module.exports = function() {
  var shimError_ = function(e) {
    return {
      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.
      bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function(c) {
    return origGetUserMedia(c).catch(function(e) {
      return Promise.reject(shimError_(e));
    });
  };
};

},{}],107:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var browserDetails = require('../utils').browserDetails;

var firefoxShim = {
  shimOnTrack: function() {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        }
      });
    }
  },

  shimSourceObject: function() {
    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this.mozSrcObject;
          },
          set: function(stream) {
            this.mozSrcObject = stream;
          }
        });
      }
    }
  },

  shimPeerConnection: function() {
    if (typeof window !== 'object' || !(window.RTCPeerConnection ||
        window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (browserDetails.version < 38) {
          // .urls is not supported in FF < 38.
          // create RTCIceServers with a single url.
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (server.hasOwnProperty('urls')) {
                for (var j = 0; j < server.urls.length; j++) {
                  var newServer = {
                    url: server.urls[j]
                  };
                  if (server.urls[j].indexOf('turn') === 0) {
                    newServer.username = server.username;
                    newServer.credential = server.credential;
                  }
                  newIceServers.push(newServer);
                }
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
        }
        return new mozRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype;

      // wrap static methods. Currently just generateCertificate.
      if (mozRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return mozRTCPeerConnection.generateCertificate;
          }
        });
      }

      window.RTCSessionDescription = mozRTCSessionDescription;
      window.RTCIceCandidate = mozRTCIceCandidate;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = RTCPeerConnection.prototype[method];
          RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                RTCIceCandidate : RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        RTCPeerConnection.prototype.addIceCandidate;
    RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    if (browserDetails.version < 48) {
      // shim getStats with maplike support
      var makeMapStats = function(stats) {
        var map = new Map();
        Object.keys(stats).forEach(function(key) {
          map.set(key, stats[key]);
          map[key] = stats[key];
        });
        return map;
      };

      var nativeGetStats = RTCPeerConnection.prototype.getStats;
      RTCPeerConnection.prototype.getStats = function(selector, onSucc, onErr) {
        return nativeGetStats.apply(this, [selector || null])
          .then(function(stats) {
            return makeMapStats(stats);
          })
          .then(onSucc, onErr);
      };
    }
  }
};

// Expose public methods.
module.exports = {
  shimOnTrack: firefoxShim.shimOnTrack,
  shimSourceObject: firefoxShim.shimSourceObject,
  shimPeerConnection: firefoxShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils":110,"./getusermedia":108}],108:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logging = require('../utils').log;
var browserDetails = require('../utils').browserDetails;

// Expose public methods.
module.exports = function() {
  var shimError_ = function(e) {
    return {
      name: {
        SecurityError: 'NotAllowedError',
        PermissionDeniedError: 'NotAllowedError'
      }[e.name] || e.name,
      message: {
        'The operation is insecure.': 'The request is not allowed by the ' +
        'user agent or the platform in the current context.'
      }[e.message] || e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  // getUserMedia constraints shim.
  var getUserMedia_ = function(constraints, onSuccess, onError) {
    var constraintsToFF37_ = function(c) {
      if (typeof c !== 'object' || c.require) {
        return c;
      }
      var require = [];
      Object.keys(c).forEach(function(key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = c[key] = (typeof c[key] === 'object') ?
            c[key] : {ideal: c[key]};
        if (r.min !== undefined ||
            r.max !== undefined || r.exact !== undefined) {
          require.push(key);
        }
        if (r.exact !== undefined) {
          if (typeof r.exact === 'number') {
            r. min = r.max = r.exact;
          } else {
            c[key] = r.exact;
          }
          delete r.exact;
        }
        if (r.ideal !== undefined) {
          c.advanced = c.advanced || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[key] = {min: r.ideal, max: r.ideal};
          } else {
            oc[key] = r.ideal;
          }
          c.advanced.push(oc);
          delete r.ideal;
          if (!Object.keys(r).length) {
            delete c[key];
          }
        }
      });
      if (require.length) {
        c.require = require;
      }
      return c;
    };
    constraints = JSON.parse(JSON.stringify(constraints));
    if (browserDetails.version < 38) {
      logging('spec: ' + JSON.stringify(constraints));
      if (constraints.audio) {
        constraints.audio = constraintsToFF37_(constraints.audio);
      }
      if (constraints.video) {
        constraints.video = constraintsToFF37_(constraints.video);
      }
      logging('ff37: ' + JSON.stringify(constraints));
    }
    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {
      onError(shimError_(e));
    });
  };

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      getUserMedia_(constraints, resolve, reject);
    });
  };

  // Shim for mediaDevices on older versions.
  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
      addEventListener: function() { },
      removeEventListener: function() { }
    };
  }
  navigator.mediaDevices.enumerateDevices =
      navigator.mediaDevices.enumerateDevices || function() {
        return new Promise(function(resolve) {
          var infos = [
            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
          ];
          resolve(infos);
        });
      };

  if (browserDetails.version < 41) {
    // Work around http://bugzil.la/1169665
    var orgEnumerateDevices =
        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
    navigator.mediaDevices.enumerateDevices = function() {
      return orgEnumerateDevices().then(undefined, function(e) {
        if (e.name === 'NotFoundError') {
          return [];
        }
        throw e;
      });
    };
  }
  if (browserDetails.version < 49) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      return origGetUserMedia(c).then(function(stream) {
        // Work around https://bugzil.la/802326
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(function(track) {
            track.stop();
          });
          throw new DOMException('The object can not be found here.',
                                 'NotFoundError');
        }
        return stream;
      }, function(e) {
        return Promise.reject(shimError_(e));
      });
    };
  }
  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    if (browserDetails.version < 44) {
      return getUserMedia_(constraints, onSuccess, onError);
    }
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    console.warn('navigator.getUserMedia has been replaced by ' +
                 'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
};

},{"../utils":110}],109:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';
var safariShim = {
  // TODO: DrAlex, should be here, double check against LayoutTests
  // shimOnTrack: function() { },

  // TODO: once the back-end for the mac port is done, add.
  // TODO: check for webkitGTK+
  // shimPeerConnection: function() { },

  shimGetUserMedia: function() {
    navigator.getUserMedia = navigator.webkitGetUserMedia;
  }
};

// Expose public methods.
module.exports = {
  shimGetUserMedia: safariShim.shimGetUserMedia
  // TODO
  // shimOnTrack: safariShim.shimOnTrack,
  // shimPeerConnection: safariShim.shimPeerConnection
};

},{}],110:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logDisabled_ = true;

// Utility methods.
var utils = {
  disableLog: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
        'adapter.js logging enabled';
  },

  log: function() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  },

  /**
   * Extract browser version out of the provided user agent string.
   *
   * @param {!string} uastring userAgent string.
   * @param {!string} expr Regular expression used as match criteria.
   * @param {!number} pos position in the version string to be returned.
   * @return {!number} browser version.
   */
  extractVersion: function(uastring, expr, pos) {
    var match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  },

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  detectBrowser: function() {
    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    // Firefox.
    if (navigator.mozGetUserMedia) {
      result.browser = 'firefox';
      result.version = this.extractVersion(navigator.userAgent,
          /Firefox\/([0-9]+)\./, 1);

    // all webkit-based browsers
    } else if (navigator.webkitGetUserMedia) {
      // Chrome, Chromium, Webview, Opera, all use the chrome shim for now
      if (window.webkitRTCPeerConnection) {
        result.browser = 'chrome';
        result.version = this.extractVersion(navigator.userAgent,
          /Chrom(e|ium)\/([0-9]+)\./, 2);

      // Safari or unknown webkit-based
      // for the time being Safari has support for MediaStreams but not webRTC
      } else {
        // Safari UA substrings of interest for reference:
        // - webkit version:           AppleWebKit/602.1.25 (also used in Op,Cr)
        // - safari UI version:        Version/9.0.3 (unique to Safari)
        // - safari UI webkit version: Safari/601.4.4 (also used in Op,Cr)
        //
        // if the webkit version and safari UI webkit versions are equals,
        // ... this is a stable version.
        //
        // only the internal webkit version is important today to know if
        // media streams are supported
        //
        if (navigator.userAgent.match(/Version\/(\d+).(\d+)/)) {
          result.browser = 'safari';
          result.version = this.extractVersion(navigator.userAgent,
            /AppleWebKit\/([0-9]+)\./, 1);

        // unknown webkit-based browser
        } else {
          result.browser = 'Unsupported webkit-based browser ' +
              'with GUM support but no WebRTC support.';
          return result;
        }
      }

    // Edge.
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
      result.browser = 'edge';
      result.version = this.extractVersion(navigator.userAgent,
          /Edge\/(\d+).(\d+)$/, 2);

    // Default fallthrough: not supported.
    } else {
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  }
};

// Export.
module.exports = {
  log: utils.log,
  disableLog: utils.disableLog,
  browserDetails: utils.detectBrowser(),
  extractVersion: utils.extractVersion
};

},{}],111:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],112:[function(require,module,exports){
var bus = require('page-bus')
var short = require('short-uuid')
var id = short().generate()
var emitters = {}
var names = []
var meta = bus({key: '_meta_'})
var join = bus({key: '_join_'})
var self = bus({key: id})
var swarm = {} // ids
var count = 0

join.emit('data', {id: id})

join.on('data', e => {
  if(e.id == id) return
  let em = swarm[e.id] = bus({key: e.id})
  count++
  if(Math.random() <= 1 / Math.pow(count, 2)) return
  else em.emit('data', {events: names, swamrm: Object.keys(swarm)})
})

self.on('data', e => {
  e.events.forEach(ev => {
    if(!emitters[e.name]) {
      var emitter = emitters[e.name] = bus({key:e.name})
    }
  })
  e.swarm.forEach(s => {
    if(!swarm[s]) swarm[s] = bus({key: s})
  })
 count = swarm.length
})

meta.on('data', e => {
  if(!emitters[e.name]) emitters[e.name] = bus({key:e.name})
})

module.exports = {on, once, emit}

function on(name, fn){
  if(!emitters[name]) {
    names.push(name)
    meta.emit('data', {name: name})
    setTimeout(e => on(name, fn), 0)
  }  
  else {
    emitters[name].on(name, fn)
  }
}

function once(name, fn){
  if(!emitters[name]) {
    meta.emit('data', {name: name})
    setTimeout(e => on(name, fn), 0)
  }  
  else emitters[name].once(name, fn)
}

function emit(name, data){
  if(!emitters[name]) {
    meta.emit('data', {name: name})
    setTimeout(e => emit(name, data, 0))
  }  
  else emitters[name].emit(name, data)
}

},{"page-bus":31,"short-uuid":52}],113:[function(require,module,exports){
(function (process,setImmediate){(function (){
var ms2s = 1.0 / 1000.0;
var ns2ms = 1.0 / 1000000.0
var ns2s = 1e-9

module.exports = T

function T(){
	if(!process.hrtime){ // browser fill

		process.hrtime = function(){

			if(arguments.length){
				arguments[1] = new Date().getTime();
				arguments[0] =  arguments[1] - millies(arguments[0])
			}

			else {
				arguments[0] = new Date().getTime();
			}
			
			return [parseInt(arguments[0] * ms2s), parseInt(((arguments[0] * ms2s) % 1) / ns2s)];
			
		}
	}
  if(!(this instanceof T)) return new T();
  var self = this;
  self.start = self.last = self.beat = process.hrtime();
  self.x = []
  self.end = []
  self.beats =  []
  self.averageSetSize = 333
  self.threshold = 1e6 // 10,000,000 ns ( 10 ms )
  self.skip = false
};

T.prototype.sinceBegin = function(){
  return process.hrtime(this.start)
};

T.prototype.sinceLast = function(){
  this.x = process.hrtime(this.last)
  this.last = process.hrtime()
  return this.x
}

T.prototype.sinceLastNS = function(){
  return nanos(this.sinceLast())
};

T.prototype.sinceBeginNS = function(){
  return nanos(this.sinceBegin())
};

T.prototype.avg = function(){
  var ns = nanos(this.sinceLast())
  this.beats.push(ns);
  this.beats = this.beats.splice(-this.averageSetSize)
  return avg(this.beats);
};

T.prototype.everyS = function(s, fn, go){
	this.every(s * 1e9, fn, go)
}

T.prototype.every = function(ns, fn, go){

  var self = new T();
  var timer = new T();

  var inter = ns || 0
    , fn = fn || function(t,c){c()}
    ;   
      
  function tick(){

    var ns = nanos(self.sinceLast());
//  unnecessary cuz no longer trying to optimize in loop()
//    self.beats.push(ns);
    loop()

  };

  function loop(){
    var d = inter - (nanos(process.hrtime()) - nanos(self.beat));

    if(d < 10000) {
      tock()
    }

    else if(self.skip) {
     setImmediate(loop)
    }

    else if(d < self.threshold) {
      // under the threshold, its nextTicks until the interval is up
      self.skip = true; setImmediate(loop) 
    }

    else {
      if(false && self.beats.length > 9) {
        var r = self.beats.length / self.averageSetSize;
        self.threshold = avg(self.beats) * .45 * r * 2
      }

      // for future reference:
      // console.log(avg(self.beats), self.beats.length, 'threshold = ' + self.threshold)

      self.skip = false; 
      setTimeout(loop, self.threshold / 1e6)
    }
  };

  function tock(){
    self.beat = process.hrtime();
    self.skip = false;
    fn(tick, nanos(timer.sinceLast()))
  };
  
  if(go) tock()

  else loop()

}

function millies(arr){
	return (arr[0] * 1e3) + (arr[1] * ns2ms)
}

function nanos(arr){
  return arr[0] * 1e9 + arr[1]
}

function add(a, b){
  var ns = a[1] + b[1];
  b[0] += a[0];
  b[1] = ns % 1e9;
  if(ns !== b[1]) b[0]++;
  return b
};

function avg(){

  return Array.prototype.slice.call(arguments[0]).reduce(function(a,i){return a += i },0) / arguments[0].length

}

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":136,"timers":157}],114:[function(require,module,exports){
(function (global){(function (){
'use strict';

var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? global : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],115:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],116:[function(require,module,exports){

},{}],117:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":115,"buffer":117,"ieee754":130}],118:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"./":119,"get-intrinsic":125}],119:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"function-bind":124,"get-intrinsic":125}],120:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"get-intrinsic":125}],121:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],122:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],123:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],124:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":123}],125:[function(require,module,exports){
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"function-bind":124,"has":129,"has-symbols":126}],126:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":127}],127:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],128:[function(require,module,exports){
'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

},{"has-symbols/shams":127}],129:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":124}],130:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],131:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],132:[function(require,module,exports){
'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"call-bind/callBound":118,"has-tostringtag/shams":128}],133:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],134:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require('has-tostringtag/shams')();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};

},{"has-tostringtag/shams":128}],135:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"available-typed-arrays":114,"call-bind/callBound":118,"es-abstract/helpers/getOwnPropertyDescriptor":120,"foreach":122,"has-tostringtag/shams":128}],136:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],137:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],138:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],139:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":137,"./encode":138}],140:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"buffer":117,"dup":50}],141:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":121,"inherits":131,"readable-stream/lib/_stream_duplex.js":143,"readable-stream/lib/_stream_passthrough.js":144,"readable-stream/lib/_stream_readable.js":145,"readable-stream/lib/_stream_transform.js":146,"readable-stream/lib/_stream_writable.js":147,"readable-stream/lib/internal/streams/end-of-stream.js":151,"readable-stream/lib/internal/streams/pipeline.js":153}],142:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],143:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":145,"./_stream_writable":147,"_process":136,"inherits":131}],144:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./_stream_transform":146,"dup":36,"inherits":131}],145:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":142,"./_stream_duplex":143,"./internal/streams/async_iterator":148,"./internal/streams/buffer_list":149,"./internal/streams/destroy":150,"./internal/streams/from":152,"./internal/streams/state":154,"./internal/streams/stream":155,"_process":136,"buffer":117,"events":121,"inherits":131,"string_decoder/":156,"util":116}],146:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"../errors":142,"./_stream_duplex":143,"dup":38,"inherits":131}],147:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":142,"./_stream_duplex":143,"./internal/streams/destroy":150,"./internal/streams/state":154,"./internal/streams/stream":155,"_process":136,"buffer":117,"inherits":131,"util-deprecate":158}],148:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

},{"./end-of-stream":151,"_process":136}],149:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"buffer":117,"dup":41,"util":116}],150:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

},{"_process":136}],151:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"../../../errors":142,"dup":43}],152:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],153:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"../../../errors":142,"./end-of-stream":151,"dup":45}],154:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"../../../errors":142,"dup":46}],155:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"events":121}],156:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76,"safe-buffer":140}],157:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":136,"timers":157}],158:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],159:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],160:[function(require,module,exports){
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

'use strict';

var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

},{"is-arguments":132,"is-generator-function":134,"is-typed-array":135,"which-typed-array":162}],161:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

}).call(this)}).call(this,require('_process'))

},{"./support/isBuffer":159,"./support/types":160,"_process":136,"inherits":131}],162:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof g[typedArray] === 'function') {
			var arr = new g[typedArray]();
			if (Symbol.toStringTag in arr) {
				var proto = getPrototypeOf(arr);
				var descriptor = gOPD(proto, Symbol.toStringTag);
				if (!descriptor) {
					var superProto = getPrototypeOf(proto);
					descriptor = gOPD(superProto, Symbol.toStringTag);
				}
				toStrTags[typedArray] = descriptor.get;
			}
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = require('is-typed-array');

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"available-typed-arrays":114,"call-bind/callBound":118,"es-abstract/helpers/getOwnPropertyDescriptor":120,"foreach":122,"has-tostringtag/shams":128,"is-typed-array":135}]},{},[3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uL2pzeW50aC1maWxlLXNhbXBsZS9pbmRleC5qcyIsIi4uL2pzeW50aC1taWMvc3RyZWFtLmpzIiwiL2hvbWUvam9obm55L3Byb2plY3RzL3AycGNvbnNlbnQvaG9zdC5qcyIsIm5vZGVfbW9kdWxlcy9hbnktYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hbnktYmFzZS9zcmMvY29udmVydGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jsb2ItdG8tYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItc3BsaXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2xhc3MtbGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9kZXRlY3QtYnJvd3Nlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kb21yZWFkeS9yZWFkeS5qcyIsIm5vZGVfbW9kdWxlcy9lcnItY29kZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudC10YXJnZXQtc2hpbS9kaXN0L2V2ZW50LXRhcmdldC1zaGltLmpzIiwibm9kZV9tb2R1bGVzL2dldC1icm93c2VyLXJ0Yy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZXRpZHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2V0dXNlcm1lZGlhL2dldHVzZXJtZWRpYS5qcyIsIm5vZGVfbW9kdWxlcy9oeXBlcnNjcmlwdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbWluaW1pc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9ieC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vYngvZGlzdC9tb2J4LmNqcy5kZXZlbG9wbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9tb2J4L2Rpc3QvbW9ieC5janMucHJvZHVjdGlvbi5taW4uanMiLCJub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmFub2Fzc2VydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vaHJlZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vZ2ctb3B1cy1kZWNvZGVyL2Rpc3Qvb2dnLW9wdXMtZGVjb2Rlci5taW4uanMiLCJub2RlX21vZHVsZXMvb3B1cy1tZWRpYS1yZWNvcmRlci9PcHVzTWVkaWFSZWNvcmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYWdlLWJ1cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9xdWV1ZS1taWNyb3Rhc2svaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZXJyb3JzLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9ydW4td2F0ZXJmYWxsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NkcC9zZHAuanMiLCJub2RlX21vZHVsZXMvc2hvcnQtdXVpZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaWduYWxodWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9ldmVudC1zb3VyY2Utc3RyZWFtL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9uZXRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL2Zvci1lYWNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy9mb3ItZWFjaC9ub2RlX21vZHVsZXMvaXMtZnVuY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL3RyaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9kaXN0L3N0b3JlLmxlZ2FjeS5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9wbHVnaW5zL2pzb24yLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3BsdWdpbnMvbGliL2pzb24yLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3NyYy9zdG9yZS1lbmdpbmUuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvYWxsLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL2Nvb2tpZVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvbG9jYWxTdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL21lbW9yeVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvb2xkRkYtZ2xvYmFsU3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9zdG9yYWdlcy9vbGRJRS11c2VyRGF0YVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvc2Vzc2lvblN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJvdWdoMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL3Rocm91Z2gyLmpzIiwibm9kZV9tb2R1bGVzL3RvLWFycmF5YnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9tZDUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvbmlsLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvcmVnZXguanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3JuZy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9zaGExLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjEuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3YzLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92MzUuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3Y0LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92NS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdmFsaWRhdGUuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2FkYXB0ZXJfY29yZS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvY2hyb21lL2Nocm9tZV9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9jaHJvbWUvZ2V0dXNlcm1lZGlhLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9lZGdlL2VkZ2Vfc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZWRnZS9nZXR1c2VybWVkaWEuanMiLCJub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2ZpcmVmb3gvZmlyZWZveF9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9maXJlZm94L2dldHVzZXJtZWRpYS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvc2FmYXJpL3NhZmFyaV9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJzaGFyZWRFbWl0dGVyLmpzIiwiLi4vc2luY2Utd2hlbi9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9oYXMtdG9zdHJpbmd0YWcvc2hhbXMuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLXR5cGVkLWFycmF5L2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxNQUFNO0VBQ3hCLE1BQU0sa0JBQWtCLE1BQU0sYUFBYSxJQUFJLE1BQU0sbUJBQW1CO0VBQ3hFLElBQUksTUFBTTtFQUNWLElBQUksSUFBSSxPQUFPLENBQUMsYUFBYSxDQUFDO0VBQzlCLElBQUksS0FBSyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7RUFDNUIsSUFBSSxNQUFNLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztFQUNwQyxHQUFHLEtBQUssQ0FBQyxjQUFjLEVBQUUsS0FBSztJQUM1QixPQUFPLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDZCxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUs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QUFDLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLHFCQUFxQjs7OztNQUl2QyxFQUFFLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQztLQUNoQixDQUFDO0lBQ0Y7Q0FDSCxDQUFDOzs7Ozs7QUNycEJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDclFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDenNMQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0NBO0FBQ0E7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25tQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdDlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xZQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25tQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM3NCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLy8gaGFuZGxlcyBhdWRpbyBmaWxlcyBhbmQgcmF3LCBtb25vLCBhdWRpbyBidWZmZXJzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29udGV4dCwgYnVmZiwgY2Ipe1xuICBcbiAgdmFyIG5hbWUgPSBidWZmLmNvbnN0cnVjdG9yLm5hbWVcbiAgLy9pZihNYXRoLnJhbmRvbSgpIDwgLjA1KSBjb25zb2xlLmxvZyhidWZmKVxuICBpZihuYW1lID09ICdBcnJheUJ1ZmZlcicpe1xuICAgIGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKGJ1ZmYpLnRoZW4oZnVuY3Rpb24oZGF0YSl7XG4gICAgICB2YXIgc291cmNlID0gY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKVxuICAgICAgc291cmNlLmJ1ZmZlciA9IGRhdGFcbi8qICAgICAgdmFyIGdhaW4gPSBjb250ZXh0LmNyZWF0ZUdhaW4oKVxuICAgICAgZ2Fpbi5jaGFubmVsQ291bnQgPSAxXG4gICAgICBnYWluLmNoYW5uZWxDb3VudE1vZGUgPSAnZXhwbGljaXQnXG4gICAgICBnYWluLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9ICdzcGVha2VycydcbiAgICAgIHNvdXJjZS5jb25uZWN0KGdhaW4pXG4gICAgICBzb3VyY2UuX2Nvbm5lY3QgPSBzb3VyY2UuY29ubmVjdFxuICAgICAgc291cmNlLmNvbm5lY3QgPSBnYWluLmNvbm5lY3RcbiAqLyAgICAgY2IobnVsbCwgc291cmNlKSBcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpe2NiKGVyciwgbnVsbCl9KVxuXHRcbiAgfWVsc2UgaWYobmFtZSA9PSAnQXJyYXknKXtcbiAgXG4gICAgdmFyIHNvdXJjZSA9IGNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICBcbiAgICB2YXIgYnVmZmVyID0gY29udGV4dC5jcmVhdGVCdWZmZXIoMiwgYnVmZlswXS5sZW5ndGgsIGNvbnRleHQuc2FtcGxlUmF0ZSlcblxuICAgIHRyeXsgLy8gbmV3XG4gICAgICBidWZmZXIuY29weVRvQ2hhbm5lbChidWZmWzBdLCAwLCAwKVxuICAgICAgYnVmZmVyLmNvcHlUb0NoYW5uZWwoYnVmZlsxXSwgMSwgMClcblxuICAgIH1jYXRjaChlcnIpeyAvLyBvbGRcbiAgICAgIC8vYnVmZmVyLmdldENoYW5uZWxEYXRhKDApLnNldChidWZmKVxuICAgIH1cbiAgICBcbiAgICBzb3VyY2UuYnVmZmVyID0gYnVmZmVyO1xuICAgIFxuICAgIC8qXG4gICAgdmFyIGdhaW4gPSBjb250ZXh0LmNyZWF0ZUdhaW4oKVxuICAgIGdhaW4uY2hhbm5lbENvdW50ID0gMlxuICAgIGdhaW4uY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCdcbiAgICBnYWluLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9ICdzcGVha2VycydcbiAgICBzb3VyY2UuZ2FpbiA9IGdhaW5cbiAgICBzb3VyY2UuY29ubmVjdChnYWluKVxuICAgIHNvdXJjZS5fY29ubmVjdCA9IHNvdXJjZS5jb25uZWN0XG4gICAgc291cmNlLmNvbm5lY3QgPSBnYWluLmNvbm5lY3RcbiAgICBpZihjYikgY2IobnVsbCwgc291cmNlKVxuICAgICovXG4gICAgcmV0dXJuIHNvdXJjZVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1hc3Rlciwgc3RyZWFtKXtcbiAgICB2YXIgbm9kZSA9IG1hc3Rlci5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pXG4gICAgdmFyIGdhaW4gPSBtYXN0ZXIuY3JlYXRlR2FpbigpXG4gICAgZ2Fpbi5jaGFubmVsQ291bnQgPSAxXG4gICAgZ2Fpbi5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0J1xuICAgIGdhaW4uIGNoYW5uZWxJbnRlcnByZXRhdGlvbiA9ICdzcGVha2VycydcbiAgICBub2RlLmNvbm5lY3QoZ2FpbilcbiAgICByZXR1cm4gZ2FpblxufVxuIiwiXG5yZXF1aXJlKCdkb21yZWFkeScpKHJlID0+IHtcbiAgY29uc3QgV2ViQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0XG4gIHZhciBtYXN0ZXIgXG4gIHZhciBoID0gcmVxdWlyZSgnaHlwZXJzY3JpcHQnKVxuICB2YXIgdWkgPSByZXF1aXJlKCdnZXRpZHMnKSgpXG4gIHZhciBidXMgPSByZXF1aXJlKCcuL3NoYXJlZEVtaXR0ZXInKVxuICBidXMub25jZSgnaWZyYW1lTG9hZGVkJywgZSA9PiB7XG4gICAgY29uc29sZS5sb2coZSlcbiAgICBidXMuZW1pdCgncG9uZycsIHtnb2F0OiAxfSlcbiAgICBidXMub24oJ2Nsb2NrJywgZSA9PiBjb25zb2xlLmxvZyhlKSlcbiAgfSlcbiAgLy92YXIgaWZyYW1lID0gcmVxdWlyZSgnLi4vaWZyYW1hcmZpJylcbiAgLy92YXIgcGVlcmluZyA9IGlmcmFtZShyZXF1aXJlKCcuL3BlZXJpbmcuanMnKSlcbiAgLy91aS5wZWVyaW5nLmFwcGVuZENoaWxkKHBlZXJpbmcpXG4gIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbiAgdmFyIFBlZXIgPSByZXF1aXJlKCdzaW1wbGUtcGVlcicpXG4gIHZhciBzaWduYWxodWIgPSByZXF1aXJlKCdzaWduYWxodWInKVxuICBjb25zdCB7bWFrZUF1dG9PYnNlcnZhYmxlLCAgYXV0b3J1bn0gPSByZXF1aXJlKCdtb2J4JylcbiAgY29uc3Qgc2hvcnQgPSByZXF1aXJlKCdzaG9ydC11dWlkJyk7XG4gIGNvbnN0IHRvYSA9IHJlcXVpcmUoJ3RvLWFycmF5YnVmZmVyJylcbiAgY29uc3QgYnRvYiA9IHJlcXVpcmUoJ2Jsb2ItdG8tYnVmZmVyJylcbiAgY29uc3QgdGhydSA9IHJlcXVpcmUoJ3Rocm91Z2gyJylcbiAgdmFyIHN0b3JlID0gcmVxdWlyZSgnc3RvcmUnKVxuICBjb25zdCBUaW1lID0gcmVxdWlyZSgnLi4vc2luY2Utd2hlbicpXG4gIHZhciBqbWljID0gcmVxdWlyZSgnLi4vanN5bnRoLW1pYy9zdHJlYW0nKVxuICB2YXIgc2FtcGxlciA9IHJlcXVpcmUoJy4uL2pzeW50aC1maWxlLXNhbXBsZScpXG4gIHZhciBtZWRpYSBcbiAgdmFyIHJ1bnAgPXJlcXVpcmUoJ3J1bi13YXRlcmZhbGwnKVxuICB2YXIgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpXG4gIHZhciBuYW5hID0gcmVxdWlyZSgnbmFub2hyZWYnKVxuICB2YXIgbWluaW1pc3QgPSByZXF1aXJlKCdtaW5pbWlzdCcpXG4gIHZhciBhcmd2ID0gbWluaW1pc3QocHJvY2Vzcy5hcmd2LCB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgaG9zdDogJ2ZvbGtzdGFjay5jb20nLFxuICAgICAgcG9ydDogODAsXG4gICAgICBwcm90b2NvbDogJ2h0dHBzJ1xuICAgIH1cbiAgfSlcbiAgdmFyIGRlYnViID0gc2lnbmFsaHViKCdodHRwczovL2ZvbGtzdGFjay5jb206ODAnLCAnZGVidWcnKVxuICAvL3ZhciByZXQ9ZGVidWIuc3Vic2NyaWJlKCdyZXR1cm4nKVxuXG4gIHZhciBhcHAgXG5cbiAgd2luZG93LnN0b3JlID0gc3RvcmVcbiAgc3RvcmUuY2xlYXJBbGwoKTtcbiAgcnVucChbaW5pdFN0YXRlLCBpbml0VUldLCAoZXJyLCBhcHApPT57XG4gICAgYXBwID0gYXBwXG5cbiAgICB1aS5pbml0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGUgPT4ge1xuICAgICAgYXBwLl9sb2coJ2luaXQnKVxuXG4gICAgICB0cnl7XG4gICAgICAgIHJ1bnAoW2NhcHR1cmVTb3VyY2UsIGNhcHR1cmVTaW5rLCBjYXB0dXJlTmV0d29yaywgaW5pdEF1ZGlvLCBpbml0Q2FzdChhcHApXS5yZXZlcnNlKCksIChlcnIsIGFwcCk9PntcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnIsIGFwcClcbiAgICAgICAgICAvL2FwcC5hdWRpby5zb3VyY2VTdHJlYW0ucGlwZShhcHAuYXVkaW8uc2lua1N0cmVhbSkgLy8gaGVoXG4gICAgICAgICAgaWYoYXBwLnNlc3Npb24uYnJvYWRjYXN0aW5nKSB7XG4gICAgICAgICAgICBhcHAubmV0d29yay5kaXN0YW5jZSA9IDFcbi8vICAgICAgICAgICAgYXBwLm5ldHdvcmsuc291cmNlU3RyZWFtID0gYXBwLmF1ZGlvLnNvdXJjZVN0cmVhbVxuICAgICAgICAgICAgYXBwLm5ldHdvcmsuaXNTZWVrV29ydGh5KClcbiAgICAgICAgICAgIGFwcC5uZXR3b3JrLmFsbG93Q2FsbHMoYXBwLnNlc3Npb24uc3RyZWFtKVxuICAgICAgICAgIFxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGFwcC5uZXR3b3JrLnNvdXJjZVNlZWsoKVxuICAgICAgfSl9IGNhdGNoIChlcnIpe1xuICAgICAgICBhcHAuX2xvZyhlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgfSlcblxuICB2YXIgYWVsID0gdWkucGxheWVyXG4gIHZhciBtaW1lID0gJ2F1ZGlvL29nZztjb2RlY3M9b3B1cydcblxuXG4gIGZ1bmN0aW9uIGluaXRTdGF0ZShjYil7XG5cbiAgICBjbGFzcyBBcHAge1xuICAgIFxuICAgICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5taWMgPSAxLzJcbiAgICAgICAgdGhpcy5tb25pdG9yID0gMFxuICAgICAgICB0aGlzLmNhbGwgPSAxLzJcbiAgICAgICAgdGhpcy50cmFjayA9IDEvMlxuICAgICAgICB0aGlzLnF1YWxpdHkgPSA2NDAwMFxuICAgICAgICB0aGlzLnVwZGF0ZSA9IG51bGxcbiAgICAgICAgbWFrZUF1dG9PYnNlcnZhYmxlKHRoaXMpXG4gICAgICB9XG5cbiAgICAgIHNldEdhaW4oZGlhbCwgdmFsdWUpe1xuICAgICAgICB0aGlzW2RpYWxdID0gdmFsdWVcbiAgICAgICAgdGhpcy51cGRhdGUgPSBbZGlhbCwgdmFsdWVdXG4gICAgICB9XG4gICAgXG4gICAgfVxuXG4gICAgY29uc3QgYXBwID0gbmV3IEFwcFxuICAgIGJ1cy5vbignYXBwU3RhdGVDaGFuZ2UnLCBlID0+e1xuICAgICAgYXBwLnNldEdhaW4oZVswXSwgZVsxXSlcbiAgICB9KVxuICAgIHZhciBzZXNzaW9uID0gc3RvcmUuZ2V0KCdzZXNzaW9uJylcbiAgICBpZighc2Vzc2lvbikgc2Vzc2lvbiA9IHtpZDogc2hvcnQoKS5nZW5lcmF0ZSgpLnNwbGl0KCkucmV2ZXJzZSgpLmpvaW4oKS5zbGljZSgwLDExKX1cbiAgICBzZXNzaW9uLmJyb2FkY2FzdGluZyA9IHRydWVcbiAgICB2YXIgcSA9IHFzLnBhcnNlKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc2xpY2UoMSkpXG4gICAgaWYocS5zdHJlYW0pIHtcbiAgICAgIHNlc3Npb24uc3RyZWFtID0gcS5zdHJlYW1cbiAgICAgIHNlc3Npb24uYnJvYWRjYXN0aW5nID0gZmFsc2UgXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2Vzc2lvbi5zdHJlYW0gPSBzZXNzaW9uLnN0cmVhbSB8fCBzaG9ydCgpLmdlbmVyYXRlKCkuc3BsaXQoKS5yZXZlcnNlKCkuam9pbigpLnNsaWNlKDAsMTEpXG4gICAgfVxuXG4gICAgYXBwLnNlc3Npb24gPSBzZXNzaW9uXG4gIGFwcC5fbG9nID0gZnVuY3Rpb24oX2lkKSB7IHJldHVybiBlID0+IHtcbiAgICAgIC8vdWkuZGVidWcuYXBwZW5kQ2hpbGQoaCgncCcsIGUudG9TdHJpbmcoKSkpICAgIFxuICAgICAgZGVidWIuYnJvYWRjYXN0KCdkZWJ1ZycsIEpTT04uc3RyaW5naWZ5KHtpZDogX2lkLCBsb2c6IGV9KSlcbiAgfSB9KHNlc3Npb24uaWQpXG4gICAgc3RvcmUuc2V0KCdzZXNzaW9uJywgc2Vzc2lvbilcbiAgICBjb25zb2xlLmxvZyhhcHApXG4gICAgY2IobnVsbCwgYXBwKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEF1ZGlvKGFwcCwgY2Ipe1xuICAgIGNvbnN0IGF1ZGlvID0ge31cbiAgICB2YXIgT3B1c01lZGlhUmVjb3JkZXIgPSByZXF1aXJlKCdvcHVzLW1lZGlhLXJlY29yZGVyJykgXG4gICAgd2luZG93Lk1lZGlhUmVjb3JkZXIgPSBPcHVzTWVkaWFSZWNvcmRlcjtcbiAgICBtYXN0ZXIgPSBuZXcgV2ViQXVkaW9Db250ZXh0KHtzYW1wbGVSYXRlOiA0ODAwMH0pXG4gICAgYXVkaW8ubWFzdGVyID0gbWFzdGVyXG4gICAgYXVkaW8uYnJvYWRjYXN0bWl4ZXIgPSBtYXN0ZXIuY3JlYXRlQ2hhbm5lbE1lcmdlcigyKVxuICAgIGF1ZGlvLmNhbGxtaXhlciA9IG1hc3Rlci5jcmVhdGVDaGFubmVsTWVyZ2VyKDIpXG4gICAgYXVkaW8uYnJvYWRjYXN0c3RyZWFtID0gbWFzdGVyLmNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKVxuICAgIGF1ZGlvLmNhbGxzdHJlYW0gPSBtYXN0ZXIuY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpXG4gICAgYXVkaW8ubW9uaXRvciA9IG1hc3Rlci5jcmVhdGVHYWluKClcbiAgICBhdWRpby5taWMgPSBtYXN0ZXIuY3JlYXRlR2FpbigpXG4gICAgYXVkaW8uY2FsbCA9IG1hc3Rlci5jcmVhdGVHYWluKClcbiAgICBhdWRpby50cmFja21peGVyID0gbWFzdGVyLmNyZWF0ZUNoYW5uZWxNZXJnZXIoMilcbiAgICBhdWRpby50cmFjayA9IG1hc3Rlci5jcmVhdGVHYWluKClcbiAgICBhdWRpby50cmFja21peGVyLmNvbm5lY3QoYXVkaW8udHJhY2spXG5cbiAgICBhdWRpby5icm9hZGNhc3RtaXhlci5jb25uZWN0KGF1ZGlvLmJyb2FkY2FzdHN0cmVhbSlcbiAgICAvL2F1ZGlvLmJyb2FkY2FzdG1peGVyLmNvbm5lY3QoYXVkaW8ubW9uaXRvcilcblxuICAgIGF1ZGlvLmNhbGxtaXhlci5jb25uZWN0KGF1ZGlvLmNhbGxzdHJlYW0pXG4gICAgLy9hdWRpby5jYWxsbWl4ZXIuY29ubmVjdChhdWRpby5tb25pdG9yKVxuXG5cbiAgICBhdWRpby5taWMuY29ubmVjdChhdWRpby5tb25pdG9yKVxuICAgIGF1ZGlvLmNhbGwuY29ubmVjdChhdWRpby5tb25pdG9yKVxuICAgIGF1ZGlvLnRyYWNrLmNvbm5lY3QoYXVkaW8ubW9uaXRvcilcbiAgICBhdWRpby5tb25pdG9yLmNvbm5lY3QobWFzdGVyLmRlc3RpbmF0aW9uKVxuXG4gICAgYXVkaW8ubWljLmNvbm5lY3QoYXVkaW8uYnJvYWRjYXN0bWl4ZXIpXG4gICAgLy9hdWRpby50cmFjay5jb25uZWN0KGF1ZGlvLmJyb2FkY2FzdG1peGVyKVxuICAgIC8vYXVkaW8uY2FsbC5jb25uZWN0KGF1ZGlvLmJyb2FkY2FzdG1peGVyKVxuXG4gICAgLy9hdWRpby5taWMuY29ubmVjdChhdWRpby5jYWxsbWl4ZXIpXG4gICAgLy9hdWRpby50cmFjay5jb25uZWN0KGF1ZGlvLmNhbGxtaXhlcilcblxuICAgIGF1ZGlvLmJyb2FkY2FzdG1peGVyLmNvbm5lY3QoYXVkaW8uYnJvYWRjYXN0c3RyZWFtKVxuICAgIGF1ZGlvLmNhbGxtaXhlci5jb25uZWN0KGF1ZGlvLmNhbGxzdHJlYW0pXG4gICAgXG4gICAgY29uc3Qgd29ya2VyT3B0aW9ucyA9IHtcbiAgICAgIGVuY29kZXJXb3JrZXJGYWN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFVNRCBzaG91bGQgYmUgdXNlZCBpZiB5b3UgZG9uJ3QgdXNlIGEgd2ViIHdvcmtlciBidW5kbGVyIGZvciB0aGlzLlxuICAgICAgICByZXR1cm4gbmV3IFdvcmtlcih0b2IoZnMucmVhZEZpbGVTeW5jKCcuL3B1YmxpYy9zdGF0aWMvZW5jb2Rlcldvcmtlci51bWQuanMnKSkpXG4gICAgICB9LFxuICAgICAgT2dnT3B1c0VuY29kZXJXYXNtUGF0aDogdG9iKGZzLnJlYWRGaWxlU3luYygnLi9wdWJsaWMvc3RhdGljL09nZ09wdXNFbmNvZGVyLndhc20nKSksXG4gICAgICBXZWJNT3B1c0VuY29kZXJXYXNtUGF0aDogdG9iKGZzLnJlYWRGaWxlU3luYygnLi9wdWJsaWMvc3RhdGljL1dlYk1PcHVzRW5jb2Rlci53YXNtJykpXG4gICAgfTtcblxuICAgIGF1ZGlvLmJyb2FkY2FzdGVuY29kZXIgPSBuZXcgTWVkaWFSZWNvcmRlcihhdWRpby5icm9hZGNhc3RzdHJlYW0uc3RyZWFtLCB7YXVkaW9CaXRzUGVyU2Vjb25kOjQwMDAwLCBtaW1lVHlwZTptaW1lfSwgd29ya2VyT3B0aW9ucylcbiAgICBhdWRpby5jYWxsZW5jb2RlciA9IG5ldyBNZWRpYVJlY29yZGVyKGF1ZGlvLmNhbGxzdHJlYW0uc3RyZWFtLCB7YXVkaW9CaXRzUGVyU2Vjb25kOjQwMDAwLCBtaW1lVHlwZTptaW1lfSwgd29ya2VyT3B0aW9ucylcblxuICAgIGF1ZGlvLmJyb2FkY2FzdGVuY29kZXIuYWRkRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIGUgPT4ge1xuICAgICAgYnRvYihlLmRhdGEsIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYoYXBwLnNlc3Npb24uYnJvYWRjYXN0aW5nKSBhcHAuX2xvZyhidWYubGVuZ3RoKVxuICAgICAgICAvL2J1ZnIucHVzaChuZXcgVWludDhBcnJheShidWYpKVxuICAgIC8vICAgIGFwcC5hdWRpby5kZWNvZGVyLmRlY29kZShidWYpICAgICBcbiAgICAgICAgYXBwLm5ldHdvcmsuYnJvYWRjYXN0KGJ1ZilcbiAgICAgICAgLy9zdHJTcmMud3JpdGUoYnVmKVxuICAgICAgfSlcblxuICAgIH0pXG5cbiAgICBhdWRpby5jYWxsZW5jb2Rlci5hZGRFdmVudExpc3RlbmVyKCdkYXRhYXZhaWxhYmxlJywgZSA9PiB7XG4gICAgICBidG9iKGUuZGF0YSwgKGVyciwgYnVmKSA9PiB7XG4gICAgICAgIC8vYnVmci5wdXNoKG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgICAgIGFwcC5hdWRpby5kZWNvZGVyLmRlY29kZShidWYpICAgICBcbiAgICAgICAgLy9hcHAubmV0d29yay5zZW5kKGJ1ZilcbiAgICAgICAgLy9zdHJTcmMud3JpdGUoYnVmKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgXG4gICAgYXVkaW8uYnJvYWRjYXN0ZW5jb2Rlci5zdGFydCgxMDAwKVxuXG4gICAgYXV0b3J1bigoKT0+e1xuICAgICAgaWYoYXBwLnVwZGF0ZSkge1xuICAgICAgICBhdWRpb1thcHAudXBkYXRlWzBdXS5nYWluLnZhbHVlID0gTWF0aC5tYXgoMCwgYXBwLnVwZGF0ZVsxXSkvLy5tb25pdG9yXG4gICAgICB9IFxuICAgIH0pXG5cbiAgICBhcHAuX2xvZyhgbWVkaWFSZWNvcmRlciBhZGRlZD8gJHsoISFhdWRpby5icm9hZGNhc3RlbmNvZGVyKX1gKVxuXG4gICAgYXBwLmF1ZGlvID0gYXVkaW9cbiAgICBtYXN0ZXIucmVzdW1lKClcbiAgICBjYihudWxsLCBhcHApXG4gIH1cblxuICBmdW5jdGlvbiBpbml0VUkoYXBwLCBjYil7XG5cbiAgICB1aS5saXZlbGluay5pbm5lclRleHQgPSAnaHR0cHM6Ly9nYWJyLnZlcmNlbC5hcHA/c3RyZWFtPScrYXBwLnNlc3Npb24uc3RyZWFtXG4gICAgdWkuY29weWJ1dHRvbi5vbmNoYW5nZSA9IGUgPT4ge1xuICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodWkubGluay5pbm5lclRleHQpXG4gICAgfVxuICAgIHVpLnJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICBhcHAubmV0d29yay5pbml0Q2FsbChhcHAuc2Vzc2lvbi5zdHJlYW0pXG4gICAgfSlcbiAgICB1aS5maWxlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGUgPT4ge1xuICAgICAgY29uc29sZS5sb2coZS50YXJnZXQuZmlsZXNbMF0pXG4gICAgICB2YXIgYSA9IGgoJ2F1ZGlvLmludmVydCcsIHtjb250cm9sczogdHJ1ZSwgc3JjIDogVVJMLmNyZWF0ZU9iamVjdFVSTChlLnRhcmdldC5maWxlc1swXSl9KVxuICAgICAgdWkudHJhY2tzLmFwcGVuZENoaWxkKGEpXG4gICAgICB2YXIgYz0gYXBwLmF1ZGlvLm1hc3Rlci5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UoYSlcbiAgICAgIGNvbnNvbGUubG9nKGEpXG4gICAgICBjLmNvbm5lY3QoYXBwLmF1ZGlvLnRyYWNrbWl4ZXIpXG4gICAgICBidG9iKGUudGFyZ2V0LmZpbGVzWzBdLCAoZXJyLCBidWYpID0+IHtcbiAgICAgICAgc2FtcGxlcihhcHAuYXVkaW8ubWFzdGVyLCBidWYuYnVmZmVyLCAoZXJyLCBub2RlKSA9PntcbiAgICAgICAgICAvL25vZGUuY29ubmVjdChhcHAuYXVkaW8ubWFzdGVyLmRlc3RpbmF0aW9uKVxuICAgICAgICAgIC8vbm9kZS5zdGFydCgwKVxuICAgICAgICB9KSAgICAgIFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgO1tdLmZvckVhY2guY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPXJhbmdlXScpLCBlID0+IHtcbiAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBldiA9PiB7XG4gICAgICAgIGJ1cy5lbWl0KCdhcHBTdGF0ZUNoYW5nZScsIFtldi50YXJnZXQubmFtZSwgTnVtYmVyKGV2LnRhcmdldC52YWx1ZSldKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgO1tdLmZvckVhY2guY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1tdXRlXScpLCBlID0+IHtcbiAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZXYgPT4ge1xuICAgICAgICBidXMuZW1pdCgnYXBwU3RhdGVDaGFuZ2UnLCBbZXYudGFyZ2V0LmRhdGFzZXQubXV0ZSwgLSBhcHBbZXYudGFyZ2V0LmRhdGFzZXQubXV0ZV1dKVxuICAgICAgfSlcbiAgICB9KVxuXG5cbiAgICB1aS5tb25pdG9yUmFuZ2UuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhlLnRhcmdldC52YWx1ZSlcbiAgICAgIC8vYnVzLmVtaXQoJ2FwcFN0YXRlQ2hhbmdlJywgWydtb25pdG9yJywgTnVtYmVyKGUudGFyZ2V0LnZhbHVlKV0pXG4gICAgICAvL2FwcC5zZXRHYWluKCdtb25pdG9yJywgTnVtYmVyKGUudGFyZ2V0LnZhbHVlKSlcbiAgICB9KVxuXG4gICAgY2IobnVsbCxhcHApXG5cbiAgfVxuXG5cbiAgZnVuY3Rpb24gaW5pdENhc3QoYXBwKXtcbiAgXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNiKXtcbiAgICAgIGFwcC5fbG9nKCdzdGF0ZUluaXQnKVxuICAgICAgY2IobnVsbCwgYXBwKVxuICAgIFxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjYXB0dXJlTmV0d29yayhhcHAsIGNiKSB7XG4gICAgdmFyIG5ldHdvcmsgPSBuZXcgTmV0d29yayhhcHAsIGFyZ3YucHJvdG9jb2wgKyAnOi8vJyArIGFyZ3YuaG9zdCArICc6JyArIGFyZ3YucG9ydClcbiAgICBhcHAuX2xvZygnbmV0Q2FwJylcbiAgICBhcHAubmV0d29yayA9IG5ldHdvcmtcblxuICAgIGNiKG51bGwsIGFwcClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhcHR1cmVTb3VyY2UgKGFwcCwgY2IpIHtcbiAgICAvLyBUT0RPIHNvdXJjZSBpcyBlaXRoZXIgdGhlIG1lZGlhc3RyZWFtIG9yIGEgcGVlciBjb25uZWN0aW9uXG4gICAgXG4gICAgaWYodHJ1ZSB8fCBhcHAuc2Vzc2lvbi5icm9hZGNhc3Rpbmcpe1xuICAgICAgYWRkTWVkaWEoKGVyciwgc3RyZWFtKSA9PntcbiAgICAgICAgYXBwLl9sb2coYG1lZGlhU3RyZWFtIGFkZGVkPyAkeyghIXN0cmVhbSl9YClcbiAgICAgICAgYXBwLl9sb2coYG1lZGlhU3RyZWFtIGVycm9yPyAkeyhlcnIpfWApXG5cbiAgICAgICAgY29uc29sZS5sb2coZXJyKVxuICAgICAgICBjb25zb2xlLmxvZyhzdHJlYW0pXG5cbiAgICAgICAgY29uc3QgbWljID0gYXBwLmF1ZGlvLm1hc3Rlci5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pIFxuICAgICAgICBtaWMuY29ubmVjdChhcHAuYXVkaW8ubWljKVxuXG4gICAgICAgIGFwcC5hdWRpby5tZWRpYXN0cmVhbSA9IHN0cmVhbVxuICAgICAgICBhcHAuYXVkaW8ubWljbm9kZSA9IG1pY1xuICAgIFxuICAgICAgICAvKlxuICAgICAgICB2YXIgYnVmciA9IFtdXG4gICAgICAgIGFwcC5hdWRpby5idWZmZXIgPSBidWZyXG4gICAgICAgIGNvbnN0IHN0clNyYyA9IHRocnUoKGIsIHIsIGNiKT0+e1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3NvdXJjZScsIGIpXG4gICAgICAgICAgY2IobnVsbCwgYilcbiAgICAgICAgfSxlPT57XG4gICAgICAgICAgY29uc29sZS5sb2coZSlcbiAgICAgICAgfSApXG4gICAgICAgIGFwcC5hdWRpby5zb3VyY2VTdHJlYW0gPSBzdHJTcmNcbiAgICAgICAgKi9cbiAgICAgICAgLy8gZG8gc2FtZSBmb3IgaG9zdCBtb25pdG9yaW5nOlxuICAgICAgICAvL2Zvcih2YXIgc21pdGggaW4gcGhvbmVib29rKSBtZWRpYVN0cmVhbS5waXBlKHBob25lYm9va1tzbWl0aF0pIFxuICAgICAgICAvL3VpLm1vbml0b3Iuc3JjT2JqZWN0ID0gc3RyZWFtLy8gPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSkgICAgICBcbiAgICAgICAgLy8gRGVsZXRlIHRoZSBlbmNvZGVyIHdoZW4gZmluaXNoZWQgd2l0aCBpdCAoRW1zY3JpcHRlbiBkb2VzIG5vdCBhdXRvbWF0aWNhbGx5IGNhbGwgQysrIG9iamVjdCBkZXN0cnVjdG9ycylcbiAgICAgICAgLy9lbmNvZGVyLmRlbGV0ZSgpO1xuICAgICAgIGFwcC5fbG9nKCdzb3VyY2VDYXAnKVxuICAgICAgICBjYihlcnIsIGFwcClcbiAgICAgICAgXG4gICAgICBcbiAgICAgIH0pXG4gICAgfVxuXG5cblxuXG4gIH1cblxuICBmdW5jdGlvbiBjYXB0dXJlU2luayhhcHAsIGNiKXtcbiAgICB2YXIge09nZ09wdXNEZWNvZGVyfSA9IHJlcXVpcmUoJ29nZy1vcHVzLWRlY29kZXInKVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3NtKGxvZyl7XG4gICAgXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IE9nZ09wdXNEZWNvZGVyKHtvbkRlY29kZSwgb25EZWNvZGVBbGx9KVxuXG4gICAgICBmdW5jdGlvbiBvbkRlY29kZSAoKSB7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uRGVjb2RlQWxsICh7Y2hhbm5lbERhdGEsIHNhbXBsZXNEZWNvZGVkLCBzYW1wbGVSYXRlfSkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKGNoYW5uZWxEYXRhKVxuICAgICAgICBsZXQgc2FtID0gc2FtcGxlcihhcHAuYXVkaW8ubWFzdGVyLCBjaGFubmVsRGF0YSlcbiAgICAgICAgc2FtLmNvbm5lY3QoYXBwLmF1ZGlvLm1hc3Rlci5kZXN0aW5hdGlvbilcbiAgICAgICAgc2FtLnN0YXJ0KDApXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGRlY29kZXIucmVhZHlcblxuICAgICAgLypcbiAgICAgIGNvbnN0IHNpbmtTdHJlYW0gPSB0aHJ1KChidWYsIGVuYywgY2IpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ3NpbmsnLCBidWYpXG4gICAgICAgIGRlY29kZXIuZGVjb2RlKGJ1ZilcbiAgICAgICAgY2IoKVxuICAgICAgfSwgZSA9PntcbiAgICAgICAgY29uc29sZS5sb2coZSlcbiAgICAgIFxuICAgICAgfSlcblxuICAgICAgdmFyIHNpbmtTdGF0ZSA9IHtcbiAgICAgICAgc2luazogc2lua1N0cmVhbSxcbiAgICAgIH1cbiAgICAgICovXG4gICAgICBidXMub24oXCJzb3VyY2VQZWVyQ2FwdHVyZWRcIiwgaWQgPT4ge1xuICAgICAgICBsZXQgcGVlciA9IGFwcC5uZXR3b3JrLmNvbm5lY3Rpb25zW2lkXVxuICAgICAgICBwZWVyLm9uKCdkYXRhJywgYnVmID0+IHtcbiAgICAgICAgICBhcHAuX2xvZyhidWYubGVuZ3RoKVxuICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgIGRlY29kZXIucmVhZHkudGhlbigoKSA9PiBkZWNvZGVyLmRlY29kZShidWYpKVxuICAgICAgICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICAgICAgIGFwcC5fbG9nKGVyci50b1N0cmluZygpKVxuICAgICAgICAgICAgZGVjb2Rlci5yZWFkeS50aGVuKCgpPT5kZWNvZGVyLmZyZWUoKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICBsb2coKVxuICAgICAgYXBwLmF1ZGlvLmRlY29kZXIgPSBkZWNvZGVyXG4gICAgICAvL2FwcC5hdWRpby5zaW5rU3RyZWFtID0gc2lua1N0cmVhbVxuICAgICAgYXBwLl9sb2coJ3NpbmtDYXAnKVxuICAgICAgY2IobnVsbCwgYXBwKVxuICAgICAgXG4gICAgfVxuXG5cbiAgICB3c20oZnVuY3Rpb24oKXtjb25zb2xlLmxvZygnV0FTTScpfSlcblxuICB9XG5cblxuXG4gIGZ1bmN0aW9uIHRvYihidWYsIHR5cGU9XCJhcHBsaWNhdGlvbi93YXNtXCIpe1xuICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtuZXcgQnVmZmVyKGJ1ZikuYnVmZmVyXSwge3R5cGV9KSlcbiAgfVxuICAgXG4gIHZhciBwZWVycyA9IHt9XG5cbiAgLy91aS5hZGRNaWMub25jbGljayA9IGUgPT4gYWRkTWVkaWEoKVxuXG4gIGZ1bmN0aW9uIG11dGUodG9yZil7XG4gICAgbWljU3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0uZW5hYmxlZCA9IHRvcmZcbiAgfVxuXG5cbiAgdmFyIGNvbm5lY3RpbmcgPSB7fVxuICBmdW5jdGlvbiBpbml0QnJvYWRjYXN0KCl7XG4gICAgLy8gc291cmNlIGNhcCB0aGVuIGJyb2FkY2FzdFxuICAgIHNlc3Npb24uYnJvYWRjYXN0SWQgPSBzaG9ydCgpLmdlbmVyYXRlKClcbiAgICBzZXNzaW9zLmRpc3RhbmNlID0gMFxuICAgIHNlc3Npb24ubWF4Q29ubmVjdGlvbnMgPSAyMFxuICAgIHNlc3Npb24ub2ZmZXJzT3V0ID0gMFxuICAgIC8vIGJlIHNlZWthYmxlIHdoZW4uLlxuICAgIHNlZWthYmxlKHNlc3Npb24pXG4gICAgcmV0dXJuIHNlc3Npb25cbiAgfVxuXG5cblxuICBjbGFzcyBOZXR3b3JrIHsgXG5cbiAgICBjb25zdHJ1Y3RvcihhcHAsIGFkZHIpe1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICAgIC8vY29uc29sZS5sb2coc3RhdGUsIGFkZHIpXG4gICAgICB0aGlzLmFwcCA9IGFwcFxuICAgICAgdGhpcy5odWIgPSBzaWduYWxodWIoYWRkciwgYXBwLnNlc3Npb24uc3RyZWFtKVxuICAgICAgdGhpcy5jaGFubmVsID0gYXBwLnNlc3Npb24uc3RyZWFtXG4gICAgICB0aGlzLmlkID0gYXBwLnNlc3Npb24uaWRcbiAgICAgIHRoaXMuc3RhdGUgPSBhcHAuc3RhdGVcbiAgICAgIHRoaXMuY29ubmVjdGlvbnMgPSB7fVxuICAgICAgdGhpcy5odWJzID0ge30gXG4gICAgICB0aGlzLnBlZXJzID0ge31cbiAgICAgIHRoaXMuY2FsbGVycyA9IHt9XG4gICAgICB0aGlzLmNvbm5lY3RpbmcgPSB7fVxuICAgICAgdGhpcy5kaXN0YW5jZSA9IDFcbiAgICAgIHRoaXMub2ZmZXJzT3V0ID0gMFxuICAgICAgdGhpcy5tYXhDb25uZWN0aW9ucyA9IDQgLy8gc3RhcnQgbG93LCB0ZXN0IGhpZ2gsIGFsc28gaGVscHMgc3ByZWFkIGVhcmx5IHBjYXN0IHRlc3RpbmdcbiAgICAgIHRoaXMuZHVyYXRpb24gPSBudWxsIC8vIHNpbmNlLXdoZW5cbiAgICAgIHRoaXMuY2hhbm5lbHMgPSB7fVxuICAgICAgdGhpcy5kdXJhdGlvbiA9IG5ldyBUaW1lXG4gICAgICB0aGlzLnNpbmtTdHJlYW0gPSB0aHJ1KGJ1ZiA9PiB7XG4gICAgICAgIGZvcih2YXIgbiBpbiB0aGlzLnBlZXJzKXtcbiAgICAgICAgICBsZXQgcCA9IHRoaXMucGVlcnNbbl1cbiAgICAgICAgICBpZihwLndyaXRhYmxlKSBwLndyaXRlKGJ1ZilcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24gY2xvc2UoKXt9KVxuICAgIH1cblxuICAgIGJyb2FkY2FzdChidWYpe1xuICAgICAgZm9yKHZhciBuIGluIHRoaXMucGVlcnMpIHRoaXMucGVlcnNbbl0ud3JpdGUoYnVmKVxuICAgIH1cblxuICAgIHNlbmQoYnVmKXtcbiAgICAgIGZvcih2YXIgbiBpbiB0aGlzLmNhbGxlcnMpIHRoaXMuY2FsbGVyc1tuXS53cml0ZShidWYpXG4gICAgfVxuXG4gICAgbG9nKCl7XG4gICAgICBjb25zb2xlLmxvZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgfVxuXG4gICAgY2xvc2VQZWVyU2lnbmFsKGFkZHIpe1xuICAgICAgdGhpcy5odWIudW5zdWJzY3JpYmUoYWRkcilcbiAgICAgIC8vZGVsZXRlIHRoaXMuY29ubmVjdGlvbnNbYWRkcl1cbiAgICB9XG5cbiAgICBkaXNhbGxvd0NhbGxzKGlkKXtcbiAgICAgIHRoaXMuaHViLnVuc3Vic2NyaWJlKCdjYWxsZXI6JytpZClcbiAgICB9XG5cbiAgICBhbGxvd0NhbGxzKGlkKXtcbiAgICAgIGxldCBjYWxscyA9IHRoaXMuaHViLnN1YnNjcmliZSgnY2FsbGVyOicraWQpXG4gICAgICBjYWxscy5vbignZGF0YScsIG1zZz0+e1xuICAgICAgICBtc2c9SlNPTi5wYXJzZShtc2cpXG4gICAgICAgIGJ1cy5lbWl0KCdjYWxsZXInLCBtc2cpXG4gICAgICB9KVxuICAgICAgYnVzLm9uKCdjYWxsJywgbXNnID0+e1xuICAgICAgICB0aGlzLmNhbGxEaXJlY3QobXNnLnBlZXJJZClcbiAgICAgIH0pXG5cbiAgICB9XG5cbiAgICBpbml0Q2FsbChpZCl7XG4gICAgICBcbiAgICAgIHRoaXMuaHViLmJyb2FkY2FzdCgnY2FsbGVyOicraWQsIHtwZWVySWQ6IHRoaXMuaWR9KVxuICAgICAgbGV0IHBlZXIgPSB0aGlzLmluaXRDb25uZWN0KGlkLCBmYWxzZSwgdGhpcy5pZClcbiAgICAgIHBlZXIub25jZSgnY29ubmVjdGVkJywgZSA9PntcbiAgICAgICAgdGhpcy5jYWxsZXJzW2lkXSA9IHBlZXJcbiAgICAgICAgYnVzLmVtaXQoJ0NhbGwgU291cmNlIENhcHR1cmVkJywgcGVlcilcblxuICAgICAgfSlcbiAgICAgIFxuICAgICAgXG4gICAgfVxuXG4gICAgY2FsbERpcmVjdChpZCl7XG4gICAgICBsZXQgcGVlciA9IHRoaXMuaW5pdENvbm5lY3QoaWQsIHRydWUsIHRoaXMuaWQpXG4gICAgICBwZWVyLm9uY2UoJ2Nvbm5lY3RlZCcsIGUgPT57XG4gICAgICAgIHRoaXMuY2FsbGVyc1tpZF0gPSBwZWVyXG4gICAgICAgIGJ1cy5lbWl0KCdDYWxsIFNvdXJjZSBDYXB0dXJlZCcsIHBlZXIpXG5cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgc291cmNlU2VlaygpeyAvLyBpZCBmb3IgYSBwZWVyIHN0cmVhbVxuICAgICAgdmFyIHNlbGYgPSB0aGlzIFxuICAgICAgbGV0IG1hc2sgPSBzaG9ydCgpLmdlbmVyYXRlKClcbiAgICAgIGxldCBvZmZlcmluZ3MgPSB0aGlzLmh1Yi5zdWJzY3JpYmUobWFzaylcbiAgICAgIHZhciBiZXN0ID0gMC8vSW5maW5pdHlcbiAgICAgIHZhciBjaG9zZW5cbiAgICAgIHZhciBzdGFydCA9IG5ldyBUaW1lXG4gICAgICBvZmZlcmluZ3Mub24oJ2RhdGEnLCBvZmZlciA9PiB7XG4gICAgICAgIG9mZmVyID0gSlNPTi5wYXJzZShvZmZlcilcbiAgICAgICAgc2VsZi5hcHAuX2xvZyhvZmZlcilcbiAgICAgICAgbGV0IHNjb3JlID0gKDEgLyBvZmZlci5kaXN0YW5jZSkgKiBvZmZlci5kdXJhdGlvblxuICAgICAgICBpZihzY29yZSA+IGJlc3QpIHtcbiAgICAgICAgICBiZXN0ID0gc2NvcmUgLy9vZmZlci5kaXN0YW5jZVxuICAgICAgICAgIGNob3NlbiA9IG9mZmVyXG4gICAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKGNob3NlbilcbiAgICAgIH0pXG4gICAgICBsZXQgdDAgPSBzZXRUaW1lb3V0KGUgPT4ge1xuICAgICAgY29uc29sZS5sb2coY2hvc2VuKVxuICAgICAgICBpZihjaG9zZW4pIHtcbiAgICAvLyAgICAgIHRoaXMuaHViLnVuc3Vic2NyaWJlKG1hc2spXG4gICAgICAgICAgLy8gZG8gY2hvc2VuXG4gICAgICAgICAgYnVzLmVtaXQoJ3NvdXJjZVBlZXJJZENhcHR1cmVkJywgY2hvc2VuLnBlZXJJZClcbiAgICAgICAgICAvL3NlbGYuc291cmNlQ2FwKGNob3NlbilcbiAgICAgICAgICBsZXQgcGVlciA9IHRoaXMuaW5pdENvbm5lY3QoY2hvc2VuLnBlZXJJZCwgdHJ1ZSwgbWFzaylcbiAgICAgICAgICBwZWVyLm9uY2UoJ2Nvbm5lY3QnLCBlID0+IHtcbiAgICAgICAgICAgIGJ1cy5lbWl0KCdzb3VyY2VQZWVyQ2FwdHVyZWQnLCBjaG9zZW4ucGVlcklkKVxuICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGNob3Nlbi5kaXN0YW5jZSArIDFcbiAgICAgICAgICAgIHRoaXMuc291cmNlU3RyZWFtID0gcGVlclxuICAgICAgICAgICAgc2VsZi5hcHAuX2xvZygnU291cmNlIFBlZXIgQ2FwdHVyZWQuJylcblxuICAgICAgICAgIH0pXG4gICAgICAgICAgcGVlci5vbignY2xvc2UnLCBlID0+IHtcbiAgICAgICAgICAgIHNlbGYuYXBwLl9sb2coJ1NvdXJjZSBQZWVyIENsb3NlZCcpXG5cbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuYXBwLl9sb2coJ0VycjogTm8gc291cmNlIHBlZXIgZm91bmQuJykgICAgXG4gICAgICAgIH1cbiAgICAgIH0sIDEzMDAwKVxuICAgICAgXG5cbiAgICAgIHRoaXMuaHViLmJyb2FkY2FzdCgnc291cmNlJywgXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBwZWVySWQ6IG1hc2tcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICAgIFxuICAgIH1cblxuICAgIHNldCBzb3VyY2VTdHJlYW0oc3RyZWFtKXtcbiAgICAgIHRoaXMuX3NvdXJjZVN0cmVhbSA9IHN0cmVhbVxuICAgICAgdGhpcy5kdXJhdGlvbiA9IG5ldyBUaW1lKClcbiAgICAgIC8vc3RyZWFtLnBpcGUodGhpcy5zaW5rU3RyZWFtKVxuICAgICAgLy9zdHJlYW0ucGlwZShhcHAuYXVkaW8uc2lua1N0cmVhbSlcbiAgICB9XG5cbiAgICBnZXQgc291cmNlU3RyZWFtKCl7XG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlU3RyZWFtXG4gICAgfVxuXG4gICAgdW5zZWVrYWJsZShzZXNzaW9uKXtcbiAgICAgIGlmKHNlc2lvbikgdGhpcy5odWIudW5zdWJzY3JpYmUoc2Vzc2lvbilcbiAgICB9XG5cbiAgICBpc1NlZWtXb3J0aHkoKXtcbiAgICAgIGxldCByID0gdGhpcy5vZmZlcnNPdXQgPCB0aGlzLm1heENvbm5lY3Rpb25zXG4gICAgICBsZXQgcyA9IHRoaXMubWF4Q29ubmVjdGlvbnMgPiBPYmplY3Qua2V5cyh0aGlzLmNvbm5lY3Rpb25zKS5sZW5ndGggIFxuICAgICAgbGV0IHEgPSByICYmIHMgXG4gICAgICB0aGlzLl9zZWVrYWJsZSA9IHFcbiAgICAgIGlmKHEpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VyID0gdGhpcy5odWIuc3Vic2NyaWJlKCdzb3VyY2UnKVxuICAgICAgICB0aGlzLnNvdXJjZXIub24oJ2RhdGEnLCBtc2cgPT4gdGhpcy5zZWVrYWJsZShKU09OLnBhcnNlKG1zZykpKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmKHRoaXMuc291cmNlcikgdGhpcy5zb3VyY2VyLmNsb3NlKClcbiAgICAgICAgXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc2Vla2FibGVcbiAgICB9XG5cbiAgICBzZXRzdWIoaWQpe1xuICAgICAgaWYodGhpcy5odWJzW2lkXSkgcmV0dXJuIHRoaXMuaHVic1tpZF1cbiAgICAgIGVsc2UgdGhpcy5odWJzW2lkXSA9IHRoaXMuaHViLnN1YnNjcmliZShpZClcbiAgICB9XG4gICAgZ2V0c3ViKGlkKXtcbiAgICAgIHJldHVybiB0aGlzLmh1YnNbaWRdXG4gICAgfVxuXG4gICAgdW5zdWIoaWQpe1xuICAgICAgaWYodGhpcy5odWJzW2lkXSkge1xuICAgICAgICB0aGlzLmh1Yi51bnN1YnNjcmliZShpZCkgXG4gICAgICAgIGRlbGV0ZSB0aGlzLmh1YnNbaWRdIFxuICAgICAgfVxuICAgIH1cblxuICAgIHNlZWthYmxlKG1zZyl7IFxuICAgIHRoaXMuYXBwLl9sb2cobXNnKVxuICAgICAgbGV0IHNlbGYgPSB0aGlzXG4gICAgICBpZihmYWxzZSkgcmV0dXJuIC8vIHx8IE1hdGgucmFuZG9tKCkgPCAxIC8gTWF0aC5wb3coc2VsZi5kaXN0YW5jZSwgMikpIHJldHVyblxuICAgICAgZWxzZXtcbiAgICAgICAgc2VsZi5vZmZlcnNPdXQgKz0gMVxuICAgICAgICBzZXRUaW1lb3V0KGU9PntcbiAgICAgICAgICB0aGlzLm9mZmVyc091dC0tXG4gICAgICAgICAgLy90aGlzLmRpc25pdChtc2cucGVlcklkLCBtYXNrKVxuICAgICAgICB9LCAxMTExKjMpXG4gICAgICAgIGxldCBtYXNrID0gc2hvcnQoKS5nZW5lcmF0ZSgpXG4gICAgICAgIGxldCBwZWVyID0gdGhpcy5pbml0Q29ubmVjdChtc2cucGVlcklkLCBmYWxzZSwgbWFzaylcbiAgICAgICAgcGVlci5vbmNlKCdjb25uZWN0JywgZSA9PntcbiAgICAgICAgICBzZWxmLnBlZXJzW21zZy5wZWVySWRdID0gcGVlclxuICAgICAgICB9KVxuICAgICAgICBwZWVyLm9uY2UoJ2Nsb3NlJywgZSA9PntcbiAgICAgICAgICBkZWxldGUgc2VsZi5wZWVyc1ttc2cucGVlcklkXVxuICAgICAgICAgIHNlbGYuaXNTZWVrV29ydGh5KClcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5odWIuYnJvYWRjYXN0KG1zZy5wZWVySWQsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBwZWVySWQ6IG1hc2ssXG4gICAgICAgICAgdG86IG1zZy5wZWVySWQsXG4gICAgICAgICAgZGlzdGFuY2U6IHRoaXMuZGlzdGFuY2UsXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24uc2luY2VCZWdpbk5TKClcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGlzbml0KGlkLCBtYXNrKXtcbiAgICAgIC8vZGVsZXRlIHRoaXMuY29ubmVjdGluZ1tpZF1cbiAgICAgIC8vdGhpcy5odWIudW5zdWJzY3JpYmUobWFzaylcbiAgICB9XG5cbiAgICBpbml0Q29ubmVjdChpZCwgaW5pdCwgbWFzayl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgIGxldCBwaXBlID0gdGhpcy5odWIuc3Vic2NyaWJlKG1hc2spXG4gICAgICB2YXIgY2FsbGVyID0gbmV3IFBlZXIoe2luaXRpYXRvcjogaW5pdCwgdHJpY2tsZTogZmFsc2UsIG9iamVjdE1vZGU6IGZhbHNlfSlcbiAgICAgIHRoaXMuY29ubmVjdGluZ1tpZF0gPSBjYWxsZXJcbiAgICAgIHBpcGUub24oJ2Vycm9yJywgZSA9PiBjb25zb2xlLmxvZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKVxuICAgICAgcGlwZS5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKVxuICAgICAgICAvLyBjYWxsZXJJRFxuICAgICAgICB2YXIgcGVlciA9IHNlbGYuY29ubmVjdGluZ1tkYXRhLnBlZXJJZF1cbiAgICAgICAgcGVlci5zaWduYWwoZGF0YS5zaWduYWwpXG4gICAgICAgIHBlZXIub25jZSgnY29ubmVjdCcsIGUgPT4ge1xuICAgICAgICAgIC8vIGNsb3NlIG1hc2sgaHViXG4gICAgICAgIH0pXG4gICAgICAgIC8vdWkuY2FsbGVycy5hcHBlbmRDaGlsZChoKCdkaXYuY2FsbGVyJywgaCgnYnV0dG9uLmNvbm5lY3QnLCBgQ29ubmVjdCB0byAke2RhdGEubmFtZSB8fCBmcm9tfWAsIHtvbmNsaWNrOiBfY29ubmVjdH0pKSkgIFxuICAgICAgfSlcbiAgICAgIGNhbGxlci5fZGVidWcgPSBjb25zb2xlLmxvZ1xuICAgICAgY2FsbGVyLm9uKCdzaWduYWwnLCBzaWcgPT4gdGhpcy5odWIuYnJvYWRjYXN0KGlkLCBKU09OLnN0cmluZ2lmeSh7cGVlcklkOiBtYXNrLCB0bzogaWQsIHNpZ25hbDogc2lnIH0pKSlcbiAgICAgIGNhbGxlci5vbmNlKCdjb25uZWN0JywgZSA9PiB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnNbaWRdID0gY2FsbGVyXG4gICAgICAgIHRoaXMuY29ubmVjdGluZ1tpZF0gPSBudWxsXG4gICAgICAgIGNvbnNvbGUubG9nKGBjb25uZWN0ZWQgdG8gJHtPYmplY3Qua2V5cyh0aGlzLmNvbm5lY3Rpb25zKS5sZW5ndGh9IHBlZXJzYClcbiAgICAgIH0pXG4gICAgICBjYWxsZXIub24oJ2Nsb3NlJywgZSA9PiB7XG4gICAgICAgIHRoaXMuZGlzbml0KGlkLCBtYXNrKVxuICAgICAgfSlcbiAgICAgIGNhbGxlci5vbignZXJyb3InLCBlID0+IGNvbnNvbGUubG9nKGUpKVxuICAgICAgcmV0dXJuIGNhbGxlclxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gYWRkTWVkaWEoY2IsIGF1ZGlvPXRydWUsIHZpZGVvPWZhbHNlKXtcbiAgICB2YXIgZ2FtID0gcmVxdWlyZSgnZ2V0dXNlcm1lZGlhJylcbiAgICAvLyBXZWIgd29ya2VyIGFuZCAud2FzbSBjb25maWd1cmF0aW9uLiBOb3RlOiBUaGlzIGlzIE5PVCBhIHBhcnQgb2YgVzNDIHN0YW5kYXJkLlxuICAgIGdhbSh7dmlkZW8sIGF1ZGlvfSwgZnVuY3Rpb24oZXJyLCBzdHJlYW0pe1xuICAgICAgLy9jb25zb2xlLmxvZyhzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKSlcblxuXG4gICAgICBjYihlcnIsIHN0cmVhbSlcbiAgICB9KVxuICAgfSAgICBcbn0pXG4iLCJ2YXIgQ29udmVydGVyID0gcmVxdWlyZSgnLi9zcmMvY29udmVydGVyJyk7XG5cbi8qKlxuICogRnVuY3Rpb24gZ2V0IHNvdXJjZSBhbmQgZGVzdGluYXRpb24gYWxwaGFiZXQgYW5kIHJldHVybiBjb252ZXJ0IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHNyY0FscGhhYmV0XG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gZHN0QWxwaGFiZXRcbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24obnVtYmVyfEFycmF5KX1cbiAqL1xuZnVuY3Rpb24gYW55QmFzZShzcmNBbHBoYWJldCwgZHN0QWxwaGFiZXQpIHtcbiAgICB2YXIgY29udmVydGVyID0gbmV3IENvbnZlcnRlcihzcmNBbHBoYWJldCwgZHN0QWxwaGFiZXQpO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBudW1iZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xBcnJheX0gbnVtYmVyXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRlci5jb252ZXJ0KG51bWJlcik7XG4gICAgfVxufTtcblxuYW55QmFzZS5CSU4gPSAnMDEnO1xuYW55QmFzZS5PQ1QgPSAnMDEyMzQ1NjcnO1xuYW55QmFzZS5ERUMgPSAnMDEyMzQ1Njc4OSc7XG5hbnlCYXNlLkhFWCA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxubW9kdWxlLmV4cG9ydHMgPSBhbnlCYXNlOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb252ZXJ0ZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gc3JjQWxwaGFiZXRcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBkc3RBbHBoYWJldFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbnZlcnRlcihzcmNBbHBoYWJldCwgZHN0QWxwaGFiZXQpIHtcbiAgICBpZiAoIXNyY0FscGhhYmV0IHx8ICFkc3RBbHBoYWJldCB8fCAhc3JjQWxwaGFiZXQubGVuZ3RoIHx8ICFkc3RBbHBoYWJldC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgYWxwaGFiZXQnKTtcbiAgICB9XG4gICAgdGhpcy5zcmNBbHBoYWJldCA9IHNyY0FscGhhYmV0O1xuICAgIHRoaXMuZHN0QWxwaGFiZXQgPSBkc3RBbHBoYWJldDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IG51bWJlciBmcm9tIHNvdXJjZSBhbHBoYWJldCB0byBkZXN0aW5hdGlvbiBhbHBoYWJldFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBudW1iZXIgLSBudW1iZXIgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgcG9pbnRzXG4gKlxuICogQHJldHVybnMge3N0cmluZ3xBcnJheX1cbiAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgdmFyIGksIGRpdmlkZSwgbmV3bGVuLFxuICAgIG51bWJlck1hcCA9IHt9LFxuICAgIGZyb21CYXNlID0gdGhpcy5zcmNBbHBoYWJldC5sZW5ndGgsXG4gICAgdG9CYXNlID0gdGhpcy5kc3RBbHBoYWJldC5sZW5ndGgsXG4gICAgbGVuZ3RoID0gbnVtYmVyLmxlbmd0aCxcbiAgICByZXN1bHQgPSB0eXBlb2YgbnVtYmVyID09PSAnc3RyaW5nJyA/ICcnIDogW107XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZChudW1iZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVyIFwiJyArIG51bWJlciArICdcIiBjb250YWlucyBvZiBub24tYWxwaGFiZXRpYyBkaWdpdHMgKCcgKyB0aGlzLnNyY0FscGhhYmV0ICsgJyknKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zcmNBbHBoYWJldCA9PT0gdGhpcy5kc3RBbHBoYWJldCkge1xuICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBudW1iZXJNYXBbaV0gPSB0aGlzLnNyY0FscGhhYmV0LmluZGV4T2YobnVtYmVyW2ldKTtcbiAgICB9XG4gICAgZG8ge1xuICAgICAgICBkaXZpZGUgPSAwO1xuICAgICAgICBuZXdsZW4gPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRpdmlkZSA9IGRpdmlkZSAqIGZyb21CYXNlICsgbnVtYmVyTWFwW2ldO1xuICAgICAgICAgICAgaWYgKGRpdmlkZSA+PSB0b0Jhc2UpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJNYXBbbmV3bGVuKytdID0gcGFyc2VJbnQoZGl2aWRlIC8gdG9CYXNlLCAxMCk7XG4gICAgICAgICAgICAgICAgZGl2aWRlID0gZGl2aWRlICUgdG9CYXNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyTWFwW25ld2xlbisrXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID0gbmV3bGVuO1xuICAgICAgICByZXN1bHQgPSB0aGlzLmRzdEFscGhhYmV0LnNsaWNlKGRpdmlkZSwgZGl2aWRlICsgMSkuY29uY2F0KHJlc3VsdCk7XG4gICAgfSB3aGlsZSAobmV3bGVuICE9PSAwKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkIG51bWJlciB3aXRoIHNvdXJjZSBhbHBoYWJldFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgbnVtYmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0aGlzLnNyY0FscGhhYmV0LmluZGV4T2YobnVtYmVyW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udmVydGVyOyIsIi8qISBibG9iLXRvLWJ1ZmZlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuLyogZ2xvYmFsIEJsb2IsIEZpbGVSZWFkZXIgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBibG9iVG9CdWZmZXIgKGJsb2IsIGNiKSB7XG4gIGlmICh0eXBlb2YgQmxvYiA9PT0gJ3VuZGVmaW5lZCcgfHwgIShibG9iIGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBCbG9iJylcbiAgfVxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgfVxuXG4gIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcblxuICBmdW5jdGlvbiBvbkxvYWRFbmQgKGUpIHtcbiAgICByZWFkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIG9uTG9hZEVuZCwgZmFsc2UpXG4gICAgaWYgKGUuZXJyb3IpIGNiKGUuZXJyb3IpXG4gICAgZWxzZSBjYihudWxsLCBCdWZmZXIuZnJvbShyZWFkZXIucmVzdWx0KSlcbiAgfVxuXG4gIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgb25Mb2FkRW5kLCBmYWxzZSlcbiAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG59XG4iLCIvKiFcbiAqIENyb3NzLUJyb3dzZXIgU3BsaXQgMS4xLjFcbiAqIENvcHlyaWdodCAyMDA3LTIwMTIgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+XG4gKiBBdmFpbGFibGUgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBFQ01BU2NyaXB0IGNvbXBsaWFudCwgdW5pZm9ybSBjcm9zcy1icm93c2VyIHNwbGl0IG1ldGhvZFxuICovXG5cbi8qKlxuICogU3BsaXRzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncyB1c2luZyBhIHJlZ2V4IG9yIHN0cmluZyBzZXBhcmF0b3IuIE1hdGNoZXMgb2YgdGhlXG4gKiBzZXBhcmF0b3IgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IGFycmF5LiBIb3dldmVyLCBpZiBgc2VwYXJhdG9yYCBpcyBhIHJlZ2V4IHRoYXQgY29udGFpbnNcbiAqIGNhcHR1cmluZyBncm91cHMsIGJhY2tyZWZlcmVuY2VzIGFyZSBzcGxpY2VkIGludG8gdGhlIHJlc3VsdCBlYWNoIHRpbWUgYHNlcGFyYXRvcmAgaXMgbWF0Y2hlZC5cbiAqIEZpeGVzIGJyb3dzZXIgYnVncyBjb21wYXJlZCB0byB0aGUgbmF0aXZlIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBhbmQgY2FuIGJlIHVzZWQgcmVsaWFibHlcbiAqIGNyb3NzLWJyb3dzZXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzcGxpdC5cbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gc2VwYXJhdG9yIFJlZ2V4IG9yIHN0cmluZyB0byB1c2UgZm9yIHNlcGFyYXRpbmcgdGhlIHN0cmluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXRdIE1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIGluY2x1ZGUgaW4gdGhlIHJlc3VsdCBhcnJheS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2Ygc3Vic3RyaW5ncy5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQmFzaWMgdXNlXG4gKiBzcGxpdCgnYSBiIGMgZCcsICcgJyk7XG4gKiAvLyAtPiBbJ2EnLCAnYicsICdjJywgJ2QnXVxuICpcbiAqIC8vIFdpdGggbGltaXRcbiAqIHNwbGl0KCdhIGIgYyBkJywgJyAnLCAyKTtcbiAqIC8vIC0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBCYWNrcmVmZXJlbmNlcyBpbiByZXN1bHQgYXJyYXlcbiAqIHNwbGl0KCcuLndvcmQxIHdvcmQyLi4nLCAvKFthLXpdKykoXFxkKykvaSk7XG4gKiAvLyAtPiBbJy4uJywgJ3dvcmQnLCAnMScsICcgJywgJ3dvcmQnLCAnMicsICcuLiddXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIHNwbGl0KHVuZGVmKSB7XG5cbiAgdmFyIG5hdGl2ZVNwbGl0ID0gU3RyaW5nLnByb3RvdHlwZS5zcGxpdCxcbiAgICBjb21wbGlhbnRFeGVjTnBjZyA9IC8oKT8/Ly5leGVjKFwiXCIpWzFdID09PSB1bmRlZixcbiAgICAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgIHNlbGY7XG5cbiAgc2VsZiA9IGZ1bmN0aW9uKHN0ciwgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgYG5hdGl2ZVNwbGl0YFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gXCJbb2JqZWN0IFJlZ0V4cF1cIikge1xuICAgICAgcmV0dXJuIG5hdGl2ZVNwbGl0LmNhbGwoc3RyLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpICsgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyBcIm1cIiA6IFwiXCIpICsgKHNlcGFyYXRvci5leHRlbmRlZCA/IFwieFwiIDogXCJcIikgKyAvLyBQcm9wb3NlZCBmb3IgRVM2XG4gICAgICAoc2VwYXJhdG9yLnN0aWNreSA/IFwieVwiIDogXCJcIiksXG4gICAgICAvLyBGaXJlZm94IDMrXG4gICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgXCJnXCIpLFxuICAgICAgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICBzdHIgKz0gXCJcIjsgLy8gVHlwZS1jb252ZXJ0XG4gICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cChcIl5cIiArIHNlcGFyYXRvci5zb3VyY2UgKyBcIiQoPyFcXFxccylcIiwgZmxhZ3MpO1xuICAgIH1cbiAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICovXG4gICAgbGltaXQgPSBsaW1pdCA9PT0gdW5kZWYgPyAtMSA+Pj4gMCA6IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICBsaW1pdCA+Pj4gMDsgLy8gVG9VaW50MzIobGltaXQpXG4gICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyKSkge1xuICAgICAgLy8gYHNlcGFyYXRvci5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHVuZGVmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlcGFyYXRvci5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvci50ZXN0KFwiXCIpKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKFwiXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChzdHIuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn0pKCk7XG4iLCIvLyBjb250YWlucywgYWRkLCByZW1vdmUsIHRvZ2dsZVxudmFyIGluZGV4b2YgPSByZXF1aXJlKCdpbmRleG9mJylcblxubW9kdWxlLmV4cG9ydHMgPSBDbGFzc0xpc3RcblxuZnVuY3Rpb24gQ2xhc3NMaXN0KGVsZW0pIHtcbiAgICB2YXIgY2wgPSBlbGVtLmNsYXNzTGlzdFxuXG4gICAgaWYgKGNsKSB7XG4gICAgICAgIHJldHVybiBjbFxuICAgIH1cblxuICAgIHZhciBjbGFzc0xpc3QgPSB7XG4gICAgICAgIGFkZDogYWRkXG4gICAgICAgICwgcmVtb3ZlOiByZW1vdmVcbiAgICAgICAgLCBjb250YWluczogY29udGFpbnNcbiAgICAgICAgLCB0b2dnbGU6IHRvZ2dsZVxuICAgICAgICAsIHRvU3RyaW5nOiAkdG9TdHJpbmdcbiAgICAgICAgLCBsZW5ndGg6IDBcbiAgICAgICAgLCBpdGVtOiBpdGVtXG4gICAgfVxuXG4gICAgcmV0dXJuIGNsYXNzTGlzdFxuXG4gICAgZnVuY3Rpb24gYWRkKHRva2VuKSB7XG4gICAgICAgIHZhciBsaXN0ID0gZ2V0VG9rZW5zKClcbiAgICAgICAgaWYgKGluZGV4b2YobGlzdCwgdG9rZW4pID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGxpc3QucHVzaCh0b2tlbilcbiAgICAgICAgc2V0VG9rZW5zKGxpc3QpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKHRva2VuKSB7XG4gICAgICAgIHZhciBsaXN0ID0gZ2V0VG9rZW5zKClcbiAgICAgICAgICAgICwgaW5kZXggPSBpbmRleG9mKGxpc3QsIHRva2VuKVxuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgIHNldFRva2VucyhsaXN0KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHRva2VuKSB7XG4gICAgICAgIHJldHVybiBpbmRleG9mKGdldFRva2VucygpLCB0b2tlbikgPiAtMVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZSh0b2tlbikge1xuICAgICAgICBpZiAoY29udGFpbnModG9rZW4pKSB7XG4gICAgICAgICAgICByZW1vdmUodG9rZW4pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZCh0b2tlbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBlbGVtLmNsYXNzTmFtZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZW0oaW5kZXgpIHtcbiAgICAgICAgdmFyIHRva2VucyA9IGdldFRva2VucygpXG4gICAgICAgIHJldHVybiB0b2tlbnNbaW5kZXhdIHx8IG51bGxcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUb2tlbnMoKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZVxuXG4gICAgICAgIHJldHVybiBmaWx0ZXIoY2xhc3NOYW1lLnNwbGl0KFwiIFwiKSwgaXNUcnV0aHkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VG9rZW5zKGxpc3QpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoXG5cbiAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBsaXN0LmpvaW4oXCIgXCIpXG4gICAgICAgIGNsYXNzTGlzdC5sZW5ndGggPSBsZW5ndGhcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdFtpXSA9IGxpc3RbaV1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBsaXN0W2xlbmd0aF1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlciAoYXJyLCBmbikge1xuICAgIHZhciByZXQgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmbihhcnJbaV0pKSByZXQucHVzaChhcnJbaV0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaXNUcnV0aHkodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4gZW5hYmxlT3ZlcnJpZGUgPT09IG51bGwgPyBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSkgOiBlbmFibGVPdmVycmlkZSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCcm93c2VySW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VySW5mbyhuYW1lLCB2ZXJzaW9uLCBvcykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLm9zID0gb3M7XG4gICAgfVxuICAgIHJldHVybiBCcm93c2VySW5mbztcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJJbmZvID0gQnJvd3NlckluZm87XG52YXIgTm9kZUluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZUluZm8odmVyc2lvbikge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLm5hbWUgPSAnbm9kZSc7XG4gICAgICAgIHRoaXMub3MgPSBwcm9jZXNzLnBsYXRmb3JtO1xuICAgIH1cbiAgICByZXR1cm4gTm9kZUluZm87XG59KCkpO1xuZXhwb3J0cy5Ob2RlSW5mbyA9IE5vZGVJbmZvO1xudmFyIEJvdEluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQm90SW5mbygpIHtcbiAgICAgICAgdGhpcy5ib3QgPSB0cnVlOyAvLyBOT1RFOiBkZXByZWNhdGVkIHRlc3QgbmFtZSBpbnN0ZWFkXG4gICAgICAgIHRoaXMubmFtZSA9ICdib3QnO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9zID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEJvdEluZm87XG59KCkpO1xuZXhwb3J0cy5Cb3RJbmZvID0gQm90SW5mbztcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbnZhciBTRUFSQ0hCT1hfVUFfUkVHRVggPSAvYWxleGF8Ym90fGNyYXdsKGVyfGluZyl8ZmFjZWJvb2tleHRlcm5hbGhpdHxmZWVkYnVybmVyfGdvb2dsZSB3ZWIgcHJldmlld3xuYWdpb3N8cG9zdHJhbmt8cGluZ2RvbXxzbHVycHxzcGlkZXJ8eWFob28hfHlhbmRleC87XG52YXIgU0VBUkNIQk9UX09TX1JFR0VYID0gLyhudWhrKXwoR29vZ2xlYm90KXwoWWFtbXlib3QpfChPcGVuYm90KXwoU2x1cnApfChNU05Cb3QpfChBc2sgSmVldmVzXFwvVGVvbWEpfChpYV9hcmNoaXZlcikvO1xudmFyIFJFUVVJUkVEX1ZFUlNJT05fUEFSVFMgPSAzO1xudmFyIHVzZXJBZ2VudFJ1bGVzID0gW1xuICAgIFsnYW9sJywgL0FPTFNoaWVsZFxcLyhbMC05XFwuX10rKS9dLFxuICAgIFsnZWRnZScsIC9FZGdlXFwvKFswLTlcXC5fXSspL10sXG4gICAgWydlZGdlLWlvcycsIC9FZGdpT1NcXC8oWzAtOVxcLl9dKykvXSxcbiAgICBbJ3lhbmRleGJyb3dzZXInLCAvWWFCcm93c2VyXFwvKFswLTlcXC5fXSspL10sXG4gICAgWyd2aXZhbGRpJywgL1ZpdmFsZGlcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsna2FrYW90YWxrJywgL0tBS0FPVEFMS1xccyhbMC05XFwuXSspL10sXG4gICAgWydzYW1zdW5nJywgL1NhbXN1bmdCcm93c2VyXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ3NpbGsnLCAvXFxiU2lsa1xcLyhbMC05Ll8tXSspXFxiL10sXG4gICAgWydtaXVpJywgL01pdWlCcm93c2VyXFwvKFswLTlcXC5dKykkL10sXG4gICAgWydiZWFrZXInLCAvQmVha2VyQnJvd3NlclxcLyhbMC05XFwuXSspL10sXG4gICAgWydlZGdlLWNocm9taXVtJywgL0VkZ1xcLyhbMC05XFwuXSspL10sXG4gICAgW1xuICAgICAgICAnY2hyb21pdW0td2VidmlldycsXG4gICAgICAgIC8oPyFDaHJvbS4qT1BSKXd2XFwpLipDaHJvbSg/OmV8aXVtKVxcLyhbMC05XFwuXSspKDo/XFxzfCQpLyxcbiAgICBdLFxuICAgIFsnY2hyb21lJywgLyg/IUNocm9tLipPUFIpQ2hyb20oPzplfGl1bSlcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsncGhhbnRvbWpzJywgL1BoYW50b21KU1xcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sXG4gICAgWydjcmlvcycsIC9DcmlPU1xcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sXG4gICAgWydmaXJlZm94JywgL0ZpcmVmb3hcXC8oWzAtOVxcLl0rKSg/Olxcc3wkKS9dLFxuICAgIFsnZnhpb3MnLCAvRnhpT1NcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnb3BlcmEtbWluaScsIC9PcGVyYSBNaW5pLipWZXJzaW9uXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ29wZXJhJywgL09wZXJhXFwvKFswLTlcXC5dKykoPzpcXHN8JCkvXSxcbiAgICBbJ29wZXJhJywgL09QUlxcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sXG4gICAgWydpZScsIC9UcmlkZW50XFwvN1xcLjAuKnJ2XFw6KFswLTlcXC5dKykuKlxcKS4qR2Vja28kL10sXG4gICAgWydpZScsIC9NU0lFXFxzKFswLTlcXC5dKyk7LipUcmlkZW50XFwvWzQtN10uMC9dLFxuICAgIFsnaWUnLCAvTVNJRVxccyg3XFwuMCkvXSxcbiAgICBbJ2JiMTAnLCAvQkIxMDtcXHNUb3VjaC4qVmVyc2lvblxcLyhbMC05XFwuXSspL10sXG4gICAgWydhbmRyb2lkJywgL0FuZHJvaWRcXHMoWzAtOVxcLl0rKS9dLFxuICAgIFsnaW9zJywgL1ZlcnNpb25cXC8oWzAtOVxcLl9dKykuKk1vYmlsZS4qU2FmYXJpLiovXSxcbiAgICBbJ3NhZmFyaScsIC9WZXJzaW9uXFwvKFswLTlcXC5fXSspLipTYWZhcmkvXSxcbiAgICBbJ2ZhY2Vib29rJywgL0ZCQVZcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnaW5zdGFncmFtJywgL0luc3RhZ3JhbVxccyhbMC05XFwuXSspL10sXG4gICAgWydpb3Mtd2VidmlldycsIC9BcHBsZVdlYktpdFxcLyhbMC05XFwuXSspLipNb2JpbGUvXSxcbiAgICBbJ2lvcy13ZWJ2aWV3JywgL0FwcGxlV2ViS2l0XFwvKFswLTlcXC5dKykuKkdlY2tvXFwpJC9dLFxuICAgIFsnc2VhcmNoYm90JywgU0VBUkNIQk9YX1VBX1JFR0VYXSxcbl07XG52YXIgb3BlcmF0aW5nU3lzdGVtUnVsZXMgPSBbXG4gICAgWydpT1MnLCAvaVAoaG9uZXxvZHxhZCkvXSxcbiAgICBbJ0FuZHJvaWQgT1MnLCAvQW5kcm9pZC9dLFxuICAgIFsnQmxhY2tCZXJyeSBPUycsIC9CbGFja0JlcnJ5fEJCMTAvXSxcbiAgICBbJ1dpbmRvd3MgTW9iaWxlJywgL0lFTW9iaWxlL10sXG4gICAgWydBbWF6b24gT1MnLCAvS2luZGxlL10sXG4gICAgWydXaW5kb3dzIDMuMTEnLCAvV2luMTYvXSxcbiAgICBbJ1dpbmRvd3MgOTUnLCAvKFdpbmRvd3MgOTUpfChXaW45NSl8KFdpbmRvd3NfOTUpL10sXG4gICAgWydXaW5kb3dzIDk4JywgLyhXaW5kb3dzIDk4KXwoV2luOTgpL10sXG4gICAgWydXaW5kb3dzIDIwMDAnLCAvKFdpbmRvd3MgTlQgNS4wKXwoV2luZG93cyAyMDAwKS9dLFxuICAgIFsnV2luZG93cyBYUCcsIC8oV2luZG93cyBOVCA1LjEpfChXaW5kb3dzIFhQKS9dLFxuICAgIFsnV2luZG93cyBTZXJ2ZXIgMjAwMycsIC8oV2luZG93cyBOVCA1LjIpL10sXG4gICAgWydXaW5kb3dzIFZpc3RhJywgLyhXaW5kb3dzIE5UIDYuMCkvXSxcbiAgICBbJ1dpbmRvd3MgNycsIC8oV2luZG93cyBOVCA2LjEpL10sXG4gICAgWydXaW5kb3dzIDgnLCAvKFdpbmRvd3MgTlQgNi4yKS9dLFxuICAgIFsnV2luZG93cyA4LjEnLCAvKFdpbmRvd3MgTlQgNi4zKS9dLFxuICAgIFsnV2luZG93cyAxMCcsIC8oV2luZG93cyBOVCAxMC4wKS9dLFxuICAgIFsnV2luZG93cyBNRScsIC9XaW5kb3dzIE1FL10sXG4gICAgWydPcGVuIEJTRCcsIC9PcGVuQlNEL10sXG4gICAgWydTdW4gT1MnLCAvU3VuT1MvXSxcbiAgICBbJ0Nocm9tZSBPUycsIC9Dck9TL10sXG4gICAgWydMaW51eCcsIC8oTGludXgpfChYMTEpL10sXG4gICAgWydNYWMgT1MnLCAvKE1hY19Qb3dlclBDKXwoTWFjaW50b3NoKS9dLFxuICAgIFsnUU5YJywgL1FOWC9dLFxuICAgIFsnQmVPUycsIC9CZU9TL10sXG4gICAgWydPUy8yJywgL09TXFwvMi9dLFxuICAgIFsnU2VhcmNoIEJvdCcsIFNFQVJDSEJPVF9PU19SRUdFWF0sXG5dO1xuZnVuY3Rpb24gZGV0ZWN0KHVzZXJBZ2VudCkge1xuICAgIGlmICghIXVzZXJBZ2VudCkge1xuICAgICAgICByZXR1cm4gcGFyc2VVc2VyQWdlbnQodXNlckFnZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVVzZXJBZ2VudChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldE5vZGVWZXJzaW9uKCk7XG59XG5leHBvcnRzLmRldGVjdCA9IGRldGVjdDtcbmZ1bmN0aW9uIHBhcnNlVXNlckFnZW50KHVhKSB7XG4gICAgLy8gb3B0ZWQgZm9yIHVzaW5nIHJlZHVjZSBoZXJlIHJhdGhlciB0aGFuIEFycmF5I2ZpcnN0IHdpdGggYSByZWdleC50ZXN0IGNhbGxcbiAgICAvLyB0aGlzIGlzIHByaW1hcmlseSBiZWNhdXNlIHVzaW5nIHRoZSByZWR1Y2Ugd2Ugb25seSBwZXJmb3JtIHRoZSByZWdleFxuICAgIC8vIGV4ZWN1dGlvbiBvbmNlIHJhdGhlciB0aGFuIG9uY2UgZm9yIHRoZSB0ZXN0IGFuZCBmb3IgdGhlIGV4ZWMgYWdhaW4gYmVsb3dcbiAgICAvLyBwcm9iYWJseSBzb21ldGhpbmcgdGhhdCBuZWVkcyB0byBiZSBiZW5jaG1hcmtlZCB0aG91Z2hcbiAgICB2YXIgbWF0Y2hlZFJ1bGUgPSB1YSAhPT0gJycgJiZcbiAgICAgICAgdXNlckFnZW50UnVsZXMucmVkdWNlKGZ1bmN0aW9uIChtYXRjaGVkLCBfYSkge1xuICAgICAgICAgICAgdmFyIGJyb3dzZXIgPSBfYVswXSwgcmVnZXggPSBfYVsxXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdWFNYXRjaCA9IHJlZ2V4LmV4ZWModWEpO1xuICAgICAgICAgICAgcmV0dXJuICEhdWFNYXRjaCAmJiBbYnJvd3NlciwgdWFNYXRjaF07XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICBpZiAoIW1hdGNoZWRSdWxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IG1hdGNoZWRSdWxlWzBdLCBtYXRjaCA9IG1hdGNoZWRSdWxlWzFdO1xuICAgIGlmIChuYW1lID09PSAnc2VhcmNoYm90Jykge1xuICAgICAgICByZXR1cm4gbmV3IEJvdEluZm8oKTtcbiAgICB9XG4gICAgdmFyIHZlcnNpb25QYXJ0cyA9IG1hdGNoWzFdICYmIG1hdGNoWzFdLnNwbGl0KC9bLl9dLykuc2xpY2UoMCwgMyk7XG4gICAgaWYgKHZlcnNpb25QYXJ0cykge1xuICAgICAgICBpZiAodmVyc2lvblBhcnRzLmxlbmd0aCA8IFJFUVVJUkVEX1ZFUlNJT05fUEFSVFMpIHtcbiAgICAgICAgICAgIHZlcnNpb25QYXJ0cyA9IF9fc3ByZWFkQXJyYXlzKHZlcnNpb25QYXJ0cywgY3JlYXRlVmVyc2lvblBhcnRzKFJFUVVJUkVEX1ZFUlNJT05fUEFSVFMgLSB2ZXJzaW9uUGFydHMubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZlcnNpb25QYXJ0cyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJyb3dzZXJJbmZvKG5hbWUsIHZlcnNpb25QYXJ0cy5qb2luKCcuJyksIGRldGVjdE9TKHVhKSk7XG59XG5leHBvcnRzLnBhcnNlVXNlckFnZW50ID0gcGFyc2VVc2VyQWdlbnQ7XG5mdW5jdGlvbiBkZXRlY3RPUyh1YSkge1xuICAgIGZvciAodmFyIGlpID0gMCwgY291bnQgPSBvcGVyYXRpbmdTeXN0ZW1SdWxlcy5sZW5ndGg7IGlpIDwgY291bnQ7IGlpKyspIHtcbiAgICAgICAgdmFyIF9hID0gb3BlcmF0aW5nU3lzdGVtUnVsZXNbaWldLCBvcyA9IF9hWzBdLCByZWdleCA9IF9hWzFdO1xuICAgICAgICB2YXIgbWF0Y2ggPSByZWdleC50ZXN0KHVhKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmRldGVjdE9TID0gZGV0ZWN0T1M7XG5mdW5jdGlvbiBnZXROb2RlVmVyc2lvbigpIHtcbiAgICB2YXIgaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbjtcbiAgICByZXR1cm4gaXNOb2RlID8gbmV3IE5vZGVJbmZvKHByb2Nlc3MudmVyc2lvbi5zbGljZSgxKSkgOiBudWxsO1xufVxuZXhwb3J0cy5nZXROb2RlVmVyc2lvbiA9IGdldE5vZGVWZXJzaW9uO1xuZnVuY3Rpb24gY3JlYXRlVmVyc2lvblBhcnRzKGNvdW50KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBjb3VudDsgaWkrKykge1xuICAgICAgICBvdXRwdXQucHVzaCgnMCcpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuIiwiLyohXG4gICogZG9tcmVhZHkgKGMpIER1c3RpbiBEaWF6IDIwMTQgLSBMaWNlbnNlIE1JVFxuICAqL1xuIWZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uKSB7XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcpIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpXG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JykgZGVmaW5lKGRlZmluaXRpb24pXG4gIGVsc2UgdGhpc1tuYW1lXSA9IGRlZmluaXRpb24oKVxuXG59KCdkb21yZWFkeScsIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZm5zID0gW10sIGxpc3RlbmVyXG4gICAgLCBkb2MgPSBkb2N1bWVudFxuICAgICwgaGFjayA9IGRvYy5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGxcbiAgICAsIGRvbUNvbnRlbnRMb2FkZWQgPSAnRE9NQ29udGVudExvYWRlZCdcbiAgICAsIGxvYWRlZCA9IChoYWNrID8gL15sb2FkZWR8XmMvIDogL15sb2FkZWR8Xml8XmMvKS50ZXN0KGRvYy5yZWFkeVN0YXRlKVxuXG5cbiAgaWYgKCFsb2FkZWQpXG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKGRvbUNvbnRlbnRMb2FkZWQsIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKGRvbUNvbnRlbnRMb2FkZWQsIGxpc3RlbmVyKVxuICAgIGxvYWRlZCA9IDFcbiAgICB3aGlsZSAobGlzdGVuZXIgPSBmbnMuc2hpZnQoKSkgbGlzdGVuZXIoKVxuICB9KVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICBsb2FkZWQgPyBzZXRUaW1lb3V0KGZuLCAwKSA6IGZucy5wdXNoKGZuKVxuICB9XG5cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7IFtrZXk6IHN0cmluZ106IGFueSB9fSBFeHRlbnNpb25zXG4gKiBAdHlwZWRlZiB7RXJyb3J9IEVyclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2VcbiAqL1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBvYmpcbiAqIEBwYXJhbSB7RXh0ZW5zaW9uc30gcHJvcHNcbiAqIEByZXR1cm5zIHtFcnJvciAmIEV4dGVuc2lvbnN9XG4gKi9cbmZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogcHJvcHNba2V5XSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7YW55fSBlcnIgLSBBbiBFcnJvclxuICogQHBhcmFtIHtzdHJpbmd8RXh0ZW5zaW9uc30gY29kZSAtIEEgc3RyaW5nIGNvZGUgb3IgcHJvcHMgdG8gc2V0IG9uIHRoZSBlcnJvclxuICogQHBhcmFtIHtFeHRlbnNpb25zfSBbcHJvcHNdIC0gUHJvcHMgdG8gc2V0IG9uIHRoZSBlcnJvclxuICogQHJldHVybnMge0Vycm9yICYgRXh0ZW5zaW9uc31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3IoZXJyLCBjb2RlLCBwcm9wcykge1xuICAgIGlmICghZXJyIHx8IHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSBwYXNzIGFuIEVycm9yIHRvIGVyci1jb2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICBwcm9wcyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcHJvcHMgPSBjb2RlO1xuICAgICAgICBjb2RlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUpIHtcbiAgICAgICAgcHJvcHMuY29kZSA9IGNvZGU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFzc2lnbihlcnIsIHByb3BzKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHByb3BzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgcHJvcHMuc3RhY2sgPSBlcnIuc3RhY2s7XG5cbiAgICAgICAgY29uc3QgRXJyQ2xhc3MgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICBFcnJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihlcnIpKTtcblxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGFzc2lnbihuZXcgRXJyQ2xhc3MoKSwgcHJvcHMpO1xuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUVycm9yO1xuIiwiLyoqXG4gKiBAYXV0aG9yIFRvcnUgTmFnYXNoaW1hIDxodHRwczovL2dpdGh1Yi5jb20vbXlzdGljYXRlYT5cbiAqIEBjb3B5cmlnaHQgMjAxNSBUb3J1IE5hZ2FzaGltYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFNlZSBMSUNFTlNFIGZpbGUgaW4gcm9vdCBkaXJlY3RvcnkgZm9yIGZ1bGwgbGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFByaXZhdGVEYXRhXG4gKiBAcHJvcGVydHkge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0LlxuICogQHByb3BlcnR5IHt7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGV2ZW50UGhhc2UgVGhlIGN1cnJlbnQgZXZlbnQgcGhhc2UuXG4gKiBAcHJvcGVydHkge0V2ZW50VGFyZ2V0fG51bGx9IGN1cnJlbnRUYXJnZXQgVGhlIGN1cnJlbnQgZXZlbnQgdGFyZ2V0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBjYW5jZWxlZCBUaGUgZmxhZyB0byBwcmV2ZW50IGRlZmF1bHQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0b3BwZWQgVGhlIGZsYWcgdG8gc3RvcCBwcm9wYWdhdGlvbiBpbW1lZGlhdGVseS5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb258bnVsbH0gcGFzc2l2ZUxpc3RlbmVyIFRoZSBsaXN0ZW5lciBpZiB0aGUgY3VycmVudCBsaXN0ZW5lciBpcyBwYXNzaXZlLiBPdGhlcndpc2UgdGhpcyBpcyBudWxsLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVTdGFtcCBUaGUgdW5peCB0aW1lLlxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIFByaXZhdGUgZGF0YSBmb3IgZXZlbnQgd3JhcHBlcnMuXG4gKiBAdHlwZSB7V2Vha01hcDxFdmVudCwgUHJpdmF0ZURhdGE+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgcHJpdmF0ZURhdGEgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIENhY2hlIGZvciB3cmFwcGVyIGNsYXNzZXMuXG4gKiBAdHlwZSB7V2Vha01hcDxPYmplY3QsIEZ1bmN0aW9uPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHdyYXBwZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBHZXQgcHJpdmF0ZSBkYXRhLlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCB0byBnZXQgcHJpdmF0ZSBkYXRhLlxuICogQHJldHVybnMge1ByaXZhdGVEYXRhfSBUaGUgcHJpdmF0ZSBkYXRhIG9mIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBkKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0diA9IHByaXZhdGVEYXRhLmdldChldmVudCk7XG4gICAgY29uc29sZS5hc3NlcnQocmV0diAhPSBudWxsLCBcIid0aGlzJyBpcyBleHBlY3RlZCBhbiBFdmVudCBvYmplY3QsIGJ1dCBnb3RcIiwgZXZlbnQpO1xuICAgIHJldHVybiByZXR2XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS1ldmVudFxuICogQHByaXZhdGVcbiAqL1xuLyoqXG4gKiBUaGUgZXZlbnQgd3JhcHBlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCBvZiB0aGlzIGRpc3BhdGNoaW5nLlxuICogQHBhcmFtIHtFdmVudHx7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgb3JpZ2luYWwgZXZlbnQgdG8gd3JhcC5cbiAqL1xuZnVuY3Rpb24gRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgcHJpdmF0ZURhdGEuc2V0KHRoaXMsIHtcbiAgICAgICAgZXZlbnRUYXJnZXQsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBldmVudFBoYXNlOiAyLFxuICAgICAgICBjdXJyZW50VGFyZ2V0OiBldmVudFRhcmdldCxcbiAgICAgICAgY2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgICBzdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgcGFzc2l2ZUxpc3RlbmVyOiBudWxsLFxuICAgICAgICB0aW1lU3RhbXA6IGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpLFxuICAgIH0pO1xuXG4gICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jVW5mb3JnZWFibGVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc1RydXN0ZWRcIiwgeyB2YWx1ZTogZmFsc2UsIGVudW1lcmFibGU6IHRydWUgfSk7XG5cbiAgICAvLyBEZWZpbmUgYWNjZXNzb3JzXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCBkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3Ioa2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFNob3VsZCBiZSBlbnVtZXJhYmxlLCBidXQgY2xhc3MgbWV0aG9kcyBhcmUgbm90IGVudW1lcmFibGUuXG5FdmVudC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnQudHlwZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fVxuICAgICAqL1xuICAgIGdldCB0YXJnZXQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGFyZ2V0IG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fVxuICAgICAqL1xuICAgIGdldCBjdXJyZW50VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuY3VycmVudFRhcmdldFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRUYXJnZXRbXX0gVGhlIGNvbXBvc2VkIHBhdGggb2YgdGhpcyBldmVudC5cbiAgICAgKi9cbiAgICBjb21wb3NlZFBhdGgoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXQgPSBwZCh0aGlzKS5jdXJyZW50VGFyZ2V0O1xuICAgICAgICBpZiAoY3VycmVudFRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2N1cnJlbnRUYXJnZXRdXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IG9mIE5PTkUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgTk9ORSgpIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgb2YgQ0FQVFVSSU5HX1BIQVNFLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IENBUFRVUklOR19QSEFTRSgpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgb2YgQVRfVEFSR0VULlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IEFUX1RBUkdFVCgpIHtcbiAgICAgICAgcmV0dXJuIDJcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgb2YgQlVCQkxJTkdfUEhBU0UuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQlVCQkxJTkdfUEhBU0UoKSB7XG4gICAgICAgIHJldHVybiAzXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBldmVudFBoYXNlKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRQaGFzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGV2ZW50IGJ1YmJsaW5nLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHBkKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQuc3RvcFByb3BhZ2F0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKTtcblxuICAgICAgICBkYXRhLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGRhdGEuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gYmUgYnViYmxpbmcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGJ1YmJsZXMoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmJ1YmJsZXMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGNhbmNlbGFibGUuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBkKHRoaXMpLmV2ZW50LmNhbmNlbGFibGUpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbmNlbCB0aGlzIGV2ZW50LlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcyk7XG4gICAgICAgIGlmIChkYXRhLnBhc3NpdmVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFdmVudCNwcmV2ZW50RGVmYXVsdCgpIHdhcyBjYWxsZWQgZnJvbSBhIHBhc3NpdmUgbGlzdGVuZXI6XCIsIGRhdGEucGFzc2l2ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YS5ldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEuZXZlbnQucHJldmVudERlZmF1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZGF0YS5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGluZGljYXRlIGNhbmNlbGxhdGlvbiBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgZGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmNhbmNlbGVkXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmbGFnIHRvIGJlIGNvbXBvc2VkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjb21wb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuY29tcG9zZWQpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB1bml4IHRpbWUgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB0aW1lU3RhbXAoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS50aW1lU3RhbXBcbiAgICB9LFxufTtcblxuLy8gYGNvbnN0cnVjdG9yYCBpcyBub3QgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogRXZlbnQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG5cbi8vIEVuc3VyZSBgZXZlbnQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnRgIGlzIGB0cnVlYC5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuRXZlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnQucHJvdG90eXBlLCB3aW5kb3cuRXZlbnQucHJvdG90eXBlKTtcblxuICAgIC8vIE1ha2UgYXNzb2NpYXRpb24gZm9yIHdyYXBwZXJzLlxuICAgIHdyYXBwZXJzLnNldCh3aW5kb3cuRXZlbnQucHJvdG90eXBlLCBFdmVudCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIHJlZGlyZWN0IGEgZ2l2ZW4gcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFByb3BlcnR5IG5hbWUgdG8gZGVmaW5lIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7UHJvcGVydHlEZXNjcmlwdG9yfSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byByZWRpcmVjdCB0aGUgcHJvcGVydHkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3Ioa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50W2tleV1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICBwZCh0aGlzKS5ldmVudFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGNhbGwgYSBnaXZlbiBtZXRob2QgcHJvcGVydHkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFByb3BlcnR5IG5hbWUgdG8gZGVmaW5lIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7UHJvcGVydHlEZXNjcmlwdG9yfSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byBjYWxsIHRoZSBtZXRob2QgcHJvcGVydHkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVDYWxsRGVzY3JpcHRvcihrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gcGQodGhpcykuZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRba2V5XS5hcHBseShldmVudCwgYXJndW1lbnRzKVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSBuZXcgd3JhcHBlciBjbGFzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IEJhc2VFdmVudCBUaGUgYmFzZSB3cmFwcGVyIGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBwcm90b3R5cGUgb2YgdGhlIG9yaWdpbmFsIGV2ZW50LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgZGVmaW5lZCB3cmFwcGVyIGNsYXNzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmaW5lV3JhcHBlcihCYXNlRXZlbnQsIHByb3RvKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3RvKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJhc2VFdmVudFxuICAgIH1cblxuICAgIC8qKiBDdXN0b21FdmVudCAqL1xuICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50VGFyZ2V0LCBldmVudCkge1xuICAgICAgICBCYXNlRXZlbnQuY2FsbCh0aGlzLCBldmVudFRhcmdldCwgZXZlbnQpO1xuICAgIH1cblxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUV2ZW50LnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogQ3VzdG9tRXZlbnQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICB9KTtcblxuICAgIC8vIERlZmluZSBhY2Nlc3NvcnMuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghKGtleSBpbiBCYXNlRXZlbnQucHJvdG90eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGtleSk7XG4gICAgICAgICAgICBjb25zdCBpc0Z1bmMgPSAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIik7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgICAgICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBpc0Z1bmMgPyBkZWZpbmVDYWxsRGVzY3JpcHRvcihrZXkpIDogZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGtleSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ3VzdG9tRXZlbnRcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdyYXBwZXIgY2xhc3Mgb2YgYSBnaXZlbiBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIHByb3RvdHlwZSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQgdG8gZ2V0IGl0cyB3cmFwcGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBUaGUgd3JhcHBlciBjbGFzcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFdyYXBwZXIocHJvdG8pIHtcbiAgICBpZiAocHJvdG8gPT0gbnVsbCB8fCBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICByZXR1cm4gRXZlbnRcbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlciA9IHdyYXBwZXJzLmdldChwcm90byk7XG4gICAgaWYgKHdyYXBwZXIgPT0gbnVsbCkge1xuICAgICAgICB3cmFwcGVyID0gZGVmaW5lV3JhcHBlcihnZXRXcmFwcGVyKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpLCBwcm90byk7XG4gICAgICAgIHdyYXBwZXJzLnNldChwcm90bywgd3JhcHBlcik7XG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVyXG59XG5cbi8qKlxuICogV3JhcCBhIGdpdmVuIGV2ZW50IHRvIG1hbmFnZW1lbnQgYSBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQgb2YgdGhpcyBkaXNwYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgZXZlbnQgdG8gd3JhcC5cbiAqIEByZXR1cm5zIHtFdmVudH0gVGhlIHdyYXBwZXIgaW5zdGFuY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB3cmFwRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgY29uc3QgV3JhcHBlciA9IGdldFdyYXBwZXIoT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSk7XG4gICAgcmV0dXJuIG5ldyBXcmFwcGVyKGV2ZW50VGFyZ2V0LCBldmVudClcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHN0b3BwZWQgZmxhZyBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGdldC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uIGltbWVkaWF0ZWx5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTdG9wcGVkKGV2ZW50KSB7XG4gICAgcmV0dXJuIHBkKGV2ZW50KS5zdG9wcGVkXG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IGV2ZW50IHBoYXNlIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gc2V0IGN1cnJlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50UGhhc2UgTmV3IGV2ZW50IHBoYXNlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRFdmVudFBoYXNlKGV2ZW50LCBldmVudFBoYXNlKSB7XG4gICAgcGQoZXZlbnQpLmV2ZW50UGhhc2UgPSBldmVudFBoYXNlO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCB0YXJnZXQgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBzZXQgY3VycmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fG51bGx9IGN1cnJlbnRUYXJnZXQgTmV3IGN1cnJlbnQgdGFyZ2V0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRDdXJyZW50VGFyZ2V0KGV2ZW50LCBjdXJyZW50VGFyZ2V0KSB7XG4gICAgcGQoZXZlbnQpLmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xufVxuXG4vKipcbiAqIFNldCBhIHBhc3NpdmUgbGlzdGVuZXIgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBzZXQgY3VycmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufG51bGx9IHBhc3NpdmVMaXN0ZW5lciBOZXcgcGFzc2l2ZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0UGFzc2l2ZUxpc3RlbmVyKGV2ZW50LCBwYXNzaXZlTGlzdGVuZXIpIHtcbiAgICBwZChldmVudCkucGFzc2l2ZUxpc3RlbmVyID0gcGFzc2l2ZUxpc3RlbmVyO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IExpc3RlbmVyTm9kZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAqIEBwcm9wZXJ0eSB7MXwyfDN9IGxpc3RlbmVyVHlwZVxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXNzaXZlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9uY2VcbiAqIEBwcm9wZXJ0eSB7TGlzdGVuZXJOb2RlfG51bGx9IG5leHRcbiAqIEBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7V2Vha01hcDxvYmplY3QsIE1hcDxzdHJpbmcsIExpc3RlbmVyTm9kZT4+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgbGlzdGVuZXJzTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gTGlzdGVuZXIgdHlwZXNcbmNvbnN0IENBUFRVUkUgPSAxO1xuY29uc3QgQlVCQkxFID0gMjtcbmNvbnN0IEFUVFJJQlVURSA9IDM7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdCBvciBub3QuXG4gKiBAcGFyYW0ge2FueX0geCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbn1cblxuLyoqXG4gKiBHZXQgbGlzdGVuZXJzLlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCB0byBnZXQuXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgTGlzdGVuZXJOb2RlPn0gVGhlIGxpc3RlbmVycy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldExpc3RlbmVycyhldmVudFRhcmdldCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IGxpc3RlbmVyc01hcC5nZXQoZXZlbnRUYXJnZXQpO1xuICAgIGlmIChsaXN0ZW5lcnMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50VGFyZ2V0IG9iamVjdCwgYnV0IGdvdCBhbm90aGVyIHZhbHVlLlwiKVxuICAgIH1cbiAgICByZXR1cm4gbGlzdGVuZXJzXG59XG5cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciB0aGUgZXZlbnQgYXR0cmlidXRlIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGdldCBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge1Byb3BlcnR5RGVzY3JpcHRvcn0gVGhlIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZURlc2NyaXB0b3IoZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBsaXN0ZW5lcnMuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXJUeXBlID09PSBBVFRSSUJVVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubGlzdGVuZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0KGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIgJiYgIWlzT2JqZWN0KGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBUcmF2ZXJzZSB0byB0aGUgdGFpbCB3aGlsZSByZW1vdmluZyBvbGQgdmFsdWUuXG4gICAgICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5saXN0ZW5lclR5cGUgPT09IEFUVFJJQlVURSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb2xkIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5vZGUubmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBuZXcgdmFsdWUuXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcixcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJUeXBlOiBBVFRSSUJVVEUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvbmNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBuZXdOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5ld05vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgfVxufVxuXG4vKipcbiAqIERlZmluZSBhbiBldmVudCBhdHRyaWJ1dGUgKGUuZy4gYGV2ZW50VGFyZ2V0Lm9uY2xpY2tgKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFRhcmdldFByb3RvdHlwZSBUaGUgZXZlbnQgdGFyZ2V0IHByb3RvdHlwZSB0byBkZWZpbmUgYW4gZXZlbnQgYXR0cmJpdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGRlZmluZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZShldmVudFRhcmdldFByb3RvdHlwZSwgZXZlbnROYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50VGFyZ2V0UHJvdG90eXBlLCBgb24ke2V2ZW50TmFtZX1gLCBkZWZpbmVFdmVudEF0dHJpYnV0ZURlc2NyaXB0b3IoZXZlbnROYW1lKSk7XG59XG5cbi8qKlxuICogRGVmaW5lIGEgY3VzdG9tIEV2ZW50VGFyZ2V0IHdpdGggZXZlbnQgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGV2ZW50TmFtZXMgRXZlbnQgbmFtZXMgZm9yIGV2ZW50IGF0dHJpYnV0ZXMuXG4gKiBAcmV0dXJucyB7RXZlbnRUYXJnZXR9IFRoZSBjdXN0b20gRXZlbnRUYXJnZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FdmVudFRhcmdldChldmVudE5hbWVzKSB7XG4gICAgLyoqIEN1c3RvbUV2ZW50VGFyZ2V0ICovXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgQ3VzdG9tRXZlbnRUYXJnZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudFRhcmdldC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IEN1c3RvbUV2ZW50VGFyZ2V0LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgfSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZGVmaW5lRXZlbnRBdHRyaWJ1dGUoQ3VzdG9tRXZlbnRUYXJnZXQucHJvdG90eXBlLCBldmVudE5hbWVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ3VzdG9tRXZlbnRUYXJnZXRcbn1cblxuLyoqXG4gKiBFdmVudFRhcmdldC5cbiAqXG4gKiAtIFRoaXMgaXMgY29uc3RydWN0b3IgaWYgbm8gYXJndW1lbnRzLlxuICogLSBUaGlzIGlzIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIEN1c3RvbUV2ZW50VGFyZ2V0IGNvbnN0cnVjdG9yIGlmIHRoZXJlIGFyZSBhcmd1bWVudHMuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIGNsYXNzIEEgZXh0ZW5kcyBFdmVudFRhcmdldCB7fVxuICogICAgIGNsYXNzIEIgZXh0ZW5kcyBFdmVudFRhcmdldChcIm1lc3NhZ2VcIikge31cbiAqICAgICBjbGFzcyBDIGV4dGVuZHMgRXZlbnRUYXJnZXQoXCJtZXNzYWdlXCIsIFwiZXJyb3JcIikge31cbiAqICAgICBjbGFzcyBEIGV4dGVuZHMgRXZlbnRUYXJnZXQoW1wibWVzc2FnZVwiLCBcImVycm9yXCJdKSB7fVxuICovXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtcmV0dXJuICovXG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBFdmVudFRhcmdldCkge1xuICAgICAgICBsaXN0ZW5lcnNNYXAuc2V0KHRoaXMsIG5ldyBNYXAoKSk7XG4gICAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KGFyZ3VtZW50c1swXSlcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdHlwZXNbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KHR5cGVzKVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpXG4gICAgLyplc2xpbnQtZW5hYmxlIGNvbnNpc3RlbnQtcmV0dXJuICovXG59XG5cbi8vIFNob3VsZCBiZSBlbnVtZXJhYmxlLCBidXQgY2xhc3MgbWV0aG9kcyBhcmUgbm90IGVudW1lcmFibGUuXG5FdmVudFRhcmdldC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQWRkIGEgZ2l2ZW4gbGlzdGVuZXIgdG8gdGhpcyBldmVudCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byBhZGQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58e2NhcHR1cmU/OmJvb2xlYW4scGFzc2l2ZT86Ym9vbGVhbixvbmNlPzpib29sZWFufX0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGlzIGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGxpc3RlbmVyIHdhcyBhZGRlZCBhY3R1YWxseS5cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIiAmJiAhaXNPYmplY3QobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2xpc3RlbmVyJyBzaG91bGQgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QuXCIpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNJc09iaiA9IGlzT2JqZWN0KG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYXB0dXJlID0gb3B0aW9uc0lzT2JqID8gQm9vbGVhbihvcHRpb25zLmNhcHR1cmUpIDogQm9vbGVhbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJUeXBlID0gKGNhcHR1cmUgPyBDQVBUVVJFIDogQlVCQkxFKTtcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgbGlzdGVuZXJUeXBlLFxuICAgICAgICAgICAgcGFzc2l2ZTogb3B0aW9uc0lzT2JqICYmIEJvb2xlYW4ob3B0aW9ucy5wYXNzaXZlKSxcbiAgICAgICAgICAgIG9uY2U6IG9wdGlvbnNJc09iaiAmJiBCb29sZWFuKG9wdGlvbnMub25jZSksXG4gICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBpdCBhcyB0aGUgZmlyc3Qgbm9kZSBpZiB0aGUgZmlyc3Qgbm9kZSBpcyBudWxsLlxuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5ld05vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYXZlcnNlIHRvIHRoZSB0YWlsIHdoaWxlIGNoZWNraW5nIGR1cGxpY2F0aW9uLi5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiYgbm9kZS5saXN0ZW5lclR5cGUgPT09IGxpc3RlbmVyVHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBpZ25vcmUgZHVwbGljYXRpb24uXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgaXQuXG4gICAgICAgIHByZXYubmV4dCA9IG5ld05vZGU7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGdpdmVuIGxpc3RlbmVyIGZyb20gdGhpcyBldmVudCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58e2NhcHR1cmU/OmJvb2xlYW4scGFzc2l2ZT86Ym9vbGVhbixvbmNlPzpib29sZWFufX0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGlzIGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkIGFjdHVhbGx5LlxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIGNvbnN0IGNhcHR1cmUgPSBpc09iamVjdChvcHRpb25zKSA/IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKSA6IEJvb2xlYW4ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyVHlwZSA9IChjYXB0dXJlID8gQ0FQVFVSRSA6IEJVQkJMRSk7XG5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGlzdGVuZXIgPT09IGxpc3RlbmVyICYmIG5vZGUubGlzdGVuZXJUeXBlID09PSBsaXN0ZW5lclR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbm9kZS5uZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGEgZ2l2ZW4gZXZlbnQuXG4gICAgICogQHBhcmFtIHtFdmVudHx7dHlwZTpzdHJpbmd9fSBldmVudCBUaGUgZXZlbnQgdG8gZGlzcGF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGBmYWxzZWAgaWYgY2FuY2VsZWQuXG4gICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkgeyAvL2VzbGludC1kaXNhYmxlLWxpbmUgY29tcGxleGl0eVxuICAgICAgICBpZiAoZXZlbnQgPT0gbnVsbCB8fCB0eXBlb2YgZXZlbnQudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlxcXCJldmVudC50eXBlXFxcIiBzaG91bGQgYmUgYSBzdHJpbmcuXCIpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBsaXN0ZW5lcnMgYXJlbid0IHJlZ2lzdGVyZWQsIHRlcm1pbmF0ZS5cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBldmVudC50eXBlO1xuICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmNlIHdlIGNhbm5vdCByZXdyaXRlIHNldmVyYWwgcHJvcGVydGllcywgc28gd3JhcCBvYmplY3QuXG4gICAgICAgIGNvbnN0IHdyYXBwZWRFdmVudCA9IHdyYXBFdmVudCh0aGlzLCBldmVudCk7XG5cbiAgICAgICAgLy8gVGhpcyBkb2Vzbid0IHByb2Nlc3MgY2FwdHVyaW5nIHBoYXNlIGFuZCBidWJibGluZyBwaGFzZS5cbiAgICAgICAgLy8gVGhpcyBpc24ndCBwYXJ0aWNpcGF0aW5nIGluIGEgdHJlZS5cbiAgICAgICAgbGV0IHByZXYgPSBudWxsO1xuICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBsaXN0ZW5lciBpZiBpdCdzIG9uY2VcbiAgICAgICAgICAgIGlmIChub2RlLm9uY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbm9kZS5uZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsbCB0aGlzIGxpc3RlbmVyXG4gICAgICAgICAgICBzZXRQYXNzaXZlTGlzdGVuZXIod3JhcHBlZEV2ZW50LCAobm9kZS5wYXNzaXZlID8gbm9kZS5saXN0ZW5lciA6IG51bGwpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5saXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5saXN0ZW5lci5jYWxsKHRoaXMsIHdyYXBwZWRFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLyplc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyplc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLmxpc3RlbmVyVHlwZSAhPT0gQVRUUklCVVRFICYmIHR5cGVvZiBub2RlLmxpc3RlbmVyLmhhbmRsZUV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyLmhhbmRsZUV2ZW50KHdyYXBwZWRFdmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEJyZWFrIGlmIGBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25gIHdhcyBjYWxsZWQuXG4gICAgICAgICAgICBpZiAoaXNTdG9wcGVkKHdyYXBwZWRFdmVudCkpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHNldFBhc3NpdmVMaXN0ZW5lcih3cmFwcGVkRXZlbnQsIG51bGwpO1xuICAgICAgICBzZXRFdmVudFBoYXNlKHdyYXBwZWRFdmVudCwgMCk7XG4gICAgICAgIHNldEN1cnJlbnRUYXJnZXQod3JhcHBlZEV2ZW50LCBudWxsKTtcblxuICAgICAgICByZXR1cm4gIXdyYXBwZWRFdmVudC5kZWZhdWx0UHJldmVudGVkXG4gICAgfSxcbn07XG5cbi8vIGBjb25zdHJ1Y3RvcmAgaXMgbm90IGVudW1lcmFibGUuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRUYXJnZXQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEV2ZW50VGFyZ2V0LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuXG4vLyBFbnN1cmUgYGV2ZW50VGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50VGFyZ2V0YCBpcyBgdHJ1ZWAuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LkV2ZW50VGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZSk7XG59XG5cbmV4cG9ydHMuZGVmaW5lRXZlbnRBdHRyaWJ1dGUgPSBkZWZpbmVFdmVudEF0dHJpYnV0ZTtcbmV4cG9ydHMuRXZlbnRUYXJnZXQgPSBFdmVudFRhcmdldDtcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50VGFyZ2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0XG5tb2R1bGUuZXhwb3J0cy5FdmVudFRhcmdldCA9IG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEV2ZW50VGFyZ2V0XG5tb2R1bGUuZXhwb3J0cy5kZWZpbmVFdmVudEF0dHJpYnV0ZSA9IGRlZmluZUV2ZW50QXR0cmlidXRlXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudC10YXJnZXQtc2hpbS5qcy5tYXBcbiIsIi8vIG9yaWdpbmFsbHkgcHVsbGVkIG91dCBvZiBzaW1wbGUtcGVlclxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEJyb3dzZXJSVEMgKCkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbFxuICB2YXIgd3J0YyA9IHtcbiAgICBSVENQZWVyQ29ubmVjdGlvbjogZ2xvYmFsVGhpcy5SVENQZWVyQ29ubmVjdGlvbiB8fCBnbG9iYWxUaGlzLm1velJUQ1BlZXJDb25uZWN0aW9uIHx8XG4gICAgICBnbG9iYWxUaGlzLndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLFxuICAgIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbjogZ2xvYmFsVGhpcy5SVENTZXNzaW9uRGVzY3JpcHRpb24gfHxcbiAgICAgIGdsb2JhbFRoaXMubW96UlRDU2Vzc2lvbkRlc2NyaXB0aW9uIHx8IGdsb2JhbFRoaXMud2Via2l0UlRDU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICAgIFJUQ0ljZUNhbmRpZGF0ZTogZ2xvYmFsVGhpcy5SVENJY2VDYW5kaWRhdGUgfHwgZ2xvYmFsVGhpcy5tb3pSVENJY2VDYW5kaWRhdGUgfHxcbiAgICAgIGdsb2JhbFRoaXMud2Via2l0UlRDSWNlQ2FuZGlkYXRlXG4gIH1cbiAgaWYgKCF3cnRjLlJUQ1BlZXJDb25uZWN0aW9uKSByZXR1cm4gbnVsbFxuICByZXR1cm4gd3J0Y1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbCl7XG5cbiAgICB2YXIgaWRzID0ge307XG5cbiAgICBpZignc3RyaW5nJyA9PSB0eXBlb2YgZWwpIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwpO1xuXG4gICAgaWYoIWVsKSBlbCA9IGRvY3VtZW50O1xuXG4gICAgdmFyIGNoaWxkcmVuID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcblxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoY2hpbGRyZW4sIGZ1bmN0aW9uKGUpe1xuXG5cdGlmKGUuaWQubGVuZ3RoID4gMCl7XG5cblx0ICAgIGlkc1tlLmlkXSA9IGVcblxuXHR9XG5cbiAgICB9KVxuXG4gICAgcmV0dXJuIGlkc1xuXG59XG4iLCIvLyBnZXRVc2VyTWVkaWEgaGVscGVyIGJ5IEBIZW5yaWtKb3JldGVnIHVzZWQgZm9yIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgc2hpbVxudmFyIGFkYXB0ZXIgPSByZXF1aXJlKCd3ZWJydGMtYWRhcHRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cywgY2IpIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgdmFyIGhhdmVPcHRzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMjtcbiAgICB2YXIgZGVmYXVsdE9wdHMgPSB7dmlkZW86IHRydWUsIGF1ZGlvOiB0cnVlfTtcblxuICAgIHZhciBkZW5pZWQgPSAnUGVybWlzc2lvbkRlbmllZEVycm9yJztcbiAgICB2YXIgYWx0RGVuaWVkID0gJ1BFUk1JU1NJT05fREVOSUVEJztcbiAgICB2YXIgbm90U2F0aXNmaWVkID0gJ0NvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvcic7XG5cbiAgICAvLyBtYWtlIGNvbnN0cmFpbnRzIG9wdGlvbmFsXG4gICAgaWYgKCFoYXZlT3B0cykge1xuICAgICAgICBjYiA9IGNvbnN0cmFpbnRzO1xuICAgICAgICBjb25zdHJhaW50cyA9IGRlZmF1bHRPcHRzO1xuICAgIH1cblxuICAgIC8vIHRyZWF0IGxhY2sgb2YgYnJvd3NlciBzdXBwb3J0IGxpa2UgYW4gZXJyb3JcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci5tZWRpYURldmljZXMpeyAvL2dldFVzZXJNZWRpYSkge1xuICAgICAgICAvLyB0aHJvdyBwcm9wZXIgZXJyb3IgcGVyIHNwZWNcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01lZGlhU3RyZWFtRXJyb3InKTtcbiAgICAgICAgZXJyb3IubmFtZSA9ICdOb3RTdXBwb3J0ZWRFcnJvcic7XG5cbiAgICAgICAgLy8ga2VlcCBhbGwgY2FsbGJhY2tzIGFzeW5jXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXplIGVycm9yIGhhbmRsaW5nIHdoZW4gbm8gbWVkaWEgdHlwZXMgYXJlIHJlcXVlc3RlZFxuICAgIGlmICghY29uc3RyYWludHMuYXVkaW8gJiYgIWNvbnN0cmFpbnRzLnZpZGVvKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNZWRpYVN0cmVhbUVycm9yJyk7XG4gICAgICAgIGVycm9yLm5hbWUgPSAnTm9NZWRpYVJlcXVlc3RlZEVycm9yJztcblxuICAgICAgICAvLyBrZWVwIGFsbCBjYWxsYmFja3MgYXN5bmNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgICAudGhlbihmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIGNiKG51bGwsIHN0cmVhbSk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIGNvZXJjZSBpbnRvIGFuIGVycm9yIG9iamVjdCBzaW5jZSBGRiBnaXZlcyB1cyBhIHN0cmluZ1xuICAgICAgICAvLyB0aGVyZSBhcmUgb25seSB0d28gdmFsaWQgbmFtZXMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjXG4gICAgICAgIC8vIHdlIGNvZXJjZSBhbGwgbm9uLWRlbmllZCB0byBcImNvbnN0cmFpbnQgbm90IHNhdGlzZmllZFwiLlxuICAgICAgICBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNZWRpYVN0cmVhbUVycm9yJyk7XG4gICAgICAgICAgICBpZiAoZXJyID09PSBkZW5pZWQgfHwgZXJyID09PSBhbHREZW5pZWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gZGVuaWVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvci5uYW1lID0gbm90U2F0aXNmaWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgd2UgZ2V0IGFuIGVycm9yIG9iamVjdCBtYWtlIHN1cmUgJy5uYW1lJyBwcm9wZXJ0eSBpcyBzZXRcbiAgICAgICAgICAgIC8vIGFjY29yZGluZyB0byBzcGVjOiBodHRwOi8vZGV2LnczLm9yZy8yMDExL3dlYnJ0Yy9lZGl0b3IvZ2V0dXNlcm1lZGlhLmh0bWwjbmF2aWdhdG9ydXNlcm1lZGlhZXJyb3ItYW5kLW5hdmlnYXRvcnVzZXJtZWRpYWVycm9yY2FsbGJhY2tcbiAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgaWYgKCFlcnJvci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBsaWtlbHkgY2hyb21lIHdoaWNoXG4gICAgICAgICAgICAgICAgLy8gc2V0cyBhIHByb3BlcnR5IGNhbGxlZCBcIkVSUk9SX0RFTklFRFwiIG9uIHRoZSBlcnJvciBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBpZiBzbyB3ZSBtYWtlIHN1cmUgdG8gc2V0IGEgbmFtZVxuICAgICAgICAgICAgICAgIGlmIChlcnJvcltkZW5pZWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyci5uYW1lID0gZGVuaWVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVyci5uYW1lID0gbm90U2F0aXNmaWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICB9KTtcbn07XG4iLCJ2YXIgc3BsaXQgPSByZXF1aXJlKCdicm93c2VyLXNwbGl0JylcbnZhciBDbGFzc0xpc3QgPSByZXF1aXJlKCdjbGFzcy1saXN0JylcblxudmFyIHcgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoJ2h0bWwtZWxlbWVudCcpIDogd2luZG93XG52YXIgZG9jdW1lbnQgPSB3LmRvY3VtZW50XG52YXIgVGV4dCA9IHcuVGV4dFxuXG5mdW5jdGlvbiBjb250ZXh0ICgpIHtcblxuICB2YXIgY2xlYW51cEZ1bmNzID0gW11cblxuICBmdW5jdGlvbiBoKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLCBlID0gbnVsbFxuICAgIGZ1bmN0aW9uIGl0ZW0gKGwpIHtcbiAgICAgIHZhciByXG4gICAgICBmdW5jdGlvbiBwYXJzZUNsYXNzIChzdHJpbmcpIHtcbiAgICAgICAgLy8gT3VyIG1pbmltYWwgcGFyc2VyIGRvZXNu4oCZdCB1bmRlcnN0YW5kIGVzY2FwaW5nIENTUyBzcGVjaWFsXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgbGlrZSBgI2AuIERvbuKAmXQgdXNlIHRoZW0uIE1vcmUgcmVhZGluZzpcbiAgICAgICAgLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2Nzcy1lc2NhcGVzIC5cblxuICAgICAgICB2YXIgbSA9IHNwbGl0KHN0cmluZywgLyhbXFwuI10/W15cXHMjLl0rKS8pXG4gICAgICAgIGlmKC9eXFwufCMvLnRlc3QobVsxXSkpXG4gICAgICAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGZvckVhY2gobSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICB2YXIgcyA9IHYuc3Vic3RyaW5nKDEsdi5sZW5ndGgpXG4gICAgICAgICAgaWYoIXYpIHJldHVyblxuICAgICAgICAgIGlmKCFlKVxuICAgICAgICAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodilcbiAgICAgICAgICBlbHNlIGlmICh2WzBdID09PSAnLicpXG4gICAgICAgICAgICBDbGFzc0xpc3QoZSkuYWRkKHMpXG4gICAgICAgICAgZWxzZSBpZiAodlswXSA9PT0gJyMnKVxuICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoJ2lkJywgcylcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYobCA9PSBudWxsKVxuICAgICAgICA7XG4gICAgICBlbHNlIGlmKCdzdHJpbmcnID09PSB0eXBlb2YgbCkge1xuICAgICAgICBpZighZSlcbiAgICAgICAgICBwYXJzZUNsYXNzKGwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlLmFwcGVuZENoaWxkKHIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsKSlcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoJ251bWJlcicgPT09IHR5cGVvZiBsXG4gICAgICAgIHx8ICdib29sZWFuJyA9PT0gdHlwZW9mIGxcbiAgICAgICAgfHwgbCBpbnN0YW5jZW9mIERhdGVcbiAgICAgICAgfHwgbCBpbnN0YW5jZW9mIFJlZ0V4cCApIHtcbiAgICAgICAgICBlLmFwcGVuZENoaWxkKHIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsLnRvU3RyaW5nKCkpKVxuICAgICAgfVxuICAgICAgLy90aGVyZSBtaWdodCBiZSBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXkobCkpXG4gICAgICAgIGZvckVhY2gobCwgaXRlbSlcbiAgICAgIGVsc2UgaWYoaXNOb2RlKGwpKVxuICAgICAgICBlLmFwcGVuZENoaWxkKHIgPSBsKVxuICAgICAgZWxzZSBpZihsIGluc3RhbmNlb2YgVGV4dClcbiAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gbClcbiAgICAgIGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgbCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGwpIHtcbiAgICAgICAgICBpZignZnVuY3Rpb24nID09PSB0eXBlb2YgbFtrXSkge1xuICAgICAgICAgICAgaWYoL15vblxcdysvLnRlc3QoaykpIHtcbiAgICAgICAgICAgICAgKGZ1bmN0aW9uIChrLCBsKSB7IC8vIGNhcHR1cmUgaywgbCBpbiB0aGUgY2xvc3VyZVxuICAgICAgICAgICAgICAgIGlmIChlLmFkZEV2ZW50TGlzdGVuZXIpe1xuICAgICAgICAgICAgICAgICAgZS5hZGRFdmVudExpc3RlbmVyKGsuc3Vic3RyaW5nKDIpLCBsW2tdLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihrLnN1YnN0cmluZygyKSwgbFtrXSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgZS5hdHRhY2hFdmVudChrLCBsW2tdKVxuICAgICAgICAgICAgICAgICAgY2xlYW51cEZ1bmNzLnB1c2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgZS5kZXRhY2hFdmVudChrLCBsW2tdKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKGssIGwpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBvYnNlcnZhYmxlXG4gICAgICAgICAgICAgIGVba10gPSBsW2tdKClcbiAgICAgICAgICAgICAgY2xlYW51cEZ1bmNzLnB1c2gobFtrXShmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGVba10gPSB2XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKGsgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIGlmKCdzdHJpbmcnID09PSB0eXBlb2YgbFtrXSkge1xuICAgICAgICAgICAgICBlLnN0eWxlLmNzc1RleHQgPSBsW2tdXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgZm9yICh2YXIgcyBpbiBsW2tdKSAoZnVuY3Rpb24ocywgdikge1xuICAgICAgICAgICAgICAgIGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiB2KSB7XG4gICAgICAgICAgICAgICAgICAvLyBvYnNlcnZhYmxlXG4gICAgICAgICAgICAgICAgICBlLnN0eWxlLnNldFByb3BlcnR5KHMsIHYoKSlcbiAgICAgICAgICAgICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKHYoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0eWxlLnNldFByb3BlcnR5KHMsIHZhbClcbiAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbFtrXVtzXS5tYXRjaCgvKC4qKVxcVyshaW1wb3J0YW50XFxXKiQvKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBlLnN0eWxlLnNldFByb3BlcnR5KHMsIG1hdGNoWzFdLCAnaW1wb3J0YW50JylcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocywgbFtrXVtzXSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkocywgbFtrXVtzXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYoayA9PT0gJ2F0dHJzJykge1xuICAgICAgICAgICAgZm9yICh2YXIgdiBpbiBsW2tdKSB7XG4gICAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKHYsIGxba11bdl0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGsuc3Vic3RyKDAsIDUpID09PSBcImRhdGEtXCIpIHtcbiAgICAgICAgICAgIGUuc2V0QXR0cmlidXRlKGssIGxba10pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVba10gPSBsW2tdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBsKSB7XG4gICAgICAgIC8vYXNzdW1lIGl0J3MgYW4gb2JzZXJ2YWJsZSFcbiAgICAgICAgdmFyIHYgPSBsKClcbiAgICAgICAgZS5hcHBlbmRDaGlsZChyID0gaXNOb2RlKHYpID8gdiA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHYpKVxuXG4gICAgICAgIGNsZWFudXBGdW5jcy5wdXNoKGwoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBpZihpc05vZGUodikgJiYgci5wYXJlbnRFbGVtZW50KVxuICAgICAgICAgICAgci5wYXJlbnRFbGVtZW50LnJlcGxhY2VDaGlsZCh2LCByKSwgciA9IHZcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByLnRleHRDb250ZW50ID0gdlxuICAgICAgICB9KSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJcbiAgICB9XG4gICAgd2hpbGUoYXJncy5sZW5ndGgpXG4gICAgICBpdGVtKGFyZ3Muc2hpZnQoKSlcblxuICAgIHJldHVybiBlXG4gIH1cblxuICBoLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGVhbnVwRnVuY3MubGVuZ3RoOyBpKyspe1xuICAgICAgY2xlYW51cEZ1bmNzW2ldKClcbiAgICB9XG4gICAgY2xlYW51cEZ1bmNzLmxlbmd0aCA9IDBcbiAgfVxuXG4gIHJldHVybiBoXG59XG5cbnZhciBoID0gbW9kdWxlLmV4cG9ydHMgPSBjb250ZXh0KClcbmguY29udGV4dCA9IGNvbnRleHRcblxuZnVuY3Rpb24gaXNOb2RlIChlbCkge1xuICByZXR1cm4gZWwgJiYgZWwubm9kZU5hbWUgJiYgZWwubm9kZVR5cGVcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoYXJyLCBmbikge1xuICBpZiAoYXJyLmZvckVhY2gpIHJldHVybiBhcnIuZm9yRWFjaChmbilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGZuKGFycltpXSwgaSlcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nXG59XG5cblxuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3MsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBcbiAgICB2YXIgZmxhZ3MgPSB7IGJvb2xzIDoge30sIHN0cmluZ3MgOiB7fSwgdW5rbm93bkZuOiBudWxsIH07XG5cbiAgICBpZiAodHlwZW9mIG9wdHNbJ3Vua25vd24nXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmbGFncy51bmtub3duRm4gPSBvcHRzWyd1bmtub3duJ107XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzWydib29sZWFuJ10gPT09ICdib29sZWFuJyAmJiBvcHRzWydib29sZWFuJ10pIHtcbiAgICAgIGZsYWdzLmFsbEJvb2xzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgW10uY29uY2F0KG9wdHNbJ2Jvb2xlYW4nXSkuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIGZsYWdzLmJvb2xzW2tleV0gPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHZhciBhbGlhc2VzID0ge307XG4gICAgT2JqZWN0LmtleXMob3B0cy5hbGlhcyB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGFsaWFzZXNba2V5XSA9IFtdLmNvbmNhdChvcHRzLmFsaWFzW2tleV0pO1xuICAgICAgICBhbGlhc2VzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgYWxpYXNlc1t4XSA9IFtrZXldLmNvbmNhdChhbGlhc2VzW2tleV0uZmlsdGVyKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHggIT09IHk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgW10uY29uY2F0KG9wdHMuc3RyaW5nKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGZsYWdzLnN0cmluZ3Nba2V5XSA9IHRydWU7XG4gICAgICAgIGlmIChhbGlhc2VzW2tleV0pIHtcbiAgICAgICAgICAgIGZsYWdzLnN0cmluZ3NbYWxpYXNlc1trZXldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgfSk7XG5cbiAgICB2YXIgZGVmYXVsdHMgPSBvcHRzWydkZWZhdWx0J10gfHwge307XG4gICAgXG4gICAgdmFyIGFyZ3YgPSB7IF8gOiBbXSB9O1xuICAgIE9iamVjdC5rZXlzKGZsYWdzLmJvb2xzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgc2V0QXJnKGtleSwgZGVmYXVsdHNba2V5XSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBkZWZhdWx0c1trZXldKTtcbiAgICB9KTtcbiAgICBcbiAgICB2YXIgbm90RmxhZ3MgPSBbXTtcblxuICAgIGlmIChhcmdzLmluZGV4T2YoJy0tJykgIT09IC0xKSB7XG4gICAgICAgIG5vdEZsYWdzID0gYXJncy5zbGljZShhcmdzLmluZGV4T2YoJy0tJykrMSk7XG4gICAgICAgIGFyZ3MgPSBhcmdzLnNsaWNlKDAsIGFyZ3MuaW5kZXhPZignLS0nKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXJnRGVmaW5lZChrZXksIGFyZykge1xuICAgICAgICByZXR1cm4gKGZsYWdzLmFsbEJvb2xzICYmIC9eLS1bXj1dKyQvLnRlc3QoYXJnKSkgfHxcbiAgICAgICAgICAgIGZsYWdzLnN0cmluZ3Nba2V5XSB8fCBmbGFncy5ib29sc1trZXldIHx8IGFsaWFzZXNba2V5XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRBcmcgKGtleSwgdmFsLCBhcmcpIHtcbiAgICAgICAgaWYgKGFyZyAmJiBmbGFncy51bmtub3duRm4gJiYgIWFyZ0RlZmluZWQoa2V5LCBhcmcpKSB7XG4gICAgICAgICAgICBpZiAoZmxhZ3MudW5rbm93bkZuKGFyZykgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSAhZmxhZ3Muc3RyaW5nc1trZXldICYmIGlzTnVtYmVyKHZhbClcbiAgICAgICAgICAgID8gTnVtYmVyKHZhbCkgOiB2YWxcbiAgICAgICAgO1xuICAgICAgICBzZXRLZXkoYXJndiwga2V5LnNwbGl0KCcuJyksIHZhbHVlKTtcbiAgICAgICAgXG4gICAgICAgIChhbGlhc2VzW2tleV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHNldEtleShhcmd2LCB4LnNwbGl0KCcuJyksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0S2V5IChvYmosIGtleXMsIHZhbHVlKSB7XG4gICAgICAgIHZhciBvID0gb2JqO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoLTE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG9ba2V5XSA9PT0gdW5kZWZpbmVkKSBvW2tleV0gPSB7fTtcbiAgICAgICAgICAgIGlmIChvW2tleV0gPT09IE9iamVjdC5wcm90b3R5cGUgfHwgb1trZXldID09PSBOdW1iZXIucHJvdG90eXBlXG4gICAgICAgICAgICAgICAgfHwgb1trZXldID09PSBTdHJpbmcucHJvdG90eXBlKSBvW2tleV0gPSB7fTtcbiAgICAgICAgICAgIGlmIChvW2tleV0gPT09IEFycmF5LnByb3RvdHlwZSkgb1trZXldID0gW107XG4gICAgICAgICAgICBvID0gb1trZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleSA9IGtleXNba2V5cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycpIHJldHVybjtcbiAgICAgICAgaWYgKG8gPT09IE9iamVjdC5wcm90b3R5cGUgfHwgbyA9PT0gTnVtYmVyLnByb3RvdHlwZVxuICAgICAgICAgICAgfHwgbyA9PT0gU3RyaW5nLnByb3RvdHlwZSkgbyA9IHt9O1xuICAgICAgICBpZiAobyA9PT0gQXJyYXkucHJvdG90eXBlKSBvID0gW107XG4gICAgICAgIGlmIChvW2tleV0gPT09IHVuZGVmaW5lZCB8fCBmbGFncy5ib29sc1trZXldIHx8IHR5cGVvZiBvW2tleV0gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvW2tleV0pKSB7XG4gICAgICAgICAgICBvW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvW2tleV0gPSBbIG9ba2V5XSwgdmFsdWUgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBhbGlhc0lzQm9vbGVhbihrZXkpIHtcbiAgICAgIHJldHVybiBhbGlhc2VzW2tleV0uc29tZShmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBmbGFncy5ib29sc1t4XTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgXG4gICAgICAgIGlmICgvXi0tLis9Ly50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIC8vIFVzaW5nIFtcXHNcXFNdIGluc3RlYWQgb2YgLiBiZWNhdXNlIGpzIGRvZXNuJ3Qgc3VwcG9ydCB0aGVcbiAgICAgICAgICAgIC8vICdkb3RhbGwnIHJlZ2V4IG1vZGlmaWVyLiBTZWU6XG4gICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMDY4MzA4LzEzMjE2XG4gICAgICAgICAgICB2YXIgbSA9IGFyZy5tYXRjaCgvXi0tKFtePV0rKT0oW1xcc1xcU10qKSQvKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBtWzFdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbVsyXTtcbiAgICAgICAgICAgIGlmIChmbGFncy5ib29sc1trZXldKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gJ2ZhbHNlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEFyZyhrZXksIHZhbHVlLCBhcmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eLS1uby0uKy8udGVzdChhcmcpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gYXJnLm1hdGNoKC9eLS1uby0oLispLylbMV07XG4gICAgICAgICAgICBzZXRBcmcoa2V5LCBmYWxzZSwgYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXi0tLisvLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGFyZy5tYXRjaCgvXi0tKC4rKS8pWzFdO1xuICAgICAgICAgICAgdmFyIG5leHQgPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgIS9eLS8udGVzdChuZXh0KVxuICAgICAgICAgICAgJiYgIWZsYWdzLmJvb2xzW2tleV1cbiAgICAgICAgICAgICYmICFmbGFncy5hbGxCb29sc1xuICAgICAgICAgICAgJiYgKGFsaWFzZXNba2V5XSA/ICFhbGlhc0lzQm9vbGVhbihrZXkpIDogdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0LCBhcmcpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKC9eKHRydWV8ZmFsc2UpJC8udGVzdChuZXh0KSkge1xuICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIG5leHQgPT09ICd0cnVlJywgYXJnKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBmbGFncy5zdHJpbmdzW2tleV0gPyAnJyA6IHRydWUsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14tW14tXSsvLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgdmFyIGxldHRlcnMgPSBhcmcuc2xpY2UoMSwtMSkuc3BsaXQoJycpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgYnJva2VuID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldHRlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGFyZy5zbGljZShqKzIpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIG5leHQsIGFyZylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICgvW0EtWmEtel0vLnRlc3QobGV0dGVyc1tqXSkgJiYgLz0vLnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIG5leHQuc3BsaXQoJz0nKVsxXSwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICgvW0EtWmEtel0vLnRlc3QobGV0dGVyc1tqXSlcbiAgICAgICAgICAgICAgICAmJiAvLT9cXGQrKFxcLlxcZCopPyhlLT9cXGQrKT8kLy50ZXN0KG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBuZXh0LCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICBicm9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGxldHRlcnNbaisxXSAmJiBsZXR0ZXJzW2orMV0ubWF0Y2goL1xcVy8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBhcmcuc2xpY2UoaisyKSwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgZmxhZ3Muc3RyaW5nc1tsZXR0ZXJzW2pdXSA/ICcnIDogdHJ1ZSwgYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBrZXkgPSBhcmcuc2xpY2UoLTEpWzBdO1xuICAgICAgICAgICAgaWYgKCFicm9rZW4gJiYga2V5ICE9PSAnLScpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnc1tpKzFdICYmICEvXigtfC0tKVteLV0vLnRlc3QoYXJnc1tpKzFdKVxuICAgICAgICAgICAgICAgICYmICFmbGFncy5ib29sc1trZXldXG4gICAgICAgICAgICAgICAgJiYgKGFsaWFzZXNba2V5XSA/ICFhbGlhc0lzQm9vbGVhbihrZXkpIDogdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgYXJnc1tpKzFdLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3NbaSsxXSAmJiAvXih0cnVlfGZhbHNlKSQvLnRlc3QoYXJnc1tpKzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBhcmdzW2krMV0gPT09ICd0cnVlJywgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgZmxhZ3Muc3RyaW5nc1trZXldID8gJycgOiB0cnVlLCBhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZmxhZ3MudW5rbm93bkZuIHx8IGZsYWdzLnVua25vd25GbihhcmcpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGFyZ3YuXy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBmbGFncy5zdHJpbmdzWydfJ10gfHwgIWlzTnVtYmVyKGFyZykgPyBhcmcgOiBOdW1iZXIoYXJnKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5zdG9wRWFybHkpIHtcbiAgICAgICAgICAgICAgICBhcmd2Ll8ucHVzaC5hcHBseShhcmd2Ll8sIGFyZ3Muc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBPYmplY3Qua2V5cyhkZWZhdWx0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaGFzS2V5KGFyZ3YsIGtleS5zcGxpdCgnLicpKSkge1xuICAgICAgICAgICAgc2V0S2V5KGFyZ3YsIGtleS5zcGxpdCgnLicpLCBkZWZhdWx0c1trZXldKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgKGFsaWFzZXNba2V5XSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHNldEtleShhcmd2LCB4LnNwbGl0KCcuJyksIGRlZmF1bHRzW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiAob3B0c1snLS0nXSkge1xuICAgICAgICBhcmd2WyctLSddID0gbmV3IEFycmF5KCk7XG4gICAgICAgIG5vdEZsYWdzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBhcmd2WyctLSddLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub3RGbGFncy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgYXJndi5fLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZ3Y7XG59O1xuXG5mdW5jdGlvbiBoYXNLZXkgKG9iaiwga2V5cykge1xuICAgIHZhciBvID0gb2JqO1xuICAgIGtleXMuc2xpY2UoMCwtMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIG8gPSAob1trZXldIHx8IHt9KTtcbiAgICB9KTtcblxuICAgIHZhciBrZXkgPSBrZXlzW2tleXMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGtleSBpbiBvO1xufVxuXG5mdW5jdGlvbiBpc051bWJlciAoeCkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHJldHVybiB0cnVlO1xuICAgIGlmICgvXjB4WzAtOWEtZl0rJC9pLnRlc3QoeCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiAvXlstK10/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKShlWy0rXT9cXGQrKT8kLy50ZXN0KHgpO1xufVxuXG4iLCJcbid1c2Ugc3RyaWN0J1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbW9ieC5janMucHJvZHVjdGlvbi5taW4uanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vYnguY2pzLmRldmVsb3BtZW50LmpzJylcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIG5pY2VFcnJvcnMgPSB7XG4gIDA6IFwiSW52YWxpZCB2YWx1ZSBmb3IgY29uZmlndXJhdGlvbiAnZW5mb3JjZUFjdGlvbnMnLCBleHBlY3RlZCAnbmV2ZXInLCAnYWx3YXlzJyBvciAnb2JzZXJ2ZWQnXCIsXG4gIDE6IGZ1bmN0aW9uIF8oYW5ub3RhdGlvblR5cGUsIGtleSkge1xuICAgIHJldHVybiBcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm5vdGF0aW9uVHlwZSArIFwiJyB0byAnXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzogRmllbGQgbm90IGZvdW5kLlwiO1xuICB9LFxuXG4gIC8qXHJcbiAgMihwcm9wKSB7XHJcbiAgICAgIHJldHVybiBgaW52YWxpZCBkZWNvcmF0b3IgZm9yICcke3Byb3AudG9TdHJpbmcoKX0nYFxyXG4gIH0sXHJcbiAgMyhwcm9wKSB7XHJcbiAgICAgIHJldHVybiBgQ2Fubm90IGRlY29yYXRlICcke3Byb3AudG9TdHJpbmcoKX0nOiBhY3Rpb24gY2FuIG9ubHkgYmUgdXNlZCBvbiBwcm9wZXJ0aWVzIHdpdGggYSBmdW5jdGlvbiB2YWx1ZS5gXHJcbiAgfSxcclxuICA0KHByb3ApIHtcclxuICAgICAgcmV0dXJuIGBDYW5ub3QgZGVjb3JhdGUgJyR7cHJvcC50b1N0cmluZygpfSc6IGNvbXB1dGVkIGNhbiBvbmx5IGJlIHVzZWQgb24gZ2V0dGVyIHByb3BlcnRpZXMuYFxyXG4gIH0sXHJcbiAgKi9cbiAgNTogXCIna2V5cygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzLCBzZXRzIGFuZCBtYXBzXCIsXG4gIDY6IFwiJ3ZhbHVlcygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzLCBzZXRzIGFuZCBtYXBzXCIsXG4gIDc6IFwiJ2VudHJpZXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICA4OiBcIidzZXQoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICA5OiBcIidyZW1vdmUoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICAxMDogXCInaGFzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgMTE6IFwiJ2dldCgpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDEyOiBcIkludmFsaWQgYW5ub3RhdGlvblwiLFxuICAxMzogXCJEeW5hbWljIG9ic2VydmFibGUgb2JqZWN0cyBjYW5ub3QgYmUgZnJvemVuXCIsXG4gIDE0OiBcIkludGVyY2VwdCBoYW5kbGVycyBzaG91bGQgcmV0dXJuIG5vdGhpbmcgb3IgYSBjaGFuZ2Ugb2JqZWN0XCIsXG4gIDE1OiBcIk9ic2VydmFibGUgYXJyYXlzIGNhbm5vdCBiZSBmcm96ZW5cIixcbiAgMTY6IFwiTW9kaWZpY2F0aW9uIGV4Y2VwdGlvbjogdGhlIGludGVybmFsIHN0cnVjdHVyZSBvZiBhbiBvYnNlcnZhYmxlIGFycmF5IHdhcyBjaGFuZ2VkLlwiLFxuICAxNzogZnVuY3Rpb24gXyhpbmRleCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFwiW21vYnguYXJyYXldIEluZGV4IG91dCBvZiBib3VuZHMsIFwiICsgaW5kZXggKyBcIiBpcyBsYXJnZXIgdGhhbiBcIiArIGxlbmd0aDtcbiAgfSxcbiAgMTg6IFwibW9ieC5tYXAgcmVxdWlyZXMgTWFwIHBvbHlmaWxsIGZvciB0aGUgY3VycmVudCBicm93c2VyLiBDaGVjayBiYWJlbC1wb2x5ZmlsbCBvciBjb3JlLWpzL2VzNi9tYXAuanNcIixcbiAgMTk6IGZ1bmN0aW9uIF8ob3RoZXIpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgaW5pdGlhbGl6ZSBmcm9tIGNsYXNzZXMgdGhhdCBpbmhlcml0IGZyb20gTWFwOiBcIiArIG90aGVyLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH0sXG4gIDIwOiBmdW5jdGlvbiBfKG90aGVyKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IGluaXRpYWxpemUgbWFwIGZyb20gXCIgKyBvdGhlcjtcbiAgfSxcbiAgMjE6IGZ1bmN0aW9uIF8oZGF0YVN0cnVjdHVyZSkge1xuICAgIHJldHVybiBcIkNhbm5vdCBjb252ZXJ0IHRvIG1hcCBmcm9tICdcIiArIGRhdGFTdHJ1Y3R1cmUgKyBcIidcIjtcbiAgfSxcbiAgMjI6IFwibW9ieC5zZXQgcmVxdWlyZXMgU2V0IHBvbHlmaWxsIGZvciB0aGUgY3VycmVudCBicm93c2VyLiBDaGVjayBiYWJlbC1wb2x5ZmlsbCBvciBjb3JlLWpzL2VzNi9zZXQuanNcIixcbiAgMjM6IFwiSXQgaXMgbm90IHBvc3NpYmxlIHRvIGdldCBpbmRleCBhdG9tcyBmcm9tIGFycmF5c1wiLFxuICAyNDogZnVuY3Rpb24gXyh0aGluZykge1xuICAgIHJldHVybiBcIkNhbm5vdCBvYnRhaW4gYWRtaW5pc3RyYXRpb24gZnJvbSBcIiArIHRoaW5nO1xuICB9LFxuICAyNTogZnVuY3Rpb24gXyhwcm9wZXJ0eSwgbmFtZSkge1xuICAgIHJldHVybiBcInRoZSBlbnRyeSAnXCIgKyBwcm9wZXJ0eSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgb2JzZXJ2YWJsZSBtYXAgJ1wiICsgbmFtZSArIFwiJ1wiO1xuICB9LFxuICAyNjogXCJwbGVhc2Ugc3BlY2lmeSBhIHByb3BlcnR5XCIsXG4gIDI3OiBmdW5jdGlvbiBfKHByb3BlcnR5LCBuYW1lKSB7XG4gICAgcmV0dXJuIFwibm8gb2JzZXJ2YWJsZSBwcm9wZXJ0eSAnXCIgKyBwcm9wZXJ0eS50b1N0cmluZygpICsgXCInIGZvdW5kIG9uIHRoZSBvYnNlcnZhYmxlIG9iamVjdCAnXCIgKyBuYW1lICsgXCInXCI7XG4gIH0sXG4gIDI4OiBmdW5jdGlvbiBfKHRoaW5nKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IG9idGFpbiBhdG9tIGZyb20gXCIgKyB0aGluZztcbiAgfSxcbiAgMjk6IFwiRXhwZWN0aW5nIHNvbWUgb2JqZWN0XCIsXG4gIDMwOiBcImludmFsaWQgYWN0aW9uIHN0YWNrLiBkaWQgeW91IGZvcmdldCB0byBmaW5pc2ggYW4gYWN0aW9uP1wiLFxuICAzMTogXCJtaXNzaW5nIG9wdGlvbiBmb3IgY29tcHV0ZWQ6IGdldFwiLFxuICAzMjogZnVuY3Rpb24gXyhuYW1lLCBkZXJpdmF0aW9uKSB7XG4gICAgcmV0dXJuIFwiQ3ljbGUgZGV0ZWN0ZWQgaW4gY29tcHV0YXRpb24gXCIgKyBuYW1lICsgXCI6IFwiICsgZGVyaXZhdGlvbjtcbiAgfSxcbiAgMzM6IGZ1bmN0aW9uIF8obmFtZSkge1xuICAgIHJldHVybiBcIlRoZSBzZXR0ZXIgb2YgY29tcHV0ZWQgdmFsdWUgJ1wiICsgbmFtZSArIFwiJyBpcyB0cnlpbmcgdG8gdXBkYXRlIGl0c2VsZi4gRGlkIHlvdSBpbnRlbmQgdG8gdXBkYXRlIGFuIF9vYnNlcnZhYmxlXyB2YWx1ZSwgaW5zdGVhZCBvZiB0aGUgY29tcHV0ZWQgcHJvcGVydHk/XCI7XG4gIH0sXG4gIDM0OiBmdW5jdGlvbiBfKG5hbWUpIHtcbiAgICByZXR1cm4gXCJbQ29tcHV0ZWRWYWx1ZSAnXCIgKyBuYW1lICsgXCInXSBJdCBpcyBub3QgcG9zc2libGUgdG8gYXNzaWduIGEgbmV3IHZhbHVlIHRvIGEgY29tcHV0ZWQgdmFsdWUuXCI7XG4gIH0sXG4gIDM1OiBcIlRoZXJlIGFyZSBtdWx0aXBsZSwgZGlmZmVyZW50IHZlcnNpb25zIG9mIE1vYlggYWN0aXZlLiBNYWtlIHN1cmUgTW9iWCBpcyBsb2FkZWQgb25seSBvbmNlIG9yIHVzZSBgY29uZmlndXJlKHsgaXNvbGF0ZUdsb2JhbFN0YXRlOiB0cnVlIH0pYFwiLFxuICAzNjogXCJpc29sYXRlR2xvYmFsU3RhdGUgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgTW9iWCBpcyBydW5uaW5nIGFueSByZWFjdGlvbnNcIixcbiAgMzc6IGZ1bmN0aW9uIF8obWV0aG9kKSB7XG4gICAgcmV0dXJuIFwiW21vYnhdIGBvYnNlcnZhYmxlQXJyYXkuXCIgKyBtZXRob2QgKyBcIigpYCBtdXRhdGVzIHRoZSBhcnJheSBpbi1wbGFjZSwgd2hpY2ggaXMgbm90IGFsbG93ZWQgaW5zaWRlIGEgZGVyaXZhdGlvbi4gVXNlIGBhcnJheS5zbGljZSgpLlwiICsgbWV0aG9kICsgXCIoKWAgaW5zdGVhZFwiO1xuICB9LFxuICAzODogXCInb3duS2V5cygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0c1wiLFxuICAzOTogXCInZGVmaW5lUHJvcGVydHkoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHNcIlxufTtcbnZhciBlcnJvcnMgPSAgbmljZUVycm9ycyA7XG5mdW5jdGlvbiBkaWUoZXJyb3IpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAge1xuICAgIHZhciBlID0gdHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiID8gZXJyb3IgOiBlcnJvcnNbZXJyb3JdO1xuICAgIGlmICh0eXBlb2YgZSA9PT0gXCJmdW5jdGlvblwiKSBlID0gZS5hcHBseShudWxsLCBhcmdzKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbTW9iWF0gXCIgKyBlKTtcbiAgfVxufVxuXG52YXIgbW9ja0dsb2JhbCA9IHt9O1xuZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgcmV0dXJuIG1vY2tHbG9iYWw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xudmFyIGdldERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgRU1QVFlfQVJSQVkgPSBbXTtcbk9iamVjdC5mcmVlemUoRU1QVFlfQVJSQVkpO1xudmFyIEVNUFRZX09CSkVDVCA9IHt9O1xuT2JqZWN0LmZyZWV6ZShFTVBUWV9PQkpFQ1QpO1xudmFyIGhhc1Byb3h5ID0gdHlwZW9mIFByb3h5ICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIHBsYWluT2JqZWN0U3RyaW5nID0gLyojX19QVVJFX18qL09iamVjdC50b1N0cmluZygpO1xuZnVuY3Rpb24gYXNzZXJ0UHJveGllcygpIHtcbiAgaWYgKCFoYXNQcm94eSkge1xuICAgIGRpZSggXCJgUHJveHlgIG9iamVjdHMgYXJlIG5vdCBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIFBsZWFzZSBjb25maWd1cmUgTW9iWCB0byBlbmFibGUgYSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbi5gXCIgKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChtc2cpIHtcbiAgaWYgKCBnbG9iYWxTdGF0ZS52ZXJpZnlQcm94aWVzKSB7XG4gICAgZGllKFwiTW9iWCBpcyBjdXJyZW50bHkgY29uZmlndXJlZCB0byBiZSBhYmxlIHRvIHJ1biBpbiBFUzUgbW9kZSwgYnV0IGluIEVTNSBNb2JYIHdvbid0IGJlIGFibGUgdG8gXCIgKyBtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBnZXROZXh0SWQoKSB7XG4gIHJldHVybiArK2dsb2JhbFN0YXRlLm1vYnhHdWlkO1xufVxuLyoqXHJcbiAqIE1ha2VzIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgaW52b2tlZCBhdCBtb3N0IG9uY2UuXHJcbiAqL1xuXG5mdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgdmFyIGludm9rZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaW52b2tlZCkgcmV0dXJuO1xuICAgIGludm9rZWQgPSB0cnVlO1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNTdHJpbmdpc2godmFsdWUpIHtcbiAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG5cbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHZhciBfcHJvdG8kY29uc3RydWN0b3I7XG5cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgaWYgKHByb3RvID09IG51bGwpIHJldHVybiB0cnVlO1xuICByZXR1cm4gKChfcHJvdG8kY29uc3RydWN0b3IgPSBwcm90by5jb25zdHJ1Y3RvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm90byRjb25zdHJ1Y3Rvci50b1N0cmluZygpKSA9PT0gcGxhaW5PYmplY3RTdHJpbmc7XG59IC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNzg2NTE3MFxuXG5mdW5jdGlvbiBpc0dlbmVyYXRvcihvYmopIHtcbiAgdmFyIGNvbnN0cnVjdG9yID0gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmouY29uc3RydWN0b3I7XG4gIGlmICghY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcbiAgaWYgKFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gY29uc3RydWN0b3IubmFtZSB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYWRkSGlkZGVuUHJvcChvYmplY3QsIHByb3BOYW1lLCB2YWx1ZSkge1xuICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BOYW1lLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZEhpZGRlbkZpbmFsUHJvcChvYmplY3QsIHByb3BOYW1lLCB2YWx1ZSkge1xuICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BOYW1lLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKG5hbWUsIHRoZUNsYXNzKSB7XG4gIHZhciBwcm9wTmFtZSA9IFwiaXNNb2JYXCIgKyBuYW1lO1xuICB0aGVDbGFzcy5wcm90b3R5cGVbcHJvcE5hbWVdID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIHhbcHJvcE5hbWVdID09PSB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gaXNFUzZNYXAodGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nIGluc3RhbmNlb2YgTWFwO1xufVxuZnVuY3Rpb24gaXNFUzZTZXQodGhpbmcpIHtcbiAgcmV0dXJuIHRoaW5nIGluc3RhbmNlb2YgU2V0O1xufVxudmFyIGhhc0dldE93blByb3BlcnR5U3ltYm9scyA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSBcInVuZGVmaW5lZFwiO1xuLyoqXHJcbiAqIFJldHVybnMgdGhlIGZvbGxvd2luZzogb3duIGVudW1lcmFibGUga2V5cyBhbmQgc3ltYm9scy5cclxuICovXG5cbmZ1bmN0aW9uIGdldFBsYWluT2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyAvLyBOb3Qgc3VwcG9ydGVkIGluIElFLCBzbyB0aGVyZSBhcmUgbm90IGdvaW5nIHRvIGJlIHN5bWJvbCBwcm9wcyBhbnl3YXkuLi5cblxuICBpZiAoIWhhc0dldE93blByb3BlcnR5U3ltYm9scykgcmV0dXJuIGtleXM7XG4gIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICBpZiAoIXN5bWJvbHMubGVuZ3RoKSByZXR1cm4ga2V5cztcbiAgcmV0dXJuIFtdLmNvbmNhdChrZXlzLCBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBvYmplY3RQcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHMpO1xuICB9KSk7XG59IC8vIEZyb20gSW1tZXIgdXRpbHNcbi8vIFJldHVybnMgYWxsIG93biBrZXlzLCBpbmNsdWRpbmcgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbGljXG5cbnZhciBvd25LZXlzID0gdHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5vd25LZXlzID8gUmVmbGVjdC5vd25LZXlzIDogaGFzR2V0T3duUHJvcGVydHlTeW1ib2xzID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopKTtcbn0gOlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xuZnVuY3Rpb24gc3RyaW5naWZ5S2V5KGtleSkge1xuICBpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGtleTtcbiAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIpIHJldHVybiBrZXkudG9TdHJpbmcoKTtcbiAgcmV0dXJuIG5ldyBTdHJpbmcoa2V5KS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gdG9QcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gbnVsbCA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiA/IFwiXCIgKyB2YWx1ZSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gaGFzUHJvcCh0YXJnZXQsIHByb3ApIHtcbiAgcmV0dXJuIG9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcCk7XG59IC8vIEZyb20gSW1tZXIgdXRpbHNcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRhcmdldCkge1xuICAvLyBQb2x5ZmlsbCBuZWVkZWQgZm9yIEhlcm1lcyBhbmQgSUUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svaGVybWVzL2lzc3Vlcy8yNzRcbiAgdmFyIHJlcyA9IHt9OyAvLyBOb3RlOiB3aXRob3V0IHBvbHlmaWxsIGZvciBvd25LZXlzLCBzeW1ib2xzIHdvbid0IGJlIHBpY2tlZCB1cFxuXG4gIG93bktleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXNba2V5XSA9IGdldERlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkge1xuICB2YXIgaXQ7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIHJldHVybiBpdC5uZXh0LmJpbmQoaXQpO1xufVxuXG52YXIgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wgPSAvKiNfX1BVUkVfXyovU3ltYm9sKFwibW9ieC1zdG9yZWQtYW5ub3RhdGlvbnNcIik7XG4vKipcclxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWN0cyBhc1xyXG4gKiAtIGRlY29yYXRvclxyXG4gKiAtIGFubm90YXRpb24gb2JqZWN0XHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGFubm90YXRpb24pIHtcbiAgZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICBzdG9yZUFubm90YXRpb24odGFyZ2V0LCBwcm9wZXJ0eSwgYW5ub3RhdGlvbik7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWNvcmF0b3IsIGFubm90YXRpb24pO1xufVxuLyoqXHJcbiAqIFN0b3JlcyBhbm5vdGF0aW9uIHRvIHByb3RvdHlwZSxcclxuICogc28gaXQgY2FuIGJlIGluc3BlY3RlZCBsYXRlciBieSBgbWFrZU9ic2VydmFibGVgIGNhbGxlZCBmcm9tIGNvbnN0cnVjdG9yXHJcbiAqL1xuXG5mdW5jdGlvbiBzdG9yZUFubm90YXRpb24ocHJvdG90eXBlLCBrZXksIGFubm90YXRpb24pIHtcbiAgaWYgKCFoYXNQcm9wKHByb3RvdHlwZSwgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wpKSB7XG4gICAgYWRkSGlkZGVuUHJvcChwcm90b3R5cGUsIHN0b3JlZEFubm90YXRpb25zU3ltYm9sLCBfZXh0ZW5kcyh7fSwgcHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkpO1xuICB9IC8vIEBvdmVycmlkZSBtdXN0IG92ZXJyaWRlIHNvbWV0aGluZ1xuXG5cbiAgaWYgKCBpc092ZXJyaWRlKGFubm90YXRpb24pICYmICFoYXNQcm9wKHByb3RvdHlwZVtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0sIGtleSkpIHtcbiAgICB2YXIgZmllbGROYW1lID0gcHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWUgKyBcIi5wcm90b3R5cGUuXCIgKyBrZXkudG9TdHJpbmcoKTtcbiAgICBkaWUoXCInXCIgKyBmaWVsZE5hbWUgKyBcIicgaXMgZGVjb3JhdGVkIHdpdGggJ292ZXJyaWRlJywgXCIgKyBcImJ1dCBubyBzdWNoIGRlY29yYXRlZCBtZW1iZXIgd2FzIGZvdW5kIG9uIHByb3RvdHlwZS5cIik7XG4gIH0gLy8gQ2Fubm90IHJlLWRlY29yYXRlXG5cblxuICBhc3NlcnROb3REZWNvcmF0ZWQocHJvdG90eXBlLCBhbm5vdGF0aW9uLCBrZXkpOyAvLyBJZ25vcmUgb3ZlcnJpZGVcblxuICBpZiAoIWlzT3ZlcnJpZGUoYW5ub3RhdGlvbikpIHtcbiAgICBwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdW2tleV0gPSBhbm5vdGF0aW9uO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5vdERlY29yYXRlZChwcm90b3R5cGUsIGFubm90YXRpb24sIGtleSkge1xuICBpZiAoICFpc092ZXJyaWRlKGFubm90YXRpb24pICYmIGhhc1Byb3AocHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSwga2V5KSkge1xuICAgIHZhciBmaWVsZE5hbWUgPSBwcm90b3R5cGUuY29uc3RydWN0b3IubmFtZSArIFwiLnByb3RvdHlwZS5cIiArIGtleS50b1N0cmluZygpO1xuICAgIHZhciBjdXJyZW50QW5ub3RhdGlvblR5cGUgPSBwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdW2tleV0uYW5ub3RhdGlvblR5cGVfO1xuICAgIHZhciByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSA9IGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfO1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnQFwiICsgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgKyBcIicgdG8gJ1wiICsgZmllbGROYW1lICsgXCInOlwiICsgKFwiXFxuVGhlIGZpZWxkIGlzIGFscmVhZHkgZGVjb3JhdGVkIHdpdGggJ0BcIiArIGN1cnJlbnRBbm5vdGF0aW9uVHlwZSArIFwiJy5cIikgKyBcIlxcblJlLWRlY29yYXRpbmcgZmllbGRzIGlzIG5vdCBhbGxvd2VkLlwiICsgXCJcXG5Vc2UgJ0BvdmVycmlkZScgZGVjb3JhdG9yIGZvciBtZXRob2RzIG92ZXJyaWRlbiBieSBzdWJjbGFzcy5cIik7XG4gIH1cbn1cbi8qKlxyXG4gKiBDb2xsZWN0cyBhbm5vdGF0aW9ucyBmcm9tIHByb3RvdHlwZXMgYW5kIHN0b3JlcyB0aGVtIG9uIHRhcmdldCAoaW5zdGFuY2UpXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbGxlY3RTdG9yZWRBbm5vdGF0aW9ucyh0YXJnZXQpIHtcbiAgaWYgKCFoYXNQcm9wKHRhcmdldCwgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wpKSB7XG4gICAgaWYgKCAhdGFyZ2V0W3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkge1xuICAgICAgZGllKFwiTm8gYW5ub3RhdGlvbnMgd2VyZSBwYXNzZWQgdG8gbWFrZU9ic2VydmFibGUsIGJ1dCBubyBkZWNvcmF0ZWQgbWVtYmVycyBoYXZlIGJlZW4gZm91bmQgZWl0aGVyXCIpO1xuICAgIH0gLy8gV2UgbmVlZCBhIGNvcHkgYXMgd2Ugd2lsbCByZW1vdmUgYW5ub3RhdGlvbiBmcm9tIHRoZSBsaXN0IG9uY2UgaXQncyBhcHBsaWVkLlxuXG5cbiAgICBhZGRIaWRkZW5Qcm9wKHRhcmdldCwgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wsIF9leHRlbmRzKHt9LCB0YXJnZXRbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0W3N0b3JlZEFubm90YXRpb25zU3ltYm9sXTtcbn1cblxudmFyICRtb2J4ID0gLyojX19QVVJFX18qL1N5bWJvbChcIm1vYnggYWRtaW5pc3RyYXRpb25cIik7XG52YXIgQXRvbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIGZvciBlZmZlY3RpdmUgdW5vYnNlcnZpbmcuIEJhc2VBdG9tIGhhcyB0cnVlLCBmb3IgZXh0cmEgb3B0aW1pemF0aW9uLCBzbyBpdHMgb25CZWNvbWVVbm9ic2VydmVkIG5ldmVyIGdldHMgY2FsbGVkLCBiZWNhdXNlIGl0J3Mgbm90IG5lZWRlZFxuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBhdG9tLiBGb3IgZGVidWdnaW5nIHB1cnBvc2VzIGl0IGlzIHJlY29tbWVuZGVkIHRvIGdpdmUgaXQgYSBuYW1lLlxyXG4gICAqIFRoZSBvbkJlY29tZU9ic2VydmVkIGFuZCBvbkJlY29tZVVub2JzZXJ2ZWQgY2FsbGJhY2tzIGNhbiBiZSB1c2VkIGZvciByZXNvdXJjZSBtYW5hZ2VtZW50LlxyXG4gICAqL1xuICBmdW5jdGlvbiBBdG9tKG5hbWVfKSB7XG4gICAgaWYgKG5hbWVfID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWVfID0gIFwiQXRvbUBcIiArIGdldE5leHRJZCgpIDtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbl8gPSBmYWxzZTtcbiAgICB0aGlzLmlzQmVpbmdPYnNlcnZlZF8gPSBmYWxzZTtcbiAgICB0aGlzLm9ic2VydmVyc18gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5kaWZmVmFsdWVfID0gMDtcbiAgICB0aGlzLmxhc3RBY2Nlc3NlZEJ5XyA9IDA7XG4gICAgdGhpcy5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG4gICAgdGhpcy5vbkJPTCA9IHZvaWQgMDtcbiAgICB0aGlzLm9uQlVPTCA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG4gIH0gLy8gb25CZWNvbWVPYnNlcnZlZExpc3RlbmVyc1xuXG5cbiAgdmFyIF9wcm90byA9IEF0b20ucHJvdG90eXBlO1xuXG4gIF9wcm90by5vbkJPID0gZnVuY3Rpb24gb25CTygpIHtcbiAgICBpZiAodGhpcy5vbkJPTCkge1xuICAgICAgdGhpcy5vbkJPTC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25CVU8gPSBmdW5jdGlvbiBvbkJVTygpIHtcbiAgICBpZiAodGhpcy5vbkJVT0wpIHtcbiAgICAgIHRoaXMub25CVU9MLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEludm9rZSB0aGlzIG1ldGhvZCB0byBub3RpZnkgbW9ieCB0aGF0IHlvdXIgYXRvbSBoYXMgYmVlbiB1c2VkIHNvbWVob3cuXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGN1cnJlbnRseSBhIHJlYWN0aXZlIGNvbnRleHQuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVwb3J0T2JzZXJ2ZWQgPSBmdW5jdGlvbiByZXBvcnRPYnNlcnZlZCQxKCkge1xuICAgIHJldHVybiByZXBvcnRPYnNlcnZlZCh0aGlzKTtcbiAgfVxuICAvKipcclxuICAgKiBJbnZva2UgdGhpcyBtZXRob2QgX2FmdGVyXyB0aGlzIG1ldGhvZCBoYXMgY2hhbmdlZCB0byBzaWduYWwgbW9ieCB0aGF0IGFsbCBpdHMgb2JzZXJ2ZXJzIHNob3VsZCBpbnZhbGlkYXRlLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlcG9ydENoYW5nZWQgPSBmdW5jdGlvbiByZXBvcnRDaGFuZ2VkKCkge1xuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICBwcm9wYWdhdGVDaGFuZ2VkKHRoaXMpO1xuICAgIGVuZEJhdGNoKCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV87XG4gIH07XG5cbiAgcmV0dXJuIEF0b207XG59KCk7XG52YXIgaXNBdG9tID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJBdG9tXCIsIEF0b20pO1xuZnVuY3Rpb24gY3JlYXRlQXRvbShuYW1lLCBvbkJlY29tZU9ic2VydmVkSGFuZGxlciwgb25CZWNvbWVVbm9ic2VydmVkSGFuZGxlcikge1xuICBpZiAob25CZWNvbWVPYnNlcnZlZEhhbmRsZXIgPT09IHZvaWQgMCkge1xuICAgIG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyID0gbm9vcDtcbiAgfVxuXG4gIGlmIChvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyID09PSB2b2lkIDApIHtcbiAgICBvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyID0gbm9vcDtcbiAgfVxuXG4gIHZhciBhdG9tID0gbmV3IEF0b20obmFtZSk7IC8vIGRlZmF1bHQgYG5vb3BgIGxpc3RlbmVyIHdpbGwgbm90IGluaXRpYWxpemUgdGhlIGhvb2sgU2V0XG5cbiAgaWYgKG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyICE9PSBub29wKSB7XG4gICAgb25CZWNvbWVPYnNlcnZlZChhdG9tLCBvbkJlY29tZU9ic2VydmVkSGFuZGxlcik7XG4gIH1cblxuICBpZiAob25CZWNvbWVVbm9ic2VydmVkSGFuZGxlciAhPT0gbm9vcCkge1xuICAgIG9uQmVjb21lVW5vYnNlcnZlZChhdG9tLCBvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyKTtcbiAgfVxuXG4gIHJldHVybiBhdG9tO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eUNvbXBhcmVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG5cbmZ1bmN0aW9uIHN0cnVjdHVyYWxDb21wYXJlcihhLCBiKSB7XG4gIHJldHVybiBkZWVwRXF1YWwoYSwgYik7XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlcihhLCBiKSB7XG4gIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgMSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlcihhLCBiKSB7XG4gIGlmIChPYmplY3QuaXMpIHJldHVybiBPYmplY3QuaXMoYSwgYik7XG4gIHJldHVybiBhID09PSBiID8gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGIgOiBhICE9PSBhICYmIGIgIT09IGI7XG59XG5cbnZhciBjb21wYXJlciA9IHtcbiAgaWRlbnRpdHk6IGlkZW50aXR5Q29tcGFyZXIsXG4gIHN0cnVjdHVyYWw6IHN0cnVjdHVyYWxDb21wYXJlcixcbiAgXCJkZWZhdWx0XCI6IGRlZmF1bHRDb21wYXJlcixcbiAgc2hhbGxvdzogc2hhbGxvd0NvbXBhcmVyXG59O1xuXG5mdW5jdGlvbiBkZWVwRW5oYW5jZXIodiwgXywgbmFtZSkge1xuICAvLyBpdCBpcyBhbiBvYnNlcnZhYmxlIGFscmVhZHksIGRvbmVcbiAgaWYgKGlzT2JzZXJ2YWJsZSh2KSkgcmV0dXJuIHY7IC8vIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBjb252ZXJ0ZWQgYW5kIG11dGF0ZWQ/XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHJldHVybiBvYnNlcnZhYmxlLmFycmF5KHYsIHtcbiAgICBuYW1lOiBuYW1lXG4gIH0pO1xuICBpZiAoaXNQbGFpbk9iamVjdCh2KSkgcmV0dXJuIG9ic2VydmFibGUub2JqZWN0KHYsIHVuZGVmaW5lZCwge1xuICAgIG5hbWU6IG5hbWVcbiAgfSk7XG4gIGlmIChpc0VTNk1hcCh2KSkgcmV0dXJuIG9ic2VydmFibGUubWFwKHYsIHtcbiAgICBuYW1lOiBuYW1lXG4gIH0pO1xuICBpZiAoaXNFUzZTZXQodikpIHJldHVybiBvYnNlcnZhYmxlLnNldCh2LCB7XG4gICAgbmFtZTogbmFtZVxuICB9KTtcblxuICBpZiAodHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIiAmJiAhaXNBY3Rpb24odikgJiYgIWlzRmxvdyh2KSkge1xuICAgIGlmIChpc0dlbmVyYXRvcih2KSkge1xuICAgICAgcmV0dXJuIGZsb3codik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhdXRvQWN0aW9uKG5hbWUsIHYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2O1xufVxuZnVuY3Rpb24gc2hhbGxvd0VuaGFuY2VyKHYsIF8sIG5hbWUpIHtcbiAgaWYgKHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsKSByZXR1cm4gdjtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh2KSB8fCBpc09ic2VydmFibGVBcnJheSh2KSB8fCBpc09ic2VydmFibGVNYXAodikgfHwgaXNPYnNlcnZhYmxlU2V0KHYpKSByZXR1cm4gdjtcbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHJldHVybiBvYnNlcnZhYmxlLmFycmF5KHYsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGRlZXA6IGZhbHNlXG4gIH0pO1xuICBpZiAoaXNQbGFpbk9iamVjdCh2KSkgcmV0dXJuIG9ic2VydmFibGUub2JqZWN0KHYsIHVuZGVmaW5lZCwge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgZGVlcDogZmFsc2VcbiAgfSk7XG4gIGlmIChpc0VTNk1hcCh2KSkgcmV0dXJuIG9ic2VydmFibGUubWFwKHYsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGRlZXA6IGZhbHNlXG4gIH0pO1xuICBpZiAoaXNFUzZTZXQodikpIHJldHVybiBvYnNlcnZhYmxlLnNldCh2LCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBkZWVwOiBmYWxzZVxuICB9KTtcbiAgZGllKFwiVGhlIHNoYWxsb3cgbW9kaWZpZXIgLyBkZWNvcmF0b3IgY2FuIG9ubHkgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGFycmF5cywgb2JqZWN0cywgbWFwcyBhbmQgc2V0c1wiKTtcbn1cbmZ1bmN0aW9uIHJlZmVyZW5jZUVuaGFuY2VyKG5ld1ZhbHVlKSB7XG4gIC8vIG5ldmVyIHR1cm4gaW50byBhbiBvYnNlcnZhYmxlXG4gIHJldHVybiBuZXdWYWx1ZTtcbn1cbmZ1bmN0aW9uIHJlZlN0cnVjdEVuaGFuY2VyKHYsIG9sZFZhbHVlKSB7XG4gIGlmICggaXNPYnNlcnZhYmxlKHYpKSBkaWUoXCJvYnNlcnZhYmxlLnN0cnVjdCBzaG91bGQgbm90IGJlIHVzZWQgd2l0aCBvYnNlcnZhYmxlIHZhbHVlc1wiKTtcbiAgaWYgKGRlZXBFcXVhbCh2LCBvbGRWYWx1ZSkpIHJldHVybiBvbGRWYWx1ZTtcbiAgcmV0dXJuIHY7XG59XG5cbnZhciBPVkVSUklERSA9IFwib3ZlcnJpZGVcIjtcbnZhciBvdmVycmlkZSA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKHtcbiAgYW5ub3RhdGlvblR5cGVfOiBPVkVSUklERSxcbiAgbWFrZV86IG1ha2VfLFxuICBleHRlbmRfOiBleHRlbmRfXG59KTtcbmZ1bmN0aW9uIGlzT3ZlcnJpZGUoYW5ub3RhdGlvbikge1xuICByZXR1cm4gYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV8gPT09IE9WRVJSSURFO1xufVxuXG5mdW5jdGlvbiBtYWtlXyhhZG0sIGtleSkge1xuICAvLyBNdXN0IG5vdCBiZSBwbGFpbiBvYmplY3RcbiAgaWYgKCBhZG0uaXNQbGFpbk9iamVjdF8pIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgdGhpcy5hbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzpcIiArIChcIlxcbidcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbm5vdCBiZSB1c2VkIG9uIHBsYWluIG9iamVjdHMuXCIpKTtcbiAgfSAvLyBNdXN0IG92ZXJyaWRlIHNvbWV0aGluZ1xuXG5cbiAgaWYgKCAhaGFzUHJvcChhZG0uYXBwbGllZEFubm90YXRpb25zXywga2V5KSkge1xuICAgIGRpZShcIidcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIicgaXMgYW5ub3RhdGVkIHdpdGggJ1wiICsgdGhpcy5hbm5vdGF0aW9uVHlwZV8gKyBcIicsIFwiICsgXCJidXQgbm8gc3VjaCBhbm5vdGF0ZWQgbWVtYmVyIHdhcyBmb3VuZCBvbiBwcm90b3R5cGUuXCIpO1xuICB9XG5cbiAgcmV0dXJuIDBcbiAgLyogQ2FuY2VsICovXG4gIDtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIGRpZShcIidcIiArIHRoaXMuYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCAnbWFrZU9ic2VydmFibGUnXCIpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBhbm5vdGF0aW9uVHlwZV86IG5hbWUsXG4gICAgb3B0aW9uc186IG9wdGlvbnMsXG4gICAgbWFrZV86IG1ha2VfJDEsXG4gICAgZXh0ZW5kXzogZXh0ZW5kXyQxXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VfJDEoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSkge1xuICB2YXIgX3RoaXMkb3B0aW9uc187XG5cbiAgLy8gYm91bmRcbiAgaWYgKChfdGhpcyRvcHRpb25zXyA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXy5ib3VuZCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCA/IDBcbiAgICAvKiBDYW5jZWwgKi9cbiAgICA6IDFcbiAgICAvKiBCcmVhayAqL1xuICAgIDtcbiAgfSAvLyBvd25cblxuXG4gIGlmIChzb3VyY2UgPT09IGFkbS50YXJnZXRfKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMFxuICAgIC8qIENhbmNlbCAqL1xuICAgIDogMlxuICAgIC8qIENvbnRpbnVlICovXG4gICAgO1xuICB9IC8vIHByb3RvdHlwZVxuXG5cbiAgaWYgKGlzQWN0aW9uKGRlc2NyaXB0b3IudmFsdWUpKSB7XG4gICAgLy8gQSBwcm90b3R5cGUgY291bGQgaGF2ZSBiZWVuIGFubm90YXRlZCBhbHJlYWR5IGJ5IG90aGVyIGNvbnN0cnVjdG9yLFxuICAgIC8vIHJlc3Qgb2YgdGhlIHByb3RvIGNoYWluIG11c3QgYmUgYW5ub3RhdGVkIGFscmVhZHlcbiAgICByZXR1cm4gMVxuICAgIC8qIEJyZWFrICovXG4gICAgO1xuICB9XG5cbiAgdmFyIGFjdGlvbkRlc2NyaXB0b3IgPSBjcmVhdGVBY3Rpb25EZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSk7XG4gIGRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCBhY3Rpb25EZXNjcmlwdG9yKTtcbiAgcmV0dXJuIDJcbiAgLyogQ29udGludWUgKi9cbiAgO1xufVxuXG5mdW5jdGlvbiBleHRlbmRfJDEoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICB2YXIgYWN0aW9uRGVzY3JpcHRvciA9IGNyZWF0ZUFjdGlvbkRlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IpO1xuICByZXR1cm4gYWRtLmRlZmluZVByb3BlcnR5XyhrZXksIGFjdGlvbkRlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFjdGlvbkRlc2NyaXB0b3IoYWRtLCBfcmVmLCBrZXksIF9yZWYyKSB7XG4gIHZhciBhbm5vdGF0aW9uVHlwZV8gPSBfcmVmLmFubm90YXRpb25UeXBlXztcbiAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWU7XG5cbiAgaWYgKCAhaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCBvbiBwcm9wZXJ0aWVzIHdpdGggYSBmdW5jdGlvbiB2YWx1ZS5cIikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkRlc2NyaXB0b3IoYWRtLCBhbm5vdGF0aW9uLCBrZXksIGRlc2NyaXB0b3IsIC8vIHByb3ZpZGVzIGFiaWxpdHkgdG8gZGlzYWJsZSBzYWZlRGVzY3JpcHRvcnMgZm9yIHByb3RvdHlwZXNcbnNhZmVEZXNjcmlwdG9ycykge1xuICB2YXIgX2Fubm90YXRpb24kb3B0aW9uc18sIF9hbm5vdGF0aW9uJG9wdGlvbnNfJCwgX2Fubm90YXRpb24kb3B0aW9uc18yLCBfYW5ub3RhdGlvbiRvcHRpb25zXyQyLCBfYW5ub3RhdGlvbiRvcHRpb25zXzM7XG5cbiAgaWYgKHNhZmVEZXNjcmlwdG9ycyA9PT0gdm9pZCAwKSB7XG4gICAgc2FmZURlc2NyaXB0b3JzID0gZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzO1xuICB9XG5cbiAgYXNzZXJ0QWN0aW9uRGVzY3JpcHRvcihhZG0sIGFubm90YXRpb24sIGtleSwgZGVzY3JpcHRvcik7XG4gIHZhciB2YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWU7XG5cbiAgaWYgKChfYW5ub3RhdGlvbiRvcHRpb25zXyA9IGFubm90YXRpb24ub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfYW5ub3RhdGlvbiRvcHRpb25zXy5ib3VuZCkge1xuICAgIHZhciBfYWRtJHByb3h5XztcblxuICAgIHZhbHVlID0gdmFsdWUuYmluZCgoX2FkbSRwcm94eV8gPSBhZG0ucHJveHlfKSAhPSBudWxsID8gX2FkbSRwcm94eV8gOiBhZG0udGFyZ2V0Xyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBjcmVhdGVBY3Rpb24oKF9hbm5vdGF0aW9uJG9wdGlvbnNfJCA9IChfYW5ub3RhdGlvbiRvcHRpb25zXzIgPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX2Fubm90YXRpb24kb3B0aW9uc18yLm5hbWUpICE9IG51bGwgPyBfYW5ub3RhdGlvbiRvcHRpb25zXyQgOiBrZXkudG9TdHJpbmcoKSwgdmFsdWUsIChfYW5ub3RhdGlvbiRvcHRpb25zXyQyID0gKF9hbm5vdGF0aW9uJG9wdGlvbnNfMyA9IGFubm90YXRpb24ub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfYW5ub3RhdGlvbiRvcHRpb25zXzMuYXV0b0FjdGlvbikgIT0gbnVsbCA/IF9hbm5vdGF0aW9uJG9wdGlvbnNfJDIgOiBmYWxzZSksXG4gICAgLy8gTm9uLWNvbmZpZ3VyYWJsZSBmb3IgY2xhc3Nlc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWwgZmllbGQgcmVkZWZpbml0aW9uIGluIHN1YmNsYXNzXG4gICAgY29uZmlndXJhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBhZG0uaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9wdWxsLzI2NDEjaXNzdWVjb21tZW50LTczNzI5MjA1OFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIC8vIE5vbi1vYnNldmFibGUsIHRoZXJlZm9yZSBub24td3JpdGFibGVcbiAgICAvLyBBbHNvIHByZXZlbnRzIHJld3JpdGluZyBpbiBzdWJjbGFzcyBjb25zdHJ1Y3RvclxuICAgIHdyaXRhYmxlOiBzYWZlRGVzY3JpcHRvcnMgPyBmYWxzZSA6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmxvd0Fubm90YXRpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogbmFtZSxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kMixcbiAgICBleHRlbmRfOiBleHRlbmRfJDJcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZV8kMihhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXztcblxuICAvLyBvd25cbiAgaWYgKHNvdXJjZSA9PT0gYWRtLnRhcmdldF8pIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwgPyAwXG4gICAgLyogQ2FuY2VsICovXG4gICAgOiAyXG4gICAgLyogQ29udGludWUgKi9cbiAgICA7XG4gIH0gLy8gcHJvdG90eXBlXG4gIC8vIGJvdW5kIC0gbXVzdCBhbm5vdGF0ZSBwcm90b3MgdG8gc3VwcG9ydCBzdXBlci5mbG93KClcblxuXG4gIGlmICgoKF90aGlzJG9wdGlvbnNfID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfLmJvdW5kKSAmJiAhaXNGbG93KGFkbS50YXJnZXRfW2tleV0pKSB7XG4gICAgaWYgKHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsKSByZXR1cm4gMFxuICAgIC8qIENhbmNlbCAqL1xuICAgIDtcbiAgfVxuXG4gIGlmIChpc0Zsb3coZGVzY3JpcHRvci52YWx1ZSkpIHtcbiAgICAvLyBBIHByb3RvdHlwZSBjb3VsZCBoYXZlIGJlZW4gYW5ub3RhdGVkIGFscmVhZHkgYnkgb3RoZXIgY29uc3RydWN0b3IsXG4gICAgLy8gcmVzdCBvZiB0aGUgcHJvdG8gY2hhaW4gbXVzdCBiZSBhbm5vdGF0ZWQgYWxyZWFkeVxuICAgIHJldHVybiAxXG4gICAgLyogQnJlYWsgKi9cbiAgICA7XG4gIH1cblxuICB2YXIgZmxvd0Rlc2NyaXB0b3IgPSBjcmVhdGVGbG93RGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvciwgZmFsc2UsIGZhbHNlKTtcbiAgZGVmaW5lUHJvcGVydHkoc291cmNlLCBrZXksIGZsb3dEZXNjcmlwdG9yKTtcbiAgcmV0dXJuIDJcbiAgLyogQ29udGludWUgKi9cbiAgO1xufVxuXG5mdW5jdGlvbiBleHRlbmRfJDIoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICB2YXIgX3RoaXMkb3B0aW9uc18yO1xuXG4gIHZhciBmbG93RGVzY3JpcHRvciA9IGNyZWF0ZUZsb3dEZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yLCAoX3RoaXMkb3B0aW9uc18yID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfMi5ib3VuZCk7XG4gIHJldHVybiBhZG0uZGVmaW5lUHJvcGVydHlfKGtleSwgZmxvd0Rlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZsb3dEZXNjcmlwdG9yKGFkbSwgX3JlZiwga2V5LCBfcmVmMikge1xuICB2YXIgYW5ub3RhdGlvblR5cGVfID0gX3JlZi5hbm5vdGF0aW9uVHlwZV87XG4gIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlO1xuXG4gIGlmICggIWlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyB0byAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOlwiICsgKFwiXFxuJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbiBvbmx5IGJlIHVzZWQgb24gcHJvcGVydGllcyB3aXRoIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHZhbHVlLlwiKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmxvd0Rlc2NyaXB0b3IoYWRtLCBhbm5vdGF0aW9uLCBrZXksIGRlc2NyaXB0b3IsIGJvdW5kLCAvLyBwcm92aWRlcyBhYmlsaXR5IHRvIGRpc2FibGUgc2FmZURlc2NyaXB0b3JzIGZvciBwcm90b3R5cGVzXG5zYWZlRGVzY3JpcHRvcnMpIHtcbiAgaWYgKHNhZmVEZXNjcmlwdG9ycyA9PT0gdm9pZCAwKSB7XG4gICAgc2FmZURlc2NyaXB0b3JzID0gZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzO1xuICB9XG5cbiAgYXNzZXJ0Rmxvd0Rlc2NyaXB0b3IoYWRtLCBhbm5vdGF0aW9uLCBrZXksIGRlc2NyaXB0b3IpO1xuICB2YXIgdmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlO1xuXG4gIGlmIChib3VuZCkge1xuICAgIHZhciBfYWRtJHByb3h5XztcblxuICAgIHZhbHVlID0gdmFsdWUuYmluZCgoX2FkbSRwcm94eV8gPSBhZG0ucHJveHlfKSAhPSBudWxsID8gX2FkbSRwcm94eV8gOiBhZG0udGFyZ2V0Xyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBmbG93KHZhbHVlKSxcbiAgICAvLyBOb24tY29uZmlndXJhYmxlIGZvciBjbGFzc2VzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbCBmaWVsZCByZWRlZmluaXRpb24gaW4gc3ViY2xhc3NcbiAgICBjb25maWd1cmFibGU6IHNhZmVEZXNjcmlwdG9ycyA/IGFkbS5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L3B1bGwvMjY0MSNpc3N1ZWNvbW1lbnQtNzM3MjkyMDU4XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgLy8gTm9uLW9ic2V2YWJsZSwgdGhlcmVmb3JlIG5vbi13cml0YWJsZVxuICAgIC8vIEFsc28gcHJldmVudHMgcmV3cml0aW5nIGluIHN1YmNsYXNzIGNvbnN0cnVjdG9yXG4gICAgd3JpdGFibGU6IHNhZmVEZXNjcmlwdG9ycyA/IGZhbHNlIDogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZEFubm90YXRpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogbmFtZSxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kMyxcbiAgICBleHRlbmRfOiBleHRlbmRfJDNcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZV8kMyhhZG0sIGtleSwgZGVzY3JpcHRvcikge1xuICByZXR1cm4gdGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwgPyAwXG4gIC8qIENhbmNlbCAqL1xuICA6IDFcbiAgLyogQnJlYWsgKi9cbiAgO1xufVxuXG5mdW5jdGlvbiBleHRlbmRfJDMoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICBhc3NlcnRDb21wdXRlZERlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IpO1xuICByZXR1cm4gYWRtLmRlZmluZUNvbXB1dGVkUHJvcGVydHlfKGtleSwgX2V4dGVuZHMoe30sIHRoaXMub3B0aW9uc18sIHtcbiAgICBnZXQ6IGRlc2NyaXB0b3IuZ2V0LFxuICAgIHNldDogZGVzY3JpcHRvci5zZXRcbiAgfSksIHByb3h5VHJhcCk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENvbXB1dGVkRGVzY3JpcHRvcihhZG0sIF9yZWYsIGtleSwgX3JlZjIpIHtcbiAgdmFyIGFubm90YXRpb25UeXBlXyA9IF9yZWYuYW5ub3RhdGlvblR5cGVfO1xuICB2YXIgZ2V0ID0gX3JlZjIuZ2V0O1xuXG4gIGlmICggIWdldCkge1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzpcIiArIChcIlxcbidcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyBjYW4gb25seSBiZSB1c2VkIG9uIGdldHRlcigrc2V0dGVyKSBwcm9wZXJ0aWVzLlwiKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogbmFtZSxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kNCxcbiAgICBleHRlbmRfOiBleHRlbmRfJDRcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZV8kNChhZG0sIGtleSwgZGVzY3JpcHRvcikge1xuICByZXR1cm4gdGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwgPyAwXG4gIC8qIENhbmNlbCAqL1xuICA6IDFcbiAgLyogQnJlYWsgKi9cbiAgO1xufVxuXG5mdW5jdGlvbiBleHRlbmRfJDQoYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCkge1xuICB2YXIgX3RoaXMkb3B0aW9uc18kZW5oYW5jLCBfdGhpcyRvcHRpb25zXztcblxuICBhc3NlcnRPYnNlcnZhYmxlRGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvcik7XG4gIHJldHVybiBhZG0uZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5XyhrZXksIGRlc2NyaXB0b3IudmFsdWUsIChfdGhpcyRvcHRpb25zXyRlbmhhbmMgPSAoX3RoaXMkb3B0aW9uc18gPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc18uZW5oYW5jZXIpICE9IG51bGwgPyBfdGhpcyRvcHRpb25zXyRlbmhhbmMgOiBkZWVwRW5oYW5jZXIsIHByb3h5VHJhcCk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9ic2VydmFibGVEZXNjcmlwdG9yKGFkbSwgX3JlZiwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIHZhciBhbm5vdGF0aW9uVHlwZV8gPSBfcmVmLmFubm90YXRpb25UeXBlXztcblxuICBpZiAoICEoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpKSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyB0byAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOlwiICsgKFwiXFxuJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbm5vdCBiZSB1c2VkIG9uIGdldHRlci9zZXR0ZXIgcHJvcGVydGllc1wiKSk7XG4gIH1cbn1cblxudmFyIEFVVE8gPSBcInRydWVcIjtcbnZhciBhdXRvQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBdXRvQW5ub3RhdGlvbigpO1xuZnVuY3Rpb24gY3JlYXRlQXV0b0Fubm90YXRpb24ob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogQVVUTyxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kNSxcbiAgICBleHRlbmRfOiBleHRlbmRfJDVcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZV8kNShhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXzMsIF90aGlzJG9wdGlvbnNfNDtcblxuICAvLyBnZXR0ZXIgLT4gY29tcHV0ZWRcbiAgaWYgKGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkLm1ha2VfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpO1xuICB9IC8vIGxvbmUgc2V0dGVyIC0+IGFjdGlvbiBzZXR0ZXJcblxuXG4gIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgIC8vIFRPRE8gbWFrZSBhY3Rpb24gYXBwbGljYWJsZSB0byBzZXR0ZXIgYW5kIGRlbGVnYXRlIHRvIGFjdGlvbi5tYWtlX1xuICAgIHZhciBzZXQgPSBjcmVhdGVBY3Rpb24oa2V5LnRvU3RyaW5nKCksIGRlc2NyaXB0b3Iuc2V0KTsgLy8gb3duXG5cbiAgICBpZiAoc291cmNlID09PSBhZG0udGFyZ2V0Xykge1xuICAgICAgcmV0dXJuIGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzID8gYWRtLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAgICAgc2V0OiBzZXRcbiAgICAgIH0pID09PSBudWxsID8gMFxuICAgICAgLyogQ2FuY2VsICovXG4gICAgICA6IDJcbiAgICAgIC8qIENvbnRpbnVlICovXG4gICAgICA7XG4gICAgfSAvLyBwcm90b1xuXG5cbiAgICBkZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgc2V0OiBzZXRcbiAgICB9KTtcbiAgICByZXR1cm4gMlxuICAgIC8qIENvbnRpbnVlICovXG4gICAgO1xuICB9IC8vIGZ1bmN0aW9uIG9uIHByb3RvIC0+IGF1dG9BY3Rpb24vZmxvd1xuXG5cbiAgaWYgKHNvdXJjZSAhPT0gYWRtLnRhcmdldF8gJiYgdHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBfdGhpcyRvcHRpb25zXzI7XG5cbiAgICBpZiAoaXNHZW5lcmF0b3IoZGVzY3JpcHRvci52YWx1ZSkpIHtcbiAgICAgIHZhciBfdGhpcyRvcHRpb25zXztcblxuICAgICAgdmFyIGZsb3dBbm5vdGF0aW9uID0gKChfdGhpcyRvcHRpb25zXyA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXy5hdXRvQmluZCkgPyBmbG93LmJvdW5kIDogZmxvdztcbiAgICAgIHJldHVybiBmbG93QW5ub3RhdGlvbi5tYWtlXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgYWN0aW9uQW5ub3RhdGlvbiA9ICgoX3RoaXMkb3B0aW9uc18yID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfMi5hdXRvQmluZCkgPyBhdXRvQWN0aW9uLmJvdW5kIDogYXV0b0FjdGlvbjtcbiAgICByZXR1cm4gYWN0aW9uQW5ub3RhdGlvbi5tYWtlXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbiAgfSAvLyBvdGhlciAtPiBvYnNlcnZhYmxlXG4gIC8vIENvcHkgcHJvcHMgZnJvbSBwcm90byBhcyB3ZWxsLCBzZWUgdGVzdDpcbiAgLy8gXCJkZWNvcmF0ZSBzaG91bGQgd29yayB3aXRoIE9iamVjdC5jcmVhdGVcIlxuXG5cbiAgdmFyIG9ic2VydmFibGVBbm5vdGF0aW9uID0gKChfdGhpcyRvcHRpb25zXzMgPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc18zLmRlZXApID09PSBmYWxzZSA/IG9ic2VydmFibGUucmVmIDogb2JzZXJ2YWJsZTsgLy8gaWYgZnVuY3Rpb24gcmVzcGVjdCBhdXRvQmluZCBvcHRpb25cblxuICBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiAoKF90aGlzJG9wdGlvbnNfNCA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzQuYXV0b0JpbmQpKSB7XG4gICAgdmFyIF9hZG0kcHJveHlfO1xuXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWUuYmluZCgoX2FkbSRwcm94eV8gPSBhZG0ucHJveHlfKSAhPSBudWxsID8gX2FkbSRwcm94eV8gOiBhZG0udGFyZ2V0Xyk7XG4gIH1cblxuICByZXR1cm4gb2JzZXJ2YWJsZUFubm90YXRpb24ubWFrZV8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZF8kNShhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXzUsIF90aGlzJG9wdGlvbnNfNjtcblxuICAvLyBnZXR0ZXIgLT4gY29tcHV0ZWRcbiAgaWYgKGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG4gIH0gLy8gbG9uZSBzZXR0ZXIgLT4gYWN0aW9uIHNldHRlclxuXG5cbiAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgLy8gVE9ETyBtYWtlIGFjdGlvbiBhcHBsaWNhYmxlIHRvIHNldHRlciBhbmQgZGVsZWdhdGUgdG8gYWN0aW9uLmV4dGVuZF9cbiAgICByZXR1cm4gYWRtLmRlZmluZVByb3BlcnR5XyhrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzID8gYWRtLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAgIHNldDogY3JlYXRlQWN0aW9uKGtleS50b1N0cmluZygpLCBkZXNjcmlwdG9yLnNldClcbiAgICB9LCBwcm94eVRyYXApO1xuICB9IC8vIG90aGVyIC0+IG9ic2VydmFibGVcbiAgLy8gaWYgZnVuY3Rpb24gcmVzcGVjdCBhdXRvQmluZCBvcHRpb25cblxuXG4gIGlmICh0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmICgoX3RoaXMkb3B0aW9uc181ID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfNS5hdXRvQmluZCkpIHtcbiAgICB2YXIgX2FkbSRwcm94eV8yO1xuXG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWUuYmluZCgoX2FkbSRwcm94eV8yID0gYWRtLnByb3h5XykgIT0gbnVsbCA/IF9hZG0kcHJveHlfMiA6IGFkbS50YXJnZXRfKTtcbiAgfVxuXG4gIHZhciBvYnNlcnZhYmxlQW5ub3RhdGlvbiA9ICgoX3RoaXMkb3B0aW9uc182ID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfNi5kZWVwKSA9PT0gZmFsc2UgPyBvYnNlcnZhYmxlLnJlZiA6IG9ic2VydmFibGU7XG4gIHJldHVybiBvYnNlcnZhYmxlQW5ub3RhdGlvbi5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApO1xufVxuXG52YXIgT0JTRVJWQUJMRSA9IFwib2JzZXJ2YWJsZVwiO1xudmFyIE9CU0VSVkFCTEVfUkVGID0gXCJvYnNlcnZhYmxlLnJlZlwiO1xudmFyIE9CU0VSVkFCTEVfU0hBTExPVyA9IFwib2JzZXJ2YWJsZS5zaGFsbG93XCI7XG52YXIgT0JTRVJWQUJMRV9TVFJVQ1QgPSBcIm9ic2VydmFibGUuc3RydWN0XCI7IC8vIFByZWRlZmluZWQgYmFncyBvZiBjcmVhdGUgb2JzZXJ2YWJsZSBvcHRpb25zLCB0byBhdm9pZCBhbGxvY2F0aW5nIHRlbXBvcmFyaWx5IG9wdGlvbiBvYmplY3RzXG4vLyBpbiB0aGUgbWFqb3JpdHkgb2YgY2FzZXNcblxudmFyIGRlZmF1bHRDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyA9IHtcbiAgZGVlcDogdHJ1ZSxcbiAgbmFtZTogdW5kZWZpbmVkLFxuICBkZWZhdWx0RGVjb3JhdG9yOiB1bmRlZmluZWQsXG4gIHByb3h5OiB0cnVlXG59O1xuT2JqZWN0LmZyZWV6ZShkZWZhdWx0Q3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMpO1xuZnVuY3Rpb24gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyh0aGluZykge1xuICByZXR1cm4gdGhpbmcgfHwgZGVmYXVsdENyZWF0ZU9ic2VydmFibGVPcHRpb25zO1xufVxudmFyIG9ic2VydmFibGVBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVBbm5vdGF0aW9uKE9CU0VSVkFCTEUpO1xudmFyIG9ic2VydmFibGVSZWZBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVBbm5vdGF0aW9uKE9CU0VSVkFCTEVfUkVGLCB7XG4gIGVuaGFuY2VyOiByZWZlcmVuY2VFbmhhbmNlclxufSk7XG52YXIgb2JzZXJ2YWJsZVNoYWxsb3dBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVBbm5vdGF0aW9uKE9CU0VSVkFCTEVfU0hBTExPVywge1xuICBlbmhhbmNlcjogc2hhbGxvd0VuaGFuY2VyXG59KTtcbnZhciBvYnNlcnZhYmxlU3RydWN0QW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihPQlNFUlZBQkxFX1NUUlVDVCwge1xuICBlbmhhbmNlcjogcmVmU3RydWN0RW5oYW5jZXJcbn0pO1xudmFyIG9ic2VydmFibGVEZWNvcmF0b3JBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24ob2JzZXJ2YWJsZUFubm90YXRpb24pO1xuZnVuY3Rpb24gZ2V0RW5oYW5jZXJGcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmRlZXAgPT09IHRydWUgPyBkZWVwRW5oYW5jZXIgOiBvcHRpb25zLmRlZXAgPT09IGZhbHNlID8gcmVmZXJlbmNlRW5oYW5jZXIgOiBnZXRFbmhhbmNlckZyb21Bbm5vdGF0aW9uKG9wdGlvbnMuZGVmYXVsdERlY29yYXRvcik7XG59XG5mdW5jdGlvbiBnZXRBbm5vdGF0aW9uRnJvbU9wdGlvbnMob3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkZGVmYXVsdERlY29yO1xuXG4gIHJldHVybiBvcHRpb25zID8gKF9vcHRpb25zJGRlZmF1bHREZWNvciA9IG9wdGlvbnMuZGVmYXVsdERlY29yYXRvcikgIT0gbnVsbCA/IF9vcHRpb25zJGRlZmF1bHREZWNvciA6IGNyZWF0ZUF1dG9Bbm5vdGF0aW9uKG9wdGlvbnMpIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0RW5oYW5jZXJGcm9tQW5ub3RhdGlvbihhbm5vdGF0aW9uKSB7XG4gIHZhciBfYW5ub3RhdGlvbiRvcHRpb25zXyQsIF9hbm5vdGF0aW9uJG9wdGlvbnNfO1xuXG4gIHJldHVybiAhYW5ub3RhdGlvbiA/IGRlZXBFbmhhbmNlciA6IChfYW5ub3RhdGlvbiRvcHRpb25zXyQgPSAoX2Fubm90YXRpb24kb3B0aW9uc18gPSBhbm5vdGF0aW9uLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX2Fubm90YXRpb24kb3B0aW9uc18uZW5oYW5jZXIpICE9IG51bGwgPyBfYW5ub3RhdGlvbiRvcHRpb25zXyQgOiBkZWVwRW5oYW5jZXI7XG59XG4vKipcclxuICogVHVybnMgYW4gb2JqZWN0LCBhcnJheSBvciBmdW5jdGlvbiBpbnRvIGEgcmVhY3RpdmUgc3RydWN0dXJlLlxyXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgd2hpY2ggc2hvdWxkIGJlY29tZSBvYnNlcnZhYmxlLlxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2YWJsZSh2LCBhcmcyLCBhcmczKSB7XG4gIC8vIEBvYnNlcnZhYmxlIHNvbWVQcm9wO1xuICBpZiAoaXNTdHJpbmdpc2goYXJnMikpIHtcbiAgICBzdG9yZUFubm90YXRpb24odiwgYXJnMiwgb2JzZXJ2YWJsZUFubm90YXRpb24pO1xuICAgIHJldHVybjtcbiAgfSAvLyBhbHJlYWR5IG9ic2VydmFibGUgLSBpZ25vcmVcblxuXG4gIGlmIChpc09ic2VydmFibGUodikpIHJldHVybiB2OyAvLyBwbGFpbiBvYmplY3RcblxuICBpZiAoaXNQbGFpbk9iamVjdCh2KSkgcmV0dXJuIG9ic2VydmFibGUub2JqZWN0KHYsIGFyZzIsIGFyZzMpOyAvLyBBcnJheVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5hcnJheSh2LCBhcmcyKTsgLy8gTWFwXG5cbiAgaWYgKGlzRVM2TWFwKHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5tYXAodiwgYXJnMik7IC8vIFNldFxuXG4gIGlmIChpc0VTNlNldCh2KSkgcmV0dXJuIG9ic2VydmFibGUuc2V0KHYsIGFyZzIpOyAvLyBvdGhlciBvYmplY3QgLSBpZ25vcmVcblxuICBpZiAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPT0gbnVsbCkgcmV0dXJuIHY7IC8vIGFueXRoaW5nIGVsc2VcblxuICByZXR1cm4gb2JzZXJ2YWJsZS5ib3godiwgYXJnMik7XG59XG5cbk9iamVjdC5hc3NpZ24oY3JlYXRlT2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZURlY29yYXRvckFubm90YXRpb24pO1xudmFyIG9ic2VydmFibGVGYWN0b3JpZXMgPSB7XG4gIGJveDogZnVuY3Rpb24gYm94KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdmFyIG8gPSBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVZhbHVlKHZhbHVlLCBnZXRFbmhhbmNlckZyb21PcHRpb25zKG8pLCBvLm5hbWUsIHRydWUsIG8uZXF1YWxzKTtcbiAgfSxcbiAgYXJyYXk6IGZ1bmN0aW9uIGFycmF5KGluaXRpYWxWYWx1ZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgbyA9IGFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIChnbG9iYWxTdGF0ZS51c2VQcm94aWVzID09PSBmYWxzZSB8fCBvLnByb3h5ID09PSBmYWxzZSA/IGNyZWF0ZUxlZ2FjeUFycmF5IDogY3JlYXRlT2JzZXJ2YWJsZUFycmF5KShpbml0aWFsVmFsdWVzLCBnZXRFbmhhbmNlckZyb21PcHRpb25zKG8pLCBvLm5hbWUpO1xuICB9LFxuICBtYXA6IGZ1bmN0aW9uIG1hcChpbml0aWFsVmFsdWVzLCBvcHRpb25zKSB7XG4gICAgdmFyIG8gPSBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZU1hcChpbml0aWFsVmFsdWVzLCBnZXRFbmhhbmNlckZyb21PcHRpb25zKG8pLCBvLm5hbWUpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChpbml0aWFsVmFsdWVzLCBvcHRpb25zKSB7XG4gICAgdmFyIG8gPSBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVNldChpbml0aWFsVmFsdWVzLCBnZXRFbmhhbmNlckZyb21PcHRpb25zKG8pLCBvLm5hbWUpO1xuICB9LFxuICBvYmplY3Q6IGZ1bmN0aW9uIG9iamVjdChwcm9wcywgZGVjb3JhdG9ycywgb3B0aW9ucykge1xuICAgIHJldHVybiBleHRlbmRPYnNlcnZhYmxlKGdsb2JhbFN0YXRlLnVzZVByb3hpZXMgPT09IGZhbHNlIHx8IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnByb3h5KSA9PT0gZmFsc2UgPyBhc09ic2VydmFibGVPYmplY3Qoe30sIG9wdGlvbnMpIDogYXNEeW5hbWljT2JzZXJ2YWJsZU9iamVjdCh7fSwgb3B0aW9ucyksIHByb3BzLCBkZWNvcmF0b3JzKTtcbiAgfSxcbiAgcmVmOiAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlUmVmQW5ub3RhdGlvbiksXG4gIHNoYWxsb3c6IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKG9ic2VydmFibGVTaGFsbG93QW5ub3RhdGlvbiksXG4gIGRlZXA6IG9ic2VydmFibGVEZWNvcmF0b3JBbm5vdGF0aW9uLFxuICBzdHJ1Y3Q6IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKG9ic2VydmFibGVTdHJ1Y3RBbm5vdGF0aW9uKVxufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbnZhciBvYnNlcnZhYmxlID0gLyojX19QVVJFX18qL2Fzc2lnbihjcmVhdGVPYnNlcnZhYmxlLCBvYnNlcnZhYmxlRmFjdG9yaWVzKTtcblxudmFyIENPTVBVVEVEID0gXCJjb21wdXRlZFwiO1xudmFyIENPTVBVVEVEX1NUUlVDVCA9IFwiY29tcHV0ZWQuc3RydWN0XCI7XG52YXIgY29tcHV0ZWRBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbXB1dGVkQW5ub3RhdGlvbihDT01QVVRFRCk7XG52YXIgY29tcHV0ZWRTdHJ1Y3RBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbXB1dGVkQW5ub3RhdGlvbihDT01QVVRFRF9TVFJVQ1QsIHtcbiAgZXF1YWxzOiBjb21wYXJlci5zdHJ1Y3R1cmFsXG59KTtcbi8qKlxyXG4gKiBEZWNvcmF0b3IgZm9yIGNsYXNzIHByb3BlcnRpZXM6IEBjb21wdXRlZCBnZXQgdmFsdWUoKSB7IHJldHVybiBleHByOyB9LlxyXG4gKiBGb3IgbGVnYWN5IHB1cnBvc2VzIGFsc28gaW52b2thYmxlIGFzIEVTNSBvYnNlcnZhYmxlIGNyZWF0ZWQ6IGBjb21wdXRlZCgoKSA9PiBleHByKWA7XHJcbiAqL1xuXG52YXIgY29tcHV0ZWQgPSBmdW5jdGlvbiBjb21wdXRlZChhcmcxLCBhcmcyKSB7XG4gIGlmIChpc1N0cmluZ2lzaChhcmcyKSkge1xuICAgIC8vIEBjb21wdXRlZFxuICAgIHJldHVybiBzdG9yZUFubm90YXRpb24oYXJnMSwgYXJnMiwgY29tcHV0ZWRBbm5vdGF0aW9uKTtcbiAgfVxuXG4gIGlmIChpc1BsYWluT2JqZWN0KGFyZzEpKSB7XG4gICAgLy8gQGNvbXB1dGVkKHsgb3B0aW9ucyB9KVxuICAgIHJldHVybiBjcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGNyZWF0ZUNvbXB1dGVkQW5ub3RhdGlvbihDT01QVVRFRCwgYXJnMSkpO1xuICB9IC8vIGNvbXB1dGVkKGV4cHIsIG9wdGlvbnM/KVxuXG5cbiAge1xuICAgIGlmICghaXNGdW5jdGlvbihhcmcxKSkgZGllKFwiRmlyc3QgYXJndW1lbnQgdG8gYGNvbXB1dGVkYCBzaG91bGQgYmUgYW4gZXhwcmVzc2lvbi5cIik7XG4gICAgaWYgKGlzRnVuY3Rpb24oYXJnMikpIGRpZShcIkEgc2V0dGVyIGFzIHNlY29uZCBhcmd1bWVudCBpcyBubyBsb25nZXIgc3VwcG9ydGVkLCB1c2UgYHsgc2V0OiBmbiB9YCBvcHRpb24gaW5zdGVhZFwiKTtcbiAgfVxuXG4gIHZhciBvcHRzID0gaXNQbGFpbk9iamVjdChhcmcyKSA/IGFyZzIgOiB7fTtcbiAgb3B0cy5nZXQgPSBhcmcxO1xuICBvcHRzLm5hbWUgfHwgKG9wdHMubmFtZSA9IGFyZzEubmFtZSB8fCBcIlwiKTtcbiAgLyogZm9yIGdlbmVyYXRlZCBuYW1lICovXG5cbiAgcmV0dXJuIG5ldyBDb21wdXRlZFZhbHVlKG9wdHMpO1xufTtcbk9iamVjdC5hc3NpZ24oY29tcHV0ZWQsIGNvbXB1dGVkQW5ub3RhdGlvbik7XG5jb21wdXRlZC5zdHJ1Y3QgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihjb21wdXRlZFN0cnVjdEFubm90YXRpb24pO1xuXG52YXIgX2dldERlc2NyaXB0b3IkY29uZmlnLCBfZ2V0RGVzY3JpcHRvcjtcbi8vIG1vYnggdmVyc2lvbnNcblxudmFyIGN1cnJlbnRBY3Rpb25JZCA9IDA7XG52YXIgbmV4dEFjdGlvbklkID0gMTtcbnZhciBpc0Z1bmN0aW9uTmFtZUNvbmZpZ3VyYWJsZSA9IChfZ2V0RGVzY3JpcHRvciRjb25maWcgPSAoX2dldERlc2NyaXB0b3IgPSAvKiNfX1BVUkVfXyovZ2V0RGVzY3JpcHRvcihmdW5jdGlvbiAoKSB7fSwgXCJuYW1lXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX2dldERlc2NyaXB0b3IuY29uZmlndXJhYmxlKSAhPSBudWxsID8gX2dldERlc2NyaXB0b3IkY29uZmlnIDogZmFsc2U7IC8vIHdlIGNhbiBzYWZlbHkgcmVjeWNsZSB0aGlzIG9iamVjdFxuXG52YXIgdG1wTmFtZURlc2NyaXB0b3IgPSB7XG4gIHZhbHVlOiBcImFjdGlvblwiLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogZmFsc2Vcbn07XG5mdW5jdGlvbiBjcmVhdGVBY3Rpb24oYWN0aW9uTmFtZSwgZm4sIGF1dG9BY3Rpb24sIHJlZikge1xuICBpZiAoYXV0b0FjdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgYXV0b0FjdGlvbiA9IGZhbHNlO1xuICB9XG5cbiAge1xuICAgIGlmICghaXNGdW5jdGlvbihmbikpIGRpZShcImBhY3Rpb25gIGNhbiBvbmx5IGJlIGludm9rZWQgb24gZnVuY3Rpb25zXCIpO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uTmFtZSAhPT0gXCJzdHJpbmdcIiB8fCAhYWN0aW9uTmFtZSkgZGllKFwiYWN0aW9ucyBzaG91bGQgaGF2ZSB2YWxpZCBuYW1lcywgZ290OiAnXCIgKyBhY3Rpb25OYW1lICsgXCInXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzKCkge1xuICAgIHJldHVybiBleGVjdXRlQWN0aW9uKGFjdGlvbk5hbWUsIGF1dG9BY3Rpb24sIGZuLCByZWYgfHwgdGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJlcy5pc01vYnhBY3Rpb24gPSB0cnVlO1xuXG4gIGlmIChpc0Z1bmN0aW9uTmFtZUNvbmZpZ3VyYWJsZSkge1xuICAgIHRtcE5hbWVEZXNjcmlwdG9yLnZhbHVlID0gYWN0aW9uTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzLCBcIm5hbWVcIiwgdG1wTmFtZURlc2NyaXB0b3IpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVBY3Rpb24oYWN0aW9uTmFtZSwgY2FuUnVuQXNEZXJpdmF0aW9uLCBmbiwgc2NvcGUsIGFyZ3MpIHtcbiAgdmFyIHJ1bkluZm8gPSBfc3RhcnRBY3Rpb24oYWN0aW9uTmFtZSwgY2FuUnVuQXNEZXJpdmF0aW9uLCBzY29wZSwgYXJncyk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4uYXBwbHkoc2NvcGUsIGFyZ3MpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBydW5JbmZvLmVycm9yXyA9IGVycjtcbiAgICB0aHJvdyBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgX2VuZEFjdGlvbihydW5JbmZvKTtcbiAgfVxufVxuZnVuY3Rpb24gX3N0YXJ0QWN0aW9uKGFjdGlvbk5hbWUsIGNhblJ1bkFzRGVyaXZhdGlvbiwgLy8gdHJ1ZSBmb3IgYXV0b0FjdGlvblxuc2NvcGUsIGFyZ3MpIHtcbiAgdmFyIG5vdGlmeVNweV8gPSAgaXNTcHlFbmFibGVkKCkgJiYgISFhY3Rpb25OYW1lO1xuICB2YXIgc3RhcnRUaW1lXyA9IDA7XG5cbiAgaWYgKCBub3RpZnlTcHlfKSB7XG4gICAgc3RhcnRUaW1lXyA9IERhdGUubm93KCk7XG4gICAgdmFyIGZsYXR0ZW5lZEFyZ3MgPSBhcmdzID8gQXJyYXkuZnJvbShhcmdzKSA6IEVNUFRZX0FSUkFZO1xuICAgIHNweVJlcG9ydFN0YXJ0KHtcbiAgICAgIHR5cGU6IEFDVElPTixcbiAgICAgIG5hbWU6IGFjdGlvbk5hbWUsXG4gICAgICBvYmplY3Q6IHNjb3BlLFxuICAgICAgYXJndW1lbnRzOiBmbGF0dGVuZWRBcmdzXG4gICAgfSk7XG4gIH1cblxuICB2YXIgcHJldkRlcml2YXRpb25fID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuICB2YXIgcnVuQXNBY3Rpb24gPSAhY2FuUnVuQXNEZXJpdmF0aW9uIHx8ICFwcmV2RGVyaXZhdGlvbl87XG4gIHN0YXJ0QmF0Y2goKTtcbiAgdmFyIHByZXZBbGxvd1N0YXRlQ2hhbmdlc18gPSBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlczsgLy8gYnkgZGVmYXVsdCBwcmVzZXJ2ZSBwcmV2aW91cyBhbGxvd1xuXG4gIGlmIChydW5Bc0FjdGlvbikge1xuICAgIHVudHJhY2tlZFN0YXJ0KCk7XG4gICAgcHJldkFsbG93U3RhdGVDaGFuZ2VzXyA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQodHJ1ZSk7XG4gIH1cblxuICB2YXIgcHJldkFsbG93U3RhdGVSZWFkc18gPSBhbGxvd1N0YXRlUmVhZHNTdGFydCh0cnVlKTtcbiAgdmFyIHJ1bkluZm8gPSB7XG4gICAgcnVuQXNBY3Rpb25fOiBydW5Bc0FjdGlvbixcbiAgICBwcmV2RGVyaXZhdGlvbl86IHByZXZEZXJpdmF0aW9uXyxcbiAgICBwcmV2QWxsb3dTdGF0ZUNoYW5nZXNfOiBwcmV2QWxsb3dTdGF0ZUNoYW5nZXNfLFxuICAgIHByZXZBbGxvd1N0YXRlUmVhZHNfOiBwcmV2QWxsb3dTdGF0ZVJlYWRzXyxcbiAgICBub3RpZnlTcHlfOiBub3RpZnlTcHlfLFxuICAgIHN0YXJ0VGltZV86IHN0YXJ0VGltZV8sXG4gICAgYWN0aW9uSWRfOiBuZXh0QWN0aW9uSWQrKyxcbiAgICBwYXJlbnRBY3Rpb25JZF86IGN1cnJlbnRBY3Rpb25JZFxuICB9O1xuICBjdXJyZW50QWN0aW9uSWQgPSBydW5JbmZvLmFjdGlvbklkXztcbiAgcmV0dXJuIHJ1bkluZm87XG59XG5mdW5jdGlvbiBfZW5kQWN0aW9uKHJ1bkluZm8pIHtcbiAgaWYgKGN1cnJlbnRBY3Rpb25JZCAhPT0gcnVuSW5mby5hY3Rpb25JZF8pIHtcbiAgICBkaWUoMzApO1xuICB9XG5cbiAgY3VycmVudEFjdGlvbklkID0gcnVuSW5mby5wYXJlbnRBY3Rpb25JZF87XG5cbiAgaWYgKHJ1bkluZm8uZXJyb3JfICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbG9iYWxTdGF0ZS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzID0gdHJ1ZTtcbiAgfVxuXG4gIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHJ1bkluZm8ucHJldkFsbG93U3RhdGVDaGFuZ2VzXyk7XG4gIGFsbG93U3RhdGVSZWFkc0VuZChydW5JbmZvLnByZXZBbGxvd1N0YXRlUmVhZHNfKTtcbiAgZW5kQmF0Y2goKTtcbiAgaWYgKHJ1bkluZm8ucnVuQXNBY3Rpb25fKSB1bnRyYWNrZWRFbmQocnVuSW5mby5wcmV2RGVyaXZhdGlvbl8pO1xuXG4gIGlmICggcnVuSW5mby5ub3RpZnlTcHlfKSB7XG4gICAgc3B5UmVwb3J0RW5kKHtcbiAgICAgIHRpbWU6IERhdGUubm93KCkgLSBydW5JbmZvLnN0YXJ0VGltZV9cbiAgICB9KTtcbiAgfVxuXG4gIGdsb2JhbFN0YXRlLnN1cHByZXNzUmVhY3Rpb25FcnJvcnMgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVDaGFuZ2VzKGFsbG93U3RhdGVDaGFuZ2VzLCBmdW5jKSB7XG4gIHZhciBwcmV2ID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydChhbGxvd1N0YXRlQ2hhbmdlcyk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZnVuYygpO1xuICB9IGZpbmFsbHkge1xuICAgIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHByZXYpO1xuICB9XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KGFsbG93U3RhdGVDaGFuZ2VzKSB7XG4gIHZhciBwcmV2ID0gZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXM7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gYWxsb3dTdGF0ZUNoYW5nZXM7XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldikge1xuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyA9IHByZXY7XG59XG5cbnZhciBfU3ltYm9sJHRvUHJpbWl0aXZlO1xudmFyIENSRUFURSA9IFwiY3JlYXRlXCI7XG5fU3ltYm9sJHRvUHJpbWl0aXZlID0gU3ltYm9sLnRvUHJpbWl0aXZlO1xudmFyIE9ic2VydmFibGVWYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0F0b20pIHtcbiAgX2luaGVyaXRzTG9vc2UoT2JzZXJ2YWJsZVZhbHVlLCBfQXRvbSk7XG5cbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZVZhbHVlKHZhbHVlLCBlbmhhbmNlciwgbmFtZV8sIG5vdGlmeVNweSwgZXF1YWxzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKG5hbWVfID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWVfID0gIFwiT2JzZXJ2YWJsZVZhbHVlQFwiICsgZ2V0TmV4dElkKCkgO1xuICAgIH1cblxuICAgIGlmIChub3RpZnlTcHkgPT09IHZvaWQgMCkge1xuICAgICAgbm90aWZ5U3B5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZXF1YWxzID09PSB2b2lkIDApIHtcbiAgICAgIGVxdWFscyA9IGNvbXBhcmVyW1wiZGVmYXVsdFwiXTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9BdG9tLmNhbGwodGhpcywgbmFtZV8pIHx8IHRoaXM7XG4gICAgX3RoaXMuZW5oYW5jZXIgPSB2b2lkIDA7XG4gICAgX3RoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgX3RoaXMuZXF1YWxzID0gdm9pZCAwO1xuICAgIF90aGlzLmhhc1VucmVwb3J0ZWRDaGFuZ2VfID0gZmFsc2U7XG4gICAgX3RoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICBfdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIF90aGlzLnZhbHVlXyA9IHZvaWQgMDtcbiAgICBfdGhpcy5kZWhhbmNlciA9IHZvaWQgMDtcbiAgICBfdGhpcy5lbmhhbmNlciA9IGVuaGFuY2VyO1xuICAgIF90aGlzLm5hbWVfID0gbmFtZV87XG4gICAgX3RoaXMuZXF1YWxzID0gZXF1YWxzO1xuICAgIF90aGlzLnZhbHVlXyA9IGVuaGFuY2VyKHZhbHVlLCB1bmRlZmluZWQsIG5hbWVfKTtcblxuICAgIGlmICggbm90aWZ5U3B5ICYmIGlzU3B5RW5hYmxlZCgpKSB7XG4gICAgICAvLyBvbmx5IG5vdGlmeSBzcHkgaWYgdGhpcyBpcyBhIHN0YW5kLWFsb25lIG9ic2VydmFibGVcbiAgICAgIHNweVJlcG9ydCh7XG4gICAgICAgIHR5cGU6IENSRUFURSxcbiAgICAgICAgb2JqZWN0OiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSxcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwidmFsdWVcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiBfdGhpcy5uYW1lXyxcbiAgICAgICAgbmV3VmFsdWU6IFwiXCIgKyBfdGhpcy52YWx1ZV9cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBPYnNlcnZhYmxlVmFsdWUucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZWhhbmNlVmFsdWUgPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5kZWhhbmNlcih2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICBuZXdWYWx1ZSA9IHRoaXMucHJlcGFyZU5ld1ZhbHVlXyhuZXdWYWx1ZSk7XG5cbiAgICBpZiAobmV3VmFsdWUgIT09IGdsb2JhbFN0YXRlLlVOQ0hBTkdFRCkge1xuICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuXG4gICAgICBpZiAoIG5vdGlmeVNweSkge1xuICAgICAgICBzcHlSZXBvcnRTdGFydCh7XG4gICAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJ2YWx1ZVwiLFxuICAgICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldE5ld1ZhbHVlXyhuZXdWYWx1ZSk7XG4gICAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wcmVwYXJlTmV3VmFsdWVfID0gZnVuY3Rpb24gcHJlcGFyZU5ld1ZhbHVlXyhuZXdWYWx1ZSkge1xuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMpO1xuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQ7XG4gICAgICBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICB9IC8vIGFwcGx5IG1vZGlmaWVyXG5cblxuICAgIG5ld1ZhbHVlID0gdGhpcy5lbmhhbmNlcihuZXdWYWx1ZSwgdGhpcy52YWx1ZV8sIHRoaXMubmFtZV8pO1xuICAgIHJldHVybiB0aGlzLmVxdWFscyh0aGlzLnZhbHVlXywgbmV3VmFsdWUpID8gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEIDogbmV3VmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLnNldE5ld1ZhbHVlXyA9IGZ1bmN0aW9uIHNldE5ld1ZhbHVlXyhuZXdWYWx1ZSkge1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgIHRoaXMudmFsdWVfID0gbmV3VmFsdWU7XG4gICAgdGhpcy5yZXBvcnRDaGFuZ2VkKCk7XG5cbiAgICBpZiAoaGFzTGlzdGVuZXJzKHRoaXMpKSB7XG4gICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywge1xuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICAgIHRoaXMucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWUodGhpcy52YWx1ZV8pO1xuICB9O1xuXG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG5cbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIGlmIChmaXJlSW1tZWRpYXRlbHkpIGxpc3RlbmVyKHtcbiAgICAgIG9ic2VydmFibGVLaW5kOiBcInZhbHVlXCIsXG4gICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICB0eXBlOiBVUERBVEUsXG4gICAgICBuZXdWYWx1ZTogdGhpcy52YWx1ZV8sXG4gICAgICBvbGRWYWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xuICB9O1xuXG4gIF9wcm90by5yYXcgPSBmdW5jdGlvbiByYXcoKSB7XG4gICAgLy8gdXNlZCBieSBNU1Qgb3QgZ2V0IHVuZGVoYW5jZWQgdmFsdWVcbiAgICByZXR1cm4gdGhpcy52YWx1ZV87XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXyArIFwiW1wiICsgdGhpcy52YWx1ZV8gKyBcIl1cIjtcbiAgfTtcblxuICBfcHJvdG8udmFsdWVPZiA9IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRvUHJpbWl0aXZlKHRoaXMuZ2V0KCkpO1xuICB9O1xuXG4gIF9wcm90b1tfU3ltYm9sJHRvUHJpbWl0aXZlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gIH07XG5cbiAgcmV0dXJuIE9ic2VydmFibGVWYWx1ZTtcbn0oQXRvbSk7XG52YXIgaXNPYnNlcnZhYmxlVmFsdWUgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVWYWx1ZVwiLCBPYnNlcnZhYmxlVmFsdWUpO1xuXG52YXIgX1N5bWJvbCR0b1ByaW1pdGl2ZSQxO1xuLyoqXHJcbiAqIEEgbm9kZSBpbiB0aGUgc3RhdGUgZGVwZW5kZW5jeSByb290IHRoYXQgb2JzZXJ2ZXMgb3RoZXIgbm9kZXMsIGFuZCBjYW4gYmUgb2JzZXJ2ZWQgaXRzZWxmLlxyXG4gKlxyXG4gKiBDb21wdXRlZFZhbHVlIHdpbGwgcmVtZW1iZXIgdGhlIHJlc3VsdCBvZiB0aGUgY29tcHV0YXRpb24gZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYmF0Y2gsIG9yXHJcbiAqIHdoaWxlIGJlaW5nIG9ic2VydmVkLlxyXG4gKlxyXG4gKiBEdXJpbmcgdGhpcyB0aW1lIGl0IHdpbGwgcmVjb21wdXRlIG9ubHkgd2hlbiBvbmUgb2YgaXRzIGRpcmVjdCBkZXBlbmRlbmNpZXMgY2hhbmdlZCxcclxuICogYnV0IG9ubHkgd2hlbiBpdCBpcyBiZWluZyBhY2Nlc3NlZCB3aXRoIGBDb21wdXRlZFZhbHVlLmdldCgpYC5cclxuICpcclxuICogSW1wbGVtZW50YXRpb24gZGVzY3JpcHRpb246XHJcbiAqIDEuIEZpcnN0IHRpbWUgaXQncyBiZWluZyBhY2Nlc3NlZCBpdCB3aWxsIGNvbXB1dGUgYW5kIHJlbWVtYmVyIHJlc3VsdFxyXG4gKiAgICBnaXZlIGJhY2sgcmVtZW1iZXJlZCByZXN1bHQgdW50aWwgMi4gaGFwcGVuc1xyXG4gKiAyLiBGaXJzdCB0aW1lIGFueSBkZWVwIGRlcGVuZGVuY3kgY2hhbmdlLCBwcm9wYWdhdGUgUE9TU0lCTFlfU1RBTEUgdG8gYWxsIG9ic2VydmVycywgd2FpdCBmb3IgMy5cclxuICogMy4gV2hlbiBpdCdzIGJlaW5nIGFjY2Vzc2VkLCByZWNvbXB1dGUgaWYgYW55IHNoYWxsb3cgZGVwZW5kZW5jeSBjaGFuZ2VkLlxyXG4gKiAgICBpZiByZXN1bHQgY2hhbmdlZDogcHJvcGFnYXRlIFNUQUxFIHRvIGFsbCBvYnNlcnZlcnMsIHRoYXQgd2VyZSBQT1NTSUJMWV9TVEFMRSBmcm9tIHRoZSBsYXN0IHN0ZXAuXHJcbiAqICAgIGdvIHRvIHN0ZXAgMi4gZWl0aGVyIHdheVxyXG4gKlxyXG4gKiBJZiBhdCBhbnkgcG9pbnQgaXQncyBvdXRzaWRlIGJhdGNoIGFuZCBpdCBpc24ndCBvYnNlcnZlZDogcmVzZXQgZXZlcnl0aGluZyBhbmQgZ28gdG8gMS5cclxuICovXG5cbl9TeW1ib2wkdG9QcmltaXRpdmUkMSA9IFN5bWJvbC50b1ByaW1pdGl2ZTtcbnZhciBDb21wdXRlZFZhbHVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gbm9kZXMgd2UgYXJlIGxvb2tpbmcgYXQuIE91ciB2YWx1ZSBkZXBlbmRzIG9uIHRoZXNlIG5vZGVzXG4gIC8vIGR1cmluZyB0cmFja2luZyBpdCdzIGFuIGFycmF5IHdpdGggbmV3IG9ic2VydmVkIG9ic2VydmVyc1xuICAvLyB0byBjaGVjayBmb3IgY3ljbGVzXG4gIC8vIE4uQjogdW5taW5pZmllZCBhcyBpdCBpcyB1c2VkIGJ5IE1TVFxuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBjb21wdXRlZCB2YWx1ZSBiYXNlZCBvbiBhIGZ1bmN0aW9uIGV4cHJlc3Npb24uXHJcbiAgICpcclxuICAgKiBUaGUgYG5hbWVgIHByb3BlcnR5IGlzIGZvciBkZWJ1ZyBwdXJwb3NlcyBvbmx5LlxyXG4gICAqXHJcbiAgICogVGhlIGBlcXVhbHNgIHByb3BlcnR5IHNwZWNpZmllcyB0aGUgY29tcGFyZXIgZnVuY3Rpb24gdG8gdXNlIHRvIGRldGVybWluZSBpZiBhIG5ld2x5IHByb2R1Y2VkXHJcbiAgICogdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBwcmV2aW91cyB2YWx1ZS4gVHdvIGNvbXBhcmVycyBhcmUgcHJvdmlkZWQgaW4gdGhlIGxpYnJhcnk7IGBkZWZhdWx0Q29tcGFyZXJgXHJcbiAgICogY29tcGFyZXMgYmFzZWQgb24gaWRlbnRpdHkgY29tcGFyaXNvbiAoPT09KSwgYW5kIGBzdHJ1Y3R1cmFsQ29tcGFyZXJgIGRlZXBseSBjb21wYXJlcyB0aGUgc3RydWN0dXJlLlxyXG4gICAqIFN0cnVjdHVyYWwgY29tcGFyaXNvbiBjYW4gYmUgY29udmVuaWVudCBpZiB5b3UgYWx3YXlzIHByb2R1Y2UgYSBuZXcgYWdncmVnYXRlZCBvYmplY3QgYW5kXHJcbiAgICogZG9uJ3Qgd2FudCB0byBub3RpZnkgb2JzZXJ2ZXJzIGlmIGl0IGlzIHN0cnVjdHVyYWxseSB0aGUgc2FtZS5cclxuICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3Igd29ya2luZyB3aXRoIHZlY3RvcnMsIG1vdXNlIGNvb3JkaW5hdGVzIGV0Yy5cclxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcHV0ZWRWYWx1ZShvcHRpb25zKSB7XG4gICAgdGhpcy5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfO1xuICAgIHRoaXMub2JzZXJ2aW5nXyA9IFtdO1xuICAgIHRoaXMubmV3T2JzZXJ2aW5nXyA9IG51bGw7XG4gICAgdGhpcy5pc0JlaW5nT2JzZXJ2ZWRfID0gZmFsc2U7XG4gICAgdGhpcy5pc1BlbmRpbmdVbm9ic2VydmF0aW9uXyA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXJzXyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmRpZmZWYWx1ZV8gPSAwO1xuICAgIHRoaXMucnVuSWRfID0gMDtcbiAgICB0aGlzLmxhc3RBY2Nlc3NlZEJ5XyA9IDA7XG4gICAgdGhpcy5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfO1xuICAgIHRoaXMudW5ib3VuZERlcHNDb3VudF8gPSAwO1xuICAgIHRoaXMudmFsdWVfID0gbmV3IENhdWdodEV4Y2VwdGlvbihudWxsKTtcbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXMudHJpZ2dlcmVkQnlfID0gdm9pZCAwO1xuICAgIHRoaXMuaXNDb21wdXRpbmdfID0gZmFsc2U7XG4gICAgdGhpcy5pc1J1bm5pbmdTZXR0ZXJfID0gZmFsc2U7XG4gICAgdGhpcy5kZXJpdmF0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuc2V0dGVyXyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzVHJhY2luZ18gPSBUcmFjZU1vZGUuTk9ORTtcbiAgICB0aGlzLnNjb3BlXyA9IHZvaWQgMDtcbiAgICB0aGlzLmVxdWFsc18gPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1aXJlc1JlYWN0aW9uXyA9IHZvaWQgMDtcbiAgICB0aGlzLmtlZXBBbGl2ZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5vbkJPTCA9IHZvaWQgMDtcbiAgICB0aGlzLm9uQlVPTCA9IHZvaWQgMDtcbiAgICBpZiAoIW9wdGlvbnMuZ2V0KSBkaWUoMzEpO1xuICAgIHRoaXMuZGVyaXZhdGlvbiA9IG9wdGlvbnMuZ2V0O1xuICAgIHRoaXMubmFtZV8gPSBvcHRpb25zLm5hbWUgfHwgKCBcIkNvbXB1dGVkVmFsdWVAXCIgKyBnZXROZXh0SWQoKSApO1xuXG4gICAgaWYgKG9wdGlvbnMuc2V0KSB7XG4gICAgICB0aGlzLnNldHRlcl8gPSBjcmVhdGVBY3Rpb24oIHRoaXMubmFtZV8gKyBcIi1zZXR0ZXJcIiAsIG9wdGlvbnMuc2V0KTtcbiAgICB9XG5cbiAgICB0aGlzLmVxdWFsc18gPSBvcHRpb25zLmVxdWFscyB8fCAob3B0aW9ucy5jb21wYXJlU3RydWN0dXJhbCB8fCBvcHRpb25zLnN0cnVjdCA/IGNvbXBhcmVyLnN0cnVjdHVyYWwgOiBjb21wYXJlcltcImRlZmF1bHRcIl0pO1xuICAgIHRoaXMuc2NvcGVfID0gb3B0aW9ucy5jb250ZXh0O1xuICAgIHRoaXMucmVxdWlyZXNSZWFjdGlvbl8gPSAhIW9wdGlvbnMucmVxdWlyZXNSZWFjdGlvbjtcbiAgICB0aGlzLmtlZXBBbGl2ZV8gPSAhIW9wdGlvbnMua2VlcEFsaXZlO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENvbXB1dGVkVmFsdWUucHJvdG90eXBlO1xuXG4gIF9wcm90by5vbkJlY29tZVN0YWxlXyA9IGZ1bmN0aW9uIG9uQmVjb21lU3RhbGVfKCkge1xuICAgIHByb3BhZ2F0ZU1heWJlQ2hhbmdlZCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ub25CTyA9IGZ1bmN0aW9uIG9uQk8oKSB7XG4gICAgaWYgKHRoaXMub25CT0wpIHtcbiAgICAgIHRoaXMub25CT0wuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uQlVPID0gZnVuY3Rpb24gb25CVU8oKSB7XG4gICAgaWYgKHRoaXMub25CVU9MKSB7XG4gICAgICB0aGlzLm9uQlVPTC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoaXMgY29tcHV0ZWQgdmFsdWUuXHJcbiAgICogV2lsbCBldmFsdWF0ZSBpdHMgY29tcHV0YXRpb24gZmlyc3QgaWYgbmVlZGVkLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5pc0NvbXB1dGluZ18pIGRpZSgzMiwgdGhpcy5uYW1lXywgdGhpcy5kZXJpdmF0aW9uKTtcblxuICAgIGlmIChnbG9iYWxTdGF0ZS5pbkJhdGNoID09PSAwICYmIC8vICFnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRwaW9uICYmXG4gICAgdGhpcy5vYnNlcnZlcnNfLnNpemUgPT09IDAgJiYgIXRoaXMua2VlcEFsaXZlXykge1xuICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpIHtcbiAgICAgICAgdGhpcy53YXJuQWJvdXRVbnRyYWNrZWRSZWFkXygpO1xuICAgICAgICBzdGFydEJhdGNoKCk7IC8vIFNlZSBwZXJmIHRlc3QgJ2NvbXB1dGVkIG1lbW9pemF0aW9uJ1xuXG4gICAgICAgIHRoaXMudmFsdWVfID0gdGhpcy5jb21wdXRlVmFsdWVfKGZhbHNlKTtcbiAgICAgICAgZW5kQmF0Y2goKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVwb3J0T2JzZXJ2ZWQodGhpcyk7XG5cbiAgICAgIGlmIChzaG91bGRDb21wdXRlKHRoaXMpKSB7XG4gICAgICAgIHZhciBwcmV2VHJhY2tpbmdDb250ZXh0ID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0O1xuICAgICAgICBpZiAodGhpcy5rZWVwQWxpdmVfICYmICFwcmV2VHJhY2tpbmdDb250ZXh0KSBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy50cmFja0FuZENvbXB1dGUoKSkgcHJvcGFnYXRlQ2hhbmdlQ29uZmlybWVkKHRoaXMpO1xuICAgICAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSBwcmV2VHJhY2tpbmdDb250ZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0aGlzLnZhbHVlXztcbiAgICBpZiAoaXNDYXVnaHRFeGNlcHRpb24ocmVzdWx0KSkgdGhyb3cgcmVzdWx0LmNhdXNlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnNldHRlcl8pIHtcbiAgICAgIGlmICh0aGlzLmlzUnVubmluZ1NldHRlcl8pIGRpZSgzMywgdGhpcy5uYW1lXyk7XG4gICAgICB0aGlzLmlzUnVubmluZ1NldHRlcl8gPSB0cnVlO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNldHRlcl8uY2FsbCh0aGlzLnNjb3BlXywgdmFsdWUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmdTZXR0ZXJfID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGRpZSgzNCwgdGhpcy5uYW1lXyk7XG4gIH07XG5cbiAgX3Byb3RvLnRyYWNrQW5kQ29tcHV0ZSA9IGZ1bmN0aW9uIHRyYWNrQW5kQ29tcHV0ZSgpIHtcbiAgICAvLyBOLkI6IHVubWluaWZpZWQgYXMgaXQgaXMgdXNlZCBieSBNU1RcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICB2YXIgd2FzU3VzcGVuZGVkID1cbiAgICAvKiBzZWUgIzEyMDggKi9cbiAgICB0aGlzLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmNvbXB1dGVWYWx1ZV8odHJ1ZSk7XG5cbiAgICBpZiAoIGlzU3B5RW5hYmxlZCgpKSB7XG4gICAgICBzcHlSZXBvcnQoe1xuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJjb21wdXRlZFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIG9iamVjdDogdGhpcy5zY29wZV8sXG4gICAgICAgIHR5cGU6IFwidXBkYXRlXCIsXG4gICAgICAgIG9sZFZhbHVlOiB0aGlzLnZhbHVlXyxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlZCA9IHdhc1N1c3BlbmRlZCB8fCBpc0NhdWdodEV4Y2VwdGlvbihvbGRWYWx1ZSkgfHwgaXNDYXVnaHRFeGNlcHRpb24obmV3VmFsdWUpIHx8ICF0aGlzLmVxdWFsc18ob2xkVmFsdWUsIG5ld1ZhbHVlKTtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLnZhbHVlXyA9IG5ld1ZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9O1xuXG4gIF9wcm90by5jb21wdXRlVmFsdWVfID0gZnVuY3Rpb24gY29tcHV0ZVZhbHVlXyh0cmFjaykge1xuICAgIHRoaXMuaXNDb21wdXRpbmdfID0gdHJ1ZTsgLy8gZG9uJ3QgYWxsb3cgc3RhdGUgY2hhbmdlcyBkdXJpbmcgY29tcHV0YXRpb25cblxuICAgIHZhciBwcmV2ID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydChmYWxzZSk7XG4gICAgdmFyIHJlcztcblxuICAgIGlmICh0cmFjaykge1xuICAgICAgcmVzID0gdHJhY2tEZXJpdmVkRnVuY3Rpb24odGhpcywgdGhpcy5kZXJpdmF0aW9uLCB0aGlzLnNjb3BlXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID09PSB0cnVlKSB7XG4gICAgICAgIHJlcyA9IHRoaXMuZGVyaXZhdGlvbi5jYWxsKHRoaXMuc2NvcGVfKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5kZXJpdmF0aW9uLmNhbGwodGhpcy5zY29wZV8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVzID0gbmV3IENhdWdodEV4Y2VwdGlvbihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHByZXYpO1xuICAgIHRoaXMuaXNDb21wdXRpbmdfID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBfcHJvdG8uc3VzcGVuZF8gPSBmdW5jdGlvbiBzdXNwZW5kXygpIHtcbiAgICBpZiAoIXRoaXMua2VlcEFsaXZlXykge1xuICAgICAgY2xlYXJPYnNlcnZpbmcodGhpcyk7XG4gICAgICB0aGlzLnZhbHVlXyA9IHVuZGVmaW5lZDsgLy8gZG9uJ3QgaG9sZCBvbiB0byBjb21wdXRlZCB2YWx1ZSFcblxuICAgICAgaWYgKCB0aGlzLmlzVHJhY2luZ18gIT09IFRyYWNlTW9kZS5OT05FKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdIENvbXB1dGVkIHZhbHVlICdcIiArIHRoaXMubmFtZV8gKyBcIicgd2FzIHN1c3BlbmRlZCBhbmQgaXQgd2lsbCByZWNvbXB1dGUgb24gdGhlIG5leHQgYWNjZXNzLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcbiAgICB2YXIgcHJldlZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBhdXRvcnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRPRE86IHdoeSBpcyB0aGlzIGluIGEgZGlmZmVyZW50IHBsYWNlIHRoYW4gdGhlIHNweVJlcG9ydCgpIGZ1bmN0aW9uPyBpbiBhbGwgb3RoZXIgb2JzZXJ2YWJsZXMgaXQncyBjYWxsZWQgaW4gdGhlIHNhbWUgcGxhY2VcbiAgICAgIHZhciBuZXdWYWx1ZSA9IF90aGlzLmdldCgpO1xuXG4gICAgICBpZiAoIWZpcnN0VGltZSB8fCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICAgICAgdmFyIHByZXZVID0gdW50cmFja2VkU3RhcnQoKTtcbiAgICAgICAgbGlzdGVuZXIoe1xuICAgICAgICAgIG9ic2VydmFibGVLaW5kOiBcImNvbXB1dGVkXCIsXG4gICAgICAgICAgZGVidWdPYmplY3ROYW1lOiBfdGhpcy5uYW1lXyxcbiAgICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgICAgb2JqZWN0OiBfdGhpcyxcbiAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgb2xkVmFsdWU6IHByZXZWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdW50cmFja2VkRW5kKHByZXZVKTtcbiAgICAgIH1cblxuICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICBwcmV2VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ud2FybkFib3V0VW50cmFja2VkUmVhZF8gPSBmdW5jdGlvbiB3YXJuQWJvdXRVbnRyYWNrZWRSZWFkXygpIHtcblxuICAgIGlmICh0aGlzLmlzVHJhY2luZ18gIT09IFRyYWNlTW9kZS5OT05FKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSBDb21wdXRlZCB2YWx1ZSAnXCIgKyB0aGlzLm5hbWVfICsgXCInIGlzIGJlaW5nIHJlYWQgb3V0c2lkZSBhIHJlYWN0aXZlIGNvbnRleHQuIERvaW5nIGEgZnVsbCByZWNvbXB1dGUuXCIpO1xuICAgIH1cblxuICAgIGlmIChnbG9iYWxTdGF0ZS5jb21wdXRlZFJlcXVpcmVzUmVhY3Rpb24gfHwgdGhpcy5yZXF1aXJlc1JlYWN0aW9uXykge1xuICAgICAgY29uc29sZS53YXJuKFwiW21vYnhdIENvbXB1dGVkIHZhbHVlICdcIiArIHRoaXMubmFtZV8gKyBcIicgaXMgYmVpbmcgcmVhZCBvdXRzaWRlIGEgcmVhY3RpdmUgY29udGV4dC4gRG9pbmcgYSBmdWxsIHJlY29tcHV0ZS5cIik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVfICsgXCJbXCIgKyB0aGlzLmRlcml2YXRpb24udG9TdHJpbmcoKSArIFwiXVwiO1xuICB9O1xuXG4gIF9wcm90by52YWx1ZU9mID0gZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdG9QcmltaXRpdmUodGhpcy5nZXQoKSk7XG4gIH07XG5cbiAgX3Byb3RvW19TeW1ib2wkdG9QcmltaXRpdmUkMV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuICB9O1xuXG4gIHJldHVybiBDb21wdXRlZFZhbHVlO1xufSgpO1xudmFyIGlzQ29tcHV0ZWRWYWx1ZSA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiQ29tcHV0ZWRWYWx1ZVwiLCBDb21wdXRlZFZhbHVlKTtcblxudmFyIElEZXJpdmF0aW9uU3RhdGVfO1xuXG4oZnVuY3Rpb24gKElEZXJpdmF0aW9uU3RhdGVfKSB7XG4gIC8vIGJlZm9yZSBiZWluZyBydW4gb3IgKG91dHNpZGUgYmF0Y2ggYW5kIG5vdCBiZWluZyBvYnNlcnZlZClcbiAgLy8gYXQgdGhpcyBwb2ludCBkZXJpdmF0aW9uIGlzIG5vdCBob2xkaW5nIGFueSBkYXRhIGFib3V0IGRlcGVuZGVuY3kgdHJlZVxuICBJRGVyaXZhdGlvblN0YXRlX1tJRGVyaXZhdGlvblN0YXRlX1tcIk5PVF9UUkFDS0lOR19cIl0gPSAtMV0gPSBcIk5PVF9UUkFDS0lOR19cIjsgLy8gbm8gc2hhbGxvdyBkZXBlbmRlbmN5IGNoYW5nZWQgc2luY2UgbGFzdCBjb21wdXRhdGlvblxuICAvLyB3b24ndCByZWNhbGN1bGF0ZSBkZXJpdmF0aW9uXG4gIC8vIHRoaXMgaXMgd2hhdCBtYWtlcyBtb2J4IGZhc3RcblxuICBJRGVyaXZhdGlvblN0YXRlX1tJRGVyaXZhdGlvblN0YXRlX1tcIlVQX1RPX0RBVEVfXCJdID0gMF0gPSBcIlVQX1RPX0RBVEVfXCI7IC8vIHNvbWUgZGVlcCBkZXBlbmRlbmN5IGNoYW5nZWQsIGJ1dCBkb24ndCBrbm93IGlmIHNoYWxsb3cgZGVwZW5kZW5jeSBjaGFuZ2VkXG4gIC8vIHdpbGwgcmVxdWlyZSB0byBjaGVjayBmaXJzdCBpZiBVUF9UT19EQVRFIG9yIFBPU1NJQkxZX1NUQUxFXG4gIC8vIGN1cnJlbnRseSBvbmx5IENvbXB1dGVkVmFsdWUgd2lsbCBwcm9wYWdhdGUgUE9TU0lCTFlfU1RBTEVcbiAgLy9cbiAgLy8gaGF2aW5nIHRoaXMgc3RhdGUgaXMgc2Vjb25kIGJpZyBvcHRpbWl6YXRpb246XG4gIC8vIGRvbid0IGhhdmUgdG8gcmVjb21wdXRlIG9uIGV2ZXJ5IGRlcGVuZGVuY3kgY2hhbmdlLCBidXQgb25seSB3aGVuIGl0J3MgbmVlZGVkXG5cbiAgSURlcml2YXRpb25TdGF0ZV9bSURlcml2YXRpb25TdGF0ZV9bXCJQT1NTSUJMWV9TVEFMRV9cIl0gPSAxXSA9IFwiUE9TU0lCTFlfU1RBTEVfXCI7IC8vIEEgc2hhbGxvdyBkZXBlbmRlbmN5IGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3QgY29tcHV0YXRpb24gYW5kIHRoZSBkZXJpdmF0aW9uXG4gIC8vIHdpbGwgbmVlZCB0byByZWNvbXB1dGUgd2hlbiBpdCdzIG5lZWRlZCBuZXh0LlxuXG4gIElEZXJpdmF0aW9uU3RhdGVfW0lEZXJpdmF0aW9uU3RhdGVfW1wiU1RBTEVfXCJdID0gMl0gPSBcIlNUQUxFX1wiO1xufSkoSURlcml2YXRpb25TdGF0ZV8gfHwgKElEZXJpdmF0aW9uU3RhdGVfID0ge30pKTtcblxudmFyIFRyYWNlTW9kZTtcblxuKGZ1bmN0aW9uIChUcmFjZU1vZGUpIHtcbiAgVHJhY2VNb2RlW1RyYWNlTW9kZVtcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICBUcmFjZU1vZGVbVHJhY2VNb2RlW1wiTE9HXCJdID0gMV0gPSBcIkxPR1wiO1xuICBUcmFjZU1vZGVbVHJhY2VNb2RlW1wiQlJFQUtcIl0gPSAyXSA9IFwiQlJFQUtcIjtcbn0pKFRyYWNlTW9kZSB8fCAoVHJhY2VNb2RlID0ge30pKTtcblxudmFyIENhdWdodEV4Y2VwdGlvbiA9IGZ1bmN0aW9uIENhdWdodEV4Y2VwdGlvbihjYXVzZSkge1xuICB0aGlzLmNhdXNlID0gdm9pZCAwO1xuICB0aGlzLmNhdXNlID0gY2F1c2U7IC8vIEVtcHR5XG59O1xuZnVuY3Rpb24gaXNDYXVnaHRFeGNlcHRpb24oZSkge1xuICByZXR1cm4gZSBpbnN0YW5jZW9mIENhdWdodEV4Y2VwdGlvbjtcbn1cbi8qKlxyXG4gKiBGaW5kcyBvdXQgd2hldGhlciBhbnkgZGVwZW5kZW5jeSBvZiB0aGUgZGVyaXZhdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cclxuICogSWYgZGVwZW5kZW5jaWVzU3RhdGUgaXMgMSB0aGVuIGl0IHdpbGwgcmVjYWxjdWxhdGUgZGVwZW5kZW5jaWVzLFxyXG4gKiBpZiBhbnkgZGVwZW5kZW5jeSBjaGFuZ2VkIGl0IHdpbGwgcHJvcGFnYXRlIGl0IGJ5IGNoYW5naW5nIGRlcGVuZGVuY2llc1N0YXRlIHRvIDIuXHJcbiAqXHJcbiAqIEJ5IGl0ZXJhdGluZyBvdmVyIHRoZSBkZXBlbmRlbmNpZXMgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IHdlcmUgcmVwb3J0ZWQgYW5kXHJcbiAqIHN0b3BwaW5nIG9uIHRoZSBmaXJzdCBjaGFuZ2UsIGFsbCB0aGUgcmVjYWxjdWxhdGlvbnMgYXJlIG9ubHkgY2FsbGVkIGZvciBDb21wdXRlZFZhbHVlc1xyXG4gKiB0aGF0IHdpbGwgYmUgdHJhY2tlZCBieSBkZXJpdmF0aW9uLiBUaGF0IGlzIGJlY2F1c2Ugd2UgYXNzdW1lIHRoYXQgaWYgdGhlIGZpcnN0IHhcclxuICogZGVwZW5kZW5jaWVzIG9mIHRoZSBkZXJpdmF0aW9uIGRvZXNuJ3QgY2hhbmdlIHRoZW4gdGhlIGRlcml2YXRpb24gc2hvdWxkIHJ1biB0aGUgc2FtZSB3YXlcclxuICogdXAgdW50aWwgYWNjZXNzaW5nIHgtdGggZGVwZW5kZW5jeS5cclxuICovXG5cbmZ1bmN0aW9uIHNob3VsZENvbXB1dGUoZGVyaXZhdGlvbikge1xuICBzd2l0Y2ggKGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfKSB7XG4gICAgY2FzZSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXzpcbiAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXzpcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBJRGVyaXZhdGlvblN0YXRlXy5QT1NTSUJMWV9TVEFMRV86XG4gICAgICB7XG4gICAgICAgIC8vIHN0YXRlIHByb3BhZ2F0aW9uIGNhbiBvY2N1ciBvdXRzaWRlIG9mIGFjdGlvbi9yZWFjdGl2ZSBjb250ZXh0ICMyMTk1XG4gICAgICAgIHZhciBwcmV2QWxsb3dTdGF0ZVJlYWRzID0gYWxsb3dTdGF0ZVJlYWRzU3RhcnQodHJ1ZSk7XG4gICAgICAgIHZhciBwcmV2VW50cmFja2VkID0gdW50cmFja2VkU3RhcnQoKTsgLy8gbm8gbmVlZCBmb3IgdGhvc2UgY29tcHV0ZWRzIHRvIGJlIHJlcG9ydGVkLCB0aGV5IHdpbGwgYmUgcGlja2VkIHVwIGluIHRyYWNrRGVyaXZlZEZ1bmN0aW9uLlxuXG4gICAgICAgIHZhciBvYnMgPSBkZXJpdmF0aW9uLm9ic2VydmluZ18sXG4gICAgICAgICAgICBsID0gb2JzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBvYmogPSBvYnNbaV07XG5cbiAgICAgICAgICBpZiAoaXNDb21wdXRlZFZhbHVlKG9iaikpIHtcbiAgICAgICAgICAgIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzKSB7XG4gICAgICAgICAgICAgIG9iai5nZXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2JqLmdldCgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIHRoZSB2YWx1ZSAqb3IqIGV4Y2VwdGlvbiBhdCB0aGlzIG1vbWVudCwgYnV0IGlmIHRoZXJlIGlzIG9uZSwgbm90aWZ5IGFsbFxuICAgICAgICAgICAgICAgIHVudHJhY2tlZEVuZChwcmV2VW50cmFja2VkKTtcbiAgICAgICAgICAgICAgICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gaWYgQ29tcHV0ZWRWYWx1ZSBgb2JqYCBhY3R1YWxseSBjaGFuZ2VkIGl0IHdpbGwgYmUgY29tcHV0ZWQgYW5kIHByb3BhZ2F0ZWQgdG8gaXRzIG9ic2VydmVycy5cbiAgICAgICAgICAgIC8vIGFuZCBgZGVyaXZhdGlvbmAgaXMgYW4gb2JzZXJ2ZXIgb2YgYG9iamBcbiAgICAgICAgICAgIC8vIGludmFyaWFudFNob3VsZENvbXB1dGUoZGVyaXZhdGlvbilcblxuXG4gICAgICAgICAgICBpZiAoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXykge1xuICAgICAgICAgICAgICB1bnRyYWNrZWRFbmQocHJldlVudHJhY2tlZCk7XG4gICAgICAgICAgICAgIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2QWxsb3dTdGF0ZVJlYWRzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hhbmdlRGVwZW5kZW5jaWVzU3RhdGVUbzAoZGVyaXZhdGlvbik7XG4gICAgICAgIHVudHJhY2tlZEVuZChwcmV2VW50cmFja2VkKTtcbiAgICAgICAgYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXZBbGxvd1N0YXRlUmVhZHMpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQ29tcHV0aW5nRGVyaXZhdGlvbigpIHtcbiAgcmV0dXJuIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiAhPT0gbnVsbDsgLy8gZmlsdGVyIG91dCBhY3Rpb25zIGluc2lkZSBjb21wdXRhdGlvbnNcbn1cbmZ1bmN0aW9uIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKGF0b20pIHtcblxuICB2YXIgaGFzT2JzZXJ2ZXJzID0gYXRvbS5vYnNlcnZlcnNfLnNpemUgPiAwOyAvLyBTaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIGNoYW5nZSBvYnNlcnZlZCBzdGF0ZSBvdXRzaWRlIHN0cmljdCBtb2RlLCBleGNlcHQgZHVyaW5nIGluaXRpYWxpemF0aW9uLCBzZWUgIzU2M1xuXG4gIGlmICghZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgJiYgKGhhc09ic2VydmVycyB8fCBnbG9iYWxTdGF0ZS5lbmZvcmNlQWN0aW9ucyA9PT0gXCJhbHdheXNcIikpIGNvbnNvbGUud2FybihcIltNb2JYXSBcIiArIChnbG9iYWxTdGF0ZS5lbmZvcmNlQWN0aW9ucyA/IFwiU2luY2Ugc3RyaWN0LW1vZGUgaXMgZW5hYmxlZCwgY2hhbmdpbmcgKG9ic2VydmVkKSBvYnNlcnZhYmxlIHZhbHVlcyB3aXRob3V0IHVzaW5nIGFuIGFjdGlvbiBpcyBub3QgYWxsb3dlZC4gVHJpZWQgdG8gbW9kaWZ5OiBcIiA6IFwiU2lkZSBlZmZlY3RzIGxpa2UgY2hhbmdpbmcgc3RhdGUgYXJlIG5vdCBhbGxvd2VkIGF0IHRoaXMgcG9pbnQuIEFyZSB5b3UgdHJ5aW5nIHRvIG1vZGlmeSBzdGF0ZSBmcm9tLCBmb3IgZXhhbXBsZSwgYSBjb21wdXRlZCB2YWx1ZSBvciB0aGUgcmVuZGVyIGZ1bmN0aW9uIG9mIGEgUmVhY3QgY29tcG9uZW50PyBZb3UgY2FuIHdyYXAgc2lkZSBlZmZlY3RzIGluICdydW5JbkFjdGlvbicgKG9yIGRlY29yYXRlIGZ1bmN0aW9ucyB3aXRoICdhY3Rpb24nKSBpZiBuZWVkZWQuIFRyaWVkIHRvIG1vZGlmeTogXCIpICsgYXRvbS5uYW1lXyk7XG59XG5mdW5jdGlvbiBjaGVja0lmU3RhdGVSZWFkc0FyZUFsbG93ZWQob2JzZXJ2YWJsZSkge1xuICBpZiAoICFnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHMgJiYgZ2xvYmFsU3RhdGUub2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oXCJbbW9ieF0gT2JzZXJ2YWJsZSAnXCIgKyBvYnNlcnZhYmxlLm5hbWVfICsgXCInIGJlaW5nIHJlYWQgb3V0c2lkZSBhIHJlYWN0aXZlIGNvbnRleHQuXCIpO1xuICB9XG59XG4vKipcclxuICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGBmYCBhbmQgdHJhY2tzIHdoaWNoIG9ic2VydmFibGVzIGFyZSBiZWluZyBhY2Nlc3NlZC5cclxuICogVGhlIHRyYWNraW5nIGluZm9ybWF0aW9uIGlzIHN0b3JlZCBvbiB0aGUgYGRlcml2YXRpb25gIG9iamVjdCBhbmQgdGhlIGRlcml2YXRpb24gaXMgcmVnaXN0ZXJlZFxyXG4gKiBhcyBvYnNlcnZlciBvZiBhbnkgb2YgdGhlIGFjY2Vzc2VkIG9ic2VydmFibGVzLlxyXG4gKi9cblxuZnVuY3Rpb24gdHJhY2tEZXJpdmVkRnVuY3Rpb24oZGVyaXZhdGlvbiwgZiwgY29udGV4dCkge1xuICB2YXIgcHJldkFsbG93U3RhdGVSZWFkcyA9IGFsbG93U3RhdGVSZWFkc1N0YXJ0KHRydWUpOyAvLyBwcmUgYWxsb2NhdGUgYXJyYXkgYWxsb2NhdGlvbiArIHJvb20gZm9yIHZhcmlhdGlvbiBpbiBkZXBzXG4gIC8vIGFycmF5IHdpbGwgYmUgdHJpbW1lZCBieSBiaW5kRGVwZW5kZW5jaWVzXG5cbiAgY2hhbmdlRGVwZW5kZW5jaWVzU3RhdGVUbzAoZGVyaXZhdGlvbik7XG4gIGRlcml2YXRpb24ubmV3T2JzZXJ2aW5nXyA9IG5ldyBBcnJheShkZXJpdmF0aW9uLm9ic2VydmluZ18ubGVuZ3RoICsgMTAwKTtcbiAgZGVyaXZhdGlvbi51bmJvdW5kRGVwc0NvdW50XyA9IDA7XG4gIGRlcml2YXRpb24ucnVuSWRfID0gKytnbG9iYWxTdGF0ZS5ydW5JZDtcbiAgdmFyIHByZXZUcmFja2luZyA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uID0gZGVyaXZhdGlvbjtcbiAgZ2xvYmFsU3RhdGUuaW5CYXRjaCsrO1xuICB2YXIgcmVzdWx0O1xuXG4gIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID09PSB0cnVlKSB7XG4gICAgcmVzdWx0ID0gZi5jYWxsKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBmLmNhbGwoY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVzdWx0ID0gbmV3IENhdWdodEV4Y2VwdGlvbihlKTtcbiAgICB9XG4gIH1cblxuICBnbG9iYWxTdGF0ZS5pbkJhdGNoLS07XG4gIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IHByZXZUcmFja2luZztcbiAgYmluZERlcGVuZGVuY2llcyhkZXJpdmF0aW9uKTtcbiAgd2FybkFib3V0RGVyaXZhdGlvbldpdGhvdXREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbik7XG4gIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2QWxsb3dTdGF0ZVJlYWRzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0RGVyaXZhdGlvbldpdGhvdXREZXBlbmRlbmNpZXMoZGVyaXZhdGlvbikge1xuICBpZiAoZGVyaXZhdGlvbi5vYnNlcnZpbmdfLmxlbmd0aCAhPT0gMCkgcmV0dXJuO1xuXG4gIGlmIChnbG9iYWxTdGF0ZS5yZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZSB8fCBkZXJpdmF0aW9uLnJlcXVpcmVzT2JzZXJ2YWJsZV8pIHtcbiAgICBjb25zb2xlLndhcm4oXCJbbW9ieF0gRGVyaXZhdGlvbiAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIGlzIGNyZWF0ZWQvdXBkYXRlZCB3aXRob3V0IHJlYWRpbmcgYW55IG9ic2VydmFibGUgdmFsdWUuXCIpO1xuICB9XG59XG4vKipcclxuICogZGlmZnMgbmV3T2JzZXJ2aW5nIHdpdGggb2JzZXJ2aW5nLlxyXG4gKiB1cGRhdGUgb2JzZXJ2aW5nIHRvIGJlIG5ld09ic2VydmluZyB3aXRoIHVuaXF1ZSBvYnNlcnZhYmxlc1xyXG4gKiBub3RpZnkgb2JzZXJ2ZXJzIHRoYXQgYmVjb21lIG9ic2VydmVkL3Vub2JzZXJ2ZWRcclxuICovXG5cblxuZnVuY3Rpb24gYmluZERlcGVuZGVuY2llcyhkZXJpdmF0aW9uKSB7XG4gIC8vIGludmFyaWFudChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlICE9PSBJRGVyaXZhdGlvblN0YXRlLk5PVF9UUkFDS0lORywgXCJJTlRFUk5BTCBFUlJPUiBiaW5kRGVwZW5kZW5jaWVzIGV4cGVjdHMgZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZSAhPT0gLTFcIik7XG4gIHZhciBwcmV2T2JzZXJ2aW5nID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfO1xuICB2YXIgb2JzZXJ2aW5nID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfID0gZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmdfO1xuICB2YXIgbG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87IC8vIEdvIHRocm91Z2ggYWxsIG5ldyBvYnNlcnZhYmxlcyBhbmQgY2hlY2sgZGlmZlZhbHVlOiAodGhpcyBsaXN0IGNhbiBjb250YWluIGR1cGxpY2F0ZXMpOlxuICAvLyAgIDA6IGZpcnN0IG9jY3VycmVuY2UsIGNoYW5nZSB0byAxIGFuZCBrZWVwIGl0XG4gIC8vICAgMTogZXh0cmEgb2NjdXJyZW5jZSwgZHJvcCBpdFxuXG4gIHZhciBpMCA9IDAsXG4gICAgICBsID0gZGVyaXZhdGlvbi51bmJvdW5kRGVwc0NvdW50XztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBkZXAgPSBvYnNlcnZpbmdbaV07XG5cbiAgICBpZiAoZGVwLmRpZmZWYWx1ZV8gPT09IDApIHtcbiAgICAgIGRlcC5kaWZmVmFsdWVfID0gMTtcbiAgICAgIGlmIChpMCAhPT0gaSkgb2JzZXJ2aW5nW2kwXSA9IGRlcDtcbiAgICAgIGkwKys7XG4gICAgfSAvLyBVcGNhc3QgaXMgJ3NhZmUnIGhlcmUsIGJlY2F1c2UgaWYgZGVwIGlzIElPYnNlcnZhYmxlLCBgZGVwZW5kZW5jaWVzU3RhdGVgIHdpbGwgYmUgdW5kZWZpbmVkLFxuICAgIC8vIG5vdCBoaXR0aW5nIHRoZSBjb25kaXRpb25cblxuXG4gICAgaWYgKGRlcC5kZXBlbmRlbmNpZXNTdGF0ZV8gPiBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUpIHtcbiAgICAgIGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSA9IGRlcC5kZXBlbmRlbmNpZXNTdGF0ZV87XG4gICAgfVxuICB9XG5cbiAgb2JzZXJ2aW5nLmxlbmd0aCA9IGkwO1xuICBkZXJpdmF0aW9uLm5ld09ic2VydmluZ18gPSBudWxsOyAvLyBuZXdPYnNlcnZpbmcgc2hvdWxkbid0IGJlIG5lZWRlZCBvdXRzaWRlIHRyYWNraW5nIChzdGF0ZW1lbnQgbW92ZWQgZG93biB0byB3b3JrIGFyb3VuZCBGRiBidWcsIHNlZSAjNjE0KVxuICAvLyBHbyB0aHJvdWdoIGFsbCBvbGQgb2JzZXJ2YWJsZXMgYW5kIGNoZWNrIGRpZmZWYWx1ZTogKGl0IGlzIHVuaXF1ZSBhZnRlciBsYXN0IGJpbmREZXBlbmRlbmNpZXMpXG4gIC8vICAgMDogaXQncyBub3QgaW4gbmV3IG9ic2VydmFibGVzLCB1bm9ic2VydmUgaXRcbiAgLy8gICAxOiBpdCBrZWVwcyBiZWluZyBvYnNlcnZlZCwgZG9uJ3Qgd2FudCB0byBub3RpZnkgaXQuIGNoYW5nZSB0byAwXG5cbiAgbCA9IHByZXZPYnNlcnZpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChsLS0pIHtcbiAgICB2YXIgX2RlcCA9IHByZXZPYnNlcnZpbmdbbF07XG5cbiAgICBpZiAoX2RlcC5kaWZmVmFsdWVfID09PSAwKSB7XG4gICAgICByZW1vdmVPYnNlcnZlcihfZGVwLCBkZXJpdmF0aW9uKTtcbiAgICB9XG5cbiAgICBfZGVwLmRpZmZWYWx1ZV8gPSAwO1xuICB9IC8vIEdvIHRocm91Z2ggYWxsIG5ldyBvYnNlcnZhYmxlcyBhbmQgY2hlY2sgZGlmZlZhbHVlOiAobm93IGl0IHNob3VsZCBiZSB1bmlxdWUpXG4gIC8vICAgMDogaXQgd2FzIHNldCB0byAwIGluIGxhc3QgbG9vcC4gZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZy5cbiAgLy8gICAxOiBpdCB3YXNuJ3Qgb2JzZXJ2ZWQsIGxldCdzIG9ic2VydmUgaXQuIHNldCBiYWNrIHRvIDBcblxuXG4gIHdoaWxlIChpMC0tKSB7XG4gICAgdmFyIF9kZXAyID0gb2JzZXJ2aW5nW2kwXTtcblxuICAgIGlmIChfZGVwMi5kaWZmVmFsdWVfID09PSAxKSB7XG4gICAgICBfZGVwMi5kaWZmVmFsdWVfID0gMDtcbiAgICAgIGFkZE9ic2VydmVyKF9kZXAyLCBkZXJpdmF0aW9uKTtcbiAgICB9XG4gIH0gLy8gU29tZSBuZXcgb2JzZXJ2ZWQgZGVyaXZhdGlvbnMgbWF5IGJlY29tZSBzdGFsZSBkdXJpbmcgdGhpcyBkZXJpdmF0aW9uIGNvbXB1dGF0aW9uXG4gIC8vIHNvIHRoZXkgaGF2ZSBoYWQgbm8gY2hhbmNlIHRvIHByb3BhZ2F0ZSBzdGFsZW5lc3MgKCM5MTYpXG5cblxuICBpZiAobG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlICE9PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXykge1xuICAgIGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID0gbG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlO1xuICAgIGRlcml2YXRpb24ub25CZWNvbWVTdGFsZV8oKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhck9ic2VydmluZyhkZXJpdmF0aW9uKSB7XG4gIC8vIGludmFyaWFudChnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCwgXCJJTlRFUk5BTCBFUlJPUiBjbGVhck9ic2VydmluZyBzaG91bGQgYmUgY2FsbGVkIG9ubHkgaW5zaWRlIGJhdGNoXCIpO1xuICB2YXIgb2JzID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfO1xuICBkZXJpdmF0aW9uLm9ic2VydmluZ18gPSBbXTtcbiAgdmFyIGkgPSBvYnMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICByZW1vdmVPYnNlcnZlcihvYnNbaV0sIGRlcml2YXRpb24pO1xuICB9XG5cbiAgZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfO1xufVxuZnVuY3Rpb24gdW50cmFja2VkKGFjdGlvbikge1xuICB2YXIgcHJldiA9IHVudHJhY2tlZFN0YXJ0KCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYWN0aW9uKCk7XG4gIH0gZmluYWxseSB7XG4gICAgdW50cmFja2VkRW5kKHByZXYpO1xuICB9XG59XG5mdW5jdGlvbiB1bnRyYWNrZWRTdGFydCgpIHtcbiAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiA9IG51bGw7XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gdW50cmFja2VkRW5kKHByZXYpIHtcbiAgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uID0gcHJldjtcbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVSZWFkc1N0YXJ0KGFsbG93U3RhdGVSZWFkcykge1xuICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcztcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzID0gYWxsb3dTdGF0ZVJlYWRzO1xuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2KSB7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyA9IHByZXY7XG59XG4vKipcclxuICogbmVlZGVkIHRvIGtlZXAgYGxvd2VzdE9ic2VydmVyU3RhdGVgIGNvcnJlY3QuIHdoZW4gY2hhbmdpbmcgZnJvbSAoMiBvciAxKSB0byAwXHJcbiAqXHJcbiAqL1xuXG5mdW5jdGlvbiBjaGFuZ2VEZXBlbmRlbmNpZXNTdGF0ZVRvMChkZXJpdmF0aW9uKSB7XG4gIGlmIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHJldHVybjtcbiAgZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXztcbiAgdmFyIG9icyA9IGRlcml2YXRpb24ub2JzZXJ2aW5nXztcbiAgdmFyIGkgPSBvYnMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBvYnNbaV0ubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXztcbiAgfVxufVxuXG4vKipcclxuICogVGhlc2UgdmFsdWVzIHdpbGwgcGVyc2lzdCBpZiBnbG9iYWwgc3RhdGUgaXMgcmVzZXRcclxuICovXG5cbnZhciBwZXJzaXN0ZW50S2V5cyA9IFtcIm1vYnhHdWlkXCIsIFwic3B5TGlzdGVuZXJzXCIsIFwiZW5mb3JjZUFjdGlvbnNcIiwgXCJjb21wdXRlZFJlcXVpcmVzUmVhY3Rpb25cIiwgXCJyZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZVwiLCBcIm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uXCIsIFwiYWxsb3dTdGF0ZVJlYWRzXCIsIFwiZGlzYWJsZUVycm9yQm91bmRhcmllc1wiLCBcInJ1bklkXCIsIFwiVU5DSEFOR0VEXCIsIFwidXNlUHJveGllc1wiXTtcbnZhciBNb2JYR2xvYmFscyA9IGZ1bmN0aW9uIE1vYlhHbG9iYWxzKCkge1xuICB0aGlzLnZlcnNpb24gPSA2O1xuICB0aGlzLlVOQ0hBTkdFRCA9IHt9O1xuICB0aGlzLnRyYWNraW5nRGVyaXZhdGlvbiA9IG51bGw7XG4gIHRoaXMudHJhY2tpbmdDb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5ydW5JZCA9IDA7XG4gIHRoaXMubW9ieEd1aWQgPSAwO1xuICB0aGlzLmluQmF0Y2ggPSAwO1xuICB0aGlzLnBlbmRpbmdVbm9ic2VydmF0aW9ucyA9IFtdO1xuICB0aGlzLnBlbmRpbmdSZWFjdGlvbnMgPSBbXTtcbiAgdGhpcy5pc1J1bm5pbmdSZWFjdGlvbnMgPSBmYWxzZTtcbiAgdGhpcy5hbGxvd1N0YXRlQ2hhbmdlcyA9IGZhbHNlO1xuICB0aGlzLmFsbG93U3RhdGVSZWFkcyA9IHRydWU7XG4gIHRoaXMuZW5mb3JjZUFjdGlvbnMgPSB0cnVlO1xuICB0aGlzLnNweUxpc3RlbmVycyA9IFtdO1xuICB0aGlzLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycyA9IFtdO1xuICB0aGlzLmNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvbiA9IGZhbHNlO1xuICB0aGlzLnJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlID0gZmFsc2U7XG4gIHRoaXMub2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb24gPSBmYWxzZTtcbiAgdGhpcy5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzID0gZmFsc2U7XG4gIHRoaXMuc3VwcHJlc3NSZWFjdGlvbkVycm9ycyA9IGZhbHNlO1xuICB0aGlzLnVzZVByb3hpZXMgPSB0cnVlO1xuICB0aGlzLnZlcmlmeVByb3hpZXMgPSBmYWxzZTtcbiAgdGhpcy5zYWZlRGVzY3JpcHRvcnMgPSB0cnVlO1xufTtcbnZhciBjYW5NZXJnZUdsb2JhbFN0YXRlID0gdHJ1ZTtcbnZhciBpc29sYXRlQ2FsbGVkID0gZmFsc2U7XG52YXIgZ2xvYmFsU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgZ2xvYmFsID0gLyojX19QVVJFX18qL2dldEdsb2JhbCgpO1xuICBpZiAoZ2xvYmFsLl9fbW9ieEluc3RhbmNlQ291bnQgPiAwICYmICFnbG9iYWwuX19tb2J4R2xvYmFscykgY2FuTWVyZ2VHbG9iYWxTdGF0ZSA9IGZhbHNlO1xuICBpZiAoZ2xvYmFsLl9fbW9ieEdsb2JhbHMgJiYgZ2xvYmFsLl9fbW9ieEdsb2JhbHMudmVyc2lvbiAhPT0gbmV3IE1vYlhHbG9iYWxzKCkudmVyc2lvbikgY2FuTWVyZ2VHbG9iYWxTdGF0ZSA9IGZhbHNlO1xuXG4gIGlmICghY2FuTWVyZ2VHbG9iYWxTdGF0ZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpc29sYXRlQ2FsbGVkKSB7XG4gICAgICAgIGRpZSgzNSk7XG4gICAgICB9XG4gICAgfSwgMSk7XG4gICAgcmV0dXJuIG5ldyBNb2JYR2xvYmFscygpO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5fX21vYnhHbG9iYWxzKSB7XG4gICAgZ2xvYmFsLl9fbW9ieEluc3RhbmNlQ291bnQgKz0gMTtcbiAgICBpZiAoIWdsb2JhbC5fX21vYnhHbG9iYWxzLlVOQ0hBTkdFRCkgZ2xvYmFsLl9fbW9ieEdsb2JhbHMuVU5DSEFOR0VEID0ge307IC8vIG1ha2UgbWVyZ2UgYmFja3dhcmQgY29tcGF0aWJsZVxuXG4gICAgcmV0dXJuIGdsb2JhbC5fX21vYnhHbG9iYWxzO1xuICB9IGVsc2Uge1xuICAgIGdsb2JhbC5fX21vYnhJbnN0YW5jZUNvdW50ID0gMTtcbiAgICByZXR1cm4gZ2xvYmFsLl9fbW9ieEdsb2JhbHMgPSAvKiNfX1BVUkVfXyovbmV3IE1vYlhHbG9iYWxzKCk7XG4gIH1cbn0oKTtcbmZ1bmN0aW9uIGlzb2xhdGVHbG9iYWxTdGF0ZSgpIHtcbiAgaWYgKGdsb2JhbFN0YXRlLnBlbmRpbmdSZWFjdGlvbnMubGVuZ3RoIHx8IGdsb2JhbFN0YXRlLmluQmF0Y2ggfHwgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zKSBkaWUoMzYpO1xuICBpc29sYXRlQ2FsbGVkID0gdHJ1ZTtcblxuICBpZiAoY2FuTWVyZ2VHbG9iYWxTdGF0ZSkge1xuICAgIHZhciBnbG9iYWwgPSBnZXRHbG9iYWwoKTtcbiAgICBpZiAoLS1nbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCA9PT0gMCkgZ2xvYmFsLl9fbW9ieEdsb2JhbHMgPSB1bmRlZmluZWQ7XG4gICAgZ2xvYmFsU3RhdGUgPSBuZXcgTW9iWEdsb2JhbHMoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0R2xvYmFsU3RhdGUoKSB7XG4gIHJldHVybiBnbG9iYWxTdGF0ZTtcbn1cbi8qKlxyXG4gKiBGb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5OyB0aGlzIHdpbGwgYnJlYWsgdGhlIGludGVybmFsIHN0YXRlIG9mIGV4aXN0aW5nIG9ic2VydmFibGVzLFxyXG4gKiBidXQgY2FuIGJlIHVzZWQgdG8gZ2V0IGJhY2sgYXQgYSBzdGFibGUgc3RhdGUgYWZ0ZXIgdGhyb3dpbmcgZXJyb3JzXHJcbiAqL1xuXG5mdW5jdGlvbiByZXNldEdsb2JhbFN0YXRlKCkge1xuICB2YXIgZGVmYXVsdEdsb2JhbHMgPSBuZXcgTW9iWEdsb2JhbHMoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdEdsb2JhbHMpIHtcbiAgICBpZiAocGVyc2lzdGVudEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkgZ2xvYmFsU3RhdGVba2V5XSA9IGRlZmF1bHRHbG9iYWxzW2tleV07XG4gIH1cblxuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyA9ICFnbG9iYWxTdGF0ZS5lbmZvcmNlQWN0aW9ucztcbn1cblxuZnVuY3Rpb24gaGFzT2JzZXJ2ZXJzKG9ic2VydmFibGUpIHtcbiAgcmV0dXJuIG9ic2VydmFibGUub2JzZXJ2ZXJzXyAmJiBvYnNlcnZhYmxlLm9ic2VydmVyc18uc2l6ZSA+IDA7XG59XG5mdW5jdGlvbiBnZXRPYnNlcnZlcnMob2JzZXJ2YWJsZSkge1xuICByZXR1cm4gb2JzZXJ2YWJsZS5vYnNlcnZlcnNfO1xufSAvLyBmdW5jdGlvbiBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZTogSU9ic2VydmFibGUpIHtcbi8vICAgICBjb25zdCBsaXN0ID0gb2JzZXJ2YWJsZS5vYnNlcnZlcnNcbi8vICAgICBjb25zdCBtYXAgPSBvYnNlcnZhYmxlLm9ic2VydmVyc0luZGV4ZXNcbi8vICAgICBjb25zdCBsID0gbGlzdC5sZW5ndGhcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuLy8gICAgICAgICBjb25zdCBpZCA9IGxpc3RbaV0uX19tYXBpZFxuLy8gICAgICAgICBpZiAoaSkge1xuLy8gICAgICAgICAgICAgaW52YXJpYW50KG1hcFtpZF0gPT09IGksIFwiSU5URVJOQUwgRVJST1IgbWFwcyBkZXJpdmF0aW9uLl9fbWFwaWQgdG8gaW5kZXggaW4gbGlzdFwiKSAvLyBmb3IgcGVyZm9ybWFuY2Vcbi8vICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgIGludmFyaWFudCghKGlkIGluIG1hcCksIFwiSU5URVJOQUwgRVJST1Igb2JzZXJ2ZXIgb24gaW5kZXggMCBzaG91bGRuJ3QgYmUgaGVsZCBpbiBtYXAuXCIpIC8vIGZvciBwZXJmb3JtYW5jZVxuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy8gICAgIGludmFyaWFudChcbi8vICAgICAgICAgbGlzdC5sZW5ndGggPT09IDAgfHwgT2JqZWN0LmtleXMobWFwKS5sZW5ndGggPT09IGxpc3QubGVuZ3RoIC0gMSxcbi8vICAgICAgICAgXCJJTlRFUk5BTCBFUlJPUiB0aGVyZSBpcyBubyBqdW5rIGluIG1hcFwiXG4vLyAgICAgKVxuLy8gfVxuXG5mdW5jdGlvbiBhZGRPYnNlcnZlcihvYnNlcnZhYmxlLCBub2RlKSB7XG4gIC8vIGludmFyaWFudChub2RlLmRlcGVuZGVuY2llc1N0YXRlICE9PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiwgY2FuIGFkZCBvbmx5IGRlcGVuZGVuY2llc1N0YXRlICE9PSAtMVwiKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpID09PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiBhZGQgYWxyZWFkeSBhZGRlZCBub2RlXCIpO1xuICAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5hZGQobm9kZSk7XG4gIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID4gbm9kZS5kZXBlbmRlbmNpZXNTdGF0ZV8pIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBub2RlLmRlcGVuZGVuY2llc1N0YXRlXzsgLy8gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGUpO1xuICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgIT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIGRpZG4ndCBhZGQgbm9kZVwiKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU9ic2VydmVyKG9ic2VydmFibGUsIG5vZGUpIHtcbiAgLy8gaW52YXJpYW50KGdsb2JhbFN0YXRlLmluQmF0Y2ggPiAwLCBcIklOVEVSTkFMIEVSUk9SLCByZW1vdmUgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IGluc2lkZSBiYXRjaFwiKTtcbiAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5pbmRleE9mKG5vZGUpICE9PSAtMSwgXCJJTlRFUk5BTCBFUlJPUiByZW1vdmUgYWxyZWFkeSByZW1vdmVkIG5vZGVcIik7XG4gIC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfW1wiZGVsZXRlXCJdKG5vZGUpO1xuXG4gIGlmIChvYnNlcnZhYmxlLm9ic2VydmVyc18uc2l6ZSA9PT0gMCkge1xuICAgIC8vIGRlbGV0aW5nIGxhc3Qgb2JzZXJ2ZXJcbiAgICBxdWV1ZUZvclVub2JzZXJ2YXRpb24ob2JzZXJ2YWJsZSk7XG4gIH0gLy8gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGUpO1xuICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgPT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIHJlbW92ZSBhbHJlYWR5IHJlbW92ZWQgbm9kZTJcIik7XG5cbn1cbmZ1bmN0aW9uIHF1ZXVlRm9yVW5vYnNlcnZhdGlvbihvYnNlcnZhYmxlKSB7XG4gIGlmIChvYnNlcnZhYmxlLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb25fID09PSBmYWxzZSkge1xuICAgIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMubGVuZ3RoID09PSAwLCBcIklOVEVSTkFMIEVSUk9SLCBzaG91bGQgb25seSBxdWV1ZSBmb3IgdW5vYnNlcnZhdGlvbiB1bm9ic2VydmVkIG9ic2VydmFibGVzXCIpO1xuICAgIG9ic2VydmFibGUuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbl8gPSB0cnVlO1xuICAgIGdsb2JhbFN0YXRlLnBlbmRpbmdVbm9ic2VydmF0aW9ucy5wdXNoKG9ic2VydmFibGUpO1xuICB9XG59XG4vKipcclxuICogQmF0Y2ggc3RhcnRzIGEgdHJhbnNhY3Rpb24sIGF0IGxlYXN0IGZvciBwdXJwb3NlcyBvZiBtZW1vaXppbmcgQ29tcHV0ZWRWYWx1ZXMgd2hlbiBub3RoaW5nIGVsc2UgZG9lcy5cclxuICogRHVyaW5nIGEgYmF0Y2ggYG9uQmVjb21lVW5vYnNlcnZlZGAgd2lsbCBiZSBjYWxsZWQgYXQgbW9zdCBvbmNlIHBlciBvYnNlcnZhYmxlLlxyXG4gKiBBdm9pZHMgdW5uZWNlc3NhcnkgcmVjYWxjdWxhdGlvbnMuXHJcbiAqL1xuXG5mdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICBnbG9iYWxTdGF0ZS5pbkJhdGNoKys7XG59XG5mdW5jdGlvbiBlbmRCYXRjaCgpIHtcbiAgaWYgKC0tZ2xvYmFsU3RhdGUuaW5CYXRjaCA9PT0gMCkge1xuICAgIHJ1blJlYWN0aW9ucygpOyAvLyB0aGUgYmF0Y2ggaXMgYWN0dWFsbHkgYWJvdXQgdG8gZmluaXNoLCBhbGwgdW5vYnNlcnZpbmcgc2hvdWxkIGhhcHBlbiBoZXJlLlxuXG4gICAgdmFyIGxpc3QgPSBnbG9iYWxTdGF0ZS5wZW5kaW5nVW5vYnNlcnZhdGlvbnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gbGlzdFtpXTtcbiAgICAgIG9ic2VydmFibGUuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbl8gPSBmYWxzZTtcblxuICAgICAgaWYgKG9ic2VydmFibGUub2JzZXJ2ZXJzXy5zaXplID09PSAwKSB7XG4gICAgICAgIGlmIChvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZF8pIHtcbiAgICAgICAgICAvLyBpZiB0aGlzIG9ic2VydmFibGUgaGFkIHJlYWN0aXZlIG9ic2VydmVycywgdHJpZ2dlciB0aGUgaG9va3NcbiAgICAgICAgICBvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZF8gPSBmYWxzZTtcbiAgICAgICAgICBvYnNlcnZhYmxlLm9uQlVPKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JzZXJ2YWJsZSBpbnN0YW5jZW9mIENvbXB1dGVkVmFsdWUpIHtcbiAgICAgICAgICAvLyBjb21wdXRlZCB2YWx1ZXMgYXJlIGF1dG9tYXRpY2FsbHkgdGVhcmVkIGRvd24gd2hlbiB0aGUgbGFzdCBvYnNlcnZlciBsZWF2ZXNcbiAgICAgICAgICAvLyB0aGlzIHByb2Nlc3MgaGFwcGVucyByZWN1cnNpdmVseSwgdGhpcyBjb21wdXRlZCBtaWdodCBiZSB0aGUgbGFzdCBvYnNlcnZhYmUgb2YgYW5vdGhlciwgZXRjLi5cbiAgICAgICAgICBvYnNlcnZhYmxlLnN1c3BlbmRfKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBnbG9iYWxTdGF0ZS5wZW5kaW5nVW5vYnNlcnZhdGlvbnMgPSBbXTtcbiAgfVxufVxuZnVuY3Rpb24gcmVwb3J0T2JzZXJ2ZWQob2JzZXJ2YWJsZSkge1xuICBjaGVja0lmU3RhdGVSZWFkc0FyZUFsbG93ZWQob2JzZXJ2YWJsZSk7XG4gIHZhciBkZXJpdmF0aW9uID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuXG4gIGlmIChkZXJpdmF0aW9uICE9PSBudWxsKSB7XG4gICAgLyoqXHJcbiAgICAgKiBTaW1wbGUgb3B0aW1pemF0aW9uLCBnaXZlIGVhY2ggZGVyaXZhdGlvbiBydW4gYW4gdW5pcXVlIGlkIChydW5JZClcclxuICAgICAqIENoZWNrIGlmIGxhc3QgdGltZSB0aGlzIG9ic2VydmFibGUgd2FzIGFjY2Vzc2VkIHRoZSBzYW1lIHJ1bklkIGlzIHVzZWRcclxuICAgICAqIGlmIHRoaXMgaXMgdGhlIGNhc2UsIHRoZSByZWxhdGlvbiBpcyBhbHJlYWR5IGtub3duXHJcbiAgICAgKi9cbiAgICBpZiAoZGVyaXZhdGlvbi5ydW5JZF8gIT09IG9ic2VydmFibGUubGFzdEFjY2Vzc2VkQnlfKSB7XG4gICAgICBvYnNlcnZhYmxlLmxhc3RBY2Nlc3NlZEJ5XyA9IGRlcml2YXRpb24ucnVuSWRfOyAvLyBUcmllZCBzdG9yaW5nIG5ld09ic2VydmluZywgb3Igb2JzZXJ2aW5nLCBvciBib3RoIGFzIFNldCwgYnV0IHBlcmZvcm1hbmNlIGRpZG4ndCBjb21lIGNsb3NlLi4uXG5cbiAgICAgIGRlcml2YXRpb24ubmV3T2JzZXJ2aW5nX1tkZXJpdmF0aW9uLnVuYm91bmREZXBzQ291bnRfKytdID0gb2JzZXJ2YWJsZTtcblxuICAgICAgaWYgKCFvYnNlcnZhYmxlLmlzQmVpbmdPYnNlcnZlZF8gJiYgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0KSB7XG4gICAgICAgIG9ic2VydmFibGUuaXNCZWluZ09ic2VydmVkXyA9IHRydWU7XG4gICAgICAgIG9ic2VydmFibGUub25CTygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKG9ic2VydmFibGUub2JzZXJ2ZXJzXy5zaXplID09PSAwICYmIGdsb2JhbFN0YXRlLmluQmF0Y2ggPiAwKSB7XG4gICAgcXVldWVGb3JVbm9ic2VydmF0aW9uKG9ic2VydmFibGUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBmdW5jdGlvbiBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZTogSU9ic2VydmFibGUsIG1zZzogc3RyaW5nKSB7XG4vLyAgICAgLy8gaXQncyBleHBlbnNpdmUgc28gYmV0dGVyIG5vdCBydW4gaXQgaW4gcHJvZHVjaXRvbi4gYnV0IHRlbXBvcmFyaWx5IGhlbHBmdWwgZm9yIHRlc3Rpbmdcbi8vICAgICBjb25zdCBtaW4gPSBnZXRPYnNlcnZlcnMob2JzZXJ2YWJsZSkucmVkdWNlKChhLCBiKSA9PiBNYXRoLm1pbihhLCBiLmRlcGVuZGVuY2llc1N0YXRlKSwgMilcbi8vICAgICBpZiAobWluID49IG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZSkgcmV0dXJuIC8vIDwtIHRoZSBvbmx5IGFzc3VtcHRpb24gYWJvdXQgYGxvd2VzdE9ic2VydmVyU3RhdGVgXG4vLyAgICAgdGhyb3cgbmV3IEVycm9yKFxuLy8gICAgICAgICBcImxvd2VzdE9ic2VydmVyU3RhdGUgaXMgd3JvbmcgZm9yIFwiICtcbi8vICAgICAgICAgICAgIG1zZyArXG4vLyAgICAgICAgICAgICBcIiBiZWNhdXNlIFwiICtcbi8vICAgICAgICAgICAgIG1pbiArXG4vLyAgICAgICAgICAgICBcIiA8IFwiICtcbi8vICAgICAgICAgICAgIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZVxuLy8gICAgIClcbi8vIH1cblxuLyoqXHJcbiAqIE5PVEU6IGN1cnJlbnQgcHJvcGFnYXRpb24gbWVjaGFuaXNtIHdpbGwgaW4gY2FzZSBvZiBzZWxmIHJlcnVuaW5nIGF1dG9ydW5zIGJlaGF2ZSB1bmV4cGVjdGVkbHlcclxuICogSXQgd2lsbCBwcm9wYWdhdGUgY2hhbmdlcyB0byBvYnNlcnZlcnMgZnJvbSBwcmV2aW91cyBydW5cclxuICogSXQncyBoYXJkIG9yIG1heWJlIGltcG9zc2libGUgKHdpdGggcmVhc29uYWJsZSBwZXJmKSB0byBnZXQgaXQgcmlnaHQgd2l0aCBjdXJyZW50IGFwcHJvYWNoXHJcbiAqIEhvcGVmdWxseSBzZWxmIHJlcnVuaW5nIGF1dG9ydW5zIGFyZW4ndCBhIGZlYXR1cmUgcGVvcGxlIHNob3VsZCBkZXBlbmQgb25cclxuICogQWxzbyBtb3N0IGJhc2ljIHVzZSBjYXNlcyBzaG91bGQgYmUgb2tcclxuICovXG4vLyBDYWxsZWQgYnkgQXRvbSB3aGVuIGl0cyB2YWx1ZSBjaGFuZ2VzXG5cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNoYW5nZWQob2JzZXJ2YWJsZSkge1xuICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJjaGFuZ2VkIHN0YXJ0XCIpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfKSByZXR1cm47XG4gIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV87IC8vIElkZWFsbHkgd2UgdXNlIGZvci4ub2YgaGVyZSwgYnV0IHRoZSBkb3duY29tcGlsZWQgdmVyc2lvbiBpcyByZWFsbHkgc2xvdy4uLlxuXG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGQuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXykge1xuICAgICAgaWYgKCBkLmlzVHJhY2luZ18gIT09IFRyYWNlTW9kZS5OT05FKSB7XG4gICAgICAgIGxvZ1RyYWNlSW5mbyhkLCBvYnNlcnZhYmxlKTtcbiAgICAgIH1cblxuICAgICAgZC5vbkJlY29tZVN0YWxlXygpO1xuICAgIH1cblxuICAgIGQuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfO1xuICB9KTsgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY2hhbmdlZCBlbmRcIik7XG59IC8vIENhbGxlZCBieSBDb21wdXRlZFZhbHVlIHdoZW4gaXQgcmVjYWxjdWxhdGUgYW5kIGl0cyB2YWx1ZSBjaGFuZ2VkXG5cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNoYW5nZUNvbmZpcm1lZChvYnNlcnZhYmxlKSB7XG4gIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNvbmZpcm1lZCBzdGFydFwiKTtcbiAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXykgcmV0dXJuO1xuICBvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfO1xuICBvYnNlcnZhYmxlLm9ic2VydmVyc18uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIGlmIChkLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uUE9TU0lCTFlfU1RBTEVfKSB7XG4gICAgICBkLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXztcblxuICAgICAgaWYgKCBkLmlzVHJhY2luZ18gIT09IFRyYWNlTW9kZS5OT05FKSB7XG4gICAgICAgIGxvZ1RyYWNlSW5mbyhkLCBvYnNlcnZhYmxlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGQuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXyAvLyB0aGlzIGhhcHBlbnMgZHVyaW5nIGNvbXB1dGluZyBvZiBgZGAsIGp1c3Qga2VlcCBsb3dlc3RPYnNlcnZlclN0YXRlIHVwIHRvIGRhdGUuXG4gICAgKSB7XG4gICAgICAgIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXztcbiAgICAgIH1cbiAgfSk7IC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNvbmZpcm1lZCBlbmRcIik7XG59IC8vIFVzZWQgYnkgY29tcHV0ZWQgd2hlbiBpdHMgZGVwZW5kZW5jeSBjaGFuZ2VkLCBidXQgd2UgZG9uJ3Qgd2FuJ3QgdG8gaW1tZWRpYXRlbHkgcmVjb21wdXRlLlxuXG5mdW5jdGlvbiBwcm9wYWdhdGVNYXliZUNoYW5nZWQob2JzZXJ2YWJsZSkge1xuICAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJtYXliZSBzdGFydFwiKTtcbiAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gIT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSByZXR1cm47XG4gIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5QT1NTSUJMWV9TVEFMRV87XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGQuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXykge1xuICAgICAgZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5QT1NTSUJMWV9TVEFMRV87XG4gICAgICBkLm9uQmVjb21lU3RhbGVfKCk7XG4gICAgfVxuICB9KTsgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwibWF5YmUgZW5kXCIpO1xufVxuXG5mdW5jdGlvbiBsb2dUcmFjZUluZm8oZGVyaXZhdGlvbiwgb2JzZXJ2YWJsZSkge1xuICBjb25zb2xlLmxvZyhcIlttb2J4LnRyYWNlXSAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIGlzIGludmFsaWRhdGVkIGR1ZSB0byBhIGNoYW5nZSBpbjogJ1wiICsgb2JzZXJ2YWJsZS5uYW1lXyArIFwiJ1wiKTtcblxuICBpZiAoZGVyaXZhdGlvbi5pc1RyYWNpbmdfID09PSBUcmFjZU1vZGUuQlJFQUspIHtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICBwcmludERlcFRyZWUoZ2V0RGVwZW5kZW5jeVRyZWUoZGVyaXZhdGlvbiksIGxpbmVzLCAxKTsgLy8gcHJldHRpZXItaWdub3JlXG5cbiAgICBuZXcgRnVuY3Rpb24oXCJkZWJ1Z2dlcjtcXG4vKlxcblRyYWNpbmcgJ1wiICsgZGVyaXZhdGlvbi5uYW1lXyArIFwiJ1xcblxcbllvdSBhcmUgZW50ZXJpbmcgdGhpcyBicmVhayBwb2ludCBiZWNhdXNlIGRlcml2YXRpb24gJ1wiICsgZGVyaXZhdGlvbi5uYW1lXyArIFwiJyBpcyBiZWluZyB0cmFjZWQgYW5kICdcIiArIG9ic2VydmFibGUubmFtZV8gKyBcIicgaXMgbm93IGZvcmNpbmcgaXQgdG8gdXBkYXRlLlxcbkp1c3QgZm9sbG93IHRoZSBzdGFja3RyYWNlIHlvdSBzaG91bGQgbm93IHNlZSBpbiB0aGUgZGV2dG9vbHMgdG8gc2VlIHByZWNpc2VseSB3aGF0IHBpZWNlIG9mIHlvdXIgY29kZSBpcyBjYXVzaW5nIHRoaXMgdXBkYXRlXFxuVGhlIHN0YWNrZnJhbWUgeW91IGFyZSBsb29raW5nIGZvciBpcyBhdCBsZWFzdCB+Ni04IHN0YWNrLWZyYW1lcyB1cC5cXG5cXG5cIiArIChkZXJpdmF0aW9uIGluc3RhbmNlb2YgQ29tcHV0ZWRWYWx1ZSA/IGRlcml2YXRpb24uZGVyaXZhdGlvbi50b1N0cmluZygpLnJlcGxhY2UoL1sqXVxcLy9nLCBcIi9cIikgOiBcIlwiKSArIFwiXFxuXFxuVGhlIGRlcGVuZGVuY2llcyBmb3IgdGhpcyBkZXJpdmF0aW9uIGFyZTpcXG5cXG5cIiArIGxpbmVzLmpvaW4oXCJcXG5cIikgKyBcIlxcbiovXFxuICAgIFwiKSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50RGVwVHJlZSh0cmVlLCBsaW5lcywgZGVwdGgpIHtcbiAgaWYgKGxpbmVzLmxlbmd0aCA+PSAxMDAwKSB7XG4gICAgbGluZXMucHVzaChcIihhbmQgbWFueSBtb3JlKVwiKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsaW5lcy5wdXNoKFwiXCIgKyBuZXcgQXJyYXkoZGVwdGgpLmpvaW4oXCJcXHRcIikgKyB0cmVlLm5hbWUpOyAvLyBNV0U6IG5vdCB0aGUgZmFzdGVzdCwgYnV0IHRoZSBlYXNpZXN0IHdheSA6KVxuXG4gIGlmICh0cmVlLmRlcGVuZGVuY2llcykgdHJlZS5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gcHJpbnREZXBUcmVlKGNoaWxkLCBsaW5lcywgZGVwdGggKyAxKTtcbiAgfSk7XG59XG5cbnZhciBSZWFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIG5vZGVzIHdlIGFyZSBsb29raW5nIGF0LiBPdXIgdmFsdWUgZGVwZW5kcyBvbiB0aGVzZSBub2Rlc1xuICBmdW5jdGlvbiBSZWFjdGlvbihuYW1lXywgb25JbnZhbGlkYXRlXywgZXJyb3JIYW5kbGVyXywgcmVxdWlyZXNPYnNlcnZhYmxlXykge1xuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9ICBcIlJlYWN0aW9uQFwiICsgZ2V0TmV4dElkKCkgO1xuICAgIH1cblxuICAgIGlmIChyZXF1aXJlc09ic2VydmFibGVfID09PSB2b2lkIDApIHtcbiAgICAgIHJlcXVpcmVzT2JzZXJ2YWJsZV8gPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXMub25JbnZhbGlkYXRlXyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ySGFuZGxlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5yZXF1aXJlc09ic2VydmFibGVfID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2aW5nXyA9IFtdO1xuICAgIHRoaXMubmV3T2JzZXJ2aW5nXyA9IFtdO1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB0aGlzLmRpZmZWYWx1ZV8gPSAwO1xuICAgIHRoaXMucnVuSWRfID0gMDtcbiAgICB0aGlzLnVuYm91bmREZXBzQ291bnRfID0gMDtcbiAgICB0aGlzLmlzRGlzcG9zZWRfID0gZmFsc2U7XG4gICAgdGhpcy5pc1NjaGVkdWxlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmlzVHJhY2tQZW5kaW5nXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNSdW5uaW5nXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNUcmFjaW5nXyA9IFRyYWNlTW9kZS5OT05FO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgICB0aGlzLm9uSW52YWxpZGF0ZV8gPSBvbkludmFsaWRhdGVfO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyXyA9IGVycm9ySGFuZGxlcl87XG4gICAgdGhpcy5yZXF1aXJlc09ic2VydmFibGVfID0gcmVxdWlyZXNPYnNlcnZhYmxlXztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSZWFjdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9uQmVjb21lU3RhbGVfID0gZnVuY3Rpb24gb25CZWNvbWVTdGFsZV8oKSB7XG4gICAgdGhpcy5zY2hlZHVsZV8oKTtcbiAgfTtcblxuICBfcHJvdG8uc2NoZWR1bGVfID0gZnVuY3Rpb24gc2NoZWR1bGVfKCkge1xuICAgIGlmICghdGhpcy5pc1NjaGVkdWxlZF8pIHtcbiAgICAgIHRoaXMuaXNTY2hlZHVsZWRfID0gdHJ1ZTtcbiAgICAgIGdsb2JhbFN0YXRlLnBlbmRpbmdSZWFjdGlvbnMucHVzaCh0aGlzKTtcbiAgICAgIHJ1blJlYWN0aW9ucygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaXNTY2hlZHVsZWQgPSBmdW5jdGlvbiBpc1NjaGVkdWxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NjaGVkdWxlZF87XG4gIH1cbiAgLyoqXHJcbiAgICogaW50ZXJuYWwsIHVzZSBzY2hlZHVsZSgpIGlmIHlvdSBpbnRlbmQgdG8ga2ljayBvZmYgYSByZWFjdGlvblxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJ1blJlYWN0aW9uXyA9IGZ1bmN0aW9uIHJ1blJlYWN0aW9uXygpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZF8pIHtcbiAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgIHRoaXMuaXNTY2hlZHVsZWRfID0gZmFsc2U7XG4gICAgICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dDtcbiAgICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHRoaXM7XG5cbiAgICAgIGlmIChzaG91bGRDb21wdXRlKHRoaXMpKSB7XG4gICAgICAgIHRoaXMuaXNUcmFja1BlbmRpbmdfID0gdHJ1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMub25JbnZhbGlkYXRlXygpO1xuXG4gICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5pc1RyYWNrUGVuZGluZ18gJiYgaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIC8vIG9uSW52YWxpZGF0ZSBkaWRuJ3QgdHJpZ2dlciB0cmFjayByaWdodCBhd2F5Li5cbiAgICAgICAgICAgIHNweVJlcG9ydCh7XG4gICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgICAgICAgIHR5cGU6IFwic2NoZWR1bGVkLXJlYWN0aW9uXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMucmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uXyhlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSBwcmV2O1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnRyYWNrID0gZnVuY3Rpb24gdHJhY2soZm4pIHtcbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkXykge1xuICAgICAgcmV0dXJuOyAvLyBjb25zb2xlLndhcm4oXCJSZWFjdGlvbiBhbHJlYWR5IGRpc3Bvc2VkXCIpIC8vIE5vdGU6IE5vdCBhIHdhcm5pbmcgLyBlcnJvciBpbiBtb2J4IDQgZWl0aGVyXG4gICAgfVxuXG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHZhciBub3RpZnkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICB2YXIgc3RhcnRUaW1lO1xuXG4gICAgaWYgKCBub3RpZnkpIHtcbiAgICAgIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBzcHlSZXBvcnRTdGFydCh7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IFwicmVhY3Rpb25cIlxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5pc1J1bm5pbmdfID0gdHJ1ZTtcbiAgICB2YXIgcHJldlJlYWN0aW9uID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0OyAvLyByZWFjdGlvbnMgY291bGQgY3JlYXRlIHJlYWN0aW9ucy4uLlxuXG4gICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gdGhpcztcbiAgICB2YXIgcmVzdWx0ID0gdHJhY2tEZXJpdmVkRnVuY3Rpb24odGhpcywgZm4sIHVuZGVmaW5lZCk7XG4gICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gcHJldlJlYWN0aW9uO1xuICAgIHRoaXMuaXNSdW5uaW5nXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNUcmFja1BlbmRpbmdfID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkXykge1xuICAgICAgLy8gZGlzcG9zZWQgZHVyaW5nIGxhc3QgcnVuLiBDbGVhbiB1cCBldmVyeXRoaW5nIHRoYXQgd2FzIGJvdW5kIGFmdGVyIHRoZSBkaXNwb3NlIGNhbGwuXG4gICAgICBjbGVhck9ic2VydmluZyh0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDYXVnaHRFeGNlcHRpb24ocmVzdWx0KSkgdGhpcy5yZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fKHJlc3VsdC5jYXVzZSk7XG5cbiAgICBpZiAoIG5vdGlmeSkge1xuICAgICAgc3B5UmVwb3J0RW5kKHtcbiAgICAgICAgdGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZW5kQmF0Y2goKTtcbiAgfTtcblxuICBfcHJvdG8ucmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uXyA9IGZ1bmN0aW9uIHJlcG9ydEV4Y2VwdGlvbkluRGVyaXZhdGlvbl8oZXJyb3IpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuZXJyb3JIYW5kbGVyXykge1xuICAgICAgdGhpcy5lcnJvckhhbmRsZXJfKGVycm9yLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcykgdGhyb3cgZXJyb3I7XG4gICAgdmFyIG1lc3NhZ2UgPSAgXCJbbW9ieF0gRW5jb3VudGVyZWQgYW4gdW5jYXVnaHQgZXhjZXB0aW9uIHRoYXQgd2FzIHRocm93biBieSBhIHJlYWN0aW9uIG9yIG9ic2VydmVyIGNvbXBvbmVudCwgaW46ICdcIiArIHRoaXMgKyBcIidcIiA7XG5cbiAgICBpZiAoIWdsb2JhbFN0YXRlLnN1cHByZXNzUmVhY3Rpb25FcnJvcnMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgZXJyb3IpO1xuICAgICAgLyoqIElmIGRlYnVnZ2luZyBicm91Z2h0IHlvdSBoZXJlLCBwbGVhc2UsIHJlYWQgdGhlIGFib3ZlIG1lc3NhZ2UgOi0pLiBUbnghICovXG4gICAgfSBlbHNlIGNvbnNvbGUud2FybihcIlttb2J4XSAoZXJyb3IgaW4gcmVhY3Rpb24gJ1wiICsgdGhpcy5uYW1lXyArIFwiJyBzdXBwcmVzc2VkLCBmaXggZXJyb3Igb2YgY2F1c2luZyBhY3Rpb24gYmVsb3cpXCIpOyAvLyBwcmV0dGllci1pZ25vcmVcblxuXG4gICAgaWYgKCBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICBuYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBlcnJvcjogXCJcIiArIGVycm9yXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIGYoZXJyb3IsIF90aGlzKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlzcG9zZWRfKSB7XG4gICAgICB0aGlzLmlzRGlzcG9zZWRfID0gdHJ1ZTtcblxuICAgICAgaWYgKCF0aGlzLmlzUnVubmluZ18pIHtcbiAgICAgICAgLy8gaWYgZGlzcG9zZWQgd2hpbGUgcnVubmluZywgY2xlYW4gdXAgbGF0ZXIuIE1heWJlIG5vdCBvcHRpbWFsLCBidXQgcmFyZSBjYXNlXG4gICAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgICAgY2xlYXJPYnNlcnZpbmcodGhpcyk7XG4gICAgICAgIGVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXREaXNwb3Nlcl8gPSBmdW5jdGlvbiBnZXREaXNwb3Nlcl8oKSB7XG4gICAgdmFyIHIgPSB0aGlzLmRpc3Bvc2UuYmluZCh0aGlzKTtcbiAgICByWyRtb2J4XSA9IHRoaXM7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiUmVhY3Rpb25bXCIgKyB0aGlzLm5hbWVfICsgXCJdXCI7XG4gIH07XG5cbiAgX3Byb3RvLnRyYWNlID0gZnVuY3Rpb24gdHJhY2UkMShlbnRlckJyZWFrUG9pbnQpIHtcbiAgICBpZiAoZW50ZXJCcmVha1BvaW50ID09PSB2b2lkIDApIHtcbiAgICAgIGVudGVyQnJlYWtQb2ludCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRyYWNlKHRoaXMsIGVudGVyQnJlYWtQb2ludCk7XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0aW9uO1xufSgpO1xuZnVuY3Rpb24gb25SZWFjdGlvbkVycm9yKGhhbmRsZXIpIHtcbiAgZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgIGlmIChpZHggPj0gMCkgZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xuICB9O1xufVxuLyoqXHJcbiAqIE1hZ2ljIG51bWJlciBhbGVydCFcclxuICogRGVmaW5lcyB3aXRoaW4gaG93IG1hbnkgdGltZXMgYSByZWFjdGlvbiBpcyBhbGxvd2VkIHRvIHJlLXRyaWdnZXIgaXRzZWxmXHJcbiAqIHVudGlsIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGlzIGlzIGdvbm5hIGJlIGEgbmV2ZXIgZW5kaW5nIGxvb3AuLi5cclxuICovXG5cbnZhciBNQVhfUkVBQ1RJT05fSVRFUkFUSU9OUyA9IDEwMDtcblxudmFyIHJlYWN0aW9uU2NoZWR1bGVyID0gZnVuY3Rpb24gcmVhY3Rpb25TY2hlZHVsZXIoZikge1xuICByZXR1cm4gZigpO1xufTtcblxuZnVuY3Rpb24gcnVuUmVhY3Rpb25zKCkge1xuICAvLyBUcmFtcG9saW5pbmcsIGlmIHJ1blJlYWN0aW9ucyBhcmUgYWxyZWFkeSBydW5uaW5nLCBuZXcgcmVhY3Rpb25zIHdpbGwgYmUgcGlja2VkIHVwXG4gIGlmIChnbG9iYWxTdGF0ZS5pbkJhdGNoID4gMCB8fCBnbG9iYWxTdGF0ZS5pc1J1bm5pbmdSZWFjdGlvbnMpIHJldHVybjtcbiAgcmVhY3Rpb25TY2hlZHVsZXIocnVuUmVhY3Rpb25zSGVscGVyKTtcbn1cblxuZnVuY3Rpb24gcnVuUmVhY3Rpb25zSGVscGVyKCkge1xuICBnbG9iYWxTdGF0ZS5pc1J1bm5pbmdSZWFjdGlvbnMgPSB0cnVlO1xuICB2YXIgYWxsUmVhY3Rpb25zID0gZ2xvYmFsU3RhdGUucGVuZGluZ1JlYWN0aW9ucztcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwOyAvLyBXaGlsZSBydW5uaW5nIHJlYWN0aW9ucywgbmV3IHJlYWN0aW9ucyBtaWdodCBiZSB0cmlnZ2VyZWQuXG4gIC8vIEhlbmNlIHdlIHdvcmsgd2l0aCB0d28gdmFyaWFibGVzIGFuZCBjaGVjayB3aGV0aGVyXG4gIC8vIHdlIGNvbnZlcmdlIHRvIG5vIHJlbWFpbmluZyByZWFjdGlvbnMgYWZ0ZXIgYSB3aGlsZS5cblxuICB3aGlsZSAoYWxsUmVhY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoKytpdGVyYXRpb25zID09PSBNQVhfUkVBQ1RJT05fSVRFUkFUSU9OUykge1xuICAgICAgY29uc29sZS5lcnJvciggXCJSZWFjdGlvbiBkb2Vzbid0IGNvbnZlcmdlIHRvIGEgc3RhYmxlIHN0YXRlIGFmdGVyIFwiICsgTUFYX1JFQUNUSU9OX0lURVJBVElPTlMgKyBcIiBpdGVyYXRpb25zLlwiICsgKFwiIFByb2JhYmx5IHRoZXJlIGlzIGEgY3ljbGUgaW4gdGhlIHJlYWN0aXZlIGZ1bmN0aW9uOiBcIiArIGFsbFJlYWN0aW9uc1swXSkgKTtcbiAgICAgIGFsbFJlYWN0aW9ucy5zcGxpY2UoMCk7IC8vIGNsZWFyIHJlYWN0aW9uc1xuICAgIH1cblxuICAgIHZhciByZW1haW5pbmdSZWFjdGlvbnMgPSBhbGxSZWFjdGlvbnMuc3BsaWNlKDApO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSByZW1haW5pbmdSZWFjdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZW1haW5pbmdSZWFjdGlvbnNbaV0ucnVuUmVhY3Rpb25fKCk7XG4gICAgfVxuICB9XG5cbiAgZ2xvYmFsU3RhdGUuaXNSdW5uaW5nUmVhY3Rpb25zID0gZmFsc2U7XG59XG5cbnZhciBpc1JlYWN0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJSZWFjdGlvblwiLCBSZWFjdGlvbik7XG5mdW5jdGlvbiBzZXRSZWFjdGlvblNjaGVkdWxlcihmbikge1xuICB2YXIgYmFzZVNjaGVkdWxlciA9IHJlYWN0aW9uU2NoZWR1bGVyO1xuXG4gIHJlYWN0aW9uU2NoZWR1bGVyID0gZnVuY3Rpb24gcmVhY3Rpb25TY2hlZHVsZXIoZikge1xuICAgIHJldHVybiBmbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYmFzZVNjaGVkdWxlcihmKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNTcHlFbmFibGVkKCkge1xuICByZXR1cm4gICEhZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHNweVJlcG9ydChldmVudCkge1xuXG4gIGlmICghZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgbGlzdGVuZXJzID0gZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxpc3RlbmVyc1tpXShldmVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNweVJlcG9ydFN0YXJ0KGV2ZW50KSB7XG5cbiAgdmFyIGNoYW5nZSA9IF9leHRlbmRzKHt9LCBldmVudCwge1xuICAgIHNweVJlcG9ydFN0YXJ0OiB0cnVlXG4gIH0pO1xuXG4gIHNweVJlcG9ydChjaGFuZ2UpO1xufVxudmFyIEVORF9FVkVOVCA9IHtcbiAgdHlwZTogXCJyZXBvcnQtZW5kXCIsXG4gIHNweVJlcG9ydEVuZDogdHJ1ZVxufTtcbmZ1bmN0aW9uIHNweVJlcG9ydEVuZChjaGFuZ2UpIHtcbiAgaWYgKGNoYW5nZSkgc3B5UmVwb3J0KF9leHRlbmRzKHt9LCBjaGFuZ2UsIHtcbiAgICB0eXBlOiBcInJlcG9ydC1lbmRcIixcbiAgICBzcHlSZXBvcnRFbmQ6IHRydWVcbiAgfSkpO2Vsc2Ugc3B5UmVwb3J0KEVORF9FVkVOVCk7XG59XG5mdW5jdGlvbiBzcHkobGlzdGVuZXIpIHtcbiAge1xuICAgIGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgICBnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMgPSBnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHJldHVybiBsICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBBQ1RJT04gPSBcImFjdGlvblwiO1xudmFyIEFDVElPTl9CT1VORCA9IFwiYWN0aW9uLmJvdW5kXCI7XG52YXIgQVVUT0FDVElPTiA9IFwiYXV0b0FjdGlvblwiO1xudmFyIEFVVE9BQ1RJT05fQk9VTkQgPSBcImF1dG9BY3Rpb24uYm91bmRcIjtcbnZhciBERUZBVUxUX0FDVElPTl9OQU1FID0gXCI8dW5uYW1lZCBhY3Rpb24+XCI7XG52YXIgYWN0aW9uQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKEFDVElPTik7XG52YXIgYWN0aW9uQm91bmRBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQUNUSU9OX0JPVU5ELCB7XG4gIGJvdW5kOiB0cnVlXG59KTtcbnZhciBhdXRvQWN0aW9uQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKEFVVE9BQ1RJT04sIHtcbiAgYXV0b0FjdGlvbjogdHJ1ZVxufSk7XG52YXIgYXV0b0FjdGlvbkJvdW5kQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKEFVVE9BQ1RJT05fQk9VTkQsIHtcbiAgYXV0b0FjdGlvbjogdHJ1ZSxcbiAgYm91bmQ6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25GYWN0b3J5KGF1dG9BY3Rpb24pIHtcbiAgdmFyIHJlcyA9IGZ1bmN0aW9uIGFjdGlvbihhcmcxLCBhcmcyKSB7XG4gICAgLy8gYWN0aW9uKGZuKCkge30pXG4gICAgaWYgKGlzRnVuY3Rpb24oYXJnMSkpIHJldHVybiBjcmVhdGVBY3Rpb24oYXJnMS5uYW1lIHx8IERFRkFVTFRfQUNUSU9OX05BTUUsIGFyZzEsIGF1dG9BY3Rpb24pOyAvLyBhY3Rpb24oXCJuYW1lXCIsIGZuKCkge30pXG5cbiAgICBpZiAoaXNGdW5jdGlvbihhcmcyKSkgcmV0dXJuIGNyZWF0ZUFjdGlvbihhcmcxLCBhcmcyLCBhdXRvQWN0aW9uKTsgLy8gQGFjdGlvblxuXG4gICAgaWYgKGlzU3RyaW5naXNoKGFyZzIpKSB7XG4gICAgICByZXR1cm4gc3RvcmVBbm5vdGF0aW9uKGFyZzEsIGFyZzIsIGF1dG9BY3Rpb24gPyBhdXRvQWN0aW9uQW5ub3RhdGlvbiA6IGFjdGlvbkFubm90YXRpb24pO1xuICAgIH0gLy8gYWN0aW9uKFwibmFtZVwiKSAmIEBhY3Rpb24oXCJuYW1lXCIpXG5cblxuICAgIGlmIChpc1N0cmluZ2lzaChhcmcxKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZURlY29yYXRvckFubm90YXRpb24oY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihhdXRvQWN0aW9uID8gQVVUT0FDVElPTiA6IEFDVElPTiwge1xuICAgICAgICBuYW1lOiBhcmcxLFxuICAgICAgICBhdXRvQWN0aW9uOiBhdXRvQWN0aW9uXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgZGllKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yIGBhY3Rpb25gXCIpO1xuICB9O1xuXG4gIHJldHVybiByZXM7XG59XG5cbnZhciBhY3Rpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uRmFjdG9yeShmYWxzZSk7XG5PYmplY3QuYXNzaWduKGFjdGlvbiwgYWN0aW9uQW5ub3RhdGlvbik7XG52YXIgYXV0b0FjdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25GYWN0b3J5KHRydWUpO1xuT2JqZWN0LmFzc2lnbihhdXRvQWN0aW9uLCBhdXRvQWN0aW9uQW5ub3RhdGlvbik7XG5hY3Rpb24uYm91bmQgPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihhY3Rpb25Cb3VuZEFubm90YXRpb24pO1xuYXV0b0FjdGlvbi5ib3VuZCA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGF1dG9BY3Rpb25Cb3VuZEFubm90YXRpb24pO1xuZnVuY3Rpb24gcnVuSW5BY3Rpb24oZm4pIHtcbiAgcmV0dXJuIGV4ZWN1dGVBY3Rpb24oZm4ubmFtZSB8fCBERUZBVUxUX0FDVElPTl9OQU1FLCBmYWxzZSwgZm4sIHRoaXMsIHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBpc0FjdGlvbih0aGluZykge1xuICByZXR1cm4gaXNGdW5jdGlvbih0aGluZykgJiYgdGhpbmcuaXNNb2J4QWN0aW9uID09PSB0cnVlO1xufVxuXG4vKipcclxuICogQ3JlYXRlcyBhIG5hbWVkIHJlYWN0aXZlIHZpZXcgYW5kIGtlZXBzIGl0IGFsaXZlLCBzbyB0aGF0IHRoZSB2aWV3IGlzIGFsd2F5c1xyXG4gKiB1cGRhdGVkIGlmIG9uZSBvZiB0aGUgZGVwZW5kZW5jaWVzIGNoYW5nZXMsIGV2ZW4gd2hlbiB0aGUgdmlldyBpcyBub3QgZnVydGhlciB1c2VkIGJ5IHNvbWV0aGluZyBlbHNlLlxyXG4gKiBAcGFyYW0gdmlldyBUaGUgcmVhY3RpdmUgdmlld1xyXG4gKiBAcmV0dXJucyBkaXNwb3NlciBmdW5jdGlvbiwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gc3RvcCB0aGUgdmlldyBmcm9tIGJlaW5nIHVwZGF0ZWQgaW4gdGhlIGZ1dHVyZS5cclxuICovXG5cbmZ1bmN0aW9uIGF1dG9ydW4odmlldywgb3B0cykge1xuICB2YXIgX29wdHMkbmFtZSwgX29wdHM7XG5cbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSBFTVBUWV9PQkpFQ1Q7XG4gIH1cblxuICB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKHZpZXcpKSBkaWUoXCJBdXRvcnVuIGV4cGVjdHMgYSBmdW5jdGlvbiBhcyBmaXJzdCBhcmd1bWVudFwiKTtcbiAgICBpZiAoaXNBY3Rpb24odmlldykpIGRpZShcIkF1dG9ydW4gZG9lcyBub3QgYWNjZXB0IGFjdGlvbnMgc2luY2UgYWN0aW9ucyBhcmUgdW50cmFja2FibGVcIik7XG4gIH1cblxuICB2YXIgbmFtZSA9IChfb3B0cyRuYW1lID0gKF9vcHRzID0gb3B0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRzLm5hbWUpICE9IG51bGwgPyBfb3B0cyRuYW1lIDogIHZpZXcubmFtZSB8fCBcIkF1dG9ydW5AXCIgKyBnZXROZXh0SWQoKSA7XG4gIHZhciBydW5TeW5jID0gIW9wdHMuc2NoZWR1bGVyICYmICFvcHRzLmRlbGF5O1xuICB2YXIgcmVhY3Rpb247XG5cbiAgaWYgKHJ1blN5bmMpIHtcbiAgICAvLyBub3JtYWwgYXV0b3J1blxuICAgIHJlYWN0aW9uID0gbmV3IFJlYWN0aW9uKG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudHJhY2socmVhY3Rpb25SdW5uZXIpO1xuICAgIH0sIG9wdHMub25FcnJvciwgb3B0cy5yZXF1aXJlc09ic2VydmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzY2hlZHVsZXIgPSBjcmVhdGVTY2hlZHVsZXJGcm9tT3B0aW9ucyhvcHRzKTsgLy8gZGVib3VuY2VkIGF1dG9ydW5cblxuICAgIHZhciBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHJlYWN0aW9uID0gbmV3IFJlYWN0aW9uKG5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghaXNTY2hlZHVsZWQpIHtcbiAgICAgICAgaXNTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICBzY2hlZHVsZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFyZWFjdGlvbi5pc0Rpc3Bvc2VkXykgcmVhY3Rpb24udHJhY2socmVhY3Rpb25SdW5uZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBvcHRzLm9uRXJyb3IsIG9wdHMucmVxdWlyZXNPYnNlcnZhYmxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aW9uUnVubmVyKCkge1xuICAgIHZpZXcocmVhY3Rpb24pO1xuICB9XG5cbiAgcmVhY3Rpb24uc2NoZWR1bGVfKCk7XG4gIHJldHVybiByZWFjdGlvbi5nZXREaXNwb3Nlcl8oKTtcbn1cblxudmFyIHJ1biA9IGZ1bmN0aW9uIHJ1bihmKSB7XG4gIHJldHVybiBmKCk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTY2hlZHVsZXJGcm9tT3B0aW9ucyhvcHRzKSB7XG4gIHJldHVybiBvcHRzLnNjaGVkdWxlciA/IG9wdHMuc2NoZWR1bGVyIDogb3B0cy5kZWxheSA/IGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZiwgb3B0cy5kZWxheSk7XG4gIH0gOiBydW47XG59XG5cbmZ1bmN0aW9uIHJlYWN0aW9uKGV4cHJlc3Npb24sIGVmZmVjdCwgb3B0cykge1xuICB2YXIgX29wdHMkbmFtZTI7XG5cbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSBFTVBUWV9PQkpFQ1Q7XG4gIH1cblxuICB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGV4cHJlc3Npb24pIHx8ICFpc0Z1bmN0aW9uKGVmZmVjdCkpIGRpZShcIkZpcnN0IGFuZCBzZWNvbmQgYXJndW1lbnQgdG8gcmVhY3Rpb24gc2hvdWxkIGJlIGZ1bmN0aW9uc1wiKTtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qob3B0cykpIGRpZShcIlRoaXJkIGFyZ3VtZW50IG9mIHJlYWN0aW9ucyBzaG91bGQgYmUgYW4gb2JqZWN0XCIpO1xuICB9XG5cbiAgdmFyIG5hbWUgPSAoX29wdHMkbmFtZTIgPSBvcHRzLm5hbWUpICE9IG51bGwgPyBfb3B0cyRuYW1lMiA6ICBcIlJlYWN0aW9uQFwiICsgZ2V0TmV4dElkKCkgO1xuICB2YXIgZWZmZWN0QWN0aW9uID0gYWN0aW9uKG5hbWUsIG9wdHMub25FcnJvciA/IHdyYXBFcnJvckhhbmRsZXIob3B0cy5vbkVycm9yLCBlZmZlY3QpIDogZWZmZWN0KTtcbiAgdmFyIHJ1blN5bmMgPSAhb3B0cy5zY2hlZHVsZXIgJiYgIW9wdHMuZGVsYXk7XG4gIHZhciBzY2hlZHVsZXIgPSBjcmVhdGVTY2hlZHVsZXJGcm9tT3B0aW9ucyhvcHRzKTtcbiAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG4gIHZhciBpc1NjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgdmFsdWU7XG4gIHZhciBvbGRWYWx1ZSA9IHVuZGVmaW5lZDsgLy8gb25seSBhbiBpc3N1ZSB3aXRoIGZpcmVJbW1lZGlhdGVseVxuXG4gIHZhciBlcXVhbHMgPSBvcHRzLmNvbXBhcmVTdHJ1Y3R1cmFsID8gY29tcGFyZXIuc3RydWN0dXJhbCA6IG9wdHMuZXF1YWxzIHx8IGNvbXBhcmVyW1wiZGVmYXVsdFwiXTtcbiAgdmFyIHIgPSBuZXcgUmVhY3Rpb24obmFtZSwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChmaXJzdFRpbWUgfHwgcnVuU3luYykge1xuICAgICAgcmVhY3Rpb25SdW5uZXIoKTtcbiAgICB9IGVsc2UgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgaXNTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2NoZWR1bGVyKHJlYWN0aW9uUnVubmVyKTtcbiAgICB9XG4gIH0sIG9wdHMub25FcnJvciwgb3B0cy5yZXF1aXJlc09ic2VydmFibGUpO1xuXG4gIGZ1bmN0aW9uIHJlYWN0aW9uUnVubmVyKCkge1xuICAgIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgaWYgKHIuaXNEaXNwb3NlZF8pIHJldHVybjtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHIudHJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5leHRWYWx1ZSA9IGFsbG93U3RhdGVDaGFuZ2VzKGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uKHIpO1xuICAgICAgfSk7XG4gICAgICBjaGFuZ2VkID0gZmlyc3RUaW1lIHx8ICFlcXVhbHModmFsdWUsIG5leHRWYWx1ZSk7XG4gICAgICBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgICAgdmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKGZpcnN0VGltZSAmJiBvcHRzLmZpcmVJbW1lZGlhdGVseSkgZWZmZWN0QWN0aW9uKHZhbHVlLCBvbGRWYWx1ZSwgcik7ZWxzZSBpZiAoIWZpcnN0VGltZSAmJiBjaGFuZ2VkKSBlZmZlY3RBY3Rpb24odmFsdWUsIG9sZFZhbHVlLCByKTtcbiAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgfVxuXG4gIHIuc2NoZWR1bGVfKCk7XG4gIHJldHVybiByLmdldERpc3Bvc2VyXygpO1xufVxuXG5mdW5jdGlvbiB3cmFwRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlciwgYmFzZUZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBiYXNlRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvckhhbmRsZXIuY2FsbCh0aGlzLCBlKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBPTl9CRUNPTUVfT0JTRVJWRUQgPSBcIm9uQk9cIjtcbnZhciBPTl9CRUNPTUVfVU5PQlNFUlZFRCA9IFwib25CVU9cIjtcbmZ1bmN0aW9uIG9uQmVjb21lT2JzZXJ2ZWQodGhpbmcsIGFyZzIsIGFyZzMpIHtcbiAgcmV0dXJuIGludGVyY2VwdEhvb2soT05fQkVDT01FX09CU0VSVkVELCB0aGluZywgYXJnMiwgYXJnMyk7XG59XG5mdW5jdGlvbiBvbkJlY29tZVVub2JzZXJ2ZWQodGhpbmcsIGFyZzIsIGFyZzMpIHtcbiAgcmV0dXJuIGludGVyY2VwdEhvb2soT05fQkVDT01FX1VOT0JTRVJWRUQsIHRoaW5nLCBhcmcyLCBhcmczKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0SG9vayhob29rLCB0aGluZywgYXJnMiwgYXJnMykge1xuICB2YXIgYXRvbSA9IHR5cGVvZiBhcmczID09PSBcImZ1bmN0aW9uXCIgPyBnZXRBdG9tKHRoaW5nLCBhcmcyKSA6IGdldEF0b20odGhpbmcpO1xuICB2YXIgY2IgPSBpc0Z1bmN0aW9uKGFyZzMpID8gYXJnMyA6IGFyZzI7XG4gIHZhciBsaXN0ZW5lcnNLZXkgPSBob29rICsgXCJMXCI7XG5cbiAgaWYgKGF0b21bbGlzdGVuZXJzS2V5XSkge1xuICAgIGF0b21bbGlzdGVuZXJzS2V5XS5hZGQoY2IpO1xuICB9IGVsc2Uge1xuICAgIGF0b21bbGlzdGVuZXJzS2V5XSA9IG5ldyBTZXQoW2NiXSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBob29rTGlzdGVuZXJzID0gYXRvbVtsaXN0ZW5lcnNLZXldO1xuXG4gICAgaWYgKGhvb2tMaXN0ZW5lcnMpIHtcbiAgICAgIGhvb2tMaXN0ZW5lcnNbXCJkZWxldGVcIl0oY2IpO1xuXG4gICAgICBpZiAoaG9va0xpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBhdG9tW2xpc3RlbmVyc0tleV07XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgTkVWRVIgPSBcIm5ldmVyXCI7XG52YXIgQUxXQVlTID0gXCJhbHdheXNcIjtcbnZhciBPQlNFUlZFRCA9IFwib2JzZXJ2ZWRcIjsgLy8gY29uc3QgSUZfQVZBSUxBQkxFID0gXCJpZmF2YWlsYWJsZVwiXG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmlzb2xhdGVHbG9iYWxTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgIGlzb2xhdGVHbG9iYWxTdGF0ZSgpO1xuICB9XG5cbiAgdmFyIHVzZVByb3hpZXMgPSBvcHRpb25zLnVzZVByb3hpZXMsXG4gICAgICBlbmZvcmNlQWN0aW9ucyA9IG9wdGlvbnMuZW5mb3JjZUFjdGlvbnM7XG5cbiAgaWYgKHVzZVByb3hpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGdsb2JhbFN0YXRlLnVzZVByb3hpZXMgPSB1c2VQcm94aWVzID09PSBBTFdBWVMgPyB0cnVlIDogdXNlUHJveGllcyA9PT0gTkVWRVIgPyBmYWxzZSA6IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgfVxuXG4gIGlmICh1c2VQcm94aWVzID09PSBcImlmYXZhaWxhYmxlXCIpIGdsb2JhbFN0YXRlLnZlcmlmeVByb3hpZXMgPSB0cnVlO1xuXG4gIGlmIChlbmZvcmNlQWN0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGVhID0gZW5mb3JjZUFjdGlvbnMgPT09IEFMV0FZUyA/IEFMV0FZUyA6IGVuZm9yY2VBY3Rpb25zID09PSBPQlNFUlZFRDtcbiAgICBnbG9iYWxTdGF0ZS5lbmZvcmNlQWN0aW9ucyA9IGVhO1xuICAgIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gZWEgPT09IHRydWUgfHwgZWEgPT09IEFMV0FZUyA/IGZhbHNlIDogdHJ1ZTtcbiAgfVxuICBbXCJjb21wdXRlZFJlcXVpcmVzUmVhY3Rpb25cIiwgXCJyZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZVwiLCBcIm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uXCIsIFwiZGlzYWJsZUVycm9yQm91bmRhcmllc1wiLCBcInNhZmVEZXNjcmlwdG9yc1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5IGluIG9wdGlvbnMpIGdsb2JhbFN0YXRlW2tleV0gPSAhIW9wdGlvbnNba2V5XTtcbiAgfSk7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyA9ICFnbG9iYWxTdGF0ZS5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbjtcblxuICBpZiAoIGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMgPT09IHRydWUpIHtcbiAgICBjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBEZWJ1ZyBmZWF0dXJlIG9ubHkuIE1vYlggd2lsbCBOT1QgcmVjb3ZlciBmcm9tIGVycm9ycyB3aGVuIGBkaXNhYmxlRXJyb3JCb3VuZGFyaWVzYCBpcyBlbmFibGVkLlwiKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlYWN0aW9uU2NoZWR1bGVyKSB7XG4gICAgc2V0UmVhY3Rpb25TY2hlZHVsZXIob3B0aW9ucy5yZWFjdGlvblNjaGVkdWxlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0ZW5kT2JzZXJ2YWJsZSh0YXJnZXQsIHByb3BlcnRpZXMsIGFubm90YXRpb25zLCBvcHRpb25zKSB7XG4gIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDQpIGRpZShcIidleHRlbmRPYnNlcnZhYmxlJyBleHBlY3RlZCAyLTQgYXJndW1lbnRzXCIpO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiKSBkaWUoXCInZXh0ZW5kT2JzZXJ2YWJsZScgZXhwZWN0cyBhbiBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnRcIik7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0YXJnZXQpKSBkaWUoXCInZXh0ZW5kT2JzZXJ2YWJsZScgc2hvdWxkIG5vdCBiZSB1c2VkIG9uIG1hcHMsIHVzZSBtYXAubWVyZ2UgaW5zdGVhZFwiKTtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QocHJvcGVydGllcykpIGRpZShcIidleHRlbmRPYnNlcnZhYmUnIG9ubHkgYWNjZXB0cyBwbGFpbiBvYmplY3RzIGFzIHNlY29uZCBhcmd1bWVudFwiKTtcbiAgICBpZiAoaXNPYnNlcnZhYmxlKHByb3BlcnRpZXMpIHx8IGlzT2JzZXJ2YWJsZShhbm5vdGF0aW9ucykpIGRpZShcIkV4dGVuZGluZyBhbiBvYmplY3Qgd2l0aCBhbm90aGVyIG9ic2VydmFibGUgKG9iamVjdCkgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgfSAvLyBQdWxsIGRlc2NyaXB0b3JzIGZpcnN0LCBzbyB3ZSBkb24ndCBoYXZlIHRvIGRlYWwgd2l0aCBwcm9wcyBhZGRlZCBieSBhZG1pbmlzdHJhdGlvbiAoJG1vYngpXG5cblxuICB2YXIgZGVzY3JpcHRvcnMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHByb3BlcnRpZXMpO1xuICB2YXIgYWRtID0gYXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucylbJG1vYnhdO1xuICBzdGFydEJhdGNoKCk7XG5cbiAgdHJ5IHtcbiAgICBvd25LZXlzKGRlc2NyaXB0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGFkbS5leHRlbmRfKGtleSwgZGVzY3JpcHRvcnNba2V5XSwgLy8gbXVzdCBwYXNzIFwidW5kZWZpbmVkXCIgZm9yIHsga2V5OiB1bmRlZmluZWQgfVxuICAgICAgIWFubm90YXRpb25zID8gdHJ1ZSA6IGtleSBpbiBhbm5vdGF0aW9ucyA/IGFubm90YXRpb25zW2tleV0gOiB0cnVlKTtcbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBlbmRCYXRjaCgpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeVRyZWUodGhpbmcsIHByb3BlcnR5KSB7XG4gIHJldHVybiBub2RlVG9EZXBlbmRlbmN5VHJlZShnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkpO1xufVxuXG5mdW5jdGlvbiBub2RlVG9EZXBlbmRlbmN5VHJlZShub2RlKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgbmFtZTogbm9kZS5uYW1lX1xuICB9O1xuICBpZiAobm9kZS5vYnNlcnZpbmdfICYmIG5vZGUub2JzZXJ2aW5nXy5sZW5ndGggPiAwKSByZXN1bHQuZGVwZW5kZW5jaWVzID0gdW5pcXVlKG5vZGUub2JzZXJ2aW5nXykubWFwKG5vZGVUb0RlcGVuZGVuY3lUcmVlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJUcmVlKHRoaW5nLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gbm9kZVRvT2JzZXJ2ZXJUcmVlKGdldEF0b20odGhpbmcsIHByb3BlcnR5KSk7XG59XG5cbmZ1bmN0aW9uIG5vZGVUb09ic2VydmVyVHJlZShub2RlKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgbmFtZTogbm9kZS5uYW1lX1xuICB9O1xuICBpZiAoaGFzT2JzZXJ2ZXJzKG5vZGUpKSByZXN1bHQub2JzZXJ2ZXJzID0gQXJyYXkuZnJvbShnZXRPYnNlcnZlcnMobm9kZSkpLm1hcChub2RlVG9PYnNlcnZlclRyZWUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1bmlxdWUobGlzdCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGxpc3QpKTtcbn1cblxudmFyIGdlbmVyYXRvcklkID0gMDtcbmZ1bmN0aW9uIEZsb3dDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgdGhpcy5tZXNzYWdlID0gXCJGTE9XX0NBTkNFTExFRFwiO1xufVxuRmxvd0NhbmNlbGxhdGlvbkVycm9yLnByb3RvdHlwZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5mdW5jdGlvbiBpc0Zsb3dDYW5jZWxsYXRpb25FcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBGbG93Q2FuY2VsbGF0aW9uRXJyb3I7XG59XG52YXIgZmxvd0Fubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlRmxvd0Fubm90YXRpb24oXCJmbG93XCIpO1xudmFyIGZsb3dCb3VuZEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlRmxvd0Fubm90YXRpb24oXCJmbG93LmJvdW5kXCIsIHtcbiAgYm91bmQ6IHRydWVcbn0pO1xudmFyIGZsb3cgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBmbG93KGFyZzEsIGFyZzIpIHtcbiAgLy8gQGZsb3dcbiAgaWYgKGlzU3RyaW5naXNoKGFyZzIpKSB7XG4gICAgcmV0dXJuIHN0b3JlQW5ub3RhdGlvbihhcmcxLCBhcmcyLCBmbG93QW5ub3RhdGlvbik7XG4gIH0gLy8gZmxvdyhmbilcblxuXG4gIGlmICggYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkgZGllKFwiRmxvdyBleHBlY3RzIHNpbmdsZSBhcmd1bWVudCB3aXRoIGdlbmVyYXRvciBmdW5jdGlvblwiKTtcbiAgdmFyIGdlbmVyYXRvciA9IGFyZzE7XG4gIHZhciBuYW1lID0gZ2VuZXJhdG9yLm5hbWUgfHwgXCI8dW5uYW1lZCBmbG93PlwiOyAvLyBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vdGovY28vYmxvYi9tYXN0ZXIvaW5kZXguanNcblxuICB2YXIgcmVzID0gZnVuY3Rpb24gcmVzKCkge1xuICAgIHZhciBjdHggPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBydW5JZCA9ICsrZ2VuZXJhdG9ySWQ7XG4gICAgdmFyIGdlbiA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0gaW5pdFwiLCBnZW5lcmF0b3IpLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgdmFyIHJlamVjdG9yO1xuICAgIHZhciBwZW5kaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBzdGVwSWQgPSAwO1xuICAgICAgcmVqZWN0b3IgPSByZWplY3Q7XG5cbiAgICAgIGZ1bmN0aW9uIG9uRnVsZmlsbGVkKHJlcykge1xuICAgICAgICBwZW5kaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHJldDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldCA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0geWllbGQgXCIgKyBzdGVwSWQrKywgZ2VuLm5leHQpLmNhbGwoZ2VuLCByZXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQocmV0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25SZWplY3RlZChlcnIpIHtcbiAgICAgICAgcGVuZGluZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXQgPSBhY3Rpb24obmFtZSArIFwiIC0gcnVuaWQ6IFwiICsgcnVuSWQgKyBcIiAtIHlpZWxkIFwiICsgc3RlcElkKyssIGdlbltcInRocm93XCJdKS5jYWxsKGdlbiwgZXJyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KHJldCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG5leHQocmV0KSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHJldCA9PSBudWxsID8gdm9pZCAwIDogcmV0LnRoZW4pKSB7XG4gICAgICAgICAgLy8gYW4gYXN5bmMgaXRlcmF0b3JcbiAgICAgICAgICByZXQudGhlbihuZXh0LCByZWplY3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXQuZG9uZSkgcmV0dXJuIHJlc29sdmUocmV0LnZhbHVlKTtcbiAgICAgICAgcGVuZGluZ1Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUocmV0LnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdQcm9taXNlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICBvbkZ1bGZpbGxlZCh1bmRlZmluZWQpOyAvLyBraWNrIG9mZiB0aGUgcHJvY2Vzc1xuICAgIH0pO1xuICAgIHByb21pc2UuY2FuY2VsID0gYWN0aW9uKG5hbWUgKyBcIiAtIHJ1bmlkOiBcIiArIHJ1bklkICsgXCIgLSBjYW5jZWxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHBlbmRpbmdQcm9taXNlKSBjYW5jZWxQcm9taXNlKHBlbmRpbmdQcm9taXNlKTsgLy8gRmluYWxseSBibG9jayBjYW4gcmV0dXJuIChvciB5aWVsZCkgc3R1ZmYuLlxuXG4gICAgICAgIHZhciBfcmVzID0gZ2VuW1wicmV0dXJuXCJdKHVuZGVmaW5lZCk7IC8vIGVhdCBhbnl0aGluZyB0aGF0IHByb21pc2Ugd291bGQgZG8sIGl0J3MgY2FuY2VsbGVkIVxuXG5cbiAgICAgICAgdmFyIHlpZWxkZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKF9yZXMudmFsdWUpO1xuICAgICAgICB5aWVsZGVkUHJvbWlzZS50aGVuKG5vb3AsIG5vb3ApO1xuICAgICAgICBjYW5jZWxQcm9taXNlKHlpZWxkZWRQcm9taXNlKTsgLy8gbWF5YmUgaXQgY2FuIGJlIGNhbmNlbGxlZCA6KVxuICAgICAgICAvLyByZWplY3Qgb3VyIG9yaWdpbmFsIHByb21pc2VcblxuICAgICAgICByZWplY3RvcihuZXcgRmxvd0NhbmNlbGxhdGlvbkVycm9yKCkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3RvcihlKTsgLy8gdGhlcmUgY291bGQgYmUgYSB0aHJvd2luZyBmaW5hbGx5IGJsb2NrXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgcmVzLmlzTW9iWEZsb3cgPSB0cnVlO1xuICByZXR1cm4gcmVzO1xufSwgZmxvd0Fubm90YXRpb24pO1xuZmxvdy5ib3VuZCA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGZsb3dCb3VuZEFubm90YXRpb24pO1xuXG5mdW5jdGlvbiBjYW5jZWxQcm9taXNlKHByb21pc2UpIHtcbiAgaWYgKGlzRnVuY3Rpb24ocHJvbWlzZS5jYW5jZWwpKSBwcm9taXNlLmNhbmNlbCgpO1xufVxuXG5mdW5jdGlvbiBmbG93UmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gcmVzdWx0OyAvLyBqdXN0IHRyaWNraW5nIFR5cGVTY3JpcHQgOilcbn1cbmZ1bmN0aW9uIGlzRmxvdyhmbikge1xuICByZXR1cm4gKGZuID09IG51bGwgPyB2b2lkIDAgOiBmbi5pc01vYlhGbG93KSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0UmVhZHModGhpbmcsIHByb3BPckhhbmRsZXIsIGhhbmRsZXIpIHtcbiAgdmFyIHRhcmdldDtcblxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSB8fCBpc09ic2VydmFibGVBcnJheSh0aGluZykgfHwgaXNPYnNlcnZhYmxlVmFsdWUodGhpbmcpKSB7XG4gICAgdGFyZ2V0ID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykpIHtcbiAgICBpZiAoICFpc1N0cmluZ2lzaChwcm9wT3JIYW5kbGVyKSkgcmV0dXJuIGRpZShcIkludGVyY2VwdFJlYWRzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBhIHNwZWNpZmljIHByb3BlcnR5LCBub3Qgd2l0aCBhbiBvYmplY3QgaW4gZ2VuZXJhbFwiKTtcbiAgICB0YXJnZXQgPSBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcE9ySGFuZGxlcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpZShcIkV4cGVjdGVkIG9ic2VydmFibGUgbWFwLCBvYmplY3Qgb3IgYXJyYXkgYXMgZmlyc3QgYXJyYXlcIik7XG4gIH1cblxuICBpZiAoIHRhcmdldC5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZGllKFwiQW4gaW50ZXJjZXB0IHJlYWRlciB3YXMgYWxyZWFkeSBlc3RhYmxpc2hlZFwiKTtcbiAgdGFyZ2V0LmRlaGFuY2VyID0gdHlwZW9mIHByb3BPckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIiA/IHByb3BPckhhbmRsZXIgOiBoYW5kbGVyO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHRhcmdldC5kZWhhbmNlciA9IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0KHRoaW5nLCBwcm9wT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSByZXR1cm4gaW50ZXJjZXB0UHJvcGVydHkodGhpbmcsIHByb3BPckhhbmRsZXIsIGhhbmRsZXIpO2Vsc2UgcmV0dXJuIGludGVyY2VwdEludGVyY2VwdGFibGUodGhpbmcsIHByb3BPckhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBpbnRlcmNlcHRJbnRlcmNlcHRhYmxlKHRoaW5nLCBoYW5kbGVyKSB7XG4gIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZykuaW50ZXJjZXB0XyhoYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJjZXB0UHJvcGVydHkodGhpbmcsIHByb3BlcnR5LCBoYW5kbGVyKSB7XG4gIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcGVydHkpLmludGVyY2VwdF8oaGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIF9pc0NvbXB1dGVkKHZhbHVlLCBwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpc09ic2VydmFibGVPYmplY3QodmFsdWUpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdmFsdWVbJG1vYnhdLnZhbHVlc18uaGFzKHByb3BlcnR5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBhdG9tID0gZ2V0QXRvbSh2YWx1ZSwgcHJvcGVydHkpO1xuICAgIHJldHVybiBpc0NvbXB1dGVkVmFsdWUoYXRvbSk7XG4gIH1cblxuICByZXR1cm4gaXNDb21wdXRlZFZhbHVlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzQ29tcHV0ZWQodmFsdWUpIHtcbiAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSkgcmV0dXJuIGRpZShcImlzQ29tcHV0ZWQgZXhwZWN0cyBvbmx5IDEgYXJndW1lbnQuIFVzZSBpc0NvbXB1dGVkUHJvcCB0byBpbnNwZWN0IHRoZSBvYnNlcnZhYmlsaXR5IG9mIGEgcHJvcGVydHlcIik7XG4gIHJldHVybiBfaXNDb21wdXRlZCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0NvbXB1dGVkUHJvcCh2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgaWYgKCAhaXNTdHJpbmdpc2gocHJvcE5hbWUpKSByZXR1cm4gZGllKFwiaXNDb21wdXRlZCBleHBlY3RlZCBhIHByb3BlcnR5IG5hbWUgYXMgc2Vjb25kIGFyZ3VtZW50XCIpO1xuICByZXR1cm4gX2lzQ29tcHV0ZWQodmFsdWUsIHByb3BOYW1lKTtcbn1cblxuZnVuY3Rpb24gX2lzT2JzZXJ2YWJsZSh2YWx1ZSwgcHJvcGVydHkpIHtcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCAoaXNPYnNlcnZhYmxlTWFwKHZhbHVlKSB8fCBpc09ic2VydmFibGVBcnJheSh2YWx1ZSkpKSByZXR1cm4gZGllKFwiaXNPYnNlcnZhYmxlKG9iamVjdCwgcHJvcGVydHlOYW1lKSBpcyBub3Qgc3VwcG9ydGVkIGZvciBhcnJheXMgYW5kIG1hcHMuIFVzZSBtYXAuaGFzIG9yIGFycmF5Lmxlbmd0aCBpbnN0ZWFkLlwiKTtcblxuICAgIGlmIChpc09ic2VydmFibGVPYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWVbJG1vYnhdLnZhbHVlc18uaGFzKHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gRm9yIGZpcnN0IGNoZWNrLCBzZWUgIzcwMVxuXG5cbiAgcmV0dXJuIGlzT2JzZXJ2YWJsZU9iamVjdCh2YWx1ZSkgfHwgISF2YWx1ZVskbW9ieF0gfHwgaXNBdG9tKHZhbHVlKSB8fCBpc1JlYWN0aW9uKHZhbHVlKSB8fCBpc0NvbXB1dGVkVmFsdWUodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBpc09ic2VydmFibGUodmFsdWUpIHtcbiAgaWYgKCBhcmd1bWVudHMubGVuZ3RoICE9PSAxKSBkaWUoXCJpc09ic2VydmFibGUgZXhwZWN0cyBvbmx5IDEgYXJndW1lbnQuIFVzZSBpc09ic2VydmFibGVQcm9wIHRvIGluc3BlY3QgdGhlIG9ic2VydmFiaWxpdHkgb2YgYSBwcm9wZXJ0eVwiKTtcbiAgcmV0dXJuIF9pc09ic2VydmFibGUodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlUHJvcCh2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgaWYgKCAhaXNTdHJpbmdpc2gocHJvcE5hbWUpKSByZXR1cm4gZGllKFwiZXhwZWN0ZWQgYSBwcm9wZXJ0eSBuYW1lIGFzIHNlY29uZCBhcmd1bWVudFwiKTtcbiAgcmV0dXJuIF9pc09ic2VydmFibGUodmFsdWUsIHByb3BOYW1lKTtcbn1cblxuZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0ua2V5c18oKTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVNYXAob2JqKSB8fCBpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKG9iai5rZXlzKCkpO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm1hcChmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9KTtcbiAgfVxuXG4gIGRpZSg1KTtcbn1cbmZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgcmV0dXJuIGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG9iai5nZXQoa2V5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKG9iai52YWx1ZXMoKSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgfVxuXG4gIGRpZSg2KTtcbn1cbmZ1bmN0aW9uIGVudHJpZXMob2JqKSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmpba2V5XV07XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqLmdldChrZXkpXTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKG9iai5lbnRyaWVzKCkpO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm1hcChmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuICAgICAgcmV0dXJuIFtpbmRleCwga2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpZSg3KTtcbn1cbmZ1bmN0aW9uIHNldChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIWlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHZhciBfdmFsdWVzID0ga2V5O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9rZXkgaW4gX3ZhbHVlcykge1xuICAgICAgICBzZXQob2JqLCBfa2V5LCBfdmFsdWVzW19rZXldKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICBvYmpbJG1vYnhdLnNldF8oa2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICBvYmouc2V0KGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgb2JqLmFkZChrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gXCJudW1iZXJcIikga2V5ID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgaWYgKGtleSA8IDApIGRpZShcIkludmFsaWQgaW5kZXg6ICdcIiArIGtleSArIFwiJ1wiKTtcbiAgICBzdGFydEJhdGNoKCk7XG4gICAgaWYgKGtleSA+PSBvYmoubGVuZ3RoKSBvYmoubGVuZ3RoID0ga2V5ICsgMTtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIGVuZEJhdGNoKCk7XG4gIH0gZWxzZSBkaWUoOCk7XG59XG5mdW5jdGlvbiByZW1vdmUob2JqLCBrZXkpIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgb2JqWyRtb2J4XS5kZWxldGVfKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICBvYmpbXCJkZWxldGVcIl0oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIG9ialtcImRlbGV0ZVwiXShrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICBpZiAodHlwZW9mIGtleSAhPT0gXCJudW1iZXJcIikga2V5ID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gICAgb2JqLnNwbGljZShrZXksIDEpO1xuICB9IGVsc2Uge1xuICAgIGRpZSg5KTtcbiAgfVxufVxuZnVuY3Rpb24gaGFzKG9iaiwga2V5KSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmpbJG1vYnhdLmhhc18oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIHJldHVybiBvYmouaGFzKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmhhcyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KG9iaikpIHtcbiAgICByZXR1cm4ga2V5ID49IDAgJiYga2V5IDwgb2JqLmxlbmd0aDtcbiAgfVxuXG4gIGRpZSgxMCk7XG59XG5mdW5jdGlvbiBnZXQob2JqLCBrZXkpIHtcbiAgaWYgKCFoYXMob2JqLCBrZXkpKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmpbJG1vYnhdLmdldF8oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIHJldHVybiBvYmouZ2V0KGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuXG4gIGRpZSgxMSk7XG59XG5mdW5jdGlvbiBhcGlEZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgZGVzY3JpcHRvcikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxuXG4gIGRpZSgzOSk7XG59XG5mdW5jdGlvbiBhcGlPd25LZXlzKG9iaikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5vd25LZXlzXygpO1xuICB9XG5cbiAgZGllKDM4KTtcbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZSh0aGluZywgcHJvcE9yQ2IsIGNiT3JGaXJlLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgaWYgKGlzRnVuY3Rpb24oY2JPckZpcmUpKSByZXR1cm4gb2JzZXJ2ZU9ic2VydmFibGVQcm9wZXJ0eSh0aGluZywgcHJvcE9yQ2IsIGNiT3JGaXJlLCBmaXJlSW1tZWRpYXRlbHkpO2Vsc2UgcmV0dXJuIG9ic2VydmVPYnNlcnZhYmxlKHRoaW5nLCBwcm9wT3JDYiwgY2JPckZpcmUpO1xufVxuXG5mdW5jdGlvbiBvYnNlcnZlT2JzZXJ2YWJsZSh0aGluZywgbGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpLm9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpO1xufVxuXG5mdW5jdGlvbiBvYnNlcnZlT2JzZXJ2YWJsZVByb3BlcnR5KHRoaW5nLCBwcm9wZXJ0eSwgbGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BlcnR5KS5vYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KTtcbn1cblxuZnVuY3Rpb24gY2FjaGUobWFwLCBrZXksIHZhbHVlKSB7XG4gIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdG9KU0hlbHBlcihzb3VyY2UsIF9fYWxyZWFkeVNlZW4pIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsIHx8IHR5cGVvZiBzb3VyY2UgIT09IFwib2JqZWN0XCIgfHwgc291cmNlIGluc3RhbmNlb2YgRGF0ZSB8fCAhaXNPYnNlcnZhYmxlKHNvdXJjZSkpIHJldHVybiBzb3VyY2U7XG4gIGlmIChpc09ic2VydmFibGVWYWx1ZShzb3VyY2UpIHx8IGlzQ29tcHV0ZWRWYWx1ZShzb3VyY2UpKSByZXR1cm4gdG9KU0hlbHBlcihzb3VyY2UuZ2V0KCksIF9fYWxyZWFkeVNlZW4pO1xuXG4gIGlmIChfX2FscmVhZHlTZWVuLmhhcyhzb3VyY2UpKSB7XG4gICAgcmV0dXJuIF9fYWxyZWFkeVNlZW4uZ2V0KHNvdXJjZSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkoc291cmNlKSkge1xuICAgIHZhciByZXMgPSBjYWNoZShfX2FscmVhZHlTZWVuLCBzb3VyY2UsIG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKSk7XG4gICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgIHJlc1tpZHhdID0gdG9KU0hlbHBlcih2YWx1ZSwgX19hbHJlYWR5U2Vlbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVTZXQoc291cmNlKSkge1xuICAgIHZhciBfcmVzID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCBuZXcgU2V0KCkpO1xuXG4gICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBfcmVzLmFkZCh0b0pTSGVscGVyKHZhbHVlLCBfX2FscmVhZHlTZWVuKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9yZXM7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKHNvdXJjZSkpIHtcbiAgICB2YXIgX3JlczIgPSBjYWNoZShfX2FscmVhZHlTZWVuLCBzb3VyY2UsIG5ldyBNYXAoKSk7XG5cbiAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgX3JlczIuc2V0KGtleSwgdG9KU0hlbHBlcih2YWx1ZSwgX19hbHJlYWR5U2VlbikpO1xuICAgIH0pO1xuICAgIHJldHVybiBfcmVzMjtcbiAgfSBlbHNlIHtcbiAgICAvLyBtdXN0IGJlIG9ic2VydmFibGUgb2JqZWN0XG4gICAgdmFyIF9yZXMzID0gY2FjaGUoX19hbHJlYWR5U2Vlbiwgc291cmNlLCB7fSk7XG5cbiAgICBhcGlPd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAob2JqZWN0UHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIF9yZXMzW2tleV0gPSB0b0pTSGVscGVyKHNvdXJjZVtrZXldLCBfX2FscmVhZHlTZWVuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3JlczM7XG4gIH1cbn1cbi8qKlxyXG4gKiBCYXNpY2FsbHksIGEgZGVlcCBjbG9uZSwgc28gdGhhdCBubyByZWFjdGl2ZSBwcm9wZXJ0eSB3aWxsIGV4aXN0IGFueW1vcmUuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvSlMoc291cmNlLCBvcHRpb25zKSB7XG4gIGlmICggb3B0aW9ucykgZGllKFwidG9KUyBubyBsb25nZXIgc3VwcG9ydHMgb3B0aW9uc1wiKTtcbiAgcmV0dXJuIHRvSlNIZWxwZXIoc291cmNlLCBuZXcgTWFwKCkpO1xufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgdmFyIGVudGVyQnJlYWtQb2ludCA9IGZhbHNlO1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gXCJib29sZWFuXCIpIGVudGVyQnJlYWtQb2ludCA9IGFyZ3MucG9wKCk7XG4gIHZhciBkZXJpdmF0aW9uID0gZ2V0QXRvbUZyb21BcmdzKGFyZ3MpO1xuXG4gIGlmICghZGVyaXZhdGlvbikge1xuICAgIHJldHVybiBkaWUoXCIndHJhY2UoYnJlYWs/KScgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgYSB0cmFja2VkIGNvbXB1dGVkIHZhbHVlIG9yIGEgUmVhY3Rpb24uIENvbnNpZGVyIHBhc3NpbmcgaW4gdGhlIGNvbXB1dGVkIHZhbHVlIG9yIHJlYWN0aW9uIGV4cGxpY2l0bHlcIik7XG4gIH1cblxuICBpZiAoZGVyaXZhdGlvbi5pc1RyYWNpbmdfID09PSBUcmFjZU1vZGUuTk9ORSkge1xuICAgIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIicgdHJhY2luZyBlbmFibGVkXCIpO1xuICB9XG5cbiAgZGVyaXZhdGlvbi5pc1RyYWNpbmdfID0gZW50ZXJCcmVha1BvaW50ID8gVHJhY2VNb2RlLkJSRUFLIDogVHJhY2VNb2RlLkxPRztcbn1cblxuZnVuY3Rpb24gZ2V0QXRvbUZyb21BcmdzKGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZ2V0QXRvbShhcmdzWzBdKTtcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBnZXRBdG9tKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICB9XG59XG5cbi8qKlxyXG4gKiBEdXJpbmcgYSB0cmFuc2FjdGlvbiBubyB2aWV3cyBhcmUgdXBkYXRlZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSB0cmFuc2FjdGlvbi5cclxuICogVGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcnVuIHN5bmNocm9ub3VzbHkgbm9uZXRoZWxlc3MuXHJcbiAqXHJcbiAqIEBwYXJhbSBhY3Rpb24gYSBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgc29tZSByZWFjdGl2ZSBzdGF0ZVxyXG4gKiBAcmV0dXJucyBhbnkgdmFsdWUgdGhhdCB3YXMgcmV0dXJuZWQgYnkgdGhlICdhY3Rpb24nIHBhcmFtZXRlci5cclxuICovXG5cbmZ1bmN0aW9uIHRyYW5zYWN0aW9uKGFjdGlvbiwgdGhpc0FyZykge1xuICBpZiAodGhpc0FyZyA9PT0gdm9pZCAwKSB7XG4gICAgdGhpc0FyZyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHN0YXJ0QmF0Y2goKTtcblxuICB0cnkge1xuICAgIHJldHVybiBhY3Rpb24uYXBwbHkodGhpc0FyZyk7XG4gIH0gZmluYWxseSB7XG4gICAgZW5kQmF0Y2goKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3aGVuKHByZWRpY2F0ZSwgYXJnMSwgYXJnMikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCBhcmcxICYmIHR5cGVvZiBhcmcxID09PSBcIm9iamVjdFwiKSByZXR1cm4gd2hlblByb21pc2UocHJlZGljYXRlLCBhcmcxKTtcbiAgcmV0dXJuIF93aGVuKHByZWRpY2F0ZSwgYXJnMSwgYXJnMiB8fCB7fSk7XG59XG5cbmZ1bmN0aW9uIF93aGVuKHByZWRpY2F0ZSwgZWZmZWN0LCBvcHRzKSB7XG4gIHZhciB0aW1lb3V0SGFuZGxlO1xuXG4gIGlmICh0eXBlb2Ygb3B0cy50aW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiV0hFTl9USU1FT1VUXCIpO1xuICAgIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZGlzcG9zZXJbJG1vYnhdLmlzRGlzcG9zZWRfKSB7XG4gICAgICAgIGRpc3Bvc2VyKCk7XG4gICAgICAgIGlmIChvcHRzLm9uRXJyb3IpIG9wdHMub25FcnJvcihlcnJvcik7ZWxzZSB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9LCBvcHRzLnRpbWVvdXQpO1xuICB9XG5cbiAgb3B0cy5uYW1lID0gIG9wdHMubmFtZSB8fCBcIldoZW5AXCIgKyBnZXROZXh0SWQoKSA7XG4gIHZhciBlZmZlY3RBY3Rpb24gPSBjcmVhdGVBY3Rpb24oIG9wdHMubmFtZSArIFwiLWVmZmVjdFwiICwgZWZmZWN0KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbiAgdmFyIGRpc3Bvc2VyID0gYXV0b3J1bihmdW5jdGlvbiAocikge1xuICAgIC8vIHByZWRpY2F0ZSBzaG91bGQgbm90IGNoYW5nZSBzdGF0ZVxuICAgIHZhciBjb25kID0gYWxsb3dTdGF0ZUNoYW5nZXMoZmFsc2UsIHByZWRpY2F0ZSk7XG5cbiAgICBpZiAoY29uZCkge1xuICAgICAgci5kaXNwb3NlKCk7XG4gICAgICBpZiAodGltZW91dEhhbmRsZSkgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgICAgZWZmZWN0QWN0aW9uKCk7XG4gICAgfVxuICB9LCBvcHRzKTtcbiAgcmV0dXJuIGRpc3Bvc2VyO1xufVxuXG5mdW5jdGlvbiB3aGVuUHJvbWlzZShwcmVkaWNhdGUsIG9wdHMpIHtcbiAgaWYgKCBvcHRzICYmIG9wdHMub25FcnJvcikgcmV0dXJuIGRpZShcInRoZSBvcHRpb25zICdvbkVycm9yJyBhbmQgJ3Byb21pc2UnIGNhbm5vdCBiZSBjb21iaW5lZFwiKTtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgZGlzcG9zZXIgPSBfd2hlbihwcmVkaWNhdGUsIHJlc29sdmUsIF9leHRlbmRzKHt9LCBvcHRzLCB7XG4gICAgICBvbkVycm9yOiByZWplY3RcbiAgICB9KSk7XG5cbiAgICBjYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICBkaXNwb3NlcigpO1xuICAgICAgcmVqZWN0KFwiV0hFTl9DQU5DRUxMRURcIik7XG4gICAgfTtcbiAgfSk7XG4gIHJlcy5jYW5jZWwgPSBjYW5jZWw7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGdldEFkbSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFskbW9ieF07XG59IC8vIE9wdGltaXphdGlvbjogd2UgZG9uJ3QgbmVlZCB0aGUgaW50ZXJtZWRpYXRlIG9iamVjdHMgYW5kIGNvdWxkIGhhdmUgYSBjb21wbGV0ZWx5IGN1c3RvbSBhZG1pbmlzdHJhdGlvbiBmb3IgRHluYW1pY09iamVjdHMsXG4vLyBhbmQgc2tpcCBlaXRoZXIgdGhlIGludGVybmFsIHZhbHVlcyBtYXAsIG9yIHRoZSBiYXNlIG9iamVjdCB3aXRoIGl0cyBwcm9wZXJ0eSBkZXNjcmlwdG9ycyFcblxuXG52YXIgb2JqZWN0UHJveHlUcmFwcyA9IHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBuYW1lKSB7XG4gICAgaWYgKCBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJkZXRlY3QgbmV3IHByb3BlcnRpZXMgdXNpbmcgdGhlICdpbicgb3BlcmF0b3IuIFVzZSAnaGFzJyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gZ2V0QWRtKHRhcmdldCkuaGFzXyhuYW1lKTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBuYW1lKSB7XG4gICAgcmV0dXJuIGdldEFkbSh0YXJnZXQpLmdldF8obmFtZSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgX2dldEFkbSRzZXRfO1xuXG4gICAgaWYgKCFpc1N0cmluZ2lzaChuYW1lKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCAhZ2V0QWRtKHRhcmdldCkudmFsdWVzXy5oYXMobmFtZSkpIHtcbiAgICAgIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJhZGQgYSBuZXcgb2JzZXJ2YWJsZSBwcm9wZXJ0eSB0aHJvdWdoIGRpcmVjdCBhc3NpZ25tZW50LiBVc2UgJ3NldCcgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgfSAvLyBudWxsIChpbnRlcmNlcHRlZCkgLT4gdHJ1ZSAoc3VjY2VzcylcblxuXG4gICAgcmV0dXJuIChfZ2V0QWRtJHNldF8gPSBnZXRBZG0odGFyZ2V0KS5zZXRfKG5hbWUsIHZhbHVlLCB0cnVlKSkgIT0gbnVsbCA/IF9nZXRBZG0kc2V0XyA6IHRydWU7XG4gIH0sXG4gIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUpIHtcbiAgICB2YXIgX2dldEFkbSRkZWxldGVfO1xuXG4gICAge1xuICAgICAgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcImRlbGV0ZSBwcm9wZXJ0aWVzIGZyb20gYW4gb2JzZXJ2YWJsZSBvYmplY3QuIFVzZSAncmVtb3ZlJyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU3RyaW5naXNoKG5hbWUpKSByZXR1cm4gZmFsc2U7IC8vIG51bGwgKGludGVyY2VwdGVkKSAtPiB0cnVlIChzdWNjZXNzKVxuXG4gICAgcmV0dXJuIChfZ2V0QWRtJGRlbGV0ZV8gPSBnZXRBZG0odGFyZ2V0KS5kZWxldGVfKG5hbWUsIHRydWUpKSAhPSBudWxsID8gX2dldEFkbSRkZWxldGVfIDogdHJ1ZTtcbiAgfSxcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcikge1xuICAgIHZhciBfZ2V0QWRtJGRlZmluZVByb3BlcnQ7XG5cbiAgICB7XG4gICAgICB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiZGVmaW5lIHByb3BlcnR5IG9uIGFuIG9ic2VydmFibGUgb2JqZWN0LiBVc2UgJ2RlZmluZVByb3BlcnR5JyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICB9IC8vIG51bGwgKGludGVyY2VwdGVkKSAtPiB0cnVlIChzdWNjZXNzKVxuXG5cbiAgICByZXR1cm4gKF9nZXRBZG0kZGVmaW5lUHJvcGVydCA9IGdldEFkbSh0YXJnZXQpLmRlZmluZVByb3BlcnR5XyhuYW1lLCBkZXNjcmlwdG9yKSkgIT0gbnVsbCA/IF9nZXRBZG0kZGVmaW5lUHJvcGVydCA6IHRydWU7XG4gIH0sXG4gIG93bktleXM6IGZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XG4gICAgaWYgKCBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJpdGVyYXRlIGtleXMgdG8gZGV0ZWN0IGFkZGVkIC8gcmVtb3ZlZCBwcm9wZXJ0aWVzLiBVc2UgJ2tleXMnIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiBnZXRBZG0odGFyZ2V0KS5vd25LZXlzXygpO1xuICB9LFxuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KSB7XG4gICAgZGllKDEzKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGFzRHluYW1pY09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciBfdGFyZ2V0JCRtb2J4LCBfdGFyZ2V0JCRtb2J4JHByb3h5XztcblxuICBhc3NlcnRQcm94aWVzKCk7XG4gIHRhcmdldCA9IGFzT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpO1xuICByZXR1cm4gKF90YXJnZXQkJG1vYngkcHJveHlfID0gKF90YXJnZXQkJG1vYnggPSB0YXJnZXRbJG1vYnhdKS5wcm94eV8pICE9IG51bGwgPyBfdGFyZ2V0JCRtb2J4JHByb3h5XyA6IF90YXJnZXQkJG1vYngucHJveHlfID0gbmV3IFByb3h5KHRhcmdldCwgb2JqZWN0UHJveHlUcmFwcyk7XG59XG5cbmZ1bmN0aW9uIGhhc0ludGVyY2VwdG9ycyhpbnRlcmNlcHRhYmxlKSB7XG4gIHJldHVybiBpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9yc18gIT09IHVuZGVmaW5lZCAmJiBpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9yc18ubGVuZ3RoID4gMDtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVySW50ZXJjZXB0b3IoaW50ZXJjZXB0YWJsZSwgaGFuZGxlcikge1xuICB2YXIgaW50ZXJjZXB0b3JzID0gaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfIHx8IChpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9yc18gPSBbXSk7XG4gIGludGVyY2VwdG9ycy5wdXNoKGhhbmRsZXIpO1xuICByZXR1cm4gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IGludGVyY2VwdG9ycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgIGlmIChpZHggIT09IC0xKSBpbnRlcmNlcHRvcnMuc3BsaWNlKGlkeCwgMSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW50ZXJjZXB0Q2hhbmdlKGludGVyY2VwdGFibGUsIGNoYW5nZSkge1xuICB2YXIgcHJldlUgPSB1bnRyYWNrZWRTdGFydCgpO1xuXG4gIHRyeSB7XG4gICAgLy8gSW50ZXJjZXB0b3IgY2FuIG1vZGlmeSB0aGUgYXJyYXksIGNvcHkgaXQgdG8gYXZvaWQgY29uY3VycmVudCBtb2RpZmljYXRpb24sIHNlZSAjMTk1MFxuICAgIHZhciBpbnRlcmNlcHRvcnMgPSBbXS5jb25jYXQoaW50ZXJjZXB0YWJsZS5pbnRlcmNlcHRvcnNfIHx8IFtdKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW50ZXJjZXB0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2hhbmdlID0gaW50ZXJjZXB0b3JzW2ldKGNoYW5nZSk7XG4gICAgICBpZiAoY2hhbmdlICYmICFjaGFuZ2UudHlwZSkgZGllKDE0KTtcbiAgICAgIGlmICghY2hhbmdlKSBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlO1xuICB9IGZpbmFsbHkge1xuICAgIHVudHJhY2tlZEVuZChwcmV2VSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTGlzdGVuZXJzKGxpc3RlbmFibGUpIHtcbiAgcmV0dXJuIGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzXyAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzXy5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcihsaXN0ZW5hYmxlLCBoYW5kbGVyKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc18gfHwgKGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzXyA9IFtdKTtcbiAgbGlzdGVuZXJzLnB1c2goaGFuZGxlcik7XG4gIHJldHVybiBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gbGlzdGVuZXJzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgaWYgKGlkeCAhPT0gLTEpIGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMobGlzdGVuYWJsZSwgY2hhbmdlKSB7XG4gIHZhciBwcmV2VSA9IHVudHJhY2tlZFN0YXJ0KCk7XG4gIHZhciBsaXN0ZW5lcnMgPSBsaXN0ZW5hYmxlLmNoYW5nZUxpc3RlbmVyc187XG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm47XG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxpc3RlbmVyc1tpXShjaGFuZ2UpO1xuICB9XG5cbiAgdW50cmFja2VkRW5kKHByZXZVKTtcbn1cblxuZnVuY3Rpb24gbWFrZU9ic2VydmFibGUodGFyZ2V0LCBhbm5vdGF0aW9ucywgb3B0aW9ucykge1xuICB2YXIgYWRtID0gYXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucylbJG1vYnhdO1xuICBzdGFydEJhdGNoKCk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgX2Fubm90YXRpb25zO1xuXG4gICAgLy8gRGVmYXVsdCB0byBkZWNvcmF0b3JzXG4gICAgKF9hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zKSAhPSBudWxsID8gX2Fubm90YXRpb25zIDogYW5ub3RhdGlvbnMgPSBjb2xsZWN0U3RvcmVkQW5ub3RhdGlvbnModGFyZ2V0KTsgLy8gQW5ub3RhdGVcblxuICAgIG93bktleXMoYW5ub3RhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGFkbS5tYWtlXyhrZXksIGFubm90YXRpb25zW2tleV0pO1xuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSAvLyBwcm90b1trZXlzU3ltYm9sXSA9IG5ldyBTZXQ8UHJvcGVydHlLZXk+KClcblxudmFyIGtleXNTeW1ib2wgPSAvKiNfX1BVUkVfXyovU3ltYm9sKFwibW9ieC1rZXlzXCIpO1xuZnVuY3Rpb24gbWFrZUF1dG9PYnNlcnZhYmxlKHRhcmdldCwgb3ZlcnJpZGVzLCBvcHRpb25zKSB7XG4gIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiAhaXNQbGFpbk9iamVjdChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIGRpZShcIidtYWtlQXV0b09ic2VydmFibGUnIGNhbiBvbmx5IGJlIHVzZWQgZm9yIGNsYXNzZXMgdGhhdCBkb24ndCBoYXZlIGEgc3VwZXJjbGFzc1wiKTtcbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCkpIGRpZShcIm1ha2VBdXRvT2JzZXJ2YWJsZSBjYW4gb25seSBiZSB1c2VkIG9uIG9iamVjdHMgbm90IGFscmVhZHkgbWFkZSBvYnNlcnZhYmxlXCIpO1xuICB9IC8vIE9wdGltaXphdGlvbjogYXZvaWQgdmlzaXRpbmcgcHJvdG9zXG4gIC8vIEFzc3VtZXMgdGhhdCBhbm5vdGF0aW9uLm1ha2VfLy5leHRlbmRfIHdvcmtzIHRoZSBzYW1lIGZvciBwbGFpbiBvYmplY3RzXG5cblxuICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGV4dGVuZE9ic2VydmFibGUodGFyZ2V0LCB0YXJnZXQsIG92ZXJyaWRlcywgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgYWRtID0gYXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucylbJG1vYnhdOyAvLyBPcHRpbWl6YXRpb246IGNhY2hlIGtleXMgb24gcHJvdG9cbiAgLy8gQXNzdW1lcyBtYWtlQXV0b09ic2VydmFibGUgY2FuIGJlIGNhbGxlZCBvbmx5IG9uY2UgcGVyIG9iamVjdCBhbmQgY2FuJ3QgYmUgdXNlZCBpbiBzdWJjbGFzc1xuXG4gIGlmICghdGFyZ2V0W2tleXNTeW1ib2xdKSB7XG4gICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gICAgdmFyIGtleXMgPSBuZXcgU2V0KFtdLmNvbmNhdChvd25LZXlzKHRhcmdldCksIG93bktleXMocHJvdG8pKSk7XG4gICAga2V5c1tcImRlbGV0ZVwiXShcImNvbnN0cnVjdG9yXCIpO1xuICAgIGtleXNbXCJkZWxldGVcIl0oJG1vYngpO1xuICAgIGFkZEhpZGRlblByb3AocHJvdG8sIGtleXNTeW1ib2wsIGtleXMpO1xuICB9XG5cbiAgc3RhcnRCYXRjaCgpO1xuXG4gIHRyeSB7XG4gICAgdGFyZ2V0W2tleXNTeW1ib2xdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGFkbS5tYWtlXyhrZXksIC8vIG11c3QgcGFzcyBcInVuZGVmaW5lZFwiIGZvciB7IGtleTogdW5kZWZpbmVkIH1cbiAgICAgICFvdmVycmlkZXMgPyB0cnVlIDoga2V5IGluIG92ZXJyaWRlcyA/IG92ZXJyaWRlc1trZXldIDogdHJ1ZSk7XG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgZW5kQmF0Y2goKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBTUExJQ0UgPSBcInNwbGljZVwiO1xudmFyIFVQREFURSA9IFwidXBkYXRlXCI7XG52YXIgTUFYX1NQTElDRV9TSVpFID0gMTAwMDA7IC8vIFNlZSBlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC9pc3N1ZXMvODU5XG5cbnZhciBhcnJheVRyYXBzID0ge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCh0YXJnZXQsIG5hbWUpIHtcbiAgICB2YXIgYWRtID0gdGFyZ2V0WyRtb2J4XTtcbiAgICBpZiAobmFtZSA9PT0gJG1vYngpIHJldHVybiBhZG07XG4gICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHJldHVybiBhZG0uZ2V0QXJyYXlMZW5ndGhfKCk7XG5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgJiYgIWlzTmFOKG5hbWUpKSB7XG4gICAgICByZXR1cm4gYWRtLmdldF8ocGFyc2VJbnQobmFtZSkpO1xuICAgIH1cblxuICAgIGlmIChoYXNQcm9wKGFycmF5RXh0ZW5zaW9ucywgbmFtZSkpIHtcbiAgICAgIHJldHVybiBhcnJheUV4dGVuc2lvbnNbbmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFtuYW1lXTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBhZG0gPSB0YXJnZXRbJG1vYnhdO1xuXG4gICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgIGFkbS5zZXRBcnJheUxlbmd0aF8odmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIiB8fCBpc05hTihuYW1lKSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG51bWVyaWMgc3RyaW5nXG4gICAgICBhZG0uc2V0XyhwYXJzZUludChuYW1lKSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoKSB7XG4gICAgZGllKDE1KTtcbiAgfVxufTtcbnZhciBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIHRoaXMgaXMgdGhlIHByb3AgdGhhdCBnZXRzIHByb3hpZWQsIHNvIGNhbid0IHJlcGxhY2UgaXQhXG4gIGZ1bmN0aW9uIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKG5hbWUsIGVuaGFuY2VyLCBvd25lZF8sIGxlZ2FjeU1vZGVfKSB7XG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgbmFtZSA9ICBcIk9ic2VydmFibGVBcnJheUBcIiArIGdldE5leHRJZCgpIDtcbiAgICB9XG5cbiAgICB0aGlzLm93bmVkXyA9IHZvaWQgMDtcbiAgICB0aGlzLmxlZ2FjeU1vZGVfID0gdm9pZCAwO1xuICAgIHRoaXMuYXRvbV8gPSB2b2lkIDA7XG4gICAgdGhpcy52YWx1ZXNfID0gW107XG4gICAgdGhpcy5pbnRlcmNlcHRvcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmVuaGFuY2VyXyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlaGFuY2VyID0gdm9pZCAwO1xuICAgIHRoaXMucHJveHlfID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdEtub3duTGVuZ3RoXyA9IDA7XG4gICAgdGhpcy5vd25lZF8gPSBvd25lZF87XG4gICAgdGhpcy5sZWdhY3lNb2RlXyA9IGxlZ2FjeU1vZGVfO1xuICAgIHRoaXMuYXRvbV8gPSBuZXcgQXRvbShuYW1lKTtcblxuICAgIHRoaXMuZW5oYW5jZXJfID0gZnVuY3Rpb24gKG5ld1YsIG9sZFYpIHtcbiAgICAgIHJldHVybiBlbmhhbmNlcihuZXdWLCBvbGRWLCAgbmFtZSArIFwiWy4uXVwiICk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZV8gPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWVfKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uZGVoYW5jZVZhbHVlc18gPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWVzXyh2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5kZWhhbmNlciAhPT0gdW5kZWZpbmVkICYmIHZhbHVlcy5sZW5ndGggPiAwKSByZXR1cm4gdmFsdWVzLm1hcCh0aGlzLmRlaGFuY2VyKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG5cbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIGlmIChmaXJlSW1tZWRpYXRlbHkgPT09IHZvaWQgMCkge1xuICAgICAgZmlyZUltbWVkaWF0ZWx5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgbGlzdGVuZXIoe1xuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJhcnJheVwiLFxuICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMuYXRvbV8ubmFtZV8sXG4gICAgICAgIHR5cGU6IFwic3BsaWNlXCIsXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBhZGRlZDogdGhpcy52YWx1ZXNfLnNsaWNlKCksXG4gICAgICAgIGFkZGVkQ291bnQ6IHRoaXMudmFsdWVzXy5sZW5ndGgsXG4gICAgICAgIHJlbW92ZWQ6IFtdLFxuICAgICAgICByZW1vdmVkQ291bnQ6IDBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0QXJyYXlMZW5ndGhfID0gZnVuY3Rpb24gZ2V0QXJyYXlMZW5ndGhfKCkge1xuICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNfLmxlbmd0aDtcbiAgfTtcblxuICBfcHJvdG8uc2V0QXJyYXlMZW5ndGhfID0gZnVuY3Rpb24gc2V0QXJyYXlMZW5ndGhfKG5ld0xlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgbmV3TGVuZ3RoICE9PSBcIm51bWJlclwiIHx8IG5ld0xlbmd0aCA8IDApIGRpZShcIk91dCBvZiByYW5nZTogXCIgKyBuZXdMZW5ndGgpO1xuICAgIHZhciBjdXJyZW50TGVuZ3RoID0gdGhpcy52YWx1ZXNfLmxlbmd0aDtcbiAgICBpZiAobmV3TGVuZ3RoID09PSBjdXJyZW50TGVuZ3RoKSByZXR1cm47ZWxzZSBpZiAobmV3TGVuZ3RoID4gY3VycmVudExlbmd0aCkge1xuICAgICAgdmFyIG5ld0l0ZW1zID0gbmV3IEFycmF5KG5ld0xlbmd0aCAtIGN1cnJlbnRMZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0xlbmd0aCAtIGN1cnJlbnRMZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdJdGVtc1tpXSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gLy8gTm8gQXJyYXkuZmlsbCBldmVyeXdoZXJlLi4uXG5cblxuICAgICAgdGhpcy5zcGxpY2VXaXRoQXJyYXlfKGN1cnJlbnRMZW5ndGgsIDAsIG5ld0l0ZW1zKTtcbiAgICB9IGVsc2UgdGhpcy5zcGxpY2VXaXRoQXJyYXlfKG5ld0xlbmd0aCwgY3VycmVudExlbmd0aCAtIG5ld0xlbmd0aCk7XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZUFycmF5TGVuZ3RoXyA9IGZ1bmN0aW9uIHVwZGF0ZUFycmF5TGVuZ3RoXyhvbGRMZW5ndGgsIGRlbHRhKSB7XG4gICAgaWYgKG9sZExlbmd0aCAhPT0gdGhpcy5sYXN0S25vd25MZW5ndGhfKSBkaWUoMTYpO1xuICAgIHRoaXMubGFzdEtub3duTGVuZ3RoXyArPSBkZWx0YTtcbiAgICBpZiAodGhpcy5sZWdhY3lNb2RlXyAmJiBkZWx0YSA+IDApIHJlc2VydmVBcnJheUJ1ZmZlcihvbGRMZW5ndGggKyBkZWx0YSArIDEpO1xuICB9O1xuXG4gIF9wcm90by5zcGxpY2VXaXRoQXJyYXlfID0gZnVuY3Rpb24gc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMuYXRvbV8pO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnZhbHVlc18ubGVuZ3RoO1xuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSBpbmRleCA9IDA7ZWxzZSBpZiAoaW5kZXggPiBsZW5ndGgpIGluZGV4ID0gbGVuZ3RoO2Vsc2UgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBNYXRoLm1heCgwLCBsZW5ndGggKyBpbmRleCk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIGRlbGV0ZUNvdW50ID0gbGVuZ3RoIC0gaW5kZXg7ZWxzZSBpZiAoZGVsZXRlQ291bnQgPT09IHVuZGVmaW5lZCB8fCBkZWxldGVDb3VudCA9PT0gbnVsbCkgZGVsZXRlQ291bnQgPSAwO2Vsc2UgZGVsZXRlQ291bnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkZWxldGVDb3VudCwgbGVuZ3RoIC0gaW5kZXgpKTtcbiAgICBpZiAobmV3SXRlbXMgPT09IHVuZGVmaW5lZCkgbmV3SXRlbXMgPSBFTVBUWV9BUlJBWTtcblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfLFxuICAgICAgICB0eXBlOiBTUExJQ0UsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgcmVtb3ZlZENvdW50OiBkZWxldGVDb3VudCxcbiAgICAgICAgYWRkZWQ6IG5ld0l0ZW1zXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gRU1QVFlfQVJSQVk7XG4gICAgICBkZWxldGVDb3VudCA9IGNoYW5nZS5yZW1vdmVkQ291bnQ7XG4gICAgICBuZXdJdGVtcyA9IGNoYW5nZS5hZGRlZDtcbiAgICB9XG5cbiAgICBuZXdJdGVtcyA9IG5ld0l0ZW1zLmxlbmd0aCA9PT0gMCA/IG5ld0l0ZW1zIDogbmV3SXRlbXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gX3RoaXMuZW5oYW5jZXJfKHYsIHVuZGVmaW5lZCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5sZWdhY3lNb2RlXyB8fCBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB2YXIgbGVuZ3RoRGVsdGEgPSBuZXdJdGVtcy5sZW5ndGggLSBkZWxldGVDb3VudDtcbiAgICAgIHRoaXMudXBkYXRlQXJyYXlMZW5ndGhfKGxlbmd0aCwgbGVuZ3RoRGVsdGEpOyAvLyBjaGVja3MgaWYgaW50ZXJuYWwgYXJyYXkgd2Fzbid0IG1vZGlmaWVkXG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHRoaXMuc3BsaWNlSXRlbXNJbnRvVmFsdWVzXyhpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKTtcbiAgICBpZiAoZGVsZXRlQ291bnQgIT09IDAgfHwgbmV3SXRlbXMubGVuZ3RoICE9PSAwKSB0aGlzLm5vdGlmeUFycmF5U3BsaWNlXyhpbmRleCwgbmV3SXRlbXMsIHJlcyk7XG4gICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlc18ocmVzKTtcbiAgfTtcblxuICBfcHJvdG8uc3BsaWNlSXRlbXNJbnRvVmFsdWVzXyA9IGZ1bmN0aW9uIHNwbGljZUl0ZW1zSW50b1ZhbHVlc18oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcykge1xuICAgIGlmIChuZXdJdGVtcy5sZW5ndGggPCBNQVhfU1BMSUNFX1NJWkUpIHtcbiAgICAgIHZhciBfdGhpcyR2YWx1ZXNfO1xuXG4gICAgICByZXR1cm4gKF90aGlzJHZhbHVlc18gPSB0aGlzLnZhbHVlc18pLnNwbGljZS5hcHBseShfdGhpcyR2YWx1ZXNfLCBbaW5kZXgsIGRlbGV0ZUNvdW50XS5jb25jYXQobmV3SXRlbXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlcyA9IHRoaXMudmFsdWVzXy5zbGljZShpbmRleCwgaW5kZXggKyBkZWxldGVDb3VudCk7XG4gICAgICB2YXIgb2xkSXRlbXMgPSB0aGlzLnZhbHVlc18uc2xpY2UoaW5kZXggKyBkZWxldGVDb3VudCk7XG4gICAgICB0aGlzLnZhbHVlc18ubGVuZ3RoID0gaW5kZXggKyBuZXdJdGVtcy5sZW5ndGggLSBkZWxldGVDb3VudDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnZhbHVlc19baW5kZXggKyBpXSA9IG5ld0l0ZW1zW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgb2xkSXRlbXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHRoaXMudmFsdWVzX1tpbmRleCArIG5ld0l0ZW1zLmxlbmd0aCArIF9pXSA9IG9sZEl0ZW1zW19pXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm5vdGlmeUFycmF5Q2hpbGRVcGRhdGVfID0gZnVuY3Rpb24gbm90aWZ5QXJyYXlDaGlsZFVwZGF0ZV8oaW5kZXgsIG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIHZhciBub3RpZnlTcHkgPSAhdGhpcy5vd25lZF8gJiYgaXNTcHlFbmFibGVkKCk7XG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgIG9ic2VydmFibGVLaW5kOiBcImFycmF5XCIsXG4gICAgICBvYmplY3Q6IHRoaXMucHJveHlfLFxuICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLmF0b21fLm5hbWVfLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlXG4gICAgfSA6IG51bGw7IC8vIFRoZSByZWFzb24gd2h5IHRoaXMgaXMgb24gcmlnaHQgaGFuZCBzaWRlIGhlcmUgKGFuZCBub3QgYWJvdmUpLCBpcyB0aGlzIHdheSB0aGUgdWdsaWZpZXIgd2lsbCBkcm9wIGl0LCBidXQgaXQgd29uJ3RcbiAgICAvLyBjYXVzZSBhbnkgcnVudGltZSBvdmVyaGVhZCBpbiBkZXZlbG9wbWVudCBtb2RlIHdpdGhvdXQgTk9ERV9FTlYgc2V0LCB1bmxlc3Mgc3B5aW5nIGlzIGVuYWJsZWRcblxuICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgIHRoaXMuYXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRFbmQoKTtcbiAgfTtcblxuICBfcHJvdG8ubm90aWZ5QXJyYXlTcGxpY2VfID0gZnVuY3Rpb24gbm90aWZ5QXJyYXlTcGxpY2VfKGluZGV4LCBhZGRlZCwgcmVtb3ZlZCkge1xuICAgIHZhciBub3RpZnlTcHkgPSAhdGhpcy5vd25lZF8gJiYgaXNTcHlFbmFibGVkKCk7XG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgIG9ic2VydmFibGVLaW5kOiBcImFycmF5XCIsXG4gICAgICBvYmplY3Q6IHRoaXMucHJveHlfLFxuICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLmF0b21fLm5hbWVfLFxuICAgICAgdHlwZTogU1BMSUNFLFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgIHJlbW92ZWRDb3VudDogcmVtb3ZlZC5sZW5ndGgsXG4gICAgICBhZGRlZENvdW50OiBhZGRlZC5sZW5ndGhcbiAgICB9IDogbnVsbDtcbiAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICB0aGlzLmF0b21fLnJlcG9ydENoYW5nZWQoKTsgLy8gY29uZm9ybTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvb2JzZXJ2ZVxuXG4gICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICB9O1xuXG4gIF9wcm90by5nZXRfID0gZnVuY3Rpb24gZ2V0XyhpbmRleCkge1xuICAgIGlmIChpbmRleCA8IHRoaXMudmFsdWVzXy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZV8odGhpcy52YWx1ZXNfW2luZGV4XSk7XG4gICAgfVxuXG4gICAgY29uc29sZS53YXJuKCBcIlttb2J4XSBPdXQgb2YgYm91bmRzIHJlYWQ6IFwiICsgaW5kZXggKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0XyA9IGZ1bmN0aW9uIHNldF8oaW5kZXgsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzXztcblxuICAgIGlmIChpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIC8vIHVwZGF0ZSBhdCBpbmRleCBpbiByYW5nZVxuICAgICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5hdG9tXyk7XG4gICAgICB2YXIgb2xkVmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuXG4gICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfLFxuICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2hhbmdlKSByZXR1cm47XG4gICAgICAgIG5ld1ZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgICAgfVxuXG4gICAgICBuZXdWYWx1ZSA9IHRoaXMuZW5oYW5jZXJfKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB2YXIgY2hhbmdlZCA9IG5ld1ZhbHVlICE9PSBvbGRWYWx1ZTtcblxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLm5vdGlmeUFycmF5Q2hpbGRVcGRhdGVfKGluZGV4LCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIC8vIGFkZCBhIG5ldyBpdGVtXG4gICAgICB0aGlzLnNwbGljZVdpdGhBcnJheV8oaW5kZXgsIDAsIFtuZXdWYWx1ZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdXQgb2YgYm91bmRzXG4gICAgICBkaWUoMTcsIGluZGV4LCB2YWx1ZXMubGVuZ3RoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uO1xufSgpO1xuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2YWJsZUFycmF5KGluaXRpYWxWYWx1ZXMsIGVuaGFuY2VyLCBuYW1lLCBvd25lZCkge1xuICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgbmFtZSA9ICBcIk9ic2VydmFibGVBcnJheUBcIiArIGdldE5leHRJZCgpIDtcbiAgfVxuXG4gIGlmIChvd25lZCA9PT0gdm9pZCAwKSB7XG4gICAgb3duZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGFzc2VydFByb3hpZXMoKTtcbiAgdmFyIGFkbSA9IG5ldyBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbihuYW1lLCBlbmhhbmNlciwgb3duZWQsIGZhbHNlKTtcbiAgYWRkSGlkZGVuRmluYWxQcm9wKGFkbS52YWx1ZXNfLCAkbW9ieCwgYWRtKTtcbiAgdmFyIHByb3h5ID0gbmV3IFByb3h5KGFkbS52YWx1ZXNfLCBhcnJheVRyYXBzKTtcbiAgYWRtLnByb3h5XyA9IHByb3h5O1xuXG4gIGlmIChpbml0aWFsVmFsdWVzICYmIGluaXRpYWxWYWx1ZXMubGVuZ3RoKSB7XG4gICAgdmFyIHByZXYgPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KHRydWUpO1xuICAgIGFkbS5zcGxpY2VXaXRoQXJyYXlfKDAsIDAsIGluaXRpYWxWYWx1ZXMpO1xuICAgIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHByZXYpO1xuICB9XG5cbiAgcmV0dXJuIHByb3h5O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxudmFyIGFycmF5RXh0ZW5zaW9ucyA9IHtcbiAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZSgwKTtcbiAgfSxcbiAgcmVwbGFjZTogZnVuY3Rpb24gcmVwbGFjZShuZXdJdGVtcykge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICByZXR1cm4gYWRtLnNwbGljZVdpdGhBcnJheV8oMCwgYWRtLnZhbHVlc18ubGVuZ3RoLCBuZXdJdGVtcyk7XG4gIH0sXG4gIC8vIFVzZWQgYnkgSlNPTi5zdHJpbmdpZnlcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoKTtcbiAgfSxcblxuICAvKlxyXG4gICAqIGZ1bmN0aW9ucyB0aGF0IGRvIGFsdGVyIHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmUgb2YgdGhlIGFycmF5LCAoYmFzZWQgb24gbGliLmVzNi5kLnRzKVxyXG4gICAqIHNpbmNlIHRoZXNlIGZ1bmN0aW9ucyBhbHRlciB0aGUgaW5uZXIgc3RydWN0dXJlIG9mIHRoZSBhcnJheSwgdGhlIGhhdmUgc2lkZSBlZmZlY3RzLlxyXG4gICAqIEJlY2F1c2UgdGhlIGhhdmUgc2lkZSBlZmZlY3RzLCB0aGV5IHNob3VsZCBub3QgYmUgdXNlZCBpbiBjb21wdXRlZCBmdW5jdGlvbixcclxuICAgKiBhbmQgZm9yIHRoYXQgcmVhc29uIHRoZSBkbyBub3QgY2FsbCBkZXBlbmRlbmN5U3RhdGUubm90aWZ5T2JzZXJ2ZWRcclxuICAgKi9cbiAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2UoaW5kZXgsIGRlbGV0ZUNvdW50KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5ld0l0ZW1zID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIG5ld0l0ZW1zW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG5cbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFtdO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBhZG0uc3BsaWNlV2l0aEFycmF5XyhpbmRleCk7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGFkbS5zcGxpY2VXaXRoQXJyYXlfKGluZGV4LCBkZWxldGVDb3VudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkbS5zcGxpY2VXaXRoQXJyYXlfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpO1xuICB9LFxuICBzcGxpY2VXaXRoQXJyYXk6IGZ1bmN0aW9uIHNwbGljZVdpdGhBcnJheShpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKSB7XG4gICAgcmV0dXJuIHRoaXNbJG1vYnhdLnNwbGljZVdpdGhBcnJheV8oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcyk7XG4gIH0sXG4gIHB1c2g6IGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgaXRlbXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBhZG0uc3BsaWNlV2l0aEFycmF5XyhhZG0udmFsdWVzXy5sZW5ndGgsIDAsIGl0ZW1zKTtcbiAgICByZXR1cm4gYWRtLnZhbHVlc18ubGVuZ3RoO1xuICB9LFxuICBwb3A6IGZ1bmN0aW9uIHBvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoTWF0aC5tYXgodGhpc1skbW9ieF0udmFsdWVzXy5sZW5ndGggLSAxLCAwKSwgMSlbMF07XG4gIH0sXG4gIHNoaWZ0OiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoMCwgMSlbMF07XG4gIH0sXG4gIHVuc2hpZnQ6IGZ1bmN0aW9uIHVuc2hpZnQoKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuXG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgaXRlbXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG5cbiAgICBhZG0uc3BsaWNlV2l0aEFycmF5XygwLCAwLCBpdGVtcyk7XG4gICAgcmV0dXJuIGFkbS52YWx1ZXNfLmxlbmd0aDtcbiAgfSxcbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAvLyByZXZlcnNlIGJ5IGRlZmF1bHQgbXV0YXRlcyBpbiBwbGFjZSBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHRcbiAgICAvLyB3aGljaCBtYWtlcyBpdCBib3RoIGEgJ2Rlcml2YXRpb24nIGFuZCBhICdtdXRhdGlvbicuXG4gICAgaWYgKGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgZGllKDM3LCBcInJldmVyc2VcIik7XG4gICAgfVxuXG4gICAgdGhpcy5yZXBsYWNlKHRoaXMuc2xpY2UoKS5yZXZlcnNlKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KCkge1xuICAgIC8vIHNvcnQgYnkgZGVmYXVsdCBtdXRhdGVzIGluIHBsYWNlIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdFxuICAgIC8vIHdoaWNoIGdvZXMgYWdhaW5zdCBhbGwgZ29vZCBwcmFjdGljZXMuIExldCdzIG5vdCBjaGFuZ2UgdGhlIGFycmF5IGluIHBsYWNlIVxuICAgIGlmIChnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHtcbiAgICAgIGRpZSgzNywgXCJzb3J0XCIpO1xuICAgIH1cblxuICAgIHZhciBjb3B5ID0gdGhpcy5zbGljZSgpO1xuICAgIGNvcHkuc29ydC5hcHBseShjb3B5LCBhcmd1bWVudHMpO1xuICAgIHRoaXMucmVwbGFjZShjb3B5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUodmFsdWUpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgdmFyIGlkeCA9IGFkbS5kZWhhbmNlVmFsdWVzXyhhZG0udmFsdWVzXykuaW5kZXhPZih2YWx1ZSk7XG5cbiAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgIHRoaXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG4vKipcclxuICogV3JhcCBmdW5jdGlvbiBmcm9tIHByb3RvdHlwZVxyXG4gKiBXaXRob3V0IHRoaXMsIGV2ZXJ5dGhpbmcgd29ya3MgYXMgd2VsbCwgYnV0IHRoaXMgd29ya3NcclxuICogZmFzdGVyIGFzIGV2ZXJ5dGhpbmcgd29ya3Mgb24gdW5wcm94aWVkIHZhbHVlc1xyXG4gKi9cblxuYWRkQXJyYXlFeHRlbnNpb24oXCJjb25jYXRcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZsYXRcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImluY2x1ZGVzXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJpbmRleE9mXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJqb2luXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJsYXN0SW5kZXhPZlwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwic2xpY2VcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInRvU3RyaW5nXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJ0b0xvY2FsZVN0cmluZ1wiLCBzaW1wbGVGdW5jKTsgLy8gbWFwXG5cbmFkZEFycmF5RXh0ZW5zaW9uKFwiZXZlcnlcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmaWx0ZXJcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmaW5kXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmluZEluZGV4XCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmxhdE1hcFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZvckVhY2hcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJtYXBcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJzb21lXCIsIG1hcExpa2VGdW5jKTsgLy8gcmVkdWNlXG5cbmFkZEFycmF5RXh0ZW5zaW9uKFwicmVkdWNlXCIsIHJlZHVjZUxpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwicmVkdWNlUmlnaHRcIiwgcmVkdWNlTGlrZUZ1bmMpO1xuXG5mdW5jdGlvbiBhZGRBcnJheUV4dGVuc2lvbihmdW5jTmFtZSwgZnVuY0ZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBBcnJheS5wcm90b3R5cGVbZnVuY05hbWVdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBhcnJheUV4dGVuc2lvbnNbZnVuY05hbWVdID0gZnVuY0ZhY3RvcnkoZnVuY05hbWUpO1xuICB9XG59IC8vIFJlcG9ydCBhbmQgZGVsZWdhdGUgdG8gZGVoYW5jZWQgYXJyYXlcblxuXG5mdW5jdGlvbiBzaW1wbGVGdW5jKGZ1bmNOYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIGFkbS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBkZWhhbmNlZFZhbHVlcyA9IGFkbS5kZWhhbmNlVmFsdWVzXyhhZG0udmFsdWVzXyk7XG4gICAgcmV0dXJuIGRlaGFuY2VkVmFsdWVzW2Z1bmNOYW1lXS5hcHBseShkZWhhbmNlZFZhbHVlcywgYXJndW1lbnRzKTtcbiAgfTtcbn0gLy8gTWFrZSBzdXJlIGNhbGxiYWNrcyByZWNpZXZlIGNvcnJlY3QgYXJyYXkgYXJnICMyMzI2XG5cblxuZnVuY3Rpb24gbWFwTGlrZUZ1bmMoZnVuY05hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIGFkbS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBkZWhhbmNlZFZhbHVlcyA9IGFkbS5kZWhhbmNlVmFsdWVzXyhhZG0udmFsdWVzXyk7XG4gICAgcmV0dXJuIGRlaGFuY2VkVmFsdWVzW2Z1bmNOYW1lXShmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGVsZW1lbnQsIGluZGV4LCBfdGhpczIpO1xuICAgIH0pO1xuICB9O1xufSAvLyBNYWtlIHN1cmUgY2FsbGJhY2tzIHJlY2lldmUgY29ycmVjdCBhcnJheSBhcmcgIzIzMjZcblxuXG5mdW5jdGlvbiByZWR1Y2VMaWtlRnVuYyhmdW5jTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIGFkbS5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHZhciBkZWhhbmNlZFZhbHVlcyA9IGFkbS5kZWhhbmNlVmFsdWVzXyhhZG0udmFsdWVzXyk7IC8vICMyNDMyIC0gcmVkdWNlIGJlaGF2aW9yIGRlcGVuZHMgb24gYXJndW1lbnRzLmxlbmd0aFxuXG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuXG4gICAgYXJndW1lbnRzWzBdID0gZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUsIGluZGV4KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSwgaW5kZXgsIF90aGlzMyk7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWhhbmNlZFZhbHVlc1tmdW5jTmFtZV0uYXBwbHkoZGVoYW5jZWRWYWx1ZXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBpc09ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvblwiLCBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbik7XG5mdW5jdGlvbiBpc09ic2VydmFibGVBcnJheSh0aGluZykge1xuICByZXR1cm4gaXNPYmplY3QodGhpbmcpICYmIGlzT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24odGhpbmdbJG1vYnhdKTtcbn1cblxudmFyIF9TeW1ib2wkaXRlcmF0b3IsIF9TeW1ib2wkdG9TdHJpbmdUYWc7XG52YXIgT2JzZXJ2YWJsZU1hcE1hcmtlciA9IHt9O1xudmFyIEFERCA9IFwiYWRkXCI7XG52YXIgREVMRVRFID0gXCJkZWxldGVcIjsgLy8ganVzdCBleHRlbmQgTWFwPyBTZWUgYWxzbyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9uZXN0aGFydXMvMTNiNGQ3NGYyZWY0YTJmNDM1N2RiZDNmYzIzYzFlNTRcbi8vIEJ1dDogaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L2lzc3Vlcy8xNTU2XG5cbl9TeW1ib2wkaXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XG5fU3ltYm9sJHRvU3RyaW5nVGFnID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xudmFyIE9ic2VydmFibGVNYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBoYXNNYXAsIG5vdCBoYXNoTWFwID4tKS5cbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZU1hcChpbml0aWFsRGF0YSwgZW5oYW5jZXJfLCBuYW1lXykge1xuICAgIGlmIChlbmhhbmNlcl8gPT09IHZvaWQgMCkge1xuICAgICAgZW5oYW5jZXJfID0gZGVlcEVuaGFuY2VyO1xuICAgIH1cblxuICAgIGlmIChuYW1lXyA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lXyA9ICBcIk9ic2VydmFibGVNYXBAXCIgKyBnZXROZXh0SWQoKSA7XG4gICAgfVxuXG4gICAgdGhpcy5lbmhhbmNlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzWyRtb2J4XSA9IE9ic2VydmFibGVNYXBNYXJrZXI7XG4gICAgdGhpcy5kYXRhXyA9IHZvaWQgMDtcbiAgICB0aGlzLmhhc01hcF8gPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlzQXRvbV8gPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlaGFuY2VyID0gdm9pZCAwO1xuICAgIHRoaXMuZW5oYW5jZXJfID0gZW5oYW5jZXJfO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcblxuICAgIGlmICghaXNGdW5jdGlvbihNYXApKSB7XG4gICAgICBkaWUoMTgpO1xuICAgIH1cblxuICAgIHRoaXMua2V5c0F0b21fID0gY3JlYXRlQXRvbSggdGhpcy5uYW1lXyArIFwiLmtleXMoKVwiICk7XG4gICAgdGhpcy5kYXRhXyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmhhc01hcF8gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5tZXJnZShpbml0aWFsRGF0YSk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZU1hcC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhc18gPSBmdW5jdGlvbiBoYXNfKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFfLmhhcyhrZXkpO1xuICB9O1xuXG4gIF9wcm90by5oYXMgPSBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICghZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSByZXR1cm4gdGhpcy5oYXNfKGtleSk7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5oYXNNYXBfLmdldChrZXkpO1xuXG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgdmFyIG5ld0VudHJ5ID0gZW50cnkgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKHRoaXMuaGFzXyhrZXkpLCByZWZlcmVuY2VFbmhhbmNlciwgIHRoaXMubmFtZV8gKyBcIi5cIiArIHN0cmluZ2lmeUtleShrZXkpICsgXCI/XCIgLCBmYWxzZSk7XG4gICAgICB0aGlzLmhhc01hcF8uc2V0KGtleSwgbmV3RW50cnkpO1xuICAgICAgb25CZWNvbWVVbm9ic2VydmVkKG5ld0VudHJ5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5oYXNNYXBfW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW50cnkuZ2V0KCk7XG4gIH07XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGhhc0tleSA9IHRoaXMuaGFzXyhrZXkpO1xuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IGhhc0tleSA/IFVQREFURSA6IEFERCxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuZXdWYWx1ZTogdmFsdWUsXG4gICAgICAgIG5hbWU6IGtleVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzS2V5KSB7XG4gICAgICB0aGlzLnVwZGF0ZVZhbHVlXyhrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMua2V5c0F0b21fKTtcblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBERUxFVEUsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgbmFtZToga2V5XG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzXyhrZXkpKSB7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gaXNTcHlFbmFibGVkKCk7XG4gICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuXG4gICAgICB2YXIgX2NoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm1hcFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogdGhpcy5kYXRhXy5nZXQoa2V5KS52YWx1ZV8sXG4gICAgICAgIG5hbWU6IGtleVxuICAgICAgfSA6IG51bGw7XG5cbiAgICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRTdGFydChfY2hhbmdlKTtcbiAgICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG5cbiAgICAgICAgX3RoaXMyLnVwZGF0ZUhhc01hcEVudHJ5XyhrZXksIGZhbHNlKTtcblxuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IF90aGlzMi5kYXRhXy5nZXQoa2V5KTtcblxuICAgICAgICBvYnNlcnZhYmxlLnNldE5ld1ZhbHVlXyh1bmRlZmluZWQpO1xuXG4gICAgICAgIF90aGlzMi5kYXRhX1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgfSk7XG4gICAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZSk7XG4gICAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZUhhc01hcEVudHJ5XyA9IGZ1bmN0aW9uIHVwZGF0ZUhhc01hcEVudHJ5XyhrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5oYXNNYXBfLmdldChrZXkpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS5zZXROZXdWYWx1ZV8odmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udXBkYXRlVmFsdWVfID0gZnVuY3Rpb24gdXBkYXRlVmFsdWVfKGtleSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMuZGF0YV8uZ2V0KGtleSk7XG4gICAgbmV3VmFsdWUgPSBvYnNlcnZhYmxlLnByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpO1xuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwibWFwXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG9sZFZhbHVlOiBvYnNlcnZhYmxlLnZhbHVlXyxcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0gOiBudWxsO1xuICAgICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgICBvYnNlcnZhYmxlLnNldE5ld1ZhbHVlXyhuZXdWYWx1ZSk7XG4gICAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRFbmQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmFkZFZhbHVlXyA9IGZ1bmN0aW9uIGFkZFZhbHVlXyhrZXksIG5ld1ZhbHVlKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmtleXNBdG9tXyk7XG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKG5ld1ZhbHVlLCBfdGhpczMuZW5oYW5jZXJfLCAgX3RoaXMzLm5hbWVfICsgXCIuXCIgKyBzdHJpbmdpZnlLZXkoa2V5KSAsIGZhbHNlKTtcblxuICAgICAgX3RoaXMzLmRhdGFfLnNldChrZXksIG9ic2VydmFibGUpO1xuXG4gICAgICBuZXdWYWx1ZSA9IG9ic2VydmFibGUudmFsdWVfOyAvLyB2YWx1ZSBtaWdodCBoYXZlIGJlZW4gY2hhbmdlZFxuXG4gICAgICBfdGhpczMudXBkYXRlSGFzTWFwRW50cnlfKGtleSwgdHJ1ZSk7XG5cbiAgICAgIF90aGlzMy5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgIH0pO1xuICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwibWFwXCIsXG4gICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICB0eXBlOiBBREQsXG4gICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICBuYW1lOiBrZXksXG4gICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICB9IDogbnVsbDtcbiAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAodGhpcy5oYXMoa2V5KSkgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlXyh0aGlzLmRhdGFfLmdldChrZXkpLmdldCgpKTtcbiAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVfKHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZV8gPSBmdW5jdGlvbiBkZWhhbmNlVmFsdWVfKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVoYW5jZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZXIodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8ua2V5cyA9IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5kYXRhXy5rZXlzKCk7XG4gIH07XG5cbiAgX3Byb3RvLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXMoKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBfa2V5cyRuZXh0ID0ga2V5cy5uZXh0KCksXG4gICAgICAgICAgICBkb25lID0gX2tleXMkbmV4dC5kb25lLFxuICAgICAgICAgICAgdmFsdWUgPSBfa2V5cyRuZXh0LnZhbHVlO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZG9uZSxcbiAgICAgICAgICB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IHNlbGYuZ2V0KHZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5lbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXMoKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBfa2V5cyRuZXh0MiA9IGtleXMubmV4dCgpLFxuICAgICAgICAgICAgZG9uZSA9IF9rZXlzJG5leHQyLmRvbmUsXG4gICAgICAgICAgICB2YWx1ZSA9IF9rZXlzJG5leHQyLnZhbHVlO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZG9uZSxcbiAgICAgICAgICB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IFt2YWx1ZSwgc2VsZi5nZXQodmFsdWUpXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90b1tfU3ltYm9sJGl0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0aGlzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zdGVwLnZhbHVlLFxuICAgICAgICAgIGtleSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgIHZhbHVlID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBrZXksIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKiogTWVyZ2UgYW5vdGhlciBvYmplY3QgaW50byB0aGlzIG9iamVjdCwgcmV0dXJucyB0aGlzLiAqL1xuICA7XG5cbiAgX3Byb3RvLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2Uob3RoZXIpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmIChpc09ic2VydmFibGVNYXAob3RoZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBNYXAob3RoZXIpO1xuICAgIH1cblxuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KG90aGVyKSkgZ2V0UGxhaW5PYmplY3RLZXlzKG90aGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5zZXQoa2V5LCBvdGhlcltrZXldKTtcbiAgICAgIH0pO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkob3RoZXIpKSBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBrZXkgPSBfcmVmWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBfcmVmWzFdO1xuICAgICAgICByZXR1cm4gX3RoaXM0LnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0pO2Vsc2UgaWYgKGlzRVM2TWFwKG90aGVyKSkge1xuICAgICAgICBpZiAob3RoZXIuY29uc3RydWN0b3IgIT09IE1hcCkgZGllKDE5LCBvdGhlcik7XG4gICAgICAgIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyICE9PSBudWxsICYmIG90aGVyICE9PSB1bmRlZmluZWQpIGRpZSgyMCwgb3RoZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgdW50cmFja2VkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoX3RoaXM1LmtleXMoKSksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIF90aGlzNVtcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UodmFsdWVzKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAvLyBJbXBsZW1lbnRhdGlvbiByZXF1aXJlbWVudHM6XG4gICAgLy8gLSByZXNwZWN0IG9yZGVyaW5nIG9mIHJlcGxhY2VtZW50IG1hcFxuICAgIC8vIC0gYWxsb3cgaW50ZXJjZXB0b3JzIHRvIHJ1biBhbmQgcG90ZW50aWFsbHkgcHJldmVudCBpbmRpdmlkdWFsIG9wZXJhdGlvbnNcbiAgICAvLyAtIGRvbid0IHJlY3JlYXRlIG9ic2VydmFibGVzIHRoYXQgYWxyZWFkeSBleGlzdCBpbiBvcmlnaW5hbCBtYXAgKHNvIHdlIGRvbid0IGRlc3Ryb3kgZXhpc3Rpbmcgc3Vic2NyaXB0aW9ucylcbiAgICAvLyAtIGRvbid0IF9rZXlzQXRvbS5yZXBvcnRDaGFuZ2VkIGlmIHRoZSBrZXlzIG9mIHJlc3VsdGluZyBtYXAgYXJlIGluZGVudGljYWwgKG9yZGVyIG1hdHRlcnMhKVxuICAgIC8vIC0gbm90ZSB0aGF0IHJlc3VsdCBtYXAgbWF5IGRpZmZlciBmcm9tIHJlcGxhY2VtZW50IG1hcCBkdWUgdG8gdGhlIGludGVyY2VwdG9yc1xuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gbWFwIHNvIHdlIGNhbiBkbyBxdWljayBrZXkgbG9va3Vwc1xuICAgICAgdmFyIHJlcGxhY2VtZW50TWFwID0gY29udmVydFRvTWFwKHZhbHVlcyk7XG4gICAgICB2YXIgb3JkZXJlZERhdGEgPSBuZXcgTWFwKCk7IC8vIFVzZWQgZm9yIG9wdGltaXphdGlvblxuXG4gICAgICB2YXIga2V5c1JlcG9ydENoYW5nZWRDYWxsZWQgPSBmYWxzZTsgLy8gRGVsZXRlIGtleXMgdGhhdCBkb24ndCBleGlzdCBpbiByZXBsYWNlbWVudCBtYXBcbiAgICAgIC8vIGlmIHRoZSBrZXkgZGVsZXRpb24gaXMgcHJldmVudGVkIGJ5IGludGVyY2VwdG9yXG4gICAgICAvLyBhZGQgZW50cnkgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVzdWx0IG1hcFxuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShfdGhpczYuZGF0YV8ua2V5cygpKSwgX3N0ZXAzOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGtleSA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAvLyBDb25jdXJyZW50bHkgaXRlcmF0aW5nL2RlbGV0aW5nIGtleXNcbiAgICAgICAgLy8gaXRlcmF0b3Igc2hvdWxkIGhhbmRsZSB0aGlzIGNvcnJlY3RseVxuICAgICAgICBpZiAoIXJlcGxhY2VtZW50TWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgdmFyIGRlbGV0ZWQgPSBfdGhpczZbXCJkZWxldGVcIl0oa2V5KTsgLy8gV2FzIHRoZSBrZXkgcmVtb3ZlZD9cblxuXG4gICAgICAgICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgICAgIC8vIF9rZXlzQXRvbS5yZXBvcnRDaGFuZ2VkKCkgd2FzIGFscmVhZHkgY2FsbGVkXG4gICAgICAgICAgICBrZXlzUmVwb3J0Q2hhbmdlZENhbGxlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERlbGV0ZSBwcmV2ZW50ZWQgYnkgaW50ZXJjZXB0b3JcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF90aGlzNi5kYXRhXy5nZXQoa2V5KTtcblxuICAgICAgICAgICAgb3JkZXJlZERhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBNZXJnZSBlbnRyaWVzXG5cblxuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UocmVwbGFjZW1lbnRNYXAuZW50cmllcygpKSwgX3N0ZXA0OyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQoKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwNCR2YWx1ZSA9IF9zdGVwNC52YWx1ZSxcbiAgICAgICAgICAgIF9rZXkgPSBfc3RlcDQkdmFsdWVbMF0sXG4gICAgICAgICAgICBfdmFsdWUgPSBfc3RlcDQkdmFsdWVbMV07XG5cbiAgICAgICAgLy8gV2Ugd2lsbCB3YW50IHRvIGtub3cgd2hldGhlciBhIG5ldyBrZXkgaXMgYWRkZWRcbiAgICAgICAgdmFyIGtleUV4aXN0ZWQgPSBfdGhpczYuZGF0YV8uaGFzKF9rZXkpOyAvLyBBZGQgb3IgdXBkYXRlIHZhbHVlXG5cblxuICAgICAgICBfdGhpczYuc2V0KF9rZXksIF92YWx1ZSk7IC8vIFRoZSBhZGRpdGlvbiBjb3VsZCBoYXZlIGJlZW4gcHJldmVudCBieSBpbnRlcmNlcHRvclxuXG5cbiAgICAgICAgaWYgKF90aGlzNi5kYXRhXy5oYXMoX2tleSkpIHtcbiAgICAgICAgICAvLyBUaGUgdXBkYXRlIGNvdWxkIGhhdmUgYmVlbiBwcmV2ZW50ZWQgYnkgaW50ZXJjZXB0b3JcbiAgICAgICAgICAvLyBhbmQgYWxzbyB3ZSB3YW50IHRvIHByZXNlcnZlIGV4aXN0aW5nIHZhbHVlc1xuICAgICAgICAgIC8vIHNvIHVzZSB2YWx1ZSBmcm9tIF9kYXRhIG1hcCAoaW5zdGVhZCBvZiByZXBsYWNlbWVudCBtYXApXG4gICAgICAgICAgdmFyIF92YWx1ZTIgPSBfdGhpczYuZGF0YV8uZ2V0KF9rZXkpO1xuXG4gICAgICAgICAgb3JkZXJlZERhdGEuc2V0KF9rZXksIF92YWx1ZTIpOyAvLyBXYXMgYSBuZXcga2V5IGFkZGVkP1xuXG4gICAgICAgICAgaWYgKCFrZXlFeGlzdGVkKSB7XG4gICAgICAgICAgICAvLyBfa2V5c0F0b20ucmVwb3J0Q2hhbmdlZCgpIHdhcyBhbHJlYWR5IGNhbGxlZFxuICAgICAgICAgICAga2V5c1JlcG9ydENoYW5nZWRDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDaGVjayBmb3IgcG9zc2libGUga2V5IG9yZGVyIGNoYW5nZVxuXG5cbiAgICAgIGlmICgha2V5c1JlcG9ydENoYW5nZWRDYWxsZWQpIHtcbiAgICAgICAgaWYgKF90aGlzNi5kYXRhXy5zaXplICE9PSBvcmRlcmVkRGF0YS5zaXplKSB7XG4gICAgICAgICAgLy8gSWYgc2l6ZSBkaWZmZXJzLCBrZXlzIGFyZSBkZWZpbml0ZWx5IG1vZGlmaWVkXG4gICAgICAgICAgX3RoaXM2LmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGl0ZXIxID0gX3RoaXM2LmRhdGFfLmtleXMoKTtcblxuICAgICAgICAgIHZhciBpdGVyMiA9IG9yZGVyZWREYXRhLmtleXMoKTtcbiAgICAgICAgICB2YXIgbmV4dDEgPSBpdGVyMS5uZXh0KCk7XG4gICAgICAgICAgdmFyIG5leHQyID0gaXRlcjIubmV4dCgpO1xuXG4gICAgICAgICAgd2hpbGUgKCFuZXh0MS5kb25lKSB7XG4gICAgICAgICAgICBpZiAobmV4dDEudmFsdWUgIT09IG5leHQyLnZhbHVlKSB7XG4gICAgICAgICAgICAgIF90aGlzNi5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXh0MSA9IGl0ZXIxLm5leHQoKTtcbiAgICAgICAgICAgIG5leHQyID0gaXRlcjIubmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBVc2UgY29ycmVjdGx5IG9yZGVyZWQgbWFwXG5cblxuICAgICAgX3RoaXM2LmRhdGFfID0gb3JkZXJlZERhdGE7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBPYnNlcnZhYmxlTWFwXVwiO1xuICB9O1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcyk7XG4gIH07XG5cbiAgLyoqXHJcbiAgICogT2JzZXJ2ZXMgdGhpcyBvYmplY3QuIFRyaWdnZXJzIGZvciB0aGUgZXZlbnRzICdhZGQnLCAndXBkYXRlJyBhbmQgJ2RlbGV0ZScuXHJcbiAgICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3Qvb2JzZXJ2ZVxyXG4gICAqIGZvciBjYWxsYmFjayBkZXRhaWxzXHJcbiAgICovXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICBpZiAoIGZpcmVJbW1lZGlhdGVseSA9PT0gdHJ1ZSkgZGllKFwiYG9ic2VydmVgIGRvZXNuJ3Qgc3VwcG9ydCBmaXJlSW1tZWRpYXRlbHk9dHJ1ZSBpbiBjb21iaW5hdGlvbiB3aXRoIG1hcHMuXCIpO1xuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcblxuICBfcHJvdG8uaW50ZXJjZXB0XyA9IGZ1bmN0aW9uIGludGVyY2VwdF8oaGFuZGxlcikge1xuICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhPYnNlcnZhYmxlTWFwLCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YV8uc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IF9TeW1ib2wkdG9TdHJpbmdUYWcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJNYXBcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2JzZXJ2YWJsZU1hcDtcbn0oKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cbnZhciBpc09ic2VydmFibGVNYXAgPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVNYXBcIiwgT2JzZXJ2YWJsZU1hcCk7XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb01hcChkYXRhU3RydWN0dXJlKSB7XG4gIGlmIChpc0VTNk1hcChkYXRhU3RydWN0dXJlKSB8fCBpc09ic2VydmFibGVNYXAoZGF0YVN0cnVjdHVyZSkpIHtcbiAgICByZXR1cm4gZGF0YVN0cnVjdHVyZTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGFTdHJ1Y3R1cmUpKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoZGF0YVN0cnVjdHVyZSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChkYXRhU3RydWN0dXJlKSkge1xuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YVN0cnVjdHVyZSkge1xuICAgICAgbWFwLnNldChrZXksIGRhdGFTdHJ1Y3R1cmVba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGllKDIxLCBkYXRhU3RydWN0dXJlKTtcbiAgfVxufVxuXG52YXIgX1N5bWJvbCRpdGVyYXRvciQxLCBfU3ltYm9sJHRvU3RyaW5nVGFnJDE7XG52YXIgT2JzZXJ2YWJsZVNldE1hcmtlciA9IHt9O1xuX1N5bWJvbCRpdGVyYXRvciQxID0gU3ltYm9sLml0ZXJhdG9yO1xuX1N5bWJvbCR0b1N0cmluZ1RhZyQxID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xudmFyIE9ic2VydmFibGVTZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYnNlcnZhYmxlU2V0KGluaXRpYWxEYXRhLCBlbmhhbmNlciwgbmFtZV8pIHtcbiAgICBpZiAoZW5oYW5jZXIgPT09IHZvaWQgMCkge1xuICAgICAgZW5oYW5jZXIgPSBkZWVwRW5oYW5jZXI7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVfID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWVfID0gIFwiT2JzZXJ2YWJsZVNldEBcIiArIGdldE5leHRJZCgpIDtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXNbJG1vYnhdID0gT2JzZXJ2YWJsZVNldE1hcmtlcjtcbiAgICB0aGlzLmRhdGFfID0gbmV3IFNldCgpO1xuICAgIHRoaXMuYXRvbV8gPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlaGFuY2VyID0gdm9pZCAwO1xuICAgIHRoaXMuZW5oYW5jZXJfID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcblxuICAgIGlmICghaXNGdW5jdGlvbihTZXQpKSB7XG4gICAgICBkaWUoMjIpO1xuICAgIH1cblxuICAgIHRoaXMuYXRvbV8gPSBjcmVhdGVBdG9tKHRoaXMubmFtZV8pO1xuXG4gICAgdGhpcy5lbmhhbmNlcl8gPSBmdW5jdGlvbiAobmV3Viwgb2xkVikge1xuICAgICAgcmV0dXJuIGVuaGFuY2VyKG5ld1YsIG9sZFYsIG5hbWVfKTtcbiAgICB9O1xuXG4gICAgaWYgKGluaXRpYWxEYXRhKSB7XG4gICAgICB0aGlzLnJlcGxhY2UoaW5pdGlhbERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBPYnNlcnZhYmxlU2V0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVoYW5jZVZhbHVlXyA9IGZ1bmN0aW9uIGRlaGFuY2VWYWx1ZV8odmFsdWUpIHtcbiAgICBpZiAodGhpcy5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWhhbmNlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICB1bnRyYWNrZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKF90aGlzLmRhdGFfLnZhbHVlcygpKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIF90aGlzW1wiZGVsZXRlXCJdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrRm4sIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0aGlzKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgIGNhbGxiYWNrRm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwgdmFsdWUsIHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmF0b21fKTtcblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgbmV3VmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gdGhpczsgLy8gaWRlYWxseSwgdmFsdWUgPSBjaGFuZ2UudmFsdWUgd291bGQgYmUgZG9uZSBoZXJlLCBzbyB0aGF0IHZhbHVlcyBjYW4gYmVcbiAgICAgIC8vIGNoYW5nZWQgYnkgaW50ZXJjZXB0b3IuIFNhbWUgYXBwbGllcyBmb3Igb3RoZXIgU2V0IGFuZCBNYXAgYXBpJ3MuXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmRhdGFfLmFkZChfdGhpczIuZW5oYW5jZXJfKHZhbHVlLCB1bmRlZmluZWQpKTtcblxuICAgICAgICBfdGhpczIuYXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gIGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcblxuICAgICAgdmFyIF9jaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJzZXRcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgbmV3VmFsdWU6IHZhbHVlXG4gICAgICB9IDogbnVsbDtcblxuICAgICAgaWYgKG5vdGlmeVNweSAmJiBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiKSBzcHlSZXBvcnRTdGFydChfY2hhbmdlKTtcbiAgICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlKTtcbiAgICAgIGlmIChub3RpZnlTcHkgJiYgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIikgc3B5UmVwb3J0RW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gX2RlbGV0ZSh2YWx1ZSkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBvbGRWYWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXModmFsdWUpKSB7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gIGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcblxuICAgICAgdmFyIF9jaGFuZ2UyID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwic2V0XCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogREVMRVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG9sZFZhbHVlOiB2YWx1ZVxuICAgICAgfSA6IG51bGw7XG5cbiAgICAgIGlmIChub3RpZnlTcHkgJiYgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIikgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZTIpO1xuICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuYXRvbV8ucmVwb3J0Q2hhbmdlZCgpO1xuXG4gICAgICAgIF90aGlzMy5kYXRhX1tcImRlbGV0ZVwiXSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlMik7XG4gICAgICBpZiAobm90aWZ5U3B5ICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIpIHNweVJlcG9ydEVuZCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5oYXMgPSBmdW5jdGlvbiBoYXModmFsdWUpIHtcbiAgICB0aGlzLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YV8uaGFzKHRoaXMuZGVoYW5jZVZhbHVlXyh2YWx1ZSkpO1xuICB9O1xuXG4gIF9wcm90by5lbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICB2YXIga2V5cyA9IEFycmF5LmZyb20odGhpcy5rZXlzKCkpO1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheS5mcm9tKHRoaXMudmFsdWVzKCkpO1xuICAgIHJldHVybiBtYWtlSXRlcmFibGUoe1xuICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICBuZXh0SW5kZXggKz0gMTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgdmFsdWVzLmxlbmd0aCA/IHtcbiAgICAgICAgICB2YWx1ZTogW2tleXNbaW5kZXhdLCB2YWx1ZXNbaW5kZXhdXSxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9IDoge1xuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ua2V5cyA9IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gIH07XG5cbiAgX3Byb3RvLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICB0aGlzLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgIHZhciBvYnNlcnZhYmxlVmFsdWVzID0gQXJyYXkuZnJvbSh0aGlzLmRhdGFfLnZhbHVlcygpKTtcbiAgICByZXR1cm4gbWFrZUl0ZXJhYmxlKHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiBuZXh0SW5kZXggPCBvYnNlcnZhYmxlVmFsdWVzLmxlbmd0aCA/IHtcbiAgICAgICAgICB2YWx1ZTogc2VsZi5kZWhhbmNlVmFsdWVfKG9ic2VydmFibGVWYWx1ZXNbbmV4dEluZGV4KytdKSxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9IDoge1xuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uob3RoZXIpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmIChpc09ic2VydmFibGVTZXQob3RoZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZXQob3RoZXIpO1xuICAgIH1cblxuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG90aGVyKSkge1xuICAgICAgICBfdGhpczQuY2xlYXIoKTtcblxuICAgICAgICBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQuYWRkKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRVM2U2V0KG90aGVyKSkge1xuICAgICAgICBfdGhpczQuY2xlYXIoKTtcblxuICAgICAgICBvdGhlci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQuYWRkKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyICE9PSBudWxsICYmIG90aGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGllKFwiQ2Fubm90IGluaXRpYWxpemUgc2V0IGZyb20gXCIgKyBvdGhlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIC8vIC4uLiAnZmlyZUltbWVkaWF0ZWx5JyBjb3VsZCBhbHNvIGJlIHRydWU/XG4gICAgaWYgKCBmaXJlSW1tZWRpYXRlbHkgPT09IHRydWUpIGRpZShcImBvYnNlcnZlYCBkb2Vzbid0IHN1cHBvcnQgZmlyZUltbWVkaWF0ZWx5PXRydWUgaW4gY29tYmluYXRpb24gd2l0aCBzZXRzLlwiKTtcbiAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XG4gIH07XG5cbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgT2JzZXJ2YWJsZVNldF1cIjtcbiAgfTtcblxuICBfcHJvdG9bX1N5bWJvbCRpdGVyYXRvciQxXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoT2JzZXJ2YWJsZVNldCwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YV8uc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IF9TeW1ib2wkdG9TdHJpbmdUYWckMSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcIlNldFwiO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYnNlcnZhYmxlU2V0O1xufSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxudmFyIGlzT2JzZXJ2YWJsZVNldCA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZVNldFwiLCBPYnNlcnZhYmxlU2V0KTtcblxudmFyIGRlc2NyaXB0b3JDYWNoZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xudmFyIFJFTU9WRSA9IFwicmVtb3ZlXCI7XG52YXIgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKHRhcmdldF8sIHZhbHVlc18sIG5hbWVfLCAvLyBVc2VkIGFueXRpbWUgYW5ub3RhdGlvbiBpcyBub3QgZXhwbGljaXRlbHkgcHJvdmlkZWRcbiAgZGVmYXVsdEFubm90YXRpb25fKSB7XG4gICAgaWYgKHZhbHVlc18gPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWVzXyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdEFubm90YXRpb25fID09PSB2b2lkIDApIHtcbiAgICAgIGRlZmF1bHRBbm5vdGF0aW9uXyA9IGF1dG9Bbm5vdGF0aW9uO1xuICAgIH1cblxuICAgIHRoaXMudGFyZ2V0XyA9IHZvaWQgMDtcbiAgICB0aGlzLnZhbHVlc18gPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleXNBdG9tXyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnNfID0gdm9pZCAwO1xuICAgIHRoaXMucHJveHlfID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQbGFpbk9iamVjdF8gPSB2b2lkIDA7XG4gICAgdGhpcy5hcHBsaWVkQW5ub3RhdGlvbnNfID0gdm9pZCAwO1xuICAgIHRoaXMucGVuZGluZ0tleXNfID0gdm9pZCAwO1xuICAgIHRoaXMudGFyZ2V0XyA9IHRhcmdldF87XG4gICAgdGhpcy52YWx1ZXNfID0gdmFsdWVzXztcbiAgICB0aGlzLm5hbWVfID0gbmFtZV87XG4gICAgdGhpcy5kZWZhdWx0QW5ub3RhdGlvbl8gPSBkZWZhdWx0QW5ub3RhdGlvbl87XG4gICAgdGhpcy5rZXlzQXRvbV8gPSBuZXcgQXRvbSggdGhpcy5uYW1lXyArIFwiLmtleXNcIiApOyAvLyBPcHRpbWl6YXRpb246IHdlIHVzZSB0aGlzIGZyZXF1ZW50bHlcblxuICAgIHRoaXMuaXNQbGFpbk9iamVjdF8gPSBpc1BsYWluT2JqZWN0KHRoaXMudGFyZ2V0Xyk7XG5cbiAgICBpZiAoICFpc0Fubm90YXRpb24odGhpcy5kZWZhdWx0QW5ub3RhdGlvbl8pKSB7XG4gICAgICBkaWUoXCJkZWZhdWx0QW5ub3RhdGlvbiBtdXN0IGJlIHZhbGlkIGFubm90YXRpb25cIik7XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gUHJlcGFyZSBzdHJ1Y3R1cmUgZm9yIHRyYWNraW5nIHdoaWNoIGZpZWxkcyB3ZXJlIGFscmVhZHkgYW5ub3RhdGVkXG4gICAgICB0aGlzLmFwcGxpZWRBbm5vdGF0aW9uc18gPSB7fTtcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8gPSBmdW5jdGlvbiBnZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNfLmdldChrZXkpLmdldCgpO1xuICB9O1xuXG4gIF9wcm90by5zZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyA9IGZ1bmN0aW9uIHNldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMudmFsdWVzXy5nZXQoa2V5KTtcblxuICAgIGlmIChvYnNlcnZhYmxlIGluc3RhbmNlb2YgQ29tcHV0ZWRWYWx1ZSkge1xuICAgICAgb2JzZXJ2YWJsZS5zZXQobmV3VmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBpbnRlcmNlcHRcblxuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gbnVsbDtcbiAgICAgIG5ld1ZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgIH1cblxuICAgIG5ld1ZhbHVlID0gb2JzZXJ2YWJsZS5wcmVwYXJlTmV3VmFsdWVfKG5ld1ZhbHVlKTsgLy8gbm90aWZ5IHNweSAmIG9ic2VydmVyc1xuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQpIHtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gIGlzU3B5RW5hYmxlZCgpO1xuXG4gICAgICB2YXIgX2NoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwib2JqZWN0XCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgIG9sZFZhbHVlOiBvYnNlcnZhYmxlLnZhbHVlXyxcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0gOiBudWxsO1xuXG4gICAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZSk7XG4gICAgICBvYnNlcnZhYmxlLnNldE5ld1ZhbHVlXyhuZXdWYWx1ZSk7XG4gICAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZSk7XG4gICAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLmdldF8gPSBmdW5jdGlvbiBnZXRfKGtleSkge1xuICAgIGlmIChnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gJiYgIWhhc1Byb3AodGhpcy50YXJnZXRfLCBrZXkpKSB7XG4gICAgICAvLyBLZXkgZG9lc24ndCBleGlzdCB5ZXQsIHN1YnNjcmliZSBmb3IgaXQgaW4gY2FzZSBpdCdzIGFkZGVkIGxhdGVyXG4gICAgICB0aGlzLmhhc18oa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50YXJnZXRfW2tleV07XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XHJcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXHJcbiAgICogQHBhcmFtIHtBbm5vdGF0aW9ufGJvb2xlYW59IGFubm90YXRpb24gdHJ1ZSAtIHVzZSBkZWZhdWx0IGFubm90YXRpb24sIGZhbHNlIC0gY29weSBhcyBpc1xyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJveHlUcmFwIHdoZXRoZXIgaXQncyBjYWxsZWQgZnJvbSBwcm94eSB0cmFwXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbH0gdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlIChwcm94eVRyYXAgKyBub24tY29uZmlndXJhYmxlKSwgbnVsbCB3aGVuIGNhbmNlbGxlZCBieSBpbnRlcmNlcHRvclxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldF8gPSBmdW5jdGlvbiBzZXRfKGtleSwgdmFsdWUsIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgdXNlIC5oYXMoa2V5KSAtIHdlIGNhcmUgYWJvdXQgb3duXG4gICAgaWYgKGhhc1Byb3AodGhpcy50YXJnZXRfLCBrZXkpKSB7XG4gICAgICAvLyBFeGlzdGluZyBwcm9wXG4gICAgICBpZiAodGhpcy52YWx1ZXNfLmhhcyhrZXkpKSB7XG4gICAgICAgIC8vIE9ic2VydmFibGUgKGNhbiBiZSBpbnRlcmNlcHRlZClcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICAvLyBOb24tb2JzZXJ2YWJsZSAtIHByb3h5XG4gICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0aGlzLnRhcmdldF8sIGtleSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9uLW9ic2VydmFibGVcbiAgICAgICAgdGhpcy50YXJnZXRfW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5ldyBwcm9wXG4gICAgICByZXR1cm4gdGhpcy5leHRlbmRfKGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0sIHRoaXMuZGVmYXVsdEFubm90YXRpb25fLCBwcm94eVRyYXApO1xuICAgIH1cbiAgfSAvLyBUcmFwIGZvciBcImluXCJcbiAgO1xuXG4gIF9wcm90by5oYXNfID0gZnVuY3Rpb24gaGFzXyhrZXkpIHtcbiAgICBpZiAoIWdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgLy8gU2tpcCBrZXkgc3Vic2NyaXB0aW9uIG91dHNpZGUgZGVyaXZhdGlvblxuICAgICAgcmV0dXJuIGtleSBpbiB0aGlzLnRhcmdldF87XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nS2V5c18gfHwgKHRoaXMucGVuZGluZ0tleXNfID0gbmV3IE1hcCgpKTtcbiAgICB2YXIgZW50cnkgPSB0aGlzLnBlbmRpbmdLZXlzXy5nZXQoa2V5KTtcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGVudHJ5ID0gbmV3IE9ic2VydmFibGVWYWx1ZShrZXkgaW4gdGhpcy50YXJnZXRfLCByZWZlcmVuY2VFbmhhbmNlciwgIHRoaXMubmFtZV8gKyBcIi5cIiArIHN0cmluZ2lmeUtleShrZXkpICsgXCI/XCIgLCBmYWxzZSk7XG4gICAgICB0aGlzLnBlbmRpbmdLZXlzXy5zZXQoa2V5LCBlbnRyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5LmdldCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxyXG4gICAqIEBwYXJhbSB7QW5ub3RhdGlvbnxib29sZWFufSBhbm5vdGF0aW9uIHRydWUgLSB1c2UgZGVmYXVsdCBhbm5vdGF0aW9uLCBmYWxzZSAtIGlnbm9yZSBwcm9wXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ubWFrZV8gPSBmdW5jdGlvbiBtYWtlXyhrZXksIGFubm90YXRpb24pIHtcbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgYW5ub3RhdGlvbiA9IHRoaXMuZGVmYXVsdEFubm90YXRpb25fO1xuICAgIH1cblxuICAgIGlmIChhbm5vdGF0aW9uID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFzc2VydEFubm90YWJsZSh0aGlzLCBhbm5vdGF0aW9uLCBrZXkpO1xuXG4gICAgaWYgKCEoa2V5IGluIHRoaXMudGFyZ2V0XykpIHtcbiAgICAgIHZhciBfdGhpcyR0YXJnZXRfJHN0b3JlZEE7XG5cbiAgICAgIC8vIFRocm93IG9uIG1pc3Npbmcga2V5LCBleGNlcHQgZm9yIGRlY29yYXRvcnM6XG4gICAgICAvLyBEZWNvcmF0b3IgYW5ub3RhdGlvbnMgYXJlIGNvbGxlY3RlZCBmcm9tIHdob2xlIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgIC8vIFdoZW4gY2FsbGVkIGZyb20gc3VwZXIoKSBzb21lIHByb3BzIG1heSBub3QgZXhpc3QgeWV0LlxuICAgICAgLy8gSG93ZXZlciB3ZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IG1pc3NpbmcgcHJvcCxcbiAgICAgIC8vIGJlY2F1c2UgdGhlIGRlY29yYXRvciBtdXN0IGhhdmUgYmVlbiBhcHBsaWVkIHRvIHNvbWV0aGluZy5cbiAgICAgIGlmICgoX3RoaXMkdGFyZ2V0XyRzdG9yZWRBID0gdGhpcy50YXJnZXRfW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRhcmdldF8kc3RvcmVkQVtrZXldKSB7XG4gICAgICAgIHJldHVybjsgLy8gd2lsbCBiZSBhbm5vdGF0ZWQgYnkgc3ViY2xhc3MgY29uc3RydWN0b3JcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpZSgxLCBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlXywgdGhpcy5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzb3VyY2UgPSB0aGlzLnRhcmdldF87XG5cbiAgICB3aGlsZSAoc291cmNlICYmIHNvdXJjZSAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IGdldERlc2NyaXB0b3Ioc291cmNlLCBrZXkpO1xuXG4gICAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICB2YXIgb3V0Y29tZSA9IGFubm90YXRpb24ubWFrZV8odGhpcywga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpO1xuICAgICAgICBpZiAob3V0Y29tZSA9PT0gMFxuICAgICAgICAvKiBDYW5jZWwgKi9cbiAgICAgICAgKSByZXR1cm47XG4gICAgICAgIGlmIChvdXRjb21lID09PSAxXG4gICAgICAgIC8qIEJyZWFrICovXG4gICAgICAgICkgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpO1xuICAgIH1cblxuICAgIHJlY29yZEFubm90YXRpb25BcHBsaWVkKHRoaXMsIGFubm90YXRpb24sIGtleSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eURlc2NyaXB0b3J9IGRlc2NyaXB0b3JcclxuICAgKiBAcGFyYW0ge0Fubm90YXRpb258Ym9vbGVhbn0gYW5ub3RhdGlvbiB0cnVlIC0gdXNlIGRlZmF1bHQgYW5ub3RhdGlvbiwgZmFsc2UgLSBjb3B5IGFzIGlzXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBwcm94eVRyYXAgd2hldGhlciBpdCdzIGNhbGxlZCBmcm9tIHByb3h5IHRyYXBcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxudWxsfSB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUgKHByb3h5VHJhcCArIG5vbi1jb25maWd1cmFibGUpLCBudWxsIHdoZW4gY2FuY2VsbGVkIGJ5IGludGVyY2VwdG9yXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZXh0ZW5kXyA9IGZ1bmN0aW9uIGV4dGVuZF8oa2V5LCBkZXNjcmlwdG9yLCBhbm5vdGF0aW9uLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhbm5vdGF0aW9uID09PSB0cnVlKSB7XG4gICAgICBhbm5vdGF0aW9uID0gdGhpcy5kZWZhdWx0QW5ub3RhdGlvbl87XG4gICAgfVxuXG4gICAgaWYgKGFubm90YXRpb24gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZpbmVQcm9wZXJ0eV8oa2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApO1xuICAgIH1cblxuICAgIGFzc2VydEFubm90YWJsZSh0aGlzLCBhbm5vdGF0aW9uLCBrZXkpO1xuICAgIHZhciBvdXRjb21lID0gYW5ub3RhdGlvbi5leHRlbmRfKHRoaXMsIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcblxuICAgIGlmIChvdXRjb21lKSB7XG4gICAgICByZWNvcmRBbm5vdGF0aW9uQXBwbGllZCh0aGlzLCBhbm5vdGF0aW9uLCBrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRjb21lO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlEZXNjcmlwdG9yfSBkZXNjcmlwdG9yXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBwcm94eVRyYXAgd2hldGhlciBpdCdzIGNhbGxlZCBmcm9tIHByb3h5IHRyYXBcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxudWxsfSB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUgKHByb3h5VHJhcCArIG5vbi1jb25maWd1cmFibGUpLCBudWxsIHdoZW4gY2FuY2VsbGVkIGJ5IGludGVyY2VwdG9yXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVmaW5lUHJvcGVydHlfID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc3RhcnRCYXRjaCgpOyAvLyBEZWxldGVcblxuICAgICAgdmFyIGRlbGV0ZU91dGNvbWUgPSB0aGlzLmRlbGV0ZV8oa2V5KTtcblxuICAgICAgaWYgKCFkZWxldGVPdXRjb21lKSB7XG4gICAgICAgIC8vIEZhaWx1cmUgb3IgaW50ZXJjZXB0ZWRcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU91dGNvbWU7XG4gICAgICB9IC8vIEFERCBpbnRlcmNlcHRvclxuXG5cbiAgICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgICBuZXdWYWx1ZTogZGVzY3JpcHRvci52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG5cbiAgICAgICAgaWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgZGVzY3JpcHRvciA9IF9leHRlbmRzKHt9LCBkZXNjcmlwdG9yLCB7XG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBEZWZpbmVcblxuXG4gICAgICBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIGlmICghUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH0gLy8gTm90aWZ5XG5cblxuICAgICAgdGhpcy5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyhrZXksIGRlc2NyaXB0b3IudmFsdWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIElmIG9yaWdpbmFsIGRlc2NyaXB0b3IgYmVjb21lcyByZWxldmFudCwgbW92ZSB0aGlzIHRvIGFubm90YXRpb24gZGlyZWN0bHlcbiAgO1xuXG4gIF9wcm90by5kZWZpbmVPYnNlcnZhYmxlUHJvcGVydHlfID0gZnVuY3Rpb24gZGVmaW5lT2JzZXJ2YWJsZVByb3BlcnR5XyhrZXksIHZhbHVlLCBlbmhhbmNlciwgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc3RhcnRCYXRjaCgpOyAvLyBEZWxldGVcblxuICAgICAgdmFyIGRlbGV0ZU91dGNvbWUgPSB0aGlzLmRlbGV0ZV8oa2V5KTtcblxuICAgICAgaWYgKCFkZWxldGVPdXRjb21lKSB7XG4gICAgICAgIC8vIEZhaWx1cmUgb3IgaW50ZXJjZXB0ZWRcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU91dGNvbWU7XG4gICAgICB9IC8vIEFERCBpbnRlcmNlcHRvclxuXG5cbiAgICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgICBuZXdWYWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYWNoZWREZXNjcmlwdG9yID0gZ2V0Q2FjaGVkT2JzZXJ2YWJsZVByb3BEZXNjcmlwdG9yKGtleSk7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnMgPyB0aGlzLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBjYWNoZWREZXNjcmlwdG9yLmdldCxcbiAgICAgICAgc2V0OiBjYWNoZWREZXNjcmlwdG9yLnNldFxuICAgICAgfTsgLy8gRGVmaW5lXG5cbiAgICAgIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgaWYgKCFSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUodmFsdWUsIGVuaGFuY2VyLCBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiID8gdGhpcy5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgOiBcIk9ic2VydmFibGVPYmplY3Qua2V5XCIsIGZhbHNlKTtcbiAgICAgIHRoaXMudmFsdWVzXy5zZXQoa2V5LCBvYnNlcnZhYmxlKTsgLy8gTm90aWZ5ICh2YWx1ZSBwb3NzaWJseSBjaGFuZ2VkIGJ5IE9ic2VydmFibGVWYWx1ZSlcblxuICAgICAgdGhpcy5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyhrZXksIG9ic2VydmFibGUudmFsdWVfKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiBvcmlnaW5hbCBkZXNjcmlwdG9yIGJlY29tZXMgcmVsZXZhbnQsIG1vdmUgdGhpcyB0byBhbm5vdGF0aW9uIGRpcmVjdGx5XG4gIDtcblxuICBfcHJvdG8uZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eV8gPSBmdW5jdGlvbiBkZWZpbmVDb21wdXRlZFByb3BlcnR5XyhrZXksIG9wdGlvbnMsIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0QmF0Y2goKTsgLy8gRGVsZXRlXG5cbiAgICAgIHZhciBkZWxldGVPdXRjb21lID0gdGhpcy5kZWxldGVfKGtleSk7XG5cbiAgICAgIGlmICghZGVsZXRlT3V0Y29tZSkge1xuICAgICAgICAvLyBGYWlsdXJlIG9yIGludGVyY2VwdGVkXG4gICAgICAgIHJldHVybiBkZWxldGVPdXRjb21lO1xuICAgICAgfSAvLyBBREQgaW50ZXJjZXB0b3JcblxuXG4gICAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgICAgbmV3VmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLm5hbWUgfHwgKG9wdGlvbnMubmFtZSA9IFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB0aGlzLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSA6IFwiT2JzZXJ2YWJsZU9iamVjdC5rZXlcIik7XG4gICAgICBvcHRpb25zLmNvbnRleHQgPSB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF87XG4gICAgICB2YXIgY2FjaGVkRGVzY3JpcHRvciA9IGdldENhY2hlZE9ic2VydmFibGVQcm9wRGVzY3JpcHRvcihrZXkpO1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZ2xvYmFsU3RhdGUuc2FmZURlc2NyaXB0b3JzID8gdGhpcy5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQ6IGNhY2hlZERlc2NyaXB0b3IuZ2V0LFxuICAgICAgICBzZXQ6IGNhY2hlZERlc2NyaXB0b3Iuc2V0XG4gICAgICB9OyAvLyBEZWZpbmVcblxuICAgICAgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICBpZiAoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmFsdWVzXy5zZXQoa2V5LCBuZXcgQ29tcHV0ZWRWYWx1ZShvcHRpb25zKSk7IC8vIE5vdGlmeVxuXG4gICAgICB0aGlzLm5vdGlmeVByb3BlcnR5QWRkaXRpb25fKGtleSwgdW5kZWZpbmVkKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5RGVzY3JpcHRvcn0gZGVzY3JpcHRvclxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJveHlUcmFwIHdoZXRoZXIgaXQncyBjYWxsZWQgZnJvbSBwcm94eSB0cmFwXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVsbH0gdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlIChwcm94eVRyYXAgKyBub24tY29uZmlndXJhYmxlKSwgbnVsbCB3aGVuIGNhbmNlbGxlZCBieSBpbnRlcmNlcHRvclxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlbGV0ZV8gPSBmdW5jdGlvbiBkZWxldGVfKGtleSwgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBObyBzdWNoIHByb3BcbiAgICBpZiAoIWhhc1Byb3AodGhpcy50YXJnZXRfLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIEludGVyY2VwdFxuXG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgdHlwZTogUkVNT1ZFXG4gICAgICB9KTsgLy8gQ2FuY2VsbGVkXG5cbiAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gbnVsbDtcbiAgICB9IC8vIERlbGV0ZVxuXG5cbiAgICB0cnkge1xuICAgICAgdmFyIF90aGlzJHBlbmRpbmdLZXlzXywgX3RoaXMkcGVuZGluZ0tleXNfJGdlO1xuXG4gICAgICBzdGFydEJhdGNoKCk7XG4gICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgdmFyIG5vdGlmeVNweSA9IFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNTcHlFbmFibGVkKCk7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IHRoaXMudmFsdWVzXy5nZXQoa2V5KTsgLy8gVmFsdWUgbmVlZGVkIGZvciBzcGllcy9saXN0ZW5lcnNcblxuICAgICAgdmFyIHZhbHVlID0gdW5kZWZpbmVkOyAvLyBPcHRpbWl6YXRpb246IGRvbid0IHB1bGwgdGhlIHZhbHVlIHVubGVzcyB3ZSB3aWxsIG5lZWQgaXRcblxuICAgICAgaWYgKCFvYnNlcnZhYmxlICYmIChub3RpZnkgfHwgbm90aWZ5U3B5KSkge1xuICAgICAgICB2YXIgX2dldERlc2NyaXB0b3I7XG5cbiAgICAgICAgdmFsdWUgPSAoX2dldERlc2NyaXB0b3IgPSBnZXREZXNjcmlwdG9yKHRoaXMudGFyZ2V0Xywga2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXREZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgfSAvLyBkZWxldGUgcHJvcCAoZG8gZmlyc3QsIG1heSBmYWlsKVxuXG5cbiAgICAgIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgaWYgKCFSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGFyZ2V0X1trZXldO1xuICAgICAgfSAvLyBBbGxvdyByZS1hbm5vdGF0aW5nIHRoaXMgZmllbGRcblxuXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBkZWxldGUgdGhpcy5hcHBsaWVkQW5ub3RhdGlvbnNfW2tleV07XG4gICAgICB9IC8vIENsZWFyIG9ic2VydmFibGVcblxuXG4gICAgICBpZiAob2JzZXJ2YWJsZSkge1xuICAgICAgICB0aGlzLnZhbHVlc19bXCJkZWxldGVcIl0oa2V5KTsgLy8gZm9yIGNvbXB1dGVkLCB2YWx1ZSBpcyB1bmRlZmluZWRcblxuICAgICAgICBpZiAob2JzZXJ2YWJsZSBpbnN0YW5jZW9mIE9ic2VydmFibGVWYWx1ZSkge1xuICAgICAgICAgIHZhbHVlID0gb2JzZXJ2YWJsZS52YWx1ZV87XG4gICAgICAgIH0gLy8gTm90aWZ5OiBhdXRvcnVuKCgpID0+IG9ialtrZXldKSwgc2VlICMxNzk2XG5cblxuICAgICAgICBwcm9wYWdhdGVDaGFuZ2VkKG9ic2VydmFibGUpO1xuICAgICAgfSAvLyBOb3RpZnkgXCJrZXlzL2VudHJpZXMvdmFsdWVzXCIgb2JzZXJ2ZXJzXG5cblxuICAgICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0Q2hhbmdlZCgpOyAvLyBOb3RpZnkgXCJoYXNcIiBvYnNlcnZlcnNcbiAgICAgIC8vIFwiaW5cIiBhcyBpdCBtYXkgc3RpbGwgZXhpc3QgaW4gcHJvdG9cblxuICAgICAgKF90aGlzJHBlbmRpbmdLZXlzXyA9IHRoaXMucGVuZGluZ0tleXNfKSA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzJHBlbmRpbmdLZXlzXyRnZSA9IF90aGlzJHBlbmRpbmdLZXlzXy5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBlbmRpbmdLZXlzXyRnZS5zZXQoa2V5IGluIHRoaXMudGFyZ2V0Xyk7IC8vIE5vdGlmeSBzcGllcy9saXN0ZW5lcnNcblxuICAgICAgaWYgKG5vdGlmeSB8fCBub3RpZnlTcHkpIHtcbiAgICAgICAgdmFyIF9jaGFuZ2UyID0ge1xuICAgICAgICAgIHR5cGU6IFJFTU9WRSxcbiAgICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJvYmplY3RcIixcbiAgICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgICAgb2xkVmFsdWU6IHZhbHVlLFxuICAgICAgICAgIG5hbWU6IGtleVxuICAgICAgICB9O1xuICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UyKTtcbiAgICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UyKTtcbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbm90aWZ5U3B5KSBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZW5kQmF0Y2goKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcclxuICAgKiBPYnNlcnZlcyB0aGlzIG9iamVjdC4gVHJpZ2dlcnMgZm9yIHRoZSBldmVudHMgJ2FkZCcsICd1cGRhdGUnIGFuZCAnZGVsZXRlJy5cclxuICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9vYnNlcnZlXHJcbiAgICogZm9yIGNhbGxiYWNrIGRldGFpbHNcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vYnNlcnZlXyA9IGZ1bmN0aW9uIG9ic2VydmVfKGNhbGxiYWNrLCBmaXJlSW1tZWRpYXRlbHkpIHtcbiAgICBpZiAoIGZpcmVJbW1lZGlhdGVseSA9PT0gdHJ1ZSkgZGllKFwiYG9ic2VydmVgIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmlyZSBpbW1lZGlhdGVseSBwcm9wZXJ0eSBmb3Igb2JzZXJ2YWJsZSBvYmplY3RzLlwiKTtcbiAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcblxuICBfcHJvdG8ubm90aWZ5UHJvcGVydHlBZGRpdGlvbl8gPSBmdW5jdGlvbiBub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyhrZXksIHZhbHVlKSB7XG4gICAgdmFyIF90aGlzJHBlbmRpbmdLZXlzXzIsIF90aGlzJHBlbmRpbmdLZXlzXzIkZztcblxuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIG5vdGlmeVNweSA9ICBpc1NweUVuYWJsZWQoKTtcblxuICAgIGlmIChub3RpZnkgfHwgbm90aWZ5U3B5KSB7XG4gICAgICB2YXIgY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgdHlwZTogQURELFxuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJvYmplY3RcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICBuZXdWYWx1ZTogdmFsdWVcbiAgICAgIH0gOiBudWxsO1xuICAgICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRFbmQoKTtcbiAgICB9XG5cbiAgICAoX3RoaXMkcGVuZGluZ0tleXNfMiA9IHRoaXMucGVuZGluZ0tleXNfKSA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzJHBlbmRpbmdLZXlzXzIkZyA9IF90aGlzJHBlbmRpbmdLZXlzXzIuZ2V0KGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwZW5kaW5nS2V5c18yJGcuc2V0KHRydWUpOyAvLyBOb3RpZnkgXCJrZXlzL2VudHJpZXMvdmFsdWVzXCIgb2JzZXJ2ZXJzXG5cbiAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gIH07XG5cbiAgX3Byb3RvLm93bktleXNfID0gZnVuY3Rpb24gb3duS2V5c18oKSB7XG4gICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gb3duS2V5cyh0aGlzLnRhcmdldF8pO1xuICB9O1xuXG4gIF9wcm90by5rZXlzXyA9IGZ1bmN0aW9uIGtleXNfKCkge1xuICAgIC8vIFJldHVybnMgZW51bWVyYWJsZSAmJiBvd24sIGJ1dCB1bmZvcnR1bmF0ZWx5IGtleXNBdG9tIHdpbGwgcmVwb3J0IG9uIEFOWSBrZXkgY2hhbmdlLlxuICAgIC8vIFRoZXJlIGlzIG5vIHdheSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIE9iamVjdC5rZXlzKG9iamVjdCkgYW5kIFJlZmxlY3Qub3duS2V5cyhvYmplY3QpIC0gYm90aCBhcmUgaGFuZGxlZCBieSBvd25LZXlzIHRyYXAuXG4gICAgLy8gV2UgY2FuIGVpdGhlciBvdmVyLXJlcG9ydCBpbiBPYmplY3Qua2V5cyhvYmplY3QpIG9yIHVuZGVyLXJlcG9ydCBpbiBSZWZsZWN0Lm93bktleXMob2JqZWN0KVxuICAgIC8vIFdlIGNob29zZSB0byBvdmVyLXJlcG9ydCBpbiBPYmplY3Qua2V5cyhvYmplY3QpLCBiZWNhdXNlOlxuICAgIC8vIC0gdHlwaWNhbGx5IGl0J3MgdXNlZCB3aXRoIHNpbXBsZSBkYXRhIG9iamVjdHNcbiAgICAvLyAtIHdoZW4gc3ltYm9saWMvbm9uLWVudW1lcmFibGUga2V5cyBhcmUgcmVsZXZhbnQgUmVmbGVjdC5vd25LZXlzIHdvcmtzIGFzIGV4cGVjdGVkXG4gICAgdGhpcy5rZXlzQXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50YXJnZXRfKTtcbiAgfTtcblxuICByZXR1cm4gT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uO1xufSgpO1xuZnVuY3Rpb24gYXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkbmFtZTtcblxuICBpZiAoIG9wdGlvbnMgJiYgaXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCkpIHtcbiAgICBkaWUoXCJPcHRpb25zIGNhbid0IGJlIHByb3ZpZGVkIGZvciBhbHJlYWR5IG9ic2VydmFibGUgb2JqZWN0cy5cIik7XG4gIH1cblxuICBpZiAoaGFzUHJvcCh0YXJnZXQsICRtb2J4KSkge1xuICAgIGlmICggIShnZXRBZG1pbmlzdHJhdGlvbih0YXJnZXQpIGluc3RhbmNlb2YgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKSkge1xuICAgICAgZGllKFwiQ2Fubm90IGNvbnZlcnQgJ1wiICsgZ2V0RGVidWdOYW1lKHRhcmdldCkgKyBcIicgaW50byBvYnNlcnZhYmxlIG9iamVjdDpcIiArIFwiXFxuVGhlIHRhcmdldCBpcyBhbHJlYWR5IG9ic2VydmFibGUgb2YgZGlmZmVyZW50IHR5cGUuXCIgKyBcIlxcbkV4dGVuZGluZyBidWlsdGlucyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgaWYgKCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpKSBkaWUoXCJDYW5ub3QgbWFrZSB0aGUgZGVzaWduYXRlZCBvYmplY3Qgb2JzZXJ2YWJsZTsgaXQgaXMgbm90IGV4dGVuc2libGVcIik7XG4gIHZhciBuYW1lID0gKF9vcHRpb25zJG5hbWUgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm5hbWUpICE9IG51bGwgPyBfb3B0aW9ucyRuYW1lIDogIChpc1BsYWluT2JqZWN0KHRhcmdldCkgPyBcIk9ic2VydmFibGVPYmplY3RcIiA6IHRhcmdldC5jb25zdHJ1Y3Rvci5uYW1lKSArIFwiQFwiICsgZ2V0TmV4dElkKCkgO1xuICB2YXIgYWRtID0gbmV3IE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbih0YXJnZXQsIG5ldyBNYXAoKSwgU3RyaW5nKG5hbWUpLCBnZXRBbm5vdGF0aW9uRnJvbU9wdGlvbnMob3B0aW9ucykpO1xuICBhZGRIaWRkZW5Qcm9wKHRhcmdldCwgJG1vYngsIGFkbSk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG52YXIgaXNPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvblwiLCBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24pO1xuXG5mdW5jdGlvbiBnZXRDYWNoZWRPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3Ioa2V5KSB7XG4gIHJldHVybiBkZXNjcmlwdG9yQ2FjaGVba2V5XSB8fCAoZGVzY3JpcHRvckNhY2hlW2tleV0gPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uZ2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5KTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSB7XG4gIGlmIChpc09iamVjdCh0aGluZykpIHtcbiAgICByZXR1cm4gaXNPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24odGhpbmdbJG1vYnhdKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlY29yZEFubm90YXRpb25BcHBsaWVkKGFkbSwgYW5ub3RhdGlvbiwga2V5KSB7XG4gIHZhciBfYWRtJHRhcmdldF8kc3RvcmVkQW47XG5cbiAge1xuICAgIGFkbS5hcHBsaWVkQW5ub3RhdGlvbnNfW2tleV0gPSBhbm5vdGF0aW9uO1xuICB9IC8vIFJlbW92ZSBhcHBsaWVkIGRlY29yYXRvciBhbm5vdGF0aW9uIHNvIHdlIGRvbid0IHRyeSB0byBhcHBseSBpdCBhZ2FpbiBpbiBzdWJjbGFzcyBjb25zdHJ1Y3RvclxuXG5cbiAgKF9hZG0kdGFyZ2V0XyRzdG9yZWRBbiA9IGFkbS50YXJnZXRfW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSkgPT0gbnVsbCA/IHRydWUgOiBkZWxldGUgX2FkbSR0YXJnZXRfJHN0b3JlZEFuW2tleV07XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFubm90YWJsZShhZG0sIGFubm90YXRpb24sIGtleSkge1xuICAvLyBWYWxpZCBhbm5vdGF0aW9uXG4gIGlmICggIWlzQW5ub3RhdGlvbihhbm5vdGF0aW9uKSkge1xuICAgIGRpZShcIkNhbm5vdCBhbm5vdGF0ZSAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOiBJbnZhbGlkIGFubm90YXRpb24uXCIpO1xuICB9XG4gIC8qXHJcbiAgLy8gQ29uZmlndXJhYmxlLCBub3Qgc2VhbGVkLCBub3QgZnJvemVuXHJcbiAgLy8gUG9zc2libHkgbm90IG5lZWRlZCwganVzdCBhIGxpdHRsZSBiZXR0ZXIgZXJyb3IgdGhlbiB0aGUgb25lIHRocm93biBieSBlbmdpbmUuXHJcbiAgLy8gQ2FzZXMgd2hlcmUgdGhpcyB3b3VsZCBiZSB1c2VmdWwgdGhlIG1vc3QgKHN1YmNsYXNzIGZpZWxkIGluaXRpYWxpemVyKSBhcmUgbm90IGludGVyY2VwdGFibGUgYnkgdGhpcy5cclxuICBpZiAoX19ERVZfXykge1xyXG4gICAgICBjb25zdCBjb25maWd1cmFibGUgPSBnZXREZXNjcmlwdG9yKGFkbS50YXJnZXRfLCBrZXkpPy5jb25maWd1cmFibGVcclxuICAgICAgY29uc3QgZnJvemVuID0gT2JqZWN0LmlzRnJvemVuKGFkbS50YXJnZXRfKVxyXG4gICAgICBjb25zdCBzZWFsZWQgPSBPYmplY3QuaXNTZWFsZWQoYWRtLnRhcmdldF8pXHJcbiAgICAgIGlmICghY29uZmlndXJhYmxlIHx8IGZyb3plbiB8fCBzZWFsZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGAke2FkbS5uYW1lX30uJHtrZXkudG9TdHJpbmcoKX1gXHJcbiAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSA9IGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfXHJcbiAgICAgICAgICBsZXQgZXJyb3IgPSBgQ2Fubm90IGFwcGx5ICcke3JlcXVlc3RlZEFubm90YXRpb25UeXBlfScgdG8gJyR7ZmllbGROYW1lfSc6YFxyXG4gICAgICAgICAgaWYgKGZyb3plbikge1xyXG4gICAgICAgICAgICAgIGVycm9yICs9IGBcXG5PYmplY3QgaXMgZnJvemVuLmBcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChzZWFsZWQpIHtcclxuICAgICAgICAgICAgICBlcnJvciArPSBgXFxuT2JqZWN0IGlzIHNlYWxlZC5gXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIWNvbmZpZ3VyYWJsZSkge1xyXG4gICAgICAgICAgICAgIGVycm9yICs9IGBcXG5wcm9wZXJ0eSBpcyBub3QgY29uZmlndXJhYmxlLmBcclxuICAgICAgICAgICAgICAvLyBNZW50aW9uIG9ubHkgaWYgY2F1c2VkIGJ5IHVzIHRvIGF2b2lkIGNvbmZ1c2lvblxyXG4gICAgICAgICAgICAgIGlmIChoYXNQcm9wKGFkbS5hcHBsaWVkQW5ub3RhdGlvbnMhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgIGVycm9yICs9IGBcXG5UbyBwcmV2ZW50IGFjY2lkZW50YWwgcmUtZGVmaW5pdGlvbiBvZiBhIGZpZWxkIGJ5IGEgc3ViY2xhc3MsIGBcclxuICAgICAgICAgICAgICAgICAgZXJyb3IgKz0gYGFsbCBhbm5vdGF0ZWQgZmllbGRzIG9mIG5vbi1wbGFpbiBvYmplY3RzIChjbGFzc2VzKSBhcmUgbm90IGNvbmZpZ3VyYWJsZS5gXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGllKGVycm9yKVxyXG4gICAgICB9XHJcbiAgfVxyXG4gICovXG4gIC8vIE5vdCBhbm5vdGF0ZWRcblxuXG4gIGlmICggIWlzT3ZlcnJpZGUoYW5ub3RhdGlvbikgJiYgaGFzUHJvcChhZG0uYXBwbGllZEFubm90YXRpb25zXywga2V5KSkge1xuICAgIHZhciBmaWVsZE5hbWUgPSBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpO1xuICAgIHZhciBjdXJyZW50QW5ub3RhdGlvblR5cGUgPSBhZG0uYXBwbGllZEFubm90YXRpb25zX1trZXldLmFubm90YXRpb25UeXBlXztcbiAgICB2YXIgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgPSBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlXztcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgcmVxdWVzdGVkQW5ub3RhdGlvblR5cGUgKyBcIicgdG8gJ1wiICsgZmllbGROYW1lICsgXCInOlwiICsgKFwiXFxuVGhlIGZpZWxkIGlzIGFscmVhZHkgYW5ub3RhdGVkIHdpdGggJ1wiICsgY3VycmVudEFubm90YXRpb25UeXBlICsgXCInLlwiKSArIFwiXFxuUmUtYW5ub3RhdGluZyBmaWVsZHMgaXMgbm90IGFsbG93ZWQuXCIgKyBcIlxcblVzZSAnb3ZlcnJpZGUnIGFubm90YXRpb24gZm9yIG1ldGhvZHMgb3ZlcnJpZGVuIGJ5IHN1YmNsYXNzLlwiKTtcbiAgfVxufVxuXG4vKipcclxuICogVGhpcyBhcnJheSBidWZmZXIgY29udGFpbnMgdHdvIGxpc3RzIG9mIHByb3BlcnRpZXMsIHNvIHRoYXQgYWxsIGFycmF5c1xyXG4gKiBjYW4gcmVjeWNsZSB0aGVpciBwcm9wZXJ0eSBkZWZpbml0aW9ucywgd2hpY2ggc2lnbmlmaWNhbnRseSBpbXByb3ZlcyBwZXJmb3JtYW5jZSBvZiBjcmVhdGluZ1xyXG4gKiBwcm9wZXJ0aWVzIG9uIHRoZSBmbHkuXHJcbiAqL1xuXG52YXIgT0JTRVJWQUJMRV9BUlJBWV9CVUZGRVJfU0laRSA9IDA7IC8vIFR5cGVzY3JpcHQgd29ya2Fyb3VuZCB0byBtYWtlIHN1cmUgT2JzZXJ2YWJsZUFycmF5IGV4dGVuZHMgQXJyYXlcblxudmFyIFN0dWJBcnJheSA9IGZ1bmN0aW9uIFN0dWJBcnJheSgpIHt9O1xuXG5mdW5jdGlvbiBpbmhlcml0KGN0b3IsIHByb3RvKSB7XG4gIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY3Rvci5wcm90b3R5cGUsIHByb3RvKTtcbiAgfSBlbHNlIGlmIChjdG9yLnByb3RvdHlwZS5fX3Byb3RvX18gIT09IHVuZGVmaW5lZCkge1xuICAgIGN0b3IucHJvdG90eXBlLl9fcHJvdG9fXyA9IHByb3RvO1xuICB9IGVsc2Uge1xuICAgIGN0b3IucHJvdG90eXBlID0gcHJvdG87XG4gIH1cbn1cblxuaW5oZXJpdChTdHViQXJyYXksIEFycmF5LnByb3RvdHlwZSk7IC8vIFdlZXggcHJvdG8gZnJlZXplIHByb3RlY3Rpb24gd2FzIGhlcmUsXG4vLyBidXQgaXQgaXMgdW5jbGVhciB3aHkgdGhlIGhhY2sgaXMgbmVlZCBhcyBNb2JYIG5ldmVyIGNoYW5nZWQgdGhlIHByb3RvdHlwZVxuLy8gYW55d2F5LCBzbyByZW1vdmVkIGl0IGluIFY2XG5cbnZhciBMZWdhY3lPYnNlcnZhYmxlQXJyYXkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHViQXJyYXkpIHtcbiAgX2luaGVyaXRzTG9vc2UoTGVnYWN5T2JzZXJ2YWJsZUFycmF5LCBfU3R1YkFycmF5KTtcblxuICBmdW5jdGlvbiBMZWdhY3lPYnNlcnZhYmxlQXJyYXkoaW5pdGlhbFZhbHVlcywgZW5oYW5jZXIsIG5hbWUsIG93bmVkKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgbmFtZSA9ICBcIk9ic2VydmFibGVBcnJheUBcIiArIGdldE5leHRJZCgpIDtcbiAgICB9XG5cbiAgICBpZiAob3duZWQgPT09IHZvaWQgMCkge1xuICAgICAgb3duZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9TdHViQXJyYXkuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIHZhciBhZG0gPSBuZXcgT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24obmFtZSwgZW5oYW5jZXIsIG93bmVkLCB0cnVlKTtcbiAgICBhZG0ucHJveHlfID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyk7XG4gICAgYWRkSGlkZGVuRmluYWxQcm9wKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAkbW9ieCwgYWRtKTtcblxuICAgIGlmIChpbml0aWFsVmFsdWVzICYmIGluaXRpYWxWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgcHJldiA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQodHJ1ZSk7IC8vIEB0cy1pZ25vcmVcblxuICAgICAgX3RoaXMuc3BsaWNlV2l0aEFycmF5KDAsIDAsIGluaXRpYWxWYWx1ZXMpO1xuXG4gICAgICBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTGVnYWN5T2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KCkge1xuICAgIHRoaXNbJG1vYnhdLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJyYXlzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJyYXlzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KHRoaXMuc2xpY2UoKSwgLy9AdHMtaWdub3JlXG4gICAgYXJyYXlzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGlzT2JzZXJ2YWJsZUFycmF5KGEpID8gYS5zbGljZSgpIDogYTtcbiAgICB9KSk7XG4gIH07XG5cbiAgX3Byb3RvW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgIHJldHVybiBtYWtlSXRlcmFibGUoe1xuICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gbmV4dEluZGV4IDwgc2VsZi5sZW5ndGggPyB7XG4gICAgICAgICAgdmFsdWU6IHNlbGZbbmV4dEluZGV4KytdLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKExlZ2FjeU9ic2VydmFibGVBcnJheSwgW3tcbiAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uZ2V0QXJyYXlMZW5ndGhfKCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZW5ndGgpIHtcbiAgICAgIHRoaXNbJG1vYnhdLnNldEFycmF5TGVuZ3RoXyhuZXdMZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogU3ltYm9sLnRvU3RyaW5nVGFnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFwiQXJyYXlcIjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGVnYWN5T2JzZXJ2YWJsZUFycmF5O1xufShTdHViQXJyYXkpO1xuXG5PYmplY3QuZW50cmllcyhhcnJheUV4dGVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIHByb3AgPSBfcmVmWzBdLFxuICAgICAgZm4gPSBfcmVmWzFdO1xuICBpZiAocHJvcCAhPT0gXCJjb25jYXRcIikgYWRkSGlkZGVuUHJvcChMZWdhY3lPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlLCBwcm9wLCBmbik7XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlFbnRyeURlc2NyaXB0b3IoaW5kZXgpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1skbW9ieF0uZ2V0XyhpbmRleCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpc1skbW9ieF0uc2V0XyhpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlCdWZmZXJJdGVtKGluZGV4KSB7XG4gIGRlZmluZVByb3BlcnR5KExlZ2FjeU9ic2VydmFibGVBcnJheS5wcm90b3R5cGUsIFwiXCIgKyBpbmRleCwgY3JlYXRlQXJyYXlFbnRyeURlc2NyaXB0b3IoaW5kZXgpKTtcbn1cblxuZnVuY3Rpb24gcmVzZXJ2ZUFycmF5QnVmZmVyKG1heCkge1xuICBpZiAobWF4ID4gT0JTRVJWQUJMRV9BUlJBWV9CVUZGRVJfU0laRSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gT0JTRVJWQUJMRV9BUlJBWV9CVUZGRVJfU0laRTsgaW5kZXggPCBtYXggKyAxMDA7IGluZGV4KyspIHtcbiAgICAgIGNyZWF0ZUFycmF5QnVmZmVySXRlbShpbmRleCk7XG4gICAgfVxuXG4gICAgT0JTRVJWQUJMRV9BUlJBWV9CVUZGRVJfU0laRSA9IG1heDtcbiAgfVxufVxucmVzZXJ2ZUFycmF5QnVmZmVyKDEwMDApO1xuZnVuY3Rpb24gY3JlYXRlTGVnYWN5QXJyYXkoaW5pdGlhbFZhbHVlcywgZW5oYW5jZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBMZWdhY3lPYnNlcnZhYmxlQXJyYXkoaW5pdGlhbFZhbHVlcywgZW5oYW5jZXIsIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSkge1xuICBpZiAodHlwZW9mIHRoaW5nID09PSBcIm9iamVjdFwiICYmIHRoaW5nICE9PSBudWxsKSB7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KHRoaW5nKSkge1xuICAgICAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIGRpZSgyMyk7XG4gICAgICByZXR1cm4gdGhpbmdbJG1vYnhdLmF0b21fO1xuICAgIH1cblxuICAgIGlmIChpc09ic2VydmFibGVTZXQodGhpbmcpKSB7XG4gICAgICByZXR1cm4gdGhpbmdbJG1vYnhdO1xuICAgIH1cblxuICAgIGlmIChpc09ic2VydmFibGVNYXAodGhpbmcpKSB7XG4gICAgICBpZiAocHJvcGVydHkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaW5nLmtleXNBdG9tXztcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gdGhpbmcuZGF0YV8uZ2V0KHByb3BlcnR5KSB8fCB0aGluZy5oYXNNYXBfLmdldChwcm9wZXJ0eSk7XG4gICAgICBpZiAoIW9ic2VydmFibGUpIGRpZSgyNSwgcHJvcGVydHksIGdldERlYnVnTmFtZSh0aGluZykpO1xuICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh0aGluZykpIHtcbiAgICAgIGlmICghcHJvcGVydHkpIHJldHVybiBkaWUoMjYpO1xuXG4gICAgICB2YXIgX29ic2VydmFibGUgPSB0aGluZ1skbW9ieF0udmFsdWVzXy5nZXQocHJvcGVydHkpO1xuXG4gICAgICBpZiAoIV9vYnNlcnZhYmxlKSBkaWUoMjcsIHByb3BlcnR5LCBnZXREZWJ1Z05hbWUodGhpbmcpKTtcbiAgICAgIHJldHVybiBfb2JzZXJ2YWJsZTtcbiAgICB9XG5cbiAgICBpZiAoaXNBdG9tKHRoaW5nKSB8fCBpc0NvbXB1dGVkVmFsdWUodGhpbmcpIHx8IGlzUmVhY3Rpb24odGhpbmcpKSB7XG4gICAgICByZXR1cm4gdGhpbmc7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpbmcpKSB7XG4gICAgaWYgKGlzUmVhY3Rpb24odGhpbmdbJG1vYnhdKSkge1xuICAgICAgLy8gZGlzcG9zZXIgZnVuY3Rpb25cbiAgICAgIHJldHVybiB0aGluZ1skbW9ieF07XG4gICAgfVxuICB9XG5cbiAgZGllKDI4KTtcbn1cbmZ1bmN0aW9uIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wZXJ0eSkge1xuICBpZiAoIXRoaW5nKSBkaWUoMjkpO1xuICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKGdldEF0b20odGhpbmcsIHByb3BlcnR5KSk7XG4gIGlmIChpc0F0b20odGhpbmcpIHx8IGlzQ29tcHV0ZWRWYWx1ZSh0aGluZykgfHwgaXNSZWFjdGlvbih0aGluZykpIHJldHVybiB0aGluZztcbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0aGluZykgfHwgaXNPYnNlcnZhYmxlU2V0KHRoaW5nKSkgcmV0dXJuIHRoaW5nO1xuICBpZiAodGhpbmdbJG1vYnhdKSByZXR1cm4gdGhpbmdbJG1vYnhdO1xuICBkaWUoMjQsIHRoaW5nKTtcbn1cbmZ1bmN0aW9uIGdldERlYnVnTmFtZSh0aGluZywgcHJvcGVydHkpIHtcbiAgdmFyIG5hbWVkO1xuXG4gIGlmIChwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbmFtZWQgPSBnZXRBdG9tKHRoaW5nLCBwcm9wZXJ0eSk7XG4gIH0gZWxzZSBpZiAoaXNBY3Rpb24odGhpbmcpKSB7XG4gICAgcmV0dXJuIHRoaW5nLm5hbWU7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSB8fCBpc09ic2VydmFibGVNYXAodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZVNldCh0aGluZykpIHtcbiAgICBuYW1lZCA9IGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB2YWxpZCBmb3IgYXJyYXlzIGFzIHdlbGxcbiAgICBuYW1lZCA9IGdldEF0b20odGhpbmcpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVkLm5hbWVfO1xufVxuXG52YXIgdG9TdHJpbmcgPSBvYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYiwgZGVwdGgpIHtcbiAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICBkZXB0aCA9IC0xO1xuICB9XG5cbiAgcmV0dXJuIGVxKGEsIGIsIGRlcHRoKTtcbn0gLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL2Jsb2IvNWMyMzdhN2M2ODJmYjY4ZmQ1Mzc4MjAzZjBiZjIyZGNlMTYyNDg1NC91bmRlcnNjb3JlLmpzI0wxMTg2LUwxMjg5XG4vLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuXG5mdW5jdGlvbiBlcShhLCBiLCBkZXB0aCwgYVN0YWNrLCBiU3RhY2spIHtcbiAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjsgLy8gYG51bGxgIG9yIGB1bmRlZmluZWRgIG9ubHkgZXF1YWwgdG8gaXRzZWxmIChzdHJpY3QgY29tcGFyaXNvbikuXG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTsgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cblxuICBpZiAoYSAhPT0gYSkgcmV0dXJuIGIgIT09IGI7IC8vIEV4aGF1c3QgcHJpbWl0aXZlIGNoZWNrc1xuXG4gIHZhciB0eXBlID0gdHlwZW9mIGE7XG4gIGlmICghaXNGdW5jdGlvbih0eXBlKSAmJiB0eXBlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBiICE9IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTsgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cblxuICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgY2FzZSBcIltvYmplY3QgUmVnRXhwXVwiOiAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuXG4gICAgY2FzZSBcIltvYmplY3QgU3RyaW5nXVwiOlxuICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgIHJldHVybiBcIlwiICsgYSA9PT0gXCJcIiArIGI7XG5cbiAgICBjYXNlIFwiW29iamVjdCBOdW1iZXJdXCI6XG4gICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU4uXG4gICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiOyAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuXG4gICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuXG4gICAgY2FzZSBcIltvYmplY3QgRGF0ZV1cIjpcbiAgICBjYXNlIFwiW29iamVjdCBCb29sZWFuXVwiOlxuICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgcmV0dXJuICthID09PSArYjtcblxuICAgIGNhc2UgXCJbb2JqZWN0IFN5bWJvbF1cIjpcbiAgICAgIHJldHVybiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC52YWx1ZU9mLmNhbGwoYSkgPT09IFN5bWJvbC52YWx1ZU9mLmNhbGwoYik7XG5cbiAgICBjYXNlIFwiW29iamVjdCBNYXBdXCI6XG4gICAgY2FzZSBcIltvYmplY3QgU2V0XVwiOlxuICAgICAgLy8gTWFwcyBhbmQgU2V0cyBhcmUgdW53cmFwcGVkIHRvIGFycmF5cyBvZiBlbnRyeS1wYWlycywgYWRkaW5nIGFuIGluY2lkZW50YWwgbGV2ZWwuXG4gICAgICAvLyBIaWRlIHRoaXMgZXh0cmEgbGV2ZWwgYnkgaW5jcmVhc2luZyB0aGUgZGVwdGguXG4gICAgICBpZiAoZGVwdGggPj0gMCkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfSAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cblxuXG4gIGEgPSB1bndyYXAoYSk7XG4gIGIgPSB1bndyYXAoYik7XG4gIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09IFwiW29iamVjdCBBcnJheV1cIjtcblxuICBpZiAoIWFyZUFycmF5cykge1xuICAgIGlmICh0eXBlb2YgYSAhPSBcIm9iamVjdFwiIHx8IHR5cGVvZiBiICE9IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTsgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cblxuICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsXG4gICAgICAgIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShpc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmIGlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpICYmIFwiY29uc3RydWN0b3JcIiBpbiBhICYmIFwiY29uc3RydWN0b3JcIiBpbiBiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGRlcHRoIDwgMCkge1xuICAgIGRlcHRoID0gLTE7XG4gIH0gLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG5cblxuICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XG4gIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICB9IC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cblxuXG4gIGFTdGFjay5wdXNoKGEpO1xuICBiU3RhY2sucHVzaChiKTsgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG5cbiAgaWYgKGFyZUFycmF5cykge1xuICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7IC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGRlcHRoIC0gMSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgdmFyIGtleTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDsgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuXG4gICAgaWYgKE9iamVjdC5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgaWYgKCEoaGFzUHJvcChiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBkZXB0aCAtIDEsIGFTdGFjaywgYlN0YWNrKSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG5cblxuICBhU3RhY2sucG9wKCk7XG4gIGJTdGFjay5wb3AoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHVud3JhcChhKSB7XG4gIGlmIChpc09ic2VydmFibGVBcnJheShhKSkgcmV0dXJuIGEuc2xpY2UoKTtcbiAgaWYgKGlzRVM2TWFwKGEpIHx8IGlzT2JzZXJ2YWJsZU1hcChhKSkgcmV0dXJuIEFycmF5LmZyb20oYS5lbnRyaWVzKCkpO1xuICBpZiAoaXNFUzZTZXQoYSkgfHwgaXNPYnNlcnZhYmxlU2V0KGEpKSByZXR1cm4gQXJyYXkuZnJvbShhLmVudHJpZXMoKSk7XG4gIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBtYWtlSXRlcmFibGUoaXRlcmF0b3IpIHtcbiAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGdldFNlbGY7XG4gIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZigpIHtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGlzQW5ub3RhdGlvbih0aGluZykge1xuICByZXR1cm4gKC8vIENhbiBiZSBmdW5jdGlvblxuICAgIHRoaW5nIGluc3RhbmNlb2YgT2JqZWN0ICYmIHR5cGVvZiB0aGluZy5hbm5vdGF0aW9uVHlwZV8gPT09IFwic3RyaW5nXCIgJiYgaXNGdW5jdGlvbih0aGluZy5tYWtlXykgJiYgaXNGdW5jdGlvbih0aGluZy5leHRlbmRfKVxuICApO1xufVxuXG4vKipcclxuICogKGMpIE1pY2hlbCBXZXN0c3RyYXRlIDIwMTUgLSAyMDIwXHJcbiAqIE1JVCBMaWNlbnNlZFxyXG4gKlxyXG4gKiBXZWxjb21lIHRvIHRoZSBtb2J4IHNvdXJjZXMhIFRvIGdldCBhbiBnbG9iYWwgb3ZlcnZpZXcgb2YgaG93IE1vYlggaW50ZXJuYWxseSB3b3JrcyxcclxuICogdGhpcyBpcyBhIGdvb2QgcGxhY2UgdG8gc3RhcnQ6XHJcbiAqIGh0dHBzOi8vbWVkaXVtLmNvbS9AbXdlc3RzdHJhdGUvYmVjb21pbmctZnVsbHktcmVhY3RpdmUtYW4taW4tZGVwdGgtZXhwbGFuYXRpb24tb2YtbW9ic2VydmFibGUtNTU5OTUyNjJhMjU0Iy54dmJoNnFkNzRcclxuICpcclxuICogU291cmNlIGZvbGRlcnM6XHJcbiAqID09PT09PT09PT09PT09PVxyXG4gKlxyXG4gKiAtIGFwaS8gICAgIE1vc3Qgb2YgdGhlIHB1YmxpYyBzdGF0aWMgbWV0aG9kcyBleHBvc2VkIGJ5IHRoZSBtb2R1bGUgY2FuIGJlIGZvdW5kIGhlcmUuXHJcbiAqIC0gY29yZS8gICAgSW1wbGVtZW50YXRpb24gb2YgdGhlIE1vYlggYWxnb3JpdGhtOyBhdG9tcywgZGVyaXZhdGlvbnMsIHJlYWN0aW9ucywgZGVwZW5kZW5jeSB0cmVlcywgb3B0aW1pemF0aW9ucy4gQ29vbCBzdHVmZiBjYW4gYmUgZm91bmQgaGVyZS5cclxuICogLSB0eXBlcy8gICBBbGwgdGhlIG1hZ2ljIHRoYXQgaXMgbmVlZCB0byBoYXZlIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCB2YWx1ZXMgaXMgaW4gdGhpcyBmb2xkZXIuIEluY2x1ZGluZyB0aGUgbW9kaWZpZXJzIGxpa2UgYGFzRmxhdGAuXHJcbiAqIC0gdXRpbHMvICAgVXRpbGl0eSBzdHVmZi5cclxuICpcclxuICovXG5bXCJTeW1ib2xcIiwgXCJNYXBcIiwgXCJTZXRcIl0uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICB2YXIgZyA9IGdldEdsb2JhbCgpO1xuXG4gIGlmICh0eXBlb2YgZ1ttXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGRpZShcIk1vYlggcmVxdWlyZXMgZ2xvYmFsICdcIiArIG0gKyBcIicgdG8gYmUgYXZhaWxhYmxlIG9yIHBvbHlmaWxsZWRcIik7XG4gIH1cbn0pO1xuXG5pZiAodHlwZW9mIF9fTU9CWF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSBcIm9iamVjdFwiKSB7XG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FuZHlrb2cvbW9ieC1kZXZ0b29scy9cbiAgX19NT0JYX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0TW9ieCh7XG4gICAgc3B5OiBzcHksXG4gICAgZXh0cmFzOiB7XG4gICAgICBnZXREZWJ1Z05hbWU6IGdldERlYnVnTmFtZVxuICAgIH0sXG4gICAgJG1vYng6ICRtb2J4XG4gIH0pO1xufVxuXG5leHBvcnRzLiRtb2J4ID0gJG1vYng7XG5leHBvcnRzLkZsb3dDYW5jZWxsYXRpb25FcnJvciA9IEZsb3dDYW5jZWxsYXRpb25FcnJvcjtcbmV4cG9ydHMuT2JzZXJ2YWJsZU1hcCA9IE9ic2VydmFibGVNYXA7XG5leHBvcnRzLk9ic2VydmFibGVTZXQgPSBPYnNlcnZhYmxlU2V0O1xuZXhwb3J0cy5SZWFjdGlvbiA9IFJlYWN0aW9uO1xuZXhwb3J0cy5fYWxsb3dTdGF0ZUNoYW5nZXMgPSBhbGxvd1N0YXRlQ2hhbmdlcztcbmV4cG9ydHMuX2FsbG93U3RhdGVDaGFuZ2VzSW5zaWRlQ29tcHV0ZWQgPSBydW5JbkFjdGlvbjtcbmV4cG9ydHMuX2FsbG93U3RhdGVSZWFkc0VuZCA9IGFsbG93U3RhdGVSZWFkc0VuZDtcbmV4cG9ydHMuX2FsbG93U3RhdGVSZWFkc1N0YXJ0ID0gYWxsb3dTdGF0ZVJlYWRzU3RhcnQ7XG5leHBvcnRzLl9hdXRvQWN0aW9uID0gYXV0b0FjdGlvbjtcbmV4cG9ydHMuX2VuZEFjdGlvbiA9IF9lbmRBY3Rpb247XG5leHBvcnRzLl9nZXRBZG1pbmlzdHJhdGlvbiA9IGdldEFkbWluaXN0cmF0aW9uO1xuZXhwb3J0cy5fZ2V0R2xvYmFsU3RhdGUgPSBnZXRHbG9iYWxTdGF0ZTtcbmV4cG9ydHMuX2ludGVyY2VwdFJlYWRzID0gaW50ZXJjZXB0UmVhZHM7XG5leHBvcnRzLl9pc0NvbXB1dGluZ0Rlcml2YXRpb24gPSBpc0NvbXB1dGluZ0Rlcml2YXRpb247XG5leHBvcnRzLl9yZXNldEdsb2JhbFN0YXRlID0gcmVzZXRHbG9iYWxTdGF0ZTtcbmV4cG9ydHMuX3N0YXJ0QWN0aW9uID0gX3N0YXJ0QWN0aW9uO1xuZXhwb3J0cy5hY3Rpb24gPSBhY3Rpb247XG5leHBvcnRzLmF1dG9ydW4gPSBhdXRvcnVuO1xuZXhwb3J0cy5jb21wYXJlciA9IGNvbXBhcmVyO1xuZXhwb3J0cy5jb21wdXRlZCA9IGNvbXB1dGVkO1xuZXhwb3J0cy5jb25maWd1cmUgPSBjb25maWd1cmU7XG5leHBvcnRzLmNyZWF0ZUF0b20gPSBjcmVhdGVBdG9tO1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0eSA9IGFwaURlZmluZVByb3BlcnR5O1xuZXhwb3J0cy5lbnRyaWVzID0gZW50cmllcztcbmV4cG9ydHMuZXh0ZW5kT2JzZXJ2YWJsZSA9IGV4dGVuZE9ic2VydmFibGU7XG5leHBvcnRzLmZsb3cgPSBmbG93O1xuZXhwb3J0cy5mbG93UmVzdWx0ID0gZmxvd1Jlc3VsdDtcbmV4cG9ydHMuZ2V0ID0gZ2V0O1xuZXhwb3J0cy5nZXRBdG9tID0gZ2V0QXRvbTtcbmV4cG9ydHMuZ2V0RGVidWdOYW1lID0gZ2V0RGVidWdOYW1lO1xuZXhwb3J0cy5nZXREZXBlbmRlbmN5VHJlZSA9IGdldERlcGVuZGVuY3lUcmVlO1xuZXhwb3J0cy5nZXRPYnNlcnZlclRyZWUgPSBnZXRPYnNlcnZlclRyZWU7XG5leHBvcnRzLmhhcyA9IGhhcztcbmV4cG9ydHMuaW50ZXJjZXB0ID0gaW50ZXJjZXB0O1xuZXhwb3J0cy5pc0FjdGlvbiA9IGlzQWN0aW9uO1xuZXhwb3J0cy5pc0JveGVkT2JzZXJ2YWJsZSA9IGlzT2JzZXJ2YWJsZVZhbHVlO1xuZXhwb3J0cy5pc0NvbXB1dGVkID0gaXNDb21wdXRlZDtcbmV4cG9ydHMuaXNDb21wdXRlZFByb3AgPSBpc0NvbXB1dGVkUHJvcDtcbmV4cG9ydHMuaXNGbG93ID0gaXNGbG93O1xuZXhwb3J0cy5pc0Zsb3dDYW5jZWxsYXRpb25FcnJvciA9IGlzRmxvd0NhbmNlbGxhdGlvbkVycm9yO1xuZXhwb3J0cy5pc09ic2VydmFibGUgPSBpc09ic2VydmFibGU7XG5leHBvcnRzLmlzT2JzZXJ2YWJsZUFycmF5ID0gaXNPYnNlcnZhYmxlQXJyYXk7XG5leHBvcnRzLmlzT2JzZXJ2YWJsZU1hcCA9IGlzT2JzZXJ2YWJsZU1hcDtcbmV4cG9ydHMuaXNPYnNlcnZhYmxlT2JqZWN0ID0gaXNPYnNlcnZhYmxlT2JqZWN0O1xuZXhwb3J0cy5pc09ic2VydmFibGVQcm9wID0gaXNPYnNlcnZhYmxlUHJvcDtcbmV4cG9ydHMuaXNPYnNlcnZhYmxlU2V0ID0gaXNPYnNlcnZhYmxlU2V0O1xuZXhwb3J0cy5rZXlzID0ga2V5cztcbmV4cG9ydHMubWFrZUF1dG9PYnNlcnZhYmxlID0gbWFrZUF1dG9PYnNlcnZhYmxlO1xuZXhwb3J0cy5tYWtlT2JzZXJ2YWJsZSA9IG1ha2VPYnNlcnZhYmxlO1xuZXhwb3J0cy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbmV4cG9ydHMub2JzZXJ2ZSA9IG9ic2VydmU7XG5leHBvcnRzLm9uQmVjb21lT2JzZXJ2ZWQgPSBvbkJlY29tZU9ic2VydmVkO1xuZXhwb3J0cy5vbkJlY29tZVVub2JzZXJ2ZWQgPSBvbkJlY29tZVVub2JzZXJ2ZWQ7XG5leHBvcnRzLm9uUmVhY3Rpb25FcnJvciA9IG9uUmVhY3Rpb25FcnJvcjtcbmV4cG9ydHMub3ZlcnJpZGUgPSBvdmVycmlkZTtcbmV4cG9ydHMub3duS2V5cyA9IGFwaU93bktleXM7XG5leHBvcnRzLnJlYWN0aW9uID0gcmVhY3Rpb247XG5leHBvcnRzLnJlbW92ZSA9IHJlbW92ZTtcbmV4cG9ydHMucnVuSW5BY3Rpb24gPSBydW5JbkFjdGlvbjtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5zcHkgPSBzcHk7XG5leHBvcnRzLnRvSlMgPSB0b0pTO1xuZXhwb3J0cy50cmFjZSA9IHRyYWNlO1xuZXhwb3J0cy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuZXhwb3J0cy51bnRyYWNrZWQgPSB1bnRyYWNrZWQ7XG5leHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcbmV4cG9ydHMud2hlbiA9IHdoZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2J4LmNqcy5kZXZlbG9wbWVudC5qcy5tYXBcbiIsImZ1bmN0aW9uIHQodCl7Zm9yKHZhciBuPWFyZ3VtZW50cy5sZW5ndGgsaT1uZXcgQXJyYXkobj4xP24tMTowKSxyPTE7cjxuO3IrKylpW3ItMV09YXJndW1lbnRzW3JdO3Rocm93IG5ldyBFcnJvcihcIm51bWJlclwiPT10eXBlb2YgdD9cIltNb2JYXSBtaW5pZmllZCBlcnJvciBucjogXCIrdCsoaS5sZW5ndGg/XCIgXCIraS5tYXAoU3RyaW5nKS5qb2luKFwiLFwiKTpcIlwiKStcIi4gRmluZCB0aGUgZnVsbCBlcnJvciBhdDogaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L2Jsb2IvbWFpbi9wYWNrYWdlcy9tb2J4L3NyYy9lcnJvcnMudHNcIjpcIltNb2JYXSBcIit0KX1mdW5jdGlvbiBuKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnhufWZ1bmN0aW9uIGkoKXtWbnx8dChcIlByb3h5IG5vdCBhdmFpbGFibGVcIil9ZnVuY3Rpb24gcih0KXt2YXIgbj0hMTtyZXR1cm4gZnVuY3Rpb24oKXtpZighbilyZXR1cm4gbj0hMCx0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX19ZnVuY3Rpb24gZSh0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIG8odCl7c3dpdGNoKHR5cGVvZiB0KXtjYXNlXCJzdHJpbmdcIjpjYXNlXCJzeW1ib2xcIjpjYXNlXCJudW1iZXJcIjpyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiB1KHQpe3JldHVybiBudWxsIT09dCYmXCJvYmplY3RcIj09dHlwZW9mIHR9ZnVuY3Rpb24gcyh0KXt2YXIgbjtpZighdSh0KSlyZXR1cm4hMTt2YXIgaT1PYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7cmV0dXJuIG51bGw9PWl8fChudWxsPT0obj1pLmNvbnN0cnVjdG9yKT92b2lkIDA6bi50b1N0cmluZygpKT09PU5ufWZ1bmN0aW9uIGYodCl7dmFyIG49bnVsbD09dD92b2lkIDA6dC5jb25zdHJ1Y3RvcjtyZXR1cm4hIW4mJihcIkdlbmVyYXRvckZ1bmN0aW9uXCI9PT1uLm5hbWV8fFwiR2VuZXJhdG9yRnVuY3Rpb25cIj09PW4uZGlzcGxheU5hbWUpfWZ1bmN0aW9uIGEodCxuLGkpe2duKHQsbix7ZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITAsdmFsdWU6aX0pfWZ1bmN0aW9uIGModCxuLGkpe2duKHQsbix7ZW51bWVyYWJsZTohMSx3cml0YWJsZTohMSxjb25maWd1cmFibGU6ITAsdmFsdWU6aX0pfWZ1bmN0aW9uIGgodCxuKXt2YXIgaT1cImlzTW9iWFwiK3Q7cmV0dXJuIG4ucHJvdG90eXBlW2ldPSEwLGZ1bmN0aW9uKHQpe3JldHVybiB1KHQpJiYhMD09PXRbaV19fWZ1bmN0aW9uIHYodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBNYXB9ZnVuY3Rpb24gbCh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFNldH1mdW5jdGlvbiBkKHQpe3JldHVybiBudWxsPT09dD9udWxsOlwib2JqZWN0XCI9PXR5cGVvZiB0P1wiXCIrdDp0fWZ1bmN0aW9uIGIodCxuKXtyZXR1cm4gX24uaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pfWZ1bmN0aW9uIHAodCxuKXtmb3IodmFyIGk9MDtpPG4ubGVuZ3RoO2krKyl7dmFyIHI9bltpXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsci5rZXkscil9fWZ1bmN0aW9uIHkodCxuLGkpe3JldHVybiBuJiZwKHQucHJvdG90eXBlLG4pLGkmJnAodCxpKSx0fWZ1bmN0aW9uIG0oKXtyZXR1cm4obT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXt2YXIgaT1hcmd1bWVudHNbbl07Zm9yKHZhciByIGluIGkpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGkscikmJih0W3JdPWlbcl0pfXJldHVybiB0fSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIHcodCxuKXt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKG4ucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10LHQuX19wcm90b19fPW59ZnVuY3Rpb24gaih0KXtpZih2b2lkIDA9PT10KXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gdH1mdW5jdGlvbiB4KHQsbil7KG51bGw9PW58fG4+dC5sZW5ndGgpJiYobj10Lmxlbmd0aCk7Zm9yKHZhciBpPTAscj1uZXcgQXJyYXkobik7aTxuO2krKylyW2ldPXRbaV07cmV0dXJuIHJ9ZnVuY3Rpb24gTyh0LG4pe3ZhciBpO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBTeW1ib2x8fG51bGw9PXRbU3ltYm9sLml0ZXJhdG9yXSl7aWYoQXJyYXkuaXNBcnJheSh0KXx8KGk9ZnVuY3Rpb24odCl7aWYodCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIHgodCx2b2lkIDApO3ZhciBuPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KS5zbGljZSg4LC0xKTtyZXR1cm5cIk9iamVjdFwiPT09biYmdC5jb25zdHJ1Y3RvciYmKG49dC5jb25zdHJ1Y3Rvci5uYW1lKSxcIk1hcFwiPT09bnx8XCJTZXRcIj09PW4/QXJyYXkuZnJvbSh0KTpcIkFyZ3VtZW50c1wiPT09bnx8L14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3Qobik/eCh0LHZvaWQgMCk6dm9pZCAwfX0odCkpfHxuJiZ0JiZcIm51bWJlclwiPT10eXBlb2YgdC5sZW5ndGgpe2kmJih0PWkpO3ZhciByPTA7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHI+PXQubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTp0W3IrK119fX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9cmV0dXJuKGk9dFtTeW1ib2wuaXRlcmF0b3JdKCkpLm5leHQuYmluZChpKX1mdW5jdGlvbiBBKHQpe3JldHVybiBPYmplY3QuYXNzaWduKChmdW5jdGlvbihuLGkpe2cobixpLHQpfSksdCl9ZnVuY3Rpb24gZyh0LG4saSl7Yih0LENuKXx8YSh0LENuLG0oe30sdFtDbl0pKSxmdW5jdGlvbih0KXtyZXR1cm5cIm92ZXJyaWRlXCI9PT10LnR9KGkpfHwodFtDbl1bbl09aSl9ZnVuY3Rpb24gXyh0LG4saSl7dm9pZCAwPT09biYmKG49Um4pLHZvaWQgMD09PWkmJihpPVJuKTt2YXIgcj1uZXcgTG4odCk7cmV0dXJuIG4hPT1SbiYmU3QocixuKSxpIT09Um4mJk10KHIsaSkscn1mdW5jdGlvbiBTKHQsbixpKXtyZXR1cm4gSXQodCk/dDpBcnJheS5pc0FycmF5KHQpPyRuLmFycmF5KHQse25hbWU6aX0pOnModCk/JG4ub2JqZWN0KHQsdm9pZCAwLHtuYW1lOml9KTp2KHQpPyRuLm1hcCh0LHtuYW1lOml9KTpsKHQpPyRuLnNldCh0LHtuYW1lOml9KTpcImZ1bmN0aW9uXCIhPXR5cGVvZiB0fHxBdCh0KXx8Q3QodCk/dDpmKHQpP1JpKHQpOl9pKGksdCl9ZnVuY3Rpb24gTSh0KXtyZXR1cm4gdH1mdW5jdGlvbiBWKHQsbil7cmV0dXJue3Q6dCxpOm4sbzpOLHU6Un19ZnVuY3Rpb24gTih0LG4saSxyKXt2YXIgZTtpZihudWxsPT0oZT10aGlzLmkpP3ZvaWQgMDplLmJvdW5kKXJldHVybiBudWxsPT09dGhpcy51KHQsbixpLCExKT8wOjE7aWYocj09PXQucylyZXR1cm4gbnVsbD09PXRoaXMudSh0LG4saSwhMSk/MDoyO2lmKEF0KGkudmFsdWUpKXJldHVybiAxO3ZhciBvPWsodCx0aGlzLG4saSwhMSk7cmV0dXJuIGduKHIsbixvKSwyfWZ1bmN0aW9uIFIodCxuLGkscil7dmFyIGU9ayh0LHRoaXMsbixpKTtyZXR1cm4gdC5oKG4sZSxyKX1mdW5jdGlvbiBrKHQsbixpLHIsZSl7dmFyIG8sdSxzLGYsYTt2b2lkIDA9PT1lJiYoZT1waS5zYWZlRGVzY3JpcHRvcnMpO3ZhciBjLGg9ci52YWx1ZTtyZXR1cm4obnVsbD09KG89bi5pKT92b2lkIDA6by5ib3VuZCkmJihoPWguYmluZChudWxsIT0oYz10LnYpP2M6dC5zKSkse3ZhbHVlOnoobnVsbCE9KHU9bnVsbD09KHM9bi5pKT92b2lkIDA6cy5uYW1lKT91OmkudG9TdHJpbmcoKSxoLG51bGwhPShmPW51bGw9PShhPW4uaSk/dm9pZCAwOmEuYXV0b0FjdGlvbikmJmYpLGNvbmZpZ3VyYWJsZTohZXx8dC5sLGVudW1lcmFibGU6ITEsd3JpdGFibGU6IWV9fWZ1bmN0aW9uIEUodCxuKXtyZXR1cm57dDp0LGk6bixvOlQsdTpDfX1mdW5jdGlvbiBUKHQsbixpLHIpe3ZhciBlO2lmKHI9PT10LnMpcmV0dXJuIG51bGw9PT10aGlzLnUodCxuLGksITEpPzA6MjtpZigobnVsbD09KGU9dGhpcy5pKT92b2lkIDA6ZS5ib3VuZCkmJiFDdCh0LnNbbl0pJiZudWxsPT09dGhpcy51KHQsbixpLCExKSlyZXR1cm4gMDtpZihDdChpLnZhbHVlKSlyZXR1cm4gMTt2YXIgbz1LKHQsMCwwLGksITEsITEpO3JldHVybiBnbihyLG4sbyksMn1mdW5jdGlvbiBDKHQsbixpLHIpe3ZhciBlLG89Syh0LDAsMCxpLG51bGw9PShlPXRoaXMuaSk/dm9pZCAwOmUuYm91bmQpO3JldHVybiB0LmgobixvLHIpfWZ1bmN0aW9uIEsodCxuLGkscixlLG8pe3ZvaWQgMD09PW8mJihvPXBpLnNhZmVEZXNjcmlwdG9ycyk7dmFyIHUscz1yLnZhbHVlO3JldHVybiBlJiYocz1zLmJpbmQobnVsbCE9KHU9dC52KT91OnQucykpLHt2YWx1ZTpSaShzKSxjb25maWd1cmFibGU6IW98fHQubCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiFvfX1mdW5jdGlvbiBMKHQsbil7cmV0dXJue3Q6dCxpOm4sbzpJLHU6UH19ZnVuY3Rpb24gSSh0LG4saSl7cmV0dXJuIG51bGw9PT10aGlzLnUodCxuLGksITEpPzA6MX1mdW5jdGlvbiBQKHQsbixpLHIpe3JldHVybiB0LnAobixtKHt9LHRoaXMuaSx7Z2V0OmkuZ2V0LHNldDppLnNldH0pLHIpfWZ1bmN0aW9uIEQodCxuKXtyZXR1cm57dDp0LGk6bixvOkIsdTpxfX1mdW5jdGlvbiBCKHQsbixpKXtyZXR1cm4gbnVsbD09PXRoaXMudSh0LG4saSwhMSk/MDoxfWZ1bmN0aW9uIHEodCxuLGkscil7dmFyIGUsbztyZXR1cm4gdC5tKG4saS52YWx1ZSxudWxsIT0oZT1udWxsPT0obz10aGlzLmkpP3ZvaWQgMDpvLmVuaGFuY2VyKT9lOlMscil9ZnVuY3Rpb24gRyh0KXtyZXR1cm57dDpcInRydWVcIixpOnQsbzpYLHU6V319ZnVuY3Rpb24gWCh0LG4saSxyKXt2YXIgZSxvLHUscztpZihpLmdldClyZXR1cm4gUW4ubyh0LG4saSxyKTtpZihpLnNldCl7dmFyIGE9eihuLnRvU3RyaW5nKCksaS5zZXQpO3JldHVybiByPT09dC5zP251bGw9PT10Lmgobix7Y29uZmlndXJhYmxlOiFwaS5zYWZlRGVzY3JpcHRvcnN8fHQubCxzZXQ6YX0pPzA6MjooZ24ocixuLHtjb25maWd1cmFibGU6ITAsc2V0OmF9KSwyKX1pZihyIT09dC5zJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBpLnZhbHVlKXJldHVybiBmKGkudmFsdWUpPygobnVsbD09KHM9dGhpcy5pKT92b2lkIDA6cy5hdXRvQmluZCk/UmkuYm91bmQ6UmkpLm8odCxuLGkscik6KChudWxsPT0odT10aGlzLmkpP3ZvaWQgMDp1LmF1dG9CaW5kKT9faS5ib3VuZDpfaSkubyh0LG4saSxyKTt2YXIgYyxoPSExPT09KG51bGw9PShlPXRoaXMuaSk/dm9pZCAwOmUuZGVlcCk/JG4ucmVmOiRuO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGkudmFsdWUmJihudWxsPT0obz10aGlzLmkpP3ZvaWQgMDpvLmF1dG9CaW5kKSYmKGkudmFsdWU9aS52YWx1ZS5iaW5kKG51bGwhPShjPXQudik/Yzp0LnMpKSxoLm8odCxuLGkscil9ZnVuY3Rpb24gVyh0LG4saSxyKXt2YXIgZSxvLHU7cmV0dXJuIGkuZ2V0P1FuLnUodCxuLGkscik6aS5zZXQ/dC5oKG4se2NvbmZpZ3VyYWJsZTohcGkuc2FmZURlc2NyaXB0b3JzfHx0Lmwsc2V0Onoobi50b1N0cmluZygpLGkuc2V0KX0scik6KFwiZnVuY3Rpb25cIj09dHlwZW9mIGkudmFsdWUmJihudWxsPT0oZT10aGlzLmkpP3ZvaWQgMDplLmF1dG9CaW5kKSYmKGkudmFsdWU9aS52YWx1ZS5iaW5kKG51bGwhPSh1PXQudik/dTp0LnMpKSwoITE9PT0obnVsbD09KG89dGhpcy5pKT92b2lkIDA6by5kZWVwKT8kbi5yZWY6JG4pLnUodCxuLGkscikpfWZ1bmN0aW9uIEgodCl7cmV0dXJuIHR8fHFufWZ1bmN0aW9uIFUodCl7cmV0dXJuITA9PT10LmRlZXA/UzohMT09PXQuZGVlcD9NOihuPXQuZGVmYXVsdERlY29yYXRvcikmJm51bGwhPShpPW51bGw9PShyPW4uaSk/dm9pZCAwOnIuZW5oYW5jZXIpP2k6Uzt2YXIgbixpLHJ9ZnVuY3Rpb24gRih0LG4saSl7aWYoIW8obikpcmV0dXJuIEl0KHQpP3Q6cyh0KT8kbi5vYmplY3QodCxuLGkpOkFycmF5LmlzQXJyYXkodCk/JG4uYXJyYXkodCxuKTp2KHQpPyRuLm1hcCh0LG4pOmwodCk/JG4uc2V0KHQsbik6XCJvYmplY3RcIj09dHlwZW9mIHQmJm51bGwhPT10P3Q6JG4uYm94KHQsbik7Zyh0LG4sR24pfWZ1bmN0aW9uIHoodCxuLGkscil7ZnVuY3Rpb24gZSgpe3JldHVybiAkKDAsaSxuLHJ8fHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gdm9pZCAwPT09aSYmKGk9ITEpLGUuaXNNb2J4QWN0aW9uPSEwLGlpJiYocmkudmFsdWU9dCxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIm5hbWVcIixyaSkpLGV9ZnVuY3Rpb24gJCh0LG4saSxyLGUpe3ZhciBvPUooMCxuKTt0cnl7cmV0dXJuIGkuYXBwbHkocixlKX1jYXRjaCh0KXt0aHJvdyBvLmo9dCx0fWZpbmFsbHl7WShvKX19ZnVuY3Rpb24gSih0LG4pe3ZhciBpPXBpLnRyYWNraW5nRGVyaXZhdGlvbixyPSFufHwhaTtkdCgpO3ZhciBlPXBpLmFsbG93U3RhdGVDaGFuZ2VzO3ImJih1dCgpLGU9WighMCkpO3ZhciBvPXtPOnIsQTppLGc6ZSxfOmZ0KCEwKSxTOiExLE06MCxWOm5pKyssTjp0aX07cmV0dXJuIHRpPW8uVixvfWZ1bmN0aW9uIFkobil7dGkhPT1uLlYmJnQoMzApLHRpPW4uTix2b2lkIDAhPT1uLmomJihwaS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzPSEwKSx0dChuLmcpLGF0KG4uXyksYnQoKSxuLk8mJnN0KG4uQSkscGkuc3VwcHJlc3NSZWFjdGlvbkVycm9ycz0hMX1mdW5jdGlvbiBRKHQsbil7dmFyIGk9Wih0KTt0cnl7cmV0dXJuIG4oKX1maW5hbGx5e3R0KGkpfX1mdW5jdGlvbiBaKHQpe3ZhciBuPXBpLmFsbG93U3RhdGVDaGFuZ2VzO3JldHVybiBwaS5hbGxvd1N0YXRlQ2hhbmdlcz10LG59ZnVuY3Rpb24gdHQodCl7cGkuYWxsb3dTdGF0ZUNoYW5nZXM9dH1mdW5jdGlvbiBudCh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGhpfWZ1bmN0aW9uIGl0KHQpe3N3aXRjaCh0LlIpe2Nhc2Ugc2kuazpyZXR1cm4hMTtjYXNlIHNpLlQ6Y2FzZSBzaS5DOnJldHVybiEwO2Nhc2Ugc2kuSzpmb3IodmFyIG49ZnQoITApLGk9dXQoKSxyPXQuTCxlPXIubGVuZ3RoLG89MDtvPGU7bysrKXt2YXIgdT1yW29dO2lmKGNpKHUpKXtpZihwaS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzKXUuZ2V0KCk7ZWxzZSB0cnl7dS5nZXQoKX1jYXRjaCh0KXtyZXR1cm4gc3QoaSksYXQobiksITB9aWYodC5SPT09c2kuQylyZXR1cm4gc3QoaSksYXQobiksITB9fXJldHVybiBjdCh0KSxzdChpKSxhdChuKSwhMX19ZnVuY3Rpb24gcnQodCxuLGkpe3ZhciByPWZ0KCEwKTtjdCh0KSx0Lkk9bmV3IEFycmF5KHQuTC5sZW5ndGgrMTAwKSx0LlA9MCx0LkQ9KytwaS5ydW5JZDt2YXIgZSxvPXBpLnRyYWNraW5nRGVyaXZhdGlvbjtpZihwaS50cmFja2luZ0Rlcml2YXRpb249dCxwaS5pbkJhdGNoKyssITA9PT1waS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzKWU9bi5jYWxsKGkpO2Vsc2UgdHJ5e2U9bi5jYWxsKGkpfWNhdGNoKHQpe2U9bmV3IGhpKHQpfXJldHVybiBwaS5pbkJhdGNoLS0scGkudHJhY2tpbmdEZXJpdmF0aW9uPW8sZnVuY3Rpb24odCl7Zm9yKHZhciBuPXQuTCxpPXQuTD10Lkkscj1zaS5rLGU9MCxvPXQuUCx1PTA7dTxvO3UrKyl7dmFyIHM9aVt1XTswPT09cy5CJiYocy5CPTEsZSE9PXUmJihpW2VdPXMpLGUrKykscy5SPnImJihyPXMuUil9Zm9yKGkubGVuZ3RoPWUsdC5JPW51bGwsbz1uLmxlbmd0aDtvLS07KXt2YXIgZj1uW29dOzA9PT1mLkImJnZ0KGYsdCksZi5CPTB9Zm9yKDtlLS07KXt2YXIgYT1pW2VdOzE9PT1hLkImJihhLkI9MCxodChhLHQpKX1yIT09c2kuayYmKHQuUj1yLHQucSgpKX0odCksYXQociksZX1mdW5jdGlvbiBldCh0KXt2YXIgbj10Lkw7dC5MPVtdO2Zvcih2YXIgaT1uLmxlbmd0aDtpLS07KXZ0KG5baV0sdCk7dC5SPXNpLlR9ZnVuY3Rpb24gb3QodCl7dmFyIG49dXQoKTt0cnl7cmV0dXJuIHQoKX1maW5hbGx5e3N0KG4pfX1mdW5jdGlvbiB1dCgpe3ZhciB0PXBpLnRyYWNraW5nRGVyaXZhdGlvbjtyZXR1cm4gcGkudHJhY2tpbmdEZXJpdmF0aW9uPW51bGwsdH1mdW5jdGlvbiBzdCh0KXtwaS50cmFja2luZ0Rlcml2YXRpb249dH1mdW5jdGlvbiBmdCh0KXt2YXIgbj1waS5hbGxvd1N0YXRlUmVhZHM7cmV0dXJuIHBpLmFsbG93U3RhdGVSZWFkcz10LG59ZnVuY3Rpb24gYXQodCl7cGkuYWxsb3dTdGF0ZVJlYWRzPXR9ZnVuY3Rpb24gY3QodCl7aWYodC5SIT09c2kuayl7dC5SPXNpLms7Zm9yKHZhciBuPXQuTCxpPW4ubGVuZ3RoO2ktLTspbltpXS5HPXNpLmt9fWZ1bmN0aW9uIGh0KHQsbil7dC5YLmFkZChuKSx0Lkc+bi5SJiYodC5HPW4uUil9ZnVuY3Rpb24gdnQodCxuKXt0LlguZGVsZXRlKG4pLDA9PT10Llguc2l6ZSYmbHQodCl9ZnVuY3Rpb24gbHQodCl7ITE9PT10LlcmJih0Llc9ITAscGkucGVuZGluZ1Vub2JzZXJ2YXRpb25zLnB1c2godCkpfWZ1bmN0aW9uIGR0KCl7cGkuaW5CYXRjaCsrfWZ1bmN0aW9uIGJ0KCl7aWYoMD09LS1waS5pbkJhdGNoKXttdCgpO2Zvcih2YXIgdD1waS5wZW5kaW5nVW5vYnNlcnZhdGlvbnMsbj0wO248dC5sZW5ndGg7bisrKXt2YXIgaT10W25dO2kuVz0hMSwwPT09aS5YLnNpemUmJihpLkgmJihpLkg9ITEsaS5vbkJVTygpKSxpIGluc3RhbmNlb2YgYWkmJmkuVSgpKX1waS5wZW5kaW5nVW5vYnNlcnZhdGlvbnM9W119fWZ1bmN0aW9uIHB0KHQpe3ZhciBuPXBpLnRyYWNraW5nRGVyaXZhdGlvbjtyZXR1cm4gbnVsbCE9PW4/KG4uRCE9PXQuRiYmKHQuRj1uLkQsbi5JW24uUCsrXT10LCF0LkgmJnBpLnRyYWNraW5nQ29udGV4dCYmKHQuSD0hMCx0Lm9uQk8oKSkpLCEwKTooMD09PXQuWC5zaXplJiZwaS5pbkJhdGNoPjAmJmx0KHQpLCExKX1mdW5jdGlvbiB5dCh0KXt0LkchPT1zaS5DJiYodC5HPXNpLkMsdC5YLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QuUj09PXNpLmsmJnQucSgpLHQuUj1zaS5DfSkpKX1mdW5jdGlvbiBtdCgpe3BpLmluQmF0Y2g+MHx8cGkuaXNSdW5uaW5nUmVhY3Rpb25zfHxtaSh3dCl9ZnVuY3Rpb24gd3QoKXtwaS5pc1J1bm5pbmdSZWFjdGlvbnM9ITA7Zm9yKHZhciB0PXBpLnBlbmRpbmdSZWFjdGlvbnMsbj0wO3QubGVuZ3RoPjA7KXsxMDA9PSsrbiYmKGNvbnNvbGUuZXJyb3IoXCJbbW9ieF0gY3ljbGUgaW4gcmVhY3Rpb246IFwiK3RbMF0pLHQuc3BsaWNlKDApKTtmb3IodmFyIGk9dC5zcGxpY2UoMCkscj0wLGU9aS5sZW5ndGg7cjxlO3IrKylpW3JdLiQoKX1waS5pc1J1bm5pbmdSZWFjdGlvbnM9ITF9ZnVuY3Rpb24ganQoKXtyZXR1cm4gY29uc29sZS53YXJuKFwiW21vYnguc3B5XSBJcyBhIG5vLW9wIGluIHByb2R1Y3Rpb24gYnVpbGRzXCIpLGZ1bmN0aW9uKCl7fX1mdW5jdGlvbiB4dCh0KXtyZXR1cm4gZnVuY3Rpb24obixpKXtyZXR1cm4gZShuKT96KG4ubmFtZXx8XCI8dW5uYW1lZCBhY3Rpb24+XCIsbix0KTplKGkpP3oobixpLHQpOm8oaSk/ZyhuLGksdD9PaTpqaSk6byhuKT9BKFYodD9cImF1dG9BY3Rpb25cIjpcImFjdGlvblwiLHtuYW1lOm4sYXV0b0FjdGlvbjp0fSkpOnZvaWQgMH19ZnVuY3Rpb24gT3QodCl7cmV0dXJuICQoMCwhMSx0LHRoaXMsdm9pZCAwKX1mdW5jdGlvbiBBdCh0KXtyZXR1cm4gZSh0KSYmITA9PT10LmlzTW9ieEFjdGlvbn1mdW5jdGlvbiBndCh0LG4pe2Z1bmN0aW9uIGkoKXt0KG8pfXZhciByLGU7dm9pZCAwPT09biYmKG49TW4pO3ZhciBvLHU9bnVsbCE9KHI9bnVsbD09KGU9bik/dm9pZCAwOmUubmFtZSk/cjpcIkF1dG9ydW5cIjtpZihuLnNjaGVkdWxlcnx8bi5kZWxheSl7dmFyIHM9X3QobiksZj0hMTtvPW5ldyB5aSh1LChmdW5jdGlvbigpe2Z8fChmPSEwLHMoKGZ1bmN0aW9uKCl7Zj0hMSxvLkp8fG8udHJhY2soaSl9KSkpfSksbi5vbkVycm9yLG4ucmVxdWlyZXNPYnNlcnZhYmxlKX1lbHNlIG89bmV3IHlpKHUsKGZ1bmN0aW9uKCl7dGhpcy50cmFjayhpKX0pLG4ub25FcnJvcixuLnJlcXVpcmVzT2JzZXJ2YWJsZSk7cmV0dXJuIG8uWSgpLG8uWigpfWZ1bmN0aW9uIF90KHQpe3JldHVybiB0LnNjaGVkdWxlcj90LnNjaGVkdWxlcjp0LmRlbGF5P2Z1bmN0aW9uKG4pe3JldHVybiBzZXRUaW1lb3V0KG4sdC5kZWxheSl9OlNpfWZ1bmN0aW9uIFN0KHQsbixpKXtyZXR1cm4gVnQoXCJvbkJPXCIsdCxuLGkpfWZ1bmN0aW9uIE10KHQsbixpKXtyZXR1cm4gVnQoXCJvbkJVT1wiLHQsbixpKX1mdW5jdGlvbiBWdCh0LG4saSxyKXt2YXIgbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByP2RuKG4saSk6ZG4obiksdT1lKHIpP3I6aSxzPXQrXCJMXCI7cmV0dXJuIG9bc10/b1tzXS5hZGQodSk6b1tzXT1uZXcgU2V0KFt1XSksZnVuY3Rpb24oKXt2YXIgdD1vW3NdO3QmJih0LmRlbGV0ZSh1KSwwPT09dC5zaXplJiZkZWxldGUgb1tzXSl9fWZ1bmN0aW9uIE50KHQsbixpLHIpe3ZhciBlPVRuKG4pLG89c24odCxyKVtLbl07ZHQoKTt0cnl7RW4oZSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7by51KHQsZVt0XSwhaXx8ISh0IGluIGkpfHxpW3RdKX0pKX1maW5hbGx5e2J0KCl9cmV0dXJuIHR9ZnVuY3Rpb24gUnQodCl7dmFyIG4saT17bmFtZTp0LnR0fTtyZXR1cm4gdC5MJiZ0LkwubGVuZ3RoPjAmJihpLmRlcGVuZGVuY2llcz0obj10LkwsQXJyYXkuZnJvbShuZXcgU2V0KG4pKSkubWFwKFJ0KSksaX1mdW5jdGlvbiBrdCh0KXt2YXIgbj17bmFtZTp0LnR0fTtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIHQuWCYmdC5YLnNpemU+MH0odCkmJihuLm9ic2VydmVycz1BcnJheS5mcm9tKGZ1bmN0aW9uKHQpe3JldHVybiB0Llh9KHQpKS5tYXAoa3QpKSxufWZ1bmN0aW9uIEV0KCl7dGhpcy5tZXNzYWdlPVwiRkxPV19DQU5DRUxMRURcIn1mdW5jdGlvbiBUdCh0KXtlKHQuY2FuY2VsKSYmdC5jYW5jZWwoKX1mdW5jdGlvbiBDdCh0KXtyZXR1cm4hMD09PShudWxsPT10P3ZvaWQgMDp0LmlzTW9iWEZsb3cpfWZ1bmN0aW9uIEt0KHQsbil7aWYodm9pZCAwIT09bil7aWYoITE9PT1hbih0KSlyZXR1cm4hMTtpZighdFtLbl0ubnQuaGFzKG4pKXJldHVybiExO3ZhciBpPWRuKHQsbik7cmV0dXJuIGNpKGkpfXJldHVybiBjaSh0KX1mdW5jdGlvbiBMdCh0LG4pe3JldHVybiEhdCYmKHZvaWQgMCE9PW4/ISFhbih0KSYmdFtLbl0ubnQuaGFzKG4pOmFuKHQpfHwhIXRbS25dfHxJbih0KXx8d2kodCl8fGNpKHQpKX1mdW5jdGlvbiBJdCh0KXtyZXR1cm4gTHQodCl9ZnVuY3Rpb24gUHQobil7cmV0dXJuIGFuKG4pP25bS25dLml0KCk6SGkobil8fEppKG4pP0FycmF5LmZyb20obi5rZXlzKCkpOnVuKG4pP24ubWFwKChmdW5jdGlvbih0LG4pe3JldHVybiBufSkpOnZvaWQgdCg1KX1mdW5jdGlvbiBEdChuLGkpe3JldHVybiBhbihuKT9uW0tuXS5ydChpKTpIaShuKXx8Smkobik/bi5oYXMoaSk6dW4obik/aT49MCYmaTxuLmxlbmd0aDp2b2lkIHQoMTApfWZ1bmN0aW9uIEJ0KG4pe2lmKGFuKG4pKXJldHVybiBuW0tuXS5ldCgpO3QoMzgpfWZ1bmN0aW9uIHF0KHQsbixpKXtyZXR1cm4gdC5zZXQobixpKSxpfWZ1bmN0aW9uIEd0KCl7dChcInRyYWNlKCkgaXMgbm90IGF2YWlsYWJsZSBpbiBwcm9kdWN0aW9uIGJ1aWxkc1wiKTtmb3IodmFyIG49ITEsaT1hcmd1bWVudHMubGVuZ3RoLHI9bmV3IEFycmF5KGkpLGU9MDtlPGk7ZSsrKXJbZV09YXJndW1lbnRzW2VdO1wiYm9vbGVhblwiPT10eXBlb2YgcltyLmxlbmd0aC0xXSYmKG49ci5wb3AoKSk7dmFyIG89WHQocik7aWYoIW8pcmV0dXJuIHQoXCIndHJhY2UoYnJlYWs/KScgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgYSB0cmFja2VkIGNvbXB1dGVkIHZhbHVlIG9yIGEgUmVhY3Rpb24uIENvbnNpZGVyIHBhc3NpbmcgaW4gdGhlIGNvbXB1dGVkIHZhbHVlIG9yIHJlYWN0aW9uIGV4cGxpY2l0bHlcIik7by5vdD09PWZpLk5PTkUmJmNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdICdcIitvLnR0K1wiJyB0cmFjaW5nIGVuYWJsZWRcIiksby5vdD1uP2ZpLkJSRUFLOmZpLkxPR31mdW5jdGlvbiBYdCh0KXtzd2l0Y2godC5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gcGkudHJhY2tpbmdEZXJpdmF0aW9uO2Nhc2UgMTpyZXR1cm4gZG4odFswXSk7Y2FzZSAyOnJldHVybiBkbih0WzBdLHRbMV0pfX1mdW5jdGlvbiBXdCh0LG4pe3ZvaWQgMD09PW4mJihuPXZvaWQgMCksZHQoKTt0cnl7cmV0dXJuIHQuYXBwbHkobil9ZmluYWxseXtidCgpfX1mdW5jdGlvbiBIdCh0LG4saSl7dmFyIHI7aWYoXCJudW1iZXJcIj09dHlwZW9mIGkudGltZW91dCl7dmFyIGU9bmV3IEVycm9yKFwiV0hFTl9USU1FT1VUXCIpO3I9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtpZighdVtLbl0uSil7aWYodSgpLCFpLm9uRXJyb3IpdGhyb3cgZTtpLm9uRXJyb3IoZSl9fSksaS50aW1lb3V0KX1pLm5hbWU9XCJXaGVuXCI7dmFyIG89eihcIldoZW4tZWZmZWN0XCIsbiksdT1ndCgoZnVuY3Rpb24obil7USghMSx0KSYmKG4uZGlzcG9zZSgpLHImJmNsZWFyVGltZW91dChyKSxvKCkpfSksaSk7cmV0dXJuIHV9ZnVuY3Rpb24gVXQodCxuKXt2YXIgaSxyPW5ldyBQcm9taXNlKChmdW5jdGlvbihyLGUpe3ZhciBvPUh0KHQscixtKHt9LG4se29uRXJyb3I6ZX0pKTtpPWZ1bmN0aW9uKCl7bygpLGUoXCJXSEVOX0NBTkNFTExFRFwiKX19KSk7cmV0dXJuIHIuY2FuY2VsPWkscn1mdW5jdGlvbiBGdCh0KXtyZXR1cm4gdFtLbl19ZnVuY3Rpb24genQodCl7cmV0dXJuIHZvaWQgMCE9PXQudXQmJnQudXQubGVuZ3RoPjB9ZnVuY3Rpb24gJHQodCxuKXt2YXIgaT10LnV0fHwodC51dD1bXSk7cmV0dXJuIGkucHVzaChuKSxyKChmdW5jdGlvbigpe3ZhciB0PWkuaW5kZXhPZihuKTstMSE9PXQmJmkuc3BsaWNlKHQsMSl9KSl9ZnVuY3Rpb24gSnQobixpKXt2YXIgcj11dCgpO3RyeXtmb3IodmFyIGU9W10uY29uY2F0KG4udXR8fFtdKSxvPTAsdT1lLmxlbmd0aDtvPHUmJigoaT1lW29dKGkpKSYmIWkudHlwZSYmdCgxNCksaSk7bysrKTtyZXR1cm4gaX1maW5hbGx5e3N0KHIpfX1mdW5jdGlvbiBZdCh0KXtyZXR1cm4gdm9pZCAwIT09dC5zdCYmdC5zdC5sZW5ndGg+MH1mdW5jdGlvbiBRdCh0LG4pe3ZhciBpPXQuc3R8fCh0LnN0PVtdKTtyZXR1cm4gaS5wdXNoKG4pLHIoKGZ1bmN0aW9uKCl7dmFyIHQ9aS5pbmRleE9mKG4pOy0xIT09dCYmaS5zcGxpY2UodCwxKX0pKX1mdW5jdGlvbiBadCh0LG4pe3ZhciBpPXV0KCkscj10LnN0O2lmKHIpe2Zvcih2YXIgZT0wLG89KHI9ci5zbGljZSgpKS5sZW5ndGg7ZTxvO2UrKylyW2VdKG4pO3N0KGkpfX1mdW5jdGlvbiB0bih0LG4scixlKXt2b2lkIDA9PT1yJiYocj1cIk9ic2VydmFibGVBcnJheVwiKSx2b2lkIDA9PT1lJiYoZT0hMSksaSgpO3ZhciBvPW5ldyBLaShyLG4sZSwhMSk7YyhvLm50LEtuLG8pO3ZhciB1PW5ldyBQcm94eShvLm50LENpKTtpZihvLnY9dSx0JiZ0Lmxlbmd0aCl7dmFyIHM9WighMCk7by5mdCgwLDAsdCksdHQocyl9cmV0dXJuIHV9ZnVuY3Rpb24gbm4odCxuKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBBcnJheS5wcm90b3R5cGVbdF0mJihMaVt0XT1uKHQpKX1mdW5jdGlvbiBybih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbj10aGlzW0tuXTtuLmF0LnJlcG9ydE9ic2VydmVkKCk7dmFyIGk9bi5jdChuLm50KTtyZXR1cm4gaVt0XS5hcHBseShpLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIGVuKHQpe3JldHVybiBmdW5jdGlvbihuLGkpe3ZhciByPXRoaXMsZT10aGlzW0tuXTtyZXR1cm4gZS5hdC5yZXBvcnRPYnNlcnZlZCgpLGUuY3QoZS5udClbdF0oKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4uY2FsbChpLHQsZSxyKX0pKX19ZnVuY3Rpb24gb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dGhpcyxpPXRoaXNbS25dO2kuYXQucmVwb3J0T2JzZXJ2ZWQoKTt2YXIgcj1pLmN0KGkubnQpLGU9YXJndW1lbnRzWzBdO3JldHVybiBhcmd1bWVudHNbMF09ZnVuY3Rpb24odCxpLHIpe3JldHVybiBlKHQsaSxyLG4pfSxyW3RdLmFwcGx5KHIsYXJndW1lbnRzKX19ZnVuY3Rpb24gdW4odCl7cmV0dXJuIHUodCkmJkRpKHRbS25dKX1mdW5jdGlvbiBzbih0LG4pe3ZhciBpO2lmKGIodCxLbikpcmV0dXJuIHQ7dmFyIHI9bnVsbCE9KGk9bnVsbD09bj92b2lkIDA6bi5uYW1lKT9pOlwiT2JzZXJ2YWJsZU9iamVjdFwiLGU9bmV3IFFpKHQsbmV3IE1hcCxTdHJpbmcociksZnVuY3Rpb24odCl7dmFyIG47cmV0dXJuIHQ/bnVsbCE9KG49dC5kZWZhdWx0RGVjb3JhdG9yKT9uOkcodCk6dm9pZCAwfShuKSk7cmV0dXJuIGEodCxLbixlKSx0fWZ1bmN0aW9uIGZuKHQpe3JldHVybiBZaVt0XXx8KFlpW3RdPXtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tLbl0uaHQodCl9LHNldDpmdW5jdGlvbihuKXtyZXR1cm4gdGhpc1tLbl0udnQodCxuKX19KX1mdW5jdGlvbiBhbih0KXtyZXR1cm4hIXUodCkmJlppKHRbS25dKX1mdW5jdGlvbiBjbih0LG4saSl7dmFyIHI7bnVsbD09KHI9dC5zW0NuXSl8fGRlbGV0ZSByW2ldfWZ1bmN0aW9uIGhuKHQpe2duKGlyLnByb3RvdHlwZSxcIlwiK3QsZnVuY3Rpb24odCl7cmV0dXJue2VudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW0tuXS5sdCh0KX0sc2V0OmZ1bmN0aW9uKG4pe3RoaXNbS25dLmR0KHQsbil9fX0odCkpfWZ1bmN0aW9uIHZuKHQpe2lmKHQ+dHIpe2Zvcih2YXIgbj10cjtuPHQrMTAwO24rKylobihuKTt0cj10fX1mdW5jdGlvbiBsbih0LG4saSl7cmV0dXJuIG5ldyBpcih0LG4saSl9ZnVuY3Rpb24gZG4obixpKXtpZihcIm9iamVjdFwiPT10eXBlb2YgbiYmbnVsbCE9PW4pe2lmKHVuKG4pKXJldHVybiB2b2lkIDAhPT1pJiZ0KDIzKSxuW0tuXS5hdDtpZihKaShuKSlyZXR1cm4gbltLbl07aWYoSGkobikpe2lmKHZvaWQgMD09PWkpcmV0dXJuIG4uYnQ7dmFyIHI9bi5wdC5nZXQoaSl8fG4ueXQuZ2V0KGkpO3JldHVybiByfHx0KDI1LGkscG4obikpLHJ9aWYoYW4obikpe2lmKCFpKXJldHVybiB0KDI2KTt2YXIgbz1uW0tuXS5udC5nZXQoaSk7cmV0dXJuIG98fHQoMjcsaSxwbihuKSksb31pZihJbihuKXx8Y2kobil8fHdpKG4pKXJldHVybiBufWVsc2UgaWYoZShuKSYmd2kobltLbl0pKXJldHVybiBuW0tuXTt0KDI4KX1mdW5jdGlvbiBibihuLGkpe3JldHVybiBufHx0KDI5KSx2b2lkIDAhPT1pP2JuKGRuKG4saSkpOkluKG4pfHxjaShuKXx8d2kobil8fEhpKG4pfHxKaShuKT9uOm5bS25dP25bS25dOnZvaWQgdCgyNCxuKX1mdW5jdGlvbiBwbih0LG4pe3ZhciBpO2lmKHZvaWQgMCE9PW4paT1kbih0LG4pO2Vsc2V7aWYoQXQodCkpcmV0dXJuIHQubmFtZTtpPWFuKHQpfHxIaSh0KXx8SmkodCk/Ym4odCk6ZG4odCl9cmV0dXJuIGkudHR9ZnVuY3Rpb24geW4odCxuLGkpe3JldHVybiB2b2lkIDA9PT1pJiYoaT0tMSksZnVuY3Rpb24gdChuLGkscixvLHUpe2lmKG49PT1pKXJldHVybiAwIT09bnx8MS9uPT0xL2k7aWYobnVsbD09bnx8bnVsbD09aSlyZXR1cm4hMTtpZihuIT1uKXJldHVybiBpIT1pO3ZhciBzPXR5cGVvZiBuO2lmKCFlKHMpJiZcIm9iamVjdFwiIT09cyYmXCJvYmplY3RcIiE9dHlwZW9mIGkpcmV0dXJuITE7dmFyIGY9cnIuY2FsbChuKTtpZihmIT09cnIuY2FsbChpKSlyZXR1cm4hMTtzd2l0Y2goZil7Y2FzZVwiW29iamVjdCBSZWdFeHBdXCI6Y2FzZVwiW29iamVjdCBTdHJpbmddXCI6cmV0dXJuXCJcIituPT1cIlwiK2k7Y2FzZVwiW29iamVjdCBOdW1iZXJdXCI6cmV0dXJuK24hPStuPytpIT0raTowPT0rbj8xLytuPT0xL2k6K249PStpO2Nhc2VcIltvYmplY3QgRGF0ZV1cIjpjYXNlXCJbb2JqZWN0IEJvb2xlYW5dXCI6cmV0dXJuK249PStpO2Nhc2VcIltvYmplY3QgU3ltYm9sXVwiOnJldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC52YWx1ZU9mLmNhbGwobik9PT1TeW1ib2wudmFsdWVPZi5jYWxsKGkpO2Nhc2VcIltvYmplY3QgTWFwXVwiOmNhc2VcIltvYmplY3QgU2V0XVwiOnI+PTAmJnIrK31uPW1uKG4pLGk9bW4oaSk7dmFyIGE9XCJbb2JqZWN0IEFycmF5XVwiPT09ZjtpZighYSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIG58fFwib2JqZWN0XCIhPXR5cGVvZiBpKXJldHVybiExO3ZhciBjPW4uY29uc3RydWN0b3IsaD1pLmNvbnN0cnVjdG9yO2lmKGMhPT1oJiYhKGUoYykmJmMgaW5zdGFuY2VvZiBjJiZlKGgpJiZoIGluc3RhbmNlb2YgaCkmJlwiY29uc3RydWN0b3JcImluIG4mJlwiY29uc3RydWN0b3JcImluIGkpcmV0dXJuITF9aWYoMD09PXIpcmV0dXJuITE7cjwwJiYocj0tMSksdT11fHxbXTtmb3IodmFyIHY9KG89b3x8W10pLmxlbmd0aDt2LS07KWlmKG9bdl09PT1uKXJldHVybiB1W3ZdPT09aTtpZihvLnB1c2gobiksdS5wdXNoKGkpLGEpe2lmKCh2PW4ubGVuZ3RoKSE9PWkubGVuZ3RoKXJldHVybiExO2Zvcig7di0tOylpZighdChuW3ZdLGlbdl0sci0xLG8sdSkpcmV0dXJuITF9ZWxzZXt2YXIgbCxkPU9iamVjdC5rZXlzKG4pO2lmKHY9ZC5sZW5ndGgsT2JqZWN0LmtleXMoaSkubGVuZ3RoIT09dilyZXR1cm4hMTtmb3IoO3YtLTspaWYoIWIoaSxsPWRbdl0pfHwhdChuW2xdLGlbbF0sci0xLG8sdSkpcmV0dXJuITF9cmV0dXJuIG8ucG9wKCksdS5wb3AoKSwhMH0odCxuLGkpfWZ1bmN0aW9uIG1uKHQpe3JldHVybiB1bih0KT90LnNsaWNlKCk6dih0KXx8SGkodCl8fGwodCl8fEppKHQpP0FycmF5LmZyb20odC5lbnRyaWVzKCkpOnR9ZnVuY3Rpb24gd24odCl7cmV0dXJuIHRbU3ltYm9sLml0ZXJhdG9yXT1qbix0fWZ1bmN0aW9uIGpuKCl7cmV0dXJuIHRoaXN9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHhuPXt9LE9uPU9iamVjdC5hc3NpZ24sQW49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixnbj1PYmplY3QuZGVmaW5lUHJvcGVydHksX249T2JqZWN0LnByb3RvdHlwZSxTbj1bXTtPYmplY3QuZnJlZXplKFNuKTt2YXIgTW49e307T2JqZWN0LmZyZWV6ZShNbik7dmFyIFZuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm94eSxObj1PYmplY3QudG9TdHJpbmcoKSxSbj1mdW5jdGlvbigpe30sa249dm9pZCAwIT09T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxFbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5vd25LZXlzP1JlZmxlY3Qub3duS2V5czprbj9mdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCkuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCkpfTpPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxUbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc3x8ZnVuY3Rpb24odCl7dmFyIG49e307cmV0dXJuIEVuKHQpLmZvckVhY2goKGZ1bmN0aW9uKGkpe25baV09QW4odCxpKX0pKSxufSxDbj1TeW1ib2woXCJtb2J4LXN0b3JlZC1hbm5vdGF0aW9uc1wiKSxLbj1TeW1ib2woXCJtb2J4IGFkbWluaXN0cmF0aW9uXCIpLExuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt2b2lkIDA9PT10JiYodD1cIkF0b21cIiksdGhpcy50dD12b2lkIDAsdGhpcy5XPSExLHRoaXMuSD0hMSx0aGlzLlg9bmV3IFNldCx0aGlzLkI9MCx0aGlzLkY9MCx0aGlzLkc9c2kuVCx0aGlzLm9uQk9MPXZvaWQgMCx0aGlzLm9uQlVPTD12b2lkIDAsdGhpcy50dD10fXZhciBuPXQucHJvdG90eXBlO3JldHVybiBuLm9uQk89ZnVuY3Rpb24oKXt0aGlzLm9uQk9MJiZ0aGlzLm9uQk9MLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiB0KCl9KSl9LG4ub25CVU89ZnVuY3Rpb24oKXt0aGlzLm9uQlVPTCYmdGhpcy5vbkJVT0wuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQoKX0pKX0sbi5yZXBvcnRPYnNlcnZlZD1mdW5jdGlvbigpe3JldHVybiBwdCh0aGlzKX0sbi5yZXBvcnRDaGFuZ2VkPWZ1bmN0aW9uKCl7ZHQoKSx5dCh0aGlzKSxidCgpfSxuLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHR9LHR9KCksSW49aChcIkF0b21cIixMbiksUG49e2lkZW50aXR5OmZ1bmN0aW9uKHQsbil7cmV0dXJuIHQ9PT1ufSxzdHJ1Y3R1cmFsOmZ1bmN0aW9uKHQsbil7cmV0dXJuIHluKHQsbil9LGRlZmF1bHQ6ZnVuY3Rpb24odCxuKXtyZXR1cm4gT2JqZWN0LmlzP09iamVjdC5pcyh0LG4pOnQ9PT1uPzAhPT10fHwxL3Q9PTEvbjp0IT10JiZuIT1ufSxzaGFsbG93OmZ1bmN0aW9uKHQsbil7cmV0dXJuIHluKHQsbiwxKX19LERuPUEoe3Q6XCJvdmVycmlkZVwiLG86ZnVuY3Rpb24oKXtyZXR1cm4gMH0sdTpmdW5jdGlvbigpe3QoXCInXCIrdGhpcy50K1wiJyBjYW4gb25seSBiZSB1c2VkIHdpdGggJ21ha2VPYnNlcnZhYmxlJ1wiKX19KSxCbj1HKCkscW49e2RlZXA6ITAsbmFtZTp2b2lkIDAsZGVmYXVsdERlY29yYXRvcjp2b2lkIDAscHJveHk6ITB9O09iamVjdC5mcmVlemUocW4pO3ZhciBHbj1EKFwib2JzZXJ2YWJsZVwiKSxYbj1EKFwib2JzZXJ2YWJsZS5yZWZcIix7ZW5oYW5jZXI6TX0pLFduPUQoXCJvYnNlcnZhYmxlLnNoYWxsb3dcIix7ZW5oYW5jZXI6ZnVuY3Rpb24odCxuLGkpe3JldHVybiBudWxsPT10fHxhbih0KXx8dW4odCl8fEhpKHQpfHxKaSh0KT90OkFycmF5LmlzQXJyYXkodCk/JG4uYXJyYXkodCx7bmFtZTppLGRlZXA6ITF9KTpzKHQpPyRuLm9iamVjdCh0LHZvaWQgMCx7bmFtZTppLGRlZXA6ITF9KTp2KHQpPyRuLm1hcCh0LHtuYW1lOmksZGVlcDohMX0pOmwodCk/JG4uc2V0KHQse25hbWU6aSxkZWVwOiExfSk6dm9pZCAwfX0pLEhuPUQoXCJvYnNlcnZhYmxlLnN0cnVjdFwiLHtlbmhhbmNlcjpmdW5jdGlvbih0LG4pe3JldHVybiB5bih0LG4pP246dH19KSxVbj1BKEduKTtPYmplY3QuYXNzaWduKEYsVW4pO3ZhciBGbix6biwkbj1PbihGLHtib3g6ZnVuY3Rpb24odCxuKXt2YXIgaT1IKG4pO3JldHVybiBuZXcgb2kodCxVKGkpLGkubmFtZSwhMCxpLmVxdWFscyl9LGFycmF5OmZ1bmN0aW9uKHQsbil7dmFyIGk9SChuKTtyZXR1cm4oITE9PT1waS51c2VQcm94aWVzfHwhMT09PWkucHJveHk/bG46dG4pKHQsVShpKSxpLm5hbWUpfSxtYXA6ZnVuY3Rpb24odCxuKXt2YXIgaT1IKG4pO3JldHVybiBuZXcgV2kodCxVKGkpLGkubmFtZSl9LHNldDpmdW5jdGlvbih0LG4pe3ZhciBpPUgobik7cmV0dXJuIG5ldyAkaSh0LFUoaSksaS5uYW1lKX0sb2JqZWN0OmZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gTnQoITE9PT1waS51c2VQcm94aWVzfHwhMT09PShudWxsPT1yP3ZvaWQgMDpyLnByb3h5KT9zbih7fSxyKTpmdW5jdGlvbih0LG4pe3ZhciByLGU7cmV0dXJuIGkoKSxudWxsIT0oZT0ocj0odD1zbih0LG4pKVtLbl0pLnYpP2U6ci52PW5ldyBQcm94eSh0LGtpKX0oe30sciksdCxuKX0scmVmOkEoWG4pLHNoYWxsb3c6QShXbiksZGVlcDpVbixzdHJ1Y3Q6QShIbil9KSxKbj1MKFwiY29tcHV0ZWRcIiksWW49TChcImNvbXB1dGVkLnN0cnVjdFwiLHtlcXVhbHM6UG4uc3RydWN0dXJhbH0pLFFuPWZ1bmN0aW9uKHQsbil7aWYobyhuKSlyZXR1cm4gZyh0LG4sSm4pO2lmKHModCkpcmV0dXJuIEEoTChcImNvbXB1dGVkXCIsdCkpO3ZhciBpPXMobik/bjp7fTtyZXR1cm4gaS5nZXQ9dCxpLm5hbWV8fChpLm5hbWU9dC5uYW1lfHxcIlwiKSxuZXcgYWkoaSl9O09iamVjdC5hc3NpZ24oUW4sSm4pLFFuLnN0cnVjdD1BKFluKTt2YXIgWm4sdGk9MCxuaT0xLGlpPW51bGwhPShGbj1udWxsPT0oem49QW4oKGZ1bmN0aW9uKCl7fSksXCJuYW1lXCIpKT92b2lkIDA6em4uY29uZmlndXJhYmxlKSYmRm4scmk9e3ZhbHVlOlwiYWN0aW9uXCIsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiExLGVudW1lcmFibGU6ITF9O1puPVN5bWJvbC50b1ByaW1pdGl2ZTt2YXIgZWksb2k9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbihuLGkscixlLG8pe3ZhciB1O3JldHVybiB2b2lkIDA9PT1yJiYocj1cIk9ic2VydmFibGVWYWx1ZVwiKSx2b2lkIDA9PT1vJiYobz1Qbi5kZWZhdWx0KSwodT10LmNhbGwodGhpcyxyKXx8dGhpcykuZW5oYW5jZXI9dm9pZCAwLHUudHQ9dm9pZCAwLHUuZXF1YWxzPXZvaWQgMCx1Lnd0PSExLHUudXQ9dm9pZCAwLHUuc3Q9dm9pZCAwLHUuanQ9dm9pZCAwLHUuZGVoYW5jZXI9dm9pZCAwLHUuZW5oYW5jZXI9aSx1LnR0PXIsdS5lcXVhbHM9byx1Lmp0PWkobix2b2lkIDAsciksdX13KG4sdCk7dmFyIGk9bi5wcm90b3R5cGU7cmV0dXJuIGkuZGVoYW5jZVZhbHVlPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10aGlzLmRlaGFuY2VyP3RoaXMuZGVoYW5jZXIodCk6dH0saS5zZXQ9ZnVuY3Rpb24odCl7KHQ9dGhpcy54dCh0KSkhPT1waS5VTkNIQU5HRUQmJnRoaXMuT3QodCl9LGkueHQ9ZnVuY3Rpb24odCl7aWYoenQodGhpcykpe3ZhciBuPUp0KHRoaXMse29iamVjdDp0aGlzLHR5cGU6VGksbmV3VmFsdWU6dH0pO2lmKCFuKXJldHVybiBwaS5VTkNIQU5HRUQ7dD1uLm5ld1ZhbHVlfXJldHVybiB0PXRoaXMuZW5oYW5jZXIodCx0aGlzLmp0LHRoaXMudHQpLHRoaXMuZXF1YWxzKHRoaXMuanQsdCk/cGkuVU5DSEFOR0VEOnR9LGkuT3Q9ZnVuY3Rpb24odCl7dmFyIG49dGhpcy5qdDt0aGlzLmp0PXQsdGhpcy5yZXBvcnRDaGFuZ2VkKCksWXQodGhpcykmJlp0KHRoaXMse3R5cGU6VGksb2JqZWN0OnRoaXMsbmV3VmFsdWU6dCxvbGRWYWx1ZTpufSl9LGkuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVwb3J0T2JzZXJ2ZWQoKSx0aGlzLmRlaGFuY2VWYWx1ZSh0aGlzLmp0KX0saS5BdD1mdW5jdGlvbih0KXtyZXR1cm4gJHQodGhpcyx0KX0saS5ndD1mdW5jdGlvbih0LG4pe3JldHVybiBuJiZ0KHtvYnNlcnZhYmxlS2luZDpcInZhbHVlXCIsZGVidWdPYmplY3ROYW1lOnRoaXMudHQsb2JqZWN0OnRoaXMsdHlwZTpUaSxuZXdWYWx1ZTp0aGlzLmp0LG9sZFZhbHVlOnZvaWQgMH0pLFF0KHRoaXMsdCl9LGkucmF3PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuanR9LGkudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0KCl9LGkudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50dCtcIltcIit0aGlzLmp0K1wiXVwifSxpLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gZCh0aGlzLmdldCgpKX0saVtabl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZU9mKCl9LG59KExuKSx1aT1oKFwiT2JzZXJ2YWJsZVZhbHVlXCIsb2kpO2VpPVN5bWJvbC50b1ByaW1pdGl2ZTt2YXIgc2ksZmksYWk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKG4pe3RoaXMuUj1zaS5ULHRoaXMuTD1bXSx0aGlzLkk9bnVsbCx0aGlzLkg9ITEsdGhpcy5XPSExLHRoaXMuWD1uZXcgU2V0LHRoaXMuQj0wLHRoaXMuRD0wLHRoaXMuRj0wLHRoaXMuRz1zaS5rLHRoaXMuUD0wLHRoaXMuanQ9bmV3IGhpKG51bGwpLHRoaXMudHQ9dm9pZCAwLHRoaXMuX3Q9dm9pZCAwLHRoaXMuU3Q9ITEsdGhpcy5NdD0hMSx0aGlzLmRlcml2YXRpb249dm9pZCAwLHRoaXMuVnQ9dm9pZCAwLHRoaXMub3Q9ZmkuTk9ORSx0aGlzLk50PXZvaWQgMCx0aGlzLlJ0PXZvaWQgMCx0aGlzLmt0PXZvaWQgMCx0aGlzLkV0PXZvaWQgMCx0aGlzLm9uQk9MPXZvaWQgMCx0aGlzLm9uQlVPTD12b2lkIDAsbi5nZXR8fHQoMzEpLHRoaXMuZGVyaXZhdGlvbj1uLmdldCx0aGlzLnR0PW4ubmFtZXx8XCJDb21wdXRlZFZhbHVlXCIsbi5zZXQmJih0aGlzLlZ0PXooXCJDb21wdXRlZFZhbHVlLXNldHRlclwiLG4uc2V0KSksdGhpcy5SdD1uLmVxdWFsc3x8KG4uY29tcGFyZVN0cnVjdHVyYWx8fG4uc3RydWN0P1BuLnN0cnVjdHVyYWw6UG4uZGVmYXVsdCksdGhpcy5OdD1uLmNvbnRleHQsdGhpcy5rdD0hIW4ucmVxdWlyZXNSZWFjdGlvbix0aGlzLkV0PSEhbi5rZWVwQWxpdmV9dmFyIGk9bi5wcm90b3R5cGU7cmV0dXJuIGkucT1mdW5jdGlvbigpeyFmdW5jdGlvbih0KXt0Lkc9PT1zaS5rJiYodC5HPXNpLkssdC5YLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QuUj09PXNpLmsmJih0LlI9c2kuSyx0LnEoKSl9KSkpfSh0aGlzKX0saS5vbkJPPWZ1bmN0aW9uKCl7dGhpcy5vbkJPTCYmdGhpcy5vbkJPTC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdCgpfSkpfSxpLm9uQlVPPWZ1bmN0aW9uKCl7dGhpcy5vbkJVT0wmJnRoaXMub25CVU9MLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiB0KCl9KSl9LGkuZ2V0PWZ1bmN0aW9uKCl7aWYodGhpcy5TdCYmdCgzMix0aGlzLnR0LHRoaXMuZGVyaXZhdGlvbiksMCE9PXBpLmluQmF0Y2h8fDAhPT10aGlzLlguc2l6ZXx8dGhpcy5FdCl7aWYocHQodGhpcyksaXQodGhpcykpe3ZhciBuPXBpLnRyYWNraW5nQ29udGV4dDt0aGlzLkV0JiYhbiYmKHBpLnRyYWNraW5nQ29udGV4dD10aGlzKSx0aGlzLnRyYWNrQW5kQ29tcHV0ZSgpJiZmdW5jdGlvbih0KXt0LkchPT1zaS5DJiYodC5HPXNpLkMsdC5YLmZvckVhY2goKGZ1bmN0aW9uKG4pe24uUj09PXNpLks/bi5SPXNpLkM6bi5SPT09c2kuayYmKHQuRz1zaS5rKX0pKSl9KHRoaXMpLHBpLnRyYWNraW5nQ29udGV4dD1ufX1lbHNlIGl0KHRoaXMpJiYodGhpcy5UdCgpLGR0KCksdGhpcy5qdD10aGlzLkN0KCExKSxidCgpKTt2YXIgaT10aGlzLmp0O2lmKG50KGkpKXRocm93IGkuY2F1c2U7cmV0dXJuIGl9LGkuc2V0PWZ1bmN0aW9uKG4pe2lmKHRoaXMuVnQpe3RoaXMuTXQmJnQoMzMsdGhpcy50dCksdGhpcy5NdD0hMDt0cnl7dGhpcy5WdC5jYWxsKHRoaXMuTnQsbil9ZmluYWxseXt0aGlzLk10PSExfX1lbHNlIHQoMzQsdGhpcy50dCl9LGkudHJhY2tBbmRDb21wdXRlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5qdCxuPXRoaXMuUj09PXNpLlQsaT10aGlzLkN0KCEwKSxyPW58fG50KHQpfHxudChpKXx8IXRoaXMuUnQodCxpKTtyZXR1cm4gciYmKHRoaXMuanQ9aSkscn0saS5DdD1mdW5jdGlvbih0KXt0aGlzLlN0PSEwO3ZhciBuLGk9WighMSk7aWYodCluPXJ0KHRoaXMsdGhpcy5kZXJpdmF0aW9uLHRoaXMuTnQpO2Vsc2UgaWYoITA9PT1waS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzKW49dGhpcy5kZXJpdmF0aW9uLmNhbGwodGhpcy5OdCk7ZWxzZSB0cnl7bj10aGlzLmRlcml2YXRpb24uY2FsbCh0aGlzLk50KX1jYXRjaCh0KXtuPW5ldyBoaSh0KX1yZXR1cm4gdHQoaSksdGhpcy5TdD0hMSxufSxpLlU9ZnVuY3Rpb24oKXt0aGlzLkV0fHwoZXQodGhpcyksdGhpcy5qdD12b2lkIDApfSxpLmd0PWZ1bmN0aW9uKHQsbil7dmFyIGk9dGhpcyxyPSEwLGU9dm9pZCAwO3JldHVybiBndCgoZnVuY3Rpb24oKXt2YXIgbz1pLmdldCgpO2lmKCFyfHxuKXt2YXIgdT11dCgpO3Qoe29ic2VydmFibGVLaW5kOlwiY29tcHV0ZWRcIixkZWJ1Z09iamVjdE5hbWU6aS50dCx0eXBlOlRpLG9iamVjdDppLG5ld1ZhbHVlOm8sb2xkVmFsdWU6ZX0pLHN0KHUpfXI9ITEsZT1vfSkpfSxpLlR0PWZ1bmN0aW9uKCl7fSxpLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHQrXCJbXCIrdGhpcy5kZXJpdmF0aW9uLnRvU3RyaW5nKCkrXCJdXCJ9LGkudmFsdWVPZj1mdW5jdGlvbigpe3JldHVybiBkKHRoaXMuZ2V0KCkpfSxpW2VpXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlT2YoKX0sbn0oKSxjaT1oKFwiQ29tcHV0ZWRWYWx1ZVwiLGFpKTshZnVuY3Rpb24odCl7dFt0LlQ9LTFdPVwiTk9UX1RSQUNLSU5HX1wiLHRbdC5rPTBdPVwiVVBfVE9fREFURV9cIix0W3QuSz0xXT1cIlBPU1NJQkxZX1NUQUxFX1wiLHRbdC5DPTJdPVwiU1RBTEVfXCJ9KHNpfHwoc2k9e30pKSxmdW5jdGlvbih0KXt0W3QuTk9ORT0wXT1cIk5PTkVcIix0W3QuTE9HPTFdPVwiTE9HXCIsdFt0LkJSRUFLPTJdPVwiQlJFQUtcIn0oZml8fChmaT17fSkpO3ZhciBoaT1mdW5jdGlvbih0KXt0aGlzLmNhdXNlPXZvaWQgMCx0aGlzLmNhdXNlPXR9LHZpPVtcIm1vYnhHdWlkXCIsXCJzcHlMaXN0ZW5lcnNcIixcImVuZm9yY2VBY3Rpb25zXCIsXCJjb21wdXRlZFJlcXVpcmVzUmVhY3Rpb25cIixcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsXCJvYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvblwiLFwiYWxsb3dTdGF0ZVJlYWRzXCIsXCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzXCIsXCJydW5JZFwiLFwiVU5DSEFOR0VEXCIsXCJ1c2VQcm94aWVzXCJdLGxpPWZ1bmN0aW9uKCl7dGhpcy52ZXJzaW9uPTYsdGhpcy5VTkNIQU5HRUQ9e30sdGhpcy50cmFja2luZ0Rlcml2YXRpb249bnVsbCx0aGlzLnRyYWNraW5nQ29udGV4dD1udWxsLHRoaXMucnVuSWQ9MCx0aGlzLm1vYnhHdWlkPTAsdGhpcy5pbkJhdGNoPTAsdGhpcy5wZW5kaW5nVW5vYnNlcnZhdGlvbnM9W10sdGhpcy5wZW5kaW5nUmVhY3Rpb25zPVtdLHRoaXMuaXNSdW5uaW5nUmVhY3Rpb25zPSExLHRoaXMuYWxsb3dTdGF0ZUNoYW5nZXM9ITEsdGhpcy5hbGxvd1N0YXRlUmVhZHM9ITAsdGhpcy5lbmZvcmNlQWN0aW9ucz0hMCx0aGlzLnNweUxpc3RlbmVycz1bXSx0aGlzLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycz1bXSx0aGlzLmNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvbj0hMSx0aGlzLnJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlPSExLHRoaXMub2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb249ITEsdGhpcy5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzPSExLHRoaXMuc3VwcHJlc3NSZWFjdGlvbkVycm9ycz0hMSx0aGlzLnVzZVByb3hpZXM9ITAsdGhpcy52ZXJpZnlQcm94aWVzPSExLHRoaXMuc2FmZURlc2NyaXB0b3JzPSEwfSxkaT0hMCxiaT0hMSxwaT1mdW5jdGlvbigpe3ZhciBpPW4oKTtyZXR1cm4gaS5fX21vYnhJbnN0YW5jZUNvdW50PjAmJiFpLl9fbW9ieEdsb2JhbHMmJihkaT0hMSksaS5fX21vYnhHbG9iYWxzJiZpLl9fbW9ieEdsb2JhbHMudmVyc2lvbiE9PShuZXcgbGkpLnZlcnNpb24mJihkaT0hMSksZGk/aS5fX21vYnhHbG9iYWxzPyhpLl9fbW9ieEluc3RhbmNlQ291bnQrPTEsaS5fX21vYnhHbG9iYWxzLlVOQ0hBTkdFRHx8KGkuX19tb2J4R2xvYmFscy5VTkNIQU5HRUQ9e30pLGkuX19tb2J4R2xvYmFscyk6KGkuX19tb2J4SW5zdGFuY2VDb3VudD0xLGkuX19tb2J4R2xvYmFscz1uZXcgbGkpOihzZXRUaW1lb3V0KChmdW5jdGlvbigpe2JpfHx0KDM1KX0pLDEpLG5ldyBsaSl9KCkseWk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsbixpLHIpe3ZvaWQgMD09PXQmJih0PVwiUmVhY3Rpb25cIiksdm9pZCAwPT09ciYmKHI9ITEpLHRoaXMudHQ9dm9pZCAwLHRoaXMuS3Q9dm9pZCAwLHRoaXMuTHQ9dm9pZCAwLHRoaXMuSXQ9dm9pZCAwLHRoaXMuTD1bXSx0aGlzLkk9W10sdGhpcy5SPXNpLlQsdGhpcy5CPTAsdGhpcy5EPTAsdGhpcy5QPTAsdGhpcy5KPSExLHRoaXMuUHQ9ITEsdGhpcy5EdD0hMSx0aGlzLkJ0PSExLHRoaXMub3Q9ZmkuTk9ORSx0aGlzLnR0PXQsdGhpcy5LdD1uLHRoaXMuTHQ9aSx0aGlzLkl0PXJ9dmFyIG49dC5wcm90b3R5cGU7cmV0dXJuIG4ucT1mdW5jdGlvbigpe3RoaXMuWSgpfSxuLlk9ZnVuY3Rpb24oKXt0aGlzLlB0fHwodGhpcy5QdD0hMCxwaS5wZW5kaW5nUmVhY3Rpb25zLnB1c2godGhpcyksbXQoKSl9LG4uaXNTY2hlZHVsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5QdH0sbi4kPWZ1bmN0aW9uKCl7aWYoIXRoaXMuSil7ZHQoKSx0aGlzLlB0PSExO3ZhciB0PXBpLnRyYWNraW5nQ29udGV4dDtpZihwaS50cmFja2luZ0NvbnRleHQ9dGhpcyxpdCh0aGlzKSl7dGhpcy5EdD0hMDt0cnl7dGhpcy5LdCgpfWNhdGNoKHQpe3RoaXMucXQodCl9fXBpLnRyYWNraW5nQ29udGV4dD10LGJ0KCl9fSxuLnRyYWNrPWZ1bmN0aW9uKHQpe2lmKCF0aGlzLkope2R0KCksdGhpcy5CdD0hMDt2YXIgbj1waS50cmFja2luZ0NvbnRleHQ7cGkudHJhY2tpbmdDb250ZXh0PXRoaXM7dmFyIGk9cnQodGhpcyx0LHZvaWQgMCk7cGkudHJhY2tpbmdDb250ZXh0PW4sdGhpcy5CdD0hMSx0aGlzLkR0PSExLHRoaXMuSiYmZXQodGhpcyksbnQoaSkmJnRoaXMucXQoaS5jYXVzZSksYnQoKX19LG4ucXQ9ZnVuY3Rpb24odCl7dmFyIG49dGhpcztpZih0aGlzLkx0KXRoaXMuTHQodCx0aGlzKTtlbHNle2lmKHBpLmRpc2FibGVFcnJvckJvdW5kYXJpZXMpdGhyb3cgdDtwaS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzfHxjb25zb2xlLmVycm9yKFwiW21vYnhdIHVuY2F1Z2h0IGVycm9yIGluICdcIit0aGlzK1wiJ1wiLHQpLHBpLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5mb3JFYWNoKChmdW5jdGlvbihpKXtyZXR1cm4gaSh0LG4pfSkpfX0sbi5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5KfHwodGhpcy5KPSEwLHRoaXMuQnR8fChkdCgpLGV0KHRoaXMpLGJ0KCkpKX0sbi5aPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5kaXNwb3NlLmJpbmQodGhpcyk7cmV0dXJuIHRbS25dPXRoaXMsdH0sbi50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiUmVhY3Rpb25bXCIrdGhpcy50dCtcIl1cIn0sbi50cmFjZT1mdW5jdGlvbih0KXt2b2lkIDA9PT10JiYodD0hMSksR3QodGhpcyx0KX0sdH0oKSxtaT1mdW5jdGlvbih0KXtyZXR1cm4gdCgpfSx3aT1oKFwiUmVhY3Rpb25cIix5aSksamk9VihcImFjdGlvblwiKSx4aT1WKFwiYWN0aW9uLmJvdW5kXCIse2JvdW5kOiEwfSksT2k9VihcImF1dG9BY3Rpb25cIix7YXV0b0FjdGlvbjohMH0pLEFpPVYoXCJhdXRvQWN0aW9uLmJvdW5kXCIse2F1dG9BY3Rpb246ITAsYm91bmQ6ITB9KSxnaT14dCghMSk7T2JqZWN0LmFzc2lnbihnaSxqaSk7dmFyIF9pPXh0KCEwKTtPYmplY3QuYXNzaWduKF9pLE9pKSxnaS5ib3VuZD1BKHhpKSxfaS5ib3VuZD1BKEFpKTt2YXIgU2k9ZnVuY3Rpb24odCl7cmV0dXJuIHQoKX0sTWk9MDtFdC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO3ZhciBWaT1FKFwiZmxvd1wiKSxOaT1FKFwiZmxvdy5ib3VuZFwiLHtib3VuZDohMH0pLFJpPU9iamVjdC5hc3NpZ24oKGZ1bmN0aW9uKHQsbil7aWYobyhuKSlyZXR1cm4gZyh0LG4sVmkpO3ZhciBpPXQscj1pLm5hbWV8fFwiPHVubmFtZWQgZmxvdz5cIix1PWZ1bmN0aW9uKCl7dmFyIHQsbj10aGlzLG89YXJndW1lbnRzLHU9KytNaSxzPWdpKHIrXCIgLSBydW5pZDogXCIrdStcIiAtIGluaXRcIixpKS5hcHBseShuLG8pLGY9dm9pZCAwLGE9bmV3IFByb21pc2UoKGZ1bmN0aW9uKG4saSl7ZnVuY3Rpb24gbyh0KXt2YXIgbjtmPXZvaWQgMDt0cnl7bj1naShyK1wiIC0gcnVuaWQ6IFwiK3UrXCIgLSB5aWVsZCBcIitoKysscy5uZXh0KS5jYWxsKHMsdCl9Y2F0Y2godCl7cmV0dXJuIGkodCl9YyhuKX1mdW5jdGlvbiBhKHQpe3ZhciBuO2Y9dm9pZCAwO3RyeXtuPWdpKHIrXCIgLSBydW5pZDogXCIrdStcIiAtIHlpZWxkIFwiK2grKyxzLnRocm93KS5jYWxsKHMsdCl9Y2F0Y2godCl7cmV0dXJuIGkodCl9YyhuKX1mdW5jdGlvbiBjKHQpe2lmKCFlKG51bGw9PXQ/dm9pZCAwOnQudGhlbikpcmV0dXJuIHQuZG9uZT9uKHQudmFsdWUpOihmPVByb21pc2UucmVzb2x2ZSh0LnZhbHVlKSkudGhlbihvLGEpO3QudGhlbihjLGkpfXZhciBoPTA7dD1pLG8odm9pZCAwKX0pKTtyZXR1cm4gYS5jYW5jZWw9Z2kocitcIiAtIHJ1bmlkOiBcIit1K1wiIC0gY2FuY2VsXCIsKGZ1bmN0aW9uKCl7dHJ5e2YmJlR0KGYpO3ZhciBuPXMucmV0dXJuKHZvaWQgMCksaT1Qcm9taXNlLnJlc29sdmUobi52YWx1ZSk7aS50aGVuKFJuLFJuKSxUdChpKSx0KG5ldyBFdCl9Y2F0Y2gobil7dChuKX19KSksYX07cmV0dXJuIHUuaXNNb2JYRmxvdz0hMCx1fSksVmkpO1JpLmJvdW5kPUEoTmkpO3ZhciBraT17aGFzOmZ1bmN0aW9uKHQsbil7cmV0dXJuIEZ0KHQpLnJ0KG4pfSxnZXQ6ZnVuY3Rpb24odCxuKXtyZXR1cm4gRnQodCkubHQobil9LHNldDpmdW5jdGlvbih0LG4saSl7dmFyIHI7cmV0dXJuISFvKG4pJiYobnVsbD09KHI9RnQodCkuZHQobixpLCEwKSl8fHIpfSxkZWxldGVQcm9wZXJ0eTpmdW5jdGlvbih0LG4pe3ZhciBpO3JldHVybiEhbyhuKSYmKG51bGw9PShpPUZ0KHQpLkd0KG4sITApKXx8aSl9LGRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKHQsbixpKXt2YXIgcjtyZXR1cm4gbnVsbD09KHI9RnQodCkuaChuLGkpKXx8cn0sb3duS2V5czpmdW5jdGlvbih0KXtyZXR1cm4gRnQodCkuZXQoKX0scHJldmVudEV4dGVuc2lvbnM6ZnVuY3Rpb24oKXt0KDEzKX19LEVpPVN5bWJvbChcIm1vYngta2V5c1wiKSxUaT1cInVwZGF0ZVwiLENpPXtnZXQ6ZnVuY3Rpb24odCxuKXt2YXIgaT10W0tuXTtyZXR1cm4gbj09PUtuP2k6XCJsZW5ndGhcIj09PW4/aS5YdCgpOlwic3RyaW5nXCIhPXR5cGVvZiBufHxpc05hTihuKT9iKExpLG4pP0xpW25dOnRbbl06aS5sdChwYXJzZUludChuKSl9LHNldDpmdW5jdGlvbih0LG4saSl7dmFyIHI9dFtLbl07cmV0dXJuXCJsZW5ndGhcIj09PW4mJnIuV3QoaSksXCJzeW1ib2xcIj09dHlwZW9mIG58fGlzTmFOKG4pP3Rbbl09aTpyLmR0KHBhcnNlSW50KG4pLGkpLCEwfSxwcmV2ZW50RXh0ZW5zaW9uczpmdW5jdGlvbigpe3QoMTUpfX0sS2k9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHQsbixpLHIpe3ZvaWQgMD09PXQmJih0PVwiT2JzZXJ2YWJsZUFycmF5XCIpLHRoaXMuSHQ9dm9pZCAwLHRoaXMuVXQ9dm9pZCAwLHRoaXMuYXQ9dm9pZCAwLHRoaXMubnQ9W10sdGhpcy51dD12b2lkIDAsdGhpcy5zdD12b2lkIDAsdGhpcy5GdD12b2lkIDAsdGhpcy5kZWhhbmNlcj12b2lkIDAsdGhpcy52PXZvaWQgMCx0aGlzLnp0PTAsdGhpcy5IdD1pLHRoaXMuVXQ9cix0aGlzLmF0PW5ldyBMbih0KSx0aGlzLkZ0PWZ1bmN0aW9uKHQsaSl7cmV0dXJuIG4odCxpLFwiT2JzZXJ2YWJsZUFycmF5Wy4uXVwiKX19dmFyIGk9bi5wcm90b3R5cGU7cmV0dXJuIGkuJHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuZGVoYW5jZXI/dGhpcy5kZWhhbmNlcih0KTp0fSxpLmN0PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10aGlzLmRlaGFuY2VyJiZ0Lmxlbmd0aD4wP3QubWFwKHRoaXMuZGVoYW5jZXIpOnR9LGkuQXQ9ZnVuY3Rpb24odCl7cmV0dXJuICR0KHRoaXMsdCl9LGkuZ3Q9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49ITEpLG4mJnQoe29ic2VydmFibGVLaW5kOlwiYXJyYXlcIixvYmplY3Q6dGhpcy52LGRlYnVnT2JqZWN0TmFtZTp0aGlzLmF0LnR0LHR5cGU6XCJzcGxpY2VcIixpbmRleDowLGFkZGVkOnRoaXMubnQuc2xpY2UoKSxhZGRlZENvdW50OnRoaXMubnQubGVuZ3RoLHJlbW92ZWQ6W10scmVtb3ZlZENvdW50OjB9KSxRdCh0aGlzLHQpfSxpLlh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXQucmVwb3J0T2JzZXJ2ZWQoKSx0aGlzLm50Lmxlbmd0aH0saS5XdD1mdW5jdGlvbihuKXsoXCJudW1iZXJcIiE9dHlwZW9mIG58fG48MCkmJnQoXCJPdXQgb2YgcmFuZ2U6IFwiK24pO3ZhciBpPXRoaXMubnQubGVuZ3RoO2lmKG4hPT1pKWlmKG4+aSl7Zm9yKHZhciByPW5ldyBBcnJheShuLWkpLGU9MDtlPG4taTtlKyspcltlXT12b2lkIDA7dGhpcy5mdChpLDAscil9ZWxzZSB0aGlzLmZ0KG4saS1uKX0saS5KdD1mdW5jdGlvbihuLGkpe24hPT10aGlzLnp0JiZ0KDE2KSx0aGlzLnp0Kz1pLHRoaXMuVXQmJmk+MCYmdm4obitpKzEpfSxpLmZ0PWZ1bmN0aW9uKHQsbixpKXt2YXIgcj10aGlzLGU9dGhpcy5udC5sZW5ndGg7aWYodm9pZCAwPT09dD90PTA6dD5lP3Q9ZTp0PDAmJih0PU1hdGgubWF4KDAsZSt0KSksbj0xPT09YXJndW1lbnRzLmxlbmd0aD9lLXQ6bnVsbD09bj8wOk1hdGgubWF4KDAsTWF0aC5taW4obixlLXQpKSx2b2lkIDA9PT1pJiYoaT1TbiksenQodGhpcykpe3ZhciBvPUp0KHRoaXMse29iamVjdDp0aGlzLnYsdHlwZTpcInNwbGljZVwiLGluZGV4OnQscmVtb3ZlZENvdW50Om4sYWRkZWQ6aX0pO2lmKCFvKXJldHVybiBTbjtuPW8ucmVtb3ZlZENvdW50LGk9by5hZGRlZH1pZihpPTA9PT1pLmxlbmd0aD9pOmkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gci5GdCh0LHZvaWQgMCl9KSksdGhpcy5VdCl7dmFyIHU9aS5sZW5ndGgtbjt0aGlzLkp0KGUsdSl9dmFyIHM9dGhpcy5ZdCh0LG4saSk7cmV0dXJuIDA9PT1uJiYwPT09aS5sZW5ndGh8fHRoaXMuUXQodCxpLHMpLHRoaXMuY3Qocyl9LGkuWXQ9ZnVuY3Rpb24odCxuLGkpe3ZhciByO2lmKGkubGVuZ3RoPDFlNClyZXR1cm4ocj10aGlzLm50KS5zcGxpY2UuYXBwbHkocixbdCxuXS5jb25jYXQoaSkpO3ZhciBlPXRoaXMubnQuc2xpY2UodCx0K24pLG89dGhpcy5udC5zbGljZSh0K24pO3RoaXMubnQubGVuZ3RoPXQraS5sZW5ndGgtbjtmb3IodmFyIHU9MDt1PGkubGVuZ3RoO3UrKyl0aGlzLm50W3QrdV09aVt1XTtmb3IodmFyIHM9MDtzPG8ubGVuZ3RoO3MrKyl0aGlzLm50W3QraS5sZW5ndGgrc109b1tzXTtyZXR1cm4gZX0saS5adD1mdW5jdGlvbih0LG4saSl7dmFyIHI9IXRoaXMuSHQmJiExLGU9WXQodGhpcyksbz1lfHxyP3tvYnNlcnZhYmxlS2luZDpcImFycmF5XCIsb2JqZWN0OnRoaXMudix0eXBlOlRpLGRlYnVnT2JqZWN0TmFtZTp0aGlzLmF0LnR0LGluZGV4OnQsbmV3VmFsdWU6bixvbGRWYWx1ZTppfTpudWxsO3RoaXMuYXQucmVwb3J0Q2hhbmdlZCgpLGUmJlp0KHRoaXMsbyl9LGkuUXQ9ZnVuY3Rpb24odCxuLGkpe3ZhciByPSF0aGlzLkh0JiYhMSxlPVl0KHRoaXMpLG89ZXx8cj97b2JzZXJ2YWJsZUtpbmQ6XCJhcnJheVwiLG9iamVjdDp0aGlzLnYsZGVidWdPYmplY3ROYW1lOnRoaXMuYXQudHQsdHlwZTpcInNwbGljZVwiLGluZGV4OnQscmVtb3ZlZDppLGFkZGVkOm4scmVtb3ZlZENvdW50OmkubGVuZ3RoLGFkZGVkQ291bnQ6bi5sZW5ndGh9Om51bGw7dGhpcy5hdC5yZXBvcnRDaGFuZ2VkKCksZSYmWnQodGhpcyxvKX0saS5sdD1mdW5jdGlvbih0KXtpZih0PHRoaXMubnQubGVuZ3RoKXJldHVybiB0aGlzLmF0LnJlcG9ydE9ic2VydmVkKCksdGhpcy4kdCh0aGlzLm50W3RdKTtjb25zb2xlLndhcm4oXCJbbW9ieC5hcnJheV0gQXR0ZW1wdCB0byByZWFkIGFuIGFycmF5IGluZGV4IChcIit0K1wiKSB0aGF0IGlzIG91dCBvZiBib3VuZHMgKFwiK3RoaXMubnQubGVuZ3RoK1wiKS4gUGxlYXNlIGNoZWNrIGxlbmd0aCBmaXJzdC4gT3V0IG9mIGJvdW5kIGluZGljZXMgd2lsbCBub3QgYmUgdHJhY2tlZCBieSBNb2JYXCIpfSxpLmR0PWZ1bmN0aW9uKG4saSl7dmFyIHI9dGhpcy5udDtpZihuPHIubGVuZ3RoKXt2YXIgZT1yW25dO2lmKHp0KHRoaXMpKXt2YXIgbz1KdCh0aGlzLHt0eXBlOlRpLG9iamVjdDp0aGlzLnYsaW5kZXg6bixuZXdWYWx1ZTppfSk7aWYoIW8pcmV0dXJuO2k9by5uZXdWYWx1ZX0oaT10aGlzLkZ0KGksZSkpIT09ZSYmKHJbbl09aSx0aGlzLlp0KG4saSxlKSl9ZWxzZSBuPT09ci5sZW5ndGg/dGhpcy5mdChuLDAsW2ldKTp0KDE3LG4sci5sZW5ndGgpfSxufSgpLExpPXtjbGVhcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNwbGljZSgwKX0scmVwbGFjZTpmdW5jdGlvbih0KXt2YXIgbj10aGlzW0tuXTtyZXR1cm4gbi5mdCgwLG4ubnQubGVuZ3RoLHQpfSx0b0pTT046ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zbGljZSgpfSxzcGxpY2U6ZnVuY3Rpb24odCxuKXtmb3IodmFyIGk9YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheShpPjI/aS0yOjApLGU9MjtlPGk7ZSsrKXJbZS0yXT1hcmd1bWVudHNbZV07dmFyIG89dGhpc1tLbl07c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm5bXTtjYXNlIDE6cmV0dXJuIG8uZnQodCk7Y2FzZSAyOnJldHVybiBvLmZ0KHQsbil9cmV0dXJuIG8uZnQodCxuLHIpfSxzcGxpY2VXaXRoQXJyYXk6ZnVuY3Rpb24odCxuLGkpe3JldHVybiB0aGlzW0tuXS5mdCh0LG4saSl9LHB1c2g6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpc1tLbl0sbj1hcmd1bWVudHMubGVuZ3RoLGk9bmV3IEFycmF5KG4pLHI9MDtyPG47cisrKWlbcl09YXJndW1lbnRzW3JdO3JldHVybiB0LmZ0KHQubnQubGVuZ3RoLDAsaSksdC5udC5sZW5ndGh9LHBvcDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNwbGljZShNYXRoLm1heCh0aGlzW0tuXS5udC5sZW5ndGgtMSwwKSwxKVswXX0sc2hpZnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zcGxpY2UoMCwxKVswXX0sdW5zaGlmdDpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzW0tuXSxuPWFyZ3VtZW50cy5sZW5ndGgsaT1uZXcgQXJyYXkobikscj0wO3I8bjtyKyspaVtyXT1hcmd1bWVudHNbcl07cmV0dXJuIHQuZnQoMCwwLGkpLHQubnQubGVuZ3RofSxyZXZlcnNlOmZ1bmN0aW9uKCl7cmV0dXJuIHBpLnRyYWNraW5nRGVyaXZhdGlvbiYmdCgzNyxcInJldmVyc2VcIiksdGhpcy5yZXBsYWNlKHRoaXMuc2xpY2UoKS5yZXZlcnNlKCkpLHRoaXN9LHNvcnQ6ZnVuY3Rpb24oKXtwaS50cmFja2luZ0Rlcml2YXRpb24mJnQoMzcsXCJzb3J0XCIpO3ZhciBuPXRoaXMuc2xpY2UoKTtyZXR1cm4gbi5zb3J0LmFwcGx5KG4sYXJndW1lbnRzKSx0aGlzLnJlcGxhY2UobiksdGhpc30scmVtb3ZlOmZ1bmN0aW9uKHQpe3ZhciBuPXRoaXNbS25dLGk9bi5jdChuLm50KS5pbmRleE9mKHQpO3JldHVybiBpPi0xJiYodGhpcy5zcGxpY2UoaSwxKSwhMCl9fTtubihcImNvbmNhdFwiLHJuKSxubihcImZsYXRcIixybiksbm4oXCJpbmNsdWRlc1wiLHJuKSxubihcImluZGV4T2ZcIixybiksbm4oXCJqb2luXCIscm4pLG5uKFwibGFzdEluZGV4T2ZcIixybiksbm4oXCJzbGljZVwiLHJuKSxubihcInRvU3RyaW5nXCIscm4pLG5uKFwidG9Mb2NhbGVTdHJpbmdcIixybiksbm4oXCJldmVyeVwiLGVuKSxubihcImZpbHRlclwiLGVuKSxubihcImZpbmRcIixlbiksbm4oXCJmaW5kSW5kZXhcIixlbiksbm4oXCJmbGF0TWFwXCIsZW4pLG5uKFwiZm9yRWFjaFwiLGVuKSxubihcIm1hcFwiLGVuKSxubihcInNvbWVcIixlbiksbm4oXCJyZWR1Y2VcIixvbiksbm4oXCJyZWR1Y2VSaWdodFwiLG9uKTt2YXIgSWksUGksRGk9aChcIk9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uXCIsS2kpLEJpPXt9LHFpPVwiYWRkXCI7SWk9U3ltYm9sLml0ZXJhdG9yLFBpPVN5bWJvbC50b1N0cmluZ1RhZzt2YXIgR2ksWGksV2k9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKG4saSxyKXt2b2lkIDA9PT1pJiYoaT1TKSx2b2lkIDA9PT1yJiYocj1cIk9ic2VydmFibGVNYXBcIiksdGhpcy5GdD12b2lkIDAsdGhpcy50dD12b2lkIDAsdGhpc1tLbl09QmksdGhpcy5wdD12b2lkIDAsdGhpcy55dD12b2lkIDAsdGhpcy5idD12b2lkIDAsdGhpcy51dD12b2lkIDAsdGhpcy5zdD12b2lkIDAsdGhpcy5kZWhhbmNlcj12b2lkIDAsdGhpcy5GdD1pLHRoaXMudHQ9cixlKE1hcCl8fHQoMTgpLHRoaXMuYnQ9XyhcIk9ic2VydmFibGVNYXAua2V5cygpXCIpLHRoaXMucHQ9bmV3IE1hcCx0aGlzLnl0PW5ldyBNYXAsdGhpcy5tZXJnZShuKX12YXIgaT1uLnByb3RvdHlwZTtyZXR1cm4gaS5ydD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wdC5oYXModCl9LGkuaGFzPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7aWYoIXBpLnRyYWNraW5nRGVyaXZhdGlvbilyZXR1cm4gdGhpcy5ydCh0KTt2YXIgaT10aGlzLnl0LmdldCh0KTtpZighaSl7dmFyIHI9aT1uZXcgb2kodGhpcy5ydCh0KSxNLFwiT2JzZXJ2YWJsZU1hcC5rZXk/XCIsITEpO3RoaXMueXQuc2V0KHQsciksTXQociwoZnVuY3Rpb24oKXtyZXR1cm4gbi55dC5kZWxldGUodCl9KSl9cmV0dXJuIGkuZ2V0KCl9LGkuc2V0PWZ1bmN0aW9uKHQsbil7dmFyIGk9dGhpcy5ydCh0KTtpZih6dCh0aGlzKSl7dmFyIHI9SnQodGhpcyx7dHlwZTppP1RpOnFpLG9iamVjdDp0aGlzLG5ld1ZhbHVlOm4sbmFtZTp0fSk7aWYoIXIpcmV0dXJuIHRoaXM7bj1yLm5ld1ZhbHVlfXJldHVybiBpP3RoaXMudG4odCxuKTp0aGlzLm5uKHQsbiksdGhpc30saS5kZWxldGU9ZnVuY3Rpb24odCl7dmFyIG49dGhpcztpZih6dCh0aGlzKSYmIUp0KHRoaXMse3R5cGU6XCJkZWxldGVcIixvYmplY3Q6dGhpcyxuYW1lOnR9KSlyZXR1cm4hMTtpZih0aGlzLnJ0KHQpKXt2YXIgaT1ZdCh0aGlzKSxyPWk/e29ic2VydmFibGVLaW5kOlwibWFwXCIsZGVidWdPYmplY3ROYW1lOnRoaXMudHQsdHlwZTpcImRlbGV0ZVwiLG9iamVjdDp0aGlzLG9sZFZhbHVlOnRoaXMucHQuZ2V0KHQpLmp0LG5hbWU6dH06bnVsbDtyZXR1cm4gV3QoKGZ1bmN0aW9uKCl7bi5idC5yZXBvcnRDaGFuZ2VkKCksbi5pbih0LCExKSxuLnB0LmdldCh0KS5PdCh2b2lkIDApLG4ucHQuZGVsZXRlKHQpfSkpLGkmJlp0KHRoaXMsciksITB9cmV0dXJuITF9LGkuaW49ZnVuY3Rpb24odCxuKXt2YXIgaT10aGlzLnl0LmdldCh0KTtpJiZpLk90KG4pfSxpLnRuPWZ1bmN0aW9uKHQsbil7dmFyIGk9dGhpcy5wdC5nZXQodCk7aWYoKG49aS54dChuKSkhPT1waS5VTkNIQU5HRUQpe3ZhciByPVl0KHRoaXMpLGU9cj97b2JzZXJ2YWJsZUtpbmQ6XCJtYXBcIixkZWJ1Z09iamVjdE5hbWU6dGhpcy50dCx0eXBlOlRpLG9iamVjdDp0aGlzLG9sZFZhbHVlOmkuanQsbmFtZTp0LG5ld1ZhbHVlOm59Om51bGw7aS5PdChuKSxyJiZadCh0aGlzLGUpfX0saS5ubj1mdW5jdGlvbih0LG4pe3ZhciBpPXRoaXM7V3QoKGZ1bmN0aW9uKCl7dmFyIHI9bmV3IG9pKG4saS5GdCxcIk9ic2VydmFibGVNYXAua2V5XCIsITEpO2kucHQuc2V0KHQsciksbj1yLmp0LGkuaW4odCwhMCksaS5idC5yZXBvcnRDaGFuZ2VkKCl9KSk7dmFyIHI9WXQodGhpcyk7ciYmWnQodGhpcyxyP3tvYnNlcnZhYmxlS2luZDpcIm1hcFwiLGRlYnVnT2JqZWN0TmFtZTp0aGlzLnR0LHR5cGU6cWksb2JqZWN0OnRoaXMsbmFtZTp0LG5ld1ZhbHVlOm59Om51bGwpfSxpLmdldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oYXModCk/dGhpcy4kdCh0aGlzLnB0LmdldCh0KS5nZXQoKSk6dGhpcy4kdCh2b2lkIDApfSxpLiR0PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10aGlzLmRlaGFuY2VyP3RoaXMuZGVoYW5jZXIodCk6dH0saS5rZXlzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnQucmVwb3J0T2JzZXJ2ZWQoKSx0aGlzLnB0LmtleXMoKX0saS52YWx1ZXM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLG49dGhpcy5rZXlzKCk7cmV0dXJuIHduKHtuZXh0OmZ1bmN0aW9uKCl7dmFyIGk9bi5uZXh0KCkscj1pLmRvbmU7cmV0dXJue2RvbmU6cix2YWx1ZTpyP3ZvaWQgMDp0LmdldChpLnZhbHVlKX19fSl9LGkuZW50cmllcz1mdW5jdGlvbigpe3ZhciB0PXRoaXMsbj10aGlzLmtleXMoKTtyZXR1cm4gd24oe25leHQ6ZnVuY3Rpb24oKXt2YXIgaT1uLm5leHQoKSxyPWkuZG9uZSxlPWkudmFsdWU7cmV0dXJue2RvbmU6cix2YWx1ZTpyP3ZvaWQgMDpbZSx0LmdldChlKV19fX0pfSxpW0lpXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVudHJpZXMoKX0saS5mb3JFYWNoPWZ1bmN0aW9uKHQsbil7Zm9yKHZhciBpLHI9Tyh0aGlzKTshKGk9cigpKS5kb25lOyl7dmFyIGU9aS52YWx1ZTt0LmNhbGwobixlWzFdLGVbMF0sdGhpcyl9fSxpLm1lcmdlPWZ1bmN0aW9uKG4pe3ZhciBpPXRoaXM7cmV0dXJuIEhpKG4pJiYobj1uZXcgTWFwKG4pKSxXdCgoZnVuY3Rpb24oKXtzKG4pP2Z1bmN0aW9uKHQpe3ZhciBuPU9iamVjdC5rZXlzKHQpO2lmKCFrbilyZXR1cm4gbjt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpO3JldHVybiBpLmxlbmd0aD9bXS5jb25jYXQobixpLmZpbHRlcigoZnVuY3Rpb24obil7cmV0dXJuIF9uLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodCxuKX0pKSk6bn0obikuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGkuc2V0KHQsblt0XSl9KSk6QXJyYXkuaXNBcnJheShuKT9uLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBpLnNldCh0WzBdLHRbMV0pfSkpOnYobik/KG4uY29uc3RydWN0b3IhPT1NYXAmJnQoMTksbiksbi5mb3JFYWNoKChmdW5jdGlvbih0LG4pe3JldHVybiBpLnNldChuLHQpfSkpKTpudWxsIT1uJiZ0KDIwLG4pfSkpLHRoaXN9LGkuY2xlYXI9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO1d0KChmdW5jdGlvbigpe290KChmdW5jdGlvbigpe2Zvcih2YXIgbixpPU8odC5rZXlzKCkpOyEobj1pKCkpLmRvbmU7KXQuZGVsZXRlKG4udmFsdWUpfSkpfSkpfSxpLnJlcGxhY2U9ZnVuY3Rpb24obil7dmFyIGk9dGhpcztyZXR1cm4gV3QoKGZ1bmN0aW9uKCl7Zm9yKHZhciByLGU9ZnVuY3Rpb24obil7aWYodihuKXx8SGkobikpcmV0dXJuIG47aWYoQXJyYXkuaXNBcnJheShuKSlyZXR1cm4gbmV3IE1hcChuKTtpZihzKG4pKXt2YXIgaT1uZXcgTWFwO2Zvcih2YXIgciBpbiBuKWkuc2V0KHIsbltyXSk7cmV0dXJuIGl9cmV0dXJuIHQoMjEsbil9KG4pLG89bmV3IE1hcCx1PSExLGY9TyhpLnB0LmtleXMoKSk7IShyPWYoKSkuZG9uZTspe3ZhciBhPXIudmFsdWU7aWYoIWUuaGFzKGEpKWlmKGkuZGVsZXRlKGEpKXU9ITA7ZWxzZXt2YXIgYz1pLnB0LmdldChhKTtvLnNldChhLGMpfX1mb3IodmFyIGgsbD1PKGUuZW50cmllcygpKTshKGg9bCgpKS5kb25lOyl7dmFyIGQ9aC52YWx1ZSxiPWRbMF0scD1kWzFdLHk9aS5wdC5oYXMoYik7aWYoaS5zZXQoYixwKSxpLnB0LmhhcyhiKSl7dmFyIG09aS5wdC5nZXQoYik7by5zZXQoYixtKSx5fHwodT0hMCl9fWlmKCF1KWlmKGkucHQuc2l6ZSE9PW8uc2l6ZSlpLmJ0LnJlcG9ydENoYW5nZWQoKTtlbHNlIGZvcih2YXIgdz1pLnB0LmtleXMoKSxqPW8ua2V5cygpLHg9dy5uZXh0KCksQT1qLm5leHQoKTsheC5kb25lOyl7aWYoeC52YWx1ZSE9PUEudmFsdWUpe2kuYnQucmVwb3J0Q2hhbmdlZCgpO2JyZWFrfXg9dy5uZXh0KCksQT1qLm5leHQoKX1pLnB0PW99KSksdGhpc30saS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBPYnNlcnZhYmxlTWFwXVwifSxpLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiBBcnJheS5mcm9tKHRoaXMpfSxpLmd0PWZ1bmN0aW9uKHQpe3JldHVybiBRdCh0aGlzLHQpfSxpLkF0PWZ1bmN0aW9uKHQpe3JldHVybiAkdCh0aGlzLHQpfSx5KG4sW3trZXk6XCJzaXplXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnQucmVwb3J0T2JzZXJ2ZWQoKSx0aGlzLnB0LnNpemV9fSx7a2V5OlBpLGdldDpmdW5jdGlvbigpe3JldHVyblwiTWFwXCJ9fV0pLG59KCksSGk9aChcIk9ic2VydmFibGVNYXBcIixXaSksVWk9e307R2k9U3ltYm9sLml0ZXJhdG9yLFhpPVN5bWJvbC50b1N0cmluZ1RhZzt2YXIgRmksemksJGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKG4saSxyKXt2b2lkIDA9PT1pJiYoaT1TKSx2b2lkIDA9PT1yJiYocj1cIk9ic2VydmFibGVTZXRcIiksdGhpcy50dD12b2lkIDAsdGhpc1tLbl09VWksdGhpcy5wdD1uZXcgU2V0LHRoaXMuYXQ9dm9pZCAwLHRoaXMuc3Q9dm9pZCAwLHRoaXMudXQ9dm9pZCAwLHRoaXMuZGVoYW5jZXI9dm9pZCAwLHRoaXMuRnQ9dm9pZCAwLHRoaXMudHQ9cixlKFNldCl8fHQoMjIpLHRoaXMuYXQ9Xyh0aGlzLnR0KSx0aGlzLkZ0PWZ1bmN0aW9uKHQsbil7cmV0dXJuIGkodCxuLHIpfSxuJiZ0aGlzLnJlcGxhY2Uobil9dmFyIGk9bi5wcm90b3R5cGU7cmV0dXJuIGkuJHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuZGVoYW5jZXI/dGhpcy5kZWhhbmNlcih0KTp0fSxpLmNsZWFyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztXdCgoZnVuY3Rpb24oKXtvdCgoZnVuY3Rpb24oKXtmb3IodmFyIG4saT1PKHQucHQudmFsdWVzKCkpOyEobj1pKCkpLmRvbmU7KXQuZGVsZXRlKG4udmFsdWUpfSkpfSkpfSxpLmZvckVhY2g9ZnVuY3Rpb24odCxuKXtmb3IodmFyIGkscj1PKHRoaXMpOyEoaT1yKCkpLmRvbmU7KXt2YXIgZT1pLnZhbHVlO3QuY2FsbChuLGUsZSx0aGlzKX19LGkuYWRkPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7aWYoenQodGhpcykmJiFKdCh0aGlzLHt0eXBlOnFpLG9iamVjdDp0aGlzLG5ld1ZhbHVlOnR9KSlyZXR1cm4gdGhpcztpZighdGhpcy5oYXModCkpe1d0KChmdW5jdGlvbigpe24ucHQuYWRkKG4uRnQodCx2b2lkIDApKSxuLmF0LnJlcG9ydENoYW5nZWQoKX0pKTt2YXIgaT1ZdCh0aGlzKTtpJiZadCh0aGlzLGk/e29ic2VydmFibGVLaW5kOlwic2V0XCIsZGVidWdPYmplY3ROYW1lOnRoaXMudHQsdHlwZTpxaSxvYmplY3Q6dGhpcyxuZXdWYWx1ZTp0fTpudWxsKX1yZXR1cm4gdGhpc30saS5kZWxldGU9ZnVuY3Rpb24odCl7dmFyIG49dGhpcztpZih6dCh0aGlzKSYmIUp0KHRoaXMse3R5cGU6XCJkZWxldGVcIixvYmplY3Q6dGhpcyxvbGRWYWx1ZTp0fSkpcmV0dXJuITE7aWYodGhpcy5oYXModCkpe3ZhciBpPVl0KHRoaXMpLHI9aT97b2JzZXJ2YWJsZUtpbmQ6XCJzZXRcIixkZWJ1Z09iamVjdE5hbWU6dGhpcy50dCx0eXBlOlwiZGVsZXRlXCIsb2JqZWN0OnRoaXMsb2xkVmFsdWU6dH06bnVsbDtyZXR1cm4gV3QoKGZ1bmN0aW9uKCl7bi5hdC5yZXBvcnRDaGFuZ2VkKCksbi5wdC5kZWxldGUodCl9KSksaSYmWnQodGhpcyxyKSwhMH1yZXR1cm4hMX0saS5oYXM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXQucmVwb3J0T2JzZXJ2ZWQoKSx0aGlzLnB0Lmhhcyh0aGlzLiR0KHQpKX0saS5lbnRyaWVzPWZ1bmN0aW9uKCl7dmFyIHQ9MCxuPUFycmF5LmZyb20odGhpcy5rZXlzKCkpLGk9QXJyYXkuZnJvbSh0aGlzLnZhbHVlcygpKTtyZXR1cm4gd24oe25leHQ6ZnVuY3Rpb24oKXt2YXIgcj10O3JldHVybiB0Kz0xLHI8aS5sZW5ndGg/e3ZhbHVlOltuW3JdLGlbcl1dLGRvbmU6ITF9Ontkb25lOiEwfX19KX0saS5rZXlzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVzKCl9LGkudmFsdWVzPWZ1bmN0aW9uKCl7dGhpcy5hdC5yZXBvcnRPYnNlcnZlZCgpO3ZhciB0PXRoaXMsbj0wLGk9QXJyYXkuZnJvbSh0aGlzLnB0LnZhbHVlcygpKTtyZXR1cm4gd24oe25leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gbjxpLmxlbmd0aD97dmFsdWU6dC4kdChpW24rK10pLGRvbmU6ITF9Ontkb25lOiEwfX19KX0saS5yZXBsYWNlPWZ1bmN0aW9uKG4pe3ZhciBpPXRoaXM7cmV0dXJuIEppKG4pJiYobj1uZXcgU2V0KG4pKSxXdCgoZnVuY3Rpb24oKXtBcnJheS5pc0FycmF5KG4pfHxsKG4pPyhpLmNsZWFyKCksbi5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gaS5hZGQodCl9KSkpOm51bGwhPW4mJnQoXCJDYW5ub3QgaW5pdGlhbGl6ZSBzZXQgZnJvbSBcIituKX0pKSx0aGlzfSxpLmd0PWZ1bmN0aW9uKHQpe3JldHVybiBRdCh0aGlzLHQpfSxpLkF0PWZ1bmN0aW9uKHQpe3JldHVybiAkdCh0aGlzLHQpfSxpLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiBBcnJheS5mcm9tKHRoaXMpfSxpLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJbb2JqZWN0IE9ic2VydmFibGVTZXRdXCJ9LGlbR2ldPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVzKCl9LHkobixbe2tleTpcInNpemVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hdC5yZXBvcnRPYnNlcnZlZCgpLHRoaXMucHQuc2l6ZX19LHtrZXk6WGksZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCJTZXRcIn19XSksbn0oKSxKaT1oKFwiT2JzZXJ2YWJsZVNldFwiLCRpKSxZaT1PYmplY3QuY3JlYXRlKG51bGwpLFFpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbih0LG4saSxyKXt2b2lkIDA9PT1uJiYobj1uZXcgTWFwKSx2b2lkIDA9PT1yJiYocj1CbiksdGhpcy5zPXZvaWQgMCx0aGlzLm50PXZvaWQgMCx0aGlzLnR0PXZvaWQgMCx0aGlzLnJuPXZvaWQgMCx0aGlzLmJ0PXZvaWQgMCx0aGlzLnN0PXZvaWQgMCx0aGlzLnV0PXZvaWQgMCx0aGlzLnY9dm9pZCAwLHRoaXMubD12b2lkIDAsdGhpcy5lbj12b2lkIDAsdGhpcy5vbj12b2lkIDAsdGhpcy5zPXQsdGhpcy5udD1uLHRoaXMudHQ9aSx0aGlzLnJuPXIsdGhpcy5idD1uZXcgTG4oXCJPYnNlcnZhYmxlT2JqZWN0LmtleXNcIiksdGhpcy5sPXModGhpcy5zKX12YXIgaT1uLnByb3RvdHlwZTtyZXR1cm4gaS5odD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5udC5nZXQodCkuZ2V0KCl9LGkudnQ9ZnVuY3Rpb24odCxuKXt2YXIgaT10aGlzLm50LmdldCh0KTtpZihpIGluc3RhbmNlb2YgYWkpcmV0dXJuIGkuc2V0KG4pLCEwO2lmKHp0KHRoaXMpKXt2YXIgcj1KdCh0aGlzLHt0eXBlOlRpLG9iamVjdDp0aGlzLnZ8fHRoaXMucyxuYW1lOnQsbmV3VmFsdWU6bn0pO2lmKCFyKXJldHVybiBudWxsO249ci5uZXdWYWx1ZX1pZigobj1pLnh0KG4pKSE9PXBpLlVOQ0hBTkdFRCl7dmFyIGU9WXQodGhpcyksbz1lP3t0eXBlOlRpLG9ic2VydmFibGVLaW5kOlwib2JqZWN0XCIsZGVidWdPYmplY3ROYW1lOnRoaXMudHQsb2JqZWN0OnRoaXMudnx8dGhpcy5zLG9sZFZhbHVlOmkuanQsbmFtZTp0LG5ld1ZhbHVlOm59Om51bGw7aS5PdChuKSxlJiZadCh0aGlzLG8pfXJldHVybiEwfSxpLmx0PWZ1bmN0aW9uKHQpe3JldHVybiBwaS50cmFja2luZ0Rlcml2YXRpb24mJiFiKHRoaXMucyx0KSYmdGhpcy5ydCh0KSx0aGlzLnNbdF19LGkuZHQ9ZnVuY3Rpb24odCxuLGkpe3JldHVybiB2b2lkIDA9PT1pJiYoaT0hMSksYih0aGlzLnMsdCk/dGhpcy5udC5oYXModCk/dGhpcy52dCh0LG4pOmk/UmVmbGVjdC5zZXQodGhpcy5zLHQsbik6KHRoaXMuc1t0XT1uLCEwKTp0aGlzLnUodCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0sdGhpcy5ybixpKX0saS5ydD1mdW5jdGlvbih0KXtpZighcGkudHJhY2tpbmdEZXJpdmF0aW9uKXJldHVybiB0IGluIHRoaXMuczt0aGlzLm9ufHwodGhpcy5vbj1uZXcgTWFwKTt2YXIgbj10aGlzLm9uLmdldCh0KTtyZXR1cm4gbnx8KG49bmV3IG9pKHQgaW4gdGhpcy5zLE0sXCJPYnNlcnZhYmxlT2JqZWN0LmtleT9cIiwhMSksdGhpcy5vbi5zZXQodCxuKSksbi5nZXQoKX0saS5vPWZ1bmN0aW9uKG4saSl7aWYoITA9PT1pJiYoaT10aGlzLnJuKSwhMSE9PWkpe2lmKCEobiBpbiB0aGlzLnMpKXt2YXIgcjtpZihudWxsPT0ocj10aGlzLnNbQ25dKT92b2lkIDA6cltuXSlyZXR1cm47dCgxLGkudCx0aGlzLnR0K1wiLlwiK24udG9TdHJpbmcoKSl9Zm9yKHZhciBlPXRoaXMucztlJiZlIT09X247KXt2YXIgbz1BbihlLG4pO2lmKG8pe3ZhciB1PWkubyh0aGlzLG4sbyxlKTtpZigwPT09dSlyZXR1cm47aWYoMT09PXUpYnJlYWt9ZT1PYmplY3QuZ2V0UHJvdG90eXBlT2YoZSl9Y24odGhpcywwLG4pfX0saS51PWZ1bmN0aW9uKHQsbixpLHIpe2lmKHZvaWQgMD09PXImJihyPSExKSwhMD09PWkmJihpPXRoaXMucm4pLCExPT09aSlyZXR1cm4gdGhpcy5oKHQsbixyKTt2YXIgZT1pLnUodGhpcyx0LG4scik7cmV0dXJuIGUmJmNuKHRoaXMsMCx0KSxlfSxpLmg9ZnVuY3Rpb24odCxuLGkpe3ZvaWQgMD09PWkmJihpPSExKTt0cnl7ZHQoKTt2YXIgcj10aGlzLkd0KHQpO2lmKCFyKXJldHVybiByO2lmKHp0KHRoaXMpKXt2YXIgZT1KdCh0aGlzLHtvYmplY3Q6dGhpcy52fHx0aGlzLnMsbmFtZTp0LHR5cGU6cWksbmV3VmFsdWU6bi52YWx1ZX0pO2lmKCFlKXJldHVybiBudWxsO3ZhciBvPWUubmV3VmFsdWU7bi52YWx1ZSE9PW8mJihuPW0oe30sbix7dmFsdWU6b30pKX1pZihpKXtpZighUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnMsdCxuKSlyZXR1cm4hMX1lbHNlIGduKHRoaXMucyx0LG4pO3RoaXMudW4odCxuLnZhbHVlKX1maW5hbGx5e2J0KCl9cmV0dXJuITB9LGkubT1mdW5jdGlvbih0LG4saSxyKXt2b2lkIDA9PT1yJiYocj0hMSk7dHJ5e2R0KCk7dmFyIGU9dGhpcy5HdCh0KTtpZighZSlyZXR1cm4gZTtpZih6dCh0aGlzKSl7dmFyIG89SnQodGhpcyx7b2JqZWN0OnRoaXMudnx8dGhpcy5zLG5hbWU6dCx0eXBlOnFpLG5ld1ZhbHVlOm59KTtpZighbylyZXR1cm4gbnVsbDtuPW8ubmV3VmFsdWV9dmFyIHU9Zm4odCkscz17Y29uZmlndXJhYmxlOiFwaS5zYWZlRGVzY3JpcHRvcnN8fHRoaXMubCxlbnVtZXJhYmxlOiEwLGdldDp1LmdldCxzZXQ6dS5zZXR9O2lmKHIpe2lmKCFSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucyx0LHMpKXJldHVybiExfWVsc2UgZ24odGhpcy5zLHQscyk7dmFyIGY9bmV3IG9pKG4saSxcIk9ic2VydmFibGVPYmplY3Qua2V5XCIsITEpO3RoaXMubnQuc2V0KHQsZiksdGhpcy51bih0LGYuanQpfWZpbmFsbHl7YnQoKX1yZXR1cm4hMH0saS5wPWZ1bmN0aW9uKHQsbixpKXt2b2lkIDA9PT1pJiYoaT0hMSk7dHJ5e2R0KCk7dmFyIHI9dGhpcy5HdCh0KTtpZighcilyZXR1cm4gcjtpZih6dCh0aGlzKSYmIUp0KHRoaXMse29iamVjdDp0aGlzLnZ8fHRoaXMucyxuYW1lOnQsdHlwZTpxaSxuZXdWYWx1ZTp2b2lkIDB9KSlyZXR1cm4gbnVsbDtuLm5hbWV8fChuLm5hbWU9XCJPYnNlcnZhYmxlT2JqZWN0LmtleVwiKSxuLmNvbnRleHQ9dGhpcy52fHx0aGlzLnM7dmFyIGU9Zm4odCksbz17Y29uZmlndXJhYmxlOiFwaS5zYWZlRGVzY3JpcHRvcnN8fHRoaXMubCxlbnVtZXJhYmxlOiExLGdldDplLmdldCxzZXQ6ZS5zZXR9O2lmKGkpe2lmKCFSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucyx0LG8pKXJldHVybiExfWVsc2UgZ24odGhpcy5zLHQsbyk7dGhpcy5udC5zZXQodCxuZXcgYWkobikpLHRoaXMudW4odCx2b2lkIDApfWZpbmFsbHl7YnQoKX1yZXR1cm4hMH0saS5HdD1mdW5jdGlvbih0LG4pe2lmKHZvaWQgMD09PW4mJihuPSExKSwhYih0aGlzLnMsdCkpcmV0dXJuITA7aWYoenQodGhpcykmJiFKdCh0aGlzLHtvYmplY3Q6dGhpcy52fHx0aGlzLnMsbmFtZTp0LHR5cGU6XCJyZW1vdmVcIn0pKXJldHVybiBudWxsO3RyeXt2YXIgaSxyO2R0KCk7dmFyIGUsbz1ZdCh0aGlzKSx1PXRoaXMubnQuZ2V0KHQpLHM9dm9pZCAwO2lmKCF1JiZvJiYocz1udWxsPT0oZT1Bbih0aGlzLnMsdCkpP3ZvaWQgMDplLnZhbHVlKSxuKXtpZighUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0aGlzLnMsdCkpcmV0dXJuITF9ZWxzZSBkZWxldGUgdGhpcy5zW3RdO3UmJih0aGlzLm50LmRlbGV0ZSh0KSx1IGluc3RhbmNlb2Ygb2kmJihzPXUuanQpLHl0KHUpKSx0aGlzLmJ0LnJlcG9ydENoYW5nZWQoKSxudWxsPT0oaT10aGlzLm9uKXx8bnVsbD09KHI9aS5nZXQodCkpfHxyLnNldCh0IGluIHRoaXMucyksbyYmbyYmWnQodGhpcyx7dHlwZTpcInJlbW92ZVwiLG9ic2VydmFibGVLaW5kOlwib2JqZWN0XCIsb2JqZWN0OnRoaXMudnx8dGhpcy5zLGRlYnVnT2JqZWN0TmFtZTp0aGlzLnR0LG9sZFZhbHVlOnMsbmFtZTp0fSl9ZmluYWxseXtidCgpfXJldHVybiEwfSxpLmd0PWZ1bmN0aW9uKHQpe3JldHVybiBRdCh0aGlzLHQpfSxpLkF0PWZ1bmN0aW9uKHQpe3JldHVybiAkdCh0aGlzLHQpfSxpLnVuPWZ1bmN0aW9uKHQsbil7dmFyIGkscixlPVl0KHRoaXMpO2UmJmUmJlp0KHRoaXMsZT97dHlwZTpxaSxvYnNlcnZhYmxlS2luZDpcIm9iamVjdFwiLGRlYnVnT2JqZWN0TmFtZTp0aGlzLnR0LG9iamVjdDp0aGlzLnZ8fHRoaXMucyxuYW1lOnQsbmV3VmFsdWU6bn06bnVsbCksbnVsbD09KGk9dGhpcy5vbil8fG51bGw9PShyPWkuZ2V0KHQpKXx8ci5zZXQoITApLHRoaXMuYnQucmVwb3J0Q2hhbmdlZCgpfSxpLmV0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnQucmVwb3J0T2JzZXJ2ZWQoKSxFbih0aGlzLnMpfSxpLml0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnQucmVwb3J0T2JzZXJ2ZWQoKSxPYmplY3Qua2V5cyh0aGlzLnMpfSxufSgpLFppPWgoXCJPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb25cIixRaSksdHI9MCxucj1mdW5jdGlvbigpe307Rmk9bnIsemk9QXJyYXkucHJvdG90eXBlLE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoRmkucHJvdG90eXBlLHppKTp2b2lkIDAhPT1GaS5wcm90b3R5cGUuX19wcm90b19fP0ZpLnByb3RvdHlwZS5fX3Byb3RvX189emk6RmkucHJvdG90eXBlPXppO3ZhciBpcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKG4saSxyLGUpe3ZhciBvO3ZvaWQgMD09PXImJihyPVwiT2JzZXJ2YWJsZUFycmF5XCIpLHZvaWQgMD09PWUmJihlPSExKSxvPXQuY2FsbCh0aGlzKXx8dGhpczt2YXIgdT1uZXcgS2kocixpLGUsITApO2lmKHUudj1qKG8pLGMoaihvKSxLbix1KSxuJiZuLmxlbmd0aCl7dmFyIHM9WighMCk7by5zcGxpY2VXaXRoQXJyYXkoMCwwLG4pLHR0KHMpfXJldHVybiBvfXcobix0KTt2YXIgaT1uLnByb3RvdHlwZTtyZXR1cm4gaS5jb25jYXQ9ZnVuY3Rpb24oKXt0aGlzW0tuXS5hdC5yZXBvcnRPYnNlcnZlZCgpO2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQpLGk9MDtpPHQ7aSsrKW5baV09YXJndW1lbnRzW2ldO3JldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KHRoaXMuc2xpY2UoKSxuLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHVuKHQpP3Quc2xpY2UoKTp0fSkpKX0saVtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxuPTA7cmV0dXJuIHduKHtuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIG48dC5sZW5ndGg/e3ZhbHVlOnRbbisrXSxkb25lOiExfTp7ZG9uZTohMCx2YWx1ZTp2b2lkIDB9fX0pfSx5KG4sW3trZXk6XCJsZW5ndGhcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tLbl0uWHQoKX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXNbS25dLld0KHQpfX0se2tleTpTeW1ib2wudG9TdHJpbmdUYWcsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCJBcnJheVwifX1dKSxufShucik7T2JqZWN0LmVudHJpZXMoTGkpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBuPXRbMF07XCJjb25jYXRcIiE9PW4mJmEoaXIucHJvdG90eXBlLG4sdFsxXSl9KSksdm4oMWUzKTt2YXIgcnI9X24udG9TdHJpbmc7W1wiU3ltYm9sXCIsXCJNYXBcIixcIlNldFwiXS5mb3JFYWNoKChmdW5jdGlvbihpKXt2b2lkIDA9PT1uKClbaV0mJnQoXCJNb2JYIHJlcXVpcmVzIGdsb2JhbCAnXCIraStcIicgdG8gYmUgYXZhaWxhYmxlIG9yIHBvbHlmaWxsZWRcIil9KSksXCJvYmplY3RcIj09dHlwZW9mIF9fTU9CWF9ERVZUT09MU19HTE9CQUxfSE9PS19fJiZfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3RNb2J4KHtzcHk6anQsZXh0cmFzOntnZXREZWJ1Z05hbWU6cG59LCRtb2J4OktufSksZXhwb3J0cy4kbW9ieD1LbixleHBvcnRzLkZsb3dDYW5jZWxsYXRpb25FcnJvcj1FdCxleHBvcnRzLk9ic2VydmFibGVNYXA9V2ksZXhwb3J0cy5PYnNlcnZhYmxlU2V0PSRpLGV4cG9ydHMuUmVhY3Rpb249eWksZXhwb3J0cy5fYWxsb3dTdGF0ZUNoYW5nZXM9USxleHBvcnRzLl9hbGxvd1N0YXRlQ2hhbmdlc0luc2lkZUNvbXB1dGVkPU90LGV4cG9ydHMuX2FsbG93U3RhdGVSZWFkc0VuZD1hdCxleHBvcnRzLl9hbGxvd1N0YXRlUmVhZHNTdGFydD1mdCxleHBvcnRzLl9hdXRvQWN0aW9uPV9pLGV4cG9ydHMuX2VuZEFjdGlvbj1ZLGV4cG9ydHMuX2dldEFkbWluaXN0cmF0aW9uPWJuLGV4cG9ydHMuX2dldEdsb2JhbFN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHBpfSxleHBvcnRzLl9pbnRlcmNlcHRSZWFkcz1mdW5jdGlvbih0LG4saSl7dmFyIHI7cmV0dXJuIEhpKHQpfHx1bih0KXx8dWkodCk/cj1ibih0KTphbih0KSYmKHI9Ym4odCxuKSksci5kZWhhbmNlcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP246aSxmdW5jdGlvbigpe3IuZGVoYW5jZXI9dm9pZCAwfX0sZXhwb3J0cy5faXNDb21wdXRpbmdEZXJpdmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT1waS50cmFja2luZ0Rlcml2YXRpb259LGV4cG9ydHMuX3Jlc2V0R2xvYmFsU3RhdGU9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgbGk7Zm9yKHZhciBuIGluIHQpLTE9PT12aS5pbmRleE9mKG4pJiYocGlbbl09dFtuXSk7cGkuYWxsb3dTdGF0ZUNoYW5nZXM9IXBpLmVuZm9yY2VBY3Rpb25zfSxleHBvcnRzLl9zdGFydEFjdGlvbj1KLGV4cG9ydHMuYWN0aW9uPWdpLGV4cG9ydHMuYXV0b3J1bj1ndCxleHBvcnRzLmNvbXBhcmVyPVBuLGV4cG9ydHMuY29tcHV0ZWQ9UW4sZXhwb3J0cy5jb25maWd1cmU9ZnVuY3Rpb24oaSl7ITA9PT1pLmlzb2xhdGVHbG9iYWxTdGF0ZSYmZnVuY3Rpb24oKXtpZigocGkucGVuZGluZ1JlYWN0aW9ucy5sZW5ndGh8fHBpLmluQmF0Y2h8fHBpLmlzUnVubmluZ1JlYWN0aW9ucykmJnQoMzYpLGJpPSEwLGRpKXt2YXIgaT1uKCk7MD09LS1pLl9fbW9ieEluc3RhbmNlQ291bnQmJihpLl9fbW9ieEdsb2JhbHM9dm9pZCAwKSxwaT1uZXcgbGl9fSgpO3ZhciByLGUsbz1pLnVzZVByb3hpZXMsdT1pLmVuZm9yY2VBY3Rpb25zO2lmKHZvaWQgMCE9PW8mJihwaS51c2VQcm94aWVzPVwiYWx3YXlzXCI9PT1vfHxcIm5ldmVyXCIhPT1vJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgUHJveHkpLFwiaWZhdmFpbGFibGVcIj09PW8mJihwaS52ZXJpZnlQcm94aWVzPSEwKSx2b2lkIDAhPT11KXt2YXIgcz1cImFsd2F5c1wiPT09dT9cImFsd2F5c1wiOlwib2JzZXJ2ZWRcIj09PXU7cGkuZW5mb3JjZUFjdGlvbnM9cyxwaS5hbGxvd1N0YXRlQ2hhbmdlcz0hMCE9PXMmJlwiYWx3YXlzXCIhPT1zfVtcImNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvblwiLFwicmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGVcIixcIm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uXCIsXCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzXCIsXCJzYWZlRGVzY3JpcHRvcnNcIl0uZm9yRWFjaCgoZnVuY3Rpb24odCl7dCBpbiBpJiYocGlbdF09ISFpW3RdKX0pKSxwaS5hbGxvd1N0YXRlUmVhZHM9IXBpLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uLGkucmVhY3Rpb25TY2hlZHVsZXImJihyPWkucmVhY3Rpb25TY2hlZHVsZXIsZT1taSxtaT1mdW5jdGlvbih0KXtyZXR1cm4gcigoZnVuY3Rpb24oKXtyZXR1cm4gZSh0KX0pKX0pfSxleHBvcnRzLmNyZWF0ZUF0b209XyxleHBvcnRzLmRlZmluZVByb3BlcnR5PWZ1bmN0aW9uKG4saSxyKXtpZihhbihuKSlyZXR1cm4gbltLbl0uaChpLHIpO3QoMzkpfSxleHBvcnRzLmVudHJpZXM9ZnVuY3Rpb24obil7cmV0dXJuIGFuKG4pP1B0KG4pLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuW3Qsblt0XV19KSk6SGkobik/UHQobikubWFwKChmdW5jdGlvbih0KXtyZXR1cm5bdCxuLmdldCh0KV19KSk6Smkobik/QXJyYXkuZnJvbShuLmVudHJpZXMoKSk6dW4obik/bi5tYXAoKGZ1bmN0aW9uKHQsbil7cmV0dXJuW24sdF19KSk6dm9pZCB0KDcpfSxleHBvcnRzLmV4dGVuZE9ic2VydmFibGU9TnQsZXhwb3J0cy5mbG93PVJpLGV4cG9ydHMuZmxvd1Jlc3VsdD1mdW5jdGlvbih0KXtyZXR1cm4gdH0sZXhwb3J0cy5nZXQ9ZnVuY3Rpb24obixpKXtpZihEdChuLGkpKXJldHVybiBhbihuKT9uW0tuXS5sdChpKTpIaShuKT9uLmdldChpKTp1bihuKT9uW2ldOnZvaWQgdCgxMSl9LGV4cG9ydHMuZ2V0QXRvbT1kbixleHBvcnRzLmdldERlYnVnTmFtZT1wbixleHBvcnRzLmdldERlcGVuZGVuY3lUcmVlPWZ1bmN0aW9uKHQsbil7cmV0dXJuIFJ0KGRuKHQsbikpfSxleHBvcnRzLmdldE9ic2VydmVyVHJlZT1mdW5jdGlvbih0LG4pe3JldHVybiBrdChkbih0LG4pKX0sZXhwb3J0cy5oYXM9RHQsZXhwb3J0cy5pbnRlcmNlcHQ9ZnVuY3Rpb24odCxuLGkpe3JldHVybiBlKGkpP2Z1bmN0aW9uKHQsbixpKXtyZXR1cm4gYm4odCxuKS5BdChpKX0odCxuLGkpOmZ1bmN0aW9uKHQsbil7cmV0dXJuIGJuKHQpLkF0KG4pfSh0LG4pfSxleHBvcnRzLmlzQWN0aW9uPUF0LGV4cG9ydHMuaXNCb3hlZE9ic2VydmFibGU9dWksZXhwb3J0cy5pc0NvbXB1dGVkPWZ1bmN0aW9uKHQpe3JldHVybiBLdCh0KX0sZXhwb3J0cy5pc0NvbXB1dGVkUHJvcD1mdW5jdGlvbih0LG4pe3JldHVybiBLdCh0LG4pfSxleHBvcnRzLmlzRmxvdz1DdCxleHBvcnRzLmlzRmxvd0NhbmNlbGxhdGlvbkVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgRXR9LGV4cG9ydHMuaXNPYnNlcnZhYmxlPUl0LGV4cG9ydHMuaXNPYnNlcnZhYmxlQXJyYXk9dW4sZXhwb3J0cy5pc09ic2VydmFibGVNYXA9SGksZXhwb3J0cy5pc09ic2VydmFibGVPYmplY3Q9YW4sZXhwb3J0cy5pc09ic2VydmFibGVQcm9wPWZ1bmN0aW9uKHQsbil7cmV0dXJuIEx0KHQsbil9LGV4cG9ydHMuaXNPYnNlcnZhYmxlU2V0PUppLGV4cG9ydHMua2V5cz1QdCxleHBvcnRzLm1ha2VBdXRvT2JzZXJ2YWJsZT1mdW5jdGlvbih0LG4saSl7aWYocyh0KSlyZXR1cm4gTnQodCx0LG4saSk7dmFyIHI9c24odCxpKVtLbl07aWYoIXRbRWldKXt2YXIgZT1PYmplY3QuZ2V0UHJvdG90eXBlT2YodCksbz1uZXcgU2V0KFtdLmNvbmNhdChFbih0KSxFbihlKSkpO28uZGVsZXRlKFwiY29uc3RydWN0b3JcIiksby5kZWxldGUoS24pLGEoZSxFaSxvKX1kdCgpO3RyeXt0W0VpXS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gci5vKHQsIW58fCEodCBpbiBuKXx8blt0XSl9KSl9ZmluYWxseXtidCgpfXJldHVybiB0fSxleHBvcnRzLm1ha2VPYnNlcnZhYmxlPWZ1bmN0aW9uKHQsbixpKXt2YXIgcj1zbih0LGkpW0tuXTtkdCgpO3RyeXtudWxsIT1ufHwobj1mdW5jdGlvbih0KXtyZXR1cm4gYih0LENuKXx8YSh0LENuLG0oe30sdFtDbl0pKSx0W0NuXX0odCkpLEVuKG4pLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiByLm8odCxuW3RdKX0pKX1maW5hbGx5e2J0KCl9cmV0dXJuIHR9LGV4cG9ydHMub2JzZXJ2YWJsZT0kbixleHBvcnRzLm9ic2VydmU9ZnVuY3Rpb24odCxuLGkscil7cmV0dXJuIGUoaSk/ZnVuY3Rpb24odCxuLGkscil7cmV0dXJuIGJuKHQsbikuZ3QoaSxyKX0odCxuLGkscik6ZnVuY3Rpb24odCxuLGkpe3JldHVybiBibih0KS5ndChuLGkpfSh0LG4saSl9LGV4cG9ydHMub25CZWNvbWVPYnNlcnZlZD1TdCxleHBvcnRzLm9uQmVjb21lVW5vYnNlcnZlZD1NdCxleHBvcnRzLm9uUmVhY3Rpb25FcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gcGkuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLnB1c2godCksZnVuY3Rpb24oKXt2YXIgbj1waS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuaW5kZXhPZih0KTtuPj0wJiZwaS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuc3BsaWNlKG4sMSl9fSxleHBvcnRzLm92ZXJyaWRlPURuLGV4cG9ydHMub3duS2V5cz1CdCxleHBvcnRzLnJlYWN0aW9uPWZ1bmN0aW9uKHQsbixpKXtmdW5jdGlvbiByKCl7aWYobD0hMSwhcC5KKXt2YXIgbj0hMTtwLnRyYWNrKChmdW5jdGlvbigpe3ZhciBpPVEoITEsKGZ1bmN0aW9uKCl7cmV0dXJuIHQocCl9KSk7bj12fHwhYihzLGkpLGQ9cyxzPWl9KSksKHYmJmkuZmlyZUltbWVkaWF0ZWx5fHwhdiYmbikmJmEocyxkLHApLHY9ITF9fXZhciBlO3ZvaWQgMD09PWkmJihpPU1uKTt2YXIgbyx1LHMsZj1udWxsIT0oZT1pLm5hbWUpP2U6XCJSZWFjdGlvblwiLGE9Z2koZixpLm9uRXJyb3I/KG89aS5vbkVycm9yLHU9bixmdW5jdGlvbigpe3RyeXtyZXR1cm4gdS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y2F0Y2godCl7by5jYWxsKHRoaXMsdCl9fSk6biksYz0haS5zY2hlZHVsZXImJiFpLmRlbGF5LGg9X3QoaSksdj0hMCxsPSExLGQ9dm9pZCAwLGI9aS5jb21wYXJlU3RydWN0dXJhbD9Qbi5zdHJ1Y3R1cmFsOmkuZXF1YWxzfHxQbi5kZWZhdWx0LHA9bmV3IHlpKGYsKGZ1bmN0aW9uKCl7dnx8Yz9yKCk6bHx8KGw9ITAsaChyKSl9KSxpLm9uRXJyb3IsaS5yZXF1aXJlc09ic2VydmFibGUpO3JldHVybiBwLlkoKSxwLlooKX0sZXhwb3J0cy5yZW1vdmU9ZnVuY3Rpb24obixpKXthbihuKT9uW0tuXS5HdChpKTpIaShuKXx8Smkobik/bi5kZWxldGUoaSk6dW4obik/KFwibnVtYmVyXCIhPXR5cGVvZiBpJiYoaT1wYXJzZUludChpLDEwKSksbi5zcGxpY2UoaSwxKSk6dCg5KX0sZXhwb3J0cy5ydW5JbkFjdGlvbj1PdCxleHBvcnRzLnNldD1mdW5jdGlvbiBuKGkscixlKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aHx8SmkoaSkpYW4oaSk/aVtLbl0uZHQocixlKTpIaShpKT9pLnNldChyLGUpOkppKGkpP2kuYWRkKHIpOnVuKGkpPyhcIm51bWJlclwiIT10eXBlb2YgciYmKHI9cGFyc2VJbnQociwxMCkpLHI8MCYmdChcIkludmFsaWQgaW5kZXg6ICdcIityK1wiJ1wiKSxkdCgpLHI+PWkubGVuZ3RoJiYoaS5sZW5ndGg9cisxKSxpW3JdPWUsYnQoKSk6dCg4KTtlbHNle2R0KCk7dmFyIG89cjt0cnl7Zm9yKHZhciB1IGluIG8pbihpLHUsb1t1XSl9ZmluYWxseXtidCgpfX19LGV4cG9ydHMuc3B5PWp0LGV4cG9ydHMudG9KUz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24gdChuLGkpe2lmKG51bGw9PW58fFwib2JqZWN0XCIhPXR5cGVvZiBufHxuIGluc3RhbmNlb2YgRGF0ZXx8IUl0KG4pKXJldHVybiBuO2lmKHVpKG4pfHxjaShuKSlyZXR1cm4gdChuLmdldCgpLGkpO2lmKGkuaGFzKG4pKXJldHVybiBpLmdldChuKTtpZih1bihuKSl7dmFyIHI9cXQoaSxuLG5ldyBBcnJheShuLmxlbmd0aCkpO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKG4sZSl7cltlXT10KG4saSl9KSkscn1pZihKaShuKSl7dmFyIGU9cXQoaSxuLG5ldyBTZXQpO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKG4pe2UuYWRkKHQobixpKSl9KSksZX1pZihIaShuKSl7dmFyIG89cXQoaSxuLG5ldyBNYXApO3JldHVybiBuLmZvckVhY2goKGZ1bmN0aW9uKG4scil7by5zZXQocix0KG4saSkpfSkpLG99dmFyIHU9cXQoaSxuLHt9KTtyZXR1cm4gQnQobikuZm9yRWFjaCgoZnVuY3Rpb24ocil7X24ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChuLHIpJiYodVtyXT10KG5bcl0saSkpfSkpLHV9KHQsbmV3IE1hcCl9LGV4cG9ydHMudHJhY2U9R3QsZXhwb3J0cy50cmFuc2FjdGlvbj1XdCxleHBvcnRzLnVudHJhY2tlZD1vdCxleHBvcnRzLnZhbHVlcz1mdW5jdGlvbihuKXtyZXR1cm4gYW4obik/UHQobikubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gblt0XX0pKTpIaShuKT9QdChuKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBuLmdldCh0KX0pKTpKaShuKT9BcnJheS5mcm9tKG4udmFsdWVzKCkpOnVuKG4pP24uc2xpY2UoKTp2b2lkIHQoNil9LGV4cG9ydHMud2hlbj1mdW5jdGlvbih0LG4saSl7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RofHxuJiZcIm9iamVjdFwiPT10eXBlb2Ygbj9VdCh0LG4pOkh0KHQsbixpfHx7fSl9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9ieC5janMucHJvZHVjdGlvbi5taW4uanMubWFwXG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsImFzc2VydC5ub3RFcXVhbCA9IG5vdEVxdWFsXG5hc3NlcnQubm90T2sgPSBub3RPa1xuYXNzZXJ0LmVxdWFsID0gZXF1YWxcbmFzc2VydC5vayA9IGFzc2VydFxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2VydFxuXG5mdW5jdGlvbiBlcXVhbCAoYSwgYiwgbSkge1xuICBhc3NlcnQoYSA9PSBiLCBtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxufVxuXG5mdW5jdGlvbiBub3RFcXVhbCAoYSwgYiwgbSkge1xuICBhc3NlcnQoYSAhPSBiLCBtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxufVxuXG5mdW5jdGlvbiBub3RPayAodCwgbSkge1xuICBhc3NlcnQoIXQsIG0pXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodCwgbSkge1xuICBpZiAoIXQpIHRocm93IG5ldyBFcnJvcihtIHx8ICdBc3NlcnRpb25FcnJvcicpXG59XG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxudmFyIHNhZmVFeHRlcm5hbExpbmsgPSAvKG5vb3BlbmVyfG5vcmVmZXJyZXIpIChub29wZW5lcnxub3JlZmVycmVyKS9cbnZhciBwcm90b2NvbExpbmsgPSAvXltcXHctX10rOi9cblxubW9kdWxlLmV4cG9ydHMgPSBocmVmXG5cbmZ1bmN0aW9uIGhyZWYgKGNiLCByb290KSB7XG4gIGFzc2VydC5ub3RFcXVhbCh0eXBlb2Ygd2luZG93LCAndW5kZWZpbmVkJywgJ25hbm9ocmVmOiBleHBlY3RlZCB3aW5kb3cgdG8gZXhpc3QnKVxuXG4gIHJvb3QgPSByb290IHx8IHdpbmRvdy5kb2N1bWVudFxuXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgY2IsICdmdW5jdGlvbicsICduYW5vaHJlZjogY2Igc2hvdWxkIGJlIHR5cGUgZnVuY3Rpb24nKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIHJvb3QsICdvYmplY3QnLCAnbmFub2hyZWY6IHJvb3Qgc2hvdWxkIGJlIHR5cGUgb2JqZWN0JylcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmICgoZS5idXR0b24gJiYgZS5idXR0b24gIT09IDApIHx8XG4gICAgICBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5IHx8IGUuYWx0S2V5IHx8IGUuc2hpZnRLZXkgfHxcbiAgICAgIGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuXG5cbiAgICB2YXIgYW5jaG9yID0gKGZ1bmN0aW9uIHRyYXZlcnNlIChub2RlKSB7XG4gICAgICBpZiAoIW5vZGUgfHwgbm9kZSA9PT0gcm9vdCkgcmV0dXJuXG4gICAgICBpZiAobm9kZS5sb2NhbE5hbWUgIT09ICdhJyB8fCBub2RlLmhyZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJhdmVyc2Uobm9kZS5wYXJlbnROb2RlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVcbiAgICB9KShlLnRhcmdldClcblxuICAgIGlmICghYW5jaG9yKSByZXR1cm5cblxuICAgIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09IGFuY2hvci5wcm90b2NvbCB8fFxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgIT09IGFuY2hvci5ob3N0bmFtZSB8fFxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucG9ydCAhPT0gYW5jaG9yLnBvcnQgfHxcbiAgICAgIGFuY2hvci5oYXNBdHRyaWJ1dGUoJ2RhdGEtbmFub2hyZWYtaWdub3JlJykgfHxcbiAgICAgIGFuY2hvci5oYXNBdHRyaWJ1dGUoJ2Rvd25sb2FkJykgfHxcbiAgICAgIChhbmNob3IuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSA9PT0gJ19ibGFuaycgJiZcbiAgICAgICAgc2FmZUV4dGVybmFsTGluay50ZXN0KGFuY2hvci5nZXRBdHRyaWJ1dGUoJ3JlbCcpKSkgfHxcbiAgICAgIHByb3RvY29sTGluay50ZXN0KGFuY2hvci5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkpIHJldHVyblxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgY2IoYW5jaG9yKVxuICB9KVxufVxuIiwiIWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMudGFibGU9bmV3IFVpbnQxNkFycmF5KDE2KSx0aGlzLnQ9bmV3IFVpbnQxNkFycmF5KDI4OCl9ZnVuY3Rpb24gZihmLHYpe3RoaXMuc291cmNlPWYsdGhpcy5zb3VyY2VJbmRleD0wLHRoaXMudGFnPTAsdGhpcy52PTAsdGhpcy5NPXYsdGhpcy5KPTAsdGhpcy5vPW5ldyB0LHRoaXMudT1uZXcgdH12YXIgdj1uZXcgdCxiPW5ldyB0LE09bmV3IFVpbnQ4QXJyYXkoMzApLEo9bmV3IFVpbnQxNkFycmF5KDMwKSxyPW5ldyBVaW50OEFycmF5KDMwKSxlPW5ldyBVaW50MTZBcnJheSgzMCksYT1uZXcgVWludDhBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pLG49bmV3IHQsaT1uZXcgVWludDhBcnJheSgzMjApO2Z1bmN0aW9uIG8odCxmLHYsYil7dmFyIE0sSjtmb3IoTT0wO008djsrK00pdFtNXT0wO2ZvcihNPTA7TTwzMC12OysrTSl0W00rdl09TS92fDA7Zm9yKEo9YixNPTA7TTwzMDsrK00pZltNXT1KLEorPTE8PHRbTV19dmFyIHM9bmV3IFVpbnQxNkFycmF5KDE2KTtmdW5jdGlvbiB1KHQsZix2LGIpe3ZhciBNLEo7Zm9yKE09MDtNPDE2OysrTSl0LnRhYmxlW01dPTA7Zm9yKE09MDtNPGI7KytNKXQudGFibGVbZlt2K01dXSsrO2Zvcih0LnRhYmxlWzBdPTAsSj0wLE09MDtNPDE2OysrTSlzW01dPUosSis9dC50YWJsZVtNXTtmb3IoTT0wO008YjsrK00pZlt2K01dJiYodC50W3NbZlt2K01dXSsrXT1NKX1mdW5jdGlvbiBjKHQpe3Qudi0tfHwodC50YWc9dC5zb3VyY2VbdC5zb3VyY2VJbmRleCsrXSx0LnY9Nyk7dmFyIGY9MSZ0LnRhZztyZXR1cm4gdC50YWc+Pj49MSxmfWZ1bmN0aW9uIGgodCxmLHYpe2lmKCFmKXJldHVybiB2O2Zvcig7dC52PDI0Oyl0LnRhZ3w9dC5zb3VyY2VbdC5zb3VyY2VJbmRleCsrXTw8dC52LHQudis9ODt2YXIgYj10LnRhZyY2NTUzNT4+PjE2LWY7cmV0dXJuIHQudGFnPj4+PWYsdC52LT1mLGIrdn1mdW5jdGlvbiBkKHQsZil7Zm9yKDt0LnY8MjQ7KXQudGFnfD10LnNvdXJjZVt0LnNvdXJjZUluZGV4KytdPDx0LnYsdC52Kz04O3ZhciB2PTAsYj0wLE09MCxKPXQudGFnO2Rve2I9MipiKygxJkopLEo+Pj49MSwrK00sdis9Zi50YWJsZVtNXSxiLT1mLnRhYmxlW01dfXdoaWxlKGI+PTApO3JldHVybiB0LnRhZz1KLHQudi09TSxmLnRbditiXX1mdW5jdGlvbiB3KHQsZix2KXt2YXIgYixNLEoscixlLG87Zm9yKGI9aCh0LDUsMjU3KSxNPWgodCw1LDEpLEo9aCh0LDQsNCkscj0wO3I8MTk7KytyKWlbcl09MDtmb3Iocj0wO3I8SjsrK3Ipe3ZhciBzPWgodCwzLDApO2lbYVtyXV09c31mb3IodShuLGksMCwxOSksZT0wO2U8YitNOyl7dmFyIGM9ZCh0LG4pO3N3aXRjaChjKXtjYXNlIDE2OnZhciB3PWlbZS0xXTtmb3Iobz1oKHQsMiwzKTtvOy0tbylpW2UrK109dzticmVhaztjYXNlIDE3OmZvcihvPWgodCwzLDMpO287LS1vKWlbZSsrXT0wO2JyZWFrO2Nhc2UgMTg6Zm9yKG89aCh0LDcsMTEpO287LS1vKWlbZSsrXT0wO2JyZWFrO2RlZmF1bHQ6aVtlKytdPWN9fXUoZixpLDAsYiksdSh2LGksYixNKX1mdW5jdGlvbiBsKHQsZix2KXtmb3IoOzspe3ZhciBiLGEsbixpLG89ZCh0LGYpO2lmKDI1Nj09PW8pcmV0dXJuIDA7aWYobzwyNTYpdC5NW3QuSisrXT1vO2Vsc2UgZm9yKGI9aCh0LE1bby09MjU3XSxKW29dKSxhPWQodCx2KSxpPW49dC5KLWgodCxyW2FdLGVbYV0pO2k8bitiOysraSl0Lk1bdC5KKytdPXQuTVtpXX19ZnVuY3Rpb24geSh0KXtmb3IodmFyIGYsdjt0LnY+ODspdC5zb3VyY2VJbmRleC0tLHQudi09ODtpZigoZj0yNTYqKGY9dC5zb3VyY2VbdC5zb3VyY2VJbmRleCsxXSkrdC5zb3VyY2VbdC5zb3VyY2VJbmRleF0pIT09KDY1NTM1Jn4oMjU2KnQuc291cmNlW3Quc291cmNlSW5kZXgrM10rdC5zb3VyY2VbdC5zb3VyY2VJbmRleCsyXSkpKXJldHVybi0zO2Zvcih0LnNvdXJjZUluZGV4Kz00LHY9Zjt2Oy0tdil0Lk1bdC5KKytdPXQuc291cmNlW3Quc291cmNlSW5kZXgrK107cmV0dXJuIHQudj0wLDB9IWZ1bmN0aW9uKHQsZil7dmFyIHY7Zm9yKHY9MDt2PDc7Kyt2KXQudGFibGVbdl09MDtmb3IodC50YWJsZVs3XT0yNCx0LnRhYmxlWzhdPTE1Mix0LnRhYmxlWzldPTExMix2PTA7djwyNDsrK3YpdC50W3ZdPTI1Nit2O2Zvcih2PTA7djwxNDQ7Kyt2KXQudFsyNCt2XT12O2Zvcih2PTA7djw4Oysrdil0LnRbMTY4K3ZdPTI4MCt2O2Zvcih2PTA7djwxMTI7Kyt2KXQudFsxNzYrdl09MTQ0K3Y7Zm9yKHY9MDt2PDU7Kyt2KWYudGFibGVbdl09MDtmb3IoZi50YWJsZVs1XT0zMix2PTA7djwzMjsrK3YpZi50W3ZdPXZ9KHYsYiksbyhNLEosNCwzKSxvKHIsZSwyLDEpLE1bMjhdPTAsSlsyOF09MjU4O3ZhciBwLFEsTz1PO2Z1bmN0aW9uIGcoKXt9Tz1tb2R1bGU7Zm9yKHZhciBBPW5ldyBVaW50OEFycmF5KDEyMyksUz0yNTtTPj0wOy0tUylBWzQ4K1NdPTUyK1MsQVs2NStTXT1TLEFbOTcrU109MjYrUztBWzQzXT02MixBWzQ3XT02MyxPLndhc209ZnVuY3Rpb24odCxNKXt2YXIgSixyLGU9bmV3IGYodCxuZXcgVWludDhBcnJheSgxMTYyMTApKTtkb3tzd2l0Y2goSj1jKGUpLGgoZSwyLDApKXtjYXNlIDA6cj15KGUpO2JyZWFrO2Nhc2UgMTpyPWwoZSx2LGIpO2JyZWFrO2Nhc2UgMjp3KGUsZS5vLGUudSkscj1sKGUsZS5vLGUudSk7YnJlYWs7ZGVmYXVsdDpyPS0zfWlmKDAhPT1yKXRocm93IEVycm9yKFwiRGF0YSBlcnJvclwiKX13aGlsZSghSik7cmV0dXJuIGUuSjxlLk0ubGVuZ3RoP1wiZnVuY3Rpb25cIj09dHlwZW9mIGUuTS5zbGljZT9lLk0uc2xpY2UoMCxlLkopOmUuTS5zdWJhcnJheSgwLGUuSik6ZS5NfSgodD0+e2NvbnN0IGY9bmV3IFVpbnQ4QXJyYXkoNzIzNzQpO2xldCB2LGI9ITEsTT0wO2ZvcihsZXQgSj0wO0o8NzIzNzQ7SisrKXY9dC5jaGFyQ29kZUF0KEopLDEzIT09diYmMTAhPT12JiYoNjEhPT12fHxiPyhiJiYoYj0hMSx2LT02NCksZltNKytdPXY8NDImJnY+MD92KzIxNDp2LTQyKTpiPSEwKTtyZXR1cm4gZi5zdWJhcnJheSgwLE0pfSkoXCLDlsOnNcK6R1x1MDAwMcKjXHUwMDExwqHDpVx1MDAxOcKlXHUwMDE4w4fDg8OIUTBdLVxcZsKeLS7CsU4ywqxMXsKuXFxcIixEwqbCq0pvwpN3XHUwMDFiwo/DmcKSwqTCgUBcdTAwMGbCpTHDnis4elxcYj/Cq8Krw53Dnm3DscO2wrB1w6tbwpXCgT/DnXzDlMK8wpTCtcOYfMKbwo/DmcOUw5bDrsOaw7XCv8OiPMKDwox+dMOsXHUwMDA0XHUwMDAyw5/CtsKBXHUwMDE1wpLDh8OxXFxcXD/Dj1x1MDAxNlx1MDAwN8K/w7cmKFxcdMKhJMO4R8K6w77CmMKPw4FWdiFcdTAwMTdowrlcdTAwMTnDhlx1MDAxZMOnw7nCocOow5gnw75cdTAwMWTDkcK9woTDl8OAwqZbV8OIc8Ohw6DCvMOXwpFcdTAwMTTChcKgc8OgwpTDuV7Dolx1MDAwZsK8fsK5wpXDuV5cdTAwMWbCrsKVwqdcdTAwMTXDjEh8w43CpMOww5nDoFx1MDAwN1x1MDAxMnvDlcOkc8KIcsKIw5osQVjDvsOIXHUwMDEzw7AhwqR7wr/Dj8OEXHUwMDFmfMKfwqZrw6fCh8Kmw5DCgcK/w6Z6w6fDpMOyfcKkw6fDssOZw5TDhzXCpD/DpVxcXFzCilx1MDAxZcKcfl3DrMOjb8OxKFx1MDAxNizCl1x1MDAxM8KDw5cgdsKpw5Y6eWTDv8OXwoTDm1hcdTAwMTbDs29Jwo5XXHUwMDAzdMKhYcK8w4l0wqjDlD1AXHUwMDExXHUwMDE5XFx0w5rDqcKpw53DgFx1MDAxYSFdw59wJ8Kvw7lRc1fDl8OfwrxwfMOFwpVewpRcdTAwMTcjXHUwMDEwbMOEw47CtVx1MDAxZsKEYcOTwp/CvMKkwpfDnFxcYsOCw4LDlMOPPX3DpcKkw711wpPDvMKWIMOcXHUwMDEwXHUwMDE4w4NcdTAwMGbCv07Dl1/DvMKEw7xywoFlX1x1MDAxOMOFw5/CkMONX8KHw6EpwoRdw7fCgFxcXFzDg8O/w7zCkMOZe8OVXHUwMDAxZcO3PUDDiMOTwrPCpMOVw79cdTAwMTNew73CmFfDk1x1MDAxN8OXwq/CkE13XHUwMDFjwpjDvMKSUGnDgcOOU8Ovwr11XHUwMDEzw4/DnsO/wo8gw7TCoVxcYibDp8OeXHUwMDAxw6jDoMOFJl5cdTAwMTfCqcOgwqB5XHUwMDFjwpZcdTAwMTfCjFx1MDAxY8OjXHUwMDA0wq9cdTAwMGXCkcKUWU7CrVx1MDAwNFxcdHTCsMOfw6nDh8KWw75cdTAwMDQzdVxcdMKXUcOfXFxcXFx1MDAxM0/DicOJXFxcIsOrwoleaCnCoURzwqdVw45cdTAwMGbDj8OwUUTDsW1XTkvDt8O8XHUwMDBmesOFXHUwMDE4XHUwMDFiTUdcdTAwMGVcdTAwMWbDvsOIaMKJPUDDuVx1MDAwNlx1MDAwMWLDmEnCqEHClMKjXHUwMDA0ecKkw752eMKYKVxcZnxpSMO8wrpcdTAwMDZ+w5VcdTAwMDfCiMONwojDgzbCnMOEXHUwMDBlfMOOw5Riw7PCuXrCqcKaw5w9QFx1MDAxNcO7woDDp8KmXFx2dsO7UsOZw77CojpEXHUwMDBmXHUwMDFia8O7NlMhXFxiw7DChMKEwoV5K2zCocK3XHUwMDFmw55cXHbCocOHXHUwMDFmw549TcKhJ1x1MDAxZsOeXHUwMDE5wqFcdTAwMDPCpMOEI1x1MDAwNybCpGRcdTAwMTnCoXVcdTAwMTVcdTAwMTPCvFxcdMOXw5jDkcOVwqhBPUDDvT1KwqElXHUwMDAxw70nwqjDocOgw4jDmCNcdTAwMDfDq1x1MDAxZlx1MDAxZcOKXFx0R8KIeTklXHUwMDA3wrtcdTAwMWZcdTAwMWXCslxcdEfCh3nCuSRcdTAwMDfDh1x1MDAxNVx1MDAxM8OHwrZcdTAwMTZcXFwiwrrCuytZYW8kM8K3wrJcdTAwMDHCt3l2UGXDinnDtMKwwpAqPUrDo1PDvMKxUsORwrPDlMOBwrcxw6HDkcK3wonDrcOMO8KUwo3CucOYw4hzw6V1wpjDmcKTKMOidcKZw5nDj8KowoHDqcOnwoDDqcOkw4E0w4RkN8Kow7rCpMO+PU3CtGbCilx1MDAwZsKUw6dxwr3DsMKAw5JbfS/CmcO4XHUwMDExd1x1MDAwN8Kxw6Z7wphDOlx1MDAxZsOmwo9Xw5VwcjBeP8OERcKvV0zDksO7NFx1MDAxZsOLUMOCL8Oew6U6wpRcdTAwMDNcdTAwMWZLXHUwMDE3w6c3b8KWw5vDsMOzwqfDlldnNSvCvMKLwpPCisO+JsK8wr7ClMKuw4DDvVx1MDAxYlx1MDAxMWzDgSRcXFwiLWRXXHUwMDA1wojDmlsowobDrVx1MDAxOFx1MDAxY8OmXHUwMDBlITpcdTAwMGUsXFxcIsOEwqRcdTAwMWLCozFCwotBLUQ+djk/XHUwMDFmw6LCmF/CksKzwonDisK7WDfDhFx1MDAxM8OuXHUwMDAxc1x1MDAwM0k/XHUwMDA2Z1QySFx1MDAxMyzCjFx1MDAxMyzDkFx1MDAxM8O8w5HCmmDDlGBpw6TChURcdTAwMDfDl8KAdzNcdTAwMWFdXHUwMDBmw7xcdTAwMDPDjGguwr7Cilx1MDAxN8KwJMOqwoFcXFwiblx1MDAxN8OgZEdcdTAwMTJsw7XDpCrDgVhcdTAwMTRmesKyw4DCrFx1MDAxNFx1MDAxNz9cdTAwMTjCksOfw6gtdcKLw6PCrlXDrMOFZMOCwoBew57DlMK+w5dbPifCmMOAQcO5XHUwMDBlw4QhXHUwMDEwLcK+wo3CjMOqe8OSw5LCisKcVTxcXGZEPDfDicK/LVPDqmzDmC9VwonDvW4sScK3XHUwMDFkbVx1MDAxZsKjXHUwMDAyOsKow7DDlMOkMMONcmTDn8OUKlx1MDAxM8KNwqhcXHY2XHUwMDFkd2/Ci1x1MDAwNMKDw41cXGI+XHUwMDE4bF3Dqn/DvsO0IcKUSWHDmlx1MDAxNVx1MDAxMcOrL21cdTAwMWTCnHnDkmfChU7DrVx1MDAxZMKPPU3Co1TDj8OFw61cdTAwMWMpw5Q3wqIoXFxiXFxiwrl5PUDCim5cdTAwMGZfa8KZfcOnd8KiJVxcdMOcw7DDn1x1MDAxY0JZwrhnw6LDvFVKw4d3wqjDqVx1MDAxZjnDvcKrw53CssKEI2AhYDjCrV/DjjDCsGpcdTAwMTDDmHvDqCfCkMOUwqlcdTAwMDFcdTAwMDHClVHCqihhwqhcdTAwMTNvwpDDpFx1MDAwMcOldcKGesKCw5nDm8K1OkJcdTAwMDUjTMKjw5pywrdcdTAwMDFbYcKzwprChTJZXFxcXHXCsEvCh1vDlmHChsOpwq3DkcK2w53CiFDCucKCwpPCgMOhwqZcdTAwMTFgw43CvsOww4pcdTAwMTbCjsO3w4zCoHHDjHDClMKbw7okwoM9QMKkJlx1MDAxN8Knw5nDs8KUXHUwMDE4w5XCq3VvwqfDqUs1w6J/wqhoeX3Dolx1MDAxN8KxKcO5wpYmXHUwMDA0w6HClMOtw5PCs3DCp1TDg3TDkcOQXHUwMDA0w4fDhMKCwpR8wqjCjVx1MDAxOcKaw5TDv8OGw4RcdTAwMTR4w59Kw7rDjiZAw6nDvVx1MDAxOMOuw45AQsKGXHUwMDEzwrVEw4LDlcOow5JcdTAwMDVcdTAwMDI+OcKUUVElRMOhw5fCllx1MDAxY8OawqjCkm9cdTAwMTElPX1pw5TCgMKcwrxwccOfXHUwMDE2wrHClFdcdTAwMWbDpWnDnD1Aw5p2SMOEw4ZcdTAwMWHDnCfCqFx1MDAxMVx1MDAxNMOcw5tcdTAwMDbCp8K9w57Dkz1AwovDtcO2wr9cXHZgVcKkesK3RcK8YFx1MDAxMj/DlkHCmFx1MDAxMMOXwoLCijfDtlxcdlvCjMKuw6E3w5rDk8KmXHUwMDExdMKXw5rDi8KJw4fDnMOjY1LCuTbDnD1Aw5xaczUvKVx1MDAwM1ZcdTAwMDTDi3/CiMO0MMOaXsK0w61qbMOdwqbDkcOgW0LCvsKpfkVcdTAwMGU3PUDDpGfCqks0IS7DpcKYeMOXwoLCqVxcZlx1MDAxZGzCgsKEwpI4w7R1w4FYJ8KRWTLDvX7CiyXCgcO1woLCmMK7bnjChVxcXFxcdTAwMGXDjWnCjMOyPlx1MDAwMSrCulrDn8KoXHUwMDFkbXUrwrh3wqt0X1xcYsKBwrTCo8OfwqHDlSckwrHDoCpkw5Uvwo7CicOXw4kow7LDr8KkwrLDnMOgfMOrLsO/MWHDscOeQlx1MDAxYsO6woZ5VWt7X0zDq8OAN2pcdTAwMTTDniHDtcK3w57Do8K/woheJ1xcditCwoPCtMKGLMK3w6FMU0BXw7Ixw6BawqrCq8K+OsKXXHUwMDAzwqPCklx1MDAwZmlGw6XDksOtWFxcXCLCkVx1MDAxNlxcZmHCiFRcdTAwMDTDicKuw5DCg8OmwqDCkilcdTAwMTfDjFx1MDAxZnxcXGJ4WcKwPUDDgVxcdsKOw7h2woo5WjpFQ0bCgsK2w49aUMO0OsOdZcK1wrDDusO8XHUwMDAzwovDj8K2XHUwMDEywoTDm8Otw5Bnw4pcXGLCoX95wrZZVFjDsEjDk8ORw6XCuGIvw5R/wpLDiXLCiMO8wobCt1x1MDAxYsOOwrVcdTAwMWHDjsKJKGVcXGYow6Ymw6/CiMO7aHslW8KaUcOow7jChcOnw7okXHUwMDBlwqfDp8OwwpvCsMO+JMKFwolIND1Kw6QrM8K8PUBVw7LDr2ZsXHUwMDE1LsKCwqLDk1x1MDAxYlMuXHUwMDBlw4nDvlx1MDAxMlY3w7clw43ClFx1MDAwZi3Ck3PCpTvDn8OOIcOdwqzCn013w7RPO385OcOcw6XDnsOeVlx1MDAwMsOxUX3CusKzwr9vMMOuXHUwMDExworCr8OIUWbCsSd1w7DDqcOZwqdIw64gNyV/w6dBRMOnXHUwMDE5ccOvwqojw4rDpsOQf0zChCzChGTDsFx1MDAxMMO6w4BcdTAwMDZcdTAwMWXDusKwU8OLw5DCpXQ5XHUwMDFmZMO8wrtcdTAwMTTDkFHDv8KvPUpcdTAwMDVcdTAwMTTCksKHw4LDtm86XHUwMDA2YcKzXFxcXFx1MDAxYyvChFx1MDAxMjrDtj1AXHUwMDA2XcKRXHUwMDFmXcOYwrRzN19cdTAwMTfDncKow7DCv0/Du8OBwrTDjFx1MDAxNjLCoS7Cs2LDo0TCtMOfw45cdTAwMWY9QGthwr/DgC7CgGtVwoDCk8OWwo9cdTAwMDfCj1/Cl8ODwrbDmcKERcKZVX8hambClMK0w4jCoFx1MDAxNMK2worDjcK6w67DpULClVxcXFxASMOrwo7Dkl5gw7Bsd3V7XFxcIlx1MDAxOcOFczHDnMO8XHUwMDFlTsKDwrnDs3bClsOQw5zCoMKzwqTCmcOcbMOOUmBCXHUwMDEzOG8yw6TClcOBR8Kbw6jCu8KcS8O2wqzDrz9Xw7tuYcOeMMKjwrHDtEfCgTlsXHUwMDAxPzZ+MVx1MDAxZcOLa1x1MDAxMsKSI1JcdTAwMDPCisOqwobCtmrCnl9cXHbDtVxcXCJcdTAwMTMuKsKnw4B6QDx9QMKqXHUwMDA0wr4vM3t3wqzCvsKvXnxpTcOZw5Jpwq8kw73CkcK1w5B9wqnCnW4nPsKfXHUwMDE0ecOLwqjDp8KvJMOFTVx1MDAxNHlLPyjCsyTChXhcXHTCv8Ocw4pcdTAwMTNcXFxcwo/Dq1x1MDAxM8O+w7bCtHLDkcOYRFx1MDAxN35AwoTDmFbCksOawpvCv8KwwqhRwo3Cs8K7Zy7Dm1x1MDAwMsOyXHUwMDE3w5xnwpx9w5zDgsOrw7rCj8K4cMKUwrxcdTAwMTPCgVxcYsOJXHUwMDE0w6HDtU9uwrkwRsOFIVPDj8OAwoDCqcKRwqkpw6nCkcOYXHUwMDE4XcKBKT1Kw4PDvcKFwpA4wq7CpCnDtl8ow6fCkMOYO8KReC3Cl8Kuw5DCusO4w7DDhlx1MDAxZk5nw4Yxw55PwoRGwqjChMKVacOewrxfwopcdTAwMTHCg2VOPE7Ck1x1MDAxOcO/wqDDvF8/wpdTw4lfXHUwMDEzw4F5w7RcXGLCpFjDgWjDiFx1MDAwNlx1MDAxOXYtSMO8w7gowpDDg8O6XFxcIsKWwoNlwr8hwrfClcKew79xwr1pXHUwMDA2XHUwMDE1W8Opw5xcXFxcY8Kdw4nCqGYqa20mXHUwMDEzw7Nzw5DDk8KVIMKGw6RzXHUwMDAxw4TDn8KQwrjDmGvDg8O6wonDs8ORw6LCu8O8Klx1MDAxN3fDhFpqQ2bCsWjDulx1MDAwNcO2XHUwMDEww5PDssONXHUwMDE4w7hxPX1cdTAwMGZcdTAwMWXDg1x1MDAxY8OVcXczw4ZSRVx1MDAxMVxcZmfDl8OJw7dRw6x+XHUwMDEywrM3XHUwMDFmwoZZwpLCrsOTwp3Co8O9worDt8Osw77CkMO7MWTDqsOEV8OhLlx1MDAxNcKWaGdcdTAwMTTDn0nDhFx1MDAwNSfDr0nCnUwnw6Nqw4/CnXbCsDppw5Elw7pcdTAwMDY2PX1cdTAwMTTDlMKJw5DCkT1Kw6/DvVx1MDAwZj1Aw7PCpsKwNcKvw5FtOcOMw7hcdTAwMWPCqMOCwrMgwpLCiV/CncKrw6zChlx1MDAxMDcqXHUwMDEzwpN4wpTDm8KFw4pkwrFcdTAwMWNlw59DRFx1MDAwM1xcdMOKwqV3wpIhXHUwMDE0w5HDsMOew6vChcO3wo01bMOJw7LCoMO9w6dcdTAwMWVdw5Z1w4TCjSDCuitdJcK6IMKAw59cdTAwMTLChVx1MDAwZsKMwqQtwp0vf8KXwqR6KFx1MDAwNsODwovDu1x1MDAwN8OZwp/ClMKyf3fDgcOfwrFLVHDCoMO8XFxcIsKkwoc5K8KkTcOBcGLDk8KDM8O9RcKLwpBKw7/Dl8K1RDpQXHUwMDE3YENcdTAwMDbCuj1AwrjCrMK5J1rDk8KTw4hcdTAwMWXCk8OIOF0kX8ONwolEXsKdw4tLeMOVXHUwMDFkaWJUw4jDocOdw5FDw5/DvzrCgTknKSrCh8K0c8KqwovCuMKJw4vDn0lcdTAwMTfCpsO4w5DDjlN3fFLDo8KDwo7DrMK1wp1vWcOFwpEvwqVcdTAwMTHCpy9cdTAwMTHDnsOSw7xsw4xCwpdEQEVYwpTDsMOFbMOkUHIxw4jCh1tOXS5Fw5XCjVx1MDAxZMKWw5jDhsOgc8KUScKhJMK5wqknw6FcdTAwMWM4XHUwMDE3XHUwMDFmwpLCslx1MDAxZsOrwrhswqFfwoXDh8Obwq7DuMKPN8Oxw7tebjvCuMK3w53Cg8KYZ0lQw7hew61uw5khYsKWw7F3w4EuV1lTw6kpwqXCmELDjU3DpHbDs8O9XHUwMDFjw6/CqVDCjMOXflx1MDAxYnpcdTAwMDVSwolcdTAwMWNRfMOxw4/CjcOVw4zCk8KzwoLCmMKMc8KtXFxiZ8O7QsKFV8K8wpHDtyjCr8OuwrFcdTAwMTHCu1x1MDAwMydcdTAwMWTDmFx1MDAxYcO5w43DosK1w6fCl0x7w79cdTAwMWPCv2nDk1x1MDAwM1TDv0nCrsONOMO1w6lywrDDp8Kpwrpuw4lwXFx0w5rDg8OFdsOcwoZ4WFx1MDAxNsKOwoDDiVvDhcOTwqrChkDDucKYaMOSXFxmw7vDtTvCt8KGw4IwR8KVbMOFQsKVNmdew7jCrE5cdTAwMWbCnFx1MDAxMMOOwpPChUfCtEzCpMOFWMKYw68tw5s7XVx1MDAxZMKuTlx1MDAxMcKHP0HDmsO2UcOQPsKdw4FcdTAwMDJcdTAwMDZfw7hcdTAwMWUoe8K8PUrCi8OWVmMkXsKVXHUwMDBlw649QD19w5AtwpdnKXByw4jCgmvCr3PCqT1Nw67CpcO/wqnDn8KJNsOzfcO8w57DqcKWwphjfVx1MDAxOFx1MDAxNsOpw5fChnTDglx1MDAxNMOHwqzDtsK9PX3Dn8ORdMOjbsO8XFx2wpnCrlx1MDAwZcObwr/Ds1x1MDAxYsK8S8KnPU0sOcOvXHUwMDE0KsKGTsKKw5fDgzBbPUDCvVbCpFA9fVLCiMKqwpV1woNSKVx1MDAxY8KMXHUwMDE5XFx0w57DvcKzw5ckw689fcKFUSgmw4xmPsK5QMOaw6/Ck8KAN3HDglx1MDAxYljCk1x1MDAxZcOmckg/wqXDqcOowrgxwrfDpT19woXDvnBVLXdcdTAwMWHCjGpcdTAwMDXDi8OTX2shwr4jwrBcdTAwMTNOeMOYP1xcZsOQe1x1MDAxOGdxwodWw5xLRsOWO183wqlhwonDnm/CvMOnwpxcdTAwMGZOw6TCkcORJsOPKS/Co8OCXHUwMDE3woxswqTDi8KdfcKXQzPDn1xcXFxSXHUwMDA0wqRcdTAwMDPDikZfw4DCmsKKazPDlsKdfcO2wrLCj8KGwrtyb8KsWGtSVlx1MDAxZMKuf17CiU5vXHUwMDA0w5Y7woFcdTAwMTTCszLCpMOEw7XCmFx1MDAxMsOWw79AwrXDpDbCp1x1MDAxMsKOw6fDoMOScWw4w7LCgkrDu8KAw4klcFx1MDAxMsOaw6zDg2nDr1x1MDAxOWJJw6TDrMK3w4DClWxcdTAwMTDDlcKERlx1MDAwN1x1MDAxN0RcdTAwMDdXwrdcdTAwMTjCoMOdwojDkMKHW8KQw5BLw6VcXHQ/MShcdTAwMWXDnSXDg07ClsO0w5QzPsKvw7gjw5Q/wqjCjiZcdTAwMWHCsMOObFx1MDAxYcKNYVx1MDAxNsOhwoZvO1VBQ8OWXHUwMDEwcnRmwoLDpcKILcKxw4XCosOAwqrDucKQw6dPXFxmcMOvbTJcdTAwMTA9fU3Cllx1MDAxNsKSwpTDjjfCtX3DvsKHXHUwMDA1wpZywprCp8OlwqBpwp3CrMKgen/Cu8OWw5LCtMOMw5dcdTAwMDRmeMKCwpF/wpvCk8ORNyFcdTAwMTHCjMKrXHUwMDAxw7pWw6spwqAjXHUwMDE3KVxcZsOpJFx1MDAwMcK3XHUwMDExw7XCiVxcXCLCucKIXHUwMDE2NsO5wr7DgcOiKCZDf8K9w6hVXHUwMDFjwrxcXGLCg1x1MDAxM8OlXHUwMDE5wrFqw6fChFsrXFxcXMKQwoI+w7DDncKvwoBsRlJswpTClTXCtFx1MDAxNsOdJsKfVkXCgSB3McKgXHUwMDFlw5pvwrbCnsOKwp/CvyrDncKfwo/Dr8O3w6HCj1x1MDAxNVTCpXhcdTAwMGbCl8OfPU02dMO2w4TCjXrCp8KqflorPUB0YMObwpBpwrLDhcO/w7XDl8Kxd1NbfMOSw6nCm1xcdsOgJMKLXcOLUUvCnsO+wrNcdTAwMWXCvcK2w49cXHRcdTAwMDLDrCPCqsOpf8KPwpRxw7zCvVlcdTAwMTJcdTAwMTnDrUE0wp7DhcORalx1MDAwZl52wpzCqVxcZnxAXHUwMDFlXHUwMDExw7vCv1khPUphw4xiw4Y4XHUwMDFmXHUwMDE2aMKTXHUwMDEzWmDDl8OYXHUwMDFiw5XDgy5cXHTDh8KbPX3DmyTCl8Ksw7zDhsKKXFxiwqxwZsK9dCt0W1p3WcOYw4nDsFx1MDAxYj19w4HDinzChcOrWsKXYMOBPUpTw5Bab8KLKsKxO0jDp1lRw5xcXHRZfsOmdMKww4TCpW/DuMOTbVdwXHUwMDFlwrTDsjxzeVx1MDAxMFx1MDAxN8OkLsKFwqzDpsKzwozDlMOjS8K3XHUwMDAxZlZvLVx1MDAxYsKcw7kpw71cXFwiXHUwMDEyw5vDtWPCsMOddizDhG3CuzdcdTAwMTMxQFTDpMOZdDzDk8KKITXDpFx1MDAwNVx1MDAxM37Cm8KlWHTDklxcYm9TOV9WwqROPU1Zw6x7TcKNwo/Ctlx1MDAwNSZXw45BwrQ+dWXDo1x1MDAxYcOCwqNsw7xBw7DCiMKIwrp7w4DCtlvDt0FcdTAwMGYxwqJ+w5bCv8Kkwo3DuVliXFxiw45BwqTCjXZcdTAwMWNRw41cdTAwMTLCnCNLw7lcdTAwMDQtXHUwMDEwwrzCoMKTwpc9QMODw57CmW4sw5l7wpjDu2DDt8KPUsKkXjlYwrfDpMKpdXZiw4vCrsOOwr3CiSTCg1x1MDAwNW7DjcOiw5Z9bzfDlMK6fsO9w49LP2LChMKrXFxcIsODTsKBw41bw4JaTFx1MDAxZFx1MDAxOMOsw5HDq8KJw6bCuHPCnklFwrLCkEfDoMOXw73ClsOxw5kjw5vCiVx1MDAwZiF9RsKRw6dcXGLDqcKEdiXChVx1MDAxNzXDuMO3UWtcdTAwMWRzO8O4PEE9TcK8RGPDllx1MDAwNcOuXHUwMDE4wr7Cs8KaXHUwMDFldF/Cr8KowpTCrcOESFx1MDAxZMKLwphcXHbCo1x1MDAwNTzDvkpCw7zDuyk9QMOdw4lSUMOcTcOEXHUwMDA1XFxiwoQkQyfCo3DCqUrClDDDnzvDkMK6woDDhcKtbTNCw7w3wocwwph0wp/CqTpcdTAwMTRRd8Kiw5DDkcKAdlB2wqtPKGHDoFx1MDAwMm1cdTAwMDVfwqNGbMOJb8O6cMKvcsO+wpBxwpfDrUrDtMKuXFxcXHZcdTAwMDTCo8KAw7Y9QFJcdTAwMTl0PX1XPX1cdTAwMWTCq11wXHUwMDEzwpnCusOOXHUwMDAyw5XDosK6w5rDqVlcXGbDjVx1MDAxMXNcdTAwMTbDocKWwofCil1Nw5JcdTAwMTkkw53Cs8KTw6DCnn/Dr3x4w65cdTAwMTc0PsKRXHUwMDA0XFx2w4/ChmTCmVx1MDAxMDXDpGBcXGLDtsKhXHUwMDEzZMO5dsKcXHUwMDEzw4XDo8KXUMK0VjN6w77Cglx1MDAxZG4jNcKBwpTDrMOHOMKHX8KLwp5cdTAwMTHCsMKjw7HCl2fCnsOew4BIw6rDqHrDn8KFWsKrXWNow7HCr8KlXHUwMDAyIGfCpMODeMKgw69lXHUwMDE1wpA/azpRw5BhVsKkw6Bvw5BcXHY9TcO+bsKCw7VcdTAwMWPDizdTXHUwMDFlw61cXFxcZ8KHw5o4w4vCncKcL31EZC7DmcOjw43CiWfCnlx1MDAwMcOhPsO8w4BWPX06wpjCgcKSwonCgDl1b8K8XHUwMDE3XHUwMDEww4dcdTAwMTBKIC3CtcOww6nDkcOnwrxaw5vDjDfDhsKcXHUwMDEzw740XHUwMDFhfD19w6A9fUB+PX3DrylGXHUwMDFmw4JcdTAwMTPCnVx1MDAwMnbCh8OjZMOnwrfDuMKiU8KVScKFwrLDjGxjLcOKXHUwMDE0wq5cdTAwMWLCgcOHPUrCvHdIXHUwMDAyXHUwMDE4w5PDj8OIcFrCoFx1MDAxM8KQwpTDpU3CjjE0LMO9VzzDjXZJKMKMRcKFwpBcdTAwMDbCkmjCosK3XFxcXMK9R1PDsHpzRC3DuXnCi8KOwp/Cg8O6w7TDnMOEwro7wpMgwoTDsz7Cl8KbwpM9TcKUY8O1w7/Dllx1MDAxZHdcdTAwMDYswoxcdTAwMTTDvcKbw4VPw4nDsGjDhMObP8KKwrjCgVx1MDAwNk7DlHPDpUDCkETDkcOJw7XCmMOvUjBcXFwiZsOLXHUwMDE2VsO1worDgH3Cq1x1MDAxM8K2e8KLVX9cdTAwMWVcdTAwMTdwX1xcXCLDsUx3w7JcdTAwMTTCklx1MDAwZsKHw4LCnMK1e8Ofw77CpnF4w4dIwpZAwrbCinQxwrhKw595dTrCrFfDqUzCgMK1QypEXHUwMDEyw7PCrjvCisO7PMOFw5/CnMO+w4xcdTAwMTfCnWIow7fCsnvDnTU9QFrDt8O8XHUwMDEyw5XDpknDmT19wrxhXHUwMDE5I8OtwplowqZcdTAwMTbDv8KmwrvCuFhcdTAwMTbCo1x1MDAwZsOqw73DlsKww6TDpsKeXFxmw71VUMK+XHUwMDBmYClLw70zXHUwMDA0w4s0wpI4w4bDisOPXFxmYcKwXHUwMDFhST9ow4BZXHUwMDFlw6zDjFx1MDAwN8Kvwq/CicOnw4ZZw7vCoVEsLjJHwrc2bkPDqsKITsOIwqXCrMOPXHUwMDAywqcjXHUwMDE5QMK1w6nDjHzDiVxcXCJeZ1fCqG/CiMKBwptcdTAwMWLDicOxU8OOOMOlPjbDl2HCtcOvw5rCksOswpDCgVx1MDAwMkdAWcOpNMKvPUrDtsO7cFx1MDAxOWw9Sj85XlJ9wrtkUMKZdsKnw5nCjcKwwpI9fcOmw5XDo1x1MDAwNlx1MDAwZsOuTlV0N1laXHUwMDE4woxLVsKGwqjCv2Ajw4VZw4JcdTAwMDLCskDCgl/DrEbCv3bCv3suw7dEw53Ck2MgwpTDm8KOwpfDlMKBKsKkf8O6wofDuEHCi33CvMOeR8O0w4sjwpPDpn3CgsOMVMKBVsO9w4nDtGBcXHbCvSBqZ0FVw4ErwqgjXHUwMDFjw73Dr8O+NFfDl1x1MDAxYcKtRcO+c8KAw4fDhXjDgknCiVDDhWrDvsKdw7/DoWzCosOXZD/CvELCsEbDoUMsw6nCtsOlcsKvXHUwMDFmw4tYwq8vwrHCnntcdTAwMWRAN3FBw7w9TcKSwrHCosOMb3vCocKew5zCoXY1w7DCosKkXFxiw4RcdTAwMDPCq17DncOcNcO3OznDq8OzwrTDnmTCjMKTw7jCszDDucK1I8K+wqXDucOFw4zDmVdKw7TDn8OKd8Obw6/DusKfXHUwMDA2w6PCnMOlwoPCsVx1MDAxYlx1MDAwM3Nnw50xPX0tXHUwMDEyfsO/VcKrwrY9TcOvREBfZsK5XHUwMDFiwqtpw6rCvsOiw6JcdTAwMGU9fT1Awq5hw5pcdTAwMDfDksOIeMKCccKkasK9w6DDucKdVMOxM8KsNlx1MDAxOMKUPkPCr3Z3wrvCu8KyOMKnw5TCksK3w6ErXHUwMDAyXFxcXEnDoSvCvUHCr8KpZWTDvF3DlcKPw6fCjnlFw7HDmiouXHUwMDFiw6tcdTAwMTbDscO3wp/Dn39bMsO9dsKaw7VmL0JdJcOfw7Mtw5XDujAgw6DDicOPUcOQLMO1XsOxw6lcdTAwMTfCm8Kvw57Ckj/Dn8K9wrZFJ8KAw45pXFxiw6nCtsKLKMK3MMKUw5bDgMKpZcKqw75dw5VcdTAwMGZqw5jDusKlw5lcdTAwMTLDsjV+PUDDt8Kjw5DCl0g9fcOuwrNcdTAwMTA/WMKAwpjDs8OpUMOmw4LCs8K3w6rDu8KOw77CnVx1MDAwNVLDkG0hPU1VwqNQSUjDmMK+NsOSwpvDksKuwoM/XHUwMDFkw7owXHUwMDAzw4k7XVRCwpDDljvCl1x1MDAxZF1cdTAwMTTDhMOSwrNcdTAwMTfCgcOzIcOQwr/CkMOXw5fDqMK/wrrDr0xcdTAwMDE1wqjCs8KLw7LDiFnDncO3XFxcXGVcdTAwMTF4XHUwMDA0wpfDrC/DkcOPw4YrwrUjfDdcdTAwMDLDtsOhKMOEXHUwMDBmXHUwMDE5woXDkcOgXHUwMDEzTMO3w53Cg2vCu8KDSVrCocKdwqBcXFxcNj19XHUwMDAzw7BzWz19w5fDi8OYwrfCh1x1MDAxOcKAw6pcdTAwMDFcdTAwMDTDg0s9QMKewrzDhcO6w4tcXHbDlXBcdTAwMGZcdTAwMTdcXHbDqcK9woPCjmo9TcKmwpTDnMK/ZDJcdTAwMDfCqUVcdTAwMDZdw61INcKrwpnClTJsXFxmwrU+XHUwMDA0PU3DisOrOsO6XFxcIjfCtMOSwqvCrcOKXHUwMDA3wrlBw7c/w75EesKVMsOSVjjDncKYJGDCvcKiSFx1MDAxMcKlw7/ChVx1MDAwMcKzf8KAwqrDjlx1MDAxNMOvXcOew5kjwqfCmi/Dsk/CncKVw43DjMOgMzDDncKrwoxBbMOhXFxmwrHDn1x1MDAxNHBcdTAwMDLCtWvDnsK3w6fCssOJNMKjXHUwMDExa8KIw6NNw6owwo4uwqbDjsKVZMOAw7TDtMOFwqx3w71jTXo9SsK+XHUwMDFiw6dzdHNlI8KaXHUwMDA3wqc9SkDDtXMuw55gZ3tcdTAwMWVcdTAwMDZZSsOLw5LCp2bDnmNcdTAwMTHCoVxcZsOkwqFcdTAwMTLDucKZbcOYKVx1MDAxM2EpY8O4w5TCqSTDkcOpJ8O5wpbCkVx1MDAxYcO8w49cdTAwMWXDtsK0wpvDqFx1MDAxMmZawq3CjVYuw5QrwpJcdTAwMDTCq8Okw6Qxw58pw6g9QFx1MDAxMMO5w6fCo8KffcKUw6omWC5OYyPDoMOdw41Ew5TDg8K9wodsPsOOw6DDpcKYw63DiSdqOMOBQjzCsz1Ne2FrOFkjw4pswo3DrUzCosKAw5vCpHtcdTAwMTFWcsOLIWNhRsOew7HDkcOrw45IXHUwMDE3T13Cn1PDvsOJwo/Cr3twWsOkw5xfw6NcXHTCr3/Ct8KWwoPCgE8kaVx1MDAwNDLDmMOVw500VVxcXFzDvWzCi3zCn2E9fcKjZcOUwrrCjsO1XHUwMDFjw70pXHUwMDEwXHUwMDEzJFHDoTIswr7Ct8Kawq/DuMOuw6vCm8KBw5jDkVlPXHUwMDBmb03Cj8KDMcOvw6dcdTAwMGZxeEFhw4FcdTAwMWbCncOvXHUwMDFmw6t2fF05eMOjOF5DwphYw73CnSPCn8KGXHUwMDFhwpNVJFx1MDAxMlxcYsKcIVx1MDAxM8Ocw6jCq8OOw63CgcKow7zCgsKsYDtxwqlcXHRJSSt2woxbwpDCqEZxwqxqXHUwMDBmw7JcdTAwMDPDtsOOw5lGwopcdTAwMDTCkFnDmMObN1vCg0FcdTAwMDPCsFx1MDAxYSVcdTAwMGXCjsOQa3FcdTAwMWXDs8Ouw6PCmcOwwp7DrX9cXGI6woPDhMKNN21UXHUwMDA2w5bCqVHCgVxcXFxmwr7CkGptw6HCg8KpPUBEb8OcwoNOK8KrW1TDszY9SsKwPMOTw69cdTAwMTBIw4PCjjdcdTAwMWPCuWo0w4NUw6BcdTAwMWNwSS1cdTAwMTXDhFx1MDAxYyXCl3ZLXHUwMDAzw7ZcdTAwMDZcdTAwMGZcdTAwMDFcdTAwMWVcdTAwMDNcdTAwMTLDp8K4XFxmwr5swoXDt1xcXCIpZMOKwplcdTAwMTJbwqdGw7NcdTAwMWJAOsK8w4DCicKNw43DrTdawoXDqMOMT8KKw71cdTAwMWXCkcKTJ8KywrnCmHQtw5zCt31cdTAwMTA9TcOEXHUwMDFjw7lcdTAwMDTDikNwPUDDicOfXHUwMDBmw4PDi8Ouw6diwpXDvsOfSMO+XHUwMDE3w68twr13d3rCpj7DscKdXHUwMDA3cCg7RMOnwrnDuMKjwrjDrsOaw5Aqw4DCizLCilNcdTAwMTDDncKcLFxcdMK6wqlWXHUwMDA2w5rDicKTwo7CosO2w4ImXHUwMDBmXHUwMDA2XHUwMDE5w5xcXFxccsOvMMKNw7PDm1x1MDAxYlozw5FQezlcdTAwMWPCuVLDsMOrYMKdw77Ds8OCwpLCvMKLXHUwMDEzwr1nw7NWUjLCrcO7wpHDlcO1ZcOFw6rCklx1MDAwNFx1MDAwM1x1MDAxNcKnMMOIwqvCvzLCglx1MDAxZipvLMK0XHUwMDE5wohdw5xHN8OeXFxmw45cdTAwMWHCpjEmPUDCtCtZX8O7wrBGw4s+VFxcZsONZcOjw5xLwqhDw4vCt8O/w5TDsMOWwpDDl8KRPU1gZcKAwoUuwpzCvsOcTsOEwoFcdTAwMTfClcKOwqFcdTAwMTXCm8Ktw49cXGJawpxiN8OtwrHCv8OAXHUwMDEyO8OMXHUwMDBmTXjDhkDCsmLDuVx1MDAwN1xcdlx1MDAxYznDu1x1MDAxM8OFXHUwMDBmXHUwMDE1wqVhw7RVwqE9fcKIXHUwMDFjw4F8wrtcdTAwMTU5w5hcdTAwMDLDh1xcdsK4w4zCu8OOwqLCjsKtXHUwMDA2dsOQw7cmS8KGwocjcStMNWFcdTAwMGXDpWrCicOtwrvCpsKZXHUwMDAywr9cXHTDsifDtVx1MDAwNlxcdFx1MDAxOMOaXHUwMDEwT8OeJHTCncKCw4bCij5RNMOWw45cdTAwMWZcdTAwMWVcdTAwMGbCkMKCez5cdTAwMDTDj8KQXHUwMDAywpc7YFx1MDAwNMOFLMKXw7rDt1x1MDAwNlrDhFbDqcK8wpkuw5DCqsOsXFx0w4fCt8OFSMOrw57DoEh8wqjCpFfCp1x1MDAxMS5dwo/DpWLCicOzMVx1MDAwM0fDm0dAbMK3esKYw4NlVcKAwrQpV1x1MDAxNcKnwok5wojDiMO/w6ZcdTAwMDZcXHTDtUlgw65cdTAwMGbDs8KhwpE/XHUwMDBmMcKFw5LCpGE/XFxcImFZXHUwMDEwfcOmw5HChMOwXHUwMDA2w7ZrXHUwMDE3wo/CtMKOwo3DjTlcdTAwMDN/eDrDvkrDtsKWw4DCocO0wqbCmcOAwpXCqMODMcOxw7VwaCvCkFx1MDAxMmzCv8OAwoDCg8OhLmTCtFxcdCTDosK6XHUwMDA3PX1cdTAwMTVcdTAwMTNcdTAwMGbCgy5GQMOsXHUwMDA1w51cdTAwMGZcdTAwMDHDl2VcdTAwMTnDmsKJeMOGw63DkFx1MDAxNDfDkcOEc8ONa0LDmlx1MDAwZVLCtTnDs1x1MDAxYUDDqcOgPsKIXHUwMDFlwrhTXHUwMDExXHUwMDFhJ1IxwqXCj8Kdwo1nJ0zCl0h0wpLCg1DDsiYwWWBcdTAwMWNMfFPCmMOuw4HCkW3CiXJcXFxcw5/DgMOoXFxcXEXDim16wpLDlMOmXmFSXFx0w6oxLcOCwoXChDZcdTAwMDXDi8KNw4RCI8K/w6Vvw7nCgnnCqcKTWMKBXFxmw4Eow6JQw47DgDnDmsKmXHUwMDE5wrFfw5vDq8Ogwr/DrEnDkcOBw4RDXHUwMDEyw4zCh8O/PUpcdTAwMTDDucKzK8O7w7fCv1xcdMKQwo/CjsOfw5RcdTAwMTTCpVx1MDAxZl3Cnlx1MDAxYlx1MDAwNsKkJGTDgFdcdTAwMTfCgDk0woZowonDvsONeGPDq8Kiwoggw6EnXHUwMDFkwrbCuMKUJ1x1MDAxZFxcYlx1MDAxY8OTw4vDocKhXHUwMDE0JsOKwqbCn8KMwprDmjDDjMKmc8KrU1xcXCJcdTAwMDTCj1xcXFzDnMKuw6DCg8OzOsOPwox1w5jDpsKuw5HCtlx1MDAwZipgPUBvacKXQWDDnsOvwqzCg0hnw4t3YcKHwrswwohcdTAwMTnDlVbDvcKBKlxcdsOuw5VcdTAwMDLCncKxwpl1WcK5RMKTdcKMw7bCglHCiFx1MDAxZVx1MDAwN1x1MDAxYsOMwovCkXsqwpPCpMOTXHUwMDAxO8OEwoBcdTAwMTRfdMKPPU3Dj8OEwovDsMK1wobDk8K0wqZcdTAwMTMnb2TDm8OZOVfDvFjChUXDrsKPw4TDpT1Kwp/CrMOCacOKPjJTLlxcXFzCr1x1MDAxYk/ClcOfw5/Cs8KJK8Khw6lcdTAwMWEyL8Onwod4dcKKw43Cu8Ozwp7CrljDkMO4XFxcXMK7w5HDg0VcdTAwMDV3wpbCjEzDg3hcXHTDjMKiXHUwMDEywpbDqsOiXHUwMDEwYVrCmsKXMyPDt8O9a8OCwqvCvsOew7zDiiFVPUDDl8KmRcKWwq3DpsKsw6I9QDjDjMONw4zDusKrw5/DnFxcdMOZw7fCsExcXGY9TcOJRlgpw7/Ci2fDpWbChWBcdTAwMThxwo9Ww5lGWCnDucOtYsK2eldlwoxxwpnDt8OcRUpmMHtcdTAwMTFrwr1cdTAwMDHCkcOTIMK/Z1x1MDAwZjnCmMOMw65cdTAwMTFcdTAwMWLCq8OSPUDCpCTDsCzCuVFcdTAwMDJcXGbDvcK5WcO3w4BcdTAwMTlcXGJmw6BDw7tRSMKhw5RzPUrCp8K8wrQ9fVx1MDAxZHR9XHUwMDFkw6nCnH9ZwrDDk8K6XHUwMDAywqQkd8KOWVbCpWcnJ8OKPUDCmMOZw6fDjsO4w6jDscKtQcKfLcKUJ8Krw5hZeMOqZWXCnMKOfMOXwoJcdTAwMDHCosOQLFVcdTAwMWFcXFxcw7/ChcOLRlx1MDAwZcOPW1PDtsKEwpHCkcOQS8OtS1DDh1x1MDAxNMOPw4DDkcOwb1x1MDAxY3PCi1DCsMONTlQ2XHUwMDE0wrl4w4LCvXrDtk7DnF5RTWDDmlxcdkdRJiTDgMOYwoljXFxcXD1KwpnDjsKQw6DCq8OHU8KEXHUwMDE1YyvCvsO9woQ3Qlx1MDAxMcKew4LChsKBw5XCjGTDsHzDilxcdMKLwqNcdTAwMGZcdTAwMTU0SsOhw4Mjw5JxPU1xXHUwMDEww5LCmlnCjcK3w5ZcdTAwMDbCvsOjXFxiUV9cdTAwMDPCu8K7w5fCs8Knw7MvN1PDpmdlWn3CplxcXFzDpFxcXCLDqGFlMsKlw7VOw51cdTAwMTfCucK0wrMtwrbCmm3CokFcXHTDp2XChcO3NsOdY1LDkF5dwrBPwqJMSGDCo1pbXHUwMDE0eEVOacKqw7HCv2nDhsKfXFx0wrtcdTAwMWTDn8KhwpFXNm3DqnJdO8K/XsO1SXpuwpDCtcOQwp1ZwpfDjS3Cplx1MDAxZsKQw4NkwrTDhMKPXHUwMDEyMMOaw4UmXHUwMDEwW3tcdTAwMTlYw4bDscOwak3Dlj1NTi7Cm8Owwo1Yw7HCoT1KTVx1MDAwMsOYwpPDpcOzw63Djistwq/CpiEpwrVxMMOww5rDg2LDt8OMJsOCwp5dw55Twq5cdTAwMDFcdTAwMWU/K8KUwq1cdTAwMDdbdMKGLlx1MDAxNEJcdTAwMDLClktMWHZcdTAwMWHCmcKZalhhMVx1MDAwM8KdXHUwMDFjwoVcdTAwMDFcXGbCrcOBwqPCmlx1MDAwNFB+wrdNSsORwq5YPU1telx1MDAwM8KOw4PCuMKkXHUwMDAzwrDDlFogacKGOlx1MDAwNVx1MDAwZVx1MDAxMMKFXHUwMDFicE7DgjdVc8KEw4M5V03CjkXCv8Kaw7LCgVJ2JDxEworCk1xcXCJSw7bCqUVabUXCn8K3JsKoI8Kyw6RAw4/CuD1Kwr4xXsKUK1x1MDAxOEfDkTNAwpJPdkl0XFxiZMObw4jDjD5cdTAwMDInwqHDosKpO0fCmC/CgMO7w75Qw5rDuWDCrcO8wobDmllYXHUwMDA0e8KRXFx0XcKsw7rCjsOpwpvCjU5rw5HCsynDjVx1MDAwZTTDp8KoXHUwMDFmwoDDmMOMXHUwMDAxYcKeLXDDpsKlw5XCucKcfMO0wq7CkzDCvUVwT3A3RcK5PklBw65hwqxMw71cdTAwMGbClcOdLVxcdjlKwpPCqMO0wp5qXHUwMDAzWyfCllRpO8OQw7rClsOWw4rDgC5cdTAwMDdrNsKXT3YzwofCmjDCtSPDncObw6pwSDvDmzfCtXg+wqfDi3Riw61bRClcXGIzVznCizkjwqTDjzDDisKRwqN6NVx1MDAwMsOywr3DsyXDrCTCg8OxXHUwMDE2dMK1w6pGw59Pwohbw4bDsFx1MDAxY1jDglx1MDAwMsOBw4TCrSY7wozCicOXwoNcdTAwMTN4esO6w5xMwpfCmlx1MDAwMcK4ZFTDvcOIw6MjOHJhw63CtMOCwro7w5JcdTAwMWJcdTAwMGbCpcOMwoZyVFpRw6xIwrdcdTAwMWbCh8Ogw5lcdTAwMWFXPX3Dp39cdTAwMTZ9wos9QMK9NMOWXU7Ci1LDnznDgS1Sf8KmbMOiw77Dl8K6w7REw7fCsMKew60jw4VjVMOswrZcdTAwMGYlXHUwMDE0w4DCicKHQj1Kw5VcdTAwMTPDgFnDq11OdMO8JVx1MDAxZENjUn9cdTAwMGZcdTAwMWPCllvCiS9uX8KDw4zCiMOCY8KVw7tjXlMhS0HDk8O+XHUwMDE2XHUwMDBmTcOowoHClmUxwrTDu33CoMKhJ8OnL0RAdVxcZnXDoCx1UjbDoMK6fkNSwoJ5wrRcXGbDvMKQw6PCnsO4IUM+XHUwMDFjRMKpScKNMcKsV8Kbwq/DkVrDo0fDhsOnwrQmVFxcdHXDuMO6XHUwMDEySMKTSykhe8KuRsOEw7Fpw7bCsjRSXFx0w6VwwpnDmXtXw6/DpMONwqTClMOZwrkqPUpcdTAwMWPDmcOYwqtRVlx1MDAxNcKXXHUwMDE3wrZcdTAwMWHCrMOlICPCjMKjPX1cdTAwMDEuw7nDkEk9QDDDl8KGw6rDi8Ofe8KoXHUwMDExw4wuw5EgOMOAYcO1IGNew5ghw6nCg8OKJHDCmcKqXHUwMDFhw5lcXHbCgUc5XHUwMDFjw4TDrcK6WcKYw7vDrsOYS1x1MDAxZcK2w43Cslx1MDAxNS5QKFfCuMKRVl1cdTAwMWTDtT5cXHY5XHUwMDA1w6V1wrTDjFTDqcO4wozDt1p9XHUwMDAzw5FWwrYywrF4XHUwMDE5esO8wopXw6I9SsOVwp3CiMO/wrZ0a2nCtMKhwoEqw7Y5RMKWwq/Cg8OSwrPDt8KMwqkjw5FcXFwiw6JcdTAwMWUhwpbDglx1MDAwMcOAOsKpX8OXXHUwMDFkLMOmWTfCi8OzwozDv8OMwrjDm3vCoHo7XHUwMDEww7XDqcK8w6zDumHCr8Krai7ChcORXHUwMDBma8KSXHUwMDE1Yi3Cp8OGbCXCkivDucOmcUMzVFx1MDAwNnbCrHTCin05aMOTw7fDpSvDtDXCgcOgwobDnsKlw4HDvcKdL8OPwqbDt8O1XHUwMDA0w7lVM01tdcO7XHUwMDE3wpNTwoTDoMOZXHUwMDAxXFxiw75cdTAwMTQzUmp/KVx1MDAwNEzCvMKQw5TCn1xcZlx1MDAxOcOzwr8ywrJCw5zCoVx1MDAxOcKGwrnDuCA9TVx1MDAxOS5Cw6RcdTAwMDXCmcOoWcOewpnCqjHCvi/Do1x1MDAxYXhcdTAwMTDCtcK0woIzRyTDjVx1MDAxOMOmWFx1MDAxN0vDpTNcdTAwMTjChsOJM8K1w6jCncOXXHUwMDAzw7fCgcKXPUrDr8Ofw77CuMOvw63Dn8OkNcOVw4TDgUtZw4B4fMKydcKCwofDs8Kbw7Q9TcOOXHUwMDBlwpDCsGfDkMKXwonDoMOeJ15cdTAwMTbCgS3DlcKLa2XDgsKES1RswoRcdTAwMDTDlMKCw7tAwrzCksOEKmHCqD93wrs9fcOESE1GY8OcesOxwpbDrz19wqM7w6pJwptcdTAwMTEvXHUwMDA0w6dCwoDCsVTCsXc9fcO/wpQ5w6/DoFx1MDAxZsOcY8K/Ok1cdTAwMDTCkEZIw4koT1xcYkHDo0DCqlx1MDAwN8O2wpXDl8OCKsO3wpHDpsOpccKKXFxmwqzCpcKfw7LCmsOCPU3DjMOvPX3ChMOIQ8KVXHUwMDA1wonCkznDn1p7w65QLMOyfsOWwpzDmFVpQsKAw78la1x1MDAwNcObw4/DrcKdXHUwMDE0XHUwMDFmw7ZKwonDjCPDg8Kaw5fDkGo9QCo9fcO6WMOEwrZcXHRcdTAwMTDCrMKpVsOhw6NMXFxcIsOLXHUwMDExNMKDw4rCsmlcdTAwMTnCr8KtXHUwMDFlcVx1MDAwN8OQwoDCqV9cdTAwMGVhNTMwZHc9fcKsw7BBwo5cdTAwMGZcdTAwMWLCrcKfQMKpwpB0w5TDo8OaL8Kuwq3Cq8Oew6AmcFHDkCYlw7zCrMOQwrRiXsOlLn7DhUNcXHZjw7RhNcOPd2dcXHbDmMO5w4d0XHUwMDEyNsO5w7jCjz1AWMOtQnxTw7TDqC/Dh8KDfWxmNcKORMKtwrN3PMOba8Orw79cdTAwMWVXw5XDosKMXXjCs1o6bcKiJTUxPX1IwodeXHUwMDA1XHUwMDFiTMO3dMOPXHUwMDEywrfDhFxcdCsxw7h/wq3CjcKuwqHDsMKiXHUwMDBmw6dcdTAwMWHDvMKXwpA/wqrCsFx1MDAwNcK6w54vc1xcdEvDuyDCksKuwqrCo0Fuw5NcdTAwMDLDo8K2w6HCgsKJXHUwMDA1w6lQQcO6wr/Cklx1MDAwMiTChsKww4HDs8KHY1xcdltUw6HCslx1MDAwM8KnwpNgJTI5YsO1XHUwMDEwwqBVwrkowqrCisKEwrPDs8KYXHUwMDAzw6LDpyDCl1x1MDAwNTxcdTAwMTVIXHUwMDBlwrB3KsOjw4/Dp8KAwo5PPU3DpsKswozCrVx1MDAxY1XDncOgwrJHUMKUwpjCisKWwr/Dt2V3woLCkXLCksKSw4PDiMKRPmhFPU1LwrpXw6xSJVx1MDAwM3HDjMKmXHUwMDFiSMKSPEfChsOGw4Bgw6dPXHUwMDE5woPDh3NlXHUwMDExXHUwMDAxwr9KI259XFx0wqPDocOIXHUwMDA3XFxcXMOUwpPDqcO6MDQzaT19w5VAXHUwMDA2XHUwMDE1wq0kXHUwMDE5QDZsw7TDgFxcdF5AVk3Dt1x1MDAwZlx1MDAxMMO1w53DsMKJOsOVUG3Ci1x1MDAxNURcXGZlw4dcdTAwMWPClUfDkFx1MDAwNVfDk8KBw6RcdTAwMGY/VsKGU1BCc0didFx1MDAwM1UzW8KEU8K1wrxrw5t5w6jCvD19asO0XFxmKlx1MDAxMlx1MDAxZWPCu8K6w6JEw5ZcdTAwMTTChmPDpcOLXHUwMDAyRVx1MDAwNcOOworCgMKcwqxHw6xcdTAwMWMww7Uxa8K0TU3Duz93SsOLwpZcdTAwMDbDr8KyNcKQVHA9fWQ/w7tcdTAwMWLDrcKzeMKFwq4mwp3DjDVkXHUwMDA3LMKEwrTDhcKsUGjDl2jCtlLCtMOkXHUwMDBmwoVgwobDk1x1MDAxYsOZw4VwwpVMeGXCv8OuUsKWWsKUw45cXHTDiibDhEFcXGbCq8O+M8KFwobCk8O9Oj7DhcOawownwrZxL1x1MDAwNMOFwqFOw7nDrm9WwpdDL8O2IFx1MDAxMFUnJzlcXGI+w7RcXGJcdTAwMDVhwpXDuFx1MDAwN8KLwopqw4M9fcOBw53ChsOgw5Amw4ZcdTAwMDLCuj1AwpNKXHUwMDA0S3w+wpdTe1YlXHUwMDFiS0LChVxcXCJ4w5xxw6BGXHUwMDBlw6trw7/CpcKHYnxTwrzDoVx1MDAxYcO+WiRcdTAwMWZcdTAwMDPCjMOpXHUwMDE1dy/DpCXDoFxcdFx1MDAxY8KENMKGw5VBwol+XHUwMDE5w7Z0wqbDuDjDhlvDtsKZXHUwMDAxJsOhwqBcdTAwMTE3wpHCrkREw7DDoXHCglxcZj19U3vDj0opdHPCvUJVXFx0w5w7PMKyeVp3w6EmwrjCgcO7wozClcO1woBcdTAwMWQ0L8KSPCHDo8K6bMOKLMOrw48zPj4ow4hfRsOYw4fCvsKDwqtWwq/CnFx1MDAwMlA/SMK+w6kjw7zDoSjDgsOXwrMpJ8OpI1x1MDAxMcKJwo/ClSxcdTAwMGVmwrNLw7jCsMKyw4xcdTAwMTLDqjPDhcKYScOWw4NDYCbCpmnDtj9KWsOSwrV5wpzCqGXClVx1MDAwZSXDhsOcw4PCkl3DlcOKwpZTwrlcdTAwMWTCjz1Nwo4oXHUwMDAxw4JcdTAwMDbCoz1KZkI4KsKnI8O2Q8KgwojDjzbDl8K4e0vCjWTDqjzCk3nCoEPCtGTDikvDu1xcXCLCrMOGwqVrw6XDnHdKNMKtXHUwMDExw4k/I8OCIMOAwqrCulxcZmfDmlcjPUBkw5HCtW97bsOYScKaU8O9wq92VcOtT8OdW0pSwpDDssKaQMOLQcK5XHUwMDA2M8OiwojCnVM9fVTCq8KZw47ChyjCr35HwrgrdMO/wqvDmHpcdTAwMTdOQ1x1MDAwZcOUwpzCj8K7XHUwMDBmwq7CrcOIXHUwMDExw4tvOMKuw4DDoMK0L0BcdTAwMWJaXHUwMDEww4/CrMKKYcONw7E0wr/Cv0DDrcOzwr/DiMKzfcODXFxcIsK2f2xLSsOre8KBw5U7XHUwMDAyXHUwMDAyPsKIw43Dmz/DtmA9TcKLRlx1MDAxMXhxw4HDi2LCoH3Cj8KcwpjCnMK/w7PDl8K2wqU9TcKmwqbDkMKkwpg2wrTDhVLCnMO9RcKLXHUwMDFiwrfCtVEgw6ZcdTAwMWVcdTAwMGZcdTAwMWNcdTAwMTHDq8OeXHUwMDE0wodcdTAwMWVcXGJzwoHDn1xcdsKvwoZcdTAwMWJmwqXDnlxcYlx1MDAwNMKwXHUwMDFhO1xcZsKuwovDtsK2w5rDnWfDrG9FXFx2w4zCtzpoWkRLXHUwMDFmwrBEwo7DlWbDtkrCk8OwfnlcXGYvw47CtFx1MDAxME3DjMKRPyErw4LCsMKowpXDvn3Cq3ttw6svQEBcdTAwMDc7wp9cdTAwMTUgw4wqw5TCosK2wo3Ch8ODY8ODWcK1wrRcXHbColx1MDAwN8OKPX3CsMOoPU09TcOWXHUwMDAzw7hLw5ZcXHZcdTAwMWbCm8K1PX07w4PDhsKrM8KdwqVqcUHDu8OSwptwSjTCml9cXHTCu8Kew6LChjTCoU43wpdsw5hcXHZDfMOawr3Cm8K2woJ5w6TCvztZw6TChlxcdH5VwptaL8KjMk3Dt8O2MVnDv8O7wonCtUfCqTPCmEhDwqzCu0huXFxcIiU9fVx1MDAxYVx1MDAwNDs5wrJswq7CnD1AUcK+w43CisKObMO9MG3DocOWw6s3L8OfPMKEw5lcdTAwMTfDs2LCt8OsX8KQNMKfwonChClcdTAwMTTCkmDCs8OIXHUwMDA3wplcdTAwMWLCu1x1MDAwMTjCtG/Dt1PDskhcdTAwMTF+XHUwMDE1w57DimPClyXDhlx1MDAxMFx1MDAxOcOJw73DmiTCqsKkwoHCvT1KwpdmwqhcdTAwMTDDqkXDtW5cdTAwMTjDuz1NworCsncvQMKSYsOhQlx1MDAxOcOuwonCpyolw6pCwp5GPUrDlFrCikJAw5zCucKxLcKQwqtIdMKIdMKgfMKHb8KCwpxzw5zDq8KPLV5Fdy0+XFx0K1x1MDAxNsOgOcOaw4TDhFx1MDAxYsKrwqzCojTDgD19NsOYwrlWwrjCsMKYwq0+KmB8SVx1MDAwNMOsJ8KNbcKNwpvChlxcXFzCp8KbQE/DvkJcdTAwMTTCqMOsw6vDpsOgOMOhwqszwrHCvDhfw6LDnirCsHUtworDosOOw5rCjVjDn0bCtsObwqLDjC9bXHUwMDFjXHUwMDA2wo1/VnzDr8OSfVxcXFzCn8O7U8KUXHUwMDAzXHUwMDExZUjCsVx1MDAxZMOhZzJYw6hcdTAwMTh/w5knwobDqMOnwpjCmcOpwrjDlcO/w6vDuWPCpFfCnMK3w5nCp8Kyw6bDuMOgwonCtcKDw69cdTAwMDHDuMOWdmLDqsKXQcK7W8Kaw55vw7fDsihify41wpckwpnDkMKQw6nDisO+XHUwMDEyw5tpbsKKNXjCiF1nwpJVw7h9w6p+w77DtFbCnMOhOjtSKcObWsKhUsOjMMKHwqzDtcKUw4hcdTAwMTXDnMOGXFx0w47DtXzCqMOVWMK1I8KXw6TDtlx1MDAxMXHCn8ODw7c5XHUwMDEzwrxcdTAwMGbCoVx1MDAxMlxcXFzCv1xcdMOTdWnDqXXDgcKzJsKYwodkI1vCh8KEIyfDpF5cdTAwMWMxwp5zXHUwMDFkwr3DpMO+XHUwMDFjMU1gaMOUw7hpPyBTcMObw5PDtcKoPUDCtMO1az1AwrTDtTs9QMK0w7XDh8KgwrDDr8KNw6nDgsOIMWHDrMORXsKNYGs5JCZcdTAwMDNMSEFRwowvwrlAwp1UwqHCvMKTw4ZcdTAwMWR8UcOnfnnCuUk9SsObXsKXSGk6UcOJwpdiwr7CmFxcYlx1MDAwN8OpJ1x1MDAxOMKowqnCkXLCqMO2w47CsWdoYMOUw5zCkHxTXHUwMDA2w6cnXHUwMDE4wpjCqcKRSCPDpcOgw4dcdTAwMWLCocK3w5QuWz1Nwp1cXHbDuFx1MDAxN8KhwqEkZcKNXFxmwqHCll1cdTAwMWJlcH/DgMOGw6tJXHUwMDA0wqjCocOSwoxcdTAwMWE1wqLCm8OGJ8OsWsOhw6zDjcKPwpBIwoHDv8OEIcKEccOhwpXDs8KDXFxmV8KUVcK3wqHDocKXw6nDpcKXXHUwMDFlw5hcdTAwMTlcdTAwMTnCmFx1MDAwN8KowqFcdTAwMTVcdTAwMTJHwpFcdTAwMThcdTAwMWZcdTAwMTjDkFx1MDAxN8KhYcK3XFxiwpvDpHBcdTAwMTlcdTAwMWNcdTAwMTfCoSNcdTAwMTLDhz4/XFxiwq9cdTAwMTfCoUvCuGrDi8O0wrxtW1pcdTAwMWFicMK4dMOmwqHDtjTDqMKxNXLCkTzDi1xcdsKaXHUwMDA2ZsOuw4JYXHUwMDAyNGxcXGY9TXvCpltcdTAwMDJdQsO/XHUwMDFjaG87wpg9fcKawoDDuTJ1w5zCkkNhwozCj8KEw4PCg8KPUsOew6IrcSNbSsK0woJcdTAwMGXCjMK0XFxiXHUwMDA1wpvDuW86w6chXFxiXHUwMDExd8ODwqQ5OcOzU8KdbcOyO8O8PUDDkzTDusKdOFx1MDAwNlx1MDAwNnPCjyVKW282w5tKw5BaV3VuN8K0LcOYXsKLw7nDhTzCtsO0Lk80TsK+a8Osw4UpOnF7w6lwQn1cXFwiwo5cdTAwMDJBXHUwMDE1R8K2O0tcXFwiJ8K0w5zDgGfCtMOYwq9lXHUwMDFhdFx1MDAxYVVFR1x1MDAwN0o5w4lgbcO2w5rDnMKccyDCksKOIMK/XFxmdFx1MDAxNsK6w4ZZwodbwp5DwqDDoD8xXHUwMDE0wo9uwqxAwohSwoRrPX3CgsOpwqXCtsO0woTDmEjDuUHCpVx1MDAwNkXDszB7w6EmcMO6JsOFXHUwMDFhw7bCqMK4XHUwMDE4XHUwMDE2I8KkJDfCncKLwqfCgWjDrlvCq8KXfMO+biDDssO2wr3CncOxwqZXUMKdMmHDhlLDqcOlQcOVXHUwMDAxI8Oowr43w6ZcdTAwMTjCkFx1MDAxZDvCvD4/w4lcdTAwMWPCuVxcYm3CkcO3w548XHUwMDAzwqMlW1rDhcO5woZ+TcKxNSrCgcKEw5PCpMO7OFvCmMKmXFx0wofDrcKxwpTDkMKxbylTwpBWVWLCkcKhwrTCnz1NPMKkwoJmwrRcdTAwMWTDvzfCpcOLZVx1MDAxNsKUQVZkw7FRwpvDsip7wq/Dn1XDk1x1MDAxZMOiw7fCt8OWw6lWw79cdTAwMDLDtcKuM8K1L8OLQlx1MDAxYsOWw7/Ds2nCscOxTcK2XHUwMDFmPU3ClcOrdmwrw43CrcK9PUBaXHUwMDExNVx1MDAwZsOiwr7DusK7dFDDtVx1MDAxOFx1MDAxOVx1MDAxOUlbMFx1MDAwN8O1w6XDk1x1MDAwMsO/w5kvw4dcdTAwMTTDqsKjwo/DhsOPJsOww4nCh8K+w5bDmDRcdTAwMTTDkcK6XHUwMDAxw6x9w5/Do8ORXFxmw6DCn8Oaw61iwrjDtD5cdTAwMDJcXFxcwpl0XHUwMDA1w7J8S3LDmsO2w7bCusKnW0k9SsKQO1JkI0vDpsKjV8K5ZV3DmMOTXFxcXH59cCHDiMKNw74sworDjsKqwrLDrHt5d8ORwovCmcO5worCpcOZIFpcdTAwMDTCjcOhJsOESznDnSM1wpJsUcKNRsOawpNcdTAwMWHCllB5wpIow4RSXHUwMDE4XHUwMDA0O8OXRsOHwrDDlV7CkjDDmsKoVcKmwp/DjsKgdsOuwrfDuFx1MDAwMiPCo3N9X3vCm8OBUsKawo9hwoHDusKXPUrDglJcdTAwMDPDnXFHw7VIw7DCpVx1MDAwMcO9wrNgw4PCgsKJw7HCj1vCucKUw6LDp8OPw5RcdTAwMDZyw5zCscKPMsO3dWPDnsOyw7rCm1EvwpXCsX3CjFxcZlTDlcKUwqzDjcKDw4vCr8K0w6NcdTAwMTPDhMKuVVc9TVXDqlxcdndnXHUwMDA2TcK8XHUwMDAzRVx1MDAwNzrDondubGnCqkJcdTAwMTjCmk3ClVjCoFHCicOCwpYqQT1AYsK3w6DCr1x1MDAxZsOHwovCucKuXHUwMDFmw5xYw5XDksKAwobDgFx1MDAxZMKnw6RWXHUwMDBmMcKewoNuwrrCncODcUc9SkzCh8OBdcOAwonDlcO1PihkWCcmQMKHUHotw6LCnjojwobChMKywqZYN25ow4E+wrvDucOPwrDDssKhVMOodcOHTVx1MDAwNsKHwoLCnVx1MDAwMzlZPU3CnHoxwoJPw5bCi8K0PD1Af1bDmnPDvsONRVxcdlx1MDAxOMK7dsK3bMOyMjxcdTAwMWQ+QVx1MDAxOHsheHVCw5s4wo3DrMOywo7DlVx1MDAwZXrCvsOXezh7XHUwMDBmw5rDtcKHw7PDi1xcXCJYw7RLwqBfwoYuXHUwMDEzMsOvw6Ayw4zDtETDtcKNwobCqVx1MDAxZVhcdTAwMDRPwq7Cl8OGNcOhXHUwMDFhw6JcdTAwMTnCucKZQ38zNFx1MDAxM2JBOMKYw6llYlDDlMOZXHUwMDA3QMKQXHUwMDAxwrjDlG57w6fDpCfCmMOfPMO/Slx1MDAxY0ppwo7CjCTDmHR2fU3CtMKTwrvCp8OWS8OUIT1Aw4zDgsKow4lcdTAwMDJeWcOlw6llw5onXHUwMDE4w6pcdTAwMTLChz7DvSXDoFxcdFx1MDAxN0XDp8K1wozCpMKLJVx1MDAwN8OsXHUwMDEywoc+w73DtVx1MDAwNVx1MDAxOcKGXHUwMDE5J8KhQcO9wrFcXGbDnEh9wo3Dp2vCm8Oywo9cdTAwMWbDi8K7w5ZcdTAwMTjCh0/DlTlcdTAwMTPDg8O1wpTDglx1MDAxY8ObworChVRQTDTClMO1PX18M8KXbcOPw483wrJvw6R9w67DkMOPwrvDulxcYsKQbcKBM8KXw6d/wqclVUnDgSRewonDlSdcdTAwMWbDt8KvaMK5UWpcdTAwMGZgwqJmWcKxw7I4woPCmsKxXHUwMDA1w6LCllx1MDAxMcOFwpYgw5rCiDJgwqRgVsK4w5rDsSDDhk7DoMOJwr5cdTAwMTDCsnBPNsO3wo0gPFTCpcOhwqbDg8Opb1x1MDAxMsKOYyFpNsONZ8Kbwr/DvsKZwpfDusKEXHUwMDFhP0hcdTAwMTHDgHhlwoPCg8ObfMKFwpjCmcOqw47Cqlx1MDAwNsKkPUBSJcOsPX3CqMKuw6NnZkFcdTAwMTfChlx1MDAxOFx1MDAxYlxcYlx1MDAxNV7CucKsXHUwMDAzPUrDjcKkw63Ds0onwq7Dl8KEZ8KFwpVgTldDbMK9wpZFXHUwMDEwwphKclxcZk/Cg1x1MDAxZmRxw61bwqPCksKVw6E1wo3Do8OxXHUwMDFiUcOrw5rCnzLCh8KRd3jCkTlcdTAwMDXCtMKdJlx1MDAxMMOeZcK6XHUwMDA2XHUwMDFhw604XHUwMDE2XHUwMDA1OMOkw5nDisKzwqE2asK9PUrCkMO6wr9pw5ZCXHUwMDFlwqPCvVx1MDAwZsO8wrHClsKvwrI5f1xcZsK6XHUwMDFiV8KmfcKfwqhywpfDu8K4U23Cv8O5ecOMw712W8K1J8Kiw67DucKfw7hSXHUwMDFlw7dNwrPCocKWw7HClFx1MDAxMSRPwp0gwpTDg8OwbMOpXHUwMDAywpPCkT1Nflx1MDAxMUTDoMKNXHUwMDA1wpbCmcOlwpN4WsKXbj1NwpHDmsO7w5EhXHUwMDE1w67Dg1/Cvj19w6LDtcKwXsKfecOWXcKqXHUwMDEzw5pcdTAwMTBlw7XClcKzwqxcdTAwMGV4woLDuCvCoSvDsVx1MDAxY2TDkWnCh8OoXHUwMDFmwqVcdTAwMTbCt8OeXHUwMDAxwrzCsFTDl0vDuMK9wrhcdTAwMThcdTAwMDRgwoEqPU03PUrDocK6JcKnw7fCqcOyb21Ow4xcXFxcwoJfecOdw7PCmGUlb8KJwoVcdTAwMTDDolx1MDAxME7DhMK0VMOCwqtSw7NcdTAwMTJ0TCBcdTAwMTLCkFx1MDAxN8K7N8OVZ8OodDLDjD1KP8KkwrFAR1xcdMOzXHUwMDFlRsOnX8Opw47DmcKYw6hRMMKJw5p1w59HXHUwMDAyYFx1MDAxMcKdwo7DhTJcdTAwMTXDqlUxXHUwMDBlXFxiw5zCs8K6wog1XHUwMDE1wq3CjMKHw75cdTAwMDRcXHbDnihcXGLDnMOhwoPCiMKkw4HCj8OIwrVAwqrCoMOJesOkw6HChcO7wqY/wr3DssODw6pJw4bDoS7DisOaM2IzQ21cdTAwMDXCvcKPw4EkaUbDv8ORwr3CtMOmw4PCrcKfw41cdTAwMDdzw43CkyXCtcOpwpRcdTAwMTnDgsKsw6gxwqHCocK2NMKrw5DDjzzDq2N2wqzDoMO6wroneG3DnT5Ewr/Coj1AwrrCslx1MDAwM8OaS1x1MDAxZkM8PX3DrcKAJETCh8KBwq1cdTAwMTTCuTB/w4NcdTAwMTVELMKlasOuw5BcdTAwMDU6wpZBwrzDtFx1MDAxN8KdLlBcdTAwMTLCkV8yw6w+XsKyw7ggSiQsw4JrXHUwMDFlwpc6IMKBXHUwMDExXFxmw7AwK1x1MDAwZWguwpJcdTAwMTHCuMKuwqLDonpcdTAwMTJbw5LDnMKNw5lObHjDpsK4esKBfcOTw6pIw6tcdTAwMDfDnMOXeMOrPU1HI8OYw7zCuDjDt8OESyDDoFfDv33Dj1x1MDAxNsOZw4ckfVMlwqU/Xk0mw6lcdTAwMDcsXsOsRMKuwp5SXHUwMDFienjDjMKFb8KuUTbCtVbCuMK0XHUwMDFhw6glwp8wwpBcdTAwMDXDoVxcYsO+XHUwMDE4TsKuXHUwMDE2a0nDq8OMZVx1MDAwNEjDusKrbsOZbGQqw500XHUwMDE0w4pWK0ZcXHZwYMKfRMK0w7vCs8KIOsOjw5gza31QXFxcXMKqw6XCu01dQMOBbMOWw5ooS8K2wozCvj49fcKNwpVcdTAwMDfDlMOswoIzw7PDjCxcdTAwMDbCizo9QMOcaz9cdTAwMWEvw4rCtsO5XFxmw5PCmCE9fVx1MDAxNsONXHUwMDFhwoFrPX3Dp8KMYcOUwpTCiSTDm1x1MDAwNUo9TVx1MDAxYnFYV1x1MDAxMlx1MDAwNm3CjUY0w4PCpcOQXHUwMDExQk1Mw4R2UMOIw6rCniFMXHUwMDFmwp/Co1x1MDAwMnlew67DmFxcdsOdwpZ3w7DDmlFMw5LDvMOdXHUwMDE0w4FDw5IkP1x1MDAxZX/DqcOIXFxibsOrwpDDmsK5YlDCmcOwwqzDrHHDo3bDjlx1MDAxNcKlbXDCpMO3w5RXw6zCscOgw7HCilpcdTAwMTY9QMKMw7LDu8KkacOxNmZ0QcKIa1x1MDAwNMOSw5nCnsO2YcOww41BwpFhwr5Swq3DgsKPb8OQUlx1MDAxY8KBw4vCmmxuw5xcdTAwMTXCtsKxNsKlwqpcXGIlPUpcdTAwMWZiw4zCnyzCisKkw4vDtsORPsKtXHUwMDFldD19w6B3wpV9w6zCscKDwojDtcO1w5J6XHUwMDE2N8OhM2LDi8KGwohKIFxcYizDs2PDvSjDnFx1MDAwZjHDmy7CqkXDv8OYwr7CuMOtZ8OOw7dJR8Obw4rDilx1MDAxMzrDpTDDhntNMcO4wqrDjWY3XHUwMDFiwp7CoMKOV8K1L8OHR8KzXHUwMDFkwojDuMKCKsKhwp9cdTAwMTUrw74vW8K5XHUwMDFkNMKmwobCp8KgejzDssKKwqtcXFwiXHUwMDBmw6lKLMKlw6oowqrDh8Oowo/Dg8Kyw4vDucORTsOqw6Eyw7lcdTAwMTDDj8OKwoFcdTAwMTfDnMOJwp/CtMOAXHUwMDA0KUHCrsK/VcO4VGDDlFrDpSZILyTDkEMxw5LCqsK4PFx1MDAxNMKGJSNlw7XDjlx1MDAxNMKnLsOswph8w4nCnFx1MDAxZcKhwoHDosOQwpHCm1x1MDAxNHbDvMKPw4fDslx1MDAwMz/ClcKPVMO1ScK/N8OqQcKgwoNgw5vDt31vw7DDm3rCuMK4woJcdTAwMTNewprCgnVrw4puw5dcdTAwMTXDusOrwrRsM1xcXCI/V8KPw6NeaDBcdTAwMWLCqE7Dnlx1MDAxN8OiwoFObFx1MDAwMcKPXHUwMDA0IT9vw6JcdTAwMTl2wpvCjcK/wpBTw7BcdTAwMTjDocKgw7BcdTAwMTjDoT7DhcKANcORw4xpwoo+PU3Ck8OrXHUwMDE3fTfCrGZ9w4xcdTAwMWVRwoN2WF3ChsKqworDuDjClsK+NcOuw5pJYFx1MDAxZMKeYMK6XHUwMDE1IXzDjF/CscKDwqdcdTAwMWLChWTChcKcU0PCjj19KMO8bVx1MDAxMMKpWMOowqjDt8KIw6nDtWtew6xcdTAwMWPCgjPDtUrCnMK5wpzCgUbDoCfCtVxcZkTDlsKFfTRiKyfDqG0yw6Y2IWJQRiB8wqDCtlx1MDAwZkNEKCU9QFrDhTxcdTAwMTRBc8OSw57CmDogX1xcdmQmW2FYwpU/w7TDgcOOZsKmwrzDrMOpw53DgcKJXHUwMDE2wrTDlVbDlcKjw4JcdTAwMDbDtcO0PUo9fXJXw5bCp8KEwplcdTAwMTVcXFwiWsOsYi/DrcO+OMK7R3XDo30mwoXDpUNbJHvCkWDClsO9KEXCpVx1MDAxM8KSbFxcdlx1MDAxMD1AY8KRfMKeTMKvXVMyNcKFIFx1MDAxNnAxQn9cXFwiwrhcdTAwMGVvUcK0W8K8PUpSwovDvnfCjXFKw4XCr1x1MDAxNiPCm8OCwqUnci7DjWdmwqzCusOewqk9fcO0woLDq1x1MDAxN8K1PUrDmyTDplxcYnDDlcKyb1x1MDAxZMOdXHUwMDE2wpwyw5dJXHUwMDFhPUDDo8K2OEhcdTAwMTZcdTAwMWNcdTAwMWRaZMKCw5PDrmzDpW7CqWFyw4rDqFx1MDAxM1x1MDAxMcO6XHUwMDE3fn95w7kxw69YXHUwMDExw4TDhGvDpMO7wovCssKoI1x1MDAxNTBqw5rCjz7CqMOpw5JOw7bDkmNvYlx1MDAxNlvCkcO/wqZOOMOePUBcXGLCq8O4KMOXVcOOXHUwMDAzw740woNjwo1HZMKOwqcnWsOIXFx2w7trw6nCmsOnJ8OiwpDDqlPDhlx1MDAxNSNcdTAwMTMjN8OcRTpaXHUwMDFiXHUwMDFlwrrCgsOGw5BcdTAwMWbCpHLCrsKpZMKRwo5cdTAwMDNZXHUwMDE4V8KJw5PDiX5cdTAwMDbDklDDrMOMw4vCl8OZwqVcdTAwMDHCsMOcw6HCg8KSU3HCsSXDnkbCnXHCj2VcdTAwMTDDqlx1MDAxY8KVwrbDvMKGXkc2KnzDtMKHwrQswrl4X8KHwpk7TTtMwoDDq8OSw7pcdTAwMWNawpJKXHUwMDAxwoPCkEvDlHA6w7HCgMOuwoRsVsKQf1x1MDAxOSpgXFxiJcOSXVxcXCLDnnhywpRJwprCplxcXCLDiFx1MDAxNcKqwrbDimVRw687wpTDtz19w6VDRsK2PU3Dt8KlwpjChMOiXFx2IMO1w6nCp1x1MDAxOcOpJlx1MDAwMsOpKMOVPX3CsShcdTAwMWVcdTAwMDLCqcODw79cdTAwMWPDscKeXHUwMDE2wpjDrVx1MDAxZMOyPUDDrMKNw6nCv2nCqD/DqMO6w41cdTAwMWFcdTAwMGbCm3Vuwr9cdTAwMTbDrjnDvsK3wq47wpzCp017eD7Dr8KcXFxiwpNxwo88w4/DgkvDmVx1MDAwNcKkwqTDmULCu1x1MDAxY8OiZsOZPX3Cq1x1MDAwND1AKMK+w4c9SsObZ1x1MDAxOGZ9XUZ7wr0jwrrCuyzDhXdcdTAwMDPCrsK9fsKow4R5I2ZWw4vCiMOqw5vDo8KPw7vDh07DgjNAXFx0O31RwoNcXGZvT8Kpw5J4OX0+w6TDm8OmXHUwMDA1w5HDglx1MDAxN8KIXHUwMDE5ScORwpPCtcO+IEZcdTAwMTF2M03DlsKbwpB7XHUwMDEzXHUwMDFjwoBiXHUwMDFkw5Quw4hGQm/ChFR3wrFJXHUwMDEwPU08w75cdTAwMWTDgGnDtFrDssK+w6tgJFx1MDAwMljCn1bDt09hN8K8wovDtFNcdTAwMGZrXFx0NMKjw67ChMOfPj/Dt8KGwpY0wpbDrVxcXFw9Slx1MDAxNsODwpFcdTAwMTErw6TCoMKew5t7wp9vI8OUw6Y8w7HDmlx1MDAxM3NpPUpawqDCvFx1MDAwN3w9TcO6wp/DqcO0wrNtwplTXHUwMDFkw5LDrVx1MDAwNEbDqFpUwrzDp8OzZlx1MDAxMsO2w5VRw7ZLw69cXHRcdTAwMDXDk8OPw5rDgMOKS0XDulx1MDAxMGrCs3RXwqPCmXYjcsKQwpXDt8K0wpx0VcOnVsOKXHUwMDA1I3hdw5nCvsKvXHUwMDA3w4Riw4vCjn3CmVV9c8OXIcOlw4fCnnw9fcORbsKMdsObw5w0NMK1XHUwMDEyXHUwMDFlw5DDhMOgw7wneMKrwo5cdTAwMTRRKHLDuVx1MDAxMlx1MDAxNsKRJsOrTndcdTAwMDPCuVx1MDAxNcKVV0fDlX/CvFxcZlx1MDAwND4gw4BcXHTDt8OMwpLChVx1MDAxY1x1MDAwNHNcXFxcasK7KkDDhsK3VcOOwo3CssOgbMK4w6clZ1xcdsKCw4k/wrZxw5zDssKfwpJjScOyw5J9w496w7vCksKywobDkz1NJMOfXHUwMDBlw7jDgDByw6N9w5bDrMOUwo/Dplx1MDAxZcKOwo7DgMKtw7bDm1x1MDAwNTnDk1xcZlbDoHZVw7TCnMOQw4bCkMOAw6nCgl9cXFwiP8KJXHUwMDE0w4HDlX/Dhlx1MDAwZX49TSXDlX3Din90XHUwMDE0w59cdTAwMWVXwrjCusKywqlVTnXCjMOuwrPDulx1MDAxY8ObwrrCpm3DtFvCg8KSwrDDjMKpIcOXw45cdTAwMGVzbVFcdTAwMWRcdTAwMTZrXFxmwrfDtHXCmCbDjibDkVTCqsOUWVrDnXNcdTAwMWPCicOVw4LDnMKhwqRMQcKtwp0lw6PDvGclXHUwMDE1wqNcdTAwMGXCqsOHwqDDtcOAwpYgRsKuXHUwMDE5PMOQw7TCm1DDicO2e8KcwpfDncOnwrZhXHUwMDAywrNcdTAwMDY2woh4XFxcXDXDuX5cdTAwMTnCq3UufVPCgVVcdTAwMTVfwozCq1xcYjdcXGI0ZUzDlcK6w7ZXwpVcdTAwMDF5PUAtwrI3QcK4T8OMwqvCiFbDncOQwo9Yw6DDhsOudMKXXHUwMDBmU0pnw51cdTAwMDZyw4wke1x1MDAxOFx1MDAxMl49SiPDj8K4w4/Dj8Ofwroqw7vCsFPCqlxcXCLDuMOTZsO0JDZcdTAwMGbCrcOqw7ZcdTAwMDHDjsO8wrTCu8K5woLCgsK0IMKWY8K7SnA1w5N0TVx1MDAwNsKXT8OaTlPCg8OfVsOARXLCg2xFwo1Vw4zChsOKwptvVsOvw6LCgFx1MDAwZTxcXGJIV8OzwqXCqUjDgcKuwqNRScOAXHUwMDEwXHUwMDA3w5zCjlx1MDAwMlx1MDAxMkRlXHUwMDExZ8Ogw4rCmMOuw5xFw4BvXcK0wo9Pw53DnMK2P1x1MDAxODDDnFx1MDAxZWbDiHnDuX0owpFcdTAwMTZcdTAwMWLCllx1MDAwM3PCgcKFL2DDvlYtwr83w7vDnMKOQsK4YDFRw6DCvsO2fWN3w45xwoZ0wr/Cq8O+w7xpwoRQUMKJRVx1MDAxMXIwUsKydMKsWMOFbsKAwoM9fV0kXFxcIip2w6pAe8KWwq3CsMOtw57CvMObw4XDpMKZwoTDjsO4XHUwMDE3QsKwwqZcdTAwMWHCpFx1MDAxM37DmUZbw4FEPy7CtHbDrcO9LEEjPU3Cvi3DuVx1MDAwNcKTw79cdTAwMTfCgsObN3xzwrZnw7PDpFHDqMKZwqZ6w5hcdTAwMWbDgnDDp8OHw45cdTAwMTfChMOlXFxiworClT1KccORXFxmKMK+w5FcXGbCuMKDw7I5OcO0X8Ovw4Rfw4zCiMOMPz1KwoLDr1x1MDAwN8KbS8OOf1x1MDAwM8KHSVx1MDAxZj1KXsKEPUrCuXJcdTAwMWZHPX3Cn8O1w4jCp8Kpw4xcdTAwMTh7U8OFw41cdTAwMTTCmlN/VjnCoyPDpcKlwotzPX3DjsK+XFxmPsOOw5/DrHFZNn9oZlx1MDAwN2HCu8OMXHUwMDA0NU8hw4RcdTAwMDJfXHUwMDE3w5bCp3JoXHUwMDE5WcOPc8O1PFxcYlUjeSfCg8OoacO6WCHChMKwUyXDlnFULMOZwp1cdTAwMTjCgMOnQ3BzXHUwMDE0woxbTcK5clx1MDAxZMKPw7g+wobCoEU8LSAtXHUwMDBmf8OYXHUwMDBmXHUwMDFkwrzDksOAwrstw4VcdTAwMDPCoMKDXHUwMDE0JMK6KyV/worDhMKGw4VcXGJ2wpZrwr/DpsK4L1x1MDAwZsOAb8KSZsK1w5rDnT19XHUwMDAxwrZcXHRtw7A3QsKiw6XCjsOXIEdWworCnzFKw6DDv8OePX3CumDCt8KEw4rDuHhqw7LCrXXCgDjCq8ObNy5cXGbCtVx1MDAxZDDClm7DhFlGXHUwMDFlwqDDtMK+w7HDjSHDvVx1MDAwNlNhQVLDhMK6wofChMOVw4rDlmlcdTAwMWZdw4XChMKjR8OLw7HCsmLDrWl1wonChcKgw5Y2MT1Nw4/CpcKaRMOwdcKCL8OEw5LCpcKsWcKMLMOoXFx0w6A8w4vDoMOTbMOnXHUwMDE5w65cdTAwMDbCllx1MDAxYcKbwrXCglx1MDAxZC7Cl8OiwoXCi15bw6Q8fMOgXHUwMDBlXsO0f0zDhzTCu8O/w6LDlsOOTsOYwqV1wq3Dllx1MDAxNcKhPU3DnE/Cgn0kR8KXwpBcdTAwMTnCmsKfVVx1MDAxMcOFTMK6w7bDucKRw6jCpVx1MDAxZMKKw4pvw5LCucOCXFxcXMOUw5LCo2HDnlx1MDAxYlx1MDAxOcO+wrfDnMKcwoJGw5tcdTAwMDNiwrRNXHUwMDEww6o+wpNcdTAwMDZIPUA7U03Cplx1MDAxY0Znw5FmwqF0wprChsKzfmI0w6M3wpZcdTAwMWYxwpBNw67DnjHDgMK3wotcdTAwMWVQXHUwMDEwaFxcXCLCnlx1MDAxOcK9woQ6YD1Nw7LCtcKPMsOYwrY+dlx1MDAxNlxcdCcmwrDDnGzCi8Ogw4lVKcOxw4LDhcK+S8KIw6RcdTAwMWXDiSZ1XHUwMDBlw5lcdTAwMDbDjSggw6ZoWcKswqHDumBUXHUwMDFlw4whw4HCt8Oew6XDv8OkPUpcdTAwMDPCssOzwrtLw5jCjChsaTnCrcO1w4XDumpcXHRcXFwiwr9cdTAwMGXDuk5cXGZcdTAwMDfCtMOjwqjCjcKSUVDDqGBcXFxcwpcwTzPDn1tcdTAwMDRTXHUwMDE1w4jCmMOQw4fCp8OwRzk0wpR0K0HDrWxzwo/CgMKaw67Cglx1MDAxNWTDukrCocONw5FTw61hw5jCt8OgwqLDnkTDmcOJwozDh1x1MDAxNmbDhcOmXHUwMDE2XHUwMDFjO3nDgcK3w51cdTAwMDRcdTAwMDfDgStwwqzCv8OiwqPDl0nCnU5cdTAwMDTDvH/Co3VXw4JfaMOJXHUwMDFiX8OtMXHDhnbDsljCjVxcXFzDt1xcXCLDnDtJw7DCq2JcdTAwMWTCnMKEXHUwMDFjR8KxK8KDYsOgw4tcdTAwMTPCjcOabsKeLMKhXHUwMDE2w7UzSMOEdsOqw5w4WsKCXHUwMDEwwoXCm8Kcw7Vaw47DrlnDhsKdQWJcdTAwMTbCnsKcZFx1MDAxMTDDrsOOfFfCuCvDj8Kxw7TCjsOdPX3CgsOcwrIyXFxcXE/DmMKDw6LDtsKIwpTCrj4lwqpcdTAwMDQuwr1rM8KNw49DNkXDkzRjwqgpwpJfdEVZNz1KwprCgcOew4LCuMOHwrbCmcO/w6xkeMKtw5nChm4uw7zDmsK/w4pyVcKXw4lte8Ouw517bnLCp8OcXHUwMDA1RMOKwqvDt8KGPX1BdcKgTMOJXHUwMDFhw6QhwpbDilTDhVxcXFzDmcO/w6drw5zDhybCh8OUcMKfw7DDr8KdRsKow4PDuWlcdTAwMWJcdTAwMDdWJWIwcj1Kc8OAwq3CuCzDrlx1MDAwNsKiwqTDklfDgVLCrcKDwrXDvUpKeVrCpcKewqprRsKLT1x1MDAxOcK1dcKcLVnDnsO6XHUwMDE1XHUwMDEyTVxcYlLDpEDDncKxw4fDjcK3T8KRUcOWw5Bvw4PDnVx1MDAwMcKRc8Orwr5cdTAwMDPCscKnSnXCp8OLXHUwMDExNFx1MDAwNcOdw4PCusK8WcONN8O4IGnCg0hcXHbCgcKPPU3DiVxcXCLDucKhw4LCqMOpwo9zXHUwMDBmUC/CjsOefMKgKsKKdEBKw5TDh1NdKExtwrRcXHbClcOIPUrDmsOaw5ZEwqzDjDQwwpFfw7fDtFx1MDAxOTQnXHUwMDBmXHUwMDA2w6LCm8K+XFxcXC9PJGNcdTAwMGZcdTAwMWZcdTAwMDdcdTAwMTk4ZWLDsMKdwrvDgcODRFx1MDAxZsO6dFx1MDAxOVx1MDAwMVx1MDAxYml/woPCsW9cdTAwMTQ3JTjCq8K8w6NSwq/DqcK+w4U4wrvCniTDuMK7T0rCgMKQesKLwovDvsOaw4/CicKiMMKLU2vDkD7CpTjDmsOCZsKCJFx1MDAxM8KEwo7CiF5+wogkVcOHw7/CjcKjZTo5wpEww7l1XHUwMDA3ZsO1w4lcdTAwMTHCh8KJRMKTZzTCtcOabm/Dp8KJXHUwMDEwNlx1MDAxZS9HcSXCnVxcZm55wqUkf1x1MDAxZFx1MDAwZlLCkcOfw5Zow7VcdTAwMTJcdTAwMTRoMMOuTlt2XHUwMDEwwo1KwotIwqXCsFs6w6/DnFx1MDAwNsKqNFx1MDAxN8O1Jns0S8KowoggwobClFx1MDAxN1lSP8K7Z1ouwrbCqFx1MDAxNcKkZsO9XFxmwos9Sjdxw6opIcKRXHUwMDE0w4lcdTAwMDJcdTAwMTTCh3LCiMKywpFcdTAwMDE+IcKYXHUwMDE0JsOXXFx2woQpYMK8wofDjndUwq3DjENzXHUwMDAxw7LDtE9cdTAwMDPCrsOeYlx1MDAxOEUjw6RYwrRXXHUwMDFhPsOQRcKOw5BawqjDtEFow47Cu8K8cXc9QMKJwoXDjyxQRsOBwq17wr3Dglx1MDAwNzbCpcKvXHUwMDAzwr3CiyDCqFx1MDAxMGslwp5cdTAwMWE4w4/DiMOfdsOBwpMjwplWXHUwMDE1wrx8w7HDnFHDrsOxwofDqlRMLiZcdTAwMWRYw6FcdTAwMDRcdTAwMTHCh8K+wqNEw5nCj1hcXGLCssOYwqduNCHDscOOOMOIXHUwMDBlQ8OlacKhw6rDmsKQYTN5w6bCv0Uow6vDo8KaRsKww6fDsMKCL8Kvw49zw4XCisOGdS3Cl1xcXCLDmmXCi8O3woXDpcOAQ1x1MDAxM8KEwqc3wqt6XHUwMDAzwrDDjMKpWEfDsX7DrcOHYsKgwqTDq8O8UMKDwpzDqFxcXCJfXyMsw4LDucKhwpxcXFwibcObdcKEw4BmdWTCvMOyaSRcdTAwMTHDplYnPX3Dg0s9TcOlwqpcXHZhPsKzeFx1MDAwZWpMXHUwMDE4ScK+XHUwMDFkwodcdTAwMWRTdMO+KzZ+wr/Ch1x1MDAwZlx1MDAwNWPDusKrwrAwR8K8ecO6XHUwMDAzwojDtsOYXHUwMDFjV8Kgw4ZcdTAwMDMqw6dPSGrCuDrChGhXwrLDrEvCtjzDsFU8wpBMPX1pXHUwMDExwrLDhFFcdTAwMDJLw5LDjVx1MDAwMsKHwoRcdTAwMWNIw6hDw4xcXHRxw7dxwrU+PX1Jw7pcdTAwMDPCtTfDhy3CjWsrwozDqsOjwpfDm8Kswo0mw6PCnFZcdTAwMTbCiMOrKW0/w7xcdTAwMTQ0XHUwMDE4w6jDu8KLw60uw4bCrMOKcsKew5xNTSZSdcKkbVZxOyfCosKiwo3DnFbDhn1EXHUwMDE5woZKw4bCp8Kww4fCtWNtXHUwMDFjUcOswrZcXFwiw7HCjcKJUkg5wrnCsVFow6dcXGZjwo7DocKxw5E3wrFbwqtPI8OvaUpKP8K/w7JcXGJ+d8Khw4PCk3jCo8ORw5hlwqrDsMKYwpPCtjNcdTAwMDRcdTAwMTDChcKdw6zDtMODwqtjKFTCmGfCpEVcdTAwMTDCsMOmUFx1MDAxOF5UMjvCjsOPXHUwMDFhwpRcdTAwMTbDtjbDv8OSXFxcXG3Cu1nCnzbDvFbDgMOIXcKEw7fCuMKUwoHDkWQ9QF7CqEowV8KAwqYww7jCqVxcYsKbf1x1MDAxNcKUw4PCol59wrA5wrBGW2NcdTAwMDPCiMKJwqbDlm7Chjdlw4DCiMK0w4w9TcOySHDCmFNqa8OpwoPCnXbCi8O8ZsOVw5fCtzXCi2HDksOVPU3Ds1tBw5bDn8KJwopcdTAwMTZvw6DCisKTVVfCv8OXYMKBw5RcdTAwMWHDknPCr8K6wqpLdsOjwpFAw55cdTAwMDLCk8KHw7PDrMKcPUDCvcO5w4XDumLCoGPCiMKGLFx1MDAwMsK2wojCnFx1MDAwNMKLw5PDujcmw5fDk1nDm8KOXHUwMDFiw4LDnVhcdTAwMWTDvVx1MDAxMz19esKBwqFXJ8KIwodDLnQnf8OeXHUwMDFlwr05wq1CLsOOw4ooajLChsKnw6c0wq7DsWguMj89QMKlXS7Dnz/DvMOyaFU9QMKpbcKkXFxcIsOIMVx1MDAxNMOBXkjDpsK+MMK/wrRCwpJ2w4XDnkjDhMOOXHUwMDAzXHUwMDEww4UhJlx1MDAxNsKWJ8O4w7XCsMOjwrnCh8OYwr5cdTAwMGbDm8KNem7Ci8KUS8KTw6nCuyfDnsKRw6/CplbCvMKyw6fCtHfCsMOxXHUwMDE4I1x1MDAxNsKRacOVwpNbXFxcIsOwUcO8YsOjbT/CtMOxZl3DkcORwp9cdTAwMGXDs8OrXFxmwpvCpWwvw5PCrygkw5xcXGJcdTAwMTZZSMONw4LDqENhIMKaw7dIXHUwMDE0woXClcKqXHUwMDE1wrkjXHUwMDA3IcOOw4bCuSNcdTAwMGbCmz/Dtlx1MDAxY0lcdTAwMDHDj8OJKcKfwodkI8ORwp/Ck1x1MDAwZXlcdTAwMTV8w7XCqXzCs8Omw41Iw4vDj8OcQyMzwpBcdTAwMGXDscOtwr3DgcOtwok5ecKHOMOJOHnChjh5XVFcXHZRwps1wrHDicKifykzXHUwMDE2w5FcdTAwMWNRw609fSN9XFx2w5smwrNcdTAwMWFiw71cXFwiPX3CnkJ/wrXDosKIbHNcdTAwMDPDmMK9XHUwMDBlwqHCu8K/Y8KDw6h2wqLDicKXL1V9XHUwMDAzw6hcXFwiNy1cdTAwMGZmJCRofXVZXHUwMDE3IMKKXid/XHUwMDE4KcO0eVx1MDAxOMK8w5smw5DCo1rDjH/Ds1FiS8O5w5vDvMK9woHCvyhcXHR2wrrDsMKAw5deXHUwMDFlw4HDunIjOcK8XHUwMDE2c2PCuSbDiMKRwolcXHRhw7LCgnfCu8O4YSBcdTAwMTNiacOQw5cnJMOkKVx1MDAwNMK7dz19wpcyOMKFw49cdTAwMDPDusOrwrzCjMKAw7HCr8OQSlx1MDAwNFx1MDAwMyvDiXh8w4xhw4dcdTAwMGZcdTAwMDQjw4JmTMKaXHUwMDE0Z8OAfsOFOcKCw6Y9QMO2SEFEJ8O4w5lDXHUwMDE4cMOCwqnDtcKnXjTDk8Kiw5fDs8OZNGBDwo0/bsOIw5PDmn8oTcKPUMKDw7DCq8KUwq7DkH1cdTAwMTl8XFxiScOVw7YtPU3DssKJMsO0YDXCgGlcdTAwMWLCr8KlwpjDp1x1MDAxZj1Awo3DgcOJPUDDuyVRPUrDu2zDhlx1MDAxNMKDfsKNXHUwMDA3XFx0wp7Cj8OJw5dDRcOpK8OgZDPDlVspbSNAw6hGwqwwwprDj0Igw4VcXHbDsVxcYsKJXFxiXlx1MDAxZVx1MDAxNcKrK0AowqpcXHbDl8OZwrPCh3zDsMKMJcOaw7DDoEvCn8ONXFxmwovDscKuNsKRXHUwMDFlfsOiYcO2e0PDkl7DtsKZwpE5w79owrXCm8KaUnjCssKOw4wmXHUwMDEzJsKqwohhwrHDrn7DoC3Cu8ODwpxww4t0wr3DjMKnXHUwMDE5w5rDumstXFxmVMKRwrLDu8K4w7dUekRwwrTCsMK8dcO4XHUwMDA3w4M9fcOcwpdcdTAwMWPDrsODw5vDvjI1K3rDuEfCvcKQwr9cdTAwMTLCkFx1MDAwNXzDtC0je8KIXFx0woVcXHbCvF1cdTAwMTJcdTAwMWNfw63CksKvUnJKwr91XHUwMDEyw7vDhMKqRsKiwrNcXGZTw4HCimHDpcOsWFx1MDAwZl3Ctlx1MDAxNnDDs8O7w5TDsFx1MDAwMyPDoFx1MDAwNlx1MDAxNDp0wq3Do8KpXFxmw4gpJMOgwokkZMKOJsKQK8KTZ1xcdsOGWCDDnWVQwq7Ch3zCmGbClFx1MDAxY8Kvw4zCh8OeKMO9TFAlwoN2w4LCljsrw6dcdTAwMTUmw6g0w5JwPX1cXGY9fS/CoFx1MDAwZVx1MDAxMMKUw6TCg8K0wo5twpR6OCXChDo4XHUwMDAzI8Kvw7rCtDHDoMO7bSZ9woBcdTAwMTNDw7XCvD1AYsK1w5s+MzTDhcK8UcOHw500QFx1MDAxY1HDicOdUSfDncOvwp/Dvz19wpzDlMObwrkkOFx1MDAxMzhcdTAwMGXCiUPCjkRcdTAwMTNIXFxcIlx1MDAwZjdcdTAwMTNdw6jDtVx1MDAxMGloPU3CnD1AwqnCpnhpIMKuXHUwMDE1XHUwMDE2w7HCsMKRw4NcdTAwMDFDw7DDjEUtw7hsOVx1MDAxYsOZOsKXPHTDrWg2fMOMTlZ3w5hgw5hewqrDscOVw6vDhVZ7wprCssKbXFxcXMO9w5PCi3I9TT19KkfDvFx1MDAxYj1Nw6hcdTAwMWTCs8K/b3HDv2EswoPCo3XDlsOoUUbDrsKlXHUwMDE1XHUwMDA2wodnwoLCpMO0wo1aw6TCu8ONK8OQdMKiwr9kw7PDjcO4w60sw7zDu8K9ZsOpJ8Knw7nDiU5GwpDChsOTw4LCnyPDucOzXHUwMDExJ8ODwqlPb3g9QMKMw5fCm1x1MDAwNsKDIMK9bMOUw7HCknbCjFx1MDAxMsOzw5HCgcOsPU3DqSQhasK8wobDhmzDmS98RsOiOEAlwoR1XHUwMDAxPMKVPUDDiyHDjMOlLMObdcKbw6rCuk5VUsKxwqFCXHUwMDEwMlY9fXHDgMORw5RvUcOOVcKzXHUwMDEyw6xLZ8KtJFNiw6jDisOYw7bDp1RAwo82wr3Ds8O6a1xcdMKlMWU7V8OMw5nDuV0swqrDjVx1MDAxMiHDhMOMNcKEQ8OLU1x1MDAwNsOow6XCt8OewpDDn8Krw7fCncKNXHUwMDE2Sl3ChmDCijfDgcO3w5Buw4nCucKHXFxcIsK0wqNBP8O4w43DvX9iw6l1XHUwMDBmwojDqERcdTAwMTNjwpnDnsKFQMKFwpDDkcK8wpfCrS9Nw5/CrHFcXGLCn8K7LcOBwovCqMOtYGPDtsKjWMKRUcKwYzstwqPDocOgwrPCi3jDrsOawoRnO1vDtsKzQsOywq3Dn3c2w6JAMMK6cW83XHUwMDA2azTDrz19KlxcXCI2woJqPUrDvT19LMO/SMKpwrBcdTAwMGbDhcO6XFxmw4phXHUwMDFkKF3DpnFvW2bDnyHDicKNwqsnw6dBw67Cv8KBZm/Dq8O5e8K6w55cXFwiecK3NMKYwq7DkcOUwqzCgMKtwqzCiMONbTfCn8Onazd+P1x1MDAxNSTCsEfDnsKwwotcdTAwMTQxbMKWJsOucmTCu8KHd8KKdHdcdTAwMTdcdTAwMWTCmFx1MDAwN8KGd8KKPX1cdTAwMDTDnjBcdTAwMWHCkcOiLcOxXy5dwrvCk8Knw4VcdTAwMDbDlMOfXHUwMDA1T8Obwpc4K1HCsznCisKDP8KPcMKnw7DClsOKX8K5OTvDlMKyQFVMQsORw6/Cm1x1MDAxNjfDkMKAXHUwMDA3wqdjZiPCkyVQw7XCqMKgKcK/wpI+w7kkwr09QFx1MDAxNsO9wpBqwrNcdTAwMDTCjsOlXHUwMDE0Q8KDw6rDk8KPXHUwMDAxwoknwqVjSTJcXFxcw7HCuDjDtsOiXHUwMDAzKC49TVxcYmvCqmR2Rn1cdTAwMDNIPX16wqTChFxcXCI2Q8OrXFx2MUQ9TSvCl8OEwo3CucOsfcKiXHUwMDE3wpJcdTAwMGUzwpVQwpjDp8KZJcKFwrYqO8KaIXRcXGJUaG/Dsz7CmsKeXHUwMDA3JcOccMOWwrE5XHUwMDA1YTHDglx1MDAxNVx1MDAxNsKNPMOCw7tcXGZcdTAwMWLDllxcZkxcdTAwMTg9TWTCoMKYOlx1MDAxYn5cXHTCrVtcdTAwMTXCt8KuIzDDjjhVw6/Dv1x1MDAxZjFQwro4wobCj8OhXHUwMDE3w57Co8Kgw4XDtVx1MDAwZjLDrFx1MDAxM8OHwobDlsO9dlx1MDAxOWR7w4TDocOEw6dsLkDDqSNOUcOyKV1mw7/DncO9w4hxQsORbGnCicK6bsKgXFx0w7Y7LDFcdTAwMWXDh8KZw7XDp8Kcw5fDuMOSwoXChFx1MDAxNlx1MDAxNsKRP8Kxwp/DkU9+w57DsmbCpi5IMMKSwojCiMOMw4PDscOeIThcdTAwMDbCl15cdTAwMTN2w7TCjVxcdsKzw5HDt1xcXCJcdTAwMGXDslx1MDAxZsKCXFxmwqLClzBcdTAwMTTCjV0kPU3Dm8KDXHUwMDEywpw0w7ZUw5h9w7jCv8KEwqjDkcOJXHUwMDExwpFZwpvCg8Oxf8KyRcOlXWh5wp5Aw7U9TcOjw5fCr1x1MDAxNcOYwpTCksKSw6jDk1x1MDAxNVJvw5LDu8OnW1xcXFzCsUpcdTAwMDUrw4vCgsOASsK8YlxcXFzCpn9kwoJcXGJMMnYlakPDk2hyXHUwMDFjwrXDncKgw4JcXHRRXHUwMDE1wrIxw7NqXHUwMDFiY8KBXHUwMDE4w6RWwrtdPUDDq1/DrcKaR8KjwrtSXHUwMDFmXFxmXHUwMDE3wo/DhF9cdTAwMGZcXHTDvGk+w5DDh8KaXHUwMDEyw409fWItZlx1MDAwZsKuwo/CqU3DrsO0S8OSPX3Ds8KQXFx0wqpEP1xcdMKNw6/DmcOrw5ZcXHTCj8KlasObNTTChFx1MDAwNcKiQ3PClmTDhXkjw4jDiMKnwqTDrmnDgMOHXlhcdTAwMDZ9wqXClyFcdTAwMDdAXHUwMDEyw5LCjirDmSk9fcO9YcOLw6fCoCN/w6nDgWzCsjjCisOoLcOPXHUwMDE3w5TCmVxcZnErwpdcdTAwMWU5wodcdTAwMWFKf8OpwrXDnUxTwpnDql9cdTAwMWU9QCnDllx1MDAxOVx1MDAxM8ODS8OMwqrCsMKjL8K3w7TDr2XDkT19w54kw5jDn1x1MDAxOMKYwp5fwrjCq1x1MDAwN8KcXHUwMDFmXHUwMDE2XcOLw73CoFx1MDAxMFx1MDAwMl1CKyTCt8OkTcKtw41cXFxcdlx1MDAxMlx1MDAwNsODXFxmw6J/w4jDpy9jwrUgw5FaO2nCoUpcdTAwMDHCjiFjXHUwMDBmw5lcdTAwMTnClMOZwqzDmcKbTEFcdTAwMWXDs8O9wq7CncKqw4gvcsOlPFx1MDAwZcO0VFxcdMOLwqZsw4bCvE/CrG7DpXfDp0JCXHUwMDE0cVx1MDAwNsOiXHUwMDAywrNcXFxcXHUwMDBmwrw9SsOCw4sgSkhcdTAwMWV5flIpYTFcdTAwMDPCscOGwrtSOMKiwqfDpnHClypnSlImw611RjF6JsKZw4XCl1nDo8OCw7bDj8OKwq4jwpwqwr19bEPDssObX1x1MDAxYT19ZsKuw4LCkW7CosOLOlx1MDAxY8O0wqh5dsOaOMO4XHUwMDAzOGDDg8KRXHUwMDE2w5l8w788XHUwMDAzwpIxTjrCpsOIw6FcdTAwMTTDtGlcXHbDgMK5wo1cdTAwMTVdbMOIwq0mw7ZcdTAwMWHCo8K8RFx1MDAwM8KYTVdEw5fCg8K2ZzJ1IDAmSlx1MDAwNMOxUMOHT8KmTsO8R2ArRVx1MDAwN8OQcEE8YcKSN1x1MDAxYcKGwpHCqlx1MDAwM1x1MDAxOSjDhMOcwrXDjVx1MDAwM8KkXFxiwphOw7w9fcOZwrRIXHUwMDA3w4xoYlx1MDAxOMK3w60+XFxcXMKdw7vCozRLXHUwMDFkWjzDnFx1MDAwMUdKw4lxaHw1wrRPfMKtwqouw44xe0hec8KXJVJYMzN5wptqdmhjKcOOXHUwMDFlw7/CrsKHXFxmw7FRXFxcIiZAw4fCt3PDuDhowpvCsCfCt8KHKsOpw5HDgsKmwq7DonPCrnLCrcKZw6JcdTAwMDbDjFx1MDAxNzvCuHPDs8OgwopLPU3DuMKHXHUwMDAyUXleXHUwMDExXHUwMDFmXFxcXMO8wppmOWhcdTAwMWXDuMOkw5nCuU3CjT1Nwr5Qwo1QRlx1MDAwZVrCs8OHwr3Dm8OSV1xcdMKjXHUwMDFjS3Mpw5tcdTAwMDdcdTAwMDNjO1xcZsK+YMOtwojDqcKHwrbCiFxcdMOyXHUwMDFhwrkkwpV1fsOJw6vDullcdTAwMTfDtMKtVMODw7xEXHUwMDEyXHUwMDFkwoQsw7zDvMOOXHUwMDA1wprDi0lcXHTDpMObWD1NwpFKw44nXFx2c8OOf2XCp8KUXFx0w6dDNcKKRcKxwqLDv8KCwrJcXGbDhyk9TVx1MDAwNcO1UMODSDlcdTAwMWViw4zDuVx1MDAxNlx1MDAxNMOmw4tMXHUwMDExw57Dun9+R8Kbw5nDhcKLw6HDm1DDvGHDmcOPw4nCjcOAw6LCrmwxQMKMw6wqOE90wqvDnFx1MDAwMjs1VX09QMKfRTLDi8K/OzZpPUpUwpHDh8K8XHUwMDA1wo9cdTAwMTHCsCTCnFx1MDAwZlx1MDAxODdmwrdkST19w6U2wrN1Y1x1MDAxY8Kcw63Ct8OLXHUwMDAzY1x1MDAxZcKdKlx1MDAwNcK5w6vDosKJwrPCt1xcXFzDuFx1MDAwN1JcdTAwMDHCiVx1MDAwMsOPK8O2wrtcdTAwMDREwr5cXGLCrypcXHbCgMOKMsKUwq9cdTAwMWXDvVx1MDAwM8Oew4nCg0dcdTAwMDfCvMOiwrs5QlNVdSZcdTAwMTjDosOsejlVw5/Dh8KRw7PDncKtwqbDmsOawqfDtFx1MDAwNsOtXHUwMDE4aMKVXHUwMDEyw4lgXHUwMDE5RMONXHUwMDEzwrTCmVx1MDAxMj1Nw5xIU8OOXWRkXHUwMDEyO1x1MDAwNMOkPX11w5pXXHUwMDA1T8KXbsK7PX08MMOlXHUwMDEww7rChDJcdTAwMWLDhMKvw5BcdTAwMTfCvcO0wotlw77CimXDhMOUwqZXwq7CtsKUw411w6VcdTAwMGZcdTAwMTA3XHUwMDFhw7/DpMKbNlx1MDAxNyNcdTAwMTQsw5nDkMKDw4RQV8OPXHUwMDFjwoPCg8KYXHUwMDFmwrNcdTAwMWPCgcKYWVx1MDAwNcOWw4jDuMK9wpDDg8KuY8OGeyXCpE7CjsKKwrBQw60swrdoQsKeeDBcdTAwMDYoMifCtsO7PMOFw7/CscODemg9fWJWaHTCoMKqwrnDtHzCkDJcdTAwMDHCnMOowrPDs8OowoDChcKZwpXChsKaw7RcXHTDt8OxVVx1MDAwNMOONnI0wrxdwrDChcKGXHUwMDEzw4xJXFx0TcK/TUc9QMO5WMOzw5w9TV/CrMOYXHUwMDFiWlx1MDAxNcKHXFx0XHUwMDE2P2FSXHUwMDA0woNILVx1MDAwZsOkdcO1IFNcXHZcdTAwMTjCl1I3w6E3YyPDkl/CgVx1MDAxMERcdTAwMDPDvEjCpMOpw5TCl3ZcdTAwMTbCp1x1MDAwZcKwwqBcdTAwMTjDgcOewofDm1Quw5JcdTAwMTRURSg2wp/Dp1x1MDAxOU9bw7TCp2Uwwp89fT1Nw6Jzwq3DvMOxOFx1MDAwM8KnQ0DCtWRcdTAwMDHDisOkXHUwMDBlw4nDu1x1MDAxOcOKw5lKMFLCqVxcYlx1MDAxYz1NdGzCnMK8SnY3dTh3XHUwMDE3XFxiw7JzXFxcIlhcdTAwMWXDgFx1MDAwMnFONcOzw6vCklx1MDAwNcKwwpQyw7tcdTAwMWZcdTAwMDdHw5pcdTAwMGV6woLCjldnw4JQXHUwMDEwXHUwMDBmXHUwMDFkKjB4KMOJwr1Vw4xYwo7DvcKmXsK+wo7DqUfDmMKBwpxcdTAwMWJEU8KROHNFwozDm1x1MDAxYcOuw5jCllLClXLDiTlwU8KNwrHDqEhrwr9cdTAwMGUoP1x1MDAwNTbCillYwqjDpcKFKkdcdTAwMTDComdOwrJaXHUwMDFlw65Cw4bCh8O6wrM/T8O0wpIuRcOzXFxcXMKxM2M5wpTDqsOBwqDDisOqwqppw45RcVx1MDAxYz19w4AgwpTDvMOwwptSSFxcXFxcdTAwMWNZwr4zXFxcIsO8wqppwo5OwrzCsMONwq3CmmxcdTAwMWTCmVx1MDAwZcKcw6fDqC/DukzDmsOgw4tcdTAwMTlRwoPDisKrw4fCssOdOcO6fsOJw4vDrFxcYsO+w7g5XHUwMDFkwpxnYsKYScKMXFx2w4VcdTAwMWPCtMOaQMKOwrVcXHbCpMOZw6tzXFxcXHNwd8Khw7nDiXvDiMOgeVx1MDAwNMOrbSp+XFxiSHtNc8KXVmRyXFx0woHCn8OVwo7Cq1x1MDAxZVsgw5PCssO/fW/DlDlcdTAwMTNcdTAwMDLCrUvDkXfDvMK/wowvRMO+McKtw7PCisOSKEBePX3CscKeKMKpw5LDpVx1MDAxNcKneMO6VcOVY1x1MDAwM1x1MDAxMcKdw6zCg25oS1Q1wqTDicKAPUDDjHnCv1x1MDAxYsK6M2PClD19w5x5dTjDkVx1MDAwNMOnw4sye0rCkD1APU3DpsKCw4jDjsKvwprDpjQhwqrCk1pGOcKrworCr8OXw4YsS8KCw7pcdTAwMWXChsK5w6DDgV/CucOOLcO9ZsOwVGjCuUbDncO9w6IjMcOjPMOkQmFAw7F0XHUwMDEyw6XDg8ONw4JEw47Cq2jCvcKQXHUwMDFiw7Vgw7/Cr1xcXFzDo13CgHh+wpx+w5ZJwphcXGbDosOYwqlcdTAwMTLCrsK9wrQ9SsOwOsO+XHUwMDA2w5jCmcKJw5rCkMK0w5PCjlx1MDAxYirCssOTO8OAS8KFwp86w5LDjybCklx1MDAxNsKrIMOCUS/CgsO2w6pDw5HDuzZRdsKBw4Ewb1xcZsKOwo9cdTAwMGZlXHUwMDBlwp4/YsKnw4PDmULCvU7Dl8OVw4vDjyZ8XHUwMDE2w4Jzw5kzwr3Djk/Dljw2w7LCgTNcdTAwMGXCpjTDsTHDoEvDtsOJMcKObcODQ21DwpfDjFx1MDAxY8KWw7tpUU3CvsOrPUrDg8OxwqPDi8ObPMKGOnozc8KHwpDCiTE6Z8O3LjxnU8OBw4M4w5RcdTAwMWPDoz/CjyVBbcKhVT7DuFPCvlxcdkrCvFx1MDAxOMOzw4rDnsOsw5w1wr/DgmBswpXDnlx1MDAxOWEtwoNCw5okw4zCt8KKw75RwrPDnz1KKMODTMKtw5s7wovCvj9cdTAwMGbDimdsZTfCg1x1MDAxMcOoY21gVsOrO8KAwoBywoTCisOPRsKKJcKMK8O2w7loR1xcYjrCnk5jNlV8TDJcdTAwMTjDusO7QXEnQ8Ktwr9GZlFpPsKAbsOywrhSYyU9QFtsXHUwMDA1eEPDnMKIwodpwr7DrTjDoX7DtnNcdTAwMWRcdTAwMTDDmcOsV8ODw54nTCo1JMOfMi9cdTAwMGbDllx1MDAwNcK4w4vDhEhow7HCtMOcXFxiw7A1wozCtMOwcsO2wrHCjSRSwqrDu1FcdTAwMDfCnizCg8OTw6PCjMKAZcOowo5nRj1NLC3DqDk+wpNcdTAwMDfDuMKGXHUwMDFiXHUwMDE5w77CtMOKLWXDnTjDu8KewpTCtEvDtzJswqc2RcOfwrx6w5TCmMKfWMKsYsKxO1x1MDAxOcOBfsOlw7NcdTAwMTDCn8KEXHUwMDFkXHUwMDE0XHUwMDFkw7HDoVx1MDAwN2paLMK2w47Ch8O6LMOJfj19W1LCrMKrwqNcdTAwMWFcdTAwMGXDgcOVXFx2YHlcdTAwMDQuw4bCtMOxbylhKWbCl8KbwpZcXHTCjMO5X8Kkw5zCp2AsQMOrw5PDs8OkwrE4XHUwMDFjwqtLKVxcYsKfbcOLwqBhbFx1MDAwNTA4wrFjwoDDusKFw5bCqcKVLMKTwpfCrsOtXHUwMDFmwos+wqR8w4DCnMOGdmjCrjlcdTAwMTPDsMOod8K9w5QqQVx1MDAxZsKSXHUwMDExwr3ClnBeXFxcIsOfWsOXwrvCk8OHJsK9wojDoH7CliDCgHU/w509TVlcdTAwMDPCuTPDgMO0wr/CiMKqfcO9w5A2w5hyXFx2XHUwMDExwp1rdGdLblxcXFzCnUzDiFx1MDAxY0HChV1JNVXCk8KzwoNxwpjCv3vDjcKMY1xcZsKcwofDuX4vwqHCmjnDuMKxXy1xXFxcIsOaYDZcdTAwMDfCkcKuXHUwMDE4w4DCmsO3XHUwMDA0w4V7worDjFx1MDAwZcOgX8K1w5TCh8K5wqBcXHRMwp1PMFxcXFzDtsKDwpLDrcKAXFxcXCvCosOMwqfCtcOGOsOuw7goXHUwMDFlXFx2dMKBw5HDscOkw67CkTvDv3JcXFwiwpEmw6YjXFxcXMOeX8OXwplvY1x1MDAxZsKzwr7Cv8KjwoRcdTAwMDQxXHUwMDAzPU3CgFx1MDAxN8OqwrPCjsOmw7zDlXDCv8Ktw6TDvMOgXHUwMDAxZsKDXFxcIsK3w5DDvMOHw7RcdTAwMTfCkjjCtUxcXGJzwoDDtndSWsK/wr/DjsO8bD1KS8Kuw6p0R1x1MDAxZsK9wrl8XsKBw7LCgcOkw4vDslrCuMK+wqxZWlTDuMKLw7VcdTAwMGXDjzTDvMOHw7JOO1x1MDAxMTZcdTAwMTgmWsKZw7RNMcOxXHUwMDE2w5vDplx1MDAwNS5zwprDjMKBXHUwMDFkwrVBwrlcdTAwMDQ9SsOZwqIrw7RcXHbDtsKdwq5KQF04w6PDjyzCgjfCscO4w5NcdTAwMTg2KU3DmMKBw6PCgTDDvHxDVsOfw73CjMKPw6VcXHbDjcOIY2rCi8KRwrbCjD1Nwospw5jDimdcXFxcw6fCv0Y3fyhfw4VcXFxcNsOPe8OYwolQw7VFw6vDk0Rpw4RcdTAwMWZ7aT95woNHajbCtXTDrsORWVstw6NrL8OFXFx2QlJbc8OccMOvXHUwMDA1wpDCllx1MDAxYjfCuGBcdTAwMTM7w7rDosORP8KcXHUwMDE3wos4wpfCtcOTQXhcdTAwMWJcdTAwMDYhw6N8w7fDrlx1MDAwN1x1MDAwNGvDoV3DhlhcXFxcNj19WmXDhlx1MDAxOcKsOsKgw5JcXGLDsMKZXFx0w6nCnFx1MDAxMkRcdTAwMTTDrmnCr8Khw7xfw5HCm8O9dcKJL2LDkH1Qwoo9QFghbMKWJUgmdcOjwpJDwqjCoMOnworDmTXDiMKHwqNcXFwiQVx1MDAwMsOFw4krdMKARFx1MDAxOcK6w4xEw41cXHbCtcKzwpfDhTbCoMKuXHUwMDE0XHUwMDAyw5XCpsKAwr7DtzLDlWRcdTAwMDbCpsO9bMKkwrhcdTAwMTTCmVx1MDAxN8KhwqbCqcKeZlx1MDAxMsKEw7BcdTAwMTjComZcdTAwMDVkw6XChMKNw7ssw7zDuT49QFxcXFxcdTAwMDTDhcKMXFxcIsOge8OKeVxcXFxUesKKcT7DtcKHRjbDt2HDsig7Vy9cdTAwMTPDoMKrwpFlLGLCgFx1MDAwZcK+wr3DlMOnw451w4leSzHDu1x1MDAxYVx1MDAxMcOsN23DqFxcXCLDrj19wq/CkMOhXHUwMDFhw6xcdTAwMDLCqzVlwrVBXHUwMDFjw6BRTlx1MDAxOcOCf8OaXFx0w4zCqmpmw4dHRT45c2xcdTAwMDZOKsODcMKtN8OLWXzCsF7CtFx1MDAwNcKAesK3P8KETmxPwrHChmQ+wptcdTAwMDbDjjLCtsKbw4I9QFx1MDAxZcOvw4jDlXRTw6RcXFxcVn7DiSVcdTAwMTDDim9RXHUwMDA2w5fCrTkgdVxcYsOVwpVcdTAwMTbDtVx1MDAxYU/DkcOSP8Kuwo0gPD1Aw747bzRcdTAwMTXDlcKCLnJTJsOswrRJPUBWI8Khw7k4w7JHw7FZw6/CqkbDvVN0w7rDhcOfwoF2J3vCusKNwonCrz7ClcK2XFx2w6DCvybCi8O+wo0+wpdPRcOWaTrChMKRXHUwMDFkwrlcdTAwMDXDu8ORJjtcdTAwMWNyXHUwMDFhJlLDhcOWw73CtMOuw79cdTAwMTHCi3fDpVx1MDAwNW7DmsOYN1pkwopuT2lzUHh1w4/CgMK+PUrDkCY9fcOKXHUwMDExXHUwMDA0Kk9ewo/DhFx1MDAxY0XDgnjCk3piw6tXSS3Dm8ONw6/DhmzDoFZbw61UQ8OTXjtcdTAwMThRfMK8TGfDvT19N1x1MDAwZT5DKcOcXFxmwq7CjzHDnsK5wrhLL8KOwr7CnUx/worCgmrDlcO4wqPDucKvJ8OCOiMtw6B3ZkE4XFxmw7p+w7DCn2PCn8Ofw7EsQyfCqcOWw4c1wrbCiMKRwqdcdTAwMTBcdTAwMTHDpcO2YVxcdMO2YcOBPU1cdTAwMWLComYgXFxcIsKcXHUwMDEwOsOqOHjClmw8djJzwrl3R1ErbDLCq3wsw7fDlMKHL8KjRsOAYsObb8O/w67DiFg7blx1MDAwNcOSNz1Nw7NAwp/Cg8KUS8OOw7rDmMKFw4PDksKPwrvDoE9AdcKTw6VFw5JcdTAwMDVwf8KgwovDoVx1MDAxM2xVwoTDlGBcdTAwMDXDtTx0w6olwqXDiCnCpcO4IcK3PU1Lw4vClEzDucKhWFx1MDAxOcKjw7nCpVxcYlx1MDAxNSknwonDiHHCrVx1MDAxMjBeWlx1MDAxNcKvS8OLwrpOw7I4XHUwMDE5wqDDrsOBwo8/XFx2wplyXHUwMDA3w5ZXemzDglx1MDAxMsOzKMOUwr9/asOow40kccOCYVPCj8KFXFxmXHUwMDE2V2zDuMK/KcK1wqFcdTAwMWZcdTAwMTRKJsOob8KYwrQ0w7x9XHUwMDE5OzBIwqfDkVPCvlx1MDAxYVZcdTAwMTHCsSdcXFwiXHUwMDFmwrTCtcOdSnUnwqPDjcO4wp9ww6VcdTAwMTlewofCq8ODwphbZsKnwozDtMK4Y3fDk2xrw7lcdTAwMWVxw4FGXHUwMDEwXHUwMDE3w6BNasKAwr9Ww7TCoE7CnsKkwrhpw6LColU7PUBEc8KiSsO4XHUwMDBmw4HCvH7CtFx1MDAxMcKmJ3fDr8O2ZjfDnGhcXHTCpcKqw59cdTAwMTLCrizCjXfCjcKxSsOuwoDDrF3DjTjDnsKlZ8OCw6lDYWtXQcOPXHUwMDE2QcOTf1Y/wqQrXHUwMDE0wpnCnFx1MDAwM2d1PDV5NMO9wrnDv8OTw5PDg8OQw498w6zCpzlXXHUwMDE2woBwfETDomBTN8KFZTnCqcKxwrLCqsKhPsOrwphYwrHCgcKFwoF6w4fDvcKYw6x/XHUwMDE2wqrCvlLDm1x1MDAxNsOrwoDCo1x1MDAwM8OhK8OMVcKgw53CpcOawoxcdTAwMTMyWVx1MDAwMzd2woVkw5F1XHUwMDFkd2I9fXzCrsOuXHUwMDEww6hldjVCwqzCkH9NTXJPfsO3MivDscKZw7xrfT1KYnNcdTAwMTLDhsK9KMKUwqfCqMKHesKXw5/CnVx1MDAxZsKBN8KZVCt7UsO+XHUwMDFjwqBvw4c7XHUwMDA0w6s/Iz/DhFHCkcKSw5TDqMKxwrjCkG5cdTAwMGXDkivCr8OJw6zDg8Oew4d5wo1hwpt8w5RcdTAwMTPCs8K5YsOKwqDDh8KfOmvDpsO3w6dHW8K9XHUwMDFmTSrDuy5cdTAwMTJVw6pcdTAwMTbDuMK7XFxmwoBfW8KsW8OdcsKuwr7CjVx1MDAxOF09QMOfKsKBw67ClFxcXCLCvXDCgsKAXHUwMDE2w7fCmC09SivDmVJswo1cdTAwMDd+PUpUw7XDmUBtwr7CiMOGwrJMwoTCtcKPYW/DtMOMw7BAw65xwp8gOMOHw7fCqsO8w655UMO2wpjCjyE0w6nDvEh6w4bCtVx1MDAwN0PCv8OTJMOpMMO/XHUwMDFiwqVqf0bDpGtcdTAwMWPDrlx1MDAwNVx1MDAwM2/CojpcdTAwMTXDt8OiX8OHR8OkwrNLw64weMOCPEbCsiVcdTAwMWZcdTAwMTcgZ8Kbwp5cdTAwMTnCl8OUIMOhwrtcdTAwMTNcdTAwMTjCpj1AX1TCvcOIOFx1MDAwMz1KXHUwMDAzw6Q+XHUwMDBlw6vDhETDnMOVXHUwMDFlwrPCmiHDm8KeS27CoWvDi1x1MDAwZTfCpsO+P8KMwoM4w7XDvsOPI8OXXHUwMDAzw47Dgi3Dhi9cdTAwMTTCmcOlY1xcXFzCn8OfQUnCoSVcXFwiwrBAYsO4w4LCpcOuKVx1MDAxMsOSVMOeJMK/wodUw4fDnsOHw4zCs8KMwoE4XHUwMDAxVcKvV8K0XHUwMDEzXlx1MDAxOFx1MDAwM8K/wqYywpnCvsKhwoRcdTAwMWLChU93VcONXHUwMDA3w7ZNw5/Dh8Oow5VxXHUwMDBmXHUwMDEywo7DrMO5w5JvwqjDsMOTw4d+w4PDncK1w6/CmHFRw7XCj39/w48pwpF2wrs3SMODwqDCssOVU8OcwqdbXHUwMDEyw6Rxw7ZcdTAwMTXCoWvCl8O2wpDCvVx1MDAwNnxBwpogw6VXwrXDocKtw6ZEPUrCmVx1MDAxN8OHw6/ChcOXV8K5w7/Ch2LCilx1MDAxYsKZYMOJZMOEd1xcXFzDpizDn8KFwrnDucKGTmsnw7xUwplqwoHDmsKUZFx1MDAxOcOEQsOFNcKWw4pYfFjDnMKhwrHDjyvCusKLNsK9w4XDhmhaw67Dnlx1MDAxMyNew4lAOinDmi50wqnCscOYecKFw5ZcdTAwMDfCi1bCp8KRwpwvPU3Dm8KDN8KxwrrCl8KYwoHDqcKyw5fColJcdTAwMTjDhcK+VcKmT8KSU8K+XHUwMDFmwqzDh8K5XHUwMDFkwqF8wqTDinZrw6fCt1xcdsKkb8OCwrfCoVx1MDAxMVx1MDAxYyFcdTAwMWTDlsKqdcO1YsKoMcOePU1cdTAwMTfDtSbDq8KPwotvXHUwMDAxw6TDtVIpwrXCoVx1MDAxN8KpXHUwMDA1wrfChcOZwqPCucKQwoDCo0VcXHZcdTAwMTlAXHUwMDExXHUwMDA0McOTw6HDtcOnXFxcXMOLYXtkw5DCulxcXCIkwqHCp1x1MDAxZXtBw4fDrVx1MDAwNWPCpsKBXHUwMDBmwp1fVSvCg8OHw4jDgXrDvkPCtHTCucKLYj9cdTAwMTTDnMOvw6XDrcO6ZMOVwqFcXHbDjFx1MDAxMD19VMKpSsK+wrDDhzRcdTAwMTDCr0hcdTAwMDLDo8OYw7s0wrzDjlxcXFxwPX3CnT7CmMK0IErCgidcdTAwMTLCosKqacK0w4HDkUzDuMO/XHUwMDE0XHUwMDE4wpPDlEJcdTAwMDFcdTAwMWHCj3XCqDbCnMK1PX3CiMKAw75+dsOww5Z9XHUwMDA2PX0mw6QkK8OHwqxsw71vw5RwSMKQUsO8wqTDi8O5woJNXHUwMDFmXHUwMDE0w4PCmcO/wr3CrcOhwpjCi3x+XHUwMDBlwr7DpMOMw4g+fSXCmsK/w6TCvXcww5guXHUwMDFkw5ZcdTAwMWTCsEZcdTAwMTLDrMOTw4BcdTAwMWVBw4fClFx1MDAxNWFcXFxcw7PCkMK9bsKMXHUwMDFmwoJcdTAwMTA9QMKVw4M7WMKiOMK5wqrCvsOUwojCjVx1MDAxY8OQeCBcdTAwMGXCmcOfwpE/wqZcdTAwMWJcdTAwMTTDgsKlwrt1wpg9SsOAXFxmMlxcXFzCpVx1MDAxMkdcdTAwMGU9fcOLw7gzUVHCpSZ0a8KYXHUwMDFiw6nClXbCosKjw65OXHUwMDA3w6tkwpY8XHUwMDA1TsORXFx2wovDn1jDqTTCvVVcdTAwMDLDul0kwr3CtsKoclx1MDAxNMOFw5whO2zDt04vUsOXRjfDoMO0w67DrUBjLsOpw4TCtcKHwoJUw59cdTAwMWVpwrQhwqRcdTAwMTUqwrxGXFxiwqMxPsObPX3DicKTwpNBIX5nP8OANcOZw6RcdTAwMDTCvDXDmcOuw7AuXHUwMDE4w7XDkVxcXCJpKVx1MDAxY8KRXHUwMDEzw4TDi8OWw53ChsKPT1x1MDAwZiVcdTAwMWRcdTAwMTPCjcKIT2jDqWRcdTAwMTIow53DmypcXFxcw4paw4VJw6DDvHPCoFAzw6zCllNqXFx2w6xcdTAwMDFcdTAwMDVSw4/DmcOdMz9hw6Qmw7TCjnZHOMK1w6BcdTAwMDbCqMKNa33DiTHDssOnw4nDplxcXCLCm8OYJ1xcXCLCpVx1MDAwZlx1MDAwM8OXXHUwMDBlwqjCusKVXHUwMDE5XHUwMDFhw5/CoT1KXHUwMDAxSsKhTFx1MDAxOMOnwqFoQMK1wonDlsK1IMKuXHUwMDFhKlx1MDAxOH49SlEtLFXCh8KoXHUwMDExwpHDvXJcXGIpIVx1MDAxN1xcdMOuw7VcdTAwMWXCoFx1MDAxM8OeXHUwMDFlWsOgwp4wI8OtXFxcXFx1MDAxOMOwSG1cdTAwMDXCiMK1wqHDg8OVwpLChCdvXHUwMDA0UTFYXFx2XFx2wpPCtCvDg07DtiHDm3jCtMOHY8K1Ylx1MDAxZWtbwrA/w6VGwqnDhMOwworCrsO1XFx2w7RcdTAwMTc9SjMjXHUwMDE5XHUwMDE1woVkw5XDh8Oewq/CqS5Dwppiwr4hwqF8woRcdTAwMThcdTAwMTPDu8O/XHUwMDEww5JTwp5BS0hcdTAwMTc8w5zChinDpMOrP2ZcdTAwMWYqwrbDgibDo8OfLVx1MDAxOVx1MDAxOUJbXHUwMDEww6LCgUQ/XHUwMDExT1x1MDAxZWTCt8OSWMO6wqtCS1xcdHIywotcXHRXa8KbVsOpwprDqWRcdTAwMWVFwoDDp8KoRcOUZ2VzPsKOwqhNw6XDn1x1MDAwMcKKw69gwqR0w4DCicOFXHUwMDA3wr9mPlx1MDAxNzvCm8OXw5ZcdTAwMDNCw7rDkMKOaDPCssKvSsO+w5fDmVxcXFzCisOewotOw6HCpMOtUsKGNMOXw43CtFx1MDAwM8K6WcO6aycrwrfCizHCqlImwqPCvcKYwobDhcKJwrfCrcOyw54twrLCvsO4wrjCvsKyXHUwMDExLDTDulx1MDAwN0nDr31twq7DvMKkOsKpYGfCn3cnwobCmVx1MDAxZlBedMOUwpxSY1x1MDAwNzlcXHTDg8OnwqTDiz1AMcKIw7jDrTTCnsO4w5nDo8OEwoZGXHUwMDAxdGNcdTAwMWNJw79cdTAwMTHDkirDqMOLVWZuwpRcdTAwMDdcXFwiO1pcXGLDjMOBw7XCjMOvMT/DlMOWwrDCjsKnw4MmwqdcdTAwMDdcdTAwMWJcdTAwMDQ0PlxcdkltwoNcdTAwMWM9TcOewpPCgMOnS8OlXFxcXMOjwoPDtFx1MDAxYmpNwo/DqkdOwow7LsKAw6xBdsKBXHUwMDFhccOZw7XDmcK2wqI+w6fCrz1NwqLCh8KcX8OzOcOyUSZtXHUwMDAxw47CikfDpcOUwrZLwp3DqVx1MDAxZEwvwqLCkX/CrsKtey5Xw5HCrcKPw6pcdTAwMDFgwqnDsTXDtcOKKMKFwqktwqXCpMO1XHUwMDFkw73Clmc9fWTCmX3DqMOSwojCmFx1MDAxMsKCc1x1MDAxNVx1MDAxYsOkwqtYPUBcdTAwMTDCvSXCkcKsScOUwp3DsFx1MDAxZsKPwpVbJ8O5w7PCkFxcdsKsLFRuOsO+MT/Ct1x1MDAxM15cdTAwMDTCiMOta1x1MDAwNVx1MDAxOCvDoUkhwo7DpSc2T8OhSU1RwoYzWsO6XHUwMDEyL8KNUjbDu8OGXHUwMDE4wpw2w5hcdTAwMDLDl29vw5JGwpo8w4xcdTAwMTZZecK4PU3DjcOnw63CrsK9U8OmXHUwMDAzw7g1M8K2dVtcXFxcW8KTVMO0b8KbwoErXHUwMDE5w5rDtMKrVsKMaS3DrWAjwoTDl8KkWFx1MDAxNMKLWsKXw5khw6XDjcO3U1pabMO0w6wgwpRTw5HCjcOqwq1TfDdcdTAwMTfCllx1MDAxN1PCkCE7R8KgKWhLMlxcXCJpwq44eMOow4V4wpjDhcO5PUBcdTAwMTlFwqRBXHUwMDFkXHUwMDA0XHUwMDFkw7HCjUHCsXHDrcO/w7dlesOfTsOEPX3Dllx1MDAxNyhEdcKYIMKaLT19w5HCrMKRw7xefG3ClcKSwoN9dMKHK3JtK1x1MDAwZV4/wqnDnMOXwpLDv8O9f8KAYMKHYcOIMMO4OTRcdTAwMWLCgMK8wox2w6rDtVx1MDAxMVMtRXjDgVZSwpHDnsK3P1x1MDAxMcOmw6YmamAqwoprwp3CjG7CscKUKU7DlFx1MDAxN8Oaf8KFQ8OLTSDDlD1AwprClcKFSz7DgcKzwqDDrMOFw6MtZcOgfsOEf3vDnGFcdTAwMTRiXHUwMDA1WMK/wo/DoFfCsMK6w5MpcMKGQ1xcXFxcdTAwMWNSwqrClMOWXHUwMDE2woxgwpBcdTAwMTQnSMOYUlx1MDAwNzZpU8Ktw5rCt8Kcw5smUT/Colx1MDAwZcOcw4tYe8KVw5pcdTAwMTg9TVxcdHzDmMKhXFxmw7XCsHA/w7/DpcKlcsOiXHUwMDAyTWXCsMOwXHUwMDEzwr/CqsO4w7zCoMOBN1xcdnE0wrfDg1x1MDAwNjjDnCXCuDJ5wponwqrDo8KuUcORwrXClsOcY8O+asO8w7pcXGJcdTAwMDVCPX1cXFwiXHUwMDA1UkTDi8Krw4FxI8KHw6fCvSFcdTAwMDZmw6sxZMOaSVx1MDAxOcODXHUwMDEwXHUwMDE1SzRcdTAwMWLCgMOHwpTCssKww5ZJSMOjw4NcdTAwMTRJV1xcdsKzPU1jR1VNwo3CmcK3XHUwMDA3YsO5U8OZwoY5XFxiwoJGw7fCslV8wrPDokVOwpY0O0jDq8OpXHUwMDFjw5zDizdCwrbDq8KWPUp7w7DDsMOFXHUwMDExU8O8wpJMwrzCtj9zR8OqQktNw6Y2w4rCmcO7UHtPw7zCv8O7wr/Dn1x1MDAxMcOvwpNtwqRYJsOOw45cXFxcwo3CkDPDrkLCvsOrwrRcdTAwMDLDjlx1MDAwN8K2w4HDi8Kow4DCssKaw7VcdTAwMTlcdTAwMTXClcOdNMKObVxcdFx1MDAxOMKAw79YwrPDisKPwqTClMKSSMOIacKoLVx1MDAxN8OWw5LDvcOUXHUwMDAxISVcXFwiL0dcXGI9TcKrwojCqVxcZsKgw5fDscO5SVHDvVx1MDAxMkfDksOBwqzCpmHDuMOewq9cdTAwMWLDisKyVXlcdTAwMDHCh1xcXCLCsCpcXFwiWsOUwr4kwrlcdTAwMTBuwrPDr1TChsKXXHUwMDFlwpzCuWReXHUwMDAzwq7DgsKAQMOlScOQwoptw6F7w53DlVxcYlIgwrnDq8Kbw7BmwqtcdTAwMDY9SsOoXHUwMDA0wpxRw5/CuMKrY8KqXHUwMDFhPlPCkMOeworCtMKLX8KMfyzDhTHDl8Osw6dyT1Fewr1fw5zCg8KnP2cxQkhPXHUwMDFke8OBwr5LXFxiZcObwpTDpDvCgjhIcMOXXFxcIsOUwprDllx1MDAxYWDDu8KFwpjCkMOQw7DDjGTDnUp3wpLCrMOQXHUwMDFkYMOJw6UqNX3CvVx1MDAxZsKMdcOsJcO3PU1cdTAwMTljcFx1MDAxMsKtwrvCp1x1MDAxOVHCs8OVw79Kw4/CsFx1MDAxY8Oww5fDjMK9PX09SsKuS3pGw4vDg0pnUlx1MDAwM8OkO0NqXFxcIsOaXHUwMDAxwrx+wrhlwq98O8OgXFxmMsOzXFxcIsKEw7k9TW5cdTAwMDFcdTAwMTRWXWIvw69cdTAwMTTDp8OwwqvDqD9IwrnCriBwwrBcXFxcXFx0w5M2cVx1MDAwMcKpUMKPw75cdTAwMTVcdTAwMDc0ajJkYcOawr7DuC17wrvDplxcdFx1MDAxZsKoI8KnKnDClcOhw6XCiyBvPUp1T8Ohw5/Cnlx1MDAwNcKocFx1MDAxY8Kuw6xrwrbDoGzDk03DssOuwoBcdTAwMTliY1TDgW/ChFhjw6NfL8O9RDvCojNjcFx1MDAxZMOnw57DgMOAXHUwMDExwr0hSGVgXHUwMDBmanDCp8O6f1x1MDAxN34uw5xgXHUwMDEybG/DksOZScORPlnCpsOmIcKaw5HDuz9cdTAwMGXDs8KDwoZ2w55XwpHDoUrDhcO+fMOhwqZuw4jDj0PClFbDsyTDuMOOO3DCgnJIw5/Dj1x1MDAxMsOAwpFQPMO3dMOlwqbCsCctw71vXHUwMDFhw4M7w7jDvldJIXd+w4rCq2FPw5LCiMKaecObwqpuc2d9RSRPNlNcdTAwMDRcXHTDiMO8UG7Cg1x1MDAxM8OMOyrDnMOFwp/Cq1/CvMOywqDCjFx1MDAxNmLCj8O1wozCnsOcREUqXHUwMDA3w6vCuFx1MDAxMMOHVC5mL0vCtsOefsKTwqtcXGZcXHbDuipcdTAwMTPClSZYwpnDrsKDwolcdTAwMWXDkMK6Y8KPPX3Cs2HCtjA+w5wrwrTDj1xcZnxcdTAwMWLCmsKhwrPDv8KAeMKUYlpcdTAwMDTDsj19Qklvw65iwrFRwrshNMOgw4BGw77DgGvDtcOKwrTCu8KhUcKOQcKbw7XDoT19TkFcXHZ+NH9HZ07DkcOmPUB3woRcXGIufUzCsldXwplGcsOdYCrCisO+wqzDjFx1MDAxZsKkwo0wwropXHUwMDExw7ktw618w6B9JUsnwqgpw6ZmXHUwMDAyXFxcIsKlw43ChsKcXHUwMDAzIVgrwoHCty7DlsKnwqtNwqLCuVxcYsOnw4JcdTAwMDfCksOrUcOvXHUwMDFhKyNcdTAwMGXCslx1MDAxMcKeN8OwwqV1QMO7czDDtMKEw6lPZMKDw6lucDXDlUhaU8K/w4RMwqPCqjHCkFx1MDAwMlxcdMOIw6nCiMKkXFxcIsKuwr0nXHUwMDE2I1FuPU1Nw5/CpmXDn8Kow5kqwot6NXg1w4Inw5pcXGI4wp5cdTAwMDPCusO9fsODXHUwMDE2w5ZeNVrCsWLCisKCdcOUwoAgwpAzw7bDgcOoP0nCjsKnRsOgwqoywot5wqfDp8KUIzVpwo3Cn8KxXUzCvVDClFx1MDAxZsOnw513U8KBwqjDp1x1MDAwM8KUacOqw7bCncOpwr5tXHUwMDE4XHUwMDFjw6xmXFxcXGbCjz1NwpvChVx1MDAwNcO0wpnCilx1MDAxMjlROsOww609TcK5w7Q3w7lgXSxQZSXDqWRcdTAwMWYlXHUwMDAxw5kmw4E2TXPCslx1MDAwNsOHwr0ndcKuw5vDpcOJMic3d8Ksw4dcXHZSXHUwMDExe8KGbMOtXHUwMDE1wqB2woTCoVx1MDAxN2w3e23DgcOtQTXDsW7Dt1nCuMKZKsO8wq5pW1xcdMK2wqnDoFx1MDAxMmZ2XFx0w4lcXFwiwpZbXHUwMDFjWsKsL8OYwoNhYz19XHUwMDA0PkvChizCs8KnWVXCuUZfw5fClinCkn3CiEDCiDzDu1x1MDAwNMOMw7hGw7PCiMKQMcOKw6LCkn5bwodIw7fDusKVXHUwMDEyw7XDoz1KccOlwqRew7vDkHBcdTAwMTlcdTAwMTnCh8OTwqojLsKmw7FWdMKSM8KNWyvDiMK7w7rCusKvw4vCsD1KwpVmY144XHUwMDFmaFx1MDAwMcKSNkVeK8K+XHUwMDFlOsOuXFxcXMKUOyd/w5XChsO6XHUwMDFlwrNBwo9cdTAwMWVbwo3DuDPDsE93JivDhXJWLFx1MDAxNMO9bWFFYksgw6lgw5rDk3vDgsKsQG3Dl01cdTAwMTbDiD19WMO+WMKaw4jDiihWw6VcdTAwMTDCi8KKIXPCocKLOMKNw6TCjVx1MDAxYcOfw6zDmktcdTAwMDLCtsKuO8OQXHUwMDAyf8Oow4HDo8OEXHUwMDExLiHCjirDncOQw6Y9TcKlwonDhMKUwrjDh8KSRW09TTxcdTAwMGVhwo3Ci8OLw6vCgcORUcOOcsKvwq3Dl8KKwpnCisOpXFx2XHUwMDE0PX0kQW/DoMOdXHUwMDExwobCvlx1MDAxNmY7cljDscObw7DDmzhGUsKkXHUwMDFhw6HCjMK9PFx1MDAxZMOgOsKEw7Q5wr4hw43DnT1KOVx1MDAwMS7CpMOFeVxcYlcqdm/Dgl1cXHTDiH/CkMKRXHUwMDFiw7s9Slx1MDAwMsKYwpfCimrCtcOkw6NmIcOkSsOtw7/DpcK4w6vDmnDDl0nDqXHCksKswpxTwrfDnzxcdTAwMTkwXHUwMDFiUsO4WWLCssKKXHUwMDE3KcKNW8O2LmYwMsK9Ylx1MDAxNsKrXHUwMDE2XHUwMDA0KcOqPUBxwogrw6LCrF5Iw79cdTAwMDPCsMKCw77ChVx1MDAxM8O2wpDCkTdlaE9+w53DnVxcXFxeJMKSXHUwMDE4TkbCi8OKw5c9SijDoDsnXFxiXHUwMDA2XFxcXCHCkGNPw61eTsOVw4fCuGBcdTAwMWNcdTAwMTdcdTAwMTbDn8O4fSFcdTAwMGY4XHUwMDA0aVxcdMKqLcO0ccKbXFxcXMODwoVLwq3Ct0nCn8OQw6/DsFx1MDAwZifCqcOlwqbCnFxcdmfCnFx1MDAxMlx1MDAxMWnCm8KowpfCpllRwrbDpVFmXFxcIlx1MDAxY8OjWlxcXFzDtn3DqmPCtjkjw7Anw63DucKnXHUwMDE3w6TCv1x1MDAwZmLCiFxcXCLDtsKPbkglXHUwMDFhwonCucOIwqMtw4FJZ2PCpsObw5FcdTAwMTFcdTAwMWVgwqlrJ8OmwrjDvVx1MDAxZGTDlsOIwolIwqLCpm3CpCbCjsOZw6EpTVxcdFM4w67ChsObJlx1MDAxZMOvwrDDicO9w7tXXHUwMDE5w7toXHUwMDFjw73CvMOcwrY+w77DjcKdwrg9TcKpZVM5wqZOwoZ1ayx3PX1ywpcrXHUwMDAxZcKHRsKgWnZcdTAwMThcdTAwMGZcdTAwMGXDuyohXHUwMDE0R1hcXFxcwrHDlcO3wppzw5LDgMKwfsK6wrbCtsKfXHUwMDEwSjFOwqM1aV3Dplxcdi5cdTAwMDbCjFx1MDAxOVHDtMO3wrjCvlx1MDAwM8O1K0h6woZqSj9cdTAwMTNsw4jCjylUwqPCg8Ogw7XCt3BZwpQ5w4xEMy3Ck1x1MDAxNMOQM8KjwobDnlx1MDAwZcOMwqzDlG91XHUwMDFhw6LDrlDCgMO1wpwlWzXCtcK+el41acO1XHUwMDFlXFx0w5zCtzJcdTAwMTlcXFxcNsOfXHUwMDFlw7rDjcK8w5VcdTAwMTLDqsK0XHUwMDA1w4HDjMKwKsOzwqPCvsOpXFxcXCpeXFx0bkvCu1LCjzdrwrwxwqNzwp3Dn8Ocb8OGwrpuw7vCvGEwbT1KSsObLcOmLnXDlsKjw4drb1x1MDAwZcKGOlxcXFzDg8Oiw7RaXFxcXCBcXGLCuVx1MDAxYW/Cu8KAf8OOw4fDi1/DhyN3w7bDilxcZklcdTAwMDHDpcK8IU7Do3XDim/CpMKMw5rCkGUywobCtEfDr1x1MDAwN1xcYi1cdTAwMDXCi8KQw5txw6NcdTAwMTcuXHUwMDA1PGxwf8OKw5DCjEAvOcOxIVx1MDAxZTXDvsKfXHUwMDA2wqzCh31EwplcXGZsXHUwMDE2OG7ChzHCksOcR8KCfizCicKrw4fDsMKrdMKKc8KLVlxcYsOLw5lAw41rPU3DkivDu1x1MDAwZcK2XHUwMDA1YsK8XHUwMDA3w5NcdTAwMDdFwpXDqMOQenFIwp9zwptWwrIyVSHDuXTCjHN5UsOnwpprP8Oow49qS8OoLcKFw71LXHUwMDBmw7bDkTLCrsK/NE7DqGzCt8KBf0XDi0LDvsK8w4bDnz7CqcO9VMKpwoDCp1LDrMOGwrrDrDNMXHUwMDE0w5VnwptawrnCgnFMwpnDs8OWXFxcXGduw4rChmzCp2tcdTAwMDM4QsOKOsK0QsOxaVxcdsOTwpzCi1TChjHDg8K3XHUwMDEyw5BGL8OTwqfDo8O4Plx1MDAxNTNcdTAwMTfDsFFjw73CujfCk8OWNsO3wo1AwpZcdTAwMWJGwpJDwr7Du3rCm8Osw4LDjTRzwrxFUH7Cnlx1MDAxYmxcdTAwMTPCrcKzW8KlecOYw6fCtcO2LsODPUpJU8OpZMOUalx1MDAxZExcdTAwMTjDi8KrRcOGwrx9V8KUwr0hIMOlwrjDtMOvw6jDj8OvSMKVf1x1MDAxM39cdTAwMTDCmmbCjFx1MDAxYsKawpJDP0JawofCmG7DoMKOXHUwMDE0w4RSXsOswpcwe8OFXFxcXD1Nwr5UMcKOwpfCm8Oew4zDlVx1MDAxOFx1MDAwZsKbw5k9QG02w7zDuC/CuVx1MDAxNFx1MDAxMMOUw5h1w6NGXHUwMDE0bVHDt1xcXFxmw6bCm1QyUmnCscO7w7/CmGg4wrltwoQ2ajbCnlxcYsKBw4vDjVxcdErCkT7Co0x7w5YkwpRbw4XDlsOAw50jMEVdwoFrw4TChlx1MDAxZcKXRFx1MDAxYcOmwrZcXHbDpcOOXFx2PU1cdTAwMDTCmsO3L20yw7XCgHFcdTAwMThOKsOnZDLDs1x1MDAxOMKnPUDCr8KVw4DDu0HDlnjDsVxcdGTDkz9cdTAwMTXCoFBLXHUwMDE5KsOvw5dcdTAwMTBNIWXDuXPDl8OMaVXCs8OVXHUwMDBlb1x1MDAxME/Dt8OFw7LCtsOLdVrDhMKdwrdodcOmKcKqWGsyw4nDp8KVKm/CjFx1MDAxYcOvwohxwozCjVx1MDAwMijCr8KYVS3Dh2pjw63CrsKCK1xcZsKATMKNw5XCoTXCuTBoPlx1MDAwNcK7XHUwMDAxwqTDucOQdmxcdTAwMDbCtcOvwpojw43CuVx1MDAxMMO3wr/Cripvw63CgcOAwpHCm8Kxw749Sn/Co8Kyw6TDp8O5OT1Nw5BaKGpaw5/CpcOXw6JtwrrDllx1MDAxZjvDmXtcdTAwMWbChVAzXHUwMDE2woFuV8OCScKvw4And0V6wrppP8KZfMKow41ow4VcXHZcdTAwMTbDgyQ2XHUwMDE5wpHCq8KjXHUwMDBmwofDtsKOw4pcdTAwMTTDi8KsXHUwMDExw4lzw6rDhUZcdTAwMWR5w5zCr1x1MDAxOUtIw6fChVx1MDAxYjhcXGIrXFxcXMOCw55PR8O7w5Vww5TCgTfDmcKKwrVHw5PCiMOvXHUwMDAzcMO4w7zDlWLCvWhxPUoxwqxva1xcYlx1MDAwZsOuwqvDtzvCg8ORw4PDgk/DjGjDiWzCsknDpsOZwpjCqy5FX1PCt8OIw7LCjyzCpDfCjsOfwoxcdTAwMDdzc8KGw7xcdTAwMWNLwqfCsDNTa27CjsO1wrbDvcKfVVXDjG/Cg2DCuFx1MDAwNcK0w4xyJlXDhls/OMO0w5dcdTAwMWVUOTVAXHUwMDFkXHUwMDEzP8OZXHUwMDA0w70wwrF9VsK1w6vChsOAVzTDrm/DlsK3wrLCs8KbW0vCsHbDs1LCrcO5w5fDnsOAwoTChVTCucORXHUwMDBlNMKyRcKmw55cdTAwMDbDpcKXSnJXwpHDicKOw4tDU8OmcsO4ecKfZVDChVZoXHUwMDBlwoRxZsOZwq12MFxcXCJcdTAwMTJqPX1aw5VcdTAwMWVcdTAwMTXCnsOiw5jDnVx1MDAxOC/Cn0RcdTAwMTEswqhEw6bDmWdxw5I6wrbDnHBcdTAwMGYrwprDhiDDnnh7esKNSsOyO8Oea8O3UypJTmbDgEDDpcOnw65RwqHCosKzXHUwMDA2wrNQXFxcIlx1MDAxZVNTwpUxwqHClMOnXFxiwpnDn2zCqcKqw5hTwq/DmFpcdTAwMTRiXFx0wo3CnyzCvVx1MDAxOcK+NMOvwonCrzppwrbCpMOML8KewpRcXGZ2w6IqYsKfwpDDklx1MDAwM8KTwp9kXHUwMDE3OClfXHUwMDFmw5HDvcKWYcOnfsKuXHUwMDEwccKEwppjUk/Dhlx1MDAxY8KAKsOPXHUwMDEww69awpzCrWw9SlxcXCJaw6bCu8KEwrEuwr5ywp7CtsKfMsOEwrBcdTAwMWbDlmc9QC/Ck8KEKMO0wqDClcOPNsOHwpc3w6RQwrjCoMOAPU04S8OfdsOXNDRcdTAwMWbDpFxcdMO1wqRRXHUwMDA1wqsxw57Du8Ocw55tVcKhw5s9SjJiQkrCosODXHUwMDEwwoc6w7daMCpxQ8ObNX5gwpfCm8Ofw4nDscOrXHUwMDFmMT/CtsODJy5cdTAwMTk5w6fCjMOWw5lYwrPDkcOzJMOfXHUwMDA0QlxcXFzCp8Obw77Co1xcXFwqXHUwMDA0wojDmX5+wq7CiMKrwotcdTAwMTExw6bDrMOawrpcdTAwMDRcdTAwMTFcdTAwMTjDm39Mw77ClsOtw6fCocOxw5Z+wqjClGvDusOdwoDCoyfCiFhcdTAwMTbCvU/ChcOeLXbDgcKLMW89TXrDo8OcwpoywrdcdTAwMGXCrcO2w6fCkcK9wrBcdTAwMTY+woEow5fDuMOFaFx1MDAwMVx1MDAwNT1KwqlGwotxKcKOXFxiJW7DlcOLV8KEXHUwMDAzZS7Dk8OewqDCv8Kww5PDgMKNUkTDrCBcXGbDhS1cdTAwMDbDpFx1MDAwND1Aw49XRsOiw5rDhMORf1LCmcO+XHUwMDE3wohcXHTCjHd8XHUwMDE4wqvDoMO2PUDCsDtcXGbDsjXDty5wUEXCuFx1MDAxOWDDg8KMasOTw5xUwoR9amHDvsK2XHUwMDE5eMKwwqXClCpcdTAwMWXCk8KFwpTDisKMXHUwMDA0wpV7woVrZMOXw7DCk8OHM8OfUcKePUrDpsOPwofCulxcYsOTXHUwMDE3wozCo8Kocnk9TTPCuHTCi3s1woHDpU4sXHUwMDFlWEDDtsKNwo9cdTAwMDXCmlx1MDAxYiFXw4DCqU3CtXjCo8KoJcOFT8Oqw57DtcKXPlxcdsKCXHUwMDAzw77Chy7Dslx1MDAxY8Khw5/Dq1jDmVx1MDAxMVx1MDAxNiRFw4s9fW9NTE0pw6PCicO/KMO8OsOtXHUwMDBmw71GXHUwMDA1e35fw6zDocOlQn/Dr8K+eWl4wrTDscOraElcdTAwMDTDsVRcdTAwMWbClUnCqHrDisO0w7BDXsOEw5/CuFxcXCIywoHDmjvCp23CosOPwq9jwqFvw6LClFx1MDAwZsOvXHUwMDA2JcKkw7VcdTAwMDVcdTAwMWFcdTAwMTJePlxcZsO2UcOMXHUwMDFkw73CpcOOXFxcXDg6JsKFXHUwMDEwUcKww5hcdTAwMDHCqEvCmcKTwpVcXGLDtC5PXHUwMDA3fVx1MDAwNFLCg8ONw6zDvcKAwpldwpjCnMKzbEnCtCwnw7Imwp7DjGYhw6JcdTAwMWQvVVx1MDAwNzfDlsKhXV1cdTAwMDTCrlU+w7nDlG9rwpbDu8ObXHUwMDFhw4A3XHUwMDAzwofCqMOqwqDCnFx1MDAwN8Kcw7FcdTAwMWNhwoPCrUrDpcK8a8O4L8Kxw6fDlFx1MDAxOVx1MDAwMsKfwoBNRMKbXHUwMDAxwonDucKybMKNwpdjw6ovNEPDi8Ksw4PCgcO7woZ1wo9Qw6k6dTrCnsOFb8OFwqfDrcKXwqbDmmR9w4k6w5LDlsO0wo3DvsO7w75RMkXDliRuwq1ow7vDonLDiUrCk1x1MDAxZcKzw7DDryRuwq1ow6tpXHUwMDFmM1x1MDAxZcKlw4LCnVx1MDAxNWjDi2TCoMOJw7rDpnzDgWfDi8KdJVXCgFx1MDAxZsKzwoBcdTAwMWUzw5s8w7ppwqXDgcK8WsKlZ8OXJlx1MDAxM8KvbSjCp0RcdTAwMDTDml7Dn3PDj8KnwpjCicK2wqRcdTAwMDLCncKow6fDu0J/wqnCul95wohvwrPDjcOqwqTDvlxcdsO6NsK/w7lSWMKJJMKTTkNTw4cowqtcdTAwMWRbwqjDiVx1MDAwZmHCpmp7XHUwMDBlwo5cdTAwMDU0XHUwMDEzw4fDgsOZM1vDq8Kiw7TDpsKNw7fDtH0lPU3Ch1x1MDAxMSBcdTAwMTHDrVbCqHbChDh+wrxnOsO1wpjCtFk3d8ORa8O7w7fCv8KKwpNcdTAwMDJUwqkgNVxcXFx4w57CsMKWcEJcdTAwMTQnwptFasO9wotcdTAwMDNkw7nDujzDsFx1MDAxNcKgXHUwMDAzN1x1MDAwMifCnsO1wqTDvsKAwqN0woVGI8KswrDCm8O8LFx1MDAwM8O4PUBcXGLClsKnW8OkXHUwMDE5w65lw6/CpcOhXHUwMDE5wq5GPnFJXVx1MDAxMMKfI8K5w7EtXHUwMDAyJMKEw4vCkjVVKsODcGllXFxmcUrDrMOgwrbCqlx1MDAwNVlNbMKXwq3Ci8OjwqhcdTAwMTPCucO8ZMKgXHUwMDFlw7o9TVxcXFzCtkTCrMKlw4LDhMOtwq7DllxcZsKnWsKZwohcdTAwMDPClm3Cl1x1MDAxYWtBwoMqXHUwMDA0XHUwMDAzXHUwMDFmNMKwXcK5w4Y6XHUwMDFjIcKxXHUwMDAzw7XDpMOrwqLDm8Omw5V9ZTdcdTAwMTnCllfDn8K1XHUwMDE4w6g9fcOhwrRKwqJxXHUwMDFkI8OAwpVcdTAwMWTCjVxcYm99w7XCtVx1MDAwM8OewpdBMMOWwrLCkHzCk8Kqf8OBw4DDn8OPw6zCqHbChMORw7B/w7fClcKLwrFcdTAwMGbDl1xcYsKkesOHZcOje1x1MDAxZS5ldsKNScOZw5x6I1x1MDAwNsO9XHUwMDE3ZD9cXFwiXHUwMDA3OMOaUcOqwqHDrcKQZ8O/P8KVw7PCisOUw4zCp0RFwp1oeEV6woXDt37Cmlx1MDAwNEnCrGh3w7XDvjzCpj5cXGLCmMOPw4VcdTAwMTTCnXLCrlbCrFx1MDAwM1x1MDAxZVx1MDAxMMKmwq7DmGpjw75cdTAwMDckw6JcdTAwMWFHXHUwMDAzwp9mwqXDksOVw6NTw5hwUcKzcn5hwqzCojFwwolcdTAwMDXCjGPDvW9lw6tCw4smdmFKw7RJXHUwMDE1YFDCvWLCrcKlwphcXFxcPX19w5hAX03ClcOePsKiw7zCgE/Djn9VMcKNwozDpcO9wrLDl1x1MDAxN1x1MDAxY8OFd8KCwpUvwpXDkzjCslx1MDAxOcK0w6bDgFx1MDAwZnTCjMOlwqrDpVx1MDAxMChcdTAwMDTCrlx1MDAxZjdGfHzCkFxcdFx1MDAwNlx1MDAxOWpNRyhcdTAwMWYoXHUwMDA2w6ZkasOxJsKBWVDCjsOTPzXDiS7CnsOfwqxcdTAwMGZyw4zDuV/CoGjClsKPw5xmwpo9fcOGTF5CwpzDjsK+w5XCqMKvw6LDs3jCocObJsOoXHUwMDFhQ8OswpTCkcKmOicuT1dUwoAvw7DCn1x1MDAxMy1cdTAwMTZcdTAwMDPCjsOaR1V5w47Cr8KtPj1KwpNywrB1wrwvwqg0wrLCmlxcXFzCqcOKwoTDksOYSCDCnMK8wqvCgMOFbMOWw5XClsKoZMOca8Oew7tcdTAwMWNlwoLCuH/CmcKAwoPCljc9QMO+w7DChlhDdEAmesKQw7XDll5Ww7dcdTAwMWJfbcKcwqFcdTAwMThleMKDXVDCvDknw4vClXLCg8KWfcOQwodcdTAwMTAlw4hAw41mNiVyw5x9wr1cdTAwMDPChcOWwrTDq1x1MDAwNWcrJMOSXHUwMDE5dWhcXFxcJm/DucOUwqg1w5TCtsKUw67CgMOkQcKpw59MXHUwMDE0woc/R8OewprCisK8MG7Ds8K4P2dcdTAwMGVawprCgsKGdcOIw6bCvEBuOU8nw6fDtsONM8OMclx1MDAwMj5cdTAwMWI2XHUwMDA0w4fCtWd9w7XClsKsalrCusKtwrJ2e2fDosKiw4PDusOMw6fDml3ChsOIXFxiScKgwqDDjiXDlcO/wp/DklxcYsOVw7/DhcKSwpHDkMKfd8OjXHUwMDE4b3ZcXFxcXFxcXMOpw4XCv8O3w51cdTAwMWFcdTAwMTE4cj7CusKRwrFALMOQRilyRULDusOxw7vCvXfCt8KfJGrCtsKywpBKIFxcYjvDm8OqQcKewqdcdTAwMTNcdTAwMTNcXHZcdTAwMDHCo8KNwpJKXFx2wrJCw75SaVxcXCJwIMK6ecKWwobDhsKWYFx1MDAxZUNNwqbCo8O/w5dLwrjDnMOuXHUwMDE0XHUwMDEzw55cdTAwMWMzwrjChcK2w5DDkVx1MDAxMsKYd8Okwp4jwp3CicKXwo5Jwr7CgsKXNkvCm0pcdTAwMTNDeTnDs8KrXFxcIsKswpFcdTAwMWHDryU5w5XDiGvCrMO8XcKLw6VcXHRcdTAwMTkqPsODwpvDn8K7MsOIbMKzw6fCgijCrcORWsOAw41ZKibDrVrDvcKFw6wjQFx1MDAxOHQ9TcOWXHUwMDFmwqjDn0vDpVfCg2fDocOJXHUwMDFiQcOtw6TCmWx4Pz1KZMOcR8KEw50ywp3DiVx1MDAxMsOVXHUwMDEze2HCsibDncOLwqzCjEXDgcO2wrpcdTAwMTDCrWNcdTAwMTcmTELDi8KDwrnCpE/DnMKOXHUwMDAyOcOvXFxmT3DDgz1Awrk9QMOmwrbCk3fClsKKw6XDrVx1MDAxZcKKw7LCpUXDslx1MDAwMcOfwrHCsl3Do8OIw4zChMKJfjVAwoTDksO0w5Fiw7rCjsKDc0LCm8OGwprDusO4woRhflx1MDAxOMOzXFxiw5rDo8KhWcKBWcKOw6RcdTAwMWLCgcKHXHUwMDFlw4zDpMO7w73DvMKhW8K3ZsOPwolcdTAwMDRcdTAwMTFzwqhPwpjCplvDh8OtcMONfcKqw5stwrjDsWnDucKiIMOQdcOJw61mI2XDlFxcdMOSa0NcdTAwMWTDrcOjwqF3fMOHwrpFw7wgbFx1MDAxMMOGw7/DpmRTw4law7vCssOww5B0R8KoRFx1MDAxMcOLw5nDk1x1MDAxMsKXwo5cdTAwMTbCjMKpNsOEw4ZcXGZxMMKGLVx1MDAxMjI9fVx1MDAxOMKZempPJDZ/w4Ivw550SMO9woTDjMOxwqVcdTAwMDRcdTAwMDXCkcOlQz/DicOOw61cdTAwMTVdKsKsw7pcdTAwMGU+VnrDhMOBWEVcXFxcwrhcdTAwMGXDg8OZwrBfwrvCnUPDkcO1XcKJw5nDucKXwpdmXHUwMDFkw5ckwoZcdTAwMTTDiVx1MDAxY8O2XFx0UT1AUsKQM8Kdbj1KY05se2RcdTAwMTdcdTAwMWRNIUbDu1x1MDAxYlvCmsOsw4szXHUwMDBmPUDDm01xXHUwMDE4wr/DvCfCgsOzw6dcdTAwMWPDtsO5b8KOXFxcInpjw4VYw4ZcdTAwMWXCr8Klw6PDvHPCgWh+wonCu8OJwrpcXGIhwofDqVx1MDAxOcKIJ8KxXHUwMDE4dCU2XHUwMDA1wpDDm8OMw7M2VcOrdcOOYMOLRlx1MDAxZFx1MDAwNnBzXHUwMDFmwrjDo8KNfHXDvlxcdMORXFxcXHAwcCdBMXJLXHUwMDA1w4XCssOFOMKlTi/Dg8Ovw4tcdTAwMWPDg8KQwpZvw6/Dr8ONwpjCt8KsWcKgwq5GwpLCu8KzaMOkLiXDgMKgwpfCglx1MDAxNcKOwoo9SsKuwrgqwq3DjjPDk1RCXHUwMDE5w5A9QF5SwpjDtsKya8KZfsOpw6Qrw5E5wrPCicKgXHUwMDA2OsKbPUB+wrR4w6E1McOOQ8K+wpbDnF9ew75qXHUwMDBlwpN4XHUwMDFmw7Qlw4fDnlx1MDAxOcOuwptnwqjCrsKcSCPDjMK3w4JBXHUwMDFmXHUwMDA1wrpMw5V8w6Ryw5TDm3tGwolZfcOvXFxmXHUwMDE2w5HDsy5nUMOIwqZrZMK3KXDDusK9IcOnYsOUwrpcdTAwMTBcXHZBwp1cdTAwMTfCsmHCosO3dcKEfn/CnMOmK8OqwrFcdTAwMWUww6bCulx1MDAxZjBcdTAwMWXCqMOVXFx0w7olXHUwMDE2csOdwqHDjFdDRD1Kw7XCjC7Cs8OxXFx0wr7DnsOMw7PDlVhDw7/Dt8KFfMK4UcKdZ0tcdTAwMDXDnFxcYsKFM1x1MDAxOMO8YkJcdTAwMGUmwqDDplx1MDAxZVx1MDAxYcKgw5fClDDCpyt/TF3DjFlPwobDocK+wptibsKmXFxmecO5LVx1MDAxMCDChcOJacK5wpdJw4XCvMO3worCrMKnXHUwMDEyw4pxwoJmV1x1MDAxNlx1MDAwMz1NJVx1MDAxY8KxSMKNXHUwMDFmY8OHeUZcXHTDoVx1MDAxN8OLw7HDnsKHR1cpXHUwMDEwdUdwVcO8T8KUwpHCkMKTY8KAwrLCosOSwp9cdTAwMTJcXGLDpTLDhyPDn8KvdsKQL8KlOMK0XHUwMDE1esO8w5vCoFx1MDAwNMOawqLDnsKLw4DDj8OUbkpcdTAwMTZxwoZvw5RKw5PCq2tcdTAwMWN8wo7DocKMw4UwXHUwMDE0w7TCoDzDkUrCqMOkwoNow5Fkb8K/WVRcdTAwMWTCgMKjwofCo8OHXHUwMDBlQm9cXGJCw4Buw6dUw7tdwr9cdTAwMDHCm1x1MDAwZsOCPUrCrnfCgThRwrFeQMOySkpYXHUwMDFhXFxcXMO2wozDtyXCrMKFw7F7XHUwMDA0w7c8w7LCqlxcYsKTe8K5w7PCnE1TeMOYVsOTw6Q0XHUwMDA1w4PDn8KSw4t4OcKQNFhkwrTDo8KbwoTDn8OeXHUwMDE3S1x1MDAxMsO6IF9IwqQ2wo1dO1x1MDAwN2Iuw4p2wrbCgcKBL8K8N8OCXFx2wrTDv8ODw7fDkUx5XHUwMDExw7fDicKoZMOJbMOewpfCtMOOwqHDpcOgTD19JURJw7zDicK5XHUwMDA2wol2w6Izw6VcXHZZZFx1MDAxZjh+wpfCkmrDmcK1w4dcdTAwMWUvwplcdTAwMGZcdTAwMWTCgy7CmMKcXHUwMDBmN8Oow59Tw64zwrwlw5cgXHUwMDFiXHUwMDE4w6nCvybDlcKBL1/CiiA7wpEhwrtBw6bCglvDhSnCrFnDmMKJw77CpcOrw4VcdTAwMDTCgsKiJlDCk8O1VVx1MDAxNcOePUBvN1x1MDAxZsO7w708w4o+wofDi8OCcsOfwronPU1cdTAwMTRIw6fDlGlcdTAwMDXDiD9cdTAwMDNcdTAwMTXDqcOdwqzCg0J7TMKhwpfCtlx1MDAwNcOxwqdcdTAwMTnCgyUlwqdcdTAwMTLCq8KnI3FcdTAwMTQ4w5hzeMKHwqZowqpgwqRnbWJcXGbDkk5Dw5Yhw5V3w6LCjkTDsV9cXHTCksOpXHUwMDA1XHUwMDAxXHUwMDAxL8Kgw6TCv8KIXHUwMDA0XFx2wrPDq8O6wpBlwqTChVx1MDAwNMO+RcKsXsOQN14owotfwr5lwrTCscKNXHUwMDE5w55cdTAwMTLCs3lJXFx0YX9/wphcdTAwMWPCrjTDuEjDpX4zRVx1MDAwNMKSYcO2KMKIwprDu8Oyw4nDuMOxWVx1MDAxYzZcdTAwMDTDpcKiwo89SsORXHUwMDEywr/ChMOVw63CpcKjXHUwMDA2OT1NdU/Dv3hcXGLDqMKSOFxcXCJxw5tcdTAwMDHCusKlwrlMwrPCjcOjw5rCncONwr/ChMKSw6Qnw4fCvFx1MDAwZsOPwpPDgVBrXFxiw6HDi29Ewo/Dk8K/w4TDisOhVsK4wrgrK8KATcO+w7wuVVxcXCLCh8KEecKudcOtwoBHwpc4XFxmVjRXwosyw6RQQVPDkifCgcK5R8K7woDDlFx1MDAxYsOrSGnCsjVtw4xhfmJxI1xcdsOpblx1MDAxNmE7K8KUU8K2w7p2QcKCwpJXwpfCnClTfcKlw5FcdTAwMDPCgTdCfE7Co8OGwpRgcMO6VlxcXFwvwqIxaCxcXHRRNz7DksKOw6I9QENcdTAwMGbDiFx1MDAxZsKpe3RAbMK5d8Kkw64mw7XCrljCucK8e0dcXFxcO1NcdTAwMTRCXnBcXHRcdTAwMWLDk1LCkcOkJ33DmzXCt1x1MDAxZnnDv1x1MDAwNj1NwpvCtHjDqG3ClVDCnMO7wqp/w5s5wrjDncKRZMK1wrHCksOfw67CoU92wrrCpcO/woNwwp/DkDYuwpzDijfCo8KWf8Oew4nDkEnDsjXCj0bCiVx1MDAxMMOvw5zDgcKQecKdXHUwMDFiw7U1w7Z8w5/CjcOeXHUwMDBmwqDCkMKzwoVYwoPCs01OW8KwwoIvwo7Cqlx1MDAwNWlcdTAwMThew7DCmsK8w7vDgMK8T8KEwocmXHUwMDA1w6Izw7PDkk5cdTAwMTjDjlx1MDAxYcK9w7xELcOuw4HCoT1Aw5XCp8KCXHUwMDBlwrdzw6Y9QGfDr1x1MDAwZcKOw5XDj8OfwoZYw5piwohkwqjCh1jDtsOiXHUwMDFiwp/Dj1x1MDAxOMOjw4nDs8OAwrnDqcKxwqN3YEpcdTAwMTZcdTAwMTXCh3RcdTAwMGbCvsOOwrzDr2rDkMOdwqDDoDFhacOPwpdFM3glwpLCoyvCjMKdw4oqYcKbwrbCo3fDjsKQwp5sXHUwMDE3w6jDlcOxQ8OjwqTDslx1MDAxYy1MNlx1MDAxYy1cdTAwMWRcdTAwMWNcdTAwMWYhPsKWPU1mw7PCisOow6Z2wqpYw5w3XHUwMDE1wpPDn8OiXHUwMDA2M1F3XHUwMDFjwqXCoMOyXHUwMDE2w4dSKMKVw4Flw6PCncKeXHUwMDFmwpvCjcKcwqrDkGDCuMK1RMKmXFxiXHUwMDA2w4bCrMOmXHUwMDBmw61cdTAwMDLDqDXCu0BLw7V/ZVBRw5vDrkZsw4vDn8KtW8OXw4LCm8OfVCZxf8OMIMKJXHUwMDFjw7PCisKkwpU+wodlwqdcdTAwMTTDvW9tWcO5w6h7f8KrwqVIw73CsVx1MDAwN3RcdTAwMWHCkHnDiVnCosKGwqfDoX5wwp46f8Ouwq7Cg1x1MDAxZjTDnVx1MDAxNsOuw5XCkmBcdTAwMTR3w5RQXHUwMDEywqouw5BPY8OIIVx1MDAwNH3CvcOlwqjDqcKeX8KiZsObXHUwMDFiw6tyPU1cXGZLwpHDpX7DlHrCv8Ozwqg4dmPClMOQw79cdTAwMWJ5wqQtwqNvwoLCoMOew4XCjVxcYi8lw6LCgmHDisOGPUrCr1x1MDAxNFx1MDAxOMK5XFxcXMOtw6dcXGZcdTAwMGXCo3XCpnZ4dcKTNT1Kw7lDOWcrdsKXw6pcdTAwMTfDssO/a3VlJ8O5w7TDnEY5wqXDt8OWYCg9TcK5Z3rDoMKzw67CscKYYcKtfmbDlcOMw6/DlMKtXHUwMDE0w63DvsKiVHZBw7xDwq9fXHUwMDFlw7VcdTAwMTNcdTAwMTl8wrfDi1x1MDAxNMOaeDrDhFB3wrDClCnCvsOncMONwrXDoVx1MDAxNFx1MDAxNWXCnMOGwo3DgcK5woHDtsOCb2VxwojDnlx1MDAxYzbCiWLChmTCrlx1MDAwM13DvyXDvUBcdTAwMDTDl8KrXHUwMDA3w7zCtkZzPi/CmFxcXCI2w5vDkMKkQcKNwpxcXFxcw7IjwozCtcOOXHUwMDEyYMKLwrlEPUDDq8K9a2PDkFN0wrjDnMOAw4fDtGnDjE3CkcK6XHUwMDAzW8O3XHUwMDEzw4LCpMK/bcOFwptqwqcpXFx0J8ONw5DDqsKNwrTCoWJcdTAwMTQ9fTrDgVx1MDAwZW5iNGbCkcKCwqTCk2N7MjRbwr5OKVx1MDAxM13DscOTXHUwMDFkwqLCgMOxQMKIw4vCs0VYccOVwoNvwpzDt8KbdWHDtlTDhHnDqMKlSGXCoFxcXCLCvsKUwpJLPMKKwq57MMKJw6TDtFx1MDAxOUDDuMK5wrhcdTAwMTPCvVxcZsKRXHUwMDE4wpJzXHUwMDFjJ8KJI8KnXHUwMDA2wo5zKsOhIXvDicKqw4ZNJWY9TcKDw4tRdsKqw5PCknhcdTAwMWEpaMKdLMOiw4zConzDsVjDhMKrw7hcdTAwMTTDjMKTXHUwMDEwaXjDvXDDu1JvwodewqvDpcK1XHUwMDFjd1xcXCJjw4xcdTAwMTgsf3V3YMOPwq/Cv8KrU3ItUC/Ck8Ksw6zDlEbDncKMwpLCnG5Fwq/CjHFcXGLCs8OWwqNcdTAwMWN1w67Di2vCmGrCksKnw54xX8KfwopcdTAwMTnDgVx1MDAwMWHDkMKCXHUwMDE1worDnsOLXHUwMDEzwoBqw4LDvFx1MDAxOcOtd8K6wqfCgF09TcO6wqFcdTAwMDLDjDtMP3gvclx1MDAxMnRcXFwiXHUwMDEzUFx1MDAxZsKUw7doUcK5XkHDkCTDpkQ8IFx1MDAwZm9XwrZlXHUwMDFlwrZcXFwiwrNcdTAwMWXDoVx1MDAwNjxdwoPDji5PSsKhwprDt8OZW3zCo8Ocw43Cp3dcdTAwMDfCmT1Kw5d8wod/wrB/fShcdTAwMDNcdTAwMWTDjMKHaHnCt8OcOMOaXFx2w5vCucKxXHUwMDBlwp54wrwvwq5BRsKAwoJPwroxw5hcdTAwMWLDskzChcKvw4FNXHUwMDA1w41awp1QL8Oww45cXFxcTlxcdHzDv2xjV21Mw6tcdTAwMWFcdTAwMWLCnXMqw5LCk8KcbXdCWFx1MDAwNMKUwovDucKYw57CuERkO8OpesKlMsK4K8OLPUBcXHRSw5JVw5LCnsKkw4zDsz19TsKiw7LDs1x1MDAwZSxXw6E+V8OHXFxiwqMjwqXDhsOYR1x1MDAxM8OKf1x1MDAxMVk9QMOkw5/DvMKfTEfCtGIow7zCgVx1MDAwMXRRXHUwMDAye3xcdTAwMDbDmWk0TcKETVx1MDAwM8KCTsOdRMO2KyZBeWBIw7PCkkkjPUDDmMODwpZcXFxcwrzCi8OEbcOtw5/CoMOcVsK8XFx2w67CtsKRPUBcdTAwMDTDs8OQTVx1MDAwMyVcdTAwMWVcdTAwMTHCvMOfwr3Dt27DnMOJw7xJw6pjPUB0YEXDs1x1MDAxOMOeXHUwMDE3wqdcdTAwMTfCjsKdwrtcdTAwMTY4JyvDg8KTw5fCjsOFTVx1MDAwM8K5XHUwMDEzOXvDg8KVTz19w79OU1xcYsOYacKlXHUwMDAxeMOgV8K8w6d/wqnDmMKHZUMgwqbDj8Kiwr0oKsKNw57CgMOcTMK8R8OewpR9wp3CucK9w6/CpsOBwrzCm8KbXFxcIsOMPELDs8O6wqBcXHbCu8OTMzPCq23CrMKsPlx1MDAxNXbDssOwSDZZw51eXmzCtcObXHUwMDEww7rCmkfDqFx1MDAxMsOywpo/w6hcXFwiw6rCmj/DqFxcXCLDosKaP8OoXFxcIsOawpo/w6hcXFwiw5rCmj/DqFxcXCLDmsKiPU11RUDCkMK5wqRcdTAwMWLCi8KbXHUwMDE3dUVAwqXCiVx1MDAwNMOawqrCr1x1MDAxOMOPNsK1Z8KTwoImw7XCoEBlwoLCsF9TwpPDicOcw6TDtcKuwprCusKRwqQvXHUwMDFjXHUwMDE0XHUwMDFlwotuw63CjE7CusK+V1TDvifCssKnwpHDqTHCq1x1MDAwNMKhPlx1MDAxOXI9QDdcdTAwMWZKcSHDnsOjXHUwMDE5fHFcXFxcI3jChMKLw5DDqD1NLlx1MDAwMk5cdTAwMDFyw7rCsy49TcKVUFx1MDAxMnDCrMKWw7cuwo3Cu8KKwpDDty49TcK7worCmMO3LsK9wrvCisO1w4Qzw7ZcdTAwMDRZXHUwMDFhMMOTw45yw7rCty7DoipVwqsvwqTCgsKLMFTCusO3TMOHXHUwMDFjwqxcdTAwMGVKwqjDkCbDhMK7PUpxPUB2ajbDlWVcXGbDhDNkwrvCilx1MDAxOcOEMy4mw4rDuMOhwpDCrMObcsOawpHDty49TcK7wopcdTAwMDHDhDNQTcOrwrhfPX3DjsKUw6VcdTAwMGXCrGhHw79gXHUwMDAyw5HCi2bDjnklXHUwMDE5woTCp0RcXHRgXHUwMDBlw7XDqlx1MDAxNsKXw7MzQF/Cryt0w7c5SkFcdTAwMDd0wr5aXHUwMDEydcOqwrXChU3ClcOjwrNcdTAwMTfCti9Xw41PwrROwpHDv31cdTAwMTNDw7LDjMKkw4nClV/DsE/DisODwqc/w6vDtnQnXHUwMDE3S8OBwp9GOcOzPsKyWsOdPX3DlsKTwqXCucKbXkHDuMKAw7BcdTAwMTLCkMOCMyFjXHUwMDBlw50zwqUxXHUwMDAywpHCh8K7PsKWw69cdTAwMTHCtcK7XHUwMDE2QCXCgMK5wr5cdTAwMTUyw6/Dkn7Do1tMw40wwptcdTAwMTJuXFxiL3Y4w77Cqlxcdlx1MDAxY8K5w7B9wro0LcK8ecK8QMK9OMOOwpLDp8KdwptxZcKIw5vClsOBecO/XHUwMDExwpBcdTAwMDdYKcOOaFx1MDAxOcOKX8KPwqXDm0JjIMOZwpU+OWhhXHUwMDEwXHUwMDFkXHUwMDFlcMO4w7HCp1xcYsKpw7lOw5zCocOFQsKrX8OQw4xcdTAwMWRcdTAwMTHDqcKpw6jDn8OUXHUwMDA3wq57w64+TMKVw5xcdTAwMDXCt1dxXHUwMDA0XHUwMDA2woJnO8OJw53DncKTwplfIC5lw4Vuw57CsFXCqVx1MDAwN8Kgw57Dg0ZALHVNw4jDisO0Jy7CjMOaw4nDqsK3wqvDgEXDocO7b8Kfw4dcdTAwMDfDvCXDrXfDt8KXXHUwMDEyXFx0w4YrXHUwMDE4wptcdTAwMGbDsUHDjmhdwptcdTAwMTg5XHUwMDEzUEHDkTk9fSEmwpsqwofDnsKRwpUqwrZcdTAwMDTChlx1MDAwMjxywrBcdTAwMTg9fVx1MDAxYsKqKMOIXFxcXDbDrColQsOIXHUwMDEzw6jDllLDisKewp9kSHtjw47ClFx1MDAxNjrClMKzPMK3NUlcdTAwMWQvXHUwMDAyYWVxwrXDt1xcYm1cdTAwMTbDqsOjw7nCjyjDpSY6QGJUwqDDkibDlShcXHYpXHUwMDEzSSjDucKeUsORwr1VL1x1MDAwMlx1MDAwNlPDmWfCrsOdY3pcdTAwMWV8ZMKew7TDp8OsWcOgwrHDnVx1MDAwMsOHN1x1MDAwZsOVw6g5w5IuXHUwMDA2wp3CnsKiRVx1MDAxOWhowpdcdTAwMDfCjX98XHUwMDE2N8KAd8K4XHUwMDAyw7Fbw5sww50xwoxcdTAwMDdkdlEhPUDCjVZcXGZew71cdTAwMTTDnMKIW8Kqw5PCqcKCfcK8Klx1MDAxNXZhw5TCuj19XHUwMDFmQsKgNcOzw6t/wrl4w67DlsOaXFxiwrU1PjdxY35aw4Yhw5PCgsO1w6Jww71cdTAwMDbCuXDCiFPDlTjDkErDu0RcdTAwMTJ3w7h+w5txOUV2LsODwrTDqcOew5HDqsKhU0TDnC/Cl1x1MDAwZUw7UD19w4c5woVcdTAwMDNyXHUwMDA1XHUwMDA1w7hSXHUwMDAxUlc9QCZcdTAwMDPCtcOCw44vw4NpXHUwMDAxZMOuw63DoDzCg3Bpwr88MVx1MDAxNmxkNcOvK8OUTMKTUsO3wqLCi8Ouwpc8ZsOiworCgsKawr1cXGLDiMO3w61cdTAwMWEow6/ChlxcYsKVwpTDmVx1MDAxYSgmw77CniPCqSnDk8K/w6dcdTAwMDRdccOqw47CpsKUXHUwMDA0XHUwMDFhwqjDhMK8QlfCuFJewoPDs8KCIzNcdTAwMTZGwo1cdTAwMGZRI8O1KmVaw5lcdTAwMDfDhmZJw4bCp8KCw5LDqcOCRU7DuMO7K8Oww71aYnE0MFfDuVx1MDAwZlTCusOoT8K7UX7DrsK9wrlWTlJMYU1hw6jDpsKzTsKJXFxiwp7DvSbCi8O2wr01RX0mwr02wpLCtkQxwqtcdTAwMDdOasOCYnHCmcOCwrjDhcKcwpzCvzvDpcKZwqzCu8KRw4k3XcKfXHUwMDFlw73DkVx1MDAxYcKYwpwrYcKEwplCw5/CksKsPUp9PMOXXFxcIsKnXFxcXFlxw5TCg8KQRcKFfGbDkG1Tw67CpcKKwqfDnMKpXHUwMDEyQVx1MDAwM8KZw6TDuMOKw6TDqsKhXFxcXMKlwp3CgsKtacOgwqrDrDLChcK9w7rClMOEXHUwMDAyw4TCrsKwfsKFw4Muw63Dl8O3VsOJMsKjw6DDqMKAZ0HCv2rChMOFwobCiMOvwqjCrsK/c8KoZcOfwr8zQk9mwo5PworCsVx1MDAxZT19w4lCbCxcXHTCvVvDqcO0XHUwMDE0w7rDoVg7VcO5OmTDsMKVw6zDpF7DjGzDs1xcYsKLw6XCvEDCrcKmw649QE/DmC99wrTDlnVbXHUwMDE1w7svw6DDhcKWT8O/w7TDksOkw4tWwovCvsOcJMKPWzNcdTAwMDXDglfDpzZowpdcdTAwMTTCl8O9woZcdTAwMTHDsntbwojCg8KpQDB2wq9Dwq9cdTAwMDN8O8OzwpQnw4LCv2c1MsOkfsKtXHUwMDA1w4rCh8Kcw5FeJ8KmI3XChzHCusO1w7g8PU3DhVx1MDAwZcOBYUjDiFjDgVhjwpbDuF9cdTAwMTVZw4JfTsKOJCdFfWzDjDrDjkVHw7jDoVx1MDAwM1x1MDAwNcKnw4cmwqPDv1x1MDAxYlnCmWbDh111XHUwMDFhJVHDo8K+RMOBYcOIw7TDg8OXXFxcIifDjcOGXHUwMDEzwrRcXHTCnSMsSsKQYMOWT1x1MDAxZVx1MDAwNsO0wo/CssKZw4LDlnfDkMK9S8KQTjnDv8Oiw6XDqz1AaVxcdFxcYnpcdTAwMDc4RcKywpnDuVx1MDAxZcKZw7l+w6HDrcO0XFx2XHUwMDA1dmLDv8KXXHUwMDEzw7XCpmVcdTAwMTVcXHQ9QMOWwr7CmMKlw5jCrG7DoSbDt8Kxw6hcdTAwMWPDqXrDh8KnXHUwMDE1dcKpwqjCsMOSw57Dl1x1MDAwZnDDtlx1MDAxZVx1MDAxND4rNcOUw5HCkCV5w7ckU3fDmcOMQznDuMKAwp5cXFxcTMKUw5zCssO9w6HCj2PDqsOkScOtw5fCi8OVwpJPVUDCrzg6VVx1MDAxNj1KKsK4az1Ne8Kyw4ZcdTAwMWE1XHUwMDA0PUpzw45qw4I9SkLCk2xnM8K+w4fCpsOEeMKtb8Kvwo/Dl3vCucOawq/Cl8OWw6c+wpjCtMKbWFpcdTAwMGYrKndFw4zCkmUqXHUwMDAyw4LDt8OwejXDjFx1MDAxZXBFwq/DgHVVwojCu3HDmSt6PU1SJ8KPwp3ClCUvesOAYH7Dgz1NLMOywrDCgsOKXHUwMDE0wpbDicKvw5PDssKQwoXCnDzChcKdXFxmb1xcXCJcdTAwMDN2wqE9SsKRwrhcXGLDqsO5VsKmeibDtirDo8O3w7nDnkBcXFxcLnPCpDDDtjTChUJFJsKGTMOWYVx1MDAxYsKww41mP1x1MDAwN8KsXHUwMDEzwo3DmMOPNMOhw4Fnwp3DkMOxwrYtLcKwXHUwMDExw7PDq1x1MDAxOFpBw7bCnMOcw7FcdTAwMTnDj8O5w5BoW8Oow5R5wpLCoFpKwqc8woFhw5HDqErCg1x1MDAwMyFgXHUwMDFmXHUwMDE5wpfDlFx1MDAxNiDDkyVCwqDDjFxcdMKnTkbCpcOselxcdDPCp8KTw7/CocOew6vDtMORV8KJI1x1MDAxY8KeJ3JYccKrw41sd8OZw5xFwrfCpUFcdTAwMTl5wqQuw5jCpFx1MDAwN8KFwoHDoWTCscOIw4AuNsK5ZmTCg8K4e2fCs2/CiMOgwqDCkMO3NMKow7jCrsOfwpbCilA9fVx1MDAxNcKIw7/CnSVcdTAwMTnCs2dSwqMrXHUwMDA3w78hwpfCisOgw582d8KXXHUwMDA0XHUwMDE4d8OWwrdcdTAwMTDDo8Kaw5zCgiQ7VzPDhMOQXHUwMDBlX8OXST1AL8Kjw7zDlcO1RDTDsMOVwq92XHUwMDE4I8OOd8OowqBcdTAwMWRcdTAwMWLDnsOTwqPCpFx1MDAxY8Kyw5jCs0nCtsO8wpPDlsKqK8KValx1MDAxMXTCrlx1MDAxYSFYWk1dSlx1MDAxNMK5wojCssK3L8OYZjN8asKPY8KpKMKRw4LCkiPCvsKEYMK/bcK2akxcdTAwMDRcdTAwMWPDsMOOIVx1MDAwZcO0J3rCi2RqwovDgMOdwqzDhCB7Z0dxw4HCpj1NXHUwMDE1RTnDrMKRw4nCmcOnw6TDo8OeWlx1MDAxMmRMwrbDpFx1MDAxYcO4XHUwMDFjejZcdTAwMWNcdTAwMGbCuGswwo1uw4jCj8KmWsO+w7nDjFx1MDAwMzkgwqlww7vDgWHCsnJzwq1cdTAwMWHCtcOjwq1IwrZcdTAwMTM0wrlbOHfCgCDCqcKmw6TCnDl3fcOdw69Ww65Rflx1MDAxMFx1MDAxZMOUXHUwMDEzw57Di8KBXHUwMDEyw6lrXHUwMDFlwpNmwqNcXGLDgD1KNMKyw4kqScK3LsKiccKnT8O3XHUwMDE4w4c7wp3DnMK0wpdEw6tMw5LDucK9XHUwMDExdWNQXHUwMDEyw5TDjMObw6VcdTAwMWLDqFx1MDAwMcKNw4PDrlx1MDAxOMOdw53Cm8ORwq/DtTrDplx1MDAxN8Kjwq7CsFx1MDAwMsOdwrE0wqzCssKtw47Cv8OswoXDm1x1MDAxMcOqYsKtXHUwMDFmclx1MDAxY8KLw77CjsOhw6zCk8KjZMOxw43Ch185wpZBwoJtwrfDgsOow4gmSVx1MDAxY8O/wr7Dt3PCoMOEw4/CmWjDk8K4w4JqbVxcYsOJwpA8w5DDrmhPwqXDhDJzw4zCszpcdTAwMDPCjMO2PX1cXHY9SnFvZsOrwoHDqMKtw6tyw6XDk8OywqNcdTAwMTPDtVxcdFxcdsKnw67ClyjDqsO2UMKJw4LDg8KvZnzDp1x1MDAxYWUkw5XCisKWO8OMw7/DjMOnwpYmw4DCpnHDkcKtw49UbsOmwrpcdTAwMTBWwpHDs1xcXCImwrpcdTAwMTVKX1bCpcOCwq9Mw65za1lcdTAwMTN3wpY3XHUwMDFjw4xcXGLDhW7CisOywplcdTAwMDXDi8O7alx1MDAwMT/CvzVNw6nDhMKzXFxcIsKsXHUwMDEwXHUwMDA3wrxtVMOBwr7Dqlx1MDAwM8KSMVx1MDAxNnc9TcOCwqoycDnDpVx1MDAxMFx1MDAxMzVcdTAwMTAmwqHCiDRcdTAwMWNcdTAwMTBoXHUwMDFhWWLCiVx1MDAwNMK1XHUwMDAxUkZxwqw7wqtGw5LCtsKNXHUwMDFmwr3CgjVYwqJ8XHUwMDEyR2ZcdTAwMDbDk0l4w7rDucKWw7lHSm5sXHUwMDA1w4nCpUnCmGBlOcKKw6LCmVx1MDAwNcONTMO9w7E7e8OswohjXFxcIsKZN8K9XHUwMDE0YsOkPl7CsmUzXHUwMDFiw4fDpFx1MDAwZVxcYsKPw7F0wr3Cgy0gwq9cdTAwMDXCl0YwwoHDiVx1MDAxM8OGwrtPXFxmw6PCtMKcfcKcw7hcdTAwMWEoUcKpXHUwMDE1XFx2woHDl2LDncKMwqJvwrjDt1XDpMOvXHUwMDBlwq/Dm8KHXHUwMDExTcOGRTtywqg2w5rCqG7Dqlx1MDAxY8OOwoM3w6w0wpdcdTAwMTjDhFtXwoNcdTAwMWMrw4rDpVx1MDAwNcKiUcOSwpUsw5HCgD/CgcOFw4AkXHUwMDBlw456w5PDgcOYKcOvKFHDrsO8wqjCr23ChcKJwqR2VUvDl1xcdMOtw4NuXFx2w5pyVcO8V8KqwozDlsKTwrXDiVjDncOCWsK3XHUwMDBmw6zDmMKSbFB5J1rCnsKfO1t5c2bDg8KiXFxiwoHDisOVwoxcdTAwMTJcdTAwMWbDvS1ywqHDo8KSbVx1MDAxMsOYw7rDnsOmb8KSXFx2wpxbVsOowqE2w5RkXHUwMDE3VkHDh8Oqd8OwXFxcInnDolx1MDAwZsKcWzxSw7XCssKmwqzCgMKgaMOSIcKAXHUwMDE0wobCusOtc8KDXHUwMDExTMOQQMOHw5DChsOuZsOSw73Dq8KGw6TCu3XDoUJHw7ZvXHUwMDE5RcOyT1xcXFzDl8KdwrN2McKdw6vCo8KGw6PDisOZRMO2T1xcYsKAXHUwMDExPMODPUDDo27DkMO4b0jDrVxcYsOXXHUwMDFiw43Co8KTXHUwMDA3wrfDnMOawrF6UMOtwqZcdTAwMTnCszjDikzCjTnCrsKxwrRgwrduQlZEwo7Cl2LDhsKNJ8OtwoLCt8OIQybDoC5ec1x1MDAwZnXCrcOzw43CsFx1MDAxZTrCusOTXHUwMDA3w5BcdTAwMWXDvW9cdTAwMWNcXHbDkcK3XHUwMDBlw63DuTpcXGbCvsKCwoPDn8KFXHUwMDAxb25IT8ODXHUwMDFmRmh8XHUwMDEyQCBsPsKkZFx1MDAwMsOibDbCl1vDj8OZPsK8w7DDpMK/wqbCpMOjw4I9QMKBNMKfw4XDvVx1MDAxZsO1w6/CpMKnT8K7w4xkw7fDgMK1dsKJU8OKwphcdTAwMGY4OMK0wpLCpTXDumjCtMKfwrs1wpLCuiM+w5FTw4FcdTAwMWZsXFxcIlx1MDAwZl5cdTAwMGbCjFx1MDAxNsKTeH1Yw7LCm8KUWlx1MDAxMcO8V8KQMMKdXHUwMDAzw5pkw4HDssOew7hPXFxcXMOHRcOywo9GXVnDo8K2QWrCt37CiV7Dt1x1MDAwNcOcw6vChjomJMOjw7bCu8OTeMKHQHLCh2zDgcOrOVxcdlx1MDAxZcK2XFxcXMKAw6vDiMKrXHUwMDFhwoXCnMO6wozDvkfCm2LClnloZsKueMKJwrQ8Q0BFJybCncKVwpvDlsOGwrPCoVx1MDAxY8KtTS09fcK5alx1MDAxOcOrXHUwMDExwrXCgULCucOGw5DDvDnCm8OkJ8KBwpbChic0w6nDmyk0w6nDm8KkL8OyW8KkL1xcdsO4wqgvemItwqMtfsKYZFx1MDAwN1NMwqnCv1x1MDAxOTDDry55wp3DjMKGYVx1MDAxNMKOw6dcdTAwMWHDtyc0eFxcXFwvMjXDni/DsFjCn8OeXHUwMDEyXHUwMDE4KsKfXFx2XHUwMDEww4ooQVx1MDAxMVx1MDAwN1x1MDAxNMOmRVx1MDAxMT1Nw78jw6LDuFExcsOGQ8KZwq1Gw7jCrGDDmsO4d2jDksODXHUwMDAzw47CgcKNdUpcdTAwMGXDtFMpw6hwcVjDp1x1MDAwNMOiMGDCglxcYsKmw6k9QEFjwqfCtFVPw5fCg8KsXHUwMDAzwp5qw5crw6VGRTzCosOnbSB6YFxcdMKqI21VXHUwMDBlVybCosKZOjp6XHUwMDE1w7JvwpoqwpjDrMOTdmgjM8OIY8OLf8OhMifCmcOZwoJwwrx0w7XCu1xcdMKiw7FSwrJvw7bCncOmUcKaXHUwMDE0w4PCgSVcdTAwMTgmw6nCgsKvPCZKXFxcIsOObHXCl1x1MDAxY8OGwqAoLMKFMsKyK080wq9TwqzDhMOmw5nChTHDt8KCd8OJLlxcdMK/ScKIN1x1MDAwZXLCpMOPUsOjVsOIY3jDvEp0wqh0KCXCosOqwoHCg1ZMScKJwpfCqsOmXHUwMDBlYmlBJMOOwpgswoh8wpDCoMO6woBcdTAwMDfDu3jCt0TCncOTIVx1MDAxMcO/IcKWW3jCrU3CmG/DuMK8ckxcdTAwMDLDr3TDm8O6wprCllnCgsKcXHUwMDA0w6DClVHDrXFcdTAwMDPDjcOqdzjDgjXCq1Mzw6bDs3TCrnXCvMOMw7bDgnrChMKaLMKsw4vDiVTCjsKMXFxcImRGPsKawrPDi8OHRjjDkFHCqsKkwrd6XHUwMDAycmzDu1lzwpHChcK6Y09YPX3CtcKKw4FCXHUwMDE5w4hcdTAwMGbCl8KLRjzCoz1AwqnDicKXLSvDnMK0w6ZAw5DDt3xFanlOwrjChXw5wrrDuMKjw7PCiMK7wpDCrsO5woXCocKvw73DmcOlwrbChsKlw5/ChSpcXHRtwrs8wpbDuFx1MDAwZsOHwp85ey7CgWMoXFx0LMOTXHUwMDFiacKkScOQXHUwMDA0SHJeJ0vDpUM6YCrDsMK2VTtnTcKSwpY9TUhmLlXDtUl3XHUwMDFhclx1MDAxY3FcdTAwMTVoVFBmJ8KyLMOeXHUwMDFjSMOwT8O7w6dBXFx0QsK5wpnDjT1AXHUwMDFlwrPDnE3DvlxcXFxcdTAwMTMwwqTCoT1KXHUwMDAyOF06w4vCssKhO1x1MDAwZsKvfFx1MDAxM8Oow65MwpPCi0lcdTAwMDZfw7M+YXXDv8KQwrgoQMOGV2RsWcK0wrzCiMOcw4M+wr47wqtYw7ZAVWHCr0nDjFx1MDAxYsK3w5nDqS43McOyw4BcdTAwMTVAO8OsV8KxZVx1MDAxMlx1MDAxMljDhlJcdTAwMTV1LMK+U8OpNHvCm8OsIVLDicKpLcOiX1x1MDAxM27DnDBIwrDDqjZgWHZNw7bDpcKew6RcdTAwMDLCpXrCiMOAXHUwMDEyw4hcdTAwMGbDgD1AZsOmdFx1MDAxZsO2ZFXCokVxwqwvwqnDhMKewpVLUFx1MDAxNEw9TT1Kwppnwp0yXHUwMDAyWsO6RVx1MDAxZsK/P8K7w5pcdTAwMGZUf1xcdMOKQcOmwqM6XHUwMDE1wrNMXFxmwr1Mw4bCiVkpZ8OeXHUwMDBlwrbDtnTDg8KPP8OAwoVcdTAwMDR9LcKPXHUwMDE5JcKmUcKuwrVJJMK/XHUwMDE0fsK0TjXCvT19bnLDp3lgw5Ivwr1IOzFcdTAwMTVXwopIKMKIwoVUOVkjw7fDi3JcdTAwMDHDnlJcdTAwMDdnJ1nCq3jCi8KJNXzCjsKbwp5SwpLDt0ZHXHUwMDAyecKqw6DCoX7CmcK2O3bCgcOwXFxiw7t+w4tZw5xcdTAwMWFGPX1cXGbDmjrDjS/Ct0tQw4orw5bCtsKaeMK9YsOTJcOnXcO9w7fCt1HDoHIwLE53wpDCty7CoirCssKEXHUwMDE2woI6wp7DrnvDlyB7WsOJwofCsMKaw7dEw5sswoZoXHUwMDFiwpxgdlx1MDAxNGZGY8OXwpdcdTAwMThGwoDDo0w9SsO0w7bCmixsw5tcdTAwMWNGw5jCv8OSeMKWfFx1MDAxMF1Ew6FcXFxcw4VcdTAwMWZsw4XDuMOsO8Khw4xaQMOWwphpXHUwMDA3KsK3w4vCk3HCpsOHwrZAUVx1MDAwNW3Dt3B1XHUwMDEyPMO4wrDDoMK1wrxuXHUwMDA2cVxcXFzDq8OLworDvcKywq/Dm1x1MDAxYXzCnlrDhcKqXFx2w7Mvw5HDicKZIDp+XHUwMDFlSsOgwqh/wqFOwpNBw4XDpsO+w6DCv047wrpyTlnDoFx1MDAxNMKRMcOWwoB3OlJcXGbCq3fDtTNcdTAwMTDCkcOIwq5lwrbCucKywrFuw7TClX3DqFx1MDAwZsKOw6TDl8OBVMOJw5cjw6ZcdTAwMDHCnlx1MDAxMUfDmcOpw57DozHCkMKFw6lMwq1fw5vCs8K7UcKPw6pdXFxcIjhqVFx1MDAwMW5Uw5NcXGJBQmzDtGTCnFx1MDAwNlx1MDAxNkZLcnwwwp1UTVx1MDAxMMOLcsO2wq3DgcOMN1x1MDAwNX4/bMKPw67Dn8KrPsKidMOOXFxcXMKYw7M9TT19w4jDksO0YnrDnH7ChHs1wrTCkcOWwqxcdTAwMWPCtsOzdMOIw4LChCMxVMKmwo1owqHDicKbeT5cdTAwMWZcdTAwMGbDp8OWPkrCmsKLw5vCkXlCXHUwMDFmK8KAfz4kw7PCtMOBV30swrjDpMOSw64jw4NVXHUwMDFjwo/DgSzCljnDqFXDqMK/XHUwMDE1wpfDlMOPw49UwrLCkMKGcMOXM8KAZ8OBw5TDlMKIPUrDgnlcdTAwMWNcdTAwMTd3w7XDrz1Afl96wovDiMOOPMOgXHUwMDExI8OzbEnDjMKPw6HDssKJwqDCvMOBw4zDsmZcdTAwMTPCgcKzw4jCm3XDmMOEw7tcdTAwMDfColPCnGdcdTAwMDPCmcKfUcKSXFx2wq3DuMKBwphGwqrDmWHCq8Kew6zDiG/Cn8OSSlZ3VVx1MDAxYWZCZFx1MDAxN2jDoCpcdTAwMTbCqcOvJWXCu1jCqsOxw5E1RGzDg1x1MDAxM8OMXHUwMDBldsKxXHUwMDExw6lsJD/DtXTCj8K3MsO8w7DDnMK7XHUwMDBlasKiw7bDq8K8bFPDlcKHw61Vb1nDjnlcdTAwMDXCv8OpPCt7ccKFwp/Di8KHwpZrwozCsMKAd8Kxw4FZQcKaw5tcdTAwMTTDiGLDhMOyRcKNIMKkXHUwMDA3wqJjwrzDjVjCmcOdwobCgsO2XHUwMDFkcjtMXHUwMDExw7XCosOxw57Cs3tcdTAwMDTDryA/w50se13CkFx1MDAwMVx1MDAwM25UXHUwMDA0wozDqyZkfSNVXHUwMDEyM8OlwoDDil1cdTAwMDLDnMKcw5xcdTAwMDLDpHbDh8KYw7XCocOZasOfaMO5Y8Ofw4bDqcKWwq/ChFxcYsOuw7NcdTAwMTDCkmprMFZcdTAwMGXDgcOiMMOlXHUwMDE0w5bDmMKnXHUwMDAyaVx1MDAxY8O1w75MwphCw7/Co8OFwpXCjsOYQFPDvnTDu1x1MDAwZV3ClDtpNTc+Nz/DrF3CgDBXw53DnVx1MDAwND19PUrClVJcdTAwMDVRXHUwMDFmwpXCisKJw47DmWTDkMKCXHUwMDFkXHUwMDFhw7DDnlvCucK4VG7DlsKrwoNrw4deNcOQXHUwMDAzXHUwMDA0wrs8J8OZQnrDvlLDtlx1MDAxZFx1MDAxN8Kvw4HDvVx1MDAwZlx1MDAwN8Ksw4PCqMOewonDlcOEw7bCtMKnIMOywphYX1LDi8OxVG1bw5TCkFx1MDAwNVDDt8KuICZcdTAwMDXDjMOvwrTCv8OGXHUwMDE1wpfDlFx1MDAwNFx1MDAxN8OPXHUwMDE0XHUwMDA0WFxcdkgheVx1MDAwNzB5w7BcdTAwMDdBc8KJw6FnQH4je8OzK8KXXHUwMDE0w5nCocOYSlx1MDAxYcOVw4xLwq3DisKfXHUwMDEww5NcXHTDt1XDjFx1MDAxOD1NbsOfwojDkT1ASMKLwrV1wrtOwrZ3wqhcdTAwMDJcdTAwMWZjw5dgw41cdTAwMWPCgcKiw4E0XHUwMDE2PsO9WE3CocOgw708Wzcyd8KGIcO9JmF0SHQ9fWU6w5/CrsKsw5PCkjNcdTAwMWVcdTAwMWUkwqZhcMK6XHUwMDFmwpTDoMOhwonCoMKHJz9ywqZ+KcKSfyd6w4I3fmnCksKCfsOpwrpyKlx1MDAxNn5Xak/DmMOkwqsvw7nDp0NBO8KJw6dew5jDqFRawpTDkcOVwpDDjDvDvGo9fcKOwqt3w73DvcKrJMKxfFxcYsOXw5A6NcOfw5hlw7nCsG1cXFxcc1x1MDAxMi3DvsKdXHUwMDBlQ8OGw7LCpsOnwoPDsWZGRVx1MDAxNMKBw71cdTAwMTQ+wpTCsMKhw44sNj/CgVx1MDAxMD19w6RcdTAwMWY0wqrDhcKeJMO0wpJcXFxcN8OuwofDqmZsw7/Cg0/DplbDsFx1MDAwNVx1MDAwZsOSwonCnsK0esKGN8OpXHUwMDA3w7XDmsOGw7dcdTAwMWXDqcKUw5LCosKjwrbDpMKXw7DDqETCtMOzwrpcdTAwMTg9SsOLZE02wrBUwotIwq3Dhzg9TcOHXHUwMDEyPUDDlMOtVsKVVMKnwrd6w41OwpNcdTAwMTjCi8OOwojDo8Osw6rDvMKaXHUwMDA3LHspwo9VwrZmwrl/w7c8XHUwMDA1wp1cdTAwMTDCrsKXXHUwMDFlSDfDpcOXwqPDqMOMXHUwMDAzwro9fcKQw7jClz8lXHUwMDBlOHnCtMOEQFhcdTAwMWY6VsKcXFxiw5sqXHUwMDE1w7LDuCbCtD/DosKYwoktWMKBw4t7V8KeXHUwMDA0Z8KGw6duwoHDoVx1MDAxM1x1MDAxNGY5XHUwMDE5w7TCocO9wrFcdTAwMWbCmsO2w6FmwoZ3NcKFXHUwMDFjw4J/XlfDrsOOZsOrLT5cXGbDvMKmw6XCtSXClFxcXFxcXGZHZT1NR1s5dsKaw4FcdTAwMTbCoMOObFx1MDAxOUszWVx1MDAwNkNZwrZzwo3DgsK4w5dfe1x1MDAwN8OpwoTDocO9w47Cu8KkVlgxwpTCocKsw5FcdTAwMDY1XHUwMDFlwo3Ch8KJw6nDmcK0f3nCkVx1MDAxNT19YknCvMKyLMO5TsOjw5LCicOZXcKawqRcdTAwMTldXHUwMDEyZS9vwpXCt8OGJsOSXHUwMDE3wo8uwp7DmMK+KDxcdTAwMDTDuCnDr8KBWcOhw4TDnFAjw50uw4/Ds0fCo8OAwqJTXHUwMDE3ScKtwow1wofCgFx1MDAxNsOkLS3DosKXwq/Di8OaQMKVJ03ClG3Dq345w7DDilHCssKPU8OsTMKMw6Z0w6UmwppoIMKSW1x1MDAxNMOfw7bDjkEuw7/DjsK3XHUwMDFjw7cyw4otwoXCjU1ww5Umw7zCoVx1MDAxNMOlPX3DoFx1MDAxMMOqw5fCjGbDoFJsMEfDt8Klwps8w6U9TcOUSsOzw7jCk8OjwrUpw4NdwoDCkknDjMKtfjXDkGkjMytcdTAwMGUhwqTDqcOKVMKVcsOywoY8wpVWw7hRdcOyam7DlTJcdTAwMGXDs8O8w5g9TcK0XHUwMDA1w6/DklfDvHPCmF3Dv8ONbMONw5TCrMK4dFPDu8KbR1x1MDAxZsOew4NZW1Qvw7vDjVx1MDAxOXNWIFx1MDAwN1x1MDAwMlx1MDAxMjnDrE/DjVx1MDAxMMK/W18gwqcww7xmwr4nwoLDvnFewq7CnlNWw4NcdTAwMDJcdTAwMTY+V1x1MDAxODNcXHRgXHUwMDE0elxcdsOMXsKawrVcXFwiwrZAw5PDqsOCI8K2w65xw4I6XHUwMDE4w7pzwqPCsHQsPsK+wrPDu8KePMK+Z19Uw6bDh2jDnlxcXFzDlkJVwrVcdTAwMDTDgsO2XHUwMDBmwrppw7PCmMKzw6fDmVx1MDAwNlx1MDAxY8OCwrpcdTAwMTldw4/CosOfwo/DhDLDmyY8w6Q9fcOLZlx1MDAxNiTCqsObe0TCjsKeeDvDhsORwoPDjmMyw4o9fcKWZMOsWsKLaGDCvsKzwp5cdTAwMDEgfMK9wpw4XsK1XHUwMDE2wr/DvFx1MDAxZcOtwqHCs8KDw6vCqlx1MDAxYkxcdTAwMWbCnE7CrEI2d8K8TW4twpVkwq7DnFxcdlx1MDAxYUXCp8KGwqowwqsvTsO0PiVcdTAwMDHCh8K1ODM4w65cdTAwMTY/XHUwMDE0TFx1MDAxZiTDpSRja8KWw4TDiD1Kb8OJdUXDhi3CuGrDsDFwPX1iXHUwMDExJMOROz7Dj8K8wpXCrMOAwodcdTAwMWbDtVPCncOhelp3XHUwMDEwdlx1MDAxZVxcYsOFw5kkesOow7FYwpPCi8K4W0XDp8K0cC/DkcOMw6tNXHUwMDFkfGhzwpXChMOJw7/Dt8Klw7XCssKiw6bCglx1MDAxNzR7X8O0wr/DlMKCw4jCl8O6wpbDpsOawqbDgCduYFx1MDAwN1x1MDAwMcOmw4vCm8OWXHUwMDAyXHUwMDBlwoxvw6Fww5BoNVLDrsOrwrxjOcOlwrbClcOdcDdPXHUwMDE2wr/CqFx1MDAwN8Opw545w4bDi8KBw4jClcKqUsKSXHUwMDEwwoUow7PDvcKzwoM1eXHDt8KVwqN9wppcdTAwMTbCtCpuw6/Ci8OGNsKXfn/CjHZRw65GY8OewoDDulxcXFxEdG7Du8KiwoFnbz1AO2fDr8OYw79wXio/XHUwMDBmdUV/S8Kec01uw4QjXHUwMDE2M8K7TD1NXHUwMDFlw5NKXHUwMDA0w4Q8XHUwMDAzXFx0RVx1MDAwMsOnW3HClWRMZsOywr5Uw7xxfFZLw5Atw4w9fVxcYsKMfcOKT1TCisKXTEnDv8K/ecOgw4VcdTAwMTcxcMOPwrNcdTAwMTLCs8OsZcOaXHUwMDBmX1Y+TVXCpsKjd1fCpsK9wo41w4RiwpZWK8OtQ8Otw7zCmHfCosOtclx1MDAxN8KBK8OpXFxcXMOTwqJ0XFxmwrVcdTAwMGU8w4/CunvDt1PCi1x1MDAxMFx1MDAwM8KpXHUwMDExw6h5eMOaVMKfwq1cdTAwMWR9XHUwMDBmccKpw5d6UMODYsOUw6VNJ8Olw4J5woDComHCl8Oew4zCoTnDrMOtw7TCtD91w6Q+w6IrXHUwMDE4wo5nTsKXwq1cdTAwMTbCvcOhXHUwMDE5woDCosKJUmIww5A0wql+T8O8w7LCvll5KmUzfG7Cp3dQL8OPITFrKG3Dhy7DosK4wr7DjVNcXFwiKsOFw5xxPnJcdTAwMTLDrCjDm1xcdsKmPUpcdTAwMWQwaCrDk8KGScK6XHUwMDEwXHUwMDA1dCVswoVCI1rCk8KLTMK8d8KPa8OQRMOyw7JcdTAwMWLCgVx1MDAxZX1FwpZMUWfDo1Rha0NcdTAwMTXDqDbCrMOWUcO4X3ZcdTAwMGbDlcO1w5PDmsOPXHUwMDEyIMKTw6ZuI3rDkTnDmsKRw7Vrw6LDjMOzwotzw5FcdTAwMDEpcV4yw4jCtWlIOMKEd2o2w47CrHrCmlx1MDAxMsORwoc0w5NGw443wpTDjVx1MDAwMsKDwrdcdTAwMDEowrrDnsK6wqrCgF7DhDDDm8Ohw7TCgUPCj8KZNT/Dt1NcXHbDtsKjXHUwMDE4XlxcXFx0XHUwMDA2wobDtlxcYsOQXHUwMDA3XHUwMDFkwopcdTAwMWPChcKpwopcdTAwMWPChcK3eWPCusKGXHUwMDBlwpHClVHCqcOVwqvCl8OUw67DoHpcdTAwMDHDk1lyRVx1MDAxMMKVwrdcdTAwMDJcdTAwMWFcXHTClTQlYcOewrdcdTAwMWVtXFx0JcKtO8OAVMKAXHUwMDE4fcKyIcK0wonDncKAXHUwMDExUsKwPU1cdTAwMWNcdTAwMTY/XFxcIsKowo/DrcKQS8KTVcKeXHUwMDE2LUrClGrCjHBcdTAwMDXClSY2PU1hwolYw6dEM8O2NFjDt8OKXHUwMDE4wrTDosO8UUQge3vCn8KTLcORw4pkwq7Dn8KWw4JPwp9HdC15XHUwMDFhO8KMMHdwI8OzwqLCu8KZwoTDh8KOwr5Uw4PCnTdjw4NcdTAwMTLCuGdhXHUwMDAxO8KaXHUwMDEyXFxcXMKlwqJSTD1NwqPDjMO8wrVcdTAwMGVcdTAwMTY9Sncyw51FLzbCv8OBw7bCqMOtw7xISsOrMlFcdTAwMDRqKcKBwpFcdTAwMTbDosOOwpvDqsKFTFg8wonDp8OPZsKfwr/DmMOVRS0hw4x1KsOlwonDs08gNcKfVFx1MDAxYWbDmMO6T3ZVJsOrw5ZcdTAwMTjDlT1KIVx1MDAxM1TCgFx1MDAxZk3CtEV5wrnDucOQw7HCr1x1MDAwMj1AU1x1MDAxYsKkXHUwMDFlf3J7TDHClmXDh8KcXFxcXMKHXHUwMDE3w65/Q8K7XFxcIn1cdTAwMGbDpVfCv3PDkEhMw7h9w6jCnX/DqMKiLcKfdMOlf8Kcw5/ChVx1MDAwZjVTwpfDkcOGd8KBw7HDlMK8wotGRFhRfTg6wrJuOCrCocKgdDJwwqfCn8Omw7Qrw7w9TXjDo1fCh8OHw5bCnMK6wo7CjVx1MDAxYcOcwprChyDDucKGJsKKMcO/OUo9QMKtwrvDoy1Ow5TDgn/CrTAww4Nlw4BcdTAwMTbDpCvDj3vDlFxcZlx1MDAxZMOfZHh0XHUwMDFiUi/Dmy7ClD1KwrzCoMOVwplcdTAwMDLDn8KGwpzDp8K7P8O8wpJBXHUwMDFlwoBpw7zDp8O2wqZXJCzDlMONLsOnZ8OwMHVcdTAwMTLCvFRcdTAwMDRKwp3DlcO9w6/CpcOsakZrLMOibMOywr14w5TChMKtcnTCkjhZRcOMScOAw7pcXFxcdVPCtsKfw5XCp8O2XHUwMDA1esO5w4Yrw6LCvMOAP8KXbsOhNVx1MDAxZn0xw4dFw6tcdTAwMTE5MTXDo3DCsMKiXHUwMDE4W8KHw57DvsOBJsKuV8KCwp4uwqfDkWNcdTAwMDJAXHUwMDFkQMKfSsO5N1XDo8K3KcKDO8OVw4rDmMK8w5HDuD1Kwr7DkcKowopcdTAwMTLCg8OiwqHDglx1MDAxOUhcdTAwMTUuVC1iw6skw47Di1x1MDAxY1VFSsK9XHUwMDEzXHUwMDE1XHUwMDBlw615XHUwMDFlRcO9VMOePU3Do0VcdTAwMGZcdTAwMTnDosK4XHUwMDEzPU0rw50jJWgvLzI5O8KjwrBcdTAwMDIhw7PCgMKxbH7DmMKIe8OsI8Kzw67CkVnCgVxcZsKVwrDDuMKWMl3CusOgTcKdIcOzwrdcdTAwMWHDvlx1MDAwZlx1MDAxYnPDlyXCnlx1MDAwMcKzw4nCt8OwTsKIKcO2wrBtw6TDhMOmwoLCl8KIwr7Dj1t6QznCv1x1MDAwNkjDssOlwoDDtWXCm8Ksb1Jpw5Few6TCnsKkwq3CiivCrW5oSVx1MDAwNF9cdTAwMWXCj1LCjMKbwq1cdTAwMWTDhsKMXHUwMDE4XHUwMDAzQlPCu17CtGHCoV7CpcKlXHUwMDFmw5LCh8KMXHUwMDFlwqhFMmxEPHjDhcOJwrxpwrjDt8KuwrvChVx1MDAwM8Ofwpt3wqVmw7Qhw4ZpMVx1MDAwN8KTw77ChcOGwpQ9TcKTXHUwMDBlw61SXHUwMDFiS8OBPX1vw7DDjMOVw5zCqE8+b1x1MDAxM2UowqolezVcdTAwMTctw7DDs1xcXCJcdTAwMTnDuMKxw7PDjlx1MDAxMXHCtFxcdsO1XFxcIk5cdTAwMTctw5NcdTAwMWROXHUwMDBlwq7CnsOdw40jX8OUeMKxwrdcdTAwMWPDvkjDgcO6Nj7CgMKIOMOBKcK3wrbCscKhYcOIS8OqXFx2emPCtFx1MDAxN8K2SD/DlsKxXHUwMDA2wrtcdTAwMGbDlMKGXHUwMDFjbcO0MsORw5LDsFtlNcKjS8OsU8KfZMOEwrTDiHIxwp7CicKOw6fCqMOnwpxFWMOJwp7Dv8K9XHUwMDE0w4Z9w4NcdTAwMTbDoWZcdTAwMTFgwqXCpsOUw5ghPUpHXHUwMDBlw6U8w5drw4LCicKwOcK/w6lcXHbDsX1tcsOkwqPCoFTCpsO+woBfw6DDicK/JsOxIcOJXHUwMDA1ak81wp7CriEmS3nDoS3CksOOe8KoSyTDlHXDisKUw7xoesOiV8O4JMKUXHUwMDE0ccKbW1hcdTAwMDLDiWPCj8KeMcKLXyFcXFxcwqdcdTAwMTN6I1XDqMOYQ1xcZsKNwovDv8O8w5w7wqJQwrlcXFwiw4Asw4hcdTAwMTg9QHDCucKsJ8K2NnDDnMKMRMOPYVx1MDAwZcOjKUfDk8OmwoBcdTAwMTMmw7nDvX0rw4p8XHUwMDA3YUR0KVhVw4bDvsKONMO9XHUwMDFhwqhxwopcdTAwMWHCjsOROMKxezTCr8ONa8Kqw71cXGJcXHTDp8K6w5DCpyDCnGXCqMO0alxcXCLCoWg+wqrDncOGXHUwMDBlwptBKMOPXHUwMDAxYlx1MDAwMsOIIGnDlMKNwqPDpMOYXHUwMDFkw6bDv2I8w7g9TcOsW8O6UMKCPUouXHUwMDFjw5JdwpnDjVvCgMKOw4h5w5tkM8KOwoVqwrNwwrQrYnN/wp/ChsOKw6BwXHUwMDA0w6spdcO+wpdkwqbDjsO7XHUwMDExwpnDpTrDnHdqaMKLXHUwMDAzwoDCgGHDlMKFXHUwMDAxwrDCl8Opw4tDw4DCm8KqZ8KjODJ7czbDpVxcZlx1MDAxZlxcXFzCskrCq8OqeMKMw63CmsOgw53CoWVcXFwiW8K4w500McKlQ8Kgw79KX8OIw4BcdTAwMTF+JFxcXCJ9XHUwMDA1TyRSOmjDplxcYjDCv0NtXHUwMDBmwpk9SjpcdTAwMTLCmcKiXHUwMDBlPX00Jlx1MDAxNCclXHUwMDFiw7DCpF0gUlx1MDAwNcOZXHUwMDE3WX5rRmctw5zDjWoxTU7Cs8KUwobCpMKXwqI5wp49QMKXLcK9w5FmwqVPw7LDgD89QMKLalx1MDAxN8O0L2rDpTPDqMKgwotUw7stUMK+fcOvwqoywpNPw6rChcKLw77Cilx1MDAwM0FYXHUwMDFjLcOyw4lNXHUwMDBmwpnDrcKyw4PCh8KNw4J4wobDi8KSwrTCnMO9XHUwMDA3TGl7Ni54w5nCplPCrk1zXHUwMDFlw4l2w4pcdTAwMTldw7DDt1x1MDAwNjpyw7wtwqM1wrFcdTAwMGbCqFx1MDAwZkR2w4TDm8K6asOtc8OXw5PDh1x1MDAwM1xcXFzDg1xcXFzCicOneD7CsDTCpGtcXGJdw6vDkFx1MDAxMTXClcOtworDhU89fVPDvcOWUyrDhsKIwoDCrkXDrj5UUGHCkG5TU1xcXCLCsFx1MDAxNlfCssKVID1AbmHCjcKAw5BcdTAwMTbCisKcXsKqwo4zwrjDhjZNwrrCssKJwoRcdTAwMGbDkMOtfE1JwpB9wq1+XHUwMDA2wp9TT8K5XFxmwpTDrF5jwrvDmcK9wrV/UUpFwoR6cTPDg8KNwrpHQ1xcXFw1w5fClWzDlsOAPU0ywpnDg8OBw4XDjDbDtcOqwqfDuz7DvMKzXHUwMDEyw4XDo1PCuUXClFx1MDAwZjDDoGpNwrBEP8KUK8OQXHUwMDFkwp/DnMK9w7x7Rn1cdTAwMGXCl8KUwq/CkcKZwpV4PU3CisOIM8Ojwq9wO1o3XHUwMDA1wpfCt8KXPUBcdTAwMDJvwobCjMO7PUo9SsKUwp3CksKLw4B0wqVAKlJsPUBeLz19XFxmw47CiFxcYsK8SMKtUMOawr3Dj0RcdTAwMWHCuz1AXHUwMDA3KcOwVGrCs1nDsj19fMKhXHUwMDEywrfDm8Kha1x1MDAwNsONw77CtVx1MDAwM0DCsFfDicO8MDxvwohOwrbCoXbCnSRYwpfCqD7CkjzCpcKLXHUwMDEwwrrCrXBcdTAwMTnDlMKEZMKgwrPCnMKCQ8K/wph3eMOMwpR0NHkxw7FcXHQ9fcOSMUDCplx1MDAwZcK9WV1OXHUwMDE3w4UnwrFcdTAwMDdcdTAwMWPDhsKiRF3DjVJnXcKeOSnCusOcXHUwMDBmw71cdTAwMTRcdTAwMWXDjl5xZih0PklKSk7CjFx1MDAxN2zCr1x1MDAwM1x1MDAwMcOowpHDiMOyLMKeQFx1MDAxNsO6w7DDtMKZw7stTm8pX8Opw53DnsOpesK9wo/CvsKgw4vDtD1NTD1KSsOUUMKBwp7CtDrDjTjCncKrw4fDl8KSw4precKsXHUwMDE3w4FcdTAwMDRcXFwiw5XCu1x1MDAxY1nDi8OmOsKodlTDs8OmXHUwMDA1IUh6ayHCvMKWPU3Dv8O3Z8KzSlFCw5teb8KwwobCq1t3XHUwMDFhwqlcdTAwMDQ9fTRTw7fDvEzCmzdcdTAwMTXCl8K5YMKMwqHDqcKswrF+w6ssw707Jl5DwqJhYFRZa1F5UMOPw6t4wrDCmmp/woXCtMKXw6hzw4RcXHbCkS05w7bCq2tePG3DkcOVUMK9w4/DiVx1MDAxMm/CvzDDmT19dMOuPUrCtSjDkWjDj8Ozw5LCk8K0wqnDncOow4XCucOzLcK8Z8Kzw7TDjGpSwp3Ds8Ozwro4wqLCmDhxw4rDq1xcZjBMXFxmw7LDusKqw7vCvF1qelxcXFxcdTAwMGbCq8KgI3bCrsOlXm/DkWFyKlx1MDAxZcKaKiNTXFxiw7rDmFxcYkohYzPDvmxtw7t1w6TCpMOzVMK7e09cdTAwMDF0NMOsZsOLf1x1MDAxYjzDnsKAXHUwMDEzT8KEwpDCqVx1MDAxYcKFXFxmwp3Dp1x1MDAxZMKlwpPCmcKTXHUwMDFlXFx0w6wgw6bCqDXDv2jDl1vCtGAxfHgld3vDqXDCnD19wqBrw5LCr1ZQwoNTPUoswppCwr7Dt1x1MDAxM8OvwqzClcKcf1x1MDAwM8OXdsKMwoPDoFXCusO0wpI9QHTDuzrDjMOAwrpcdTAwMDVVw4pcdTAwMDNKQ3rCgFx1MDAwZsKdw7Frw43CpnjDu8K3wpjDm1xcYljCpcO8csKvw7ZcXGbDjsKfw6lcXGZcXHbCvcOKODPDosKnwqjDnns6XFxiXHUwMDAywonDnlx1MDAwZk0xwqNXXFx2wqbCiHU6O291XHUwMDA2UinDi1xcZlrCgCbCscO6w4DDqj/Cv1xcdFZYLsOyQWHDhXZCXHUwMDExNcKkwpVyw7zColxcZkfCuzrDq8OYQTZ+U8OWw6/DuHpcXGY9fU9cdTAwMDJOwpvCkTPDgX40QVxcZjPCsmhiw5BWPMOzwpRBN0BCXHUwMDA0U8OOesOXwqp6w49cdTAwMDIswrLDhivCl8OUZz1Aw5PClVx1MDAxOcKCw4RcdTAwMTYyVMORPMKrwpIww53DmWBcdTAwMTfDlsOywrNcdTAwMTDDq8O1w6NcdTAwMDRcdTAwMTYvw4NSSMKLSj19wr9rfjjDi8Oqw6RaPX01wqjDqMOLw6Nkw6ZOXHUwMDA3d2xcXGY9QMOAclx1MDAxNMKhw699XHUwMDFhb8OewqvDqHzDmGbCpsKPw4E1KMOYKlx1MDAwMsOAT8KIeVx1MDAxNVXCjVlNw7fCpS5cXGbCn8OcTcK4JF1lw6ZzN8Ksw5ZcdTAwMDRaw51iScOwwpjDsWUyJsOSXHUwMDAyN8OOLMKEbMOaTkFlw6Nuw6dXSsKYwpnDnsOaSHTCtHVnXHUwMDA0w6vDk8OYwrTCtFlrV8OnJ1LCr8Omw7Esc3rCpC/DgMOew4LCvcOWPMOdXFxic2bCt3/Cq0xObcKKXHUwMDBmwpA1OMKQwqPDgXbCmMKKJ2TDjcKJw4jCgVx1MDAxMSZcdTAwMThcdTAwMWJcXGLDlcOsU1x1MDAxOcOKw6zCml5ZwoDDh2DDq8OhXFx2XFx2wo7Cim16w7lcdTAwMTDCpcOZYGcuwrzDg8KKXFxcIl9cdTAwMDZuw6pcdTAwMDZcdTAwMDJcdTAwMTZCNVvCuj19YMKORlx1MDAwN8OmS8KUKMOwwpfCtcOnWV7Cm3c1w6vDr8KaKcOmwpM0wr3DgU5cXGLCmcKow6vDssO7Xlx1MDAxYcKiwoRbw7fChcOzbkdpw5TDo8ORw6/DgMOKw4LDh8KZfcK/XHUwMDFjUVx1MDAxYsKrXHUwMDBlwoc8w7LCocKvOjZcdTAwMWJcdTAwMGXCsG7Ds8KLwqDDhy9Kwr3Cs8KyLMKRQivCm8OiwqZcdTAwMWFcdTAwMTXCkMKpw4pcdTAwMTVowp3CgMOmOMKxw7XCsVxcZsO0Wlx1MDAxZcOgwok9TcOTwrjDkMKKwo1GwpXCpkjCusKiYsOeXHUwMDE5w7vDqH5ELMOTwohUwrfCvTXDsVx1MDAxYcKgXFx2w5LDhMOZMWNtSsOmwrkrSmPChiheZsKLXHUwMDE0c1IwwrxmeMOfLlx1MDAxYcOoPX05w4HDkcOow6zDlm5cdTAwMTTDpkPDnD1Nw77ClXvDm0VDwqXDgS5TfcKWwpPDj8KSIcOow73ClDhJXHUwMDE5w47ChMK+w4hAw5MwUcKdeTTDvlxcYkgmwrXCscKXJsKqQCtcdTAwMTjCucOawoF4XHUwMDAxw7hcdTAwMTNww4ZuXHUwMDFmesK2QMOuVVx1MDAxNl3DnsOlwrtcXGbDkHhpesK2XHUwMDE5RcOkXHUwMDA3XHUwMDAywp8sIMOxw5/CocOoQsO1WDHCsXlcXGbCgG9cdTAwMTBcdTAwMDbDo8O3LcKUwrxxw7dcdTAwMGZNT1rCjjbCuj/Cmi3DlsOlw6DCsiViwq3CvUs7w6xtwrrCqsK4wog0Y8OXwrDDqMOewp0ywoY5XHUwMDEyNzTDklx1MDAxZcKuw4PDv8O3Y8Oab25cdTAwMWTDoMOiw6nDhFx1MDAwMz1AI8KvcytTXFxcIsOHwrZcdTAwMTPDomHDqMOZXHUwMDFiw5jCo8K3w5rDoMKCw58vJ8OYwqxcdTAwMGXCvXbCjyXDqMKnw4bDocO9w4vDncO9JsO0wonCjVxcdFnCp8Opwp/DqcOWwqTCvEjCmcKtNcKGK8OoXFxcXMK0Y3JjwqjDijLDkWTCvkPCt1xcXFxXfCtcdTAwMTkow4zDoHdTw4jDoUnCrVx1MDAwNXHDnThmMsKjJcKgw6jDiWFcdTAwMTPCtMKyRTrCjFx1MDAxZDM7TkrCgFx1MDAxOMKWXHUwMDE3w7LDmjjCk8Kaw6DDisKIw6rDmsOqR8K+e8O0bsKuMcKmXHUwMDFkKsKVacOQw7gxwrTDuzHCpn3CtMKlXHUwMDEyTHbDvjfDqcKuw65OMlHCrFx1MDAxZMKxw4IhSiUjwofCl0bCjVx1MDAxOMKvb8OfIEc0w6fDgMOXfTvCgjTChcKuZMK3RcKAwqTChMOvwr3Ck8OlXHUwMDEzXFxcIsOcaW1fVcKWXHUwMDEyw7dcdTAwMTLCtsOewrPCg1x1MDAxNVBlaC/ClcKDwo5Swo/CrFvCo8KHXHUwMDFlXHUwMDA1XHUwMDFjNyNcdTAwMWHDmMOLUyZwwrfDtsKXbcKyw4xNXHUwMDFlPUAqXHUwMDE4wrRcdTAwMTjColx1MDAwM3rCgMOoNMOvYMOCXHUwMDFiwoB/SsKmwoXDhsKzU8KGwpFcdTAwMGVRXFx2w5zCr0TDs1lILcO4WsOqwpFqNsOeb8Olw5fDol3DiylcXHTCncOyw4Z+w4TDicOtw6LDm1x1MDAxNMOre8OSwoPClsO+XHUwMDEww65FR0N8XHUwMDFjwot7YsOTVTZEXFxiwqTDp8K4cn/CpMOnw7fDs2dkdcOqXHUwMDE5JTxcXFwiZcKpwqhMw7vDgcKdw73Dulx1MDAxOFx1MDAwZsOxwovDmcKaXHUwMDA3w4RcXGZ+w4VQw5l/XHUwMDA0XHUwMDAzwql2w65Aw5tcdTAwMDXDvi7DhSDDoEzCqXPCi8KoZsO1w7wtasKuwqjCrT1AXHUwMDBmLUI1w443wok8PX3Di8K/KjZcdTAwMWbCscOiw7lcXHbDv8O3McOVLTDDlVx1MDAxZS3CpMKrw6gkXFx2T1x1MDAwMzjCosOUV0rClzPCu8KcPUA3XHUwMDA0SsOHwrNPMcOfwpZdT37Cnlx1MDAwMsK8wqNbRMOnw4lcXHRcdTAwMDLChMKhw4zCnUYxwo/CqVx1MDAxYcKOPGBGw49Dwo4swrDCnsKGwoJBXS9CPsKmKMOOPsKIwqFyT8OOw589SsKlw7JcXGIww5zCtsO3wpZTPUrDunrCi1NcdTAwMTB1RsKzwrNzSjs5XHUwMDE2wr9jRkrDnmHDtCQ4wrPDsygsw67Dq1x1MDAwMnbDhTHCu8KyfVvDvVxcdj9Lw6LCknxmMcOZwrbDknHCj8KNwr7DgMKHw4lqwpY4wrZMXHUwMDE2wrzCo8Ohw6JcdTAwMTLDuy9cdTAwMTc5wqo9QMORIMO1w4BCw4fDq8OGXsKGJVMjw7HDtMO/b15qTMOfU8OQLMOmRsOIw4VMO8O/w4ozwrPDgMKnaMKCZsO2w5/CrMO1w7nDuD1AJcK0d3zCjsOuwqjDisKNwo9FfTDDlFFgTCPDkMKWLcOTw5Ffw7zCkVx1MDAxZMOwXHUwMDEzwozCvcOYXHUwMDA3YCnDgsOWwrLDkMOOwoPCjD1Kw6jDuUnCv8OMXHUwMDE5XFxmwr3CrGEzXHUwMDAzbTVEwro9QHXDkSY/XcOmwqXDncOaUsO1w49cXHTDmk5bw7F4eU0kKcOdIcOJwot7LsO1SVpkbVxcYsKHwpzDuGNNwqzDik5cdTAwMDPCk8K8Lj8/a3pqwrM8TjLCvE9WUsKsw4LCnWxbMX7DtsKDw4NAwp0wPX3CkMOvw4Y/w51Kw7LDl8OIwofDuWMpJVxcYjkhXHUwMDE1wqfDiMO1woRcdTAwMThcdTAwMTbCrsOIXHUwMDE4w5Qkwp/CgcKBwqHCn8KdV8OeS8KxT1xcXFwua8KAX0tFM8K6QjE5w5JwwotcdTAwMDNrXHUwMDEyXFx2bMOvXHUwMDFjw6nClXHCnMKzwo7CvFdmasK+w6knw7PCrDDDusKOwr03O8Oiwp94w6PCpsK6w7J/w7LDhlRcdTAwMTPDo8OrwoPCjMKXKsKRVcKLwpEvWCTCs8K2w7HDrC1Gw5lzwonCq1bChMODwpbDtEkyw581XHUwMDFhwrDCmjFAw57CrVx1MDAxOHXDsHjDksOQPUrCumV/wpbDlHcgw6LCu1x1MDAxNiZcdTAwMWHCqcKJasK2U8OYwp15fCVcdTAwMTlFwpJYwodaw6bDilx1MDAxY1xcXCLDiVx1MDAwNyFPw6hlWyXCslx1MDAxNcKCJsO3wrdUc8KIb1x1MDAxY2xcXGIgw4lcdTAwMDZ6wrzDlsOqwp1aXHUwMDAyMj/DqU5ewq7DonDDssK4bMKOdsKww5JRwp7Du8KKOTDCmMOUQsOhXHUwMDFjwrM+w6HDtTpcdTAwMDI1wo57UlfCm8OGwo5mM37Dj2N4wr0rLsKRc8OdckBcdTAwMThcdTAwMGZgSjxcdTAwMTliw45ZYMKfVHZcdTAwMWbDocOEw6zCm0JcdTAwMDMxwoBcdTAwMTRpw53CtHNkLlbDvMKMw6FSZlFcdTAwMDNHcmrCoFx1MDAwMiTCoWzDplx1MDAwNTrCg2nDgG06w4NhdsKqOMKcSlxcdMOaXHUwMDE5wrfCvsOJwrJSPCHCv03CgD/Cm0g3w6/ChXPCmk3Dn8KOXHUwMDA1OVx1MDAxY2TCm8Ohf8OsS1x1MDAwM8KrfMOFPjLCtcOiwoRDYMOVSsKFPX3CtcOFXFx2KVx1MDAxMMKwXcKkKX14wphFWcKbTMKGPUo2w7FbwofDvCPDjCjCpcK9w5NGwp7Dl2LDl19cdTAwMGXCgMKsQXHDgDzCncKBw6bCtcOULFx1MDAxM1xcYsK6wqvCli9cdTAwMThDw49zw7rDvsODXHUwMDE0ccK7w4fClMOiXHUwMDFmwr7Dsl9cXFxcwrJ2XHUwMDA0Y8Kbw5zCvMKFw7DDglXDqsKsccKOwrN+w4LCocKMw7hRXHUwMDE1w7jCvMKHw57Ds1x1MDAxNMOSXHUwMDA2wpo1XHUwMDExw4g9SmDDksK6Zk/DuMK2bsObw6/DqsKdLcOBQ8K2NcOTPDDCrFx1MDAwZjVcXHZOwrzCtsOFwr3Dp8OEdlx1MDAxZsOtc8OpMETCkMOMw7A8w4DDhMKUwp02KMOhw6k6Q1x1MDAxOTFbwpxcXGY9QMKuM0DCumJcdTAwMDFRL8OAw5NkdMKIw69vZ8K0eSMmXHUwMDExwr7Djlx1MDAxNMOlVcKXOCc6wozDkTxvXFxmwpRNwrIrXFxmYMK+TsOfPnvCl2rDhcOUWcKRY8OFPsKqwo91wqDDmy9nK8O5Plx1MDAxMcKewqpIwqpGXHUwMDEzcMKcIcKywqHClcKsTMKzXFx0MFU9TcKdRcOgwrLCgStRSDXDjMK9w5rCn0rCrMOUwr3CliFOw7t8w7NDXHUwMDFiMH1UXHUwMDA2UjFcdTAwMDPDkMKBw4x3Lj/DrlxcdsOrXHUwMDEzw5RiwoVOw6rCtEXCiS/DhnRUdmVcdTAwMTM4wpPCnUdYfjtmwr/DvEp6w5JlcsOfMibCrMO/XFxcIk/ChMOYN8K0eVx1MDAxMFx1MDAwMT19wrnDo1PCoWHCm8K6dcKiOCDCuMOXw6NYw5vCisKew7fCisKGw7zDgi3Do1bCtinDq1x1MDAwNFx1MDAxZWRcXGbCt8OkwrLCly9dw4lrQ8KKRVXCp8KMS1x1MDAwM8OswqbCqFx1MDAwMlx1MDAxY3TDvzbCnkUoXHUwMDEzwpxfV8OGw7pfXHUwMDAxPU1cdTAwMTZcXFxcfU/DnMO+Q1ZcdTAwMWTCjXY9QCRbMMOJwoTDj8KbcD19w77DqFx1MDAwZcK8w5NcXGLCgMKMwrHCsn9Lw4PCkmjCozlzKlTCksKjf8OCXHUwMDEzw63CvzxcdTAwMWXCt8KFw49cdTAwMTDCqVxcXFzClTFcdTAwMWTDonMoT1x1MDAwNVDCu8KGwrzCh8OqXFx2XHUwMDE3XHUwMDFhwq3DpsKHXHUwMDAxfsOoM8OkW05Pw5rDmsOjYDXDgMOJSmdzwphcdTAwMTVWwodcdTAwMTJcdTAwMGXCmlx1MDAwZsKresKYw7zDhzp5NlxcYsKTcCbCiynCucOdWsOLeyHCqcK2w6lcXFxcwqw4fMKtXHUwMDE5TmHDrcOfwpwrwotFXHUwMDAzWcKtPX0ww5p1QVbCh1xcZi5cdTAwMDPCk8OUdVbClcO8TMKrw7DCnVYpeU1RXHUwMDAzwph1woZaw7x4XHUwMDEzwrtMXHUwMDE1wr1cdTAwMTZVMsO2XHUwMDFmw6Jnw6JOXHUwMDBmwqwgNcOAw7bCusOCeMKremfCvUzDhFx1MDAxM8K0R07CvMOkw7HDgXY2e1pcXFwiw6F7XHUwMDFiKcK7PsKDwoDChzzDu8OUdMKWKlxcZk/Cr8OTwpgmKVxcYlx1MDAxYcK5w7tcdTAwMDbDkMKJXFxmw7rCgWlcdTAwMDLCgHJFXHUwMDFhw5cnKcOwOWjDs8OOw442XHUwMDA2TcKGeMOLUErClVx1MDAxNCbDtcOOYsKwecOMQcKGwpVvwpRxfScpwozDglxcXCJcdTAwMWbDq3TCrygtMsK6w7VcXFxcwp49SsKLa8KCw7g9fVx1MDAxMVV3wpRXK1x1MDAxZSpjwq3CiMOma0LCln9ywoBpTFx1MDAxOGhcdTAwMThIW1x1MDAwMk5fU8OxNMKfw7hcdTAwMDRcdTAwMTBUesO4wrrCscODbsKMXFxcIsK7TcOSw5BcXHbCqcObT03CmMOdw7LCmcOawoU9SsKpbVx1MDAxY0lbwq09Slx1MDAxNSnDgmvCisOkwpvCiMKDXFxmQMKrXHUwMDFmw6jDosK6VsO8wpnCrsOIMcKDw64rwpTCnXw1w63DnCfCjkFsw7xcdTAwMGUrKcOiXHUwMDFkTsOswrjDhVx1MDAxYyrCj007eFx1MDAwNsKWwo9MVlx1MDAxMzbCicOjwqbCjFx1MDAxZsK1wpFHRMK7U1dcdTAwMDZAw7BcdTAwMWHDrXpcdTAwMDZKw7LCkcOEw5PCu8KMdHjCrMO8w6wsdMKOw5NAwphMw4PColRpw4PCoW7DkFVcdTAwMWPCpjnDvnXDjMOzworDg09twpJRIcKywqnCvcODw5vChn7DsynDuFDCrCfDu3NmRHZVWsK+wpbCtGbCryZaTGnDosKTwqApQMO2QMOhU1xcZltjXHUwMDFiw5ZRwqI6XHUwMDA2dFx1MDAwNlx1MDAxN1x1MDAwNsK6wr1iTcKGXFxcXMKGNlTCoW5EXHUwMDFlKVx1MDAwM1x1MDAwNERgw5lPXHUwMDE3Nn7DlGfCisOtwrrDpHxcXFxcw4g3wpM9fcKpXsOhwrBmYcOLwrRcdTAwMTZHTMKoM8O2XHUwMDE4JEHCksOvw7d9wqvCkz5cdTAwMGXDj8K8wopPXHUwMDFiTDzDikYkwobDkD1Kwptzw4JRwoMhwqrDtT1NwqlJUcOIQ1xcZjQlXHUwMDE5PU1OXHUwMDExKcK5UcKKUMO7KcKjwqzDhcOLXHUwMDFiw6l5Nlx1MDAwZsOwcGppw69IbMKrPUrDncOIwr7Do3LDhcKWXHUwMDA2LD1AYEFaXHUwMDFmw4lYMMO2w7NMwqfDmMKpwrvDgcKGKcKsw5YjSsOjdiZ3KcOkUFx1MDAwNsOOwoHDgsODayTDtVx1MDAwNsKETinCpEVcdTAwMDY0w7VcdTAwMGUywrxdMcOZXFxcXMOOK2d/X1xcZjNOPX1LworDpMOAXHUwMDE5w7PCncKOXHUwMDAxR0LDuCNcdTAwMTnDpi5TXHUwMDE4Tlx1MDAxNlx1MDAwMcOqY8OwYzE6w6LDr8OuwoXCpsOFVMKcw6VcdTAwMGbCvFx1MDAxMMOuwq0mwqxfIMO2w5fDslQ3XHUwMDA2W8Ohw7TDiMO/woDDvMOVw5I+c8OIwqrCk8KuXHUwMDEww4bDpsKywr7DrsKVwo7Cmj1NwplcXGbChz/Ds1x1MDAxOMKAXHUwMDA2w4JIwp7CsWLDucOOwrZcdTAwMTQ6OsOfwqLCnMO+w6nCh8ONw65HwoY8XFxcXFPCoMOhwrsrNcKzw7UvwoDDgkvDlzvCvjdmw4/DrsK6McK5L3LDgHzCvTHCrSs2WMO8wocrw6FBXHUwMDEzVD19cVFDwrNOw6nDisKHf33CscOBX8K3QMOZXFxmw7hcdTAwMWbCk8OrwolxMMKFw6s1L8OFbcK7cnzCk8KYfcOYSjzCksOuwpc9fTLCsMONwqLDpVnDoix1w5/CtC3CpMOyNmg8XHUwMDFkL1ctXHUwMDAyM8KMw5FGYcOaOcOfUlPDj1xcXCJ7wptcdTAwMTZpw6Iww4ZLSC7ChsKOXFxmwqdOw5dyT8O4wo9cdTAwMTlYQlfDuFx1MDAwNj1Aw4/CnMKKwoQ6w6rDgnx9csK5JGkww4lcdTAwMDJ1Llx1MDAxM8K7wp0pXHUwMDE2wrUpwpHDuMOywrZ6w5rDnMOvwoNLw7VcdTAwMWXDrcKQcynChsKvwobCuMKMKV3CsW3CpsOtw6lcdTAwMDdcdTAwMDTDjsOKPU1Vw49UOcK9w4DCq8KNw47DuW3CkMOVwrpbXcKYI3bCmMK4PkHCsy/Dh1x1MDAwZcKpwqUgwpPCnMOqTcKAUlLDuSzCmko1csOUw4bCg8OLMcOfw6TDo0BcdTAwMTPCtMK6Z2XDr1x1MDAxOCxyw4JdWy/DqF3Di0lwwqB6T8KoZMOccDZhXHUwMDFiw7TDoTzDuETDrMKDw4JUwo3CmG5AwpkuwrjCq1x1MDAwNTvDnlx1MDAwMkLDuMKIwqrDnVApw7jCrFdRXHUwMDBmPU1YXHUwMDA3c8KQXHUwMDA2bcO/b0zCpGt+XHUwMDEwRG7CnsOOXHUwMDFkwpdRw4fCjVx1MDAxMHDDqMOGw7dcdTAwMDbDo8KvXHUwMDE3clHDusO2fjVQUG3DocK3w5LDjmNcdTAwMWXDssOuw6XDhsKzYcKGXFx2wqzDisOvNFNIwo7CsMKzwqzDlGvCjlx1MDAxMnzDnMOGLcK+dT/CnnVmw7A2XHUwMDE0T1x1MDAxM1xcZsKtKMKswpzCq1xcXFzDg1x1MDAwNcOiwq3CucK0YMKvWTlSw5s3XHUwMDAyVsKMQsKaLcKAPUpUXFxmwrxaXjF9dMOrXHUwMDA2w6vDvsKwYsKmw4rDr8KbUMK7w446YXfDgD1NSkvDh8KOw6hTQ1svUTF2NT1KJsKeXHUwMDFjw5BgXHUwMDEwwqDCkMOaOlZ+fsOgwoozwr7DhcKFOzlHe0BiwqrCosKHwp3ChVx1MDAxYcO5wps3P8KSw4DDg8K/wqIlVlxcZlvDnU1Qwq3Dl8ODTWHCtcKBw7TDvjhkWT1Awqg/wo7DpX5cdTAwMTXDl8K6WWNMe8KVw5tLwpHCj8KQV8OgwrVOw4XDg8K8eMOKUCbDnlx1MDAxMMOAw5hawp/CvsKCwqLCulQuw5HCgsOBXS5sXHUwMDA2w6c9SsOuPX1cdTAwMTnDsVNxXHUwMDEwwr1qTTEwL1x1MDAwM8ORwr1lfE/CpMO4R2tcdTAwMDU4w6jChMO4LD1NwqB4L8K2wr1HwqHDoiPDrsOuw7NRLUPDi8O1w7ZGd8OXK0rCoMOQJ8OqwrF2RmPCisOgwoXCtcKHwqY9Slx1MDAwMz19a1JFNsOvwrTDo3PDpMOFw6DCjFx1MDAwMcOIP8Ouw5IqwqvClcO5eMOmLzRcXHZFw6Igw67CicO6w6rDtMK1PX07ZcOZw6JPwrvDrmBXwo55wpzCjnXDnMOxR8ODPMOdwr9lwqzCjMKqQHLCsyFcdTAwMDTDgFx1MDAwMivDhncyNkNSw480XHUwMDE5L3vCtU/ClcKPXHUwMDE0asO2ejHCsl7DjMOLwpTCqjJQwphcdTAwMWPCvlDCpsKDeFxcXFzDvVx1MDAxYsONw7ZGw699Z8Oyw45xXFxcXMKBa8Omw6/Dlktyw4fDscODclxcZsKvOXLCiUluw4xzw6bCozrDkVHDiMKINcOXYsODenXDulx1MDAxZMKZd2lcXFxcw7jDuHdXUMOtwpnDujTCq8KzK8OtUMOuJjtcdTAwMTnDp8KTw7I/flx1MDAxNsKnPU3DhHNcdTAwMWLDkMOjw67DvMKsw6vCiULCrcO7wq7DtDXDgEx+X1xcZsOwLijDscO6TFx1MDAwNcKlwpxcdTAwMTVcdTAwMWPCmsOhwrxGbcKpaivCjMOOPUo1LMOSai4nY8K9wrPDgsKFw4Z1LMOEcypKXHUwMDBmwqVrVMKtXHUwMDE2wobDtlx1MDAxMzxcdTAwMWJcdTAwMDfCvH9uXFx0w6pywrXDgsKHwo5fSsOMQsKKfmrCmcOQclxcZkVKSMKJXHUwMDAywrjCuW1Mw6FHw5xLXlx1MDAxZcOuZ23DlEjDmsOTw67CmMKbd1x1MDAxYkFCw4I8WcOIRmvCusK/w5NGwrsrWsKGwrhcdTAwMGXCvGLCj0vDgVx1MDAxYU/Ds8OPwqJJQsOcwqcuW1x1MDAxZHPDoVx1MDAwMcODwoVcdTAwMDF/w6ZcdTAwMDVOTsOLNSHCujtAVV1xw4zCg2B8P8KoTFxcZsKZXFxmw4ZZKcOITFxcYlx1MDAwNMKow7p2wqpcdTAwMTDDq3/ChXrCpsO9wqjDmlxcdldcdTAwMWUka3HDl8O1w6t1WX04w4vChyfDqsK4XHUwMDAxwrFCw5PCqG5Ba8O/akkwwq5Fwr4zasK/KcOPwo7CmGvDgMKCw7/Cr14yUmtEwqDDkMOgXHUwMDBmw5rCmcK/w5PCl0NcdTAwMDbCl29cdTAwMDYyXHUwMDFhVsOGwqxOw63Do8KfScKWXFx2w6ZGw4YmwrHCl1xcXFxacVx1MDAxMG4mPX04PnfDgVx1MDAxYUZqwpdNMMOfNytfwprDn2nCjjnDgMK0XHUwMDEyWcKALMOSwrROMsOhTW9Rc8KawqVcdTAwMDMrwprDt8OWw69cdTAwMTXDg3RmLMOGcMKyMU46e1tDfMODwrvDs1x1MDAxMsOKXHUwMDEyw4rDoMOOYMKvOmR8T8K6csKBw5rDrl9cXHbDtcO4w77CsMOVN05cdTAwMDVmw61Fw5ZLanbDgWJcdTAwMDZcdTAwMGUsw7dTw7Iww4rDvTsmesKqwpdYM8KFw5h8PU3ChCzDssK8w5PCt8ODLcO7woByXHUwMDEySWHCl8Oxw7J+w4I4SsKCw4HDtsOHwplcXFxcXHUwMDFkPUrCmit9w43DosKswq1YXHUwMDE0w4TDpSRcdTAwMWbDt1x1MDAxNsK/XHUwMDFlw41MTzXDh8ODw6Qkw6vCinrDg8ODw5HCosKBPkLDpEvClFxcdm/CkDfCmjPCusK3XHUwMDE0YmV7w4Y4w4nDjsKNwplcdTAwMTRzw4o1wphrd31cdTAwMDJ7LMK4wrLCpDdeXHUwMDFmVGFcdTAwMTUxwrvCjCDDkMOYXHUwMDBmXHUwMDEweEzCnUHCm2nClkrCssOyw75vwo5cdTAwMDTCucK2b8OCIF3DnUzCiDfCqsOhw53Dkz19XHUwMDA2XHUwMDE0wo5cdTAwMTR8e8KYwpg5wo0tXHUwMDFhXFxcXMKlaURON1x1MDAwMcOWcnvDh2o9QMKQwq1qXHUwMDE4IMOQwq3DsF/Dg2Qlw7tfw79cdTAwMWE+XHUwMDA2fi0kbEhIPsKYejhbwrNcXGZcdTAwMTLCpMKJw67Dq8O7wrRmwo95w6jDkMOFY8K7w47Dslx1MDAxNUo7wqLCpiRSPUo8w6NYw7UnwpnClHlcdTAwMWXDssKTZMORwp7CmsOjQDwpXFx0w47DilxcXFxcdTAwMWZaw59UwrEsXHUwMDFlTcODTsK0wpR1w7TCl3fDnsO5w77CpMK2K8O+KS7ChcKMwqE1W8KwKMKhwq9xw4wnPUBuw5HCjyduXHUwMDBlL27CtcOjNUB6wosoWVx1MDAxMsOvwph0w4I8bMOaXHUwMDE5KsKcMcKHNl3DgVvCqjpweE8kKcOJRCrDhFV6OMOCwrTCjE09QHXDuixFfTHCmjnCmjRrw4VkJsORwodNwr3DryjDjzdsLsKdccK4XcKhwr7Dq8KBw40tXHUwMDEww4zDrm1cdTAwMWRcXHTDqDHCk8O5XHUwMDBmdkfCslxcZizDgmpcdTAwMTlifcK1XHUwMDA1e8OGRT9NNz19YTnCrcOeXHUwMDAzw7rCiSZcdTAwMTHDukvDocOtMFx1MDAwZsKGwp1PwoDCgVx1MDAxYsOcw7xcXGbDk8KTwo5DwpXDuMKgw7zCqsOnwoTDt8KLw43CgDLCqsK/XHUwMDAyWcO6wo9MwpdFRsODw4JEdcK4w6rCucKTMXDCtGXCksKtMFZCUlt4dlx1MDAxZsOiaFbCl1x1MDAxNHhWMF1cdTAwMTJAwq3Ch8OMOVgxXHUwMDEyXFxmc1YuwoXCjE/DhMOkwrtoWMKRTzzCuVxcXFxew6BcdTAwMDZoXHUwMDAyKTTDtFx1MDAwM0jDjsK/w5ExdC/DgcK7KcKxw4HCtWHCuE1cdTAwMTAzQ1HDmD7Cq8OBwrNcdTAwMDLChTXDjinDvcKuwptcdTAwMDdbXFxmSz1NUFk6eT19w6LCucKKw5lxw5t7OG0xwoowwrzCo8KcXHUwMDA2wpPCs1x1MDAxYnEwPUDDo1x1MDAwN8KUY1xcdFRDST1NcMKEw7/CisK+QFx1MDAxOFxcdlBaa1FtZsKdcMO8XFx2PUpAwpJcdTAwMGXCoFTCsMKwwrduZcKcwobCrUfDhGnDtsK9w5zDi8Kmw5U+LntUNFx1MDAxY1xcXFw6I1nDj8Ouw4HCvz1NU8O9Pnl4woRwwoDCq8OAwrxpfMObw5TCjn9zdMO0wrs0XHUwMDAxZsK0wrzCrcOIw5U2OsKWXHUwMDEwM1x1MDAwNcKjdMKyJcONJVx1MDAxMmjDk8OpfMKpw4/CpVxcdkZGw6w5XHUwMDEzw6nDmsKRKH0vw6tjwoTCtMO+NT43QU45JiHCqVx1MDAxYnvDiT7ChsKrbcKcw4ViX1x1MDAxY8OZwrnCsC4pdFx1MDAxZnRzISByIcOyw7ImwrtcdTAwMTcoTVx1MDAwMU9Rw5VcdTAwMWFcdTAwMTXDqVlcdTAwMTjCrS1cdTAwMTjCmFx1MDAxY8KowrwvwqJuNEhcXFwiwqEtIXDDskbDtnNPw6NMQ8K9XHUwMDE0wr0oJUFcdTAwMWNwWMKyw51cdTAwMDRRL8KjJyXCgXDDkMKBw6DDoXHDmHF4IMK5bCHDiVhIVmsrU1x1MDAxYcKOXHUwMDBlwo9SwpNvwqM6PU1Iw6jCisK7w5QnXHUwMDE4XHUwMDA1QcKFJcKmUl9Uw5NZwqvCgCfDpcK7w5zCm8KSwrjDplx1MDAwMVFxw696wrvCp8OxUkfDlMOcXHUwMDExw45cdTAwMThcdTAwMDfDusK5wqc5JXzDksOXwqfCmSTCrFx1MDAxM8K6SC/DqD9Nw7h7XHUwMDE3wqNcXHZvScOUwrzDlFx1MDAxM8Odw45cdTAwMDbCksOUYcKCw7TDv8Kcw7I6b2LDjXh3XHUwMDEzXcOPwpEhw5dcdTAwMTdbeldcdTAwMWZcXFwiw7FcdTAwMDNeU8OPNWklwpbCij1Aw7PCt8Oow4fCp8Ovw747XHUwMDE0XHUwMDE2XFx0XHUwMDExw6dcXFxcw5xcXFxcwoTDunfCrsOpwoHDtsOjXVxcdMKqwpnDhMK+aE91Z1x1MDAxN8OlXHUwMDA3XHUwMDAxw71cdTAwMTF1b31cdTAwMWPCumnCr8OowoXCp8KLfHjCnC0jXHUwMDExPynDjyFMdCDDll5cdTAwMWbDn1x1MDAxOW1cXHTDgWhTdMK5w5wsXHUwMDE0XHUwMDE2ZVx1MDAwNMOhw57CmcKZw4k1wo9zecOAwpTDgcKAwrpnTCVcdTAwMTkoT0PDk8KRw77Dqj19w40qXHUwMDA2JFx1MDAwMyHDmFx1MDAxOcKDwokxJlk3w53Dl8K9w5PCl8O+YXRyw4HDvXdcdTAwMWUjKcKSbF3Dn8OXYcKHVMOfw5LCqnRcdTAwMTLDpVx1MDAxYnFLwqlKXHUwMDFmwrJcdTAwMDQgXWnDpcOReXdcdTAwMTRcdTAwMDdcdTAwMDHDgVPCl8KnacOPXHUwMDEwwp7CmEjDqcORw5l4w6Q9SsOdwoZcXFwiw4TDqFXDvMO9aMORLldcdTAwMTdlWWfDpcO9wpBcdTAwMWHDtMOodFx1MDAxM8Kuw5nDpSTCmVx1MDAxOMK9wr/CmCdow6smwpLCicK8w74kwolVw57CmVx1MDAxZV/DvFx1MDAxNcOlOTJSw73DqVBpd1xcYsODXHUwMDA2X2PCj8Ocw7fCjsOQc8OMwrPDgTNcXHRcdTAwMGXDmFx1MDAxYmQ9TW7CjcKdPU3CsXA1wrYmwrZoQ1hdXHUwMDFlXFxcXMOmwpVaw6/CqsKZw5rChFxcdMKIKcKqw4jDgVxcYjPCh8KZXHUwMDA3bWQnwp89QMKTw5XClMKBwpLDp8O7RsOLw6NxbX9NwoUnwqzDhMObwoTDqFx1MDAxNGM/wpfCv8KOXHUwMDBmwod0w6k/wqc+w5UvQVxcXCLCpih6XFxiVsKvwp1cdTAwMWN8XHUwMDFjwrbChsObXHUwMDE2aMODwqHDvFx1MDAxMMO8w7t8wrVcdTAwMTJ1emzDocOoXHUwMDE2w6nChcKkSSHCkiHCtlxcXCJdw50lflx1MDAwMVxcdFxcdMKIw6k1wqlHJCNcdTAwMWTCscOxwrnDnFx1MDAxOVHDqVPCpkUnwp9cdTAwMWbDgcKhw4fCiMOHwp1oaSVcdTAwMGVcdTAwMWLCk8O7w7HDuDnDjWhcdTAwMTbCpcOZJcKoXHUwMDA0w6XDuMOhXHUwMDFiwpnCmcOmQyRcdTAwMTDDtlx1MDAxNcKqXHUwMDAxXHUwMDExwog3wqnDvyhcXFxcI1x1MDAwZsO5QVx1MDAxZMKIXHUwMDAyw6hiIcKmw7zCnVx1MDAxZlx1MDAxMVx1MDAxNsOdw4bCkcOAw7lIacKXwqJEKcO+IFx1MDAxM8O5wrjCnUc3R8OvR8KNZcOCOFx1MDAwNThcdTAwMTc4wqjCsX4xw7/Dm2nCszRcdTAwMWPCmlo9QHxOwprDjsO4wpnCiHrDgD9JO07CnsOfYcO/e3vDisOoZsOnwqMoXFxcIlx1MDAxOHdVXHUwMDExf8OBeHPCuUllVFx1MDAwMsOxw73Dj8OJw5/Dg8K7w5jDkMOUTHnCgMK0ZFJ5e1HCq1x1MDAwNMKqw7LDicK2w4bDmGYyRX7Ch8O7w7p4w5NcdTAwMTHDgcK0w6fDiFxcXFwnw4HDmyVcdTAwMWbDvTTCgHBcdTAwMTjDgFx1MDAxYsK9KcOXw5TCllx1MDAwN8KVIHnDqHRcdTAwMDRgZMK0wqfDgGgwXHUwMDA3wofCpsKhMV/CslbDjsKTw6NJbTEnJFx1MDAxOGgmw6Vsw5lcdTAwMWXCosKtSMKnw4XDq8O8w6nDj8OSeitcdTAwMTnDocKgw6nCmMKjwoXDiMOoXsOZdcKdwozDgcK2XHUwMDFlwpnCpcKnXHUwMDE0wrXCg8Kqwr7DuMKJISjCqX/DjiXDnn5cdTAwMTfDpDfCrmDDnGlcdTAwMTbDscO0w7rCqcOnwqdcdTAwMGbCpCQowq7CosO6w6leUEInw4w+wr1cdTAwMGXCjj5ow5BcdTAwMWUpMFx1MDAxZsK8w54+XHUwMDE5wqduXHUwMDFhw5FJJ8O9XFxiU8OSwoVlXHUwMDE1esOHwqtcXHZcdTAwMTkvw5xpNMOewqnCoVx1MDAxNT7CpsOBw4AoR8KRUlx1MDAxZH1Pw74ldcOJdkNiworDl03CnsKJdVNcdTAwMDNVw4PCklx1MDAxZsKiXHUwMDFlXHUwMDE5XHUwMDE1w51CI3fDjcO1wqFcdTAwMTbDmcOZw4RcXFxcwostw4jClXzDrcOOacO1KFx1MDAxNEElw4VcdTAwMTjDv0jCjMO8R8KRIcKHPUDDsMKJw5/CscOQw6TCtVx1MDAwN0nCqFx1MDAxNWF/XHUwMDEwd8OCw5ZqwoTCiMK0XFxmXHUwMDFiw7HCrFxcZn3DuGrCv2pcdTAwMGV5w7vDrGVmw53CpMO3wqvClVl+dlx1MDAwN21Rw4BZXFx0wqdcdTAwMWLDk8Kww6dcXHTDolPCn0XCuMKGwqnDj8OSXHUwMDExPMOGesOmwqJcdTAwMTHCr1EkJ8KwbnnDk8KHwqU9Slx1MDAxNH1PXHUwMDE3a8ONUHfChcKnPUpcdTAwMTQ1P8Onwqhow7vCo1x1MDAxZMOgw4fCo8OWw4vDtcK2eFjCiMOiwrfCl1x1MDAwMWDCm0PDg8KEw6bCpiVcdTAwMGZcdTAwMTHChHDCuMOowr3DtMOAXHUwMDE3YsO9wotmworCgmzDs8Omw7fDscOYw6nDvsO6RUJiaMKpKMOAwr05XHUwMDFlw7fDg8KLM8KvNcOhw4jDpMORwpFcdTAwMTA7QsK9ZcKpXHUwMDFkw4NRwoRcdTAwMTDDmMOrMy81wqHDhsKjw5bCk1x1MDAwZVxcZknCh8OawopcdTAwMDVcdTAwMDNxXHUwMDA0UMO4wqjCmy/CtT1KR8OkwpDDmMOLI183MVjCnsKSQzBwd1TChcOkJ8O+Z8Knw51raFxcdi9Vw4TDmGZfWiHCt8O1w5bDlFxcdMKfPU3Dk8OQwqjCmnxcdTAwMThcdTAwMWV/wqVYZlrCoTrCuEJpw4/CqFx1MDAxOcO/w4FkcMKYM8KPw51gXHUwMDE4w6kow7xcdTAwMDJcdTAwMDTCjcKGwot/w63DqDXDmcOfwrYww4pbwr1cdTAwMTHCl8KWwqPClj1KRsOEZMONwospw4NlwpnCtsOGwrBQwr9XXFx0wp1cdTAwMThcXHZxXcKlXFx2XHUwMDFhXHUwMDFiT1x1MDAxZsOlwoTDiUQ3wrTDtMODw6PClCXCs8OgXHUwMDExw6TDsC1Nw5BZXHUwMDA1wpxcdTAwMTZcdTAwMWN1VcKRw4nCssOew6zDv8KlWcOoND19XHUwMDFhwqNcdTAwMGVcdTAwMWTCg1xcdsOdLMOJXHUwMDAxw43Dii1xw6ssd8KoXjnDq1x1MDAwM8KRNFxcZsO5TMKvw61mdVxcXCLCslx1MDAxOU9xwrJcdTAwMTHDrMKFw4rCosK3WWgldsOLc8KLw5fDrMKXw6LCmV/CmWXChsK1w4DCpjpZP8OYWMKBXHUwMDE0PsK2wq5cdTAwMTVcXGbDnsOywqXCmFVcdTAwMDZ6RsOMclxcYsKcw4jCpcKcO8KmJj5Sf8KDwr9QL8KZw6hhw4lmb8OIPUDCgcOCw47Don07XHUwMDFiw4Q+w6TCosO9w6JhP8OrJ8Kmw4/Cn3TChVxcXCLCtT1KwqfDlUtBwrLDocKAwovCusKsNVnDicORw63Dp2PDiSXDlsKwPU3DvcO0wrjDtMO9wqJ5PUrCssOmw6ExXFxibVNGfMKGw5PDosK8wplWw4I5wqEhw6rDo8KRNE0/w5pcXGY1w69AKHkowqbDslx1MDAwMcKXwq9cdTAwMWTCmsKQwrrCrMORworDnUrCrnlcdTAwMWNcdTAwMTnDrMKFLlx1MDAxMcO4bSjCgFTDgFXCsFx1MDAxYV8jw7k+wpDDqlx1MDAxOVBcXFwiwrbCsSbCp3xmKiMnwoFgfMK4S8K0QT7CgVx1MDAxZMK+PUpcdTAwMDFDwqIhwovDsiM2wq8ndGE+I8OmYyZSw6jDgmnDgMOmwrs0wpt0w5d0wrkvw4fCrEjCrzAjUDPCocKwVcKDVVx1MDAwM1LCslxcXCLDiCx8w4zCkTRcdTAwMDXCo0nCosKlwr5cdTAwMDFTX8OyUVx1MDAxZMOtLnliw5jDlsKwwqZcXGI8wobCqiEwNThcdTAwMWFRa8KoaVVGwq1Gd8KAOHvCqFXDqUFcdTAwMTjDhi3Do2bDrVx1MDAxYsONwoDCm8K2wrw1XHUwMDFhW8KCOlbDmsKuw6bDhsKBUiwowoNVQzVIXHUwMDFjwp/CosK9w6JmJVNSwqtcdTAwMDbCpcOKfm9qwrJBLMO5w7lcXHbCoWtcdTAwMDPDkStcdTAwMTHCmcKdT8Ofwq5cdTAwMDZiw6tcdTAwMDPDscKsw4fCtGlcXHbDp1x1MDAwNUt3wpJwwqtlw61cXHZIwptIw7hcdTAwMWFcXGJcdTAwMWNcXHTCrFx1MDAxZV7Cq8KZw5vDtH/DtMOxPiTDtcO5esKSXFx2wplcXHZcdTAwMTFcdTAwMWPDmcKtwr5cXGJcdTAwMWPDsVTCmMKrwp7Cty9cdTAwMDHCq03Du1x1MDAxYVx1MDAwNjbCr8KFJcOAfsKPw7DCuUNnXFxcXH5iXHUwMDAyw73DrcKfwqrDncONw6fDh8OXw5/Dj8OjM37DksKmwpPDhFx1MDAxNCVcdTAwMWInw61cdTAwMDXDkSFYw53CpcKgw5nCiWTDncKmdHR2woLCuiFqMTVtdzfCn2/Cq1bDn8KpPUDDhk/DtcOBw5jChsOoW1xcdMKpXHUwMDFlPUpcdTAwMDI9Slx1MDAwZcKbw5vDmlxcZsOaw6g9Sl/Dl3TClMKxTml1dcKddVx1MDAxYcKSw4PCsTnDm0bCksOIw4k8QjrDmlFPSsOqXHUwMDA2wqF2asKuwo8oXHUwMDA2P8Odw6HCgUlpwpzDocOYw6TClVx1MDAwNcO7XHUwMDAzwpNTw7MrKyVcdTAwMThJZ8OkJyVcdTAwMDc9TcOxw6HCqWnCqCbDq8OWw74kTXFcdTAwMTVcdTAwMWM5XHUwMDAxw5nDgsKDwqdcdTAwMTnDssK7XHUwMDE3w4VcdTAwMThcdTAwMTfDksOJJ8OnXHUwMDFiw7LDu1x1MDAxN8OFXHUwMDE4aMOjacOVwqcowrMlXHUwMDA1w6jDucOHwoPDqcKnXHUwMDA1w5bCsTnCkMKZwqTCmlx1MDAxM8KYXHUwMDA3w6DCjWnCucO4w7hpJD1KXHUwMDEyw5ZcdTAwMGVcdTAwMGXDhFx1MDAwZT5cdTAwMWTCqsKqXHUwMDBlwqrCl8OBSVx1MDAwN1xcdMOgwp/Dv8O2w57DqndpwqHDvsO3w5jDlcOpKcKKwqBcXHRcXHRcXGJ5w7TDvMKKwpNcdTAwMWYnXHUwMDE3w6PCmUtoXHUwMDEywphFVsOtRyZmP8OuUTFnSTjCucKAPUo4XFxiScKywoBNMcOpZcKgTkLDtcK6wqVoXsOvwoPDs21cdTAwMTZcdTAwMDRzbcOrUU9aXHUwMDEzw5DDtVdcdTAwMGXDpMKmScOww5XDrsKdMcORw6xcdTAwMWbCrEjCu8KtN0tcdTAwMTDCqEU9SiVwb8Kywq3CkT19RsKGVjnCnCDDhDAxwoXDnG1mw4PDnkXCp8Knwql0wqdcdTAwMDctwrzCoXI2aMK0XHUwMDE0MMONfDjCssKmw6pcXGJcXGZowoHDq8OSWsOPXFxcIsK+wpApwo5cdTAwMDTDg3F7Y8KmwrRcdTAwMTQubcOwwoPCs8OMcCvCnywjUn3DvixKwqNHwpXDoUvCjcK8XHUwMDFkw5FZXFxiw5rDmcOPXHUwMDE3w7PCkU9nZSFLXFx2wrNjw4zCo8KVwqBGw6kmXHUwMDFhwq00w77Cv8OsO8Obwr1UwpDDmFx1MDAwMsKkXHUwMDFlXHUwMDE0w714w6jDgMOPNURDw4HCh1vCoXd9XHUwMDFkw79xScO/XsOXwoYxwrlCw4F7woTDncKWw73Cu8OVR8OHwqY/fcKBKcOaXFxcIsOGw5TCozd3w7fCgUjCqHrDusOcwpxcdTAwMWZHw4PDgsKFW8OVwqhcdTAwMDUowr1cdTAwMDFcdTAwMTlVw5TDgsOlw407e8ODwq/DvcOBwpZnwqQjw6sxfzd9dcK5wrtbw4PCr13CgVx1MDAxN2LCoFx1MDAwZlxcdnHCq8OLwq1cdTAwMDHDusKbXHUwMDEzw6/Dn8O1YEliwp1cdTAwMWRcdTAwMDNBY3/DnShcXGLDrcKMXXRcdTAwMTXCgGFIZ1xcdCh+w4rCi1x1MDAwNsO5PX3CmFLDk8KHw7vColx1MDAxNsO8J8KhwrREcCdnwq3DsFBBwoFZXHUwMDAzwqZcdTAwMTImXHUwMDA3w6HClGRAJ2dswo1Rwr89QGrCqMOZZijDksOWXHUwMDEwYjI3RcOBwrvCgcOnwqbDscKzwpXCuWTDq3vCkVx1MDAxNTteYMOfw5LCmMO/wrhcdTAwMTDDlcK5acOUwpTCgmTCpTjCuXRZw5bCiMOgXHUwMDFmXHUwMDEyw48lST7Dv8K2XHUwMDA2wqzDrFDDjn/DtsKGw6RcdTAwMTPDusOvcUl/NsOHw4LCuzPCo39cdTAwMWRcdTAwMTTDoUdiw78gXHUwMDBlwr3CrMOcw5tNXcKMw6zCjsO7JsOfw6V5w6BoI8OWwpBmwqpDQ8OFe37Dp8KaXHUwMDA3WCDDtMOtIcO0RMOAwrjDrFxcdlvDg0/DncKAXHUwMDE3wq5cdTAwMWVpU8OUw4ViwqQ5wrnDs1LDh8OfwpTDsVx1MDAxYlXCuWhSw5PDg2I2NDZ5w4dcXFxcwqdTwr4pXFx2cV/ClzXCpcOZOz1Nw53DtcKRXHUwMDAxwplpwpvDl8ONfWvDr1x1MDAwNsOvaWZTwpkkTMK6w7FcdTAwMWbCuMO5dMOUwqDCqEvCu8Kbwr1VXHUwMDE1w4DCl2bCplx1MDAxN1x1MDAxM0FfZ8OVwqvCksKCwpZ0e1x1MDAxZsKswp/DpVx1MDAxYsOXXHUwMDAxRFAtwqbDrcK9NcKQVsKIw6lcdTAwMTVcXFwiwq9cdTAwMDXDucOpw5TDhTY2QsOFwoR6W8KVXHUwMDEzw7DDp07CqcOUcHjDrFxcdsO7wr3CtD1KwrBnwrrCiMORwrTDgMKvwrVaTlxcXFxLw6XDksKUXHUwMDE4XHUwMDE4wp0hacKwUsKRMyhpwqdAw61RdcKKVsKCw4rDksOOw6JEw5TDqHjDq1NcdTAwMThtw7jDiTzDlsKwdMO0QmjChVxcXCLDjX7CoMOTwpZAw75UPUBUQMOsZ8OwLEHCkjDDssKdXFxiesKnZlx1MDAwZcKRM3hSwr9Vw4g8w4JSwojCsFEow493w5RiXHUwMDFiw5HCr8O5wpTDmkTCr8KsSXTDiMO6XHUwMDFlUlPCvMK0wpFWw6bCuX5mScKiV3rCpzfCgUXDjmTCsVxcdMOswok3wplPXHUwMDEzwphAwoYow4nCnsOgXHUwMDFhV8K/WW3CmHIoZi9pI8OHwrpcXHRcdTAwMDHCmsO5LcOvMcK0w4Uvw4k+wqE1XFxcXF7DgcKTwqY9Slx1MDAxYsK/w7jDq0XDtD/Dnz/Dh8K/YDVyXHUwMDBmWMKsNMO6woLCusO1w6nDkVxcdsOQU8OZaMKGwpdfWXZcdTAwMWFEw7TCu8OKUlxcZsK9XHUwMDE0XHUwMDA0woJqw5jDuVxcdsOlUjDCncOGXFxcIlnCgcOuw4YjwqFmc8OfQFxcYsKOLMKPTlx1MDAwZsOzwqzDpsKiNMK8S8K5TsOpXHUwMDBmwrTDiMKsZ8O0wqXCvsKhVMOEw6pnXHUwMDBlwpRaw4ZZwq7CvnNcdTAwMDRcdTAwMGUowo7DqFxcXFxcdTAwMWHDmcKAwrvCmsOXOlxcYnl8fnxOXHUwMDE5QMKpXiPDnFTDh1RwdFHCvsOew4s7Yy/DucOkwqpmMlx1MDAxMcONw4o2w7B6wowtd8KNwrfCv8K0w5xUw6N0M8K0wovCrFt0w490w45zw7PCr1xcXFzCusOVV8KmT8O/w5XDtDnCqsORwozDmMKRa8O0MUrCh2xOMWnDiybDlsOwwpXDq2fDj8OHwrTCrinCv3rCvFrCksOUw7LCsVx1MDAwZcOsw4XCqcKFXHUwMDFmw6DClGnCksO4wpTCq8Kdw7h0w7zCtMO8XHUwMDFhd1x1MDAwZUYvwplcdTAwMDMsXHUwMDEzwqFswpNzXcKdKmJEMHnCucKqw7ksPUpMw7vDgcOvwprDicK4w4TDpzTCo2HCo0XDs8OhwoJcdTAwMThcdTAwMGXChcKmwqBdZsOJNinCmTAzw6TDqsK9TcOiUcKBwp3DiVZywp/CsFx1MDAxNErDv3nCtER0wq5cXHTDq1x1MDAwNsKnTsKJTsKhXHUwMDBlXHUwMDFkw4BcXHQzJk1cdTAwMDYpw5E7XHUwMDBlKcKpXHUwMDAxwqzDi1x1MDAxM8K+woHCqcOMw4DDisOCw5Vuw44+UMKiNlx1MDAxOUpjT0nDrMKtYyZrw5R3w6rDizpcdTAwMGZXJsKxwprCqVohwpjCvCzDo8Ktw456w44kdsOTwq/CpcOFYlx1MDAxMSnCp8K1YnHCmMOEw4hEw6E/w7zCvsOYVFnCgcO8wqrDsCTCvVxcZsKcw487w6rDrcO/w7rCrsOhwqoow4FUd37CoCvCncOucsKzwpJBw7Mvaz7Co8KEw64pKsO3IMKQwqJNwrvDnsKCTG7CvcOvZkYrZG1cdTAwMWHCgDMkTix4aS5cdTAwMTPDkVNcdTAwMDd9XFxcXFxcZk5vwqJVXHUwMDEwXFx0wo/Dok3Ctm1cdTAwMTDClGJgwqvClVx1MDAwZVTDo0zDuFx1MDAxM1I/wrs0w7tuTcOPL8KqwrMxwrrDpcKMXHUwMDBmwoZaw7TCkMKqc8OQw7PCoVxcZmnDp8KcXHUwMDFiw7JcXHZcdTAwMDc3w5XCgD1AQFx1MDAwZlx1MDAwZsKQwpFPT8Owwrc2Qlx1MDAxMlxcZlx1MDAxNlx1MDAxMsKKwpTCjMOKw7jDgcOQJCjDpsKpwp9cdTAwMTVcXGbDg23ChcOhwpbChmjDlVZlV8Kkw65cdTAwMWHDqkvDiMK4XHUwMDEww6TChCxjwoNDwpPClCHCvMKfwqUgX1x1MDAxN1x1MDAwNMOewqFcdTAwMDHDg21cdTAwMTF4SDTCiibDpsKtNcOwbkHDuMKGaMKZXHUwMDA3w6bCpMO0IcOaw6c9SsOOPsOHw4YswpfDo8OPwqMmw5DCtsKww40xwrjDuHhcdTAwMWJcdTAwMWLCrcOgw4jDjHdcdTAwMDXCkMO5w69Vwrg9QMORw69cdTAwMTlyXHUwMDA1wrzCvMK8fMO3XHUwMDFmwrB/f8OTe8KDTVxcXFzCuMO4eMOHXHUwMDAywqDClVx1MDAxOFx1MDAxNsOQwr/Dj8OTw4A8w5nCrsOdXFxcIlx1MDAwNV7DisOgw57DklLCn3LCjGrClMKbwovCi3R6wozDt8O2X3E4w5fDhsKHw73DoFx1MDAxNyHDmlx1MDAxMCNPQ8OQLcOyPUrDgsOEw77CtyHDnXXCuT1Aw49cdTAwMDFOPUDDkEd0aMOmw41QY1pKw7rDucO5wqbDpMO5w4DCvip1wpLDj8KVPUpcdTAwMDVcdTAwMDZcdTAwMDbDmSQ9QMO5wrBcdTAwMDNDQ3tTw7M5w7TDkT1AP8OQwoB5w5PDl3VcXHRbw7PDr8KmfSVcdTAwMDYjccOBw4HDjsOIXkHDqcOpV8KVXHUwMDEyXHUwMDFiw4TDmMOfwp9TXHUwMDAzw5U0w41QQHfCrlx1MDAxOMOJw4/Dj8KJwqpvJsOQwr7CjsOCwpTCi8Ogwp89QMOYwr5cdTAwMGUyU8OTXHUwMDBlwrZcXGZMw7XDncOkw7pcXFwiIcKoMSE6wpFlwp7CgsK1OSjChiE+XHUwMDA1OFxcdHk5XFx2OCjDpmM8S8O5w4dcdTAwMTNmQMOTw7ZHwqZcXGJBwo1WdcK2wrJcdTAwMTHCpcK9Xz1KNsKuUzI4wq3DncOQwpnDn8O2VMO4wo7CosOIw4w8w7VHXHUwMDA2OFx1MDAwMTcoajjDgDdhbVx1MDAxN1x1MDAxYcO3w4DCrmTDoknCr8KtScKfazjCrcKRwr11w70nwoYmXFxcXHjCqzvCu2lcdTAwMDbCp3ojacKROy/CuDLCk1x1MDAxYcOEwrXClzDCg3RDaMKmw4JiTDdnYUjDomvDjsOTQsO4wrh6w498w5bCocO6wpfCilXDnsKrw5M9QMOQMyzDvCzChcKswrpgwp5cdTAwMTnCqlx1MDAwNMKqw7LCiXF4aT98w7DDqUl5woAxXHUwMDE0w7LCqltcdTAwMWXDlsKIUsKqwprCrsK9Jy9cXHRcdTAwMTNcdTAwMThJXHUwMDE5WDHDo1x1MDAwMsKFwoXDgsODQkNEXHUwMDEyXHUwMDE1XHUwMDEzXHUwMDE0wpLClcKrwpfDksOQw5TDjMOWw44yw4dFL8Kjw4x6XHUwMDFhw6JcdTAwMGVZIDzCpSHDusK9f8O5woDDqVQoWlx1MDAxZiXCv8OIwqvDvF/CrMODRMOzwqRTcG13J8KWYDdcdTAwMTQkXHUwMDFmXHUwMDFkw7EhwqFhWMKHw6bCmsKgXHUwMDAxXHUwMDEyw6tIXHUwMDE4wpgnw59zXFxcXFx1MDAxY8K+OcKfwqNDwp9cdTAwMTFcdTAwMWXDgFx1MDAxY1x1MDAxNsO7TsOHR2Q+w581w5LDgsOUXHUwMDFlw4tcXGJeXHUwMDFhw5PCgcO+w6FxUTlsXHUwMDEzZcOLwp7Ds8O+f8KZw7TDg1xcXFxcdTAwMDdbwrBkM1x1MDAwMcOZw5h0wpvDj8KYXHUwMDE5w5JGPU1qwp/DhsKGwoFDOSggwo7ChX/Co8OawpnDk1xcYlx1MDAxOFx1MDAxOcKZwplHwoRgw6diZcKbdsOaISrChX1nNz9Pw6vCqcOdwqfDjVx1MDAxN1x1MDAwNFx1MDAwZlx1MDAxZFfCscOhw7d1RWTDusO0an3Dg1lRbcK0XHUwMDE4VlxcXCJwacOjwqLColx1MDAxNcK0woPCj8K9PX3DscK4NsKOZsKGJFx1MDAwM8KCw4JCXHUwMDEywpTDk8OVVFVcdTAwMWM/XHUwMDBlw6LCsXlcdTAwMTbDk8OJf8K+PUpcdTAwMTnDisO5w5FgQcK3PGTCg2osPUpyw7VvRlXDtMKHXHUwMDFmw79/KDnCucO4w49lwpQpXFx0XcOhYVx1MDAwZcKxOcKgWsO/wq9FwqPCmnjChMK0JMKmZsKpw5rDi1x1MDAxNClcXGLDvSdcdTAwMWNuwpfDjsOVw5vCsDzDpsKAwqbDkFx1MDAxNSdcdTAwMTfDjcOVVX3DrScwXHUwMDAzw4VcdTAwMTPClcOTU1x1MDAxYsOTw6nCh1x1MDAxOcOZwpdUNlx1MDAxN8KZw4rDtMOBQVxcdMO9XHUwMDAxXHUwMDA1XHUwMDFmI0vCiMKHXsOww710ccKvVX/CiVx1MDAxOcOJw4lJw4nChlxcYsOpw4xWwpvDgsOlw5fCu8OANHtcdTAwMWXCiTlhdlx1MDAxY8OhYX7CgVx1MDAwZcK7TGvDs8KHLsKUwolcdTAwMDLCp8O/e21cdTAwMTfCvsOTUVfClVx1MDAxMHZcdTAwMWPDnntRw5XCq8OqVD1Nwr9+w6VnXHUwMDFmw6h8wrUkwqhOwoJqJ8KYw5nDnsOBw5HCqGlcdTAwMDdodHnDgCRcdTAwMWRcXHbChsKvw4XDpF7DvydcdTAwMTNcdTAwMTBcdTAwMDTDu0BUw5x+IVx1MDAxNcO1XHUwMDA1VMOxOMO8wr3DjcKkaFx1MDAwN2fDpE5dw7LCgMKHwrBcdTAwMTQnIFx1MDAxZSbDgMO0wpJ5PX1PwpNcdTAwMTRcdTAwMTnDucOhw6E4WcO4NFx1MDAxM8ORw63CscOWwp/CoWhjMcKBw6bDtn5cdTAwMGYyw6DDqMOpw6jCm8KaeyDDmijCpMK0LnnDp8OpaWdkw53Dk1xcXFw9QFx1MDAwNWzCh8KrXHUwMDFlwoPCpMOlw6jDqMKWZcOaUsKlw6LDncKrXFxcXDtcXFxcw5ZcdTAwMWMrw6PDlcOMwoTCh8OSOX/DhMO+wrnDjcOrwqbDlFx1MDAxNcKgwr/Dp0bDvyfDllvDtGrCsCRcdTAwMWQgw75ecH3CsFx1MDAxNCjDusOkWMOzczdcdTAwMTTDscO4wqXCscOQwrFcdTAwMDMzMsKUXFx0wojChsOFS8O+TkZcdTAwMTXCpMKlwpfCpcKPw47CtTjDgifCp1x1MDAwN8OJXHUwMDE4R8KFwrxDwpLDjXhcdTAwMWPDvVx1MDAxZFx1MDAxN1x1MDAwMy/DssOHwrHDmzxcdTAwMTNEXHUwMDFlJsKiwqfDh8OmXHUwMDA3c3lqwqggKChcXFwiPUrDvsOww7RcdTAwMWLCtsK/MMOBw6XDqVx1MDAwN8KJw4jCh1x1MDAwN8OlwppcdTAwMWNywoHCjT9jfDXDlkXDrlx1MDAwZlx1MDAxOMOcRVx1MDAxZsOYdMKxJMKbTsKuecKfXFx0w5PDnMK9w4/CpFxcYl5vXHUwMDE0dH3Dp8OHQcOUZn7DjsOSXFxiXHUwMDE5IWB3w5pcdTAwMTDCrcOBXHUwMDFlw7HDnVx1MDAxMFx1MDAxNEotw7JwXHUwMDE5w7lcdTAwMDHDgVx1MDAwMcOQwqVcdTAwMTLCunYmwqjCqcKlKcK2W3hEwq5NwqnDqWdkw5/DoErDunTCu8OVwqHCqMOpwpUtXHUwMDA3wqE9QFx1MDAxMMOkXFxcXMKpw6VlSWBZw7dcdTAwMWHDoX5PWcKxwrRcdTAwMTVcdTAwMDVcdTAwMWTCtcK6wqHCoU1PwoPCm8K3IFx1MDAxZFx1MDAwN8KXw6zCoTHCl2jDk8OxworCv0LDslx1MDAwN15cdTAwMTTCrEFcdTAwMWbCpMOEaHLCoMOiTMO/w79ow7crXHUwMDBlIMOQU8K0XHUwMDBlXHUwMDE4w7VcdTAwMGZcdTAwMTNIw7R8SsOZccKFUcKCUmpnw7tcdTAwMWbDkMKPw4TDmTjDs8Oww4nDuWFhTmPDlDpYJiMgXHUwMDBlXHUwMDAyXHUwMDFlw4vDmsKAPX3DscOKwoHDgUTDvGfCn8OjJlx1MDAxZSjCpFxcdMOow6lkw4zDicKww6LDnC5rw4nCg8OFXcOuwrzCjTdcdTAwMTJJXHUwMDFhwpzDucO2XHUwMDFiXHUwMDE4MCzCm19cdTAwMDVcdTAwMDVcdTAwMWQjw7vDk8KwwqxcXHYgXHUwMDE0w4Y8JWjCnUHDknLDs1x1MDAxY8K+XzdWJMOjI8KwcMORP8O/wqzDomcuwpFcdTAwMTPDqS0mbXHCuXlkUXpcdTAwMDFfw5vCnlx1MDAxNlx1MDAxNVx1MDAxOWFMwpRswoTDhcOcw4DDk2fCtsO5d3LDtcO0w7NVJmfCksOyw5LDm8KbUynDhiBeVsKZTlcnwrnDqsO1w5dcXGZcdTAwMTZcdTAwMTTCt3jDiMOow7xcdTAwMDQjw5fCsWLDt8OjacO4XHUwMDA1OcKpw65FeMO4c0bCsSlDM0rCmHLCnMOIw6LCtsOzZ1TCvFx1MDAxNcOuwotwXHUwMDE4T8OYwpHCnMOJalx1MDAxYzbDvsOqXHUwMDA2J8O6w409TcOIwq/CiEYhRlx1MDAxZVx1MDAxOEo3XFx0XHUwMDE1w4jCrCrDiXVtNsKwIcK3w4hAw6dpwpttcMKmK2/Dl8KLUsOJMzbCn3zCsMOLVGnDrMKbw4dcdTAwMDLDhcKowpxiflbCgcKvwoZcdTAwMTjCknR5ccK0w5RSVcO0wrTDnMO9PUrCu2TClcOnw4FKSMKwO07DicOpw65cdTAwMDV5J8OPwqTDj05cXHRaLsO6woHCky7Ch3J9wrRcdTAwMTTCq8KwXHUwMDFiwqo/wqJcdTAwMDVLMntcdTAwMDHCq8OMw7hqUnVpUcK0wqQtPjXDl1x1MDAxZmDDijjDvMKUOcKqXHUwMDE1asOAalxcZlx1MDAxYi9cXHRdUVPDq0fCtcKpwq1DKcKpJCnDvSlZPCtSK1orVitQK1UrUCvDnUTCujA6w4J0WsOmb8Orwqo7b0MqK8KgUj19XFxcXMODP8KywrZvK8KoUkVKZUrDqjozMcONKmkuXcK+VcO6SkrCoUp5w4rDq2ouw6HDrlpcdTAwMWEvTMOdwozCsSovK8KvKjctNC9EMz4wPjheMFI0wpJGejbCg2pJUjhSwqtiXFxiwqpQLMOPLMOPLcKPKsKPK3cww7QvwqzDu3U0XHUwMDE0O8OUMsOSLsOSwr7Dgk1qTMOKVMOKXHUwMDEzal3Dslx1MDAxYUZ6R8O6wpbDisOjalx1MDAxZMKrQCxXMMKENMOeRsKST3pnw7pEw4rDn2pcdTAwMTXCq2AswpcwXHUwMDA0NMO+csOWX8OKUMOKXHUwMDA3asKlwqsgLUcuZDbCnj5cdTAwMTJiYX4ww5VNLMOfKsOHMGR1wrDCncKqWCzChzDDpDTDvjTCnkdcdTAwMTJQw7rCl8OKZWohwqpIKmcswqQsXHUwMDFlPlx1MDAxMmPDunXDilx1MDAwMWrCmcKrXFxiLcKnLiQ2XHUwMDFlL1x1MDAxMkXDujlKQmXDj8OkwqooKlx1MDAxZsK8K37DmEcqIy1rLXBrPX11XHUwMDFiwqrDqjrCqsKzb0rCqUpfSjdKV0pHSmdKLUpNSj19Sl1KfCvChCtcdTAwMDMqXHUwMDAzK2MqYyzDq1Rsw74qSsKBw4prasOawqpCXHUwMDBmMy5cdTAwMTXDnsOqw7pLw7JJw7JBw7JJwpIyejp6MsO6WsOKesOKwrtqwotqXFx2asKNwqrDjMKqw7ArO8OFwqhmekbDs8ORblHCs1xcYjvDh0zCpGzCjnhcdTAwMGVwwqJ4XFxcIm7DtG5cXGLDhS/DnkNcdTAwMTJTw7Nhw55kPX3Cq8OEwqrDpMKqbCouwpXCqsKoKsKva3XDn0FyNWp7OFx1MDAxZUDCkkbDnsKAwoHCq8KwKnLChMKqwqbDi8KvZTU+NMKqw6Mxwr44V8KCWcO6fCrDuSrCklx1MDAxZsOYLcOrwq7Cg8O0MsKEw6bCtWpPKlBxXHUwMDEywqXDpi7ChDnDinR6McOIK8OaaCxHwq8ockcqwpZmXHUwMDFlazArw7LDvsKea8KYasOhw4vCisO3JMOKfSrDosK/wrDDisK9KsOkQ8Oww4rDnSrDplTCksOiwpAqXFxcIlx1MDAxMGw9TcOfPCpcdTAwMDIyXHUwMDA3w7XCkCpcXHbCl8KVwqJAwqrDkjA2Q8KOOcKTLEJcdTAwMTVKw5RcdTAwMWVSKlx1MDAxY8KNwqnColFewo4zKsO0XHUwMDFmWMK6QSrDkE0qw53DrjdcdTAwMWMyPUpeLMKaQMOqNDFcdTAwMDErw4otwqrDg3XDi8OLXHUwMDE3L8K6w5Atclx1MDAxOSNrwoMtw4rDtip+wokqwpR1Wlx1MDAxYcKMUlx1MDAxYS7DqmQ4w6okwqAuXHUwMDFhwpQ+XHUwMDFhNiRVwqUrw5rCi0rCsknCu8Oqw73Dm8OqXHUwMDA1wpI9SlvCqsOgM2plO2rClTDDisKnw4Qyw5xyMMODwqprXFxmw4MwXFxcXMOELsOcLD1KSC49SlguPUpcdTAwMTDCrDrDsSrCmsKvKsKGZSrDmEgqwoEzwqpVNcOqw48rw6LCimx8w5wqwoZPKsOYSCpcdTAwMDE4wqpVLj1KwrgrPUpcdTAwMTAswppBwqwsRi49SmgsPUpcdTAwMWPCgMOqZcKAw6vDpcKAw61lRT1KXHUwMDA3XHUwMDE1SjkqXHUwMDA0wrMqXHUwMDA0UCrCl0HCqmDCjlFcdTAwMGXCn0FcdTAwMGXCozlcdTAwMGVHKsOlQcK+cVx1MDAxNTLCvlx1MDAxM0LCvlx1MDAxNy7CvjvDqsKkP8OqZFx1MDAwZTbCvidGXHUwMDFhKsKqwqRAwqpEwqQ3wqLDvTBmLMK6ICxyw4FcXGIvXFxiK2rDmcKtXFxmP8KeKnkrw4ZBK8OGT8KZwqpcdTAwMDEqw7bDgSrDtlx1MDAxZsOHXFxmw6TCucO+Zy7DnU8uNcOKwq3DqMOKwqXDn8OKwqHDunfDiiTCssK4wqtow6cwZ1x1MDAxNCxcdTAwMDc7wqvDiMKqw6d2w7PCrUhcdTAwMTLCq1x1MDAwNlvDssODMMODw6gwQ8OAwqrDpsOyMEtXw61cXHbCoz1Kw6NIXHUwMDFhwoHCvjPDqcK1XFx2ZFx1MDAxYcORNVxcXCLDusOhK1x1MDAxOMKxwpzDs20oXHUwMDFmXHUwMDA0XFx2wqd6e35rT1x1MDAxYcKEw4fDkHQqw54ywqpcdTAwMTJFd33DnyPCinVXKj1Nwp1RJsOodn3DmVxcdGsxNSTDqcOMKHx+w7/CklN0w6hCUDjDlsK/w4xcdTAwMWHCo1rDj8OodHvDmcK3w47Dk8K8wovDvD7DiFR3w59cdTAwMTbCusOQwpRJdX3CpERcXFxcwr5SbsKwwpTDk8K8w4vCiEnDgcOLw6TCqGtpwqTCulZvQcO0fFx1MDAxY1rDpWrDmXHDgGzCqMKcfsO/VmNcdTAwMTRcdTAwMWZXY8OUw652w4hsY1rDsyzCqn/DlcOTalx1MDAxM3d8w4okwoQ+UsKJbUhcdTAwMWbDpMOCccKfXHUwMDA3XFx2e0x5aH/Dn8KwecOrwoY/dFl1alxcdsOlLMK0OHzDjsKIScKAw450RsK+UsOmwojCs8KUw7vCgcOQwpTDgVN9wqTDusODPX1XfcKrXFx0w5TDvlx1MDAxNVx1MDAxZsOUfsOBwq1Ew7/CoW7Ct8OMbcO+UyPCsVx1MDAxNMK+XFxiPjc0M17Dk8OUw5fDhMO+XHUwMDE1alfDlFx1MDAwZcOXQMKvXHUwMDEwwpV9w6hIZH5cdTAwMTc1R3TCmTPComcsXHUwMDFmworDvMOkSFx1MDAxZiTCumjDv8K/wpFqwrMwRHx/w6k3UyPCvXDCvlxcYsKWwo00wrldw4vCklx1MDAwMk5cdTAwMTNfw7bCjlnCo8KKcFxcdk1cdTAwMTB+NSrDm8Ogw6zCvMO8dcOfw4xuXFx2PUB+wrXDqTdcdTAwMWZcdTAwMDRcdTAwMDfDgFx1MDAxNMKcw5zDjSRGXHUwMDE2XFx2wqgxdFxcYsOjScOPXHUwMDExXFx2csOLwqoofn/Crj19XHUwMDFmZMO3w4NUw5NEasOLMEHDtEHDpcOsJTF8wqTDtMKYflxcdMKKwqHDtGFcdTAwMDXCrcKkw6fDs8K9XHUwMDE0wqRcXGZvwrN2w6bDk8OUTktPw6nCvcOLXHUwMDFlw6Q6wq/CsSR8XHUwMDFlwqRpXHUwMDE0XHUwMDFmScKpw5ROwpAywq/Cm0rDv8KMRTZcdTAwMGY5w4tcdTAwMWXCosOtUntcdTAwMGbCmsOUw49Rwr7CpMKHaMK8XHUwMDE0wrw4w40kXHUwMDEwwrfDkMKSwr0ydCjDqkJ0wpluPsKvaMK4w4/DlEBwfcOZw6fCjMOLJj1NU8OeUMK4XHUwMDFjwrd2KihRe8KkwqHCvcOTw6jCn1PCvlx1MDAxOVx1MDAwZV5cdTAwMTTDn1xcdE7DlMO1SsK9PMKfwpHCm8Kfwp9NXHUwMDEyUzlcdTAwMTRtOjlcdTAwMGY1XHUwMDFmRDlcdTAwMTTDlnDDksK1woTDisKYwqvDk3XCvkc9SsOHMcOCw5csw7Z/a8Otw7DCrXDDscKYSsOCXFx0wo9ew7/DvHR9wrfDuFrDnMOoODbCnj19w7rDgVx1MDAwN8O8PlnChsKwwpRcdTAwMGXCrVx1MDAxM8KpwoHDgMOUwpTDgMONXHUwMDE2eMOyfcOmwqDDgsKaLFx1MDAwN8KiZHNqXHUwMDFiXHUwMDE4VXzCoCPDtH7Cv8OVVFx1MDAwZsOVw5l4X1x1MDAwNMKVfMOmfsKXw5RcdTAwMGbDpFhcdTAwMGbDhcKPalx1MDAxYsOmwrfDk3BJXcOUw49cdTAwMDbCvMOMwqlcdTAwMDR6wqBlR1JcXGJwUcOUXHUwMDE0wrtVf1/Dq8KtXFxmXHUwMDAzM1Nlw4InccKZN8OMwoRcXGZtw5PDsMOGwppywp1GXHUwMDFlbT1NK8Oxw5M+WcKWXFxcXMO/XHUwMDEywoFuI8OYP3t/wr3CkHzCoFx1MDAwNUB8w6ZcdTAwMDLCpMK0w4jDn8ODw4xcdTAwMDcgesOmXHUwMDBlPU3CvsOHXHUwMDE4wqPDlFRcdTAwMWNQXHUwMDBmwpXDu2tfeCVyXHUwMDFidCh6V8KmaFx1MDAxN1x1MDAxNcOXcVx1MDAxZMO+XHUwMDE3XHUwMDEyw7Avw4jCnsO1wrPDi17Ch0l1XHUwMDA1Y3nDkMKjf8O9XHUwMDEyw5Rvw7VcdTAwMTLDlFx1MDAxZUdeecO6bFx1MDAwNcK/XHUwMDA3w4tcdTAwMTN9w4lcdTAwMTLDgMORwpx8wrdHUHzDpl3DiHzDqDVNw47ChGzCncOOwqLCp8Kdw45Ew6HCmcOBXHUwMDFjwrfDplJ/TynCgMO0XHUwMDE4NnnDhMOhw7Jrw4RYREt3w4F2wrtcdTAwMTBfVsOBw6Alw7pWwofCvyg8IG17w4DCk1x1MDAwZcKlw7JcdTAwMWEwUcOzw55cdTAwMTbDiVk9TcKFXHUwMDA0VsOtwoVcdTAwMWJrw5B7w79yw6BcdTAwMGYnMsKDXHUwMDA0wqPDhMOWXHUwMDA3wrVtw5xmwr/CucOcf8KxV1x1MDAwZsOUwojCtsOBPU3Dl8KDS8KRIVx1MDAxMMOARsKnf8KHw6jCj1x1MDAxZcKSI8Oww7TDr1x1MDAxY8OmM1x1MDAxN1x1MDAxY8OowolcdTAwMWY/woQsPD7Coj1NRT9EJ8OoU1xcXCIgXFxcXMOmw5RPwp3CosKgw5Q5wqPDpsKMcWjCp8OVwrx5IcKVXHUwMDExXHUwMDFkwpBkNFx1MDAxNmTClS5/w4PDuS7DqMOcaMK0wrfDkT1AVFx1MDAxY8OEwpLDj8OAVT19wr/Cplx1MDAxN8OZUlx1MDAxYsOYN37CmGbDo8KAQ8OmXHUwMDFlVFx1MDAxZcOrXFxcXD/DpTXDiX7CosOLc8OUf8OtXHUwMDE5w5XCgMOfwrDDlVx1MDAxYsOIw57DlFx1MDAwM3/CuXrDkVnDnsOUw6FcdTAwMTY5XHUwMDAxwpJGwp/CicKtw6FXc8O9IVx1MDAxZcKRw7fDgEc/woTDpjZ/XHUwMDE3cCjCkMKXXFx0T1xcYmR/wpTCocKeXHUwMDE2XHUwMDEwXHUwMDBlXHUwMDE1XHUwMDFjwr7Dn1x1MDAxZVx1MDAxMlx1MDAxZnFcdTAwMWVcdTAwMTLCu8KbJGbCncOIwqvDh1x1MDAwZkvCrcOUw6I+bVxcdMOxwqRwwrdcdTAwMDVcdTAwMDXCtsKiw5fDncK2woXDsC7DhVxcXCLCsMOqXHUwMDE0XHUwMDFlMcOYw4Rgw5jChcKUPUDDjMOBwop4XHUwMDA1ZcKFXHUwMDAyZ8K+w5xcdTAwMGU3w6jCkcKDP8OgXFx0wpRbwpPDmWtxf8OKw7h+wq3CpFxcXFwwNnLDj8KjwooxbFx1MDAwN1x1MDAxNjMwcMO8VcOEwoTDpMKJwrRcXFxcwpPCq1x1MDAwM8O0cMOcw77CuGXCnMO+TVNcdTAwMWFFXHUwMDE4QXpBKVR9w5jCp1x1MDAxNMO+w7XCgEfDtMKTw6g7X8KKwqxPXHUwMDFmUcOoScO/w644w4zDgMOZIcOLw7DDo8KxfMO8wqXCjcOSayjDgz7DnEB7w6jDtcOAesOtwphcdTAwMTjDjsO0w7dYemBBwol7wpnDn8KjXHUwMDFlw7dCUcKkw7DDscKbXHUwMDFlclx1MDAxNWRkwpbCjF3Ch8OZJsK1OMOHXHUwMDE3UMKfYsOOdsOUw44jwqzDvsOwYm1cdTAwMTNcdTAwMDXDpcK0w449TcOGSHJRwo4uw7PDpinCpGzDsFI9QMKFYMOyKcOGVsKZwoLCtsKGw4jCi8K5w4Z/wpTDjSZcdTAwMGXDkXM0w6PDqyfCosKtPU3DjyNJw6nDp1x1MDAwZlxcdMOjXHUwMDA3S8KCI1x1MDAwZcK3w4wpwoFTXHUwMDBmwqzDiXhUw4zCsWPDlH/DlcO5w5PDt8Kgwp3Du8KSXFxiwqFqXcO/wpbDjsOgwofDp8K+w5jCsMKZw4VcXGLCg1x1MDAxOcONMFx1MDAxZHnDnHA1XHUwMDBmw4nDg2ZCwo3Ck2ghwqHCt1x1MDAwZsOZSyzDhcONwpUgXHUwMDAzZ3nDlVx1MDAxMsORw4/DiT1Nw549QMObw7jCj8OnXHUwMDA3XHUwMDBmazg3XHUwMDE4w4g9TcOXXHUwMDA0w6bClcK9w4Ajwq7DssO5M1x1MDAwMsKpwpvCiVx1MDAxYcOuwpbDr8O6XHUwMDA3w5HCgcKvXHUwMDE3XHUwMDA3OkHCgyRjYMOwwptcdTAwMGbCvMKiw4d/NFMhwqhHw7XDgsKow6RTIcOKXFxiXHUwMDFkTMKWaMOow6wywpbCusKGw5otQGxFXHUwMDA1wpV3fT19P8OPw5LDoW/DvMO+w7Q3w5zDvkrDqsOdwo3CuDxcdTAwMWZcdTAwMWXCrzDCj8KgXHUwMDA0wrokwqJcdTAwMDLDgFTCglx1MDAwZWvCtzU4w49cdTAwMTbDpH1Tw5VcXHTCn8K+XHUwMDFhJitUw7YkR8OfwoHDjUknXHUwMDEycENnPU1cdTAwMTXCjSRcXGZcdTAwMTJbfHFHw4h1wpPCk8O4wrs4f8KywrrCk8Ozb8Ocw6gnw61cdTAwMGbDmFjCiUzDqcKeOMK5XHUwMDExwoPCnsKuSTzDn3d7IHzCsVx1MDAxY8KiwrdzwpQtwpZsX8OZXHUwMDE5woXDlsO9wpZHwpbDmiPCjsKrcz1NfMKFw7XCpcOVw51cdTAwMTbCqEZHXHUwMDE3wr7Cn1xcdsO/w4pcdTAwMWbChWbCrzPDqMObbcOEPUDDsMK5YlxcXCLCk1x1MDAwNsKCw6fCo8Obc1x1MDAxM8KwP8K9wol4w6nChz1AMTBjw6fCt8OQXHUwMDEwwpFyfcKJRFx1MDAwZVLCjsOLcsOfMsOfw5IjwrFWw5JZZ8OIfsKJwoI2b8Khw7nDkH40w5h9w6NcdTAwMDLCr3DDlcK4w7pXOcOdw45+woQ9TcOOwp1cdTAwMTFfw7JcdTAwMWXCvzRcdTAwMGZcdTAwMTJtXFx2NFx1MDAxZMKBIVx1MDAxYcOpTsK2f3DChVx1MDAxMcOSw6HCgsOHw7/Dg2nCm8OKXHUwMDFiw4FUd1x1MDAxNcOoacKFw4dcdTAwMTLDv8KIwq1/PMO3bcKcwpV4wrhtw53DkMKPw5/CtsKnwoh3w63CmMKBNcO3wqLCvsKEaTfDtCHCvT9cdTAwMGZlXFxcXMKywoRcdTAwMTLCiXPDkyfCpG7Du8KrwqNew6dSwoR0wrdoTMOnwprDujPCg1xcdCPChcKLwr89SsKVwrTClCVcdTAwMTTDv0HDlMOWw7zDkVx1MDAxZjXDl1x1MDAxMlxcdlx1MDAxYy1BYG4vw5PDl1x1MDAwM0NcdTAwMTnDpcKPwovCv2/DgmDCn0BcdTAwMDQ8w4fDjUPDvsO0w4nCocOTwrbDpMKfw57DvMODw6l8UFx1MDAxZVLCg8OdwqVwZlx1MDAwMXbCkcK/XHUwMDA1RWBcdTAwMTPCmHd/w5rDm1x1MDAxNVchWGdcXFwiZMOww5LDssOSwpghZMOxwrV3XHUwMDFkdMOTw6TCgcKkw55cdTAwMTHDnDN8bFx1MDAxN8OlXFxcXDHCvcK0wqJ5wpfDucOTw4NzOV5XMsOIXHUwMDEwe0g/P8K5wo3CoHV/XHUwMDA3w5/CuyV/Z2tcdTAwMTNcdTAwMTdcXHRQLcO7XHUwMDE2IcKYf8KxwonDkFx1MDAxM3LDmcKYwpN7XHUwMDE2fSDDhl7DrcKGXHUwMDE5w73DrMKLf8OvODfDmHnCozt1w6tQwp3CscOgw4o5wpZXQ8Oaw5N8w4vDjV0uZFxcXFxXXHUwMDE5w659aFXDi10uwpA0XHUwMDAxw6lObsOXRFEgQcOtwqDCkcKuZMOrwoBPJ31cXGZ6TCHCu8Oow5NTXHUwMDAyw5jDlMKqwpFJw4p0w5rCvcOywp99w5rCjcKnw4pcdTAwMWTDgS3CoMOOV1x1MDAwMsK7XHUwMDFiXHUwMDFhwqVQw57CgcK/w7rCq8K2McOFw57CvcKeTE/CmEVTwpjDiMKrVmLDilx1MDAwZUvCh2hiw5PCvsKLwq5qwr3DvMOPNsKLXHUwMDFmP8KFwprDj8KlfU3DqsOVXHUwMDE4wqVcdTAwMWEvT8Oia3HCuURgLsKjNsOaX2HDvH5RwqhUXHUwMDE4WWVjZMKMbsK6w5nDgcOVw43Ct8OTw6jDkMKOwrDCj8KLwqBcdTAwMTRcXFwiw7J7w60swqcxOcKcw5xfw7t7S0hZw5TDjFJRV8KYwoZcXFwiwrLCimnCmWFRRX1nX2/DssKAwrfDksKidMKUbMO2Qlx1MDAxYsKDZTVNR39ow6fDisKYwoTCg8KYw7DDrsOiw5vDjcKxMSTComzDtMKQJFRcdTAwMWXCtMKvw53DlHU1UMORUcOwcMK4RFx1MDAxNFnCnkk9SsKKw5NzwpnDksKJXFxcXMKZwrDDkk5ZXU9oZExeMlxcYlx1MDAwMVxcdMOCXFxiw6PDo8KLw68mw6RcdTAwMTNcdTAwMGbCr2PCvcK8UW7Cr8K7dmXClMKIwromw4fClWPCm8KiwonDvcOgwrc3VcOBfsOPa1x1MDAxNSHCtDzDlsK/wqtTdFx1MDAwNnHCvyXCksOrcUFkIMKOMz5cdTAwMWJcXHROw63Do0jDjcK5RcKlU8OOaVx1MDAxZcOEIFvClMKawofDvMOow6vDvCDDnFxcYsO4OWfDpzlab1xcYsKwRUXDpsOZwqlnXHUwMDE1J8OhXHUwMDEwwrXCoSc4f8OLwpbCvcOnw5okfsOKWiZ/w5x6w5fCmMOEw5rCoFx1MDAxN8KMXFx2XHUwMDBmwqfDhcKvXHUwMDAxXHUwMDAzTWxZwqZvQsObJcOTesKdPUBZw4vDnMK/ZsKdXHUwMDE5w6VkPX1hw6rCrnPDpT1Nw6rDtsKkXHUwMDE4w6tiwrk4wo7DgMOCblpiUsK7w4PCoVjCsVx1MDAwM8OdwobDrsK2wrjDk8KPXFxmf1x1MDAxMF1VwohYwo10SF5aY8OJw6BawqE3wqBdwqlcXGY5XcKUw7FbPX3CksKdwqtjw6bDi8K3U8Ogw6nDsVZjKMK+ezbCqcOxZihcXFwiwr/Cu8OVJcOtw5rDlHzDsk7ChDjCg8OYXHUwMDBmw417wrnCv8K7wq3DoDBcdTAwMWNHw4zCrcOWUEPDisOmXHUwMDEzUFx1MDAxMlx1MDAwNMKmNVx1MDAxZcKUw5g3w7RZwp1qUlx1MDAwNDNcdTAwMTPCg8Olw4xcdTAwMDHCuVx1MDAwN8O6w7RcdTAwMTPCiMOyf8Kta8KRXHUwMDExXFxcIsOMw4zDuStyXHUwMDBlP8K2wpbDnMKww4vClV9Nw7rDtcOEWlx1MDAxZU9dLMO3XHUwMDFkwrJsXHUwMDEzwpnDscOLS8OMwoLDvlx1MDAwN18rXHUwMDBmwrd1asOlXHUwMDAxTsOLw4DCnT19e1x1MDAxNcOXfsOOwqBLR1x1MDAwN8KCw4HCq8OcPU3DnMO6UsODw7NcdTAwMTIlJkZcdTAwMWV0wpQ0wpRIw4nCsXY9QFx1MDAxMU3CpsOfKm/Dp1JuwqXCiEDDi1x1MDAwZmHCtMO7XHUwMDFkR09SwpnDtH7CjsKNfcK0wojCiVRvwpVQwr7Di2vDucO1w7pcdTAwMTTCm1x1MDAwZsOSI35jw5Rbw5NqwrnCnVTDusK4w60/w5JcdTAwMWbCpS/DnMOgPX3Di8OEW0zDrng/w4vCj1VvXHUwMDEyw7RoO8O8ZllswrDCoW7Cklx1MDAwNMKdO8KkXHUwMDFla8KuOMKnPX3Di8KDw6lvXHUwMDEyw6xJO8KUXHUwMDE5P0sjaDtcdTAwMDQ2XHUwMDFlMMOSQcKywqrDlS1ew5vCoMOQw6zCilxcXFzDqlB1w68tVkpmPlx1MDAxZSvCgMKhwq05wp4qw5jDpsONLsKcXHUwMDE1TCpswo3Ci8O+LcKowoZcdTAwMWVcdTAwMTLCrcKRXHUwMDExK3ckVWzCtcKlSlx1MDAwN8KYwqLDsXnCosOxwoE7wpwoLlxcdMKZPUohXWIpOsOYXFx0PMOLwrZVTF4pXsOmXHUwMDE5w4IyX1x1MDAxOUDDi1x1MDAxZMOFbsOyMlx1MDAxY8KmwpzCuDJcdTAwMTc7wrPDusKxwoY7VHY8w4vCiztMwr5HSmzCucKHb8KSwr/DozLCl34/w4tcdTAwMThcXGI0w55cdTAwMTDChy/DhFx1MDAwNcKIwqtYw6F+w4rDssOHP8OSKcOcND5Yw5RqXHUwMDExfFV6w7fDsjTDnsOuw5cswqdgw5ZqVcOOVMO6Jlx1MDAwMVx1MDAwZlx1MDAxMlx1MDAxMFx1MDAwZsKcwr7DnMOlRi9YVHEjI1x1MDAwZlx1MDAxMsO1w4LCnMKew6zDl0ZcdTAwMDc9QFhxXFxiacO1w7pcdTAwMDHChcKPXHUwMDEyXHUwMDExw6hcXFxcPsOcw4o2w6fDuVZtOcKsw7XCusKrwo9DwpQmwoXCtMKUXHUwMDE5w4DDjC3CpXXCu1x1MDAxZMOWfMO+wr16wrTCnmZ1w7tewr98TsKmYz8vScOFwrRgw7bDhcK0bD19XFx2wqLDun7Dnm7CqFTCnMOowoHCrMK2w6DDgcOKXHUwMDEyw5NPXHUwMDEywpdyM8Okw4rChcKsw6TCiD/DjcO8LcOvwpJuf1vDtDVXcFx1MDAxOcKewrXDu8OoXHUwMDExb1x1MDAxMsKUfTtcdTAwMWNUVGzCh8OSMlx1MDAxYj/CtHrCoMKVS8OcwoTCgMKyw4bCjDXDu0bDnWxcdTAwMGUnw5QqI8KWWWrDtcOdNMK6w4nCnStcdTAwMWMnw4TCucOAXHUwMDE2w7lxwq1cdTAwMWRcdTAwMWTCuyXDqsKmfiVXOVx1MDAxZlx1MDAwNcOBwrHDlsKdXHUwMDFjesOLwo1Iw7zCqWEvwpPCmMODwqzCvD19w5BKw6hcXHY+Tlx1MDAwNcOIwrXDjFx1MDAxMMOtworChcKaWFx1MDAxNFx1MDAxNcO1a8KNOFx1MDAxMUrDk1x1MDAxNkZOwpHDg8KtPFx1MDAxOXdwwoRcdTAwMWRQTX3DqcOzw5IkcWBsXHUwMDA1w5x7wqLCnmBkU8OycF9Rw5zDulx1MDAxMMO2VsKOwo7DgsKvaMKJw7RuME/Dg8KSw6fCn1DDlMOmw4PCq8K4wrVcXFxcw7pSwrE2XHUwMDBlw71oM8O3w5PDhsKuwoZcdTAwMTZRw4trYcO9w7tcXGbDvMKePsKUwrvCuMK8WcOPw4vDpWPCk8KSw4XCoETDpMKnZj/Dr8Oxw5HDjMKKw4N+XsKpwpU0wpxHw4TCrFx1MDAwNmh2bsO1XHUwMDExeG57J1HDjMOMwpXDs1x1MDAxMnHCgFxcXFzDpMOPw4LCtsO+wqFOw4vDp8Orc8OKKcKzcsKfwoRMw6TCmMK+wrLDqEdzam9cXHYzUiDCjWZcdTAwMDR+PX3CuXDDgsOuw43DgsOtwptcdTAwMTJcdTAwMWPCsmLDvlx1MDAxYcKcLMOkwodkK1x1MDAwZsOSd2pcdTAwMDPChcOww41Fwog9TcO7w5TClcObXHUwMDEywoZsVkQhZzDCr8O/w67DisKHZFvCksO0w6DCksOew7BNRFx1MDAxZsOpWjhcdTAwMDNuwrdtw59Zw7HDjMK7wqPCjcK7wrJEwrXCnlx1MDAxMHBLwofDp1Jewpd9TsK0wp7CtG7CtcK5wrhrwogowo3DusOaVTtcdTAwMTLCpm4uXHUwMDA0XHUwMDFmWkbDu8OzXFx2MsOpRcK3XFxiXHUwMDEwwrZww4zDicKLwpLChMKTQiRcdTAwMDRhNMOfeEnCr1x1MDAxZVx1MDAwZnHDi0XCn017w6HCik7ChFrCoS7ChMOMZixcdTAwMWJcdTAwMTDCscOMwrnDtMOLw7LCoVxcYsKaTsOVXkY3w4hnNmd/QsKww6TCkDZvw73Dj8KwTHtvMiTDvj/CtsKEXHUwMDFkwq3Cu1x1MDAwZlx1MDAxMUpcdTAwMWVbVzJcdTAwMDNnNW4hw40tO8Kfwp0yw5RJZC5cdTAwMTfCljNqWEgrw7LCk8OBaVx1MDAwNMKKXFx2wrlcdTAwMTDDmFx1MDAxYW3DiT8nw7rCr3TCicOOKVx1MDAwNzHDp3ZcdTAwMWJrw6AhOsKkYz5Lwq09fTbDpMO8wrlrw6nCgDXDu0RvS8KMdcOne1x1MDAxNsOlw6vDksKKXHUwMDE2worDrmlcdTAwMTHCr8K2wobDp3rDvcKEecKewoY9SsKzwqzCtGZ6XHUwMDAyXcKhwp7CqcOiZcKkwqjDsjfCj8OCw6TDiybDpGvDkiHDtWpOSWc6V8KYwptvXHUwMDE1wpbCh8K7XHUwMDFkwqZBXHUwMDBlIcKNKsOkRWcqwqfDq8O4wpLDiMOPXVx1MDAwNGfDvTPCtyPDukl/wrdcdTAwMTbCucKGIGPDjMKed3HCjn1cdTAwMDI5wo9cdTAwMDbCm2pcdTAwMThIOMKSIDTCpcK+JFx1MDAwNTjCh8Kzw5xtw7E4XHUwMDAzTEFXwoVcdTAwMGXDhMKRwq3CmsOFX8KUwqHDnnBPw53DlsO6PUDCgcOAUsOrw7k8X8OYw5tqXHUwMDBmw6nDt8O7wr3Du1x1MDAxMMOSwp/DkUM0wr9dbVvCm8OQXHUwMDEyIcKLPX3CjsOPwpTCrMOIw49ETcKRwpbCrn7Dn8K3en/DkEvDlGjCj8KqXHUwMDFlwp83wrrCqcOAaMOMeFx1MDAxM8OLWsKXZ1x1MDAwZWBzQVx1MDAxN8KXPUBrV8OUZFJfc0XCl2bDksKvNFx1MDAwZsOfw7rDvcObw4RcdTAwMTJvw40wPMKfw5XDjSdtw797XHUwMDBmVF9cdTAwMWUkw5dUwqQ9TcOLwrTDlMKVf8O6XHUwMDFiXHUwMDA1w7TCksOIwq9cXFxcJMOFw43CrlxcXCLDlkxcdTAwMDTDucKBblx1MDAwN8K7LFx1MDAxZcKOLUlPwqdcXGbDi0R5SDTDk8KAamXDmcOzw41cdTAwMDfDpFx1MDAxY1JMezjDv1x1MDAxOcK6b8O9w6nDtUo/w4s2PMO4wrpwVMKBw496wrfDkD7ChEltw43Crjc9SlHDolxcYsOxwpZHKcOBe8KoXHUwMDA1w63DhsO0JcOtw4ZcdTAwMTVcdTAwMTfCjDbClMKpXVdUw6nDgsKNw7XCqVrCnFBcXHTDg8KXw4XDqVxcXFw3OMKJw4I5wqVoXTUxwqfCjEBGJ8Oqw6ZcdTAwMWLCqMO5w5bDrMKZw4NwXFx0YcK2PUBcdTAwMTPCgcO2PX0pw4HCtsOsw4NcdTAwMTHDtmwpwpF2XHUwMDAzw5M4XHUwMDEwwqzDuT19w5DDgsKnw67DtkMmwrrCu2XCnMOJwqNcdTAwMGbCpMK5XHUwMDEzw6klOFx1MDAxZMOuw5jDh1x1MDAxM1x1MDAwNMKiwrVTYcOkw7PCjlnDpcO4woZ7wpjCjcOAXHUwMDAxwobCjcKYXHUwMDFlwojCi8O0XHUwMDFkWV1VXFx0wofCjsKWXFxmWVrDoMOhw7lbwpVtw7hcXFxcw53DhHldScOGeVtcdTAwMTFgw4jCjlx1MDAxZcOeW1x1MDAxZMOUw6DDg8KbXHUwMDE2ZMO4wqZzacOww6JcdTAwMDZpw6zCpjNjw7ZiR2fDssKmw5xjw6piV1x1MDAwNcOxwqbCv1xcYsO1wqJcdTAwMTBcdTAwMTjCkMKOSGFbwrttwqFcXFxceMKxw6BdNcO2RMODw5PCncOgXFxcXMOJwqnCmMKQaMOxwpnCjMO0WMKXworDgMOlw5jCkcKmwoDDmcKPw5DDtF5aK8ODw5XDg1x1MDAxZmHCgVs1w6fCgFxcXFxcdTAwMDRcdTAwMTXDgV3DuFx1MDAxY8O1w4LDkcODdULDpUXCtULCqyVsw5DDoMKoaMO9w7phw4EzdcOEw63ClmJhwrXCg8KSwoHDscOCw7jDk8KPcMKnw4TDq8OCwrnDlMKQw4BcdTAwMTnDh8OwXHUwMDE2e8OZwoxIw6nDlMKKRMOhw4BcXFxcw5F9wrVDUcOFLFx1MDAxMMO9w7XChnDCkH1gwr3DgcK6w6vCokXDkVvCsyHCvcODYXU9fcOCPUB7PX1CwqdrNsKdXHUwMDBmdj5cdTAwMWTDlGbCrMOzwpo1wo3DsMKpNMKPXHUwMDFhXHUwMDEww4vDtsOMXHUwMDAySlx1MDAxMMOowqQqw50mwqw5wp3Dl8KGw7J+w6TColvDpcKIw6NbPU3CgcOjXFxcXMKdbcOHQ2nDtMK7U1xcdMKRw7FcXFwiT8KFXTXDn1bDglx1MDAxNsKdUMO2wq1sbVx1MDAxMMOow59Iwr3Dv8OYw6/DlsOCw4vDuMOuNn7Ci8K4Zz19WsKxQVJaO8K2VsOdXHUwMDBlZ8O3wp5kITRcdTAwMGbCkCc+XHUwMDEwaCVWwp5cdTAwMWbCpFVGw6NcdTAwMWHDg8OaXHUwMDFmXHUwMDFmLVxcdmtcXHbCl8OLXHUwMDFlXFxmwpXDrMK9w5nDuTXDqTjCmDvDmMOIwql2wqIkXHUwMDAzwqjCi1x1MDAxMMOKUMKLwqdcdTAwMTdAXFx2w4LCpcKVwq/ClVx1MDAxN8KBNFV0QTPCqcKIw4hXPkLDuDo9QFxcYlM9fTBAeEDCuFx1MDAwMXY+w6BcdTAwMTnCtzpIRztOfsKnXHUwMDE5U8KmwoPDvXlcdTAwMTLCjcKYTFx1MDAxNlx1MDAwMcOWUFx1MDAwNkFPTWZcXFwiJsONwqHDpsO4d1x1MDAxOcOsw4txw6YvXHUwMDBmwpXDpsKHwqB5XHUwMDFkXHUwMDE4wphDXHUwMDEzJ1x1MDAwMXxcXHRcdTAwMDXCiFx1MDAwZlxcZj1Kwr/ChTE5XHUwMDE4wolcXGLCqFx1MDAxZXDCilx1MDAxOFx1MDAxYkfCucOJSVxcdFxcXFzDsVx1MDAxMG7Cv1x1MDAwN1xcXCI9fXk9fVx1MDAxNXjDlsKdXFxiwp5cXGZtWcKlwowpw4/CpVFkw4DCp2lbworDmcKmXHUwMDFkwozCl8OXXHUwMDEwY8OPXHUwMDEww7dER3jDt8OwK8OsXHUwMDEww7fChcKxYMOZXFx2wrnClyjDhWPDm8ODw6dgw48jw4d4wo/DncOrwq/DhFx1MDAxMMK5b8Kdw4XCjcKXw4BeUcOfw5nClFx1MDAxOMOXwohcXHTCllx1MDAxN8Okw5cjwojDscOYwpDDn8KjMcOFWcKjw4fCkiglXHUwMDE0flx1MDAxZCBvQcOFWTJcdTAwMDXDhE1cXGLDnmE5wodcdTAwMWXDksKjw709SkHDtz1NwonDpsKVw4hcXFxcXHUwMDExdVx1MDAxZE1cdTAwMDFcXHTDt8OVXHUwMDE4KcKXSMKnfMK0XHUwMDE3e8OBwo3CrVBcdTAwMWPCgsOBw63CtFx1MDAxNlsvfyDDu2I3wqDDr8KgwpcgwofDoUhcdTAwMDVgw77CsjfChMKPw7TCuMKiwpXDq2jCn8OhwovDk0TCpcKgw7V3cSDDkFx1MDAxMyrCoMKkPUBqID1Ke8KhwqDDjFx1MDAxNsKKwqBcdTAwMWJSwrBcdTAwMWbDlCHCj8ONwokww5rDhyfCrVx1MDAwM8OYw4zCi8KWKMOzO1x1MDAxNsKiwq/Du1x1MDAxNijCu8KNXHUwMDAyw6bCj8KNXHUwMDAzw785wo3CgsKlXHUwMDFkYj1ASl/Cu8O3XHUwMDA0W8K7XyPDhsOwIMKdw7PCjsOBXHUwMDBlecKQTTh3wotRJ1TCisKZw6TDgcOawp3CtcO0XHUwMDAywo/CsW7ClsOrw75UwqDCslxcYsKeIFx1MDAxMlxcdsKUw6DCl3Y3ZVx1MDAxZMKFVyXCnmtHwqVcXHTCm2DDhcKdwpM4w6VTwo9Iw4VZw5/CqsKnw5zCkEslw6zCjVvChcKfwp0zwqVSwpVDwoVPw6nCrMKnw6DCmE/CpcOxw53DiMK3w6XDm8OEV8ODw77DqsKEcsOXwo1Rw5bChsO5woRlwpnCjsO1w7nCl8KMPU3CjcOhw5pcdTAwMDHDqMKWwo/DucO/XsOcazBlXHUwMDAye8OlwqHDnEfCqMOlXHUwMDAyScOhwqHDnVx1MDAxZMO9IMOcd1x1MDAwNyVcdTAwMDLDumMxXHUwMDAywpbDjW3Dllx1MDAxNMOYw63Dll3CncK+wpfDp8KkwrbCp0HCpcKsw4cgw6jDg8KHfMKswoM9fSNAPUDCjMOzU8Kgw5dcdTAwMTNDwqBcXHbDuMOdXHUwMDE2wpkhXHUwMDFkXHUwMDE2w7d9QcKCXHUwMDFkw7p1XHUwMDE2w50gw7XDlnAmfyA9SsOFwpVcdTAwMTZcdTAwMDPDhmA9QFx1MDAxOSHCnz1Ae8Kewr3Dh1jCpcOFXHUwMDFmw4lcdTAwMDfDuMKQw5NcXGLCjyXDgFx1MDAwNsKNw6XCnknDmj1NwoBpwo7Ct3ZIw53Cq1x1MDAxNcOJw5phw7fDicOcV0XDicObw5TDgFnCgsKgPU11IMK0I8KVPUDCjSdFw4BcXFxcwqPDscKEw5jCqMO5wpjDuifDsnjCh1x1MDAxY8KzXHUwMDA3w4vDvMOzw6TDuCTDrMOUw7XCpsKNLcO1w6nDncOXacKow5pcdTAwMDXDncKow5shwogmwpDDscOwwp7DncOgXHUwMDAxKcOaa8Krw6dcdTAwMTbDq8KNwqnCg1x1MDAxYcK7XFxmPU3Clz7CqHtxPU3Cp8KofFx1MDAwMlx1MDAxNMK5PkjDpsKJRCnDhk7CrcOtw7fCj8KbXFxcImfCgybCjcOoRiAywr7DsXBnXHUwMDFjwqLDrcKIL8KmaMKvwrFcdTAwMTFCXHUwMDFhwpvCkVVJwqnDhVjDqsK1XHUwMDA3P1x1MDAxYlx1MDAxZsKhwrTColx1MDAxMURPwpZjdEPCpXLDkz1KYSV/w5rDtW5/w5bDlcOXwrDDgcOJfcOtwqU0w7/Cm8K8w58wXFxiwp/ChS1Zw5Y9QMOudMOYwoRcdTAwMDJcdTAwMGXDk0DDqFp5RVXColx1MDAxNT1KccKZwp7Cmlx1MDAxYXzCh0ZcdTAwMTbDlcKxScKow7rDrVxcXFxVXHUwMDFlXHUwMDFic2ktw5ZcdTAwMWPDuyrCoVhdw65zaHBiXHUwMDE3w5c7KMOlw7pCwoXCo8ODPUrCsXl3w5pvw4dTXHUwMDE4wqBcXFxcw63Cm1x1MDAxN8KQwqLCnsODY8Oowo/CkMKrw4nDicOdw6rDjDZ1w6Z/w680w7FcdTAwMTjDocOswpVMw5fCm8KEw4Ffw7BcdTAwMWZgwqLDh8O6QDXDiFx1MDAwMlxcZmjCu0dYYcOfw7HDvXlcdTAwMDTCjcOfwqIxwpbDvVx1MDAxMcKqw7nDllx1MDAxM8KxXFx0NsKgw67CtVx1MDAxOGNcXGbDvcKvJ8KbwrPCsD19aMOaXHUwMDA1M1x1MDAxMTfCncOwwrHCiWPCjXvDvyrCplx1MDAwM8OqL8OZZlx1MDAxMsKsXFx0wrfCmsOvw7fDmcKHw5vCpFx1MDAwZmomcMKROnDDpTHCi1x1MDAxN2phw4Ynw7o3OcODXFxmwrjCgcO1wqU9Slx1MDAwNsO/SFxcXCLDlsOdUcKIwqDDsD19w6nCtFx1MDAxY8OsJVxcYsKjXFx2w4jDnMOrXFxcIsK+w5xhw4DCiFx1MDAxMcK3woXDhsKvw6Ilw446YcK3woxcdTAwMWHCrVE2w4jDiMK3XHUwMDFhXHUwMDEwSMKuwqfCkCM9SsKaR8KJXHUwMDA2w5vDu0HDqcKaXHUwMDFjw61cdTAwMWLDsSfCmsKiw4ppwpBcdTAwMDUmwpttwp4qKCNmKsOJw7RGwqzCj8KpNsOrUcO0LFx1MDAxYkVcdTAwMTNKwoZhVTLDmXs3w7DCgMO1wqzDm8OTazLDiMOhYC55w6BCwrTChcOgNsOvX8Kgw61cdTAwMWHCs0fDrcKawrw9TcKaZsKfXHUwMDAxwppWXHUwMDBmPsK0w6XCocKvXFxmw64oTcOawpHDvTLChlxcdlo8w6VgwrjDrsKNw5ZxXFx2woFFcFxcdkHDsMKLwqLDvsOUWsKWw5VfRMKRw7dJwrfCt8KjXFx2wqJcdTAwMWHDnsKawqbDpGVGScOIPMKrw59cXHRvPUpRXHUwMDFiwo3DmiTDh1vCosO5XHUwMDFhcsKmw6JPPFx1MDAwNcOib8KLwpTCpT4gXUTCtWnDtknCtSnDvD1NwprCm1xcYmJmXHUwMDE4w69iw6ZLTETCscOHwrPDsFPDmFtcXFwiXHUwMDAzJELCpsKET0BcdTAwMWTDtcKNXHUwMDFiXFx2w6HDm1xcXCLDrMOCXHUwMDFiw4LCk0PCucKfJXfDqnvDtVA9SsOYw6gzw6JZVzjDkcKHwrnDrcOYw4hcdTAwMWJiwpvCh2YoUMOBwqrCicKQUMKKw5lFM8Oiw71XO1XDvlFcXGbDtMOpwrPCosKGbDzCiMKeZDMhw510w7DCgF/Ds8OiXFxmf1xcXFzCoDnDhsKyccKWw4jCssO5dMORPUp/M1NcXFwiVMOFwqxRQsOOXFxmw7rDjH7Dplx1MDAxNHBUOMKadsOtw63ClMO9XHUwMDFhw5jCuF5mXHUwMDAzXUfDucKIw4LCuMKPXFxiw5A9TcKlwpI8XHUwMDEwV8OFwq7DgcOmw4nCrnXCp1xcXFxcdTAwMWHCs09DwqJcdTAwMDbDhTZmwpzCmlDCiGFhPX05wqXCvMKzcWTCkVxcdsOQw7RWZsObVzVBw4LCjj1NUcKDXHUwMDAzwqInXHUwMDFiwpbCpsKGwotcXFxcXHUwMDE4acKQXFxcXCjDp8KYXFxcXGBcXFwiWkNZwp/DtcOrw5PCv2PCosOrw69Gw5bDjMOIwrXCicK3w7XDr0RcdTAwMTXCnVx1MDAxYlx1MDAxY1x1MDAwMcOjYlx1MDAwMcKbNMKIYcKPNMOgaGYvw73CqcOQwopBUDlJw5PDtsOtdXhcdTAwMGZcXHZdw7wjYk5KScOFwoFcdTAwMTE9TXvDkVx1MDAxZFx1MDAxYjfDpCrCmW0vXFxcInDCgytIwp/DnirDhSdSw6ptw4Y1wptcdTAwMWTDjmxmwp19S1xcYlx1MDAxY8OSOsKVwpVBXFx2wqXDi29cXFwiwp3CnzvCuGTCiMKuw7/DqD7Ci01cdTAwMTXCjGZfw6RCXHUwMDA1w7lVw7A4V8Ovw6ImwoVbYMOdVMOrXHUwMDA0wrtPYsOgw5AuwqlnwoLCrFx1MDAxOcOpUsOrXHUwMDE0RH1cdTAwMWJUw4nDk2JZwpVUwojDncKcVD1AaGU/aSNmPyk9QFXDrzMow4/CgmnDnT7DhVlTw699wrnDgcKMw73CkcOPwoJxw4s2w7Fkw4BcXHbDuMOaXFxcXMKmw53DijbDtcOYVsOtX8Oxw7VcdTAwMWHDgnHCj2JcdTAwMTnCmUPCqMKMwobCuMKBW1x1MDAwZsKiPU1cXFwiwpxcdTAwMDbCh8KEwrhcdTAwMDHDmFbDscK1OMK/PU3DhWHDtMKbXFxmw5HCnMK2wqI/Ylx1MDAwN8OMLGlcdTAwMWbDmMOqwoXDsX49SsKNwoM/XHUwMDAywopwL8OowoLCicKrw7lcdTAwMTbDl8OqdFx1MDAxMVVcdTAwMWHCsDE/wqLDsFx1MDAxMTTCpnp0wq7Ch8OebsOiw7HChMKuX2Zuw6JawoLCrsKXw7DCtMOawo/DlDLCkUHCssOaXHUwMDE2wp47wqhdwonCrlx1MDAxZsKAwrVcdTAwMWHDvMOXTEbDoXnCrlx1MDAxZHnCslx1MDAxYcOHw51MZj1Nw4QywoHDn8K1XHUwMDFhwq9xTGYowq8yNVxcdMKzXHUwMDFhw47DuUwmJsOFMmEoPFxcdj1NXHUwMDA3XHUwMDFhwobDmTLDiSM1w7HCp0xcdTAwMDY3wqfCiXlcdTAwMTIlYMKga8OJPyTDpsOww7pcXHTDn8KiSmw9TVjCtXrDtTs7wrRcdTAwMDNSbMOgw51vw7JQccKuw4xxwrU6SEpswo3Cv2/Dslx1MDAxNDdcdTAwMWVcdTAwMDXCmy/CtMKHwobCq1hOwoHDisKeXHUwMDAxNFx1MDAwZVx1MDAwNcKBwrhwwohSccO1XHUwMDEwwr9Nw7fDu1x1MDAwZlx1MDAxMsOcZFx1MDAxZX9cdTAwMDXDtMO6XHUwMDE1XHUwMDAzwo9SXsOKNsKnXHUwMDE4VG/CgcKhw4DDjMOhw5vDj8Oyw4nCicK0SEfDgsK0OMOveG9cdTAwMDFcdTAwMTPDk8OSKcOQPMKew7fDqS5cdTAwMTdcdTAwMTVScDnDkUDDjVxcdlx1MDAxNMOvcsKQwpU7wrxcdTAwMWJWwqxeNcO7wrXCsmzCnlx1MDAxOMKbKyRjw5sqP8Omw7VxK8ODI8KSXFxmJWbCnmlfOcKXwqZkL8OHRGUvwqPCiMO3b2bCvsK1MFx1MDAxOMO0a8OxXHUwMDFmwp3DusOkXHUwMDE0w7NcdTAwMTLDryXCll7ClX5gwoTDplk1w7tcdTAwMTTCg1x1MDAxMsKgwqBQfMOlw4LCqzjDhcKQw4rCtS/CvXoyXFxcImBmwp/DvXsnw65eXsKjeVRkIGUvwr9bU1x1MDAxMnLDv25eI35cXFxcXHUwMDA0bk/DjcKSXHUwMDE5TsOew5pKOzdcXHTDg8KqXHUwMDEwwp/DrsONwptcdTAwMTRcdTAwMWLCksOBwplGwoTDgmcrc8OZRsK5PsKEwozDu8OkwoFbw5LCv0HCrcKAXHUwMDAyccONacOrPU16wplcdTAwMWPCgsOew6BMNMOnwoZEwrNcdTAwMDTDoMK5a3PDtzvCkifDv8KaXlx1MDAxMcOrwpLCjlx1MDAxZGQ2P8KewrhsT8OpcMOMwqtnTcO6wrjDqcOLXHUwMDEyw7NcXHRcXHZcdTAwMTLCgMO5Wl5cdTAwMTEhesOuKUTCrHDDqTdwPX1JMcOLw4pcdTAwMTXCq1x1MDAxMnnDtTp+w6dRKsOnwoZcdTAwMTfCuXbClSfCulx1MDAwMcKOwolewprCtjnDvFx1MDAxYW5cdTAwMTLDmGjCrcKQwqDCpU1cdTAwMTXDpcKtw7vCqyfCiMOywpfDmFFcdTAwMDTDh1x1MDAxNsKrw7bDp1x1MDAwNsO7woxPYU4lwo5KVFx1MDAwNVx1MDAwZsK0w6R0wofDusOew4orcnnDt0PDh8OkXHUwMDA1ScKzREZ7wo7CjGk+wpZcdTAwMTPCqsOMwolcdTAwMDLDiy9FwpbDuyUzYFLCgcO5RMKDXHUwMDA3w5puw6ZkNcKOw6vDgsONwqxZw5BywpDDjTPDpFtcdTAwMDRCw6fDisK2wrrDmsOzKmfCt8O8cWFTZ8OOw6F3MUcyw79wXHUwMDA1w6nCksOMXFxiw69EwpJcXHRqwp/Cnlx1MDAwZsOQVETCv8OVwqwmwr7CvsO7w5DDl8K0w5LDtnHCqsOYXFxiXFx2w4t/woM0XHUwMDEyV1fCucOEw4HDssKswpl0MHNJwrxsPyteXFxcXFx1MDAwNlx1MDAwMsOxwo5JXHUwMDE1wovDpMOZwp9bw4FkwqhcXFxcWWjCqcKNw6zCpGRDwqfDo3l2wrrDvMKlw5BtXHUwMDE3N1x1MDAxZHs9TU99w45cdTAwMWLCtsOTf8Knw6zCgjRIXFxcXMKNw49cdTAwMTlbIMKHw6HDg3dJwphawoFJw59cXFxcw6XDmcKGwotwScOnw7I9SsK3XHUwMDExw4LDqcOdeV3DpH14XFxcXFx1MDAwNMK7w7c2XHUwMDBmwpvCtlx1MDAxM8O6Y8O2XilcdTAwMDLDucOWw6nDqMKxwoPDpMONwrNcdTAwMDNawqdlw71kwphVwo3DvcKpPX3DncK5woTDucK+wobCicOtw7bCgsOhwrTCo8K8w5/DhsODXHUwMDE5w6PCrsKDUcOnwrrDu8OpXFxcXMOBwrvCh2bCtcOzQsKFw7VuRMKAXcKBScKBXFxcXMKxelPDjcK0XHUwMDFkw4M9TcKtw53Dg8K1MX3Dg3rDsS7CkFx1MDAwNsKwwpLDkHldwqwzw4U7w7ROwqc1wo4sPU3CpkLDj8K1w4jDtk/CkcKBwpDDq8OcwqjDtsK+wphVwpDChMOWM8KdPU3Crlh9wpLDisO4wrLCtC82wqd1wrBbwrRcdTAwMTc7eHskVsOeZVx1MDAxYn7DgsK8wqB1Ymwnw6Z6XFx2XHUwMDAye1xcdsK7w6LDh8OswpRcdTAwMTPDn8Osb8OFQTRcdTAwMGYtw5XCr1x1MDAxNMOBw5zCrn3Cj8Otwq81QzlcXHbDkCxNwovDucKgU1xcdsOPXHUwMDEwwoBcdTAwMTlywrV/XFxiM8O0S1xcYsKRw6FISVbDhkTCo8K2QVxcXCJcdTAwMGbDoiTDjcOOPX3DjcKQwpdnXFx2wpUjXHUwMDEyw65cdTAwMWRcdTAwMWLDpsKQNcKFw7VcdTAwMTDCj8OHdlx1MDAxZFx1MDAwMW09TcOEXFx0d8O3wpk9QMKZw5LClyBcdTAwMTXCh8O8wqZLwqRtwp3Dt8OLXHUwMDA3w7d7w5TDt8O3XHUwMDA0wpPDgcOEXHUwMDE1w4VcdTAwMTlew4nCgMKnXHUwMDAzw4bDiFx1MDAxYcOfwqNcXGZcdTAwMTjDqFx1MDAxMMOLXHUwMDBmwpzClsOEw4M8XHUwMDA1wqfChMKtJ8OCw5bDuSDDgVvCjcKhw5jDocKLw63CryfCg8O/ZS1cdTAwMDNFXHUwMDAzwq1cdTAwMDNEQ2nCgMKZb1rChcKMYcK8wofCnMKONkVjTsOAXHUwMDA3w7/DhMOyPUBvw4/DnVx1MDAxNzlRw53Cv8Kbwq/Cllx1MDAxYsK9XFxcXGDCjMKBP8KFXHUwMDFmw6jDhFx1MDAxZsOaw4PDs3hzw4LDt8KEw5jDhMOxOMOjw6jCusOnVMOhwr5cdTAwMDdcdTAwMTnDn8KsJ8K+woPDuVx1MDAxMMOZwpPCisKvwoE9QMOdaMKHw4VcdTAwMDJmw7XCl8KWwpVcdTAwMTI4YMOOwopBwqXCqcO/wojDoMOCZ8OqRMKeRsKQwrlcdTAwMWZHwo3CsUPDm1x1MDAxNsKjwrlAPUDClFx1MDAxZUNgUCdmw4V6wpvCs8KfwojCosK/Z8Obw6jCt8OPIFx1MDAwNsKOw6lGwpnCkcKVw7lcXGLCjUvCisK3w5fDpDjDoFxcZsO3wpHClj1Nw7fDgcKWwqFcdTAwMDVFw6AjXHUwMDFjwqUgXHUwMDA3XHUwMDEzecKWXHUwMDFiw7tZwpYmw7hcdTAwMTlcdTAwMTbDlMO/w6nCgsOtwoNcdTAwMDdcdTAwMTbCvSbCiGDDlWnCr8OPXHUwMDAxw71cdTAwMDJ7wodEw6nDlMK8w6snZMKPwpvCocOWZkjCqGsrRcOlXHUwMDFhwptcdTAwMTBUKzbCuVJcXHbDtj7Cj8OWwp1zL2UgfcOtZVx1MDAxMcOSPU0vXHUwMDE5X1x1MDAxYVx1MDAxN8KKV8KGw6JzRVx1MDAxMSjDv8OrUU1cdTAwMWbCmsKMwr1oOMK9XFxcXMOuw53DsELCi1xcYsKAwo3CpiPDkTPDqDzCisKwwqM1w7fCm1x1MDAwMy01wpbCk8KTwq/CpVHCg8KNw5NnYFx1MDAwMiPDhVfDmEjCksK5w6VcdTAwMWRGXHUwMDFhJsOnJ1okXHUwMDEywrJcdTAwMGbCl8OGXHUwMDFhXHUwMDFkM8O4w6LCl8OzKsKmXHUwMDEzwqw1w6g9QFx1MDAxN8K0XHUwMDE5XHUwMDA1OcOswpnDsMOkXFx2wonDv1x1MDAxOMKCwpTDoTHDgMOpPU3Cs8OPwqXDp1x1MDAxYUF9wplcdTAwMDZcdTAwMTRRw67DlTxDZsOcPFxcdsOhXHUwMDFmaGJcdTAwMTfDillowqHDrznDvcO5JsObw7jCuSpWV0HCssO5wpIwXFx2csOdworCpsOySy5pwp9HwrTCmcKjOMOtwp3Cr8OtWznCr1xcZirCkC5AOEjCs2UxwrfDrMO7J8OtwprCs1x1MDAwZsKSZn5hRsKJXFxmbz1KwonDqU1cdTAwMWHDn8OBwo3CmsKSwoVOw7hjPMKvXHUwMDA3RcOwXFxmw79/PU1cdTAwMWHDpMOuwpLDtlxcXCLDsD1KLMONwoJcdTAwMTYlVUDCmcOiYEhZXHUwMDAzYivClUDDsMKLXHUwMDFkw6rCosKmdk0rXFx0wqXDhsKqb8KFPX3Cm8KNwoA8wrhCKsOgw7NcdTAwMDHCjsKWw6fCoUw4w7N0w6tZw5d9XHUwMDFiXHUwMDE5ccOTw6LCnHtEWDdyw7HCmcOow489TcO9XHUwMDE1UMKLw6/Ci0NcXFwiXHUwMDBlXHUwMDAxNibCosKjUHggw7TDrMONXHUwMDE4wpFcXHbCn29cdTAwMDNiwobCp1xcXFx4XHUwMDAzaEPClsK+Rlx1MDAwNsKiTTFcXHR4w7bDr1vDh8OjXHUwMDAyw5XCnjTDuMK/w7jDrcOnXVx1MDAxZFx1MDAxYcKNa2jCgMOFwr3CucOBXHUwMDFiNMKacMKfK8OIXFx0fcKqw5NTwopVw6ZSw65cdTAwMTFMwrTDmlx1MDAxOMOTTMOmw5nCiVvCiMOmw45CSVx1MDAxOVTDsMOgw5tPXFxcIlxcYlx1MDAxYjzCpn/CoVTDgMO0w4XCtHVYd8OveFDDj1x1MDAwMlxcXFzDoT7CuWfCg8K0WVTDgFxcdsOsw7JcXFxcRsOhw5A2ecKlwoTCsGXDtsO1wpt7bGM4woR9wrhxw6DDgT1NwqPCtD/CgsOww5EsXHUwMDE5w7PDk8OqwrVEVMKaPU3DrzQmPU11L1jDujvCi2VZO8KAwrdAwovCsUw7WMKIUsOsw6nDocKzXHUwMDFhIMKQO8OIXFx0VMOsw4VJwrVcdTAwMWFxwpLCuX3DqMK1w5pcdTAwMDRJYsKwYFxcXCJHw57DqVnDq8OZw6dcdTAwMGbCvzJjwog+w4vDnMKfTMOeXn3CrnRGb8OSXFx0XHUwMDFkNMOewqHCmC88YsKASsO+fMK4cDlXccOrQcO0wrpcdTAwMTc9SlxcXFxcdTAwMWXClW1TwpRcdTAwMTjDhcK0VMOtw6rCqcOlw4wuQ1xcdFRwZlx1MDAwM8KMw45cXHZ6wq4sLTXDu8O4w7IsXkxgScKjbsKrwqlfwpI0w7zCmsO2b8KwNGPDklxcdsKYYFx1MDAwNFx1MDAwNsK6wq/CpsOMXXvCr0otwo9cdTAwMTZ1ccKkTcO9w7rDnMORU1x1MDAxMsKVJG7DrsOmc2zDncKNPX3Du8Olwp1cdTAwMWJSw7VQOMKDwoHCtnHDoMOBwo3DujZcdTAwMGbCkj5IZkDCl1bCuG7DnVx1MDAwMXBKw71cdTAwMTDDu8OSXHUwMDFhJFLDnlx1MDAxYlxcdjLDvibComLCpMKawpFSw7zDojrCtsO0wqAxw4woXHUwMDFkLMK6wpnDnEnDpGDDqjHCp1xcXCJTwq7CoMKTWlx1MDAxY3VcdTAwMWRud8OEXHUwMDE4clx1MDAxZlx1MDAxMmpcdTAwMWFcdTAwMWbDpUrDpcKheHLDlcOyO3dcdTAwMTbDm3HCrcOQXHUwMDA0w4xcdTAwMWbDh8KAXHUwMDEywobDhi9kwqNcXGI+XHUwMDE3w55fcMK3w702w7rDl1x1MDAwNcOkwpLDksOjYMOcecO9asK1w6HDlMOMd0d0w5J+bcKqZsKnPnrCmcK0VsKkwodVwq9GLSXDgsOCXHUwMDA2WMKQI8OswpnCtlx1MDAwZj1AwrnDtsK6wqfDmUNcdTAwMTknecODXFx2XHUwMDA1ScKqKVx1MDAxNGDCncObw57Cv8KLTVlcXFxcecKWeV1jwol5WsKxIUnCjCjCjlx1MDAxOMKLw5TCtsOhXcK1WMKWwo5cdTAwMWNcXFxcPUBaw4NcdTAwMWPDtcODw53DlUFaXHUwMDExR8KQW3E5dsKRw7h5w4jDtMOCwo/CjlvClMObXHUwMDFiwrbDh8KpYsO9wpVEw7LDgihcdTAwMWXCisOWeWVaw4XCkERdwrhrwpR2fsOJXsK9w4dcdTAwMWV7wqLDlCPCsFx1MDAxYcOoXHUwMDFjO1xcdj1Nw5Jfw6xpVcORM3lcdTAwMTZGU8OGwpLDklnChsOzw6lcdTAwMTLCl8Opwp/DmsKhdcKbJVvDscKqXHUwMDA2PX17wqHDiMOJQsKIwo/DvcOmbsKPwqbDnT1Aw7rDpFx1MDAxMMKSw6N3w7fCg8OxXHUwMDAzwpBcdTAwMWTDnsKlw7dNLlxcdMOFw4nCscOzw514VV5cdTAwMDPCicKhw7ZcdTAwMDLDt8OUeFx1MDAxNkDCicKZYMKjfDJFZFXCvMOnw6RYwrNHw7/CvsOtOFx1MDAwM8KHw7hUwq/DucKKRVjDtsKQwr9mQMObXHUwMDE0XHUwMDE1woHDmlPDvMKVwoNmwotdwqXCoVxcdDhgw6fCmVlcdTAwMTU6wprCrsOnwoXDs8OcIDHDucOaOWRYw5vDhcOPw5nDnW3Ctlx1MDAxOMOaL8K4wrlcdTAwMDJZw5jDuVx1MDAwM2xcdTAwMTHDoVx1MDAxNnNcdTAwMWTDuVx1MDAxNsKGKDnDoCjCn2HCpV3DgMOsSGjDvFxcXCLCq8K7RsOYKcOLwqrDjcO5NVx1MDAxYcOZb8O0YsKMw5ZESMOPw43Cs8OZw6DClD1Nw4d/wqTDosOXw4lLPUDDqcKYwrbDncOcw7dcdTAwMWE4Q3XCpsKiw5tfw7hhw5rDrVx1MDAxMVx1MDAxNUdcdTAwMWHCjMO3KFxcXCJcXFwiNsKRwpYnXHUwMDAzL0lIXzLCuVx1MDAwM1x1MDAxOMK4w4kpXHUwMDFiw65twrHCoj1NXHUwMDE2RDDDpcKNSWYlXVx1MDAxZT1Nwp7CsD1KLMOhSsKmwqnCojLDuMKySMKwfz1NbFx1MDAxYihcdTAwMTLCu8OCMzfDrcOVXHUwMDA2w6xcdTAwMWLCqFx1MDAxN1vCosO0w7FywqYgXHUwMDAywoLDpsOeTETDocKjw65cXGbDrsOhPU3Dm8OxwqxiXHUwMDE2PU3DgsKqfXlQXFxmw79Lw7NcXFwiXHUwMDA0wq/Cs1xcXCLDp1o/aVxcdMOAwrDDoVx1MDAxY1DCi8OFXFxcIjZGw5tdPX3DhcKmw7TDrH3Dl1A9TcObw43CnVx1MDAxYcK4JsKGw4ZkwpE0QMOXw7bDrcOZXHUwMDE1XHUwMDFkXHUwMDFiw7zDry/DosOMw5w6WXVWwqxkw5pCZcOzwr89SsKwXHUwMDFkT8KCw5HCjFTCiMKMwoHCtMK/WMKrw5dJwoHCsMKZw6lXw63DpFx1MDAxM1x1MDAwZsOCwqN+wrjCpyxVw5pcXHbDkDTCplx1MDAwZsKRLzjCj27Colx1MDAxZn47aMOebcKuwoHCiEHCiyk5TMKmKlrDpi9cdTAwMWHDpS7DsMOSwoDDmcKswptVdTtcdTAwMWPDgsKAwqvCpCHCv03CnsOiNlx1MDAwM8O5WW9cXHTDpsOQw4zChcOxwrTCu8OEdDskXHUwMDEzwojCqsKYOcO0bTTDpsKGXHUwMDFlwo/CmWBcdTAwMTTCnMO4bjXClMO8wrvDvSg+PsKoYjN/WcKwwpvCrD1KXHUwMDFiwpJyJWJOw7duTMKxw7TDu8KSXFxmw4Q7wpLDrMOcw4tcdTAwMTJ0cErDhMKOXHUwMDE2wrHDpMKgM8K7wrnDm1F8w7REwrLChsKAZcOLXHUwMDA0w4cgXHUwMDEywqfCrT9sI8OQUsO1w7sqT8KGPUBsdE1/e1x1MDAwNHtow7Q6w7LDjCjCnShcXFxcwrnCmMKnwo/DqMKmwqfDr8KyXFxiXHUwMDA2wpHDoEbDqMOww7Z2ZsOvwrbCosKpwrrDm8K5wpLCjsOsPUDDmMKQwqTDmcO3wpHDnMKIeMKNw5jCh8O2woo8XHUwMDAxwrBbw7jDjVx1MDAwNsODw4VHwrDDtsOBW3x2wozChMOVw5rCtsKET8OeJj19Vl5cdTAwMDLCnlx1MDAwNiXChXtcdTAwMGVcdTAwMWLCjlxcdsOBPX3DsXlQX8ORwrhcXHRcdTAwMDTDllx1MDAwMybDmsKDJMK5LMOFUcOcwooxw6hAw5zDhUbDscOcPUBNw5DDmlx1MDAxNFx1MDAxMF/ClsOHXHUwMDE2wozCoMKKXHUwMDE1woQgwqBcdTAwMDN4PUB/XHUwMDFiUsOVwonCpMOAwrdjwqnDh8OnJFx1MDAxMztlXHUwMDE0XHUwMDFkwoUgJsOjSVx1MDAxNsKsw41aIcOZbjjChcOEU1xcZsOjwqXDvsKawrTDnzhowoDCj8KywoHDnsOCwovDl8OBPUDColx1MDAxMsKlMUbCo8O9Q8Oxw5ZIwq7DkTlcdTAwMWLDrMOnwoFDXHUwMDA2XcO6ScOJUjPDrFx1MDAwZlx1MDAxZsOtwppcdTAwMWbDtMK7XHUwMDAyTllGw5nDocKzw6xzwrHDjFx1MDAxYmM9TTNcdTAwMDJjaCvDlXZ3w7DCoV18w5smw4pzXHUwMDAyXHUwMDBlwqBQwphGYEPDpcOZw7LDr8Kzw7FcdTAwMWNcdTAwMWHDr8OnL8KCw6XDjDIpXljDq8KQdcOQbEnDmD7CuVx1MDAxNVjDrVx1MDAwN1x1MDAxOcO0w5tcdTAwMWNcdTAwMTg0w4ZJUsOsVMKlb1xcXCJcdTAwMDRROyjDucOUXHUwMDA0KUBcdTAwMDHDgCZcdTAwMDPCm8OJw7tcdTAwMWFTw49ge0HDksOxwr5cdTAwMTnDm8K3w57Cii9Xw6jCijHDkcOzwpE9fcKmZFNowpdqXHUwMDA1Jlx1MDAxMcO0KcOnw40+w5jCvTnDiVx1MDAxMMO9LcKSwrA4w5Bxw7spw5gmXFx0ZWTCiyBbI1pcdTAwMWHCs8OMPU1cdTAwMTI+ZMK9KMKhXHUwMDBmKVxcYlsqw5jCvXlGwqbDkMO6w6/Cni9nw4fCliTDpsKzQEbCu8Obwr8pKVx1MDAxY8O5woBvw7HDusOuXHUwMDA2w7xcdTAwMDTDsMO4XFxiw4vDicKNwqlRw5ErWMOYLTHDo8Ojw6XCpcKkNyBAXFxcXDIjJCMxNjM2NMOcw79ew53CnUhcdTAwMGVTXHUwMDFlXHUwMDFiRTw+XFxcXMKWXFxcIsKye8ONw7FuwrfCtcKzw4c6w4liW19nTV1lwpF0a3tzwpPCg2/Dj8OXwrjCt8OVw6HCqcOyw7JcdTAwMWHDksOCMzPDs1NcdTAwMTNDwr1cdTAwMWQ0dcO0VMOUw5BcdTAwMDHDuMOIw6HCmsOzw5zCv1x1MDAxZsKVYcKYwpNcdTAwMDbDo8KVXHUwMDE5wqg1w60rw6hNw7BPwo92U8OYw5LDiGPCoVxcdsO8wr/ClWFcdTAwMTlcdTAwMDLCnT1KwpJcdTAwMWTDs1x1MDAxZMKBwplcXGLCp1xcXCJcdTAwMWVcdTAwMGbDhcO5aSjCksODwqPCt3bDslPDmcKFw5zCkMO1w5htw7fDkVnDoFxcYsKlKChcdTAwMDVJXzU+Y8OTwp4gwrTDt8KlwrnDicOnPUAoXFxcIsO/w7HCmGc9fSHCi1tcdTAwMTMvwr/DnUDDl8KEw6nCl1x1MDAwMcKrw41cdTAwMTbCr8OgZcK5wonDqFx1MDAxOSbDu8ORwpRcdTAwMTNlWMOlwpzDq1x1MDAwNMOQw43CkcKEXHUwMDE5Z8KlIcOfwoXCimFew5/CnCN4wqYnXHUwMDEzw4Fow4jDrcOyXHUwMDE2woNFwrnDn2gpw5PCkj19wr5+w6TCisO9w4vCnVx1MDAxN1nDqFx1MDAxZVx1MDAxYyTCr1x1MDAwZsO4XHUwMDA1wqDDnCfCp8OJJsKqwpLDu2QmXHUwMDFhw4HDhsKVwobDtyDDtVx1MDAxOVx1MDAwZcOHw4x0XHUwMDE1wrlcdTAwMDYkUmFaw4vCmMKBwoXDkcOWXHUwMDExw45cdTAwMGZRwonDtTjDiFx1MDAwNsKaXHUwMDEzw4XDlsKlXHUwMDE0XFxmPU1Hw5xcXGLDo1x1MDAxNcOZJ8OAXHUwMDFiw4fDpMOlbcOwwonCnjJcdTAwMTDCtXJMXk/CqVx1MDAxNT1KXHUwMDE5XHUwMDEyw7vDjSUgwpfDlTvChCdlXHUwMDAzM8Kpw5fDl8OXXHUwMDExw7hHwog9SsKRdVx1MDAxOMK6XHUwMDA2wp/DnsOPw49cdTAwMGZcdTAwMWFcXHbDh8OdwqbDlsOzR8K8w6XChMOZwobDo8O8w7zCnMKKw6jDiVfDo23CnEEjTcKhJFx1MDAwNMK6ZU7CocKHw6PColx1MDAxYlxcZsKzPX3CpVx1MDAxMCRcdTAwMDN0XHUwMDE4PUooeMOHZMKfXHUwMDBlcsO9wpbCiUXCnMKxXHUwMDBlw5jCtVx1MDAxMcO4w4dlwqjCpiFGacKFw7TCoW1NV2LClEF5w6s8w5JeXHUwMDAzQ8ONwrxcdTAwMTTDisKmXHUwMDEywp/DnjkvPX3Culx1MDAxM8KiJE7Dl2rDjys+wpZcdTAwMTPDg8Oad1x1MDAwNnZcdTAwMTQ3PzZ9wrrCrMKLwpNXL2TCt8OoKsOVwrRcdTAwMGV6wpfCvl3DpyrCjMKwQcKqw5jCuMOMIcO6w43DkmfCvlTDh23DocO7w6RaSVx1MDAxMFhcdTAwMGZrw5nDimfDkj/DvsKZwpRWwqfCrkg1dcKuXHUwMDEzwqwoXFxiw4/Cj8KKKMO0Q8KCw7zDlcOEw6DDjsOUw5NBfirDp8KzOCrClsOzw7rDs1x1MDAxZUPChMK7w7TDjsOYeidcdTAwMTJjwp5pwpQ4XHUwMDFmwqtEeFx1MDAxOcOOwrF9ZcKLW8OydiQ0w5dzXHUwMDBmfcOhw5LCq1x1MDAxZTzCpErDn8KuJHhvw7oxXHUwMDEyMlx1MDAxNCrDj3NcdTAwMTHDvcOhwpJtw5TCtsKkcsKjw73DlcKTwpnClF/Dv23Dr8O8UVx1MDAxMsKCXHUwMDE0LsKPMn1mSWxiayzDrl7DgsO7f1pZw6A0w4w9fcKmXHUwMDEzXHUwMDFmWlfCnmfDrkNOw7pXXjlcXGZdWGzCtmpHworDpTjCjD9sXHUwMDEycGQuwoxQwqLCnmTCp8K7woDCrcODJVx1MDAwMSvCuzVcdTAwMTMrWsKpKTXDtidcXHR1wrFrLsKvRMOHdcKJw5FcdTAwMWZKwqA9TUjDtj1NwolzwqVsPnBBbixGw4/DsWtmwq9IwodsXFx0w43Cj0ssXHUwMDBlVm5Lw7bDisOXSsOAPU1Pw649fcKWw5DCsWp+wrBWZ8K7aHVVa2bDsn/CsnPDgjV9w5BcdTAwMTFswpZuUlbChUA0W0R0wp5AwqfCvz1AwqxcdTAwMTLCulx1MDAwNTrDi8Oawr5ILsKbSGlKPUA9SkpnMMOMMcOeXHUwMDEyLCRgwpcuw5tMwrlKwojCizdXwq7DksK5wojCsmbCksOQw7FtJsKwO1bCqCAyIHx0w454w6vCuMK7w73Cin9cdTAwMWXCk8O+XVx1MDAwMsK4wpYtVlxcXFzDpytsw7w8XHUwMDEzfV7DicOEbsKHw4xcdTAwMTZcdTAwMTPCg8OeZ1/CtcKkcTfDj8Ohw71tw5NcdTAwMTd6wqF3w4xZw7vDmlx1MDAxMkXCn8KtwpzDi0HDu1jDvkxcdTAwMTRVX8OEXFxiccK5w5Age1x1MDAxNHoxXHUwMDA3w4pcdTAwMWbDk8OTw77Cp8O0wrXCiG/CpXvDlcKKwrfCvsKSJEJHd0fDjVx1MDAxZVx1MDAxM8OTXHUwMDFlwqfChMK4dMOLw7h7PUDCnjfCl3fDv2piwppKw6fCrzjDjsOgesKcesO1w4fDjcK/w5PCllx1MDAxNETDv8OJw4hxIcORXHUwMDEwe8OJw5I7XHUwMDFlWMKkLsOfwrV8w5DDnVx1MDAxM8KVw55gf3LDn8OtLMKew7XCkmHClENcdTAwMWbCvcK0w445w7vCu8O+S3TDhVjDjlx1MDAwNcKTwo3DlCxUwpHCsMKYw4pDw5QrwoxcdTAwMGZQw7pWZ8KrwoxTwo3Dkj9Jw73DvDrCl8KdRExow5DDvUA6YVx1MDAxZEbCjGFgw7woOitNd1HDu8ORwpMrw65cXGLChsKwXFxcIsK5XHUwMDAzw54tbsO7w6bCsXLCuEdcdTAwMWVawrLCsTvDukNcdTAwMWXCj8KELUzCm8KYbF7DssKMXHUwMDA0P8KMwpTDqGvChsOxwqhkRsOMwo1eXHUwMDEyZiRQwpcqXHUwMDFmIC3CsjfDk8ORMW3CrsO3ScKyXHUwMDFjYnjDsWrDlsK2K8KHdGnDilx1MDAwZkvDpFx1MDAxMWZuw4LDvsO8YDrDkVx1MDAxZETCjG/DoMO8azrCm015w5HDrCzCnlQ6XHUwMDE1w700XHUwMDFiUFx1MDAxZMKTUcKyXHUwMDA0IzbCu03DpVx1MDAxM8K7OsKpw41secOQwoXCk0fCsibDoy3Du1HDtcKTwqHCslxcdiMvwptOwrFcdTAwMTNSwrLDsMO7w4vCtVx1MDAxMmXDnjPDritnwqvCgsK+w59ewqzCssOIaMKyVMOrwp5Gw65cdTAwMTDDgsO6TCQzw4NrcFx1MDAxMMONf1DDq15BwoY6wqPCjCDChTtcXGZcdTAwMTHDoMOJUsOjVGzDmcOZw4NgZcKXO0vDmTPCu8O3w6VcdTAwMWRucj1NXHUwMDE1wrZcdTAwMTDDmGtMwo7DqcKlwofDnSTDsTRcdTAwMGVkXHUwMDFiwqLCnVx1MDAxOcK0NE7DjcO7XFxiwqbDrMOdLFx1MDAwZkdcdTAwMTjClkjDvcKEwrjDoMKXwr3Cj1nDrcO+w4g9TcOJw7/Cg8OVwqXCj1I9QFx1MDAwM8K+dzdXbWnDvEdcdTAwMDM/wrHDqi7DlCHCjMKDw7d8wp5cdTAwMTTCljolVsKfVMOkJFTCrFx1MDAwZlx1MDAxN1Nrw70oUMOaXFxiScK1e8OSXFxmwo7DoFx1MDAwNMOOQsOXwoBTwo1cXHQvQMOLecO9w5VcdTAwMDPDjMOObMOuwp7DucKMXHUwMDA3NMOqXHUwMDA3YcKTS1x1MDAxNcKGw4DCucKwXFx0woTDuFx1MDAxMEBcdTAwMTHDi8OTXHUwMDE4N8OWXHUwMDFlw45TXHUwMDEyXHUwMDFhXFxmd1x1MDAxNiF7w6NcdTAwMTLDrsOFXHUwMDE3XHUwMDE2csOxRlx1MDAwZVx1MDAxNcOgw4FfXHUwMDE1w7Vwwp5cdTAwMDPCi8OgXHUwMDFhwoZAwqwwwq3Dh1pnPX3Ck8KnaMO3w6hIwr7Cq0hFwobCjMK3ScORw43CtcOSwrd/WXVtwrXDjFx1MDAwNVx1MDAwM8KFVMOTXHUwMDEywoXDsG1gwqlcdTAwMGZuw55nXHUwMDE5Q3VcdTAwMTVPw41cdTAwMDZcdTAwMDZhXHUwMDE2XHUwMDA2wqPCs3LCqFxcZlE9QMOgZUhcdTAwMDPCtlxcXCLDuMOowrTCs201JMKfw53CoSDCuVEmw61UfMObw7I9SsKvPsKIQULCt8K0eMOzXFxmwrDDlMObXHUwMDEyXHUwMDExVC/ClsOeaTw/wo8zXHUwMDFhwqoxO1x1MDAxMsOow5FcXFxcKFx1MDAwNl9EXHUwMDE4woHDrcODVMKLXHUwMDEyPD1Aw6rDtzBNwrvCmMKzYCjCl0bCtMOYZFx1MDAxMlxcdsKrwqTDrcO6w49lMMKiUGkuwqdTXcOwJsKZwqvDssO8w6o2wonDqTvCqiwhwoM9SsKJwrc9Slx1MDAxOFx1MDAxZMOdw7DCtcK1wqfDulx1MDAxZHXDoMOiw4PCi8K6w7/CmsKaQ1x1MDAxZTZww7nDuWTCjFx1MDAxZMKnw4jCsiDCmsOwNVxcZlx1MDAwNsO7w643WFxcXCLDhcO2Si7CrlxcdkLDq2M2XHUwMDAxOlx1MDAwNsKtXFx2woguw7nCisKiQGtEQsO8bMK6UMKww547w6Ytw63DpTrDpj19w63DpTtcdTAwMGUrbcKIOlx1MDAwZTNtXFxiOlx1MDAwZTttwog7XHUwMDBlQ21cXGI7wr4rbcKDOsK+M8OMcsO+w6rDl2VEbcKDO8K+Q21cdTAwMDM7XHUwMDFhKi1ZOlx1MDAxYS4twpk6XHUwMDFhMi3DmTpcdTAwMWHCtsKuwrJLPUpLMMKIXFxcXMOqfTbDpsKPwqrDsULCosO3KsO5W1x1MDAxYcOIK0PCisK6Ly1cXFxcw6tKRTDCjsKua8KANsOyNsKtXHUwMDE2QsK6SzDCg1xcXFxKfTbDnMKPasOwQsKOw7fCqsO2W8Oyw4grR8Oqw4o1Nlx1MDAxMi4wXHUwMDA3wopqccOKw6XDnMKzK8OHw6vDimU2XHUwMDEyOjDCh8KMasORWlx1MDAxMkAtZMKwa1x1MDAwMULDumM2w6TDscKqOMKMw7pvMMKePMKtwphcXFxcw4rDjULCnsK/K8OHw6/DisOlNlx1MDAxMlowwofCkGrDkVtcdTAwMTJgLWTCuGtcdTAwMDFDw7rCozbDpMO5KjBaworCqyt2worDqjAtQsOrwqo/S8KKMC3CoMKuwqpLNsKCPCzDkFrCinUyQsOtwqpfS8KKOC0gwq7Cqms2woI+LFBbworDvUVawrQrw5VcXGLCqsKDdmPDucKvXHUwMDAzwrbCv1x1MDAwZSEzXHUwMDFjw4XCisOBwoZRXHUwMDAyTyE9fVx1MDAxNsK8XHUwMDExM8Kgc8KkLsOlTsKnwqzCh1x1MDAxY2jCrMKHXHUwMDFjwqjCrMKHwrxJwqzCh8K8acKswofCvMKJwqzCh8K8wqnCrMKHfEjCrMKHfGjCrMKHfMKIwqzCh3zCqMKswofDrDnCrMKHw6xJwqzCh8OsWcKswofDrGnCrMKHw6x5wqzCh8OswonCrMKHw6zCmcKswofDrMKpwqzCh0w5wqzCh0xJwqzCh0xZwqzCh0xpwqzCh0x5wqzCh0zCicKswodMwpnCrMKHTMKpwqzCh8OMOS7DpW5pMsKgwrPDqDpcdTAwMTY8J0tcdTAwMDJPJG7DmnVcdTAwMWXCtcKKw4FcdTAwMTJFw6tYw7tpwqzCh8OMwrkuw6VuaTPCoGPCpy9cdTAwMTY8J09cdTAwMDJPJHbDmnVcdTAwMWXDhcKKw4FcdTAwMTJlw6tYw7vCqcKswofCrDHCrMKHwqw5wqzCh8KsQcKswofCrEnCrMKHwqxRwqzCh8KsWcKswofCrGHCrMKHOMKpwqrCh8KsccKswofCrHnCrMKHwqzCgcKswodsXHUwMDBlw4LDhk1cdTAwMDHDsmdcdTAwMGXCiFx1MDAxYzbCo8OAw45rw7xMwpPCvMOew7Nlw7LDpcOyZcOzw6VzSHLCiHLDiHJcXGJySHPCiHPDiHNcXGJzQ3LCg3LDg3JcdTAwMDNyQ3PCg3PDg3NcdTAwMDMzOTJZMnkywpkywrkyw5kyw7kyXHUwMDE5MjkzWTN5M8KZM8K5M8OZM8O5M1x1MDAxOcKzNsKyVsKydsKywpbCssK2wrLDlsKyw7bCslx1MDAxNsKyNsKzVsKzdsKzwpbCs8K2wrPDlsKzw7bCs1x1MDAxNsKzODrCh0pka8Kewq1cdTAwMTIyw7s/w4xdbsKhwrI4O8KHTGRvwp7CtVx1MDAxMkLDu1/DjMKdbiHCsjg8wodOZHPCnsK9XHUwMDEyUsO7f8OMw51uwqHCszg9fcKHUGR3wp7DhVx1MDAxMmLDu8Kfw4xcdTAwMWRuITMwMkAyUDJgMnAywoAywpAywqAywrAyw4Ayw5Ayw6Ayw7AyPUAyXHUwMDEwMiAyMDNAM1AzYDNwM8KAM8KQM8KgwovDu8Ohw7fCvFxcdEbDoDPDsE8hwp1cdTAwMDJRwp/Cqk5nw5jCmErCn8KuXHUwMDBlwqfChlx1MDAwN2tcdTAwMTQ6c8Kowq7CvCbCm8KfN8OTwp1OI1x1MDAxMVx1MDAxNEx8UXPDtMOxw79/w47DuMK8wr7DicOVw7Vyw4dQXFx2OcKBXHUwMDAxwrtkecOsacOYWE7Cn8OMwq7DqcKGwodzXHUwMDE0djMpw6PDpMK+w77DkzwjwprCn1fDk8KdT1x1MDAxYz1NXHUwMDE0wox8UXVcdTAwMGXDtcO/w7/DjsO4w4DDssOJw5XDtXPDh1jDuznDmMOYUcKfw6huwqnDosOgwqrDnjM8J1xcZlx1MDAwNDTDvMKQclx1MDAxZcK5wpV1csOFTMO7ecOYw5dLwpfCuG7CqcOjw6DCssOeczwnXHUwMDEwXHUwMDA0VMO8wpBzXHUwMDFlw4nClcO1csOFUMOrMVx1MDAwMT1AwrtgecKsScOYV07Cl8OMLsKJwobChXNcdTAwMDR2MyjDosOgwr7DnsOTPMKmwpzCl1fCk8KdT1xcXCJcdTAwMGZcdTAwMDTCjMO8UHVcdTAwMWHDt8Ofw7/DjsO3w4A9SsOJwpXDtXPDhVjDk0nDosOgw4jDniPCvCTCrcOdL8Kyd0rDk8KJYsKFwqtcdTAwMDI2wrwkwrHDnU/CsndLw5PDiWLChcKtXHUwMDAyRsK8JMK1w51vwrJ3TMOTXFx0YsKFwq9cdTAwMDJWwrwkwrnDncKPwrJ3TcOTSWPChcKxXHUwMDAyZsK8JMK9w53Cr8Kyd07Dk8KJY8KFwrNcdTAwMDJ2wrwkw4HDncOPwrJ3T8OTw4ljwoXCtVx1MDAwMsKGwrwkw4XDncOvwrJ3UMOTXFx0Y8KFwrdcdTAwMDLClsK8JMOJw51cdTAwMGbCsndRwpNJYsKFwrlcdTAwMDLCpsK8IMKtw50vwrN3UsKTwoliwoXCu1x1MDAwMsK2wrwgwrHDnU/Cs3dTwpPDiWLChcK9XHUwMDAyw4bCvCDCtcOdb8Kzd1TCk1xcdGLChcK/XHUwMDAyw5bCvCDCucOdwo/Cs3dVwpNJY8KFw4FcdTAwMDLDpsK8IMK9w53Cr8Kzd1bCk8KJY8KFw4NcdTAwMDLDtsO+wq/CmsKyJsKqXHUwMDFiQMKbwqV2w5g9fTbCvSVzwqV3w4hRQlBcdTAwMTM7NsK9XHUwMDFlM8Kww7MlMsKww7MlM8Kwc8KoMsKwcyjCssKnalx1MDAxY3Vadlx1MDAxY3ladsO0bVp2w7RxWnbDtHVadsO0eVp2XFxcImtadlxcXCJtWnZcXFwib1p2XFxcInFadlxcXCJzWnZcXFwidVp2XFxcIndadlxcXCJ5WnZcdTAwMGVrWnZcdTAwMGVtWnZcdTAwMGVvWnZcdTAwMGVxWnZcdTAwMGVzWnZcdTAwMGV1WnZcdTAwMGV3WnZcdTAwMGV5WnZcdTAwMWXCq8KKw4JcdTAwMTIxw6taw7tBwqzCi8OMaS7DrW7DiTLCsMKzwqg7Nj19wqdNQlAkcVx1MDAxNmnDjMK5LsOtbmkzwrDCs8OoPDY9fSdPQlAkdlp2XHUwMDFlw4XCisOCXHUwMDEyZcOrWsO7wqnCrMKLwqwxwqzCi8KsOcKswovCrEHCrMKLwqxJwqzCi8KsUcKswovCrFnCrMKLwqxhwqzCi8KsacKswovCrHHCrMKLwqx5wqzCi8KswoHCrMKLwqzCicK4TiBewqHCt1x1MDAwNk3Dm8Ohw6PCkXNEPMKlw4Z1w4XDpm3CjMOZwp1cdTAwMTlQwqPCulx1MDAwMlx1MDAxZMKGXFxickhPIGjDgcKhfDBzwqnCqlVFU8ONw47DqcOqwr/Dh1x1MDAxYWrDvMOJPUrCom3Cok5cdTAwMTPCmcKaw6ZNZsK+XHUwMDFlcWJcXGI8SHUkVUZcdTAwMTnCszZOJ0N4YG5wwrwoOFFlTG1zwqnCssK9V8K7w5vDjsOpw67Ds8OIXHUwMDEywqrDjmnDr1x1MDAxMzDDuztzwqnCtcO9R8OMbcK8KELDkcKFbsOxTidfeCHCsjh0JMKdw4bCmDxHwr9cdTAwMWUhYlx1MDAwN09kVlx1MDAxMznCnMOkd8KewobDvMKJXHUwMDBlwp7DicKKasO8w4lcdTAwMGXDmmtaTFx1MDAxM8KZwpxcdTAwMDJLQsK8XHUwMDFlcWPCljvCtnMkw5VGIDIwTyfCg8OLw47CqcO1wovCv8KKQMKAcsKtw6rCui89SsOtfMKvb8OzwpzDqsKdw78wa0zDjcOqw4HDnzHDpsKDXFxcXMO+alx1MDAxYV1XK3nCvVA/KsKIw413PUphw5zDjkzDqj1Nwp4qwqZ4NMK+MVxcXCLDocKAwqrCsXXDgTQwwpnDv2BcdTAwMWHCgVx1MDAwM3zCjcOrw73Cny7CpsKHwrQ6wo/CvzNIw45VOsKfX0bCpnRlw6vDlcO+wrnCtC/CqcO+M1x1MDAxYXLDu8OawpxyLMKiwqvChMKKLzzCiVx1MDAxYTXDlzHDucK6Q8OWMHwvKMOKw5E6w6VfMiZndcOrPU3DjS9VwrE+wqrDiVx1MDAxMWDDlmpcXFxcMGZpMcOrIcOtwq1/cMO8w6txwp47woDCsDIrw5l7TVxcXCLCt1x1MDAxNsKKXHUwMDBmwrpkXHUwMDFhQMOnwq8/TcKuPUo3woQtKEpNwoLCj8OORsOmasK5worDn8K8XHUwMDFiPUpBwpQww7nCuj5cdTAwMGYsSMOHbz1Kw717wrEnw5HDkMKqUVx1MDAxMTAubsK3MFxcdMO4aFx1MDAxYVx1MDAxOMOye8KYPUrCocKDMMOIQcKXVDrDplLChcOqwrnCjHdvwqwxXHUwMDEwOlxcXCLCilxcXCLDmnopTlx1MDAxYcO/wobCrFx1MDAwZlxcXCLCscKsIcKQZVxcXCLCmVx1MDAxNsKLYyjCgz1Kw5/CozFbwpA2wqLCj0TDqlnCjTbDu8KPPz1KwrfCo3ZcdTAwMWbDkVDCqsKpwrAvOcK3XsOWwrzCvC7CiMK7w73Dmlx1MDAwNMK0aVxcXCJzYMKsw5HDrizCgGjDgzgowrtcdTAwMTE6w5FcdTAwMTA4KMK5XHUwMDBmPUorw7vCq398wrTDqlx1MDAxOcKbMcKAwoXCsyx5w7LCi1x1MDAxYcKvMsKKb8K/Nlx1MDAxYcODwobCsMK/woPCsMKrQcKPMVxcXCJ7RsKKwr/Cvlx1MDAwMz1KZ8KjOcOVw6JKXHUwMDFhwrjDli8pwrIzw5bDkkwsw5nDsj19woLDg084Jk5CZk/Dmj4rf2HCnVDCg8K8LcOiXHUwMDE0NiN6XHUwMDBmwqzCqcOiXHUwMDFhw4k5YcKSwqvChmZWw5Vsw6zCqcOQXHUwMDA3w44vwp98w6TCmnlawpLCrizCksKrMVx1MDAxMmtEXHUwMDA2wpk1w4RbQMKebTBOYzrCjsODNsOcw58uXHUwMDEzcMKqwqZfa8OQK0rDv8Kmcnk5wo5ELHxcdTAwMGbCq05na8OAXHUwMDEzSsKFZcK6XHUwMDE4YsK6w5lWcsKNOsOywo1Mw7LDsTROXjDCjsOOL8KcQyzCvFMqw5NcdTAwMTLCrcKGwrDCrMKOXFxcIko3WcK6w7FOwrrCuWdyUkTCjk4xRsKfLcOIw5AqwrnDl8Krw7XCu8OqwpHClz1KwpdKwprDoTp0wo4qw6ZHMFx1MDAwNj8qcTEteV3CqsOxOMOqXHUwMDBmQj1Kw51mwprDr0dcXFwiwrw0wqbDnCt4byvDmUpcXGZBw6JGMcKmUDvCsV3CkVTCosK9T8OUwo5rwrXDs8OkwqwpM8K4woTCp0XDon0zW8Kxwq5lJT1Kw7HChlx1MDAxYcOVXHUwMDE0bMOzw4dcXHbDpFRcdTAwMWHDrEDDosOLKkZaL0jCosOqPX10XHUwMDA2w4A1LUpPX1LDl0fCvsOBMcKPXsKtfMKkbMOUw7R6cMKVUsOPRsK+w7ZCw7RcdTAwMTAwwo/Dv8Kww7wgwrFcdTAwMWN0bVx1MDAxODZKwqnDmMK6wok3w7LDmy1cdTAwMGXCgyojw57CqsOGODB4wp1cXFxcXHUwMDFlQMOZPU3DjcOyb2HCnGPDpsO/eDXCnCBqbk5cdTAwMGV6XHUwMDFjwqHDt8Kxw4xYKkcrXHUwMDA0OMOeK8KSP8O6LMOKY2rDlcKrw4ArVyzDhFEjw6cuwpI9QClcdTAwMDZtwqjDmcK6wobDuSPCqcK8wplcdTAwMDVHwoRcdTAwMWF/VMKCXHUwMDBlwoVcdTAwMGbCgVx1MDAxM8KFXHUwMDEzfcOzKiN+w7DCuMKyR0NlTMKkwo7DqMKHw4hcdTAwMTc+XHUwMDA1wpQnwpQnwq/ClFx1MDAxNT8hXHUwMDFhITTCniFlw7nCnMOVwp/DlUh+PU1bw63Dp1x1MDAwNMOnwoRiT1rCqFx1MDAxMlx1MDAwMsKLwo3DjcKwwrhcdTAwMWTCtVx1MDAxYnlIw4ZcdTAwMTN8wpZlw79Uw6vCi8KudVxcXCLCssKyw5rDm8OtTMKxcC9vwrHCtklkwqjCksOAXHUwMDE3PsO1LFx1MDAxZCxcdTAwMWQjwpQ1w79BwpPClnpcdTAwMDbDtlxcdFFcXHRWw7FUXHUwMDE2XHUwMDBmXHUwMDEzXHUwMDE2wp3DtW1TwqjCs23CvMKwwrg1wrQzwrNDW1jCnH7DllxcdMKiw4nCvsOrw5NcXGLCk1xcYi8tdSXDt8Ocw4LCi8K8wopHXHUwMDE0UsK2SFx1MDAxOcOHwpjDicKLw4FcdTAwMTfDgsKZw4fClcOHwo3Ch8OQwonCl1p9wo3CuMKQw6dcdTAwMWPChMO/MFx1MDAxZlx1MDAxN3TCpSPDsT94w7RcdTAwMTdcdTAwMTDDl1x1MDAwZsKVXHUwMDE3RcOGRz5jwpZ2bsKiwrZcXHRcdTAwMDLCusOSPUpcdTAwMDLCi8Kzw6tcdTAwMTPCiEPCmMKjLcORw6JcdTAwMTHCon7Do8KAXHUwMDA1WF3DhcKNwr7CkjvClMKZwok8XHUwMDE5w4FcdTAwMTNaXHUwMDAzw6DDisKJw5PCk8Obwo/Cu8ODw7LDlsOwwqbDoD1AwozDhz/DhDfCpMOVXHUwMDFlw6HCkl/Dk0h7ZMOswonDkF7ChW/CpUnDhFxcXFzCnsKebsKiXHUwMDE2XHUwMDEyflBoYlxcYsKpwoxycMKaw5jCpVxcdsOqXHUwMDFjwqvCry01XHUwMDA2wpUxw75cdTAwMDPDllvCh8KSwr7CikA0wrXCvcOPanVwQGfDnVx1MDAxMMKEXsOUUC3Dq1x1MDAxY1x1MDAwMsKyw7TCq8KzwoXCl8OtQ8Ocalx1MDAwNlx1MDAxZiXDnsKKw4bCrMK8w5TCsMOAwrjDmMOowqvDi8K7w5vCs8OTw5PDg8Ojw6MvdsOOw5tMw5VjwrPDgcKDwq3Cv8Kfwpw0XHUwMDFjTDx8XHUwMDFkw6LCrT1KwrMzw7PDvsOyw77DvsKawpRcdTAwMWUqQcK5YlxcdFxcdsKowo1sPU3CrMKmbXDCssKpccK2IFx1MDAxZklQKFx1MDAxN8KlPUorV8KCXFxmwp1cdTAwMDLDkm9QwqVcdTAwMWFeXFxiZ8KVwqnDj8Kxwq9cXFxcRENDwpHCnyDCrz1AXHUwMDEyw7XCuDRcXFxcaFx1MDAxY3vDq8KEw49cdTAwMWTDjMKjwqUlVsORwq7DtcOtRsK8XHUwMDE1PzFcdTAwMDfDlsOjZMKqw6nCmMOIwqHCnVx1MDAxZHLCucOGMcKUw63DucOJwpU1YFx1MDAxOMKCZsOOw5vCocOeXHUwMDE5w7hQw5diwq1nw6HCjHhXwoVIwoNaZcKcXHUwMDFlL2HDp3NMwrHDpVx1MDAwM8KFwr5cdTAwMTTCvcO+fsONfV/Cp8K2dGDCuMKpwoJow5/CnsKXw7jDv8K+MyNHwrFWwoBuXHUwMDE3wqLDoMKkXFxiXHUwMDA2XHUwMDFmNWdBw65ZXHUwMDFmaMKTXcKlIMONwoFcdTAwMWRxKVx1MDAwM2ZcdTAwMTdcdTAwMGbDlVx1MDAwZcOEw5tbOFx1MDAxNlx1MDAxMcOqwqHDsVx1MDAwNlxcZkU5woHCv8ORXHUwMDE3w5nCoMKewpTCnMKfKMO+XFxcInjDpcKTw73ComtcdTAwMTDDpC/Cg1jDocKWwpzDqMOfJ8K3XHUwMDA2XHUwMDFkUsKOwoJcdTAwMTjDp1xcdjDCmFx1MDAxMSnDsidkwpfCmMKkPUpcdTAwMDR8wovDq09cdTAwMDV0w5nDmcKVXHUwMDAxJiNDwqImw7LDiVnChXQkw6gpwo7DiCTDqVx1MDAxOcKlw6NcdTAwMTRcdTAwMTTCs2HCuMKXXHUwMDBmScK0wpzClDDDiMO2NMKcPUBFUE1cdTAwMDY/wqM9QMKdwrFcdTAwMDZeRW0twqnCtcOdbMOUKT7DvUAlPUBfXHUwMDFkw77CtVVxwpTDmVxcdMOMwpLDisKnJsOUwrPDsCXCg1x1MDAxZcOQw4nDrcKOw7VcdTAwMDU+PljCh8Onw5JSw6nCjcKjXHUwMDFiw4htwrvCj1x1MDAxMzXDnsKcScO5w6d/XHUwMDFhPUrDu1xcZsK2w7bCvcONUUnCpsOPw4BSXHUwMDFmw5FXLzHDmMOHw4o6XUskwqTDo3t+dCbDrVx1MDAxYU5cdTAwMTEkw7rChcK4w7tLdCzDp8Kqwo1cdTAwMDTCocKnw4DDiVx1MDAwNcOmw71cdTAwMWVrXHUwMDFjw6DDmMKIw4XDt01kwojDl0nDoMKRZ1x1MDAxOMKTwrRpwphfXHUwMDA1XFxmw7rDjMKPw7kgY2New7fChFxcdsOAY8O5woHDv8KTJHnDj3nDn1xcdMOwYcOYNlx1MDAxYXPChcOdUMOvwovCq8KnXHUwMDEzw6VPw5nCtzjCnsK2w4w0wojDvsKDw6XDp8KPMCkkYmLCjcO5w6Fjwq/Do8Opw7DCtsKcXHUwMDEzwqhAJFx1MDAxN8KZwoZcdTAwMTHCs8Kdwplow4DDiUTCmsODwpPDl8KTXHUwMDE5w6Vmw6dcdTAwMTDDslx1MDAxN8KrXHUwMDFmT1x1MDAwMWlgwqVnwrbCiCFcdTAwMTFcdTAwMTjDkTjDr1x1MDAxZcKbw6fCgcOdVEnDtsK1wqFpYVxcXFxcdTAwMDPCj8ODw6zDvkPDnVnCgMOuYMO3w7TCpcOpwpHCgnvDjsK8w7bDssORw5TCkcKxwqPDosO/LsO4wqEyXHUwMDFjw4V/dMOvNH3ChMOww6hcdTAwMWHDg2BQwqbDpsKpwoLDrcKKTVVlXHUwMDE1wrHCkMOHw75cdTAwMDTCqGtwPX3ClidsXHUwMDFmXHUwMDA2wqjCtsOkXHUwMDE1w7zDmcOaSMO/wpFuOcOgwphcdTAwMDHCvMKIwqIjw4DCplx1MDAxYcOxXHUwMDBmJsOow7hyXHUwMDBmXHUwMDE4wp/ClMOUw4vDt8KXw4R1XHUwMDE0QVx1MDAxNcKDw77CtmB8wrjCniTCnMKeXHUwMDAyw5FJXHUwMDFiwoN3w6lcdTAwMTlcdTAwMGXCjiBcdTAwMDZawp/ComB7XFxcIlx1MDAxOMO/M8Ktw7AhLMOjw57DucKxwrhcdTAwMDVcdTAwMDbDi8Ohw6bDpMKjw6HCnFx1MDAxZD1Nw7PClcK8XHUwMDE5ecOkwpTCm1x1MDAxMHtcdTAwMDXDncK9XFxcXGlcdTAwMDHCiVx1MDAwNyloKMKMw6/ChsOQI1xcZsKsw6jDjcOUwrF4Rlx1MDAwMsOkw43CpsO5wrBpwojDpcOewognXHUwMDAzwqhcdTAwMGZcdTAwMGXCu8OXw4/CuXRgw4jCtcKhw5XDuVcpw5/CoMKFw7bCq29Qwqsvw7VcdTAwMWXDn8KHwpBgM8Oow7fDs8KhXHUwMDA2fcKfXHUwMDA0Y8Khw7DDtC/DncOwIcOJZcKWXHUwMDA2w5lHNDtowrFYwrhEXHUwMDFjwpRcXGLCssOZwqlwOMKfwqLDjkLDniRcdTAwMGV/wqnDnVx1MDAxY8KTw4/DtVxcZidvTS3Dk1PDqcKNwoQ0wqUvX8KTbcOfwq1cXFxcQWXDtU7CgmTDiMOHXFxcIsKgwoLDp1x1MDAwNMKuw7LCksOXXHUwMDA0RmfCh1x1MDAxMcOWw6XCsMKtwq7ClcOPw5DDg3jCusK1wrtdPMKmWsKiw5I8w6DCj8ObJcOVPU3DjcKHw7tEX8KQwpDCj8OFXHUwMDAxXHUwMDA2w6BcdTAwMGbDgMKIwoFNd8OJw6lcdTAwMDHCnMK2XFxcIsKjw7XDmMOuw6RcdTAwMWJcdTAwMTbDn8OrwpNXZHA4woE9QHtcdTAwMTlYwpZIw7/DvsOYSMOEwqM9TcKcwrDDvcK9w5zDrHk5woRYw5nCqcKIXHUwMDAySCnCpMKhw5HDr2VcdTAwMDfCucO5aENfwplcdTAwMThcdTAwMDbDqFgjwqXCiMK3d1x1MDAwMcODJMKBw6fDplxcYk3Cn8KWccOzXHUwMDA2w77CncKIwr/ClzkoflxcdMOIwqfCjH9cXGbDnFx1MDAxY8KwPU3CpcOCw6/CtHfCp8O1IcOUXHUwMDE4XHUwMDAzV8ORwr7DpT1NwrPCrcO1w4Bew6HCmUXDnHw4w4bDosKJwoTCmm7CpMOmXHUwMDA1w6staMOpw7LCnMKQw77DrUDDp0VUN8KJXHUwMDAxXHUwMDA3wrbCpWnDj8O7w7bCnHJrwrHCmiNAXHUwMDA2KMKcwpRvw5UlwpIpPUrCg1x1MDAxZMOQwq/Ct0cpXHUwMDEyw4LCp8K/XFx2w7BcXHTCqTxdwoXCl2BAQsKnXHUwMDE5wpPDgsKWVcOWwpc9QMOSOX3Cl8K3OGjCj1LDpcKbw7nDs13DsTzCuUdVQsK9fMOEwoPCpcO6w5wgcSTDtTBFXFx0w6XCpMOVPUBcdTAwMTJ7w6tNLFxcdMKlV8OUJyRcdTAwMTB3w4FcdTAwMWHDs2o5dcOPXHUwMDAxw5PDl8OMw6vChVx1MDAwNMOFw5ZcdTAwMDdgw4TCoClkIMO/wpjChcKCXHUwMDBmwrlcdTAwMWU9SsO7XHUwMDFkwp/ClFHCsMOhYUbDmMOWVWJFRcOGw5PCvcKJXHUwMDFhwqglw6AtwonCtXVcXHRcdTAwMTVcdTAwMWLDoVx1MDAwNH3CoUlvw57CqMOQw4HDoDXCmcKGPMK4fkDCgsOYQ8O+XHUwMDFlw78jwpdcdTAwMTAlwpHCiMOYw77CrMKBwolcdTAwMWYmwoDDucKTWVx1MDAxYTPCl1x1MDAwN8OkwoJcdTAwMDdcdTAwMWMgw7LDhWwjw755w7HCuEfCoVx1MDAwNMOCw4DDgD19w5bCqcKKwplcdTAwMDLCr8KVw5c3wqdcdTAwMTTDtMOfwrhXwovDg8KbcDU0XHUwMDEwOMO5Nlx1MDAxZcKHw7o+w6FcdTAwMDIpXHUwMDE1wqvDkcKVwofDhcKGwonCsFDDtMKiw7hTwpfCqcKhwp3Dq1BhXHUwMDFmw6Rswo1RXHUwMDBmw7XDkWhcdTAwMTNcdTAwMTLDk1x1MDAxN1x1MDAxN8Ozw6LDhFx1MDAxZFx1MDAxY1x1MDAxMsKLwo8lwqNDw5fDmMObcUBcdTAwMDZcdTAwMTfDiUY9QMO8PX0hdVHClsOkw4VcdTAwMWNcdTAwMWV7XHUwMDEzWcOpw7ZcdTAwMDM9QMKNXHUwMDFiw51cdTAwMDd/w73CiMOxKMKGwoHCmsO1K8OVw6TDpVN0MVxcZkjChlkyXHUwMDBlc1x1MDAwM2HCv2jCqMKpw4rCm8O9w7zDvMKwXFxmwrLDrlxcdmUuwp92w7vDjy9JUG/DqXZiflxcdMOdwqlcXGZDw4fDgMONw5zDtETDkXXChVZ3wrhcdTAwMDcnwqNcdTAwMGbDj8KVw5/DlMOPwqfDjsKxwojDvSVBwqE5wqLDpFx1MDAwMcOwN8KlSULDosKcw4txXHUwMDA3w5jDusOYL8KPN8KFdMK/J3w9fUnDgMOeRsOyXHUwMDA3dl/Cl1bCtjXDpsOow6dLeMOkw5fCjcOram/DncOkwoF5VDzDgXI9TcO8asKxwpNnwqnCqCPDqcOew51efsK4Iydyw5HCmFx1MDAwNMOww6VcdTAwMTbCrsOuw4DDtsOjbMKlPU3DmkhcdTAwMDFVVVx1MDAxOMO4w4NAw4rDocKew75cdTAwMWPDqjRcdTAwMWTCi8Ofw5PDhy3DpMOgw4cpXHUwMDEyw5vCgcK1c8K3eMKnw6DDryk9SsOPJF00XHUwMDA0w7vCuVx1MDAxOMOJwr/Cn1x1MDAwNcOQwqHDsMKTwpTDvMObwrh6woZcdTAwMDTDn2DDvXwnPU3DiMOBLF5cdTAwMDUpw7vDjMOSwpPCkcKmw5RJY8OjwrZfwp5cdTAwMTVaeVx1MDAxNsOkXHUwMDFkwqHCjcKxw5bCjcK5w4pcdTAwMTLCtXrCp1x1MDAxZGfClMOTw5jClsO1w4Z1XHUwMDE3N8OTcVxcXCLCmz/CvcKcw7YgwrhcXHRcdTAwMDPDmzdQXHUwMDE5JSHCmMOWwrLCoMKMaWPCl3LCnsKcw7VcdTAwMDPDhVx1MDAxZHJUwpVcdTAwMTnDg2DDh8KAw6tcdTAwMTXDtcO0XHUwMDE0wq3CnsOtw6TCrMO4Vlx1MDAxMsKCJMOLU8O/PUBjw53DjCXDo1x1MDAxNcO8w4NcdTAwMTJcdTAwMTXDhlx1MDAxMkvCnSbDncKAwrBwPU3Di1x1MDAxNMKlw5lYw6XDo8O3w47Dk8OKwozCiVx1MDAxOMKrw75cXFwiN1x1MDAxOVx1MDAxMcOSwoFcdTAwMDJZZ1M9fTsnXHUwMDE1XHUwMDE4fMKpVcOrw4/Cl3vCoS7CpcKRXHUwMDFlw6PDo8KjwoImwpzCpFx1MDAwMcOjXHUwMDE3w7bCtMKoXHUwMDEzwrnCsHBcdTAwMTTDksOBw7nClEFcdTAwMTZIwoFcdTAwMDFcdTAwMWLCknDCmsOBw7TDly3DgXhVPlx1MDAwNn7CpcKKXHUwMDE5wrtOKVxcYsKWwpkjw7x5X1x1MDAxNU3CqG92O0LChFx1MDAxOcOkTiXDp1x1MDAxMFx1MDAwMcOewrrCksOhJCTDpFx1MDAxZcOGw6HCjcOgw485wqDClFxcdMOMXFxcIncxaWA3wrhcdTAwMDJcdTAwMDN9QcKEwptcXGLDkyjDkMOrw5HCk1x1MDAxZcKvw6dcdTAwMTPCo8OEY2NcdTAwMTXDncK/XHUwMDFiw5zCp8OXwoUsPEDCrsOkX8Kxb8OmwoLDhMKjwp3ChnLDvcOPXHUwMDAzw5XDqMOEwp8vw6TCpGLCosKxKFxcXFxcdTAwMTbDglx1MDAxZFx1MDAxM8OEXHUwMDE1d1x1MDAwMz19w4nDvzfDncOpeHXCqVxcYlxcdGnCkWrDmcKLw6fDqVx1MDAwM8ONwpM1wo1gwrDCmMOTd8K2w7LCuTrCjMOjw4NnwoXCmMOXwpVbdVnDjWbCuFx1MDAxOcK4w6XCo1vDmVxcdsK8K8OZbcOgXFx0wpddw63DqcKcP8OpXHUwMDEwXHUwMDA2w7HDiVBmw79cdTAwMWRcXFwiUMOmwpXCkCDDkyB8w6J1PUrDt8OUwoo5w61tdcOkwo7CvcKtw6DCpsO8w5h5J8KfwpDCqcKeeMOzXHUwMDBlJFx1MDAxZUdRw7h2w6VBWcKFWcO6WcK3XHUwMDFhaMKhVlx1MDAxZcK9PUDDtVfDlVnChMKMwoJcdTAwMGY3w4A2XHUwMDAywqPDgcKASMOhwoHDpFx1MDAxOHHDpMK+XFx2w6huI8KkPU3CjcKcXHUwMDE0XHUwMDE5wpnDtFY3PMOywqROw4l/w7BBwrZ+XHUwMDA2wq4jdMKlQVx1MDAxOH7DnsKWXFx0w7RcdTAwMDVif8OOwoppwonDhVxcdMKOwpt3wrrCncKLw4DDu8OZXHUwMDBlw7vCsD81MUXCoTPDicOFwo54wqfDjSnDqFx1MDAwN1x1MDAwM0rDu8KMw4ZcXGLDtSN/w6TDq2VxwpTDnnzDtcO/LcKpJn/Cl0PCkcOXQMKLXHUwMDE2w5LCo8KdXFx0OcOXXHUwMDEyw4rDv2TCuVxcYjHCksKhVsO6LDVcdTAwMTjDlFx1MDAwMcORwrXDhWbDvFHDgMKjIMOCQcKjw4HDuFx1MDAwNVcmwoTCpDg/XHUwMDA2W8KQXHUwMDE4wqjCmUU+YcKAwovCisKlfcKswoVCwqfDvid2PUpoQSnCocK9woZZw4NyOTJcdTAwMDcpw6rCo8OrXHUwMDAyw589QGRcXHTCrcKWRFx1MDAxMijCgMKkd2lXXHUwMDExw6ZcdTAwMTVfPX0uwoTDg3hcdTAwMDVpXHUwMDA2woY9QMKOwrPDr2BcdTAwMTnCksKFw5Evw71cdTAwMTbDoHbCplx1MDAxOcKKwqDDu8O/KMOqZjlRwoFcdTAwMWTCuCjDsVx1MDAxOMO+XHUwMDFmPX3DgMKwY8OIXsKdUjbDhCXDl1x1MDAxMsKEXHUwMDFiw5TCrMK6woXCqCM5QcKxXHUwMDBlw7DDisKvY2FYJ8OIXFxcXFDDr15cdTAwMTkhwrp5w6/DjMOhwphPaTc9TXTCnSHDvnjCp1x1MDAxYsKVwrhSU1DDjFxcZlx1MDAwN1jCi8KDw4DDvsO1XHUwMDFjZ8KZXHUwMDAxwpHDojlTw4PDrlx1MDAxOHt3XHUwMDFkXsOmwrrDqF1cdTAwMTDCnsOQw61Zwq3Dljd8fVDChVx1MDAxN1x1MDAwNMOIZ8KdwphcdTAwMWNuP8OdPX3Ds1/DocKYw5HDusOvdMOTdcK6wobDjMOwXFxmw7Fzw5V8OFFCwofDhEbCmcOkw4EzXHUwMDA3wpRcdTAwMWXClMKiKWFcdTAwMWRxXjBuwrdcdTAwMWXDgMK4R8KkwqbCoVx1MDAxZlrDgVx1MDAxMsK5SzHCqTg0PUDDpyfDscKpwpfCs8Kvw4kgw4bDi2g1d0Ejw7TDjsOYNsOCwqhcdTAwMDPCoTLDicObN8OEw6XDkl3Cmn7Ds8Kre8KhwpjCkcKwd1rCvzfDqWFcdTAwMTHDu1x1MDAxMlxcdsOBXHUwMDA1w41Yw5FUcSRXdMK3YsO1PUpbwpNww6M9fWhcdTAwMTnCl8K2dTNiYyhcdTAwMTNFXHUwMDA3XHUwMDAyJlx1MDAwN0Q9TcOoc8KJSGVcdTAwMWZcdTAwMTHCsFx1MDAxMlxcYlx1MDAxMsOTW8K/KMK7SVx1MDAwZWnDuSVieSlcdTAwMWbCkVxcYktcdTAwMWXCk1x1MDAxZsOBwqtcdTAwMTk3w7DCqcKiw6HCklx1MDAwNcK2YcKEXFxcXD1NXFx0SMObwoMmNsO3SCAmesKvI8O9K2HDpGVgVydcdTAwMWPDvMOsw71cdTAwMTjDryBVaMOZRj1NwoHDplx1MDAxOMOGJ1x1MDAxYXXCu8K3dlx1MDAxMVxcdEXCg8KJdVQ4wqglPUrDsyjDtsKCw4RcdTAwMWNcdTAwMTXCg8Omw7TCucKzwoFcdTAwMTjCpsOpXHUwMDFhwoPDmcKZw47CqcO1XFx0wp3CscOgXHUwMDFmXFxcIlx1MDAxNFx1MDAxMVx1MDAxZVxcYkTCiSRlJsO1w7DDmCVcXFxcw4EowrZcXHTDkFxcYkfCqcO9KcO4wpV7wqfCpSDDlsOZw6FcXGLChFx1MDAwNVxcdFh1WsKVJcKdw59cdTAwMTUkPsK5L2HCqVYzw6hbIMKaw7fDp1EwPX1cdTAwMThwwqjCnMOpwqlcdTAwMDdcdTAwMTlcdTAwMWTCrSpcdTAwMDNBwrl5YcKkaUNEZVx1MDAxMMO7w7/DuMOjOX83WMKIwoTCqMKCXHUwMDE3w5zDm8KJXHUwMDFiw6/Cv8OJPUDCh3rCllx1MDAwNsKbwp/DoMKWXFxiP8OTeCfClV3CjHnDn1x1MDAwNMK0PsO5XHUwMDE2w6jCo1x1MDAxNcOWw5/Cn1x1MDAxZCNcdTAwMWbDnVDDiEXCol8lXHUwMDFlKMKubcORw6bDgGZjXHUwMDAzXHUwMDE2S1xcdFxcZsK9woLDqFx1MDAxNCbDn8O3XHUwMDFmTTDCicKDwqPCm8OjXHUwMDEwwrRcdTAwMDJgwr1fOcO0w7jDmUjCh8Ohw5VcXHbDoH9cXHZcdTAwMDTCjMOjTXUkw6DDsVlXwrY9TVcpXHUwMDFjXHUwMDE3JMOcXHUwMDBlLSFBaVx1MDAwMcK/woReXHUwMDEzwo3DsMKswrnDqCVBZMKZKX/CpcKCw7jDk8KwI0DCgsKnXsOYwotwaVx1MDAwN8OPwr9lOMKuwoDDgyXChHhcXHQmw5vCkcOEw6xfw4HDpCPCs1x1MDAxOcKQw7RXw4low5XClMKaw7bClsO3w5x7XHUwMDFkQMOhw7fDhsOZwplcdTAwMWbCnlx1MDAxOMOEZMO5Y1x1MDAxNcOow5DDl8Ohw4PDmsKRXHUwMDA3w5hHIWBcdTAwMDLDs8O9RXlcXFwiXHUwMDFhw6E2KMKawo1cdTAwMTVow6c9TcOFMUd2XHUwMDA0w57CjMKDw73CmD19w5nCrMKHw7XChDfCocOUT8OHwpPDlMOgwpZcdTAwMDdQZ33DkcKbwoDCo8OvOMOPXHUwMDE1woXDoMOhwqNnZTvDn8O2w5Ujwpt8YkhcdTAwMDFkw4XDp1xcXFzDnVx1MDAxY1xcXCJaw7XDm8OxeMKHScKawo5yI1x1MDAwNcONwplQXHUwMDAyXHUwMDE2w4Umw5/CmSlVI8KPwqU9fcKgwrZcdTAwMDJcdTAwMWQnw63CusKtwqNowpU4wp5JJsKow5LChsOZScKDw6zCvmTDplRcdTAwMTVcXHZnwoUnPX1cdTAwMDMlwrRcXGbCj8KxKVJcdTAwMDVcdTAwMDHDqMKMXHUwMDA3w61cdTAwMGXDuVFdKHhdXHUwMDBlw5nColx1MDAwMcO/Vn/ClcKfwp15XHUwMDExwrrCjiVfVX/CmMODw7ZiXFxcXMKMw7TDoiBIwoPDucKuwr7DnsOBRUdfwqnCk0hYwpvDglTDlWZcdTAwMTZcdTAwMTRcdTAwMDTDjlx1MDAwZsKFPMOIw7jCgCVdUXQ+XHUwMDFjw7Enw6zDt8KPXHUwMDE5RTkof2DCoMKEwqZNwpHDt8K1wqdcdTAwMTFcdTAwMGZcdTAwMTXDnMKhwqAzw5BCTsOPXHUwMDE2VMOiw5jCoFx1MDAxN8O+w5pcXFxcXHUwMDFmWcKrwplcXHQvaMOWwqDDncO3KEDDoyDCpcOtw5ZcdTAwMTnCpsOtwo8oNcKcwrFkw4TDtVx1MDAwM8OZZMK8XHUwMDFiXHUwMDFkw7nCjcKTwrdcXHYrXHUwMDAzw5dcdTAwMTBpXHUwMDFmwqBZw7fDtsO5JcOlXHUwMDEyXHUwMDExXHUwMDBlOsKvJCdgw7FoXHUwMDA2wobCisKEw49cXFxcZMONXHUwMDAxXHUwMDEyXHUwMDBmw4EvV8OdJ8KJw5khw6hhw5Vmw7RwS8OLw43Co8KMXHUwMDFkZj9cdTAwMWZxw4h1b1x1MDAxZVx1MDAwMsKZZFlow5F5XHUwMDFmw5LCpMOKXj1Aw7dhw6jCpGbCqMOgXFxmw4fDvybCqlx1MDAxNFx1MDAwZsOpV8KHwr/DgChIw51qPU0kXcKowq/DvMOGTcOmw5bDq1x1MDAxMMOzwqVxZ8Kmw79cdTAwMWVkwprCoMKYXHUwMDA3IUhfUMKlXFx2w79iwq9YXHUwMDA1YcK1w4DCpsOZW8Knw6jCjsOqw5vCo8Orw7srwrQ7SUlRw7bDhsOIw5MnwpA9SsO5w7zCq2nDhVx1MDAwZsOXwqfCl1DCn2VXX8KEw59sT1FcdTAwMWFcdTAwMDXDgcOZw7srQ8KVwpVcdTAwMTZcdTAwMTnDp8Kjw5/DsMKpwrDCgcK5w7/DsVHDrcKaw4/DnsK/w7zDmcOOb8O1woFcXHbDmMKeXHUwMDA3wrdNw6g/wrJ2wqfDj3bDgGnDgsKmwqR9wqUhworCt1xcdsO1wonDgSlcdTAwMTfDksOnwr5mYcKQJ1TCv0rCl1TDm8OowqLDiT1Aw4nCgFx1MDAwNcKMw4XCh01+eVx1MDAxM1x1MDAwN1RhWHRcXHbCgcOGXHUwMDE2c1x1MDAwN8OabVx1MDAxNE/ClcOiwozCkFxcZj4laMOTw53CpUBnw4ApXHUwMDFkXHUwMDEzw7TDiMKuXHUwMDEzw5TCucKZwqjDuXM5woPDo31cdTAwMTTDmsOrw4jCrcK4wq/Dgzk9QMO8wrTDg8Ocw4PCl3RzXFxcXMKtwrjCn8OPw6nDp1/DtsOiWFx1MDAxM8KkXFxiQi/DkVlLXFxcIj1KXHUwMDE0w49cdTAwMDFcdTAwMGZcXHQpcsKDfcKNwpFOwqbDn8KPJT1AXHUwMDAzfcO5wpJcdTAwMWZcdTAwMTJcdTAwMTHDt8KJwqJ4YcKBPU0oXHUwMDE4IT/CnFc9TcKiU8Kvw5HCvcK5XHUwMDEzwpbCgMK2woXCsTzDkMKJw4XDlSfDpm7DkT7Dk8OpXHUwMDE3w5xcdTAwMDLDhsOhw45cdTAwMTnCnMO1XHUwMDFkw5/Cj1tcdTAwMWQmwoPDv8OZwovDpsKDwpVcdTAwMTHDkMKkw6YjXHUwMDAyw6DCi8Owwqo9TcObXHUwMDFjwrjCtFx1MDAxMVDCp3PDtmHChMKiJX14XHUwMDEywqvDg8OkXHUwMDA1w47DvzVcdTAwMWPDnT1Ac8KTXFxiIcOEwqbCi1x1MDAxOcODwrnDoVx1MDAwZVB+VMOOwqdcXFwiwr8gw47CmsO/wqs5w49Uw63CjcOIUFhCPsOYw79jXHUwMDE3wozCm8Opw6FcdTAwMThcdTAwMDfDuD19w4TDgMKpwppgXHUwMDEzw4J9ZcKNXHUwMDE4w5LCgcO5wolINlXDg8ODwrhYIVx1MDAxYsKQwrBXw6QnwqbDoVx1MDAxNMOvwrJrXHUwMDBmwoTCiMOfJsKsw6Nww5PCt01NN8K4KcOofMOCw6TDlsKsw4BhwqXCuyPCisOSKMORXHUwMDFkw6fCv8O9N0DDpcKmWcOfXHUwMDA2w6DCnFx1MDAxNcK6wpXCiSbDqHDDlsKYwoInXHUwMDE0J8KJwrHDnETCncOJwpNcXFxcw7ZZXHUwMDA3XHUwMDFlwpFVw6FFeVx1MDAxNVx1MDAxOcOGYUvDolx1MDAxM3F7w4klwrRHNSnCicKHw4fCj3bChsKLw43CrsK1w6Vtw6F6XHUwMDA2XHUwMDA3wodAQFVcdTAwMTjDj3pcdTAwMDbCh8K1w6VcdTAwMDVcXGbDr8OLw6LDpcOewoLCm8KRw7tAwrFMwrVlPsORXHUwMDAyL8KYXHUwMDE4w4HDhVx1MDAxOU55XFxcXMKRw7hcdTAwMGUmwqbCqcOnw4MzZ0PDi081LFJsXFx0w4onXHUwMDFkw6DDhXVEUMKUw4x8wqHDoTtcdTAwMTFLwrXDp8OWwpvCgMO1Tms9SsKOOMOhZig9SsOjwqnCoMOkO8O4w4TDl8Kkw5TDrlpcdTAwMWNXXHUwMDFiSipEw4p1PsOXw7XCg8KkUUbDtMODw5zCoGbCtMKpw5nDl1x1MDAxM3PDuMOhwrNTQD1KwpHCvC/Cp8KxXHUwMDEww5NDwo7CiMOuw7nCuMO9ScKBXHUwMDE4bcOiw5NcdTAwMWLCssOKaCjCn2vDrsKRw51PwpRlw7zDllx1MDAwZsKqXFxcIkXDkMK9PX3DssOaQcK7wox4XHUwMDA1XHUwMDEww4vDl8KOOcK0UDxMwoxAwqHDmCHDhUplw5pcXHbDtcK/UybCiMKQw53Dn8O4XFx2Jlx1MDAxY8KdK8KRw41SXHUwMDA2ZcOCTCVoMSrCi1xcdsKmwrbCtTHDuyrDnMKfwr/DmMKDwo1cdTAwMTlbXHUwMDE4w5bCtcK1aVTCg8O+w61cdTAwMDV8XHUwMDE2wqLDsmooeMOjPX3CqcK+RcOgKCRcdTAwMDHCvMOoYlx1MDAwZsKLw6FFYMOpw61cdTAwMGXCnSzChsOqc8Kowq5BXHUwMDAxw5JKwrDDpMKhw5hcXHZ1T1x1MDAxY8OFQjU2woPDjDPDjMOuw758w6p8wppcdTAwMWEvY1x1MDAxMFx1MDAxMMOXf8Okw6zCm2dow73DsEdMw7xIMsKWw6LCs3Zmwp5owr96XHUwMDFkw4I7RGzCjMKuw6bCq3fDiU3CucKewrjDtcK2XHUwMDA0wrTCuCNlYsO6wpQ/XHUwMDFjw6DCpTJRw53DosKJVVjCsMOgKsKgw4nCk2nCg8KGw4I9TUc3wrExVMK0ennDomdZQsKlwqpsXHUwMDBmwoVIXcKLwo7DvsOuZCZ7ecOvwoHDk0NxfMO0wqPCq0RCXWJ0wp11w6NJPU0oMybCj8O4XHUwMDFkw7ZrM37Co8KFwoM9QMOmwrQ9SsOkw4nCtsKLYcKPwrLDu1xcZsO+cMKrwpI3w61Twr3Dqlx1MDAxNMO2wp7DsHo5PU3CvMKfwoFQwqBjPU3DvcKgQMKxw4Asw5bDkCrCgMO1PUBcXHbDgMOYVMKGXHUwMDE4wrzChkdcdTAwMWPCksKzXHUwMDA2w5Qtw49nazPCl8O4UMKUN1x1MDAxOUzCjifCmMKkMVx1MDAxZsKyw7hrc8Kfw7jChsKDTMKEwppjw55cXGbDmsOOfsKCw5wgdUd/w6XDimhGLsKbw7TCnnrCg8Kcwp5cXFxcwpPDosKMwqPCo2MqcsOVw5zDrVx1MDAwZlrDknYnwofCuMOIXFx2azXDiFx1MDAxNMOtwrYzVcOQXFxcIsKyw6rDtm5PwqE9QHxcXFwiw4bCr1x1MDAxMFx1MDAwNEzClcOhw7ZcdTAwMDLDjyzChcKBw4VEw7DDpcO6f8KVwqx7w4NIwoJqwqk7w4Aow5lcdTAwMDLDrUxcdTAwMDdnXHUwMDEyXFx2Mlx1MDAxMsK0ecOEIMO4eS1cdTAwMWbCmVxcdMKsXHUwMDA3wqfCtnwpwqvCkMKZKGBcdTAwMDPChk7DrFx1MDAxMFx1MDAxMcKNXHUwMDBlw5RbwpNcXFxcYVs0wobDu8Opw5pfMmjCkCM0McKNaXzDt8O1w4XCgcOGLcKfwpLDiMOgX8KXV8K/anfChTY0wrlcdTAwMDEyw7zCvMKIw7BcdTAwMWNCcTpcdTAwMDfCg8OtVMO/RsOBw5rCpMO9woXCklHCtcOnwpZcdTAwMTPDvzDClXtcdTAwMTEtw6TCmcOCw43Ctz1Nw654w5kvw6jCn8OLw5/DiMKJwobCjlx1MDAxYiPCmMOywrPDk1x1MDAwMsKBXHUwMDE4Z8OkwpZcXHRlw57DjmthXHUwMDA1XHUwMDFlwoLCksKJXHUwMDE2cVx1MDAwNcKsworCjMK5MsOtw4fDtT19w6XClD1NOcKIw5hRXHUwMDBlXHUwMDE4w6zCl8Kyc0JGcFx1MDAxM8K8w6/DrcObY3bDv8Orw53DjMOLwrBWXHUwMDFmXHUwMDE1wqDDkF7CnMKIw4fDj1ZcdTAwMTjCgcOXWsOoNMKmXHUwMDEwwrgyw6M9TUBVVsKPPUDDkyxrwrvDoFxcdMOhbMKSw5I+w6lowoBdwpBhw79MdcOxwrRiw7I5w4A5XHUwMDE0PMO9XHUwMDBmw5TCqFx1MDAwZSxcdTAwMDHCgcKhRsKgXHUwMDE4WnLDgDRBfD/Do2DCjMO/djLCg1x1MDAxMMKxf8KgJ8O6w41SwpPDsFx1MDAxMcKzPUBjwpNow7pWwpDCvSojXHUwMDEwfVXCmj1NSyfDr8O2YMOmKcKqXFxcXMKewro/fMOdZz19ScKsw6p0w5zCq8KWO095PUDCsMOuwrbCpSPChsKLw5DDhsKQa8KqwrJfK8OlRn7CtMK/wr48wqZcdTAwMTJcdTAwMWHCqD19dEXDl8KaXHUwMDFmKsOtwp4hw4c2wq9UUMO7w4jDnznCi2rCqlZMwrnChV1VwpTDmDRcdTAwMTHCksKbXXbClHY+wrfDnMO1wrc6PX1cXFxcw4TCjl9CNFx1MDAwMWfDk0nChcOmNsOywrIrSCwgw6PCtCzDrsOTJ1rCkkJcXFwiPUA7XHUwMDFlw7tGwrbDv8OvwplKwrxcdTAwMTPDmH/DnMK9cMKLXHUwMDBmdsKxw7o8wo3CmVx1MDAwM1x1MDAwNMOAVT1AIMO9d1x1MDAwMlBjVcOdwoDDosOxw5vDlCNZXHUwMDBmw6MzQMKrPD1AJVx1MDAwNXR+w6h0XHUwMDA0YcORNkTCn8OxwpLDuztQw6DCq1x1MDAwN0HCp1Nuw4gvw4NcdTAwMTTCoDtIw4/ClVHDmHohOcOwwqwpw7JHw6hcdTAwMTbDjMOFN8OFXHUwMDAzwoIww4ZcdTAwMWYkXHUwMDE1XFxcIkFkPU1cdTAwMDTDrk9cdTAwMTbCl1x1MDAxOcKQXHUwMDBmZMKzwqvDp1x1MDAxOVx1MDAxM8OsYj9cXHbCr8K6w6V2wqJrw4lwUlxcXFxAVcODw5HDsMOtUVx1MDAxMk89QMKkwrbDkMKPwpDChMOfXHUwMDAzXHUwMDEww7lcdTAwMGZcXHbCqMO1OMOCw5jDqHtHR8KEJH3Du8OJYj5qwpVPw5/DrW4owoXCg1xcXCLDuMKqw4jDjUjCrsOkMUjDn1x1MDAwNVx1MDAxNsO7XHUwMDEzaVHDhsO3wql+XHUwMDEzwrNOw5N6aMOwwojDicOBcDxcXFwicsKrXHUwMDE0XFxcIsOmXTjCq8KCwo0uXHUwMDE1XHUwMDFmOsKTd0ArwpokwoxZIMKPIcKYNcKAasOxSFx1MDAxNMOeRcOZw70xSEJcdTAwMWVcdTAwMTl5wrN+wqJNKkhWwpVmw6PDoMKTJjtcdTAwMThcdTAwMDLClsORw4lXU1x1MDAxMWvCh2DCjDXDt1x1MDAxMMOAZ1x1MDAxNnhcdTAwMDJRXFxcXGgmQVx1MDAwZSTClWnDnsO+wrHDlFFPwpXCrXXCj8O9w7xcXFwiSsOKcFx1MDAwZmvDlcOUw6tzw4bCqsO4wo/Cq8O2w6NRXHUwMDEywozDt1x1MDAwM8KaYVx1MDAwN8KAXHUwMDA3w4vDq8KYJFx1MDAxZsKfSMK2bcKGT8KtNcO8eX/ClylwecKbanxIw4ZtwqRcdTAwMGXDpcOHXHUwMDAyw6lmY8OrNcOWNcK7XFxmw4DCo0s9QMKJQsOoXFxmXHUwMDE0w5XCkDV0M8Oew5fDrcKtXHUwMDE0SsKOw63Dr1x1MDAxZsOGwp8/QzbCrlx1MDAxNcOawp9wUcK2XHUwMDBmwqVhwpRcXHYzw4HCiMKDw6HCnSPDtcKrwrV7LVLCjcKRMXjCh8K1w5HDsTzCmlVTdHYnw45cdTAwMDRcdTAwMTTDpVx1MDAxMERcXGJcdTAwMTHDgsKYL1x1MDAxZsKYXFxiPUrDnHFcdTAwMDVcdTAwMWTCulrDjcOPRsKAwqQzTndERVxcZj94ZsK4wox7S8OwwpvCvDfDhXBcdTAwMTY7cUp8wq3DiF7ClMOQwp5nwohcdTAwMTJOwq7DnsKUbkbCj8KQwoU6KFxcdmvCt8OAw5DCt8K7M8ONTsKJXHUwMDAyX8KUwrttWcOrXHUwMDAzw41JL8O/XHUwMDFmMmHDsmLCg1x1MDAxZcOJbWXCn8OMw4zDg1x1MDAwM8Oow4LDjMOJXHUwMDFiUUjCn8OMw7lOXFxcXMOLNcKnXHUwMDEwOcO9wrHDqMOYw6dzVEI9TcKXXHUwMDFjwpDCscOQw5JOei/Dhlx1MDAwZVXCmFxcdsONZcKMZMOTJMK6eMK7w7jDtMOsScOPw73Cu8KNbyHCs29cXHbDvn3DtXtcdTAwMTJtScOpw6PClsObw65cdTAwMTVoXHUwMDA0wo42YD1Nw4/DiD7CjjDDjsOwwpjDrsKeUMKtwpVWw5DDuVx1MDAxZMK/UcOmwqlcdTAwMWHDl8OtX8K9XHUwMDA3woAmN2HDhMOkw5lcdTAwMWLDvGPDgiVuw58nw45KXFx0ccKxw6tfwrZcdTAwMWYgXHUwMDExwrTDpXpcdTAwMTnCvivDo8OYdEJQw5/CiF9rw49cdTAwMDZWKVx1MDAxZcKxccOUYF3ChD1NaHV2eS/CqWE3wpjCkcKnXHUwMDBmVsOLwqvDo3dcXGI9TXvChcK0PlJowp3DsWlJdlx1MDAxZMOJXHUwMDFhwpp0w6PDu1xcXCLDpltBwq7DjlN9wqxNbz/CpkVHflx1MDAwZcODwonCn8KCREzDosOawpbCsFx1MDAwZsKLT8KoITwyZyfCpsKxw6HCs8ORNCDDm8O7V8OaXHUwMDAywrrCicK8w7XCvmjCgWdhwo/DrDDChcOrw4vDqyPCo8O9wqTCqXtBXHUwMDAzZsK3w6zDtcKkw7Jxw7BcXHTCicOOw5tcdTAwMDdjLcOsIV0kJTbDq8OEwojDlsKkw7NwKcKAfcONw7jCrmrCnn09QMKpdzHCkFx1MDAwNsKBcFx1MDAwMVx1MDAxOVx1MDAxZX/ChUHDoT/CssOhwp3CqUHCtsKBwpLDqy/DjWBuwrhjwqFcdTAwMGXDtyhVwoXDojVUJsOlw6BJw7DCusOBMsKwwpNPw7RcdTAwMWN2X3h6wrfCsMO2OT1NXHUwMDAxw7lqw5suwqXDvFPDr1FcdTAwMTQuQsK5w5Zmw749QGpQwrVcdTAwMDEsdCMpwppowrTCojjCo3XDo8OWQ8K4w4PDjlMow5rDmcO/wobCgMOaLj7Cq8Ouw7rCg14jU2hcdTAwMTTCijVoPUpwXHUwMDBlwrHCvFx1MDAwZsOgwopKw7lRw6NMw4bDsMK7w7rDu8K5w4Vbw6jDg2M8XHUwMDFiw6JzwpDCgVx1MDAwM1rCjHrCnE/DjmDDoXk9SkzCv1x1MDAwMi1cdTAwMWPClC88ST19XFxiXFxmNsOqZEvCoMOaw4vDisOPwppcdTAwMTHCs8KNwoBYUsO9YMOTwpRcdTAwMTPCkVrCpsKeNS7Do8KBwqEzwqLCr1fDv1x1MDAwM2fCiDdFw7hIwpPCmMKKXHUwMDFmw5xIw73Dt0FcXHREwobDmMKGw6JJYcO4PUDDvsK2WcKvwqnDgUjCp3QxwqDDuS/Dj25SPX1HwrHChMOqw4JRwrxbwr1cdTAwMTBcdTAwMWFcdTAwMWLDo8Ofw4nDosKLPUA4XHUwMDA0wq/Cv8KewrRnw4DDkVx1MDAxNF5cdTAwMTHDjMK9wp5/e03DtMOeXHUwMDE0XFxcXMObYcOjw5rClU/CgWTCu8ORwq/CgsOBw7BcdTAwMDfCqcOCNsOEPUBcdTAwMWZCe1x1MDAxMsKlXHUwMDFkwqYqbiZMaGUnw63Dp8OBIMKiwoLDpMKgXFxiXHUwMDAxworDo1x1MDAwM8OAwrfDp8OBPkTCkcOXwoLCm8KXwovCgFx1MDAxNVx1MDAxOXJcdTAwMWM3w7PDgVHDtsOrPUrCkjrDij1AKVFxw5QnXHUwMDE5wrh2XHUwMDFjw6hcXFxcNsKwXUlkwrd/XHUwMDExwqVnw7PDq8Ohw5gwX1x1MDAwNn/DjsKdLMOLMjDDljlcdTAwMWXCnn5dWX04wpnCmlZpU314woDCkcKdX1xcdChkwpnDuTzCgsOJQ8KbJcKPw7HCg8O8wq/CisOgw6VcdTAwMTdXXHUwMDFhXHUwMDBmRMO5wojDosOZTFx1MDAxZsKSw5DDoVXDicKKw4pyOMOoJDbCq1x1MDAxOVdcdTAwMDRew5fDicKYXHUwMDEwXHUwMDEyw59cdTAwMWQgwpw4d1x1MDAwM1tcdTAwMDdJwrlRwo9aw4nDklx1MDAwNlx1MDAxYlRVwo91ZnPCsEIyJzbCqsOzQlfDiVbDnnPDpsKyw5bDpcKvcMOywodZw6PDqlvCgWPDjkfDmsKbMVx1MDAxZlx1MDAwZVx1MDAwNsK5wo5cdTAwMWbCj2XDjUgswpDCpjPDscOKwrbDvE7DgMKFUCbDjVx1MDAwNibCocK2XHUwMDE4w449TVtcdTAwMTHDl8Otw7NfwrLCpmLCvFx1MDAwZVx1MDAxMWZ+XHUwMDE4XFxmasOlwqtcdTAwMTBJw7HDkMOfSsKhwoo6wr1cdTAwMThcdTAwMTZcdTAwMDLDpXdgwozCvsKSOVx1MDAxZjcudz1AXWVCw41cdTAwMTjDg8OFXHUwMDA0w7Mgw4RRXHUwMDE2wpAyKsKQXHUwMDFjw4VAw5HDj8KTTsO/RcOYKy5pMWcmw6Emw6LCnsO/XHUwMDA3w6fDpi1Tw7vCgcOnXHUwMDExw5BlP8KvdsO9wqLCpCkkw6d7wqlcdTAwMTZcdTAwMDdwTlx1MDAwN07DlljCt1rDusOMWMKsw4bDjsKyTlx1MDAxYsOVw7rDgk89QCPCvcKEw6NCXHUwMDE4wrnCpsOawqxcdTAwMTTCoHIhw6F1woPDvsOyZsKvL8KPwqJcdTAwMTlvwoPCgMK4aMKjT8OWw4YuwrV3wq55wo3Du8KKKMKdXHUwMDEwYMOZPGvChMO7YsKmXHUwMDA1MsKBWlx1MDAwNcKKWGnDosOuK8KpwotcXFxcXsOdwq/DgMK9w7tcdTAwMTVcdTAwMDQ1XHUwMDFkw4VOczPChMKOw4HCnWRQYsOzaMKOw6p5wrvCtVx1MDAxNsK4JVx1MDAxOMKZW8OGwo1cdTAwMWJcXGIqwoTDj1x1MDAxOMOGw7NHXFxiXHUwMDEwPMKWw7nCj8Otw7FCw4hwwqBdXHUwMDE0PzVwwqrCoyBHTFx1MDAxMFx1MDAxYcKhwpzDscKOYMK4wqFnwrDDmsOjbMKfwqJtw6DCuX3CjVLCmcKlwrRcdTAwMWXDnynCvMK+bsOWw6PDiDjDjFxcYsOZw57DqHnCtMOmw47CkcKgw45AwrrDjsOdw6MvwrMxXHUwMDE5XFxcXDrCtlhPRsK8asKYwqnDlEfCsFx1MDAxOTZpw4bDvsKwwrfCqcK8J8OeVHQkwrh2w7olPn3CtyPDo0DCjcOww4hjUsKyw6xcdTAwMTbCosK8w69PVlx1MDAwNlxcXCItw7rDmWt9wr1cXHZob8KHK2nChlx1MDAxMsOnw7ghPUpcdTAwMWbDksOMwq1JJ8Orw7PCpSTCszlHYsKjfEnDpMKUwoPDmj1NRlx1MDAxM8KHV8K2w65SXHUwMDEzw7/CmMOAwphPXFxmw41Fw7UyXHUwMDFkccOEw4dYbcOqw61cdTAwMTJJXVx1MDAxY8KewrJoQSzDuVx1MDAwZXHDl1x1MDAwNGfChlxcZsKXw5fCsjHDk8K+wrddw4VcdTAwMWZ7ccOZXHUwMDE3XHUwMDE0wqPCksKnQMK3w5dcdTAwMDTCgMK7LMOVw4R+w7DDncObw7TDslxcZlZIf1x1MDAwZcKyWcOgwp7ChjTDtFdxacKlwqVAwozCmsOhXHUwMDBlwoMoU0dAJ8OEXHUwMDEzXkpIb8OCwqp7wpNbw4DDvMK4wr/DmzpcdTAwMDXCjsKsw4bDncO0J8Orwop7w59ww5NIwpvDt0FcdTAwMWbCs8OtPUDDosO+WVx1MDAxNko2WF9cXFwiw4Fsw4s6J8OhSVx1MDAxNCjDqcKHX8KzLnfCq8K0w5jDicOsw6hBdEnCmUZCw7DCoWRkXHUwMDA3XHUwMDE2wrTCtMK1XFx2RsOVw711XHUwMDExwqfCj8OLwrw3wrzCnGvDlsKlwrLDg8O1d8KIdsK1MMKSw5/Cplx1MDAxZMOxw6TDlEjDpsOMXHUwMDE1w5bDs8OdXHUwMDFlWVx1MDAxOTXDmlx1MDAxOSNkw4tcdTAwMTHCj3fDlMKqVcOMwpTCl8KVLlx1MDAxYsKwXHUwMDExN8K/wpPDhcO6w7rDiHjCpcOJKFx1MDAxNVxcdmbDjMOPw6ZcdTAwMTdRwrbDpMKHw6M/ZsOPXHUwMDAyRMONwqvClMKuWcOgW8KlciFBw5fDk1x1MDAwMjDDp3BcdTAwMWTCpkhSbWzDtsOlw4XCqldcdTAwMGbDkFxcZnZmXHUwMDEww5DCnXPCvTojICTCjsOUJ8KxwrnDnsKbLsK8dFx1MDAxZMOJXHUwMDA3w5lSw6pcdTAwMTBcdTAwMDPCmMKnL8KFaHhcdTAwMWZbdsOqasOIXFx0UVx1MDAxYsKkw4vDo1TChMKVXFxcXEogUE5cdTAwMTEyw4/Cg8K9X8Oswp7Dk8KWU8KCwrdVwoZvNcOPwq1WYVx1MDAwNMOgw5Nww5Qvw4s8I8KCw4HDjsKdIcOMw7p2XHUwMDFjwqcxwobDtn5pWVx1MDAxN8Kjw6/DiMKGPlx1MDAwN1x1MDAxY8KVXHUwMDEzw5bDhMOuXHUwMDE0w4LDq8KowpLCscOpWsKlN8Oqw7Bpw7zCtMKZXTfDsMOaw4zDjE9cdTAwMDfDlVx1MDAxZlx1MDAwMWLCuVx1MDAwMcKew6/DnHdcdTAwMDXCp8OMQGbCrMKuw5bDl1x1MDAwNMKVw7tXXHUwMDBlecOIeHzCtW7CvcOoXHUwMDAzJMKLwrjDp8OeXHUwMDFmw7EkRzjDnmPCrlx1MDAwZsKYw57DrFo9SsKcXHUwMDFlXHUwMDFlLzZ1wobDo1x1MDAxM8KuwrPCi8OdZ8Kpwogtw47DrcOww6vCkMK1MV88XHUwMDBmwpPDgMKIwpfDjsKOw6g0w7BcdTAwMDVcdTAwMWTDtMKqXsK9UsOjcTrDjlvDhmfDgndKw4TDv1x1MDAwZsOiXHUwMDE2wrLChFx1MDAxM8Otwp5cdTAwMTPDj1xcdlPChMKmc8KTw741QsOZSsKVdsOgw7DDscOvw7VHwpTCusKjw5Z8V1x1MDAwZcKgZMKnw4x6wp1eYsKyJy8pPU3CqsKVXHUwMDAxw4lZw5vDi23DgsOBw7HCj1fDv8OIW8O+X8KSd8KlwqTCq1ZcdTAwMThIZsONw5hhM1x1MDAxMFx1MDAxNz4wXHUwMDE3wr3ChC5qwoXDi8KcTFx1MDAxOcKFXHUwMDFiw5/CmF/CgWzDnlogWXXDucOyQ3rDtCY+OMOOw6jDscO1wrvDpMKQSMORwp/CqHpcdTAwMTjCr3zCgMObW2fDjMOldsO9fcO9wrzCiMKuJMK0T8KCTm5TOGpcdTAwMGXDj8K3PyxdwqQrw5V5PsKhLn4rw6NcXGbCr8KVRztIw4rDl8KDwrwsPlxcZsKYwoLDn8KPclx1MDAxYl49Sld8w4ZcdTAwMTbDgVfCvT1KRHPCqEl5woVcdTAwMTXDsMOMW8K4XHUwMDA3WMOgwo90XFxmXHUwMDAyw5o3Kj1NRcKwO8OawrjCpcOff33DpVx1MDAxZMO6wotORmnDiMOuwpTDpDZzw5XCoVxcdsOGI1xcZsO9woVlacO5acKfw5XCvmvDvUw9TVxcXFzDssKDw7N3VVxcdDHCp8KLM8Ocw5JWw5hHIcKowpRcXFxcw7tcdTAwMDHDiH/Dl1x1MDAwNcOUwonDn8OLw747w6PDt8KKwq12w5hcXGbDi8KPwrZGw5dcdTAwMDHDtH3DhEzCicOHW1x1MDAxOMO9wpDDq8OmwrxcdTAwMTjCvcOAPsOzw6wjOVx1MDAwNkDCpHbDrmbDk1x1MDAwMVx1MDAxNyDDrcKzMGvCmnTCuTVnfMOJN8K6w71cdTAwMTk9Sl9cdTAwMTkzwqHDncOyw4VFdH/Cjz7CtsKNICrDrMOlwpLCocKBXHUwMDA2XHUwMDBmw6PCpsOMw7ktKUVfw6gvwovCtDPCgMOJOUtTw7vCp8KTw6RUwpDDp8OaZlxcdsKWbcKlw57DucOVPUprwpHDp2rDlMOcwplkXHUwMDA3fMOJw6w3c8OjaMOoXHUwMDFiw6bCt8O2w41WY8K+QsOhwo3CiXnDmD7CvMOwXVxcdFx1MDAwM8K7XFx2OWxSZsO9WcKmw6zCssKyw5hEw77CisOjdFx1MDAxMcOCSnxpw5wxT8KYbTDDny7Cl8OcOjdMR3HCrVx1MDAxM8ODwpjDuFx1MDAxMMORY8KDZz1NwpZcdTAwMGZdd8K0fS8jV8Ocw5xlw5TDiMKFWMO5wpPDgHsuwpjCp8O+MFx1MDAwMl5cXGLDisOJwolcdTAwMTTDksOPKsOEw7xcdTAwMGVEOcOfa8OiPUDCicOpX8KawrZcdTAwMDfDklhNe8OJwrBcXHZMY8O8w7hZJ1x1MDAxYzdcdTAwMTU9SnR6WnjCrsOuwoJcdTAwMWJUwqZcXFwiwrs0SsOGwp7Dp8OFbMOJw7jCj8KIw6ZpXHUwMDA1cMO+VcKVYMKjwpg9QFx1MDAxNE5PwpdcXFwiXFxiw4RcdTAwMTDCkyPDqMOBOD1Nw4BcdTAwMTdcdTAwMTLDgcOAw7VswphTQsO5McKPfMK7XHUwMDFhamLDpsKJw7hswqQmQkTCt8OVXHUwMDA2JFx1MDAwNSfCo8Knw5gsR8KNw7HDgVx1MDAwNMKqT1k+KHXDicOvwpjDtcOlwqswOWbCjcOIJMKzwoglw63CnMK0SsKEw6HCqi/DkcOpwpXCrWnCg2rCg8KFXFxcXC/CuMKWc8OadsOxY8Ovf8O+PHLCgcKIw57ChW7DnylOa8O0w7bDoMKiw4vDkcKNXFxcXHXDs8KWwq9iw5zDm3nCvVxcZsK2w4huXHUwMDAzwop0w7Nlw5VcdTAwMWLCgsOkw4tcdTAwMGXCgHfCqMKVw7HDksKeOD1APX1cdTAwMTlcdTAwMGZ3w5jDr1pEwqjDqWFRw4XDlWTCn8KrTHdcXGLCpMKDwrFLPUpcdTAwMTlHdMOJMsOgw5pjw5l7QMK5X8O/XFxiwpnDh3cpPHrCucK1w73Dl13CuzTDqlx1MDAxMMKBU8KyecO1XHUwMDFhXHUwMDExXHUwMDEyXHUwMDE3TcOEwozDrUbCmsKgw4NCw4VnbcOqwptZw73Cm3PDgHRSXHUwMDBmUMOfIU3CgFLDtsKZMSZFXsOiwo3CqSnDgiVBJV3Dl8O6XHUwMDEyw4fDmcKDQ8KLbMK3wpVdTj19wojCsHHCn8Kow7lIw5VHV8OSXFx0w5LCpitcXGJEw73CisOmw5swaMKodMKbIV09QMKLbcO7bEnDvivDq8OWwr/DrVrChlx1MDAxZMOYwrdAbcOaUzLCpsKUbV/Cg8K3XHUwMDAzV8KWJFx1MDAwNcO6XFxmXFx2wrQ9SsOfw4lFO8KhRFxcXCLDrMK1wqhcdTAwMWZqw5HDg8OawpJcdTAwMGVyMFx1MDAxZCnDpcO4IFxcXFxRXHUwMDFmw5Zpw4UoLixnw5/CiFxcdmrCqFxcYsOYKsO/wpDDq8OMw7vDicOAw6ZcXGLCi8KibUDCpCrCplxcdm/DqcKiKkPClsO7XHUwMDEzwrbCjD1KNVkkI8OZw7nCm8Kgw5pXw7zClUZPw5Q9fVxcXCLDrMK1wqhcdTAwMWJiw7whwqvCilx1MDAwNVx1MDAxYcKBwohcdTAwMWXCqcOowq3ClMOpw6vDjC/DqjrCulx1MDAxNsOnwpBcdTAwMDPDgDXCq1nDplx1MDAxMkHDmThkNsKOwpHDnsKkXHUwMDBmb8OZwp/DrsOoXHUwMDFjKcKdWXnDvMO/w6rDlXjDk8K5MMOoXHUwMDFhwqlcXGLDlsKQT1pcdTAwMTNcdTAwMTTDo8OZJMODQSdcXHRcdTAwMTkpw7PCrcKUw53Ci8O7PUo2w71/KDFcIikpO3ZhciAkLG0sSCxJLHEsUixrPXthOntiOmZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLmNvcyh0KX0sYTpmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5leHAodCl9LGM6ZnVuY3Rpb24odCxmLHYpe3AuY29weVdpdGhpbih0LGYsZit2KX0sZDpmdW5jdGlvbih0KXtwLmxlbmd0aCxmdW5jdGlvbih0KXt0aHJvd1wiT09NXCJ9KCl9fX07V2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoTy53YXNtLGspLnRoZW4oKGZ1bmN0aW9uKHQpe3ZhciBmLHY9dC5pbnN0YW5jZS5leHBvcnRzOyQ9di5nLG09di5oLEg9di5pLEk9di5qLHE9di5rLFI9di5sLHYubSxmPXYuZS5idWZmZXIsbmV3IEludDhBcnJheShmKSxuZXcgSW50MTZBcnJheShmKSxuZXcgSW50MzJBcnJheShmKSxwPW5ldyBVaW50OEFycmF5KGYpLG5ldyBVaW50MTZBcnJheShmKSxuZXcgVWludDMyQXJyYXkoZiksUT1uZXcgRmxvYXQzMkFycmF5KGYpLG5ldyBGbG9hdDY0QXJyYXkoZiksZnVuY3Rpb24odCl7dC5mKCl9KHYpLGcoKX0pKTtjb25zdCBUPW5ldyBQcm9taXNlKCh0PT57Zz10fSkpLFk9KHQsZik9Pntjb25zdCB2PW5ldyBGbG9hdDMyQXJyYXkoZik7bGV0IGI9MDtmb3IoY29uc3QgTSBvZiB0KXYuc2V0KE0sYiksYis9TS5sZW5ndGg7cmV0dXJuIHZ9O2NsYXNzIFp7Y29uc3RydWN0b3IodCxmKXt0aGlzLmNoYW5uZWxEYXRhPXQsdGhpcy5zYW1wbGVzRGVjb2RlZD1mLHRoaXMuc2FtcGxlUmF0ZT00OGUzfX1jbGFzcyBOe2NvbnN0cnVjdG9yKHQpe3RoaXMucmVhZHk9VCx0aGlzLm9uRGVjb2RlPXQub25EZWNvZGUsdGhpcy5vbkRlY29kZUFsbD10Lm9uRGVjb2RlQWxsfXAodCl7Y29uc3QgZj1JKEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCp0KTtyZXR1cm5bZixuZXcgRmxvYXQzMkFycmF5KFEuYnVmZmVyLGYsdCldfWRlY29kZSh0KXtpZighKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSl0aHJvdyBFcnJvcihcIkRhdGEgdG8gZGVjb2RlIG11c3QgYmUgVWludDhBcnJheVwiKTt0aGlzLk98fCh0aGlzLk89SCgpKTtsZXQgZix2LGIsTSxKLHIsZSxhPVtdLG49W10saT0wO3RyeXtjb25zdCBvPTExNTIwO1t2LGJdPXRoaXMucChvKSxbTSxKXT10aGlzLnAoby8yKSxbcixlXT10aGlzLnAoby8yKTtsZXQgcyx1PTY1NTM2LGM9MDtjb25zdCBoPXQuYnl0ZUxlbmd0aDtmb3IoZj1JKHQuQllURVNfUEVSX0VMRU1FTlQqdSk7YzxoOyl7aWYocz1NYXRoLm1pbih1LGgtYykscC5zZXQodC5zdWJhcnJheShjLGMrcyksZiksYys9cywhJCh0aGlzLk8sZixzKSl0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBlbnF1ZXVlIGJ5dGVzIGZvciBkZWNvZGluZy4gIFlvdSBtYXkgYWxzbyBoYXZlIGludmFsaWQgT2dnIE9wdXMgZmlsZS5cIik7bGV0IGI7Zm9yKDsoYj1tKHRoaXMuTyx2LG8sTSxyKSk+MDspe2NvbnN0IHQ9Si5zbGljZSgwLGIpLGY9ZS5zbGljZSgwLGIpO3RoaXMub25EZWNvZGUmJnRoaXMub25EZWNvZGUobmV3IFooW3QsZl0sYikpLHRoaXMub25EZWNvZGVBbGwmJihhLnB1c2godCksbi5wdXNoKGYpLGkrPWIpfWlmKGI8MCl0aHJvdyBFcnJvcihgbGlib3B1c2ZpbGUgJHtifTogJHt7Wy0xXTpcIkEgcmVxdWVzdCBkaWQgbm90IHN1Y2NlZWQuXCIsWy0zXTpcIlRoZXJlIHdhcyBhIGhvbGUgaW4gdGhlIHBhZ2Ugc2VxdWVuY2UgbnVtYmVycyAoZS5nLiwgYSBwYWdlIHdhcyBjb3JydXB0IG9yIG1pc3NpbmcpLlwiLFstMTI4XTpcIkFuIHVuZGVybHlpbmcgcmVhZCwgc2Vlaywgb3IgdGVsbCBvcGVyYXRpb24gZmFpbGVkIHdoZW4gaXQgc2hvdWxkIGhhdmUgc3VjY2VlZGVkLlwiLFstMTI5XTpcIkEgTlVMTCBwb2ludGVyIHdhcyBwYXNzZWQgd2hlcmUgb25lIHdhcyB1bmV4cGVjdGVkLCBvciBhbiBpbnRlcm5hbCBtZW1vcnkgYWxsb2NhdGlvbiBmYWlsZWQsIG9yIGFuIGludGVybmFsIGxpYnJhcnkgZXJyb3Igd2FzIGVuY291bnRlcmVkLlwiLFstMTMwXTpcIlRoZSBzdHJlYW0gdXNlZCBhIGZlYXR1cmUgdGhhdCBpcyBub3QgaW1wbGVtZW50ZWQsIHN1Y2ggYXMgYW4gdW5zdXBwb3J0ZWQgY2hhbm5lbCBmYW1pbHkuXCIsWy0xMzFdOlwiT25lIG9yIG1vcmUgcGFyYW1ldGVycyB0byBhIGZ1bmN0aW9uIHdlcmUgaW52YWxpZC5cIixbLTEzMl06J0EgcHVycG9ydGVkIE9nZyBPcHVzIHN0cmVhbSBkaWQgbm90IGJlZ2luIHdpdGggYW4gT2dnIHBhZ2UsIGEgcHVycG9ydGVkIGhlYWRlciBwYWNrZXQgZGlkIG5vdCBzdGFydCB3aXRoIG9uZSBvZiB0aGUgcmVxdWlyZWQgc3RyaW5ncywgXCJPcHVzSGVhZFwiIG9yIFwiT3B1c1RhZ3NcIiwgb3IgYSBsaW5rIGluIGEgY2hhaW5lZCBmaWxlIHdhcyBlbmNvdW50ZXJlZCB0aGF0IGRpZCBub3QgY29udGFpbiBhbnkgbG9naWNhbCBPcHVzIHN0cmVhbXMuJyxbLTEzM106XCJBIHJlcXVpcmVkIGhlYWRlciBwYWNrZXQgd2FzIG5vdCBwcm9wZXJseSBmb3JtYXR0ZWQsIGNvbnRhaW5lZCBpbGxlZ2FsIHZhbHVlcywgb3Igd2FzIG1pc3NpbmcgYWx0b2dldGhlci5cIixbLTEzNF06XCJUaGUgSUQgaGVhZGVyIGNvbnRhaW5lZCBhbiB1bnJlY29nbml6ZWQgdmVyc2lvbiBudW1iZXIuXCIsWy0xMzZdOlwiQW4gYXVkaW8gcGFja2V0IGZhaWxlZCB0byBkZWNvZGUgcHJvcGVybHkuIFRoaXMgaXMgdXN1YWxseSBjYXVzZWQgYnkgYSBtdWx0aXN0cmVhbSBPZ2cgcGFja2V0IHdoZXJlIHRoZSBkdXJhdGlvbnMgb2YgdGhlIGluZGl2aWR1YWwgT3B1cyBwYWNrZXRzIGNvbnRhaW5lZCBpbiBpdCBhcmUgbm90IGFsbCB0aGUgc2FtZS5cIixbLTEzN106XCJXZSBmYWlsZWQgdG8gZmluZCBkYXRhIHdlIGhhZCBzZWVuIGJlZm9yZSwgb3IgdGhlIGJpdHN0cmVhbSBzdHJ1Y3R1cmUgd2FzIHN1ZmZpY2llbnRseSBtYWxmb3JtZWQgdGhhdCBzZWVraW5nIHRvIHRoZSB0YXJnZXQgZGVzdGluYXRpb24gd2FzIGltcG9zc2libGUuXCIsWy0xMzhdOlwiQW4gb3BlcmF0aW9uIHRoYXQgcmVxdWlyZXMgc2Vla2luZyB3YXMgcmVxdWVzdGVkIG9uIGFuIHVuc2Vla2FibGUgc3RyZWFtLlwiLFstMTM5XTpcIlRoZSBmaXJzdCBvciBsYXN0IGdyYW51bGUgcG9zaXRpb24gb2YgYSBsaW5rIGZhaWxlZCBiYXNpYyB2YWxpZGl0eSBjaGVja3MuXCJ9W2JdfHxcIlVua25vd24gRXJyb3JcIn1gKX10aGlzLm9uRGVjb2RlQWxsJiZpJiZ0aGlzLm9uRGVjb2RlQWxsKG5ldyBaKFtZKGEsaSksWShuLGkpXSxpKSl9Y2F0Y2gobyl7dGhyb3cgb31maW5hbGx5e1IoZiksUih2KSxSKE0pLFIocil9fWZyZWUoKXt0aGlzLk8mJnEodGhpcy5PKX19Ty5PZ2dPcHVzRGVjb2Rlcj1OLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWwmJmV4cG9ydHMmJihtb2R1bGUuZXhwb3J0cy5PZ2dPcHVzRGVjb2Rlcj1OKX0oKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9nZy1vcHVzLWRlY29kZXIubWluLmpzLm1hcCIsImNvbnN0IHsgRXZlbnRUYXJnZXQsIGRlZmluZUV2ZW50QXR0cmlidXRlIH0gPSByZXF1aXJlKCdldmVudC10YXJnZXQtc2hpbScpO1xuY29uc3QgeyBkZXRlY3QgfSA9IHJlcXVpcmUoJ2RldGVjdC1icm93c2VyJyk7XG5jb25zdCBicm93c2VyID0gZGV0ZWN0KCk7XG5cbmNvbnN0IEF1ZGlvQ29udGV4dCA9IGdsb2JhbC5BdWRpb0NvbnRleHQgfHwgZ2xvYmFsLndlYmtpdEF1ZGlvQ29udGV4dDtcbmNvbnN0IEJVRkZFUl9TSVpFID0gNDA5NjtcblxuLyoqXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9tZWRpYWNhcHR1cmUtcmVjb3JkLyNtZWRpYXJlY29yZGVyLWFwaVxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcbiAqL1xuY2xhc3MgT3B1c01lZGlhUmVjb3JkZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZW5jb2RlciB3ZWIgd29ya2VyXG4gICAqIEBuYW1lIHdvcmtlckZhY3RvcnlcbiAgICogQGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHt3b3JrZXJ9IEFuIGluc3RhbmNlIG9mIC4vZW5jb2Rlcldvcmtlci5qcyB3ZWIgd29ya2VyLlxuICAgKi9cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtIC0gVGhlIE1lZGlhU3RyZWFtIHRvIGJlIHJlY29yZGVkLiBUaGlzIHdpbGxcbiAgICogICAgICAgICAgYmUgdGhlIHZhbHVlIG9mIHRoZSBzdHJlYW0gYXR0cmlidXRlLlxuICAgKiBAcGFyYW0ge01lZGlhUmVjb3JkZXJPcHRpb25zfSBbb3B0aW9uc10gLSBBIGRpY3Rpb25hcnkgb2Ygb3B0aW9ucyB0byBmb3JcbiAgICogICAgICAgICAgdGhlIFVBIGluc3RydWN0aW5nIGhvdyB0aGUgcmVjb3JkaW5nIHdpbGwgdGFrZSBwYXJ0LlxuICAgKiAgICAgICAgICBvcHRpb25zLm1pbWVUeXBlLCBpZiBwcmVzZW50LCB3aWxsIGJlY29tZSB0aGUgdmFsdWUgb2YgbWltZVR5cGVcbiAgICogICAgICAgICAgYXR0cmlidXRlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3dvcmtlck9wdGlvbnNdIFRoaXMgaXMgYSBOT04tU1RBTkRBUkQgb3B0aW9ucyB0b1xuICAgKiAgICAgICAgICBjb25maWd1cmUgaG93IHRvIGltcG9ydCB0aGUgd2ViIHdvcmtlciAud2FzbSBjb21waWxlZCBiaW5hcmllc1xuICAgKiAgICAgICAgICB1c2VkIGZvciBlbmNvZGluZy5cbiAgICogQHBhcmFtIHt3b3JrZXJGYWN0b3J5fSBbd29ya2VyT3B0aW9ucy5lbmNvZGVyV29ya2VyRmFjdG9yeV0gQSBmYWN0b3J5XG4gICAqICAgICAgICAgIGZ1bmN0aW9uIHRoYXQgY3JlYXRlIGEgd2ViIHdvcmtlciBpbnN0YW5jZSBvZiAuL2VuY29kZXJXb3JrZXIuanNcbiAgICogICAgICAgICAgYW5kIHJldHVybnMgaXQuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBXb3JrZXIoJy4vZW5jb2Rlcldvcmtlci51bWQuanMnKX1cbiAgICogICAgICAgICAgaXMgdXNlZCBieSBkZWZhdWx0LiBUaGlzIGlzIE5PTi1TVEFOREFSRC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt3b3JrZXJPcHRpb25zLk9nZ09wdXNFbmNvZGVyV2FzbVBhdGhdXG4gICAqICAgICAgICAgIFBhdGggb2YgLi9PZ2dPcHVzRW5jb2Rlci53YXNtIHdoaWNoIGlzIHVzZWQgZm9yIE9HRyBPcHVzIGVuY29kaW5nXG4gICAqICAgICAgICAgIGJ5IHRoZSBlbmNvZGVyIHdvcmtlci4gVGhpcyBpcyBOT04tU1RBTkRBUkQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbd29ya2VyT3B0aW9ucy5XZWJNT3B1c0VuY29kZXJXYXNtUGF0aF1cbiAgICogICAgICAgICAgUGF0aCBvZiAuL1dlYk1PcHVzRW5jb2Rlci53YXNtIHdoaWNoIGlzIHVzZWQgZm9yIFdlYk0gT3B1cyBlbmNvZGluZ1xuICAgKiAgICAgICAgICBieSB0aGUgZW5jb2RlciB3b3JrZXIuIFRoaXMgaXMgTk9OLVNUQU5EQVJELlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHN0cmVhbSwgb3B0aW9ucyA9IHt9LCB3b3JrZXJPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IG1pbWVUeXBlLCBhdWRpb0JpdHNQZXJTZWNvbmQsIHZpZGVvQml0c1BlclNlY29uZCwgYml0c1BlclNlY29uZCB9ID0gb3B0aW9uczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIC8vIE5PTi1TVEFOREFSRCBvcHRpb25zXG4gICAgY29uc3QgeyBlbmNvZGVyV29ya2VyRmFjdG9yeSwgT2dnT3B1c0VuY29kZXJXYXNtUGF0aCwgV2ViTU9wdXNFbmNvZGVyV2FzbVBhdGggfSA9IHdvcmtlck9wdGlvbnM7XG5cbiAgICBzdXBlcigpO1xuICAgIC8vIEF0dHJpYnV0ZXMgZm9yIHRoZSBzcGVjaWZpY2F0aW9uIGNvbmZvcm1hbmNlLiBUaGVzZSBoYXZlIHRoZWlyIG93biBnZXR0ZXJzLlxuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9zdGF0ZSA9ICdpbmFjdGl2ZSc7XG4gICAgdGhpcy5fbWltZVR5cGUgPSBtaW1lVHlwZSB8fCAnJztcbiAgICB0aGlzLl9hdWRpb0JpdHNQZXJTZWNvbmQgPSBhdWRpb0JpdHNQZXJTZWNvbmQgfHwgYml0c1BlclNlY29uZDtcbiAgICAvKiogQHR5cGUgeydpbmFjdGl2ZSd8J3JlYWR5VG9Jbml0J3wnZW5jb2RpbmcnfCdjbG9zZWQnfSAqL1xuICAgIHRoaXMud29ya2VyU3RhdGUgPSAnaW5hY3RpdmUnO1xuXG4gICAgLy8gUGFyc2UgTUlNRSBUeXBlXG4gICAgaWYgKCFPcHVzTWVkaWFSZWNvcmRlci5pc1R5cGVTdXBwb3J0ZWQodGhpcy5fbWltZVR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50cywgYSBNSU1FIFR5cGUgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBzd2l0Y2ggKE9wdXNNZWRpYVJlY29yZGVyLl9wYXJzZVR5cGUodGhpcy5fbWltZVR5cGUpLnN1YnR5cGUpIHtcbiAgICAgIGNhc2UgJ3dhdmUnOlxuICAgICAgY2FzZSAnd2F2JzpcbiAgICAgICAgdGhpcy5fbWltZVR5cGUgPSAnYXVkaW8vd2F2ZSc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd3ZWJtJzpcbiAgICAgICAgdGhpcy5fbWltZVR5cGUgPSAnYXVkaW8vd2VibSc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvZ2cnOlxuICAgICAgICB0aGlzLl9taW1lVHlwZSA9ICdhdWRpby9vZ2cnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gU2VsZWN0IGEgdHlwZSBkZXBlbmRpbmcgb24gT1MuXG4gICAgICAgIHN3aXRjaCAoYnJvd3NlciAmJiBicm93c2VyLm5hbWUpIHtcbiAgICAgICAgICBjYXNlICdjaHJvbWUnOlxuICAgICAgICAgICAgdGhpcy5fbWltZVR5cGUgPSAnYXVkaW8vd2VibSc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2ZpcmVmb3gnOlxuICAgICAgICAgICAgdGhpcy5fbWltZVR5cGUgPSAnYXVkaW8vb2dnJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZWRnZSc6XG4gICAgICAgICAgICB0aGlzLl9taW1lVHlwZSA9ICdhdWRpby93ZWJtJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaW9zJzpcbiAgICAgICAgICBjYXNlICdzYWZhcmknOlxuICAgICAgICAgICAgdGhpcy5fbWltZVR5cGUgPSAnYXVkaW8vd2F2ZSc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLl9taW1lVHlwZSA9ICdhdWRpby93ZWJtJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuX21pbWVUeXBlKSB7XG4gICAgICBjYXNlICdhdWRpby93YXZlJzpcbiAgICAgICAgdGhpcy5fd2FzbVBhdGggPSAnJzsgLy8gd2FzbSBpcyBub3QgdXNlZFxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYXVkaW8vd2VibSc6XG4gICAgICAgIHRoaXMuX3dhc21QYXRoID0gV2ViTU9wdXNFbmNvZGVyV2FzbVBhdGggfHwgJyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhdWRpby9vZ2cnOlxuICAgICAgICB0aGlzLl93YXNtUGF0aCA9IE9nZ09wdXNFbmNvZGVyV2FzbVBhdGggfHwgJyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIEVycm9yOiBVbmV4cGVjdGVkIE1JTUUgVHlwZTogJHt0aGlzLl9taW1lVHlwZX1gKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgY3VycmVudCBkaXJlY3RvcnkgZm9yIHdvcmtlclxuICAgIGxldCB3b3JrZXJEaXIgPSAnJztcbiAgICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgICAgd29ya2VyRGlyID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG4gICAgfSBlbHNlIGlmIChzZWxmLmxvY2F0aW9uKSB7XG4gICAgICB3b3JrZXJEaXIgPSBzZWxmLmxvY2F0aW9uLmhyZWY7XG4gICAgfVxuICAgIHdvcmtlckRpciA9IHdvcmtlckRpci5zdWJzdHIoMCwgd29ya2VyRGlyLmxhc3RJbmRleE9mKCcvJykpICtcbiAgICAgICAgICAgICAgICAnL2VuY29kZXJXb3JrZXIudW1kLmpzJztcbiAgICAvLyBJZiB3b3JrZXIgZnVuY3Rpb24gaXMgaW1wb3J0ZWQgdmlhIDxzY3JpcHQ+IHRhZywgbWFrZSBpdCBibG9iIHRvIGdldCBVUkwuXG4gICAgaWYgKHR5cGVvZiBPcHVzTWVkaWFSZWNvcmRlci5lbmNvZGVyV29ya2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrZXJEaXIgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtgKCR7T3B1c01lZGlhUmVjb3JkZXIuZW5jb2Rlcldvcmtlcn0pKClgXSkpO1xuICAgIH1cblxuICAgIC8vIFNwYXduIGEgZW5jb2RlciB3b3JrZXJcbiAgICB0aGlzLl93b3JrZXJGYWN0b3J5ID0gdHlwZW9mIGVuY29kZXJXb3JrZXJGYWN0b3J5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBlbmNvZGVyV29ya2VyRmFjdG9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXyA9PiBuZXcgV29ya2VyKHdvcmtlckRpcik7XG4gICAgdGhpcy5fc3Bhd25Xb3JrZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgTWVkaWFTdHJlYW0gW0dFVFVTRVJNRURJQV0gdG8gYmUgcmVjb3JkZWQuXG4gICAqIEByZXR1cm4ge01lZGlhU3RyZWFtfVxuICAgKi9cbiAgZ2V0IHN0cmVhbSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgTUlNRSB0eXBlIFtSRkMyMDQ2XSB0aGF0IGhhcyBiZWVuIHNlbGVjdGVkIGFzIHRoZSBjb250YWluZXIgZm9yXG4gICAqIHJlY29yZGluZy4gVGhpcyBlbnRyeSBpbmNsdWRlcyBhbGwgdGhlIHBhcmFtZXRlcnMgdG8gdGhlIGJhc2VcbiAgICogbWltZVR5cGUuIFRoZSBVQSBzaG91bGQgYmUgYWJsZSB0byBwbGF5IGJhY2sgYW55IG9mIHRoZSBNSU1FIHR5cGVzXG4gICAqIGl0IHN1cHBvcnRzIGZvciByZWNvcmRpbmcuIEZvciBleGFtcGxlLCBpdCBzaG91bGQgYmUgYWJsZSB0byBkaXNwbGF5XG4gICAqIGEgdmlkZW8gcmVjb3JkaW5nIGluIHRoZSBIVE1MIDx2aWRlbz4gdGFnLiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3JcbiAgICogdGhpcyBwcm9wZXJ0eSBpcyBwbGF0Zm9ybS1zcGVjaWZpYy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1pbWVUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWltZVR5cGU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIE9wdXNNZWRpYVJlY29yZGVyIG9iamVjdC4gV2hlbiB0aGUgT3B1c01lZGlhUmVjb3JkZXJcbiAgICogaXMgY3JlYXRlZCwgdGhlIFVBIE1VU1Qgc2V0IHRoaXMgYXR0cmlidXRlIHRvIGluYWN0aXZlLlxuICAgKiBAcmV0dXJuIHtcImluYWN0aXZlXCJ8XCJyZWNvcmRpbmdcInxcInBhdXNlZFwifVxuICAgKi9cbiAgZ2V0IHN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBWaWRlbyBlbmNvZGluZy4gVW5zdXBwb3J0ZWQuXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICovXG4gIGdldCB2aWRlb0JpdHNQZXJTZWNvbmQgKCkge1xuICAgIC8vIFZpZGVvIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgQXVkaW8gZW5jb2RpbmcgdGFyZ2V0IGJpdCByYXRlIHRoYXQgd2FzIHBhc3NlZCB0b1xuICAgKiB0aGUgUGxhdGZvcm0gKHBvdGVudGlhbGx5IHRydW5jYXRlZCwgcm91bmRlZCwgZXRjKSwgb3IgdGhlIGNhbGN1bGF0ZWQgb25lXG4gICAqIGlmIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgYml0c1BlclNlY29uZC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCBhdWRpb0JpdHNQZXJTZWNvbmQgKCkge1xuICAgIHJldHVybiB0aGlzLl9hdWRpb0JpdHNQZXJTZWNvbmQ7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB3b3JrZXJcbiAgICovXG4gIF9zcGF3bldvcmtlciAoKSB7XG4gICAgdGhpcy53b3JrZXIgPSB0aGlzLl93b3JrZXJGYWN0b3J5KCk7XG4gICAgdGhpcy53b3JrZXIub25tZXNzYWdlID0gKGUpID0+IHRoaXMuX29ubWVzc2FnZUZyb21Xb3JrZXIoZSk7XG4gICAgdGhpcy53b3JrZXIub25lcnJvciA9IChlKSA9PiB0aGlzLl9vbmVycm9yRnJvbVdvcmtlcihlKTtcblxuICAgIHRoaXMuX3Bvc3RNZXNzYWdlVG9Xb3JrZXIoJ2xvYWRFbmNvZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbWltZVR5cGU6IHRoaXMuX21pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNtUGF0aDogdGhpcy5fd2FzbVBhdGggfSk7XG4gIH1cblxuICAvKipcbiAgICogUG9zdCBtZXNzYWdlIHRvIHRoZSBlbmNvZGVyIHdlYiB3b3JrZXIuXG4gICAqIEBwYXJhbSB7XCJpbml0XCJ8XCJwdXNoSW5wdXREYXRhXCJ8XCJnZXRFbmNvZGVkRGF0YVwifFwiZG9uZVwifSBjb21tYW5kIC0gVHlwZSBvZiBtZXNzYWdlIHRvIHNlbmQgdG8gdGhlIHdvcmtlclxuICAgKiBAcGFyYW0ge29iamVjdH0gbWVzc2FnZSAtIFBheWxvYWQgdG8gdGhlIHdvcmtlclxuICAgKi9cbiAgX3Bvc3RNZXNzYWdlVG9Xb3JrZXIgKGNvbW1hbmQsIG1lc3NhZ2UgPSB7fSkge1xuICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgY2FzZSAnbG9hZEVuY29kZXInOlxuICAgICAgICBsZXQgeyBtaW1lVHlwZSwgd2FzbVBhdGggfSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHsgY29tbWFuZCwgbWltZVR5cGUsIHdhc21QYXRoIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHdvcmtlclxuICAgICAgICBsZXQgeyBzYW1wbGVSYXRlLCBjaGFubmVsQ291bnQsIGJpdHNQZXJTZWNvbmQgfSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHsgY29tbWFuZCwgc2FtcGxlUmF0ZSwgY2hhbm5lbENvdW50LCBiaXRzUGVyU2Vjb25kIH0pO1xuICAgICAgICB0aGlzLndvcmtlclN0YXRlID0gJ2VuY29kaW5nJztcblxuICAgICAgICAvLyBTdGFydCBzdHJlYW1pbmdcbiAgICAgICAgdGhpcy5zb3VyY2UuY29ubmVjdCh0aGlzLnByb2Nlc3Nvcik7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yLmNvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgbGV0IGV2ZW50VG9QdXNoID0gbmV3IGdsb2JhbC5FdmVudCgnc3RhcnQnKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50VG9QdXNoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3B1c2hJbnB1dERhdGEnOlxuICAgICAgICAvLyBQYXNzIGlucHV0IGF1ZGlvIGJ1ZmZlciB0byB0aGUgZW5jb2RlciB0byBlbmNvZGUuXG4gICAgICAgIC8vIFRoZSB3b3JrZXIgTUFZIHRyaWdnZXIgJ2VuY29kZWREYXRhJy5cbiAgICAgICAgbGV0IHsgY2hhbm5lbEJ1ZmZlcnMsIGxlbmd0aCwgZHVyYXRpb24gfSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBjb21tYW5kLCBjaGFubmVsQnVmZmVycywgbGVuZ3RoLCBkdXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2dldEVuY29kZWREYXRhJzpcbiAgICAgICAgLy8gUmVxdWVzdCBlbmNvZGVkIHJlc3VsdC5cbiAgICAgICAgLy8gRXhwZWN0ZWQgJ2VuY29kZWREYXRhJyBldmVudCBmcm9tIHRoZSB3b3JrZXJcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoeyBjb21tYW5kIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgIC8vIFRlbGwgZW5jb2RlciBmaW5hbGxpemUgdGhlIGpvYiBhbmQgZGVzdG9yeSBpdHNlbGYuXG4gICAgICAgIC8vIEV4cGVjdGVkICdsYXN0RW5jb2RlZERhdGEnIGV2ZW50IGZyb20gdGhlIHdvcmtlci5cbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoeyBjb21tYW5kIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBlcnJvciBjYXNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgRXJyb3I6IEluY29ycmVjdCBwb3N0TWVzc2FnZSByZXF1ZXN0ZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIG9ubWVzc2FnZSgpIGNhbGxiYWNrIGZyb20gdGhlIHdvcmtlci5cbiAgICogQHBhcmFtIHttZXNzYWdlfSBldmVudCAtIG1lc3NhZ2UgZnJvbSB0aGUgd29ya2VyXG4gICAqL1xuICBfb25tZXNzYWdlRnJvbVdvcmtlciAoZXZlbnQpIHtcbiAgICBjb25zdCB7IGNvbW1hbmQsIGJ1ZmZlcnMgfSA9IGV2ZW50LmRhdGE7XG4gICAgbGV0IGV2ZW50VG9QdXNoO1xuICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgY2FzZSAncmVhZHlUb0luaXQnOlxuICAgICAgICBjb25zdCB7IHNhbXBsZVJhdGUsIGNoYW5uZWxDb3VudCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy53b3JrZXJTdGF0ZSA9ICdyZWFkeVRvSW5pdCc7XG5cbiAgICAgICAgLy8gSWYgc3RhcnQoKSBpcyBhbHJlYWR5IGNhbGxlZCBpbml0aWFsaXplIHdvcmtlclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3JlY29yZGluZycpIHtcbiAgICAgICAgICB0aGlzLl9wb3N0TWVzc2FnZVRvV29ya2VyKCdpbml0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzUGVyU2Vjb25kOiB0aGlzLmF1ZGlvQml0c1BlclNlY29uZH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlbmNvZGVkRGF0YSc6XG4gICAgICBjYXNlICdsYXN0RW5jb2RlZERhdGEnOlxuICAgICAgICBsZXQgZGF0YSA9IG5ldyBCbG9iKGJ1ZmZlcnMsIHsndHlwZSc6IHRoaXMuX21pbWVUeXBlfSk7XG4gICAgICAgIGV2ZW50VG9QdXNoID0gbmV3IGdsb2JhbC5FdmVudCgnZGF0YWF2YWlsYWJsZScpO1xuICAgICAgICBldmVudFRvUHVzaC5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50VG9QdXNoKTtcblxuICAgICAgICAvLyBEZXRlY3Qgb2Ygc3RvcCgpIGNhbGxlZCBiZWZvcmVcbiAgICAgICAgaWYgKGNvbW1hbmQgPT09ICdsYXN0RW5jb2RlZERhdGEnKSB7XG4gICAgICAgICAgZXZlbnRUb1B1c2ggPSBuZXcgZ2xvYmFsLkV2ZW50KCdzdG9wJyk7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50VG9QdXNoKTtcblxuICAgICAgICAgIHRoaXMud29ya2VyU3RhdGUgPSAnY2xvc2VkJztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7IC8vIElnbm9yZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBvbmVycm9yKCkgY2FsbGJhY2sgZnJvbSB0aGUgd29ya2VyLlxuICAgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGVycm9yIC0gZXJyb3Igb2JqZWN0IGZyb20gdGhlIHdvcmtlclxuICAgKi9cbiAgX29uZXJyb3JGcm9tV29ya2VyIChlcnJvcikge1xuICAgIC8vIFN0b3Agc3RyZWFtIGZpcnN0XG4gICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMucHJvY2Vzc29yLmRpc2Nvbm5lY3QoKTtcblxuICAgIHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIHRoaXMud29ya2VyU3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIFNlbmQgbWVzc2FnZSB0byBob3N0XG4gICAgbGV0IG1lc3NhZ2UgPSBbXG4gICAgICAnRmlsZU5hbWU6ICcgKyBlcnJvci5maWxlbmFtZSxcbiAgICAgICdMaW5lTnVtYmVyOiAnICsgZXJyb3IubGluZW5vLFxuICAgICAgJ01lc3NhZ2U6ICcgKyBlcnJvci5tZXNzYWdlXG4gICAgXS5qb2luKCcgLSAnKTtcbiAgICBsZXQgZXJyb3JUb1B1c2ggPSBuZXcgZ2xvYmFsLkV2ZW50KCdlcnJvcicpO1xuICAgIGVycm9yVG9QdXNoLm5hbWUgPSAnVW5rbm93bkVycm9yJztcbiAgICBlcnJvclRvUHVzaC5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXJyb3JUb1B1c2gpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvbmF1ZGlvcHJvY2VzcygpIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXNsaWNlIC0gSW4gc2Vjb25kcy4gT3B1c01lZGlhUmVjb3JkZXIgc2hvdWxkIHJlcXVlc3QgZGF0YVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gdGhlIHdvcmtlciBldmVyeSB0aW1lc2xpY2Ugc2Vjb25kcy5cbiAgICovXG4gIF9lbmFibGVBdWRpb1Byb2Nlc3NDYWxsYmFjayAodGltZXNsaWNlKSB7XG4gICAgLy8gcGFzcyBmcmFtZSBidWZmZXJzIHRvIHRoZSB3b3JrZXJcbiAgICBsZXQgZWxhcHNlZFRpbWUgPSAwO1xuICAgIHRoaXMucHJvY2Vzc29yLm9uYXVkaW9wcm9jZXNzID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgaW5wdXRCdWZmZXIsIHBsYXliYWNrVGltZSB9ID0gZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgY29uc3QgeyBzYW1wbGVSYXRlLCBsZW5ndGgsIGR1cmF0aW9uLCBudW1iZXJPZkNoYW5uZWxzIH0gPSBpbnB1dEJ1ZmZlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICAvLyBDcmVhdGUgY2hhbm5lbCBidWZmZXJzIHRvIHBhc3MgdG8gdGhlIHdvcmtlclxuICAgICAgY29uc3QgY2hhbm5lbEJ1ZmZlcnMgPSBuZXcgQXJyYXkobnVtYmVyT2ZDaGFubmVscyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2hhbm5lbHM7IGkrKykge1xuICAgICAgICBjaGFubmVsQnVmZmVyc1tpXSA9IGlucHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKGkpO1xuICAgICAgfVxuXG4gICAgICAvLyBQYXNzIGRhdGEgdG8gdGhlIHdvcmtlclxuICAgICAgY29uc3QgbWVzc2FnZSA9IHsgY2hhbm5lbEJ1ZmZlcnMsIGxlbmd0aCwgZHVyYXRpb24gfTtcbiAgICAgIHRoaXMuX3Bvc3RNZXNzYWdlVG9Xb3JrZXIoJ3B1c2hJbnB1dERhdGEnLCBtZXNzYWdlKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRpbWVcbiAgICAgIGVsYXBzZWRUaW1lICs9IGR1cmF0aW9uO1xuICAgICAgaWYgKGVsYXBzZWRUaW1lID49IHRpbWVzbGljZSkge1xuICAgICAgICB0aGlzLl9wb3N0TWVzc2FnZVRvV29ya2VyKCdnZXRFbmNvZGVkRGF0YScpO1xuICAgICAgICBlbGFwc2VkVGltZSA9IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWdpbnMgcmVjb3JkaW5nIG1lZGlhOyB0aGlzIG1ldGhvZCBjYW4gb3B0aW9uYWxseSBiZSBwYXNzZWQgYSB0aW1lc2xpY2VcbiAgICogYXJndW1lbnQgd2l0aCBhIHZhbHVlIGluIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzbGljZSAtIElmIHRoaXMgaXMgc3BlY2lmaWVkLCB0aGUgbWVkaWEgd2lsbCBiZSBjYXB0dXJlZFxuICAgKiAgICAgICAgaW4gc2VwYXJhdGUgY2h1bmtzIG9mIHRoYXQgZHVyYXRpb24sIHJhdGhlciB0aGFuIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAqICAgICAgICBvZiByZWNvcmRpbmcgdGhlIG1lZGlhIGluIGEgc2luZ2xlIGxhcmdlIGNodW5rLiBJbiBvdGhlciB3b3JkcywgYW5cbiAgICogICAgICAgIHVuZGVmaW5lZCB2YWx1ZSBvZiB0aW1lc2xpY2Ugd2lsbCBiZSB1bmRlcnN0b29kIGFzIHRoZSBsYXJnZXN0IGxvbmcgdmFsdWUuXG4gICAqL1xuICBzdGFydCAodGltZXNsaWNlID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ2luYWN0aXZlJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdET01FeGNlcHRpb246IElOVkFMSURfU1RBVEVfRVJSLCBzdGF0ZSBtdXN0IGJlIGluYWN0aXZlLicpO1xuICAgIH1cbiAgICBpZiAodGltZXNsaWNlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudHMsIHRpbWVzbGljZSBzaG91bGQgYmUgMCBvciBoaWdoZXIuJyk7XG4gICAgfVxuICAgIHRpbWVzbGljZSAvPSAxMDAwOyAvLyBDb252ZXJ0IG1pbGxpc2Vjb25kcyB0byBzZWNvbmRzXG5cbiAgICAvLyBDaGVjayB3b3JrZXIgaXMgY2xvc2VkICh1c3VhbGx5IGJ5IHN0b3AoKSkgYW5kIGluaXQuXG4gICAgaWYgKHRoaXMud29ya2VyU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aGlzLl9zcGF3bldvcmtlcigpO1xuICAgIH1cblxuICAgIC8vIEdldCBjaGFubmVsIGNvdW50IGFuZCBzYW1wbGluZyByYXRlXG4gICAgLy8gY2hhbm5lbENvdW50OiBodHRwczovL3d3dy53My5vcmcvVFIvbWVkaWFjYXB0dXJlLXN0cmVhbXMvI21lZGlhLXRyYWNrLXNldHRpbmdzXG4gICAgLy8gc2FtcGxlUmF0ZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jhc2VBdWRpb0NvbnRleHQvc2FtcGxlUmF0ZVxuICAgIHRoaXMuY29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICBsZXQgdHJhY2tzID0gdGhpcy5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgICBpZiAoIXRyYWNrc1swXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdET01FeGNlcHRpb246IFVua293bkVycm9yLCBtZWRpYSB0cmFjayBub3QgZm91bmQuJyk7XG4gICAgfVxuICAgIHRoaXMuY2hhbm5lbENvdW50ID0gdHJhY2tzWzBdLmdldFNldHRpbmdzKCkuY2hhbm5lbENvdW50IHx8IDE7XG4gICAgdGhpcy5zYW1wbGVSYXRlID0gdGhpcy5jb250ZXh0LnNhbXBsZVJhdGU7XG5cbiAgICAvKiogQHR5cGUge01lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlfSAqL1xuICAgIHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHRoaXMuc3RyZWFtKTtcbiAgICAvKiogQHR5cGUge1NjcmlwdFByb2Nlc3Nvck5vZGV9ICovXG4gICAgdGhpcy5wcm9jZXNzb3IgPSB0aGlzLmNvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKEJVRkZFUl9TSVpFLCB0aGlzLmNoYW5uZWxDb3VudCwgdGhpcy5jaGFubmVsQ291bnQpO1xuXG4gICAgLy8gU3RhcnQgcmVjb3JkaW5nXG4gICAgdGhpcy5fc3RhdGUgPSAncmVjb3JkaW5nJztcbiAgICB0aGlzLl9lbmFibGVBdWRpb1Byb2Nlc3NDYWxsYmFjayh0aW1lc2xpY2UpO1xuXG4gICAgLy8gSWYgdGhlIHdvcmtlciBpcyBhbHJlYWR5IGxvYWRlZCB0aGVuIHN0YXJ0XG4gICAgaWYgKHRoaXMud29ya2VyU3RhdGUgPT09ICdyZWFkeVRvSW5pdCcpIHtcbiAgICAgIGNvbnN0IHsgc2FtcGxlUmF0ZSwgY2hhbm5lbENvdW50IH0gPSB0aGlzO1xuICAgICAgdGhpcy5fcG9zdE1lc3NhZ2VUb1dvcmtlcignaW5pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0c1BlclNlY29uZDogdGhpcy5hdWRpb0JpdHNQZXJTZWNvbmQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHJlY29yZGluZywgYXQgd2hpY2ggcG9pbnQgYSBkYXRhYXZhaWxhYmxlIGV2ZW50IGNvbnRhaW5pbmdcbiAgICogdGhlIGZpbmFsIEJsb2Igb2Ygc2F2ZWQgZGF0YSBpcyBmaXJlZC4gTm8gbW9yZSByZWNvcmRpbmcgb2NjdXJzLlxuICAgKi9cbiAgc3RvcCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICdpbmFjdGl2ZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRE9NRXhjZXB0aW9uOiBJTlZBTElEX1NUQVRFX0VSUiwgc3RhdGUgbXVzdCBOT1QgYmUgaW5hY3RpdmUuJyk7XG4gICAgfVxuXG4gICAgLy8gU3RvcCBzdHJlYW0gZmlyc3RcbiAgICB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5wcm9jZXNzb3IuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuY29udGV4dC5jbG9zZSgpO1xuXG4gICAgLy8gU3RvcCBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCBhdCBfb25tZXNzYWdlRnJvbVdvcmtlcigpLFxuICAgIHRoaXMuX3Bvc3RNZXNzYWdlVG9Xb3JrZXIoJ2RvbmUnKTtcblxuICAgIHRoaXMuX3N0YXRlID0gJ2luYWN0aXZlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZXMgdGhlIHJlY29yZGluZyBvZiBtZWRpYS5cbiAgICovXG4gIHBhdXNlICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2luYWN0aXZlJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdET01FeGNlcHRpb246IElOVkFMSURfU1RBVEVfRVJSLCBzdGF0ZSBtdXN0IE5PVCBiZSBpbmFjdGl2ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBTdG9wIHN0cmVhbSBmaXJzdFxuICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnByb2Nlc3Nvci5kaXNjb25uZWN0KCk7XG5cbiAgICBsZXQgZXZlbnQgPSBuZXcgZ2xvYmFsLkV2ZW50KCdwYXVzZScpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgdGhpcy5fc3RhdGUgPSAncGF1c2VkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWVzIHJlY29yZGluZyBvZiBtZWRpYSBhZnRlciBoYXZpbmcgYmVlbiBwYXVzZWQuXG4gICAqL1xuICByZXN1bWUgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAnaW5hY3RpdmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogSU5WQUxJRF9TVEFURV9FUlIsIHN0YXRlIG11c3QgTk9UIGJlIGluYWN0aXZlLicpO1xuICAgIH1cblxuICAgIC8vIFJlc3RhcnQgc3RyZWFtaW5nIGRhdGFcbiAgICB0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMucHJvY2Vzc29yKTtcbiAgICB0aGlzLnByb2Nlc3Nvci5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cbiAgICBsZXQgZXZlbnQgPSBuZXcgZ2xvYmFsLkV2ZW50KCdyZXN1bWUnKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIHRoaXMuX3N0YXRlID0gJ3JlY29yZGluZyc7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdHMgYSBCbG9iIGNvbnRhaW5pbmcgdGhlIHNhdmVkIGRhdGEgcmVjZWl2ZWQgdGh1cyBmYXIgKG9yIHNpbmNlXG4gICAqIHRoZSBsYXN0IHRpbWUgcmVxdWVzdERhdGEoKSB3YXMgY2FsbGVkLiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLFxuICAgKiByZWNvcmRpbmcgY29udGludWVzLCBidXQgaW4gYSBuZXcgQmxvYi5cbiAgICovXG4gIHJlcXVlc3REYXRhICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2luYWN0aXZlJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdET01FeGNlcHRpb246IElOVkFMSURfU1RBVEVfRVJSLCBzdGF0ZSBtdXN0IE5PVCBiZSBpbmFjdGl2ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBkYXRhYXZhaWxhYmxlIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmQgYXQgX29ubWVzc2FnZUZyb21Xb3JrZXIoKVxuICAgIHRoaXMuX3Bvc3RNZXNzYWdlVG9Xb3JrZXIoJ2dldEVuY29kZWREYXRhJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyBpZiB0aGUgZ2l2ZW4gTUlNRSB0eXBlIGlzIHN1cHBvcnRlZFxuICAgKiBieSB0aGUgY3VycmVudCB1c2VyIGFnZW50IC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVUeXBlIC0gQSBNSU1FIFR5cGUsIGluY2x1ZGluZyBwYXJhbWV0ZXJzIHdoZW4gbmVlZGVkLFxuICAgKiAgICAgICAgICBzcGVjaWZ5aW5nIGEgY29udGFpbmVyIGFuZC9vciBjb2RlYyBmb3JtYXRzIGZvciByZWNvcmRpbmcuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNUeXBlU3VwcG9ydGVkIChtaW1lVHlwZSkge1xuICAgIC8vIFNlZTogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL21lZGlhY2FwdHVyZS1yZWNvcmQvI2RvbS1tZWRpYXJlY29yZGVyLWlzdHlwZXN1cHBvcnRlZFxuXG4gICAgLy8gMS4gSWYgZW1wdHkgc3RyaW5nLCByZXR1cm4gdHJ1ZS5cbiAgICBpZiAodHlwZW9mIG1pbWVUeXBlID09PSAnc3RyaW5nJyAmJiAhbWltZVR5cGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdmFyIHt0eXBlLCBzdWJ0eXBlLCBjb2RlY30gPSBPcHVzTWVkaWFSZWNvcmRlci5fcGFyc2VUeXBlKG1pbWVUeXBlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gMi4gSWYgbm90IGEgdmFsaWQgc3RyaW5nLCByZXR1cm4gZmFsc2UuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlICE9PSAnYXVkaW8nIHx8XG4gICAgICAhKHN1YnR5cGUgPT09ICdvZ2cnIHx8IHN1YnR5cGUgPT09ICd3ZWJtJyB8fFxuICAgICAgICBzdWJ0eXBlID09PSAnd2F2ZScgfHwgc3VidHlwZSA9PT0gJ3dhdicpKSB7XG4gICAgICAvLyAzLDQuIElmIHR5cGUgYW5kIHN1YnR5cGUgYXJlIHVuc3VwcG9ydGVkIHRoZSByZXR1cm4gZmFsc2UuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIDUuIElmIGNvZGVjIGlzIHVuc3VwcG9ydGVkIHRoZW4gcmV0dXJuIGZhbHNlLlxuICAgIC8vIDYuIElmIHRoZSBzcGVjaWZpZWQgY29tYmluYXRpb24gb2YgYWxsIGlzIG5vdCBzdXBwb3J0ZWQgdGhhbiByZXR1cm4gZmFsc2UuXG4gICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICBjYXNlICdvZ2cnOlxuICAgICAgICBpZiAoY29kZWMgIT09ICdvcHVzJyAmJiBjb2RlYykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dlYm0nOlxuICAgICAgICBpZiAoY29kZWMgIT09ICdvcHVzJyAmJiBjb2RlYykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3dhdmUnOlxuICAgICAgY2FzZSAnd2F2JzpcbiAgICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBDdXJyZW50bHkgb25seSBzdXBwb3J0cyBzaWduZWQgMTYgYml0c1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyA3LiByZXR1cm4gdHJ1ZS5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBNSU1FLiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgaXNUeXBlU3VwcG9ydGVkKCkgYW5kIGV0Yy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1pbWVUeXBlIC0gdHlwZVR5cGUgLSBBIE1JTUUgVHlwZSwgaW5jbHVkaW5nIHBhcmFtZXRlcnMgd2hlbiBuZWVkZWQsXG4gICAqICAgICAgICAgIHNwZWNpZnlpbmcgYSBjb250YWluZXIgYW5kL29yIGNvZGVjIGZvcm1hdHMgZm9yIHJlY29yZGluZy5cbiAgICogQHJldHVybiB7P29iamVjdH0gLSBBbiBvYmplY3Qgd2l0aCB0eXBlLCBzdWJ0eXBlLCBjb2RlYyBhdHRyaWJ1dGVzXG4gICAqICAgICAgICAgIGlmIHBhcnNlZCBjb3JyZWN0bHkuIG51bGwgaXMgcmV0dXJuZWQgaWYgcGFyc2luZyBmYWlsZWQuXG4gICAqICAgICAgICAgIElmIG1pbWVUeXBlIGlzIGFuIGVtcHR5IHN0cmluZyB0aGVuIHJldHVybiBhbiBvYmplY3Qgd2l0aCBhdHRyaWJ1dGVzXG4gICAqICAgICAgICAgIGFyZSBlbXB0eSBzdHJpbmdzXG4gICAqL1xuICBzdGF0aWMgX3BhcnNlVHlwZSAobWltZVR5cGUpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVnZXggPSAvXihcXHcrKVxcLyhcXHcrKSg7XFxzKmNvZGVjcz0oXFx3KykpPyQvO1xuICAgICAgdmFyIFssIHR5cGUsIHN1YnR5cGUsICwgY29kZWNdID0gbWltZVR5cGUubWF0Y2gocmVnZXgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAodHlwZW9mIG1pbWVUeXBlID09PSAnc3RyaW5nJyAmJiAhbWltZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHt0eXBlOiAnJywgc3VidHlwZTogJycsIGNvZGVjOiAnJ307XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHt0eXBlLCBzdWJ0eXBlLCBjb2RlY307XG4gIH1cbn1cblxuLy8gRXZlbnRIYW5kbGVyIGF0dHJpYnV0ZXMuXG4vLyBUaGlzIGNvZGUgaXMgYSBub24tc3RhbmRhcmQgRXZlbnRUYXJnZXQgYnV0IHJlcXVpcmVkIGJ5IGV2ZW50LXRhcmdldC1zaGltLlxuW1xuICAnc3RhcnQnLCAvLyBDYWxsZWQgdG8gaGFuZGxlIHRoZSB7QGxpbmsgTWVkaWFSZWNvcmRlciNzdGFydH0gZXZlbnQuXG4gICdzdG9wJywgLy8gQ2FsbGVkIHRvIGhhbmRsZSB0aGUgc3RvcCBldmVudC5cbiAgJ2RhdGFhdmFpbGFibGUnLCAvKiBDYWxsZWQgdG8gaGFuZGxlIHRoZSBkYXRhYXZhaWxhYmxlIGV2ZW50LiBUaGUgQmxvYiBvZlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkZWQgZGF0YSBpcyBjb250YWluZWQgaW4gdGhpcyBldmVudCBhbmQgY2FuIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NlZCB2aWEgaXRzIGRhdGEgYXR0cmlidXRlLiAqL1xuICAncGF1c2UnLCAvLyBDYWxsZWQgdG8gaGFuZGxlIHRoZSBwYXVzZSBldmVudC5cbiAgJ3Jlc3VtZScsIC8vIENhbGxlZCB0byBoYW5kbGUgdGhlIHJlc3VtZSBldmVudC5cbiAgJ2Vycm9yJyAvLyBDYWxsZWQgdG8gaGFuZGxlIGEgTWVkaWFSZWNvcmRlckVycm9yRXZlbnQuXG5dLmZvckVhY2gobmFtZSA9PiBkZWZpbmVFdmVudEF0dHJpYnV0ZShPcHVzTWVkaWFSZWNvcmRlci5wcm90b3R5cGUsIG5hbWUpKTtcblxuLy8gTVMgRWRnZSBzcGVjaWZpYyBtb25rZXkgcGF0Y2hpbmc6XG4vLyBvbmF1ZGlvcHJvY2VzcyBjYWxsYmFjayBjYW5ub3QgYmUgdHJpZ2dlcmVkIG1vcmUgdGhhbiB0d2ljZSB3aGVuIHBvc3RNZXNzYWdlXG4vLyB1c2VzIHRoZSBzZWNvbmRlIHRyYW5zZmVyIGFyZ3VtZW50LiBTbyBkaXNhYmxlIHRoZSB0cmFuc2ZlciBhcmd1bWVudCBvbmx5IGluIEVkZ2UuXG5pZiAoYnJvd3NlciAmJiBicm93c2VyLm5hbWUgPT09ICdlZGdlJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmlnaW5hbCA9IFdvcmtlci5wcm90b3R5cGUucG9zdE1lc3NhZ2U7XG4gICAgV29ya2VyLnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCB0cmFuc2ZlciA9IG51bGwpIHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFttZXNzYWdlXSk7XG4gICAgfTtcbiAgfSkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPcHVzTWVkaWFSZWNvcmRlcjtcbiIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VCdXM7XG5pbmhlcml0cyhQYWdlQnVzLCBFdmVudEVtaXR0ZXIpO1xuXG52YXIgZW1pdCA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdDtcbnZhciBvbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG52YXIgb25jZSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZTtcblxuZnVuY3Rpb24gUGFnZUJ1cyAob3B0cykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYWdlQnVzKSkgcmV0dXJuIG5ldyBQYWdlQnVzKG9wdHMpO1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSBvcHRzID0geyBrZXk6IG9wdHMgfTtcbiAgICB0aGlzLl9rZXkgPSBvcHRzLmtleSB8fCAncGFnZS1idXMnO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoW10pKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAoZXYua2V5ID09PSBzZWxmLl9rZXkpIHtcbiAgICAgICAgICAgIHRyeSB7IHZhciB2YWx1ZSA9IEpTT04ucGFyc2UoZXYubmV3VmFsdWUpIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgZW1pdC5hcHBseShzZWxmLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuXG5QYWdlQnVzLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeShhcmdzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIiwiLyohIHF1ZXVlLW1pY3JvdGFzay4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xubGV0IHByb21pc2VcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbidcbiAgPyBxdWV1ZU1pY3JvdGFzay5iaW5kKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKVxuICAvLyByZXVzZSByZXNvbHZlZCBwcm9taXNlLCBhbmQgYWxsb2NhdGUgaXQgbGF6aWx5XG4gIDogY2IgPT4gKHByb21pc2UgfHwgKHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKSkpXG4gICAgLnRoZW4oY2IpXG4gICAgLmNhdGNoKGVyciA9PiBzZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZXJyIH0sIDApKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIGxpbWl0IG9mIENyeXB0by5nZXRSYW5kb21WYWx1ZXMoKVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NyeXB0by9nZXRSYW5kb21WYWx1ZXNcbnZhciBNQVhfQllURVMgPSA2NTUzNlxuXG4vLyBOb2RlIHN1cHBvcnRzIHJlcXVlc3RpbmcgdXAgdG8gdGhpcyBudW1iZXIgb2YgYnl0ZXNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvaW50ZXJuYWwvY3J5cHRvL3JhbmRvbS5qcyNMNDhcbnZhciBNQVhfVUlOVDMyID0gNDI5NDk2NzI5NVxuXG5mdW5jdGlvbiBvbGRCcm93c2VyICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdTZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLlxcblVzZSBDaHJvbWUsIEZpcmVmb3ggb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTEnKVxufVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0b1xuXG5pZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByYW5kb21CeXRlc1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBvbGRCcm93c2VyXG59XG5cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzIChzaXplLCBjYikge1xuICAvLyBwaGFudG9tanMgbmVlZHMgdG8gdGhyb3dcbiAgaWYgKHNpemUgPiBNQVhfVUlOVDMyKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncmVxdWVzdGVkIHRvbyBtYW55IHJhbmRvbSBieXRlcycpXG5cbiAgdmFyIGJ5dGVzID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpXG5cbiAgaWYgKHNpemUgPiAwKSB7ICAvLyBnZXRSYW5kb21WYWx1ZXMgZmFpbHMgb24gSUUgaWYgc2l6ZSA9PSAwXG4gICAgaWYgKHNpemUgPiBNQVhfQllURVMpIHsgLy8gdGhpcyBpcyB0aGUgbWF4IGJ5dGVzIGNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAgIC8vIGNhbiBkbyBhdCBvbmNlIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAgIGZvciAodmFyIGdlbmVyYXRlZCA9IDA7IGdlbmVyYXRlZCA8IHNpemU7IGdlbmVyYXRlZCArPSBNQVhfQllURVMpIHtcbiAgICAgICAgLy8gYnVmZmVyLnNsaWNlIGF1dG9tYXRpY2FsbHkgY2hlY2tzIGlmIHRoZSBlbmQgaXMgcGFzdCB0aGUgZW5kIG9mXG4gICAgICAgIC8vIHRoZSBidWZmZXIgc28gd2UgZG9uJ3QgaGF2ZSB0byBoZXJlXG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMuc2xpY2UoZ2VuZXJhdGVkLCBnZW5lcmF0ZWQgKyBNQVhfQllURVMpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYihudWxsLCBieXRlcylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgY29kZXMgPSB7fTtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0c0xvb3NlKE5vZGVFcnJvciwgX0Jhc2UpO1xuXG4gICAgZnVuY3Rpb24gTm9kZUVycm9yKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIHJldHVybiBfQmFzZS5jYWxsKHRoaXMsIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBOb2RlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBCYXNlLm5hbWU7XG4gIE5vZGVFcnJvci5wcm90b3R5cGUuY29kZSA9IGNvZGU7XG4gIGNvZGVzW2NvZGVdID0gTm9kZUVycm9yO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTAuOC4wL2xpYi9pbnRlcm5hbC9lcnJvcnMuanNcblxuXG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpKTtcbiAgICB9KTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyksIFwiLCBvciBcIikgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChTdHJpbmcoZXhwZWN0ZWQpKTtcbiAgfVxufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aFxuXG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gsIHBvcykge1xuICByZXR1cm4gc3RyLnN1YnN0cighcG9zIHx8IHBvcyA8IDAgPyAwIDogK3Bvcywgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2VuZHNXaXRoXG5cblxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gIGlmICh0aGlzX2xlbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXNfbGVuID4gc3RyLmxlbmd0aCkge1xuICAgIHRoaXNfbGVuID0gc3RyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9pbmNsdWRlc1xuXG5cbmZ1bmN0aW9uIGluY2x1ZGVzKHN0ciwgc2VhcmNoLCBzdGFydCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChzdGFydCArIHNlYXJjaC5sZW5ndGggPiBzdHIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzZWFyY2gsIHN0YXJ0KSAhPT0gLTE7XG4gIH1cbn1cblxuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9PUFRfVkFMVUUnLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuICdUaGUgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwiJyArIG5hbWUgKyAnXCInO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBmdW5jdGlvbiAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICB2YXIgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfVxuXG4gIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIi5jb25jYXQodHlwZW9mIGFjdHVhbCk7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GJywgJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdUaGUgJyArIG5hbWUgKyAnIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJywgJ1ByZW1hdHVyZSBjbG9zZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0RFU1RST1lFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnQ2Fubm90IGNhbGwgJyArIG5hbWUgKyAnIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnO1xufSk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NVUxUSVBMRV9DQUxMQkFDSycsICdDYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9DQU5OT1RfUElQRScsICdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EJywgJ3dyaXRlIGFmdGVyIGVuZCcpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX05VTExfVkFMVUVTJywgJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJywgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1VOS05PV05fRU5DT0RJTkcnLCBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiAnVW5rbm93biBlbmNvZGluZzogJyArIGFyZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQnLCAnc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbm1vZHVsZS5leHBvcnRzLmNvZGVzID0gY29kZXM7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG4ndXNlIHN0cmljdCc7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG5cbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcblxuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG4gICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5cbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBJZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwgdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjsgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cblxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgZGVidWc7XG5cbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0Jyk7XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7IC8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG5cblxudmFyIFN0cmluZ0RlY29kZXI7XG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yO1xudmFyIGZyb207XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7IC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7IC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcblxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuXG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7IC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFJlYWRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5XG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IC8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTsgLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgZGVidWcoJ3JlYWRhYmxlQWRkQ2h1bmsnLCBjaHVuayk7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcblxuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQoKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSAvLyBXZSBjYW4gcHVzaCBtb3JlIGRhdGEgaWYgd2UgYXJlIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLlxuICAvLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZSBtb3JlIGJ5dGVzLlxuICAvLyBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLCBzdWNoIGFzIHRoZSByZXBsLlxuXG5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG5cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG5cbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInLCAnVWludDhBcnJheSddLCBjaHVuayk7XG4gIH1cblxuICByZXR1cm4gZXI7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHZhciBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gZGVjb2RlcjsgLy8gSWYgc2V0RW5jb2RpbmcobnVsbCksIGRlY29kZXIuZW5jb2RpbmcgZXF1YWxzIHV0ZjhcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nOyAvLyBJdGVyYXRlIG92ZXIgY3VycmVudCBidWZmZXIgdG8gY29udmVydCBhbHJlYWR5IHN0b3JlZCBCdWZmZXJzOlxuXG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICB3aGlsZSAocCAhPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShwLmRhdGEpO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuXG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG5cblxudmFyIE1BWF9IV00gPSAweDQwMDAwMDAwO1xuXG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG5cbiAgcmV0dXJuIG47XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG5cbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH0gLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG5cblxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjsgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcblxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59IC8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7IC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7IC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cblxuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfSAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG5cblxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlOyAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcblxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpO1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcblxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG5cbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAgIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH1cbiAgfVxufSAvLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuXG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcblxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9IC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZlxuICAvLyAxLiBJdCBpcyBub3QgZmxvd2luZywgYXMgdGhlIGZsb3cgbWVjaGFuaXNtIHdpbGwgdGFrZVxuICAvLyAgICBjYXJlIG9mIGl0LlxuICAvLyAyLiBJdCBpcyBub3QgZW5kZWQuXG4gIC8vIDMuIEl0IGlzIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLCBzbyB3ZSBjYW4gc2NoZWR1bGVcbiAgLy8gICAgYW5vdGhlciByZWFkYWJsZSBsYXRlci5cblxuXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgZmxvdyhzdHJlYW0pO1xufSAvLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cblxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIEF0dGVtcHQgdG8gcmVhZCBtb3JlIGRhdGEgaWYgd2Ugc2hvdWxkLlxuICAvL1xuICAvLyBUaGUgY29uZGl0aW9ucyBmb3IgcmVhZGluZyBtb3JlIGRhdGEgYXJlIChvbmUgb2YpOlxuICAvLyAtIE5vdCBlbm91Z2ggZGF0YSBidWZmZXJlZCAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykuIFRoZSBsb29wXG4gIC8vICAgaXMgcmVzcG9uc2libGUgZm9yIGZpbGxpbmcgdGhlIGJ1ZmZlciB3aXRoIGVub3VnaCBkYXRhIGlmIHN1Y2ggZGF0YVxuICAvLyAgIGlzIGF2YWlsYWJsZS4gSWYgaGlnaFdhdGVyTWFyayBpcyAwIGFuZCB3ZSBhcmUgbm90IGluIHRoZSBmbG93aW5nIG1vZGVcbiAgLy8gICB3ZSBzaG91bGQgX25vdF8gYXR0ZW1wdCB0byBidWZmZXIgYW55IGV4dHJhIGRhdGEuIFdlJ2xsIGdldCBtb3JlIGRhdGFcbiAgLy8gICB3aGVuIHRoZSBzdHJlYW0gY29uc3VtZXIgY2FsbHMgcmVhZCgpIGluc3RlYWQuXG4gIC8vIC0gTm8gZGF0YSBpbiB0aGUgYnVmZmVyLCBhbmQgdGhlIHN0cmVhbSBpcyBpbiBmbG93aW5nIG1vZGUuIEluIHRoaXMgbW9kZVxuICAvLyAgIHRoZSBsb29wIGJlbG93IGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyByZWFkKCkgaXMgY2FsbGVkLiBGYWlsaW5nIHRvXG4gIC8vICAgY2FsbCByZWFkIGhlcmUgd291bGQgYWJvcnQgdGhlIGZsb3cgYW5kIHRoZXJlJ3Mgbm8gb3RoZXIgbWVjaGFuaXNtIGZvclxuICAvLyAgIGNvbnRpbnVpbmcgdGhlIGZsb3cgaWYgdGhlIHN0cmVhbSBjb25zdW1lciBoYXMganVzdCBzdWJzY3JpYmVkIHRvIHRoZVxuICAvLyAgICdkYXRhJyBldmVudC5cbiAgLy9cbiAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGFib3ZlIGNvbmRpdGlvbnMgdG8ga2VlcCByZWFkaW5nIGRhdGEsIHRoZSBmb2xsb3dpbmdcbiAgLy8gY29uZGl0aW9ucyBwcmV2ZW50IHRoZSBkYXRhIGZyb20gYmVpbmcgcmVhZDpcbiAgLy8gLSBUaGUgc3RyZWFtIGhhcyBlbmRlZCAoc3RhdGUuZW5kZWQpLlxuICAvLyAtIFRoZXJlIGlzIGFscmVhZHkgYSBwZW5kaW5nICdyZWFkJyBvcGVyYXRpb24gKHN0YXRlLnJlYWRpbmcpLiBUaGlzIGlzIGFcbiAgLy8gICBjYXNlIHdoZXJlIHRoZSB0aGUgc3RyZWFtIGhhcyBjYWxsZWQgdGhlIGltcGxlbWVudGF0aW9uIGRlZmluZWQgX3JlYWQoKVxuICAvLyAgIG1ldGhvZCwgYnV0IHRoZXkgYXJlIHByb2Nlc3NpbmcgdGhlIGNhbGwgYXN5bmNocm9ub3VzbHkgYW5kIGhhdmUgX25vdF9cbiAgLy8gICBjYWxsZWQgcHVzaCgpIHdpdGggbmV3IGRhdGEuIEluIHRoaXMgY2FzZSB3ZSBza2lwIHBlcmZvcm1pbmcgbW9yZVxuICAvLyAgIHJlYWQoKXMuIFRoZSBleGVjdXRpb24gZW5kcyBpbiB0aGlzIG1ldGhvZCBhZ2FpbiBhZnRlciB0aGUgX3JlYWQoKSBlbmRzXG4gIC8vICAgdXAgY2FsbGluZyBwdXNoKCkgd2l0aCBtb3JlIGRhdGEuXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDApKSB7XG4gICAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59IC8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG5cbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcblxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9IC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuXG5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpOyAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7IC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgZGVidWcoJ2Rlc3Qud3JpdGUnLCByZXQpO1xuXG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICB9XG5cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfSAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuXG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpO1xuICB9IC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cblxuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTsgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcblxuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9IC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG5cblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpOyAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHtcbiAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICB9OyAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzOyAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7IC8vIGdvdCBhIG1hdGNoLlxuXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cblxuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gdXBkYXRlIHJlYWRhYmxlTGlzdGVuaW5nIHNvIHRoYXQgcmVzdW1lKCkgbWF5IGJlIGEgbm8tb3BcbiAgICAvLyBhIGZldyBsaW5lcyBkb3duLiBUaGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJykuXG4gICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwOyAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG5cbiAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGRlYnVnKCdvbiByZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUucmVhZGluZyk7XG5cbiAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2KSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYpIHtcbiAgdmFyIHN0YXRlID0gc2VsZi5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwO1xuXG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7IC8vIGNydWRlIHdheSB0byBjaGVjayBpZiB3ZSBzaG91bGQgcmVzdW1lXG4gIH0gZWxzZSBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKSB7XG4gICAgc2VsZi5yZXN1bWUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59IC8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTsgLy8gd2UgZmxvdyBvbmx5IGlmIHRoZXJlIGlzIG5vIG9uZSBsaXN0ZW5pbmdcbiAgICAvLyBmb3IgcmVhZGFibGUsIGJ1dCB3ZSBzdGlsbCBoYXZlIHRvIGNhbGxcbiAgICAvLyByZXN1bWUoKVxuXG4gICAgc3RhdGUuZmxvd2luZyA9ICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZztcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG5cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdyZXN1bWUnLCBzdGF0ZS5yZWFkaW5nKTtcblxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcblxuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7XG4gICAgO1xuICB9XG59IC8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG5cbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7IC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiBtZXRob2RXcmFwKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfSAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG5cblxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9IC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG5cblxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuXG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcyk7XG4gIH07XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pOyAvLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmZpcnN0KCk7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlTlQnLCBzdGF0ZS5lbmRFbWl0dGVkLCBzdGF0ZS5sZW5ndGgpOyAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblxuICAgICAgaWYgKCF3U3RhdGUgfHwgd1N0YXRlLmF1dG9EZXN0cm95ICYmIHdTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5mcm9tID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBvcHRzKSB7XG4gICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9mcm9tJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cblxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyxcbiAgICBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzA7XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCkpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG4gIGNiKGVyKTtcbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuXG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9OyAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9IC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cblxuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCkge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTsgLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ190cmFuc2Zvcm0oKScpKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG5cbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59OyAvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpOyAvLyBUT0RPKEJyaWRnZUFSKTogV3JpdGUgYSB0ZXN0IGZvciB0aGVzZSB0d28gZXJyb3IgY2FzZXNcbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcblxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCgpO1xuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HKCk7XG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcbi8qIDxyZXBsYWNlbWVudD4gKi9cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufSAvLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuXG5cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcblxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgICBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVELFxuICAgIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX05VTExfVkFMVUVTLFxuICAgIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gICAgRVJSX1VOS05PV05fRU5DT0RJTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVU5LTk9XTl9FTkNPRElORztcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0sXG4gIC8vIGUuZy4gb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGUgdnMuIG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlLCBldGMuXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG5cbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlOyAvLyBkcmFpbiBldmVudCBmbGFnLlxuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7IC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG5cbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTsgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTsgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG5cbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlOyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuXG4gIHRoaXMubGVuZ3RoID0gMDsgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cblxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTsgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuXG4gIHRoaXMuY29ya2VkID0gMDsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cblxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07IC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuXG5cbiAgdGhpcy53cml0ZWNiID0gbnVsbDsgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7IC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuXG4gIHRoaXMucGVuZGluZ2NiID0gMDsgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2ZpbmlzaCcgKGFuZCBwb3RlbnRpYWxseSAnZW5kJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwOyAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cblxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUJ1ZmZlckdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7IC8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxuXG5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIHJlYWxIYXNJbnN0YW5jZShvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpOyAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFdyaXRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3kuXG5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufSAvLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5cblxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFKCkpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCgpOyAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG59IC8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cblxuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgZXI7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInXSwgY2h1bmspO1xuICB9XG5cbiAgaWYgKGVyKSB7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcbiAgaWYgKHN0YXRlLmVuZGluZykgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTsgLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cblxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG5cbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cblxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrOyAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cblxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpKTtlbHNlIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG5cbiAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcblxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCk7XG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKSB8fCBzdHJlYW0uZGVzdHJveWVkO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn0gLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5cblxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufSAvLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuXG5cbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcblxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpOyAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuXG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tOyAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3dyaXRlKCknKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpOyAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH0gLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuXG5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuXG4gICAgaWYgKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG5cbiAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAgIC8vIGlmIHRoZSByZWFkYWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcblxuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3MubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG5cbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH0gLy8gcmV1c2UgdGhlIGZyZWUgY29ya1JlcS5cblxuXG4gIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGZpbmlzaGVkID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG5cbnZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woJ2xhc3RSZXNvbHZlJyk7XG52YXIga0xhc3RSZWplY3QgPSBTeW1ib2woJ2xhc3RSZWplY3QnKTtcbnZhciBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG52YXIga0VuZGVkID0gU3ltYm9sKCdlbmRlZCcpO1xudmFyIGtMYXN0UHJvbWlzZSA9IFN5bWJvbCgnbGFzdFByb21pc2UnKTtcbnZhciBrSGFuZGxlUHJvbWlzZSA9IFN5bWJvbCgnaGFuZGxlUHJvbWlzZScpO1xudmFyIGtTdHJlYW0gPSBTeW1ib2woJ3N0cmVhbScpO1xuXG5mdW5jdGlvbiBjcmVhdGVJdGVyUmVzdWx0KHZhbHVlLCBkb25lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGRvbmU6IGRvbmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikge1xuICB2YXIgcmVzb2x2ZSA9IGl0ZXJba0xhc3RSZXNvbHZlXTtcblxuICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgIHZhciBkYXRhID0gaXRlcltrU3RyZWFtXS5yZWFkKCk7IC8vIHdlIGRlZmVyIGlmIGRhdGEgaXMgbnVsbFxuICAgIC8vIHdlIGNhbiBiZSBleHBlY3RpbmcgZWl0aGVyICdlbmQnIG9yXG4gICAgLy8gJ2Vycm9yJ1xuXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uUmVhZGFibGUoaXRlcikge1xuICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCB0aWNrLCBiZWNhdXNlIGl0IG1pZ2h0XG4gIC8vIGVtaXQgYW4gZXJyb3Igd2l0aCBwcm9jZXNzLm5leHRUaWNrXG4gIHByb2Nlc3MubmV4dFRpY2socmVhZEFuZFJlc29sdmUsIGl0ZXIpO1xufVxuXG5mdW5jdGlvbiB3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgaXRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGl0ZXJba0VuZGVkXSkge1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXRlcltrSGFuZGxlUHJvbWlzZV0ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9LCByZWplY3QpO1xuICB9O1xufVxuXG52YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbiAoKSB7fSk7XG52YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKChfT2JqZWN0JHNldFByb3RvdHlwZU8gPSB7XG4gIGdldCBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XG4gIH0sXG5cbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBkZXRlY3RlZCBhbiBlcnJvciBpbiB0aGUgbWVhbndoaWxlXG4gICAgLy8gcmVqZWN0IHN0cmFpZ2h0IGF3YXlcbiAgICB2YXIgZXJyb3IgPSB0aGlzW2tFcnJvcl07XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0VuZGVkXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tTdHJlYW1dLmRlc3Ryb3llZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBkZWZlciB2aWEgbmV4dFRpY2sgYmVjYXVzZSBpZiAuZGVzdHJveShlcnIpIGlzXG4gICAgICAvLyBjYWxsZWQsIHRoZSBlcnJvciB3aWxsIGJlIGVtaXR0ZWQgdmlhIG5leHRUaWNrLCBhbmRcbiAgICAgIC8vIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBubyBlcnJvciBsaW5nZXJpbmcgYXJvdW5kXG4gICAgICAvLyB3YWl0aW5nIHRvIGJlIGVtaXR0ZWQuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXNba0Vycm9yXSkge1xuICAgICAgICAgICAgcmVqZWN0KF90aGlzW2tFcnJvcl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBuZXh0KCkgY2FsbHNcbiAgICAvLyB3ZSB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBQcm9taXNlIHRvIGZpbmlzaFxuICAgIC8vIHRoaXMgbG9naWMgaXMgb3B0aW1pemVkIHRvIHN1cHBvcnQgZm9yIGF3YWl0IGxvb3BzLFxuICAgIC8vIHdoZXJlIG5leHQoKSBpcyBvbmx5IGNhbGxlZCBvbmNlIGF0IGEgdGltZVxuXG5cbiAgICB2YXIgbGFzdFByb21pc2UgPSB0aGlzW2tMYXN0UHJvbWlzZV07XG4gICAgdmFyIHByb21pc2U7XG5cbiAgICBpZiAobGFzdFByb21pc2UpIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYXN0IHBhdGggbmVlZGVkIHRvIHN1cHBvcnQgbXVsdGlwbGUgdGhpcy5wdXNoKClcbiAgICAgIC8vIHdpdGhvdXQgdHJpZ2dlcmluZyB0aGUgbmV4dCgpIHF1ZXVlXG4gICAgICB2YXIgZGF0YSA9IHRoaXNba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHRoaXNba0hhbmRsZVByb21pc2VdKTtcbiAgICB9XG5cbiAgICB0aGlzW2tMYXN0UHJvbWlzZV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRzZXRQcm90b3R5cGVPLCBcInJldHVyblwiLCBmdW5jdGlvbiBfcmV0dXJuKCkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAvLyBkZXN0cm95KGVyciwgY2IpIGlzIGEgcHJpdmF0ZSBBUElcbiAgLy8gd2UgY2FuIGd1YXJhbnRlZSB3ZSBoYXZlIHRoYXQgaGVyZSwgYmVjYXVzZSB3ZSBjb250cm9sIHRoZVxuICAvLyBSZWFkYWJsZSBjbGFzcyB0aGlzIGlzIGF0dGFjaGVkIHRvXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfSk7XG4gIH0pO1xufSksIF9PYmplY3Qkc2V0UHJvdG90eXBlTyksIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuXG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHN0cmVhbSkge1xuICB2YXIgX09iamVjdCRjcmVhdGU7XG5cbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIChfT2JqZWN0JGNyZWF0ZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtTdHJlYW0sIHtcbiAgICB2YWx1ZTogc3RyZWFtLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVzb2x2ZSwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVqZWN0LCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0Vycm9yLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0VuZGVkLCB7XG4gICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtIYW5kbGVQcm9taXNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGRhdGEgPSBpdGVyYXRvcltrU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gcmVzb2x2ZTtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gcmVqZWN0O1xuICAgICAgfVxuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9PYmplY3QkY3JlYXRlKSk7XG4gIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICBmaW5pc2hlZChzdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XG4gICAgICB2YXIgcmVqZWN0ID0gaXRlcmF0b3Jba0xhc3RSZWplY3RdOyAvLyByZWplY3QgaWYgd2UgYXJlIHdhaXRpbmcgZm9yIGRhdGEgaW4gdGhlIFByb21pc2VcbiAgICAgIC8vIHJldHVybmVkIGJ5IG5leHQoKSBhbmQgc3RvcmUgdGhlIGVycm9yXG5cbiAgICAgIGlmIChyZWplY3QgIT09IG51bGwpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0b3Jba0Vycm9yXSA9IGVycjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XG5cbiAgICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaXRlcmF0b3Jba0VuZGVkXSA9IHRydWU7XG4gIH0pO1xuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgb25SZWFkYWJsZS5iaW5kKG51bGwsIGl0ZXJhdG9yKSk7XG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yOyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnYnVmZmVyJyksXG4gICAgQnVmZmVyID0gX3JlcXVpcmUuQnVmZmVyO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgndXRpbCcpLFxuICAgIGluc3BlY3QgPSBfcmVxdWlyZTIuaW5zcGVjdDtcblxudmFyIGN1c3RvbSA9IGluc3BlY3QgJiYgaW5zcGVjdC5jdXN0b20gfHwgJ2luc3BlY3QnO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoc3JjLCB0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckxpc3QsIFt7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuc2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgIGRhdGE6IHYsXG4gICAgICAgIG5leHQ6IHRoaXMuaGVhZFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgICsrdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImpvaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gam9pbihzKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29uY2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgb3IgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uc3VtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25zdW1lKG4sIGhhc1N0cmluZ3MpIHtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIGlmIChuIDwgdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIGBzbGljZWAgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICAgIHJldCA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgICAgICB0aGlzLmhlYWQuZGF0YSA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICAgICAgfSBlbHNlIGlmIChuID09PSB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gRmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoLlxuICAgICAgICByZXQgPSB0aGlzLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXIuXG4gICAgICAgIHJldCA9IGhhc1N0cmluZ3MgPyB0aGlzLl9nZXRTdHJpbmcobikgOiB0aGlzLl9nZXRCdWZmZXIobik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0cmluZyhuKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHZhciByZXQgPSBwLmRhdGE7XG4gICAgICBuIC09IHJldC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgICAgIG4gLT0gbmI7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QnVmZmVyKG4pIHtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHAuZGF0YS5jb3B5KHJldCk7XG4gICAgICBuIC09IHAuZGF0YS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gTWFrZSBzdXJlIHRoZSBsaW5rZWQgbGlzdCBvbmx5IHNob3dzIHRoZSBtaW5pbWFsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbi5cblxuICB9LCB7XG4gICAga2V5OiBjdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKF8sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgLy8gT25seSBpbnNwZWN0IG9uZSBsZXZlbC5cbiAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgIC8vIEl0IHNob3VsZCBub3QgcmVjdXJzZS5cbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTsiLCIndXNlIHN0cmljdCc7IC8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcblxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9IC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcblxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGVtaXRDbG9zZU5UKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUgJiYgIXNlbGYuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIGlmIChzZWxmLl9yZWFkYWJsZVN0YXRlICYmICFzZWxmLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cbiAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHJTdGF0ZSAmJiByU3RhdGUuYXV0b0Rlc3Ryb3kgfHwgd1N0YXRlICYmIHdTdGF0ZS5hdXRvRGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koZXJyKTtlbHNlIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3k6IGVycm9yT3JEZXN0cm95XG59OyIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvZW5kLW9mLXN0cmVhbSB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cbid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0U7XG5cbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBlb3Moc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHJldHVybiBlb3Moc3RyZWFtLCBudWxsLCBvcHRzKTtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgdmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCBvcHRzLnJlYWRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ucmVhZGFibGU7XG4gIHZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgb3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlO1xuXG4gIHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uIG9ubGVnYWN5ZmluaXNoKCkge1xuICAgIGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuICB9O1xuXG4gIHZhciB3cml0YWJsZUVuZGVkID0gc3RyZWFtLl93cml0YWJsZVN0YXRlICYmIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZDtcblxuICB2YXIgb25maW5pc2ggPSBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgIHdyaXRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcblxuICB2YXIgcmVhZGFibGVFbmRlZCA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZDtcblxuICB2YXIgb25lbmQgPSBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgIHJlYWRhYmxlRW5kZWQgPSB0cnVlO1xuICAgIGlmICghd3JpdGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcbiAgfTtcblxuICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gIH07XG5cbiAgdmFyIG9uY2xvc2UgPSBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIHZhciBlcnI7XG5cbiAgICBpZiAocmVhZGFibGUgJiYgIXJlYWRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl9yZWFkYWJsZVN0YXRlIHx8ICFzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cblxuICAgIGlmICh3cml0YWJsZSAmJiAhd3JpdGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3dyaXRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbiBvbnJlcXVlc3QoKSB7XG4gICAgc3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICB9O1xuXG4gIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkge1xuICAgIHN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTtlbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gIH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSkge1xuICAgIC8vIGxlZ2FjeSBzdHJlYW1zXG4gICAgc3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgfVxuXG4gIHN0cmVhbS5vbignZW5kJywgb25lbmQpO1xuICBzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgaWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICAgIGlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVvczsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWFkYWJsZS5mcm9tIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXInKVxufTtcbiIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvcHVtcCB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVvcztcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUyxcbiAgICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVEO1xuXG5mdW5jdGlvbiBub29wKGVycikge1xuICAvLyBSZXRocm93IHRoZSBlcnJvciBpZiBpdCBleGlzdHMgdG8gYXZvaWQgc3dhbGxvd2luZyBpdFxuICBpZiAoZXJyKSB0aHJvdyBlcnI7XG59XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTtcbiAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsb3NlZCA9IHRydWU7XG4gIH0pO1xuICBpZiAoZW9zID09PSB1bmRlZmluZWQpIGVvcyA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuICBlb3Moc3RyZWFtLCB7XG4gICAgcmVhZGFibGU6IHJlYWRpbmcsXG4gICAgd3JpdGFibGU6IHdyaXRpbmdcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIGNsb3NlZCA9IHRydWU7XG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7IC8vIHJlcXVlc3QuZGVzdHJveSBqdXN0IGRvIC5lbmQgLSAuYWJvcnQgaXMgd2hhdCB3ZSB3YW50XG5cbiAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHJldHVybiBzdHJlYW0uYWJvcnQoKTtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gc3RyZWFtLmRlc3Ryb3koKTtcbiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdwaXBlJykpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjYWxsKGZuKSB7XG4gIGZuKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGUoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGZyb20ucGlwZSh0byk7XG59XG5cbmZ1bmN0aW9uIHBvcENhbGxiYWNrKHN0cmVhbXMpIHtcbiAgaWYgKCFzdHJlYW1zLmxlbmd0aCkgcmV0dXJuIG5vb3A7XG4gIGlmICh0eXBlb2Ygc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbm9vcDtcbiAgcmV0dXJuIHN0cmVhbXMucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RyZWFtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdHJlYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIGNhbGxiYWNrID0gcG9wQ2FsbGJhY2soc3RyZWFtcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0cmVhbXNbMF0pKSBzdHJlYW1zID0gc3RyZWFtc1swXTtcblxuICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ3N0cmVhbXMnKTtcbiAgfVxuXG4gIHZhciBlcnJvcjtcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xuICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgd3JpdGluZyA9IGkgPiAwO1xuICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBpZiAocmVhZGluZykgcmV0dXJuO1xuICAgICAgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzdHJlYW1zLnJlZHVjZShwaXBlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwaXBlbGluZTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfSU5WQUxJRF9PUFRfVkFMVUUgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfSU5WQUxJRF9PUFRfVkFMVUU7XG5cbmZ1bmN0aW9uIGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpIHtcbiAgcmV0dXJuIG9wdGlvbnMuaGlnaFdhdGVyTWFyayAhPSBudWxsID8gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrIDogaXNEdXBsZXggPyBvcHRpb25zW2R1cGxleEtleV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRIaWdoV2F0ZXJNYXJrKHN0YXRlLCBvcHRpb25zLCBkdXBsZXhLZXksIGlzRHVwbGV4KSB7XG4gIHZhciBod20gPSBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KTtcblxuICBpZiAoaHdtICE9IG51bGwpIHtcbiAgICBpZiAoIShpc0Zpbml0ZShod20pICYmIE1hdGguZmxvb3IoaHdtKSA9PT0gaHdtKSB8fCBod20gPCAwKSB7XG4gICAgICB2YXIgbmFtZSA9IGlzRHVwbGV4ID8gZHVwbGV4S2V5IDogJ2hpZ2hXYXRlck1hcmsnO1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX09QVF9WQUxVRShuYW1lLCBod20pO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLmZsb29yKGh3bSk7XG4gIH0gLy8gRGVmYXVsdCB2YWx1ZVxuXG5cbiAgcmV0dXJuIHN0YXRlLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEhpZ2hXYXRlck1hcms6IGdldEhpZ2hXYXRlck1hcmtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuZXhwb3J0cy5maW5pc2hlZCA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcycpO1xuZXhwb3J0cy5waXBlbGluZSA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMnKTtcbiIsIi8qISBydW4td2F0ZXJmYWxsLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5tb2R1bGUuZXhwb3J0cyA9IHJ1bldhdGVyZmFsbFxuXG5mdW5jdGlvbiBydW5XYXRlcmZhbGwgKHRhc2tzLCBjYikge1xuICB2YXIgY3VycmVudCA9IDBcbiAgdmFyIGlzU3luYyA9IHRydWVcblxuICBmdW5jdGlvbiBkb25lIChlcnIsIGFyZ3MpIHtcbiAgICBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgYXJncyA9IGFyZ3MgPyBbXS5jb25jYXQoZXJyLCBhcmdzKSA6IFtlcnJdXG4gICAgICBpZiAoY2IpIGNiLmFwcGx5KHVuZGVmaW5lZCwgYXJncylcbiAgICB9XG4gICAgaWYgKGlzU3luYykgcHJvY2Vzcy5uZXh0VGljayhlbmQpXG4gICAgZWxzZSBlbmQoKVxuICB9XG5cbiAgZnVuY3Rpb24gZWFjaCAoZXJyKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgaWYgKCsrY3VycmVudCA+PSB0YXNrcy5sZW5ndGggfHwgZXJyKSB7XG4gICAgICBkb25lKGVyciwgYXJncylcbiAgICB9IGVsc2Uge1xuICAgICAgdGFza3NbY3VycmVudF0uYXBwbHkodW5kZWZpbmVkLCBbXS5jb25jYXQoYXJncywgZWFjaCkpXG4gICAgfVxuICB9XG5cbiAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgIHRhc2tzWzBdKGVhY2gpXG4gIH0gZWxzZSB7XG4gICAgZG9uZShudWxsKVxuICB9XG5cbiAgaXNTeW5jID0gZmFsc2Vcbn1cbiIsIi8qISBzYWZlLWJ1ZmZlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSlcblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIgLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFNEUCBoZWxwZXJzLlxudmFyIFNEUFV0aWxzID0ge307XG5cbi8vIEdlbmVyYXRlIGFuIGFscGhhbnVtZXJpYyBpZGVudGlmaWVyIGZvciBjbmFtZSBvciBtaWRzLlxuLy8gVE9ETzogdXNlIFVVSURzIGluc3RlYWQ/IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcblNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDEwKTtcbn07XG5cbi8vIFRoZSBSVENQIENOQU1FIHVzZWQgYnkgYWxsIHBlZXJjb25uZWN0aW9ucyBmcm9tIHRoZSBzYW1lIEpTLlxuU0RQVXRpbHMubG9jYWxDTmFtZSA9IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuXG4vLyBTcGxpdHMgU0RQIGludG8gbGluZXMsIGRlYWxpbmcgd2l0aCBib3RoIENSTEYgYW5kIExGLlxuU0RQVXRpbHMuc3BsaXRMaW5lcyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgcmV0dXJuIGJsb2IudHJpbSgpLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgIHJldHVybiBsaW5lLnRyaW0oKTtcbiAgfSk7XG59O1xuLy8gU3BsaXRzIFNEUCBpbnRvIHNlc3Npb25wYXJ0IGFuZCBtZWRpYXNlY3Rpb25zLiBFbnN1cmVzIENSTEYuXG5TRFBVdGlscy5zcGxpdFNlY3Rpb25zID0gZnVuY3Rpb24oYmxvYikge1xuICB2YXIgcGFydHMgPSBibG9iLnNwbGl0KCdcXG5tPScpO1xuICByZXR1cm4gcGFydHMubWFwKGZ1bmN0aW9uKHBhcnQsIGluZGV4KSB7XG4gICAgcmV0dXJuIChpbmRleCA+IDAgPyAnbT0nICsgcGFydCA6IHBhcnQpLnRyaW0oKSArICdcXHJcXG4nO1xuICB9KTtcbn07XG5cbi8vIFJldHVybnMgbGluZXMgdGhhdCBzdGFydCB3aXRoIGEgY2VydGFpbiBwcmVmaXguXG5TRFBVdGlscy5tYXRjaFByZWZpeCA9IGZ1bmN0aW9uKGJsb2IsIHByZWZpeCkge1xuICByZXR1cm4gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgIHJldHVybiBsaW5lLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbiAgfSk7XG59O1xuXG4vLyBQYXJzZXMgYW4gSUNFIGNhbmRpZGF0ZSBsaW5lLiBTYW1wbGUgaW5wdXQ6XG4vLyBjYW5kaWRhdGU6NzAyNzg2MzUwIDIgdWRwIDQxODE5OTAyIDguOC44LjggNjA3NjkgdHlwIHJlbGF5IHJhZGRyIDguOC44Ljhcbi8vIHJwb3J0IDU1OTk2XCJcblNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHM7XG4gIC8vIFBhcnNlIGJvdGggdmFyaWFudHMuXG4gIGlmIChsaW5lLmluZGV4T2YoJ2E9Y2FuZGlkYXRlOicpID09PSAwKSB7XG4gICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMikuc3BsaXQoJyAnKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICB9XG5cbiAgdmFyIGNhbmRpZGF0ZSA9IHtcbiAgICBmb3VuZGF0aW9uOiBwYXJ0c1swXSxcbiAgICBjb21wb25lbnQ6IHBhcnRzWzFdLFxuICAgIHByb3RvY29sOiBwYXJ0c1syXS50b0xvd2VyQ2FzZSgpLFxuICAgIHByaW9yaXR5OiBwYXJzZUludChwYXJ0c1szXSwgMTApLFxuICAgIGlwOiBwYXJ0c1s0XSxcbiAgICBwb3J0OiBwYXJzZUludChwYXJ0c1s1XSwgMTApLFxuICAgIC8vIHNraXAgcGFydHNbNl0gPT0gJ3R5cCdcbiAgICB0eXBlOiBwYXJ0c1s3XVxuICB9O1xuXG4gIGZvciAodmFyIGkgPSA4OyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBzd2l0Y2ggKHBhcnRzW2ldKSB7XG4gICAgICBjYXNlICdyYWRkcic6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdycG9ydCc6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCA9IHBhcnNlSW50KHBhcnRzW2kgKyAxXSwgMTApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RjcHR5cGUnOlxuICAgICAgICBjYW5kaWRhdGUudGNwVHlwZSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBleHRlbnNpb24gaGFuZGxpbmcsIGluIHBhcnRpY3VsYXIgdWZyYWdcbiAgICAgICAgY2FuZGlkYXRlW3BhcnRzW2ldXSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5kaWRhdGU7XG59O1xuXG4vLyBUcmFuc2xhdGVzIGEgY2FuZGlkYXRlIG9iamVjdCBpbnRvIFNEUCBjYW5kaWRhdGUgYXR0cmlidXRlLlxuU0RQVXRpbHMud3JpdGVDYW5kaWRhdGUgPSBmdW5jdGlvbihjYW5kaWRhdGUpIHtcbiAgdmFyIHNkcCA9IFtdO1xuICBzZHAucHVzaChjYW5kaWRhdGUuZm91bmRhdGlvbik7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5jb21wb25lbnQpO1xuICBzZHAucHVzaChjYW5kaWRhdGUucHJvdG9jb2wudG9VcHBlckNhc2UoKSk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcmlvcml0eSk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5pcCk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5wb3J0KTtcblxuICB2YXIgdHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuICBzZHAucHVzaCgndHlwJyk7XG4gIHNkcC5wdXNoKHR5cGUpO1xuICBpZiAodHlwZSAhPT0gJ2hvc3QnICYmIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyAmJlxuICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KSB7XG4gICAgc2RwLnB1c2goJ3JhZGRyJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzKTsgLy8gd2FzOiByZWxBZGRyXG4gICAgc2RwLnB1c2goJ3Jwb3J0Jyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KTsgLy8gd2FzOiByZWxQb3J0XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZS50Y3BUeXBlICYmIGNhbmRpZGF0ZS5wcm90b2NvbC50b0xvd2VyQ2FzZSgpID09PSAndGNwJykge1xuICAgIHNkcC5wdXNoKCd0Y3B0eXBlJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnRjcFR5cGUpO1xuICB9XG4gIHJldHVybiAnY2FuZGlkYXRlOicgKyBzZHAuam9pbignICcpO1xufTtcblxuLy8gUGFyc2VzIGFuIGljZS1vcHRpb25zIGxpbmUsIHJldHVybnMgYW4gYXJyYXkgb2Ygb3B0aW9uIHRhZ3MuXG4vLyBhPWljZS1vcHRpb25zOmZvbyBiYXJcblNEUFV0aWxzLnBhcnNlSWNlT3B0aW9ucyA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgcmV0dXJuIGxpbmUuc3Vic3RyKDE0KS5zcGxpdCgnICcpO1xufVxuXG4vLyBQYXJzZXMgYW4gcnRwbWFwIGxpbmUsIHJldHVybnMgUlRDUnRwQ29kZGVjUGFyYW1ldGVycy4gU2FtcGxlIGlucHV0OlxuLy8gYT1ydHBtYXA6MTExIG9wdXMvNDgwMDAvMlxuU0RQVXRpbHMucGFyc2VSdHBNYXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDkpLnNwbGl0KCcgJyk7XG4gIHZhciBwYXJzZWQgPSB7XG4gICAgcGF5bG9hZFR5cGU6IHBhcnNlSW50KHBhcnRzLnNoaWZ0KCksIDEwKSAvLyB3YXM6IGlkXG4gIH07XG5cbiAgcGFydHMgPSBwYXJ0c1swXS5zcGxpdCgnLycpO1xuXG4gIHBhcnNlZC5uYW1lID0gcGFydHNbMF07XG4gIHBhcnNlZC5jbG9ja1JhdGUgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApOyAvLyB3YXM6IGNsb2NrcmF0ZVxuICAvLyB3YXM6IGNoYW5uZWxzXG4gIHBhcnNlZC5udW1DaGFubmVscyA9IHBhcnRzLmxlbmd0aCA9PT0gMyA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiAxO1xuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLy8gR2VuZXJhdGUgYW4gYT1ydHBtYXAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvclxuLy8gUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdHBNYXAgPSBmdW5jdGlvbihjb2RlYykge1xuICB2YXIgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIHJldHVybiAnYT1ydHBtYXA6JyArIHB0ICsgJyAnICsgY29kZWMubmFtZSArICcvJyArIGNvZGVjLmNsb2NrUmF0ZSArXG4gICAgICAoY29kZWMubnVtQ2hhbm5lbHMgIT09IDEgPyAnLycgKyBjb2RlYy5udW1DaGFubmVscyA6ICcnKSArICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIGFuIGE9ZXh0bWFwIGxpbmUgKGhlYWRlcmV4dGVuc2lvbiBmcm9tIFJGQyA1Mjg1KS4gU2FtcGxlIGlucHV0OlxuLy8gYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4vLyBhPWV4dG1hcDoyL3NlbmRvbmx5IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcblNEUFV0aWxzLnBhcnNlRXh0bWFwID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cig5KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGlkOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgIGRpcmVjdGlvbjogcGFydHNbMF0uaW5kZXhPZignLycpID4gMCA/IHBhcnRzWzBdLnNwbGl0KCcvJylbMV0gOiAnc2VuZHJlY3YnLFxuICAgIHVyaTogcGFydHNbMV1cbiAgfTtcbn07XG5cbi8vIEdlbmVyYXRlcyBhPWV4dG1hcCBsaW5lIGZyb20gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGVycyBvclxuLy8gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uLlxuU0RQVXRpbHMud3JpdGVFeHRtYXAgPSBmdW5jdGlvbihoZWFkZXJFeHRlbnNpb24pIHtcbiAgcmV0dXJuICdhPWV4dG1hcDonICsgKGhlYWRlckV4dGVuc2lvbi5pZCB8fCBoZWFkZXJFeHRlbnNpb24ucHJlZmVycmVkSWQpICtcbiAgICAgIChoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICYmIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kcmVjdidcbiAgICAgICAgICA/ICcvJyArIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb25cbiAgICAgICAgICA6ICcnKSArXG4gICAgICAnICcgKyBoZWFkZXJFeHRlbnNpb24udXJpICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgYW4gZnRtcCBsaW5lLCByZXR1cm5zIGRpY3Rpb25hcnkuIFNhbXBsZSBpbnB1dDpcbi8vIGE9Zm10cDo5NiB2YnI9b247Y25nPW9uXG4vLyBBbHNvIGRlYWxzIHdpdGggdmJyPW9uOyBjbmc9b25cblNEUFV0aWxzLnBhcnNlRm10cCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga3Y7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJzsnKTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7IGorKykge1xuICAgIGt2ID0gcGFydHNbal0udHJpbSgpLnNwbGl0KCc9Jyk7XG4gICAgcGFyc2VkW2t2WzBdLnRyaW0oKV0gPSBrdlsxXTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLy8gR2VuZXJhdGVzIGFuIGE9ZnRtcCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlRm10cCA9IGZ1bmN0aW9uKGNvZGVjKSB7XG4gIHZhciBsaW5lID0gJyc7XG4gIHZhciBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gIH1cbiAgaWYgKGNvZGVjLnBhcmFtZXRlcnMgJiYgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykubGVuZ3RoKSB7XG4gICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmZvckVhY2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIHBhcmFtcy5wdXNoKHBhcmFtICsgJz0nICsgY29kZWMucGFyYW1ldGVyc1twYXJhbV0pO1xuICAgIH0pO1xuICAgIGxpbmUgKz0gJ2E9Zm10cDonICsgcHQgKyAnICcgKyBwYXJhbXMuam9pbignOycpICsgJ1xcclxcbic7XG4gIH1cbiAgcmV0dXJuIGxpbmU7XG59O1xuXG4vLyBQYXJzZXMgYW4gcnRjcC1mYiBsaW5lLCByZXR1cm5zIFJUQ1BSdGNwRmVlZGJhY2sgb2JqZWN0LiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXJ0Y3AtZmI6OTggbmFjayBycHNpXG5TRFBVdGlscy5wYXJzZVJ0Y3BGYiA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHBhcnRzLnNoaWZ0KCksXG4gICAgcGFyYW1ldGVyOiBwYXJ0cy5qb2luKCcgJylcbiAgfTtcbn07XG4vLyBHZW5lcmF0ZSBhPXJ0Y3AtZmIgbGluZXMgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdGNwRmIgPSBmdW5jdGlvbihjb2RlYykge1xuICB2YXIgbGluZXMgPSAnJztcbiAgdmFyIHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBpZiAoY29kZWMucnRjcEZlZWRiYWNrICYmIGNvZGVjLnJ0Y3BGZWVkYmFjay5sZW5ndGgpIHtcbiAgICAvLyBGSVhNRTogc3BlY2lhbCBoYW5kbGluZyBmb3IgdHJyLWludD9cbiAgICBjb2RlYy5ydGNwRmVlZGJhY2suZm9yRWFjaChmdW5jdGlvbihmYikge1xuICAgICAgbGluZXMgKz0gJ2E9cnRjcC1mYjonICsgcHQgKyAnICcgKyBmYi50eXBlICtcbiAgICAgIChmYi5wYXJhbWV0ZXIgJiYgZmIucGFyYW1ldGVyLmxlbmd0aCA/ICcgJyArIGZiLnBhcmFtZXRlciA6ICcnKSArXG4gICAgICAgICAgJ1xcclxcbic7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxpbmVzO1xufTtcblxuLy8gUGFyc2VzIGFuIFJGQyA1NTc2IHNzcmMgbWVkaWEgYXR0cmlidXRlLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXNzcmM6MzczNTkyODU1OSBjbmFtZTpzb21ldGhpbmdcblNEUFV0aWxzLnBhcnNlU3NyY01lZGlhID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgc3AgPSBsaW5lLmluZGV4T2YoJyAnKTtcbiAgdmFyIHBhcnRzID0ge1xuICAgIHNzcmM6IHBhcnNlSW50KGxpbmUuc3Vic3RyKDcsIHNwIC0gNyksIDEwKVxuICB9O1xuICB2YXIgY29sb24gPSBsaW5lLmluZGV4T2YoJzonLCBzcCk7XG4gIGlmIChjb2xvbiA+IC0xKSB7XG4gICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHIoc3AgKyAxLCBjb2xvbiAtIHNwIC0gMSk7XG4gICAgcGFydHMudmFsdWUgPSBsaW5lLnN1YnN0cihjb2xvbiArIDEpO1xuICB9IGVsc2Uge1xuICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyKHNwICsgMSk7XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufTtcblxuLy8gRXh0cmFjdHMgdGhlIE1JRCAoUkZDIDU4ODgpIGZyb20gYSBtZWRpYSBzZWN0aW9uLlxuLy8gcmV0dXJucyB0aGUgTUlEIG9yIHVuZGVmaW5lZCBpZiBubyBtaWQgbGluZSB3YXMgZm91bmQuXG5TRFBVdGlscy5nZXRNaWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIG1pZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWlkOicpWzBdO1xuICBpZiAobWlkKSB7XG4gICAgcmV0dXJuIG1pZC5zdWJzdHIoNik7XG4gIH1cbn1cblxuU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIoMTQpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgYWxnb3JpdGhtOiBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLCAvLyBhbGdvcml0aG0gaXMgY2FzZS1zZW5zaXRpdmUgaW4gRWRnZS5cbiAgICB2YWx1ZTogcGFydHNbMV1cbiAgfTtcbn07XG5cbi8vIEV4dHJhY3RzIERUTFMgcGFyYW1ldGVycyBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4vLyAgIGdldCB0aGUgZmluZ2VycHJpbnQgbGluZSBhcyBpbnB1dC4gU2VlIGFsc28gZ2V0SWNlUGFyYW1ldGVycy5cblNEUFV0aWxzLmdldER0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICB2YXIgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAgICdhPWZpbmdlcnByaW50OicpO1xuICAvLyBOb3RlOiBhPXNldHVwIGxpbmUgaXMgaWdub3JlZCBzaW5jZSB3ZSB1c2UgdGhlICdhdXRvJyByb2xlLlxuICAvLyBOb3RlMjogJ2FsZ29yaXRobScgaXMgbm90IGNhc2Ugc2Vuc2l0aXZlIGV4Y2VwdCBpbiBFZGdlLlxuICByZXR1cm4ge1xuICAgIHJvbGU6ICdhdXRvJyxcbiAgICBmaW5nZXJwcmludHM6IGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUZpbmdlcnByaW50KVxuICB9O1xufTtcblxuLy8gU2VyaWFsaXplcyBEVExTIHBhcmFtZXRlcnMgdG8gU0RQLlxuU0RQVXRpbHMud3JpdGVEdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtcywgc2V0dXBUeXBlKSB7XG4gIHZhciBzZHAgPSAnYT1zZXR1cDonICsgc2V0dXBUeXBlICsgJ1xcclxcbic7XG4gIHBhcmFtcy5maW5nZXJwcmludHMuZm9yRWFjaChmdW5jdGlvbihmcCkge1xuICAgIHNkcCArPSAnYT1maW5nZXJwcmludDonICsgZnAuYWxnb3JpdGhtICsgJyAnICsgZnAudmFsdWUgKyAnXFxyXFxuJztcbiAgfSk7XG4gIHJldHVybiBzZHA7XG59O1xuLy8gUGFyc2VzIElDRSBpbmZvcm1hdGlvbiBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4vLyAgIGdldCB0aGUgaWNlLXVmcmFnIGFuZCBpY2UtcHdkIGxpbmVzIGFzIGlucHV0LlxuU0RQVXRpbHMuZ2V0SWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAvLyBTZWFyY2ggaW4gc2Vzc2lvbiBwYXJ0LCB0b28uXG4gIGxpbmVzID0gbGluZXMuY29uY2F0KFNEUFV0aWxzLnNwbGl0TGluZXMoc2Vzc2lvbnBhcnQpKTtcbiAgdmFyIGljZVBhcmFtZXRlcnMgPSB7XG4gICAgdXNlcm5hbWVGcmFnbWVudDogbGluZXMuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHJldHVybiBsaW5lLmluZGV4T2YoJ2E9aWNlLXVmcmFnOicpID09PSAwO1xuICAgIH0pWzBdLnN1YnN0cigxMiksXG4gICAgcGFzc3dvcmQ6IGxpbmVzLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICByZXR1cm4gbGluZS5pbmRleE9mKCdhPWljZS1wd2Q6JykgPT09IDA7XG4gICAgfSlbMF0uc3Vic3RyKDEwKVxuICB9O1xuICByZXR1cm4gaWNlUGFyYW1ldGVycztcbn07XG5cbi8vIFNlcmlhbGl6ZXMgSUNFIHBhcmFtZXRlcnMgdG8gU0RQLlxuU0RQVXRpbHMud3JpdGVJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiAnYT1pY2UtdWZyYWc6JyArIHBhcmFtcy51c2VybmFtZUZyYWdtZW50ICsgJ1xcclxcbicgK1xuICAgICAgJ2E9aWNlLXB3ZDonICsgcGFyYW1zLnBhc3N3b3JkICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIFJUQ1J0cFBhcmFtZXRlcnMuXG5TRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIGRlc2NyaXB0aW9uID0ge1xuICAgIGNvZGVjczogW10sXG4gICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgZmVjTWVjaGFuaXNtczogW10sXG4gICAgcnRjcDogW11cbiAgfTtcbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICB2YXIgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICBmb3IgKHZhciBpID0gMzsgaSA8IG1saW5lLmxlbmd0aDsgaSsrKSB7IC8vIGZpbmQgYWxsIGNvZGVjcyBmcm9tIG1saW5lWzMuLl1cbiAgICB2YXIgcHQgPSBtbGluZVtpXTtcbiAgICB2YXIgcnRwbWFwbGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0cG1hcDonICsgcHQgKyAnICcpWzBdO1xuICAgIGlmIChydHBtYXBsaW5lKSB7XG4gICAgICB2YXIgY29kZWMgPSBTRFBVdGlscy5wYXJzZVJ0cE1hcChydHBtYXBsaW5lKTtcbiAgICAgIHZhciBmbXRwcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICAgIG1lZGlhU2VjdGlvbiwgJ2E9Zm10cDonICsgcHQgKyAnICcpO1xuICAgICAgLy8gT25seSB0aGUgZmlyc3QgYT1mbXRwOjxwdD4gaXMgY29uc2lkZXJlZC5cbiAgICAgIGNvZGVjLnBhcmFtZXRlcnMgPSBmbXRwcy5sZW5ndGggPyBTRFBVdGlscy5wYXJzZUZtdHAoZm10cHNbMF0pIDoge307XG4gICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnKVxuICAgICAgICAubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICAgIC8vIHBhcnNlIEZFQyBtZWNoYW5pc21zIGZyb20gcnRwbWFwIGxpbmVzLlxuICAgICAgc3dpdGNoIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnUkVEJzpcbiAgICAgICAgY2FzZSAnVUxQRkVDJzpcbiAgICAgICAgICBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLnB1c2goY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gb25seSBSRUQgYW5kIFVMUEZFQyBhcmUgcmVjb2duaXplZCBhcyBGRUMgbWVjaGFuaXNtcy5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1leHRtYXA6JykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgZGVzY3JpcHRpb24uaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKFNEUFV0aWxzLnBhcnNlRXh0bWFwKGxpbmUpKTtcbiAgfSk7XG4gIC8vIEZJWE1FOiBwYXJzZSBydGNwLlxuICByZXR1cm4gZGVzY3JpcHRpb247XG59O1xuXG4vLyBHZW5lcmF0ZXMgcGFydHMgb2YgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGRlc2NyaWJpbmcgdGhlIGNhcGFiaWxpdGllcyAvXG4vLyBwYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGtpbmQsIGNhcHMpIHtcbiAgdmFyIHNkcCA9ICcnO1xuXG4gIC8vIEJ1aWxkIHRoZSBtbGluZS5cbiAgc2RwICs9ICdtPScgKyBraW5kICsgJyAnO1xuICBzZHAgKz0gY2Fwcy5jb2RlY3MubGVuZ3RoID4gMCA/ICc5JyA6ICcwJzsgLy8gcmVqZWN0IGlmIG5vIGNvZGVjcy5cbiAgc2RwICs9ICcgVURQL1RMUy9SVFAvU0FWUEYgJztcbiAgc2RwICs9IGNhcHMuY29kZWNzLm1hcChmdW5jdGlvbihjb2RlYykge1xuICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gICAgfVxuICAgIHJldHVybiBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgfSkuam9pbignICcpICsgJ1xcclxcbic7XG5cbiAgc2RwICs9ICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJztcbiAgc2RwICs9ICdhPXJ0Y3A6OSBJTiBJUDQgMC4wLjAuMFxcclxcbic7XG5cbiAgLy8gQWRkIGE9cnRwbWFwIGxpbmVzIGZvciBlYWNoIGNvZGVjLiBBbHNvIGZtdHAgYW5kIHJ0Y3AtZmIuXG4gIGNhcHMuY29kZWNzLmZvckVhY2goZnVuY3Rpb24oY29kZWMpIHtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdHBNYXAoY29kZWMpO1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUZtdHAoY29kZWMpO1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0Y3BGYihjb2RlYyk7XG4gIH0pO1xuICB2YXIgbWF4cHRpbWUgPSAwO1xuICBjYXBzLmNvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgaWYgKGNvZGVjLm1heHB0aW1lID4gbWF4cHRpbWUpIHtcbiAgICAgIG1heHB0aW1lID0gY29kZWMubWF4cHRpbWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKG1heHB0aW1lID4gMCkge1xuICAgIHNkcCArPSAnYT1tYXhwdGltZTonICsgbWF4cHRpbWUgKyAnXFxyXFxuJztcbiAgfVxuICBzZHAgKz0gJ2E9cnRjcC1tdXhcXHJcXG4nO1xuXG4gIGNhcHMuaGVhZGVyRXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUV4dG1hcChleHRlbnNpb24pO1xuICB9KTtcbiAgLy8gRklYTUU6IHdyaXRlIGZlY01lY2hhbmlzbXMuXG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mXG4vLyBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnMuXG5TRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgZW5jb2RpbmdQYXJhbWV0ZXJzID0gW107XG4gIHZhciBkZXNjcmlwdGlvbiA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICB2YXIgaGFzUmVkID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdSRUQnKSAhPT0gLTE7XG4gIHZhciBoYXNVbHBmZWMgPSBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLmluZGV4T2YoJ1VMUEZFQycpICE9PSAtMTtcblxuICAvLyBmaWx0ZXIgYT1zc3JjOi4uLiBjbmFtZTosIGlnbm9yZSBQbGFuQi1tc2lkXG4gIHZhciBzc3JjcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICByZXR1cm4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSk7XG4gIH0pXG4gIC5maWx0ZXIoZnVuY3Rpb24ocGFydHMpIHtcbiAgICByZXR1cm4gcGFydHMuYXR0cmlidXRlID09PSAnY25hbWUnO1xuICB9KTtcbiAgdmFyIHByaW1hcnlTc3JjID0gc3NyY3MubGVuZ3RoID4gMCAmJiBzc3Jjc1swXS5zc3JjO1xuICB2YXIgc2Vjb25kYXJ5U3NyYztcblxuICB2YXIgZmxvd3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmMtZ3JvdXA6RklEJylcbiAgLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnICcpO1xuICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHBhcnRzLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQocGFydCwgMTApO1xuICAgIH0pO1xuICB9KTtcbiAgaWYgKGZsb3dzLmxlbmd0aCA+IDAgJiYgZmxvd3NbMF0ubGVuZ3RoID4gMSAmJiBmbG93c1swXVswXSA9PT0gcHJpbWFyeVNzcmMpIHtcbiAgICBzZWNvbmRhcnlTc3JjID0gZmxvd3NbMF1bMV07XG4gIH1cblxuICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjb2RlYykge1xuICAgIGlmIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdSVFgnICYmIGNvZGVjLnBhcmFtZXRlcnMuYXB0KSB7XG4gICAgICB2YXIgZW5jUGFyYW0gPSB7XG4gICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICBjb2RlY1BheWxvYWRUeXBlOiBwYXJzZUludChjb2RlYy5wYXJhbWV0ZXJzLmFwdCwgMTApLFxuICAgICAgICBydHg6IHtcbiAgICAgICAgICBzc3JjOiBzZWNvbmRhcnlTc3JjXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICBpZiAoaGFzUmVkKSB7XG4gICAgICAgIGVuY1BhcmFtID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbmNQYXJhbSkpO1xuICAgICAgICBlbmNQYXJhbS5mZWMgPSB7XG4gICAgICAgICAgc3NyYzogc2Vjb25kYXJ5U3NyYyxcbiAgICAgICAgICBtZWNoYW5pc206IGhhc1VscGZlYyA/ICdyZWQrdWxwZmVjJyA6ICdyZWQnXG4gICAgICAgIH07XG4gICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAoZW5jb2RpbmdQYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMCAmJiBwcmltYXJ5U3NyYykge1xuICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKHtcbiAgICAgIHNzcmM6IHByaW1hcnlTc3JjXG4gICAgfSk7XG4gIH1cblxuICAvLyB3ZSBzdXBwb3J0IGJvdGggYj1BUyBhbmQgYj1USUFTIGJ1dCBpbnRlcnByZXQgQVMgYXMgVElBUy5cbiAgdmFyIGJhbmR3aWR0aCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2I9Jyk7XG4gIGlmIChiYW5kd2lkdGgubGVuZ3RoKSB7XG4gICAgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPVRJQVM6JykgPT09IDApIHtcbiAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHIoNyksIDEwKTtcbiAgICB9IGVsc2UgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPUFTOicpID09PSAwKSB7XG4gICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyKDUpLCAxMCk7XG4gICAgfVxuICAgIGVuY29kaW5nUGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgcGFyYW1zLm1heEJpdHJhdGUgPSBiYW5kd2lkdGg7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nUGFyYW1ldGVycztcbn07XG5cbi8vIHBhcnNlcyBodHRwOi8vZHJhZnQub3J0Yy5vcmcvI3J0Y3J0Y3BwYXJhbWV0ZXJzKlxuU0RQVXRpbHMucGFyc2VSdGNwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgcnRjcFBhcmFtZXRlcnMgPSB7fTtcblxuICB2YXIgY25hbWU7XG4gIC8vIEdldHMgdGhlIGZpcnN0IFNTUkMuIE5vdGUgdGhhdCB3aXRoIFJUWCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZVxuICAvLyBTU1JDcy5cbiAgdmFyIHJlbW90ZVNzcmMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAgIC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICByZXR1cm4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iai5hdHRyaWJ1dGUgPT09ICdjbmFtZSc7XG4gICAgICB9KVswXTtcbiAgaWYgKHJlbW90ZVNzcmMpIHtcbiAgICBydGNwUGFyYW1ldGVycy5jbmFtZSA9IHJlbW90ZVNzcmMudmFsdWU7XG4gICAgcnRjcFBhcmFtZXRlcnMuc3NyYyA9IHJlbW90ZVNzcmMuc3NyYztcbiAgfVxuXG4gIC8vIEVkZ2UgdXNlcyB0aGUgY29tcG91bmQgYXR0cmlidXRlIGluc3RlYWQgb2YgcmVkdWNlZFNpemVcbiAgLy8gY29tcG91bmQgaXMgIXJlZHVjZWRTaXplXG4gIHZhciByc2l6ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1yc2l6ZScpO1xuICBydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSA9IHJzaXplLmxlbmd0aCA+IDA7XG4gIHJ0Y3BQYXJhbWV0ZXJzLmNvbXBvdW5kID0gcnNpemUubGVuZ3RoID09PSAwO1xuXG4gIC8vIHBhcnNlcyB0aGUgcnRjcC1tdXggYXR0ctGWYnV0ZS5cbiAgLy8gTm90ZSB0aGF0IEVkZ2UgZG9lcyBub3Qgc3VwcG9ydCB1bm11eGVkIFJUQ1AuXG4gIHZhciBtdXggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtbXV4Jyk7XG4gIHJ0Y3BQYXJhbWV0ZXJzLm11eCA9IG11eC5sZW5ndGggPiAwO1xuXG4gIHJldHVybiBydGNwUGFyYW1ldGVycztcbn07XG5cbi8vIHBhcnNlcyBlaXRoZXIgYT1tc2lkOiBvciBhPXNzcmM6Li4uIG1zaWQgbGluZXMgYW5kIHJldHVybnNcbi8vIHRoZSBpZCBvZiB0aGUgTWVkaWFTdHJlYW0gYW5kIE1lZGlhU3RyZWFtVHJhY2suXG5TRFBVdGlscy5wYXJzZU1zaWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIHBhcnRzO1xuICB2YXIgc3BlYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bXNpZDonKTtcbiAgaWYgKHNwZWMubGVuZ3RoID09PSAxKSB7XG4gICAgcGFydHMgPSBzcGVjWzBdLnN1YnN0cig3KS5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7c3RyZWFtOiBwYXJ0c1swXSwgdHJhY2s6IHBhcnRzWzFdfTtcbiAgfVxuICB2YXIgcGxhbkIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgcmV0dXJuIFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpO1xuICB9KVxuICAuZmlsdGVyKGZ1bmN0aW9uKHBhcnRzKSB7XG4gICAgcmV0dXJuIHBhcnRzLmF0dHJpYnV0ZSA9PT0gJ21zaWQnO1xuICB9KTtcbiAgaWYgKHBsYW5CLmxlbmd0aCA+IDApIHtcbiAgICBwYXJ0cyA9IHBsYW5CWzBdLnZhbHVlLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtzdHJlYW06IHBhcnRzWzBdLCB0cmFjazogcGFydHNbMV19O1xuICB9XG59O1xuXG5TRFBVdGlscy53cml0ZVNlc3Npb25Cb2lsZXJwbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBGSVhNRTogc2Vzcy1pZCBzaG91bGQgYmUgYW4gTlRQIHRpbWVzdGFtcC5cbiAgcmV0dXJuICd2PTBcXHJcXG4nICtcbiAgICAgICdvPXRoaXNpc2FkYXB0ZXJvcnRjIDgxNjk2Mzk5MTU2NDY5NDMxMzcgMiBJTiBJUDQgMTI3LjAuMC4xXFxyXFxuJyArXG4gICAgICAncz0tXFxyXFxuJyArXG4gICAgICAndD0wIDBcXHJcXG4nO1xufTtcblxuU0RQVXRpbHMud3JpdGVNZWRpYVNlY3Rpb24gPSBmdW5jdGlvbih0cmFuc2NlaXZlciwgY2FwcywgdHlwZSwgc3RyZWFtKSB7XG4gIHZhciBzZHAgPSBTRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uKHRyYW5zY2VpdmVyLmtpbmQsIGNhcHMpO1xuXG4gIC8vIE1hcCBJQ0UgcGFyYW1ldGVycyAodWZyYWcsIHB3ZCkgdG8gU0RQLlxuICBzZHAgKz0gU0RQVXRpbHMud3JpdGVJY2VQYXJhbWV0ZXJzKFxuICAgICAgdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIuZ2V0TG9jYWxQYXJhbWV0ZXJzKCkpO1xuXG4gIC8vIE1hcCBEVExTIHBhcmFtZXRlcnMgdG8gU0RQLlxuICBzZHAgKz0gU0RQVXRpbHMud3JpdGVEdGxzUGFyYW1ldGVycyhcbiAgICAgIHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQuZ2V0TG9jYWxQYXJhbWV0ZXJzKCksXG4gICAgICB0eXBlID09PSAnb2ZmZXInID8gJ2FjdHBhc3MnIDogJ2FjdGl2ZScpO1xuXG4gIHNkcCArPSAnYT1taWQ6JyArIHRyYW5zY2VpdmVyLm1pZCArICdcXHJcXG4nO1xuXG4gIGlmICh0cmFuc2NlaXZlci5kaXJlY3Rpb24pIHtcbiAgICBzZHAgKz0gJ2E9JyArIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiArICdcXHJcXG4nO1xuICB9IGVsc2UgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlciAmJiB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcikge1xuICAgIHNkcCArPSAnYT1zZW5kcmVjdlxcclxcbic7XG4gIH0gZWxzZSBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyKSB7XG4gICAgc2RwICs9ICdhPXNlbmRvbmx5XFxyXFxuJztcbiAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5ydHBSZWNlaXZlcikge1xuICAgIHNkcCArPSAnYT1yZWN2b25seVxcclxcbic7XG4gIH0gZWxzZSB7XG4gICAgc2RwICs9ICdhPWluYWN0aXZlXFxyXFxuJztcbiAgfVxuXG4gIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIpIHtcbiAgICAvLyBzcGVjLlxuICAgIHZhciBtc2lkID0gJ21zaWQ6JyArIHN0cmVhbS5pZCArICcgJyArXG4gICAgICAgIHRyYW5zY2VpdmVyLnJ0cFNlbmRlci50cmFjay5pZCArICdcXHJcXG4nO1xuICAgIHNkcCArPSAnYT0nICsgbXNpZDtcblxuICAgIC8vIGZvciBDaHJvbWUuXG4gICAgc2RwICs9ICdhPXNzcmM6JyArIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYyArXG4gICAgICAgICcgJyArIG1zaWQ7XG4gICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4KSB7XG4gICAgICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHguc3NyYyArXG4gICAgICAgICAgJyAnICsgbXNpZDtcbiAgICAgIHNkcCArPSAnYT1zc3JjLWdyb3VwOkZJRCAnICtcbiAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmMgKyAnICcgK1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4LnNzcmMgK1xuICAgICAgICAgICdcXHJcXG4nO1xuICAgIH1cbiAgfVxuICAvLyBGSVhNRTogdGhpcyBzaG91bGQgYmUgd3JpdHRlbiBieSB3cml0ZVJ0cERlc2NyaXB0aW9uLlxuICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjICtcbiAgICAgICcgY25hbWU6JyArIFNEUFV0aWxzLmxvY2FsQ05hbWUgKyAnXFxyXFxuJztcbiAgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlciAmJiB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eCkge1xuICAgIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eC5zc3JjICtcbiAgICAgICAgJyBjbmFtZTonICsgU0RQVXRpbHMubG9jYWxDTmFtZSArICdcXHJcXG4nO1xuICB9XG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBHZXRzIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGUgbWVkaWFTZWN0aW9uIG9yIHRoZSBzZXNzaW9ucGFydC5cblNEUFV0aWxzLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgLy8gTG9vayBmb3Igc2VuZHJlY3YsIHNlbmRvbmx5LCByZWN2b25seSwgaW5hY3RpdmUsIGRlZmF1bHQgdG8gc2VuZHJlY3YuXG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHN3aXRjaCAobGluZXNbaV0pIHtcbiAgICAgIGNhc2UgJ2E9c2VuZHJlY3YnOlxuICAgICAgY2FzZSAnYT1zZW5kb25seSc6XG4gICAgICBjYXNlICdhPXJlY3Zvbmx5JzpcbiAgICAgIGNhc2UgJ2E9aW5hY3RpdmUnOlxuICAgICAgICByZXR1cm4gbGluZXNbaV0uc3Vic3RyKDIpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRklYTUU6IFdoYXQgc2hvdWxkIGhhcHBlbiBoZXJlP1xuICAgIH1cbiAgfVxuICBpZiAoc2Vzc2lvbnBhcnQpIHtcbiAgICByZXR1cm4gU0RQVXRpbHMuZ2V0RGlyZWN0aW9uKHNlc3Npb25wYXJ0KTtcbiAgfVxuICByZXR1cm4gJ3NlbmRyZWN2Jztcbn07XG5cblNEUFV0aWxzLmdldEtpbmQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICB2YXIgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICByZXR1cm4gbWxpbmVbMF0uc3Vic3RyKDIpO1xufTtcblxuU0RQVXRpbHMuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICByZXR1cm4gbWVkaWFTZWN0aW9uLnNwbGl0KCcgJywgMilbMV0gPT09ICcwJztcbn07XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbm1vZHVsZS5leHBvcnRzID0gU0RQVXRpbHM7XG4iLCIvKipcbiAqIENyZWF0ZWQgYnkgU2FtdWVsIG9uIDYvNC8yMDE2LlxuICogU2ltcGxlIHdyYXBwZXIgZnVuY3Rpb25zIHRvIHByb2R1Y2Ugc2hvcnRlciBVVUlEcyBmb3IgY29va2llcywgbWF5YmUgZXZlcnl0aGluZz9cbiAqL1xuXG5jb25zdCB7IHY0OiB1dWlkdjQgfSA9IHJlcXVpcmUoJ3V1aWQnKTtcbmNvbnN0IGFueUJhc2UgPSByZXF1aXJlKCdhbnktYmFzZScpO1xuXG5jb25zdCBmbGlja3JCYXNlNTggPSAnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWic7XG5jb25zdCBjb29raWVCYXNlOTAgPSBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaISMkJSYnKCkqKy0uLzo8PT4/QFtdXl9ge3x9flwiO1xuXG5jb25zdCBiYXNlT3B0aW9ucyA9IHtcbiAgY29uc2lzdGVudExlbmd0aDogdHJ1ZSxcbn07XG5cbi8vIEEgZGVmYXVsdCBnZW5lcmF0b3IsIGluc3RhbnRpYXRlZCBvbmx5IGlmIHVzZWQuXG5sZXQgdG9GbGlja3I7XG5cbi8qKlxuICogVGFrZXMgYSBVVUlELCBzdHJpcHMgdGhlIGRhc2hlcywgYW5kIHRyYW5zbGF0ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9uZ0lkXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyl9IHRyYW5zbGF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFkZGluZ1BhcmFtc11cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHNob3J0ZW5VVUlEID0gKGxvbmdJZCwgdHJhbnNsYXRvciwgcGFkZGluZ1BhcmFtcykgPT4ge1xuICBjb25zdCB0cmFuc2xhdGVkID0gdHJhbnNsYXRvcihsb25nSWQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tL2csICcnKSk7XG5cbiAgaWYgKCFwYWRkaW5nUGFyYW1zIHx8ICFwYWRkaW5nUGFyYW1zLmNvbnNpc3RlbnRMZW5ndGgpIHJldHVybiB0cmFuc2xhdGVkO1xuXG4gIHJldHVybiB0cmFuc2xhdGVkLnBhZFN0YXJ0KFxuICAgIHBhZGRpbmdQYXJhbXMuc2hvcnRJZExlbmd0aCxcbiAgICBwYWRkaW5nUGFyYW1zLnBhZGRpbmdDaGFyLFxuICApO1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYmFjayB0byBoZXggYW5kIHR1cm4gYmFjayBpbnRvIFVVSUQgZm9ybWF0LCB3aXRoIGRhc2hlc1xuICogQHBhcmFtIHtzdHJpbmd9IHNob3J0SWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nKX0gdHJhbnNsYXRvclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgZW5sYXJnZVVVSUQgPSAoc2hvcnRJZCwgdHJhbnNsYXRvcikgPT4ge1xuICBjb25zdCB1dTEgPSB0cmFuc2xhdG9yKHNob3J0SWQpLnBhZFN0YXJ0KDMyLCAnMCcpO1xuXG4gIC8vIEpvaW4gdGhlIHplcm8gcGFkZGluZyBhbmQgdGhlIFVVSUQgYW5kIHRoZW4gc2xpY2UgaXQgdXAgd2l0aCBtYXRjaFxuICBjb25zdCBtID0gdXUxLm1hdGNoKC8oXFx3ezh9KShcXHd7NH0pKFxcd3s0fSkoXFx3ezR9KShcXHd7MTJ9KS8pO1xuXG4gIC8vIEFjY3VtdWxhdGUgdGhlIG1hdGNoZXMgYW5kIGpvaW4gdGhlbS5cbiAgcmV0dXJuIFttWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdXS5qb2luKCctJyk7XG59O1xuXG4vLyBDYWxjdWxhdGUgbGVuZ3RoIGZvciB0aGUgc2hvcnRlbmVkIElEXG5jb25zdCBnZXRTaG9ydElkTGVuZ3RoID0gKGFscGhhYmV0TGVuZ3RoKSA9PiAoXG4gIE1hdGguY2VpbChNYXRoLmxvZygyICoqIDEyOCkgLyBNYXRoLmxvZyhhbHBoYWJldExlbmd0aCkpKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoKCkgPT4ge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvQWxwaGFiZXQgLSBEZWZhdWx0cyB0byBmbGlja3JCYXNlNTggaWYgbm90IHByb3ZpZGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICpcbiAgICogQHJldHVybnMge3tuZXc6IChmdW5jdGlvbigpKSxcbiAgICogIHV1aWQ6IChmdW5jdGlvbigpKSxcbiAgICogIGZyb21VVUlEOiAoZnVuY3Rpb24oc3RyaW5nKSksXG4gICAqICB0b1VVSUQ6IChmdW5jdGlvbihzdHJpbmcpKSxcbiAgICogIGFscGhhYmV0OiAoc3RyaW5nKX19XG4gICAqL1xuICBjb25zdCBtYWtlQ29udmVydG9yID0gKHRvQWxwaGFiZXQsIG9wdGlvbnMpID0+IHtcbiAgICAvLyBEZWZhdWx0IHRvIEZsaWNrciA1OFxuICAgIGNvbnN0IHVzZUFscGhhYmV0ID0gdG9BbHBoYWJldCB8fCBmbGlja3JCYXNlNTg7XG5cbiAgICAvLyBEZWZhdWx0IHRvIGJhc2VPcHRpb25zXG4gICAgY29uc3Qgc2VsZWN0ZWRPcHRpb25zID0geyAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuXG4gICAgLy8gQ2hlY2sgYWxwaGFiZXQgZm9yIGR1cGxpY2F0ZSBlbnRyaWVzXG4gICAgaWYgKFsuLi5uZXcgU2V0KEFycmF5LmZyb20odXNlQWxwaGFiZXQpKV0ubGVuZ3RoICE9PSB1c2VBbHBoYWJldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIEFscGhhYmV0IGhhcyBkdXBsaWNhdGUgY2hhcmFjdGVycyByZXN1bHRpbmcgaW4gdW5yZWxpYWJsZSByZXN1bHRzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2hvcnRJZExlbmd0aCA9IGdldFNob3J0SWRMZW5ndGgodXNlQWxwaGFiZXQubGVuZ3RoKTtcblxuICAgIC8vIFBhZGRpbmcgUGFyYW1zXG4gICAgY29uc3QgcGFkZGluZ1BhcmFtcyA9IHtcbiAgICAgIHNob3J0SWRMZW5ndGgsXG4gICAgICBjb25zaXN0ZW50TGVuZ3RoOiBzZWxlY3RlZE9wdGlvbnMuY29uc2lzdGVudExlbmd0aCxcbiAgICAgIHBhZGRpbmdDaGFyOiB1c2VBbHBoYWJldFswXSxcbiAgICB9O1xuXG4gICAgLy8gVVVJRHMgYXJlIGluIGhleCwgc28gd2UgdHJhbnNsYXRlIHRvIGFuZCBmcm9tLlxuICAgIGNvbnN0IGZyb21IZXggPSBhbnlCYXNlKGFueUJhc2UuSEVYLCB1c2VBbHBoYWJldCk7XG4gICAgY29uc3QgdG9IZXggPSBhbnlCYXNlKHVzZUFscGhhYmV0LCBhbnlCYXNlLkhFWCk7XG4gICAgY29uc3QgZ2VuZXJhdGUgPSAoKSA9PiBzaG9ydGVuVVVJRCh1dWlkdjQoKSwgZnJvbUhleCwgcGFkZGluZ1BhcmFtcyk7XG5cbiAgICBjb25zdCB0cmFuc2xhdG9yID0ge1xuICAgICAgbmV3OiBnZW5lcmF0ZSxcbiAgICAgIGdlbmVyYXRlLFxuICAgICAgdXVpZDogdXVpZHY0LFxuICAgICAgZnJvbVVVSUQ6ICh1dWlkKSA9PiBzaG9ydGVuVVVJRCh1dWlkLCBmcm9tSGV4LCBwYWRkaW5nUGFyYW1zKSxcbiAgICAgIHRvVVVJRDogKHNob3J0VXVpZCkgPT4gZW5sYXJnZVVVSUQoc2hvcnRVdWlkLCB0b0hleCksXG4gICAgICBhbHBoYWJldDogdXNlQWxwaGFiZXQsXG4gICAgICBtYXhMZW5ndGg6IHNob3J0SWRMZW5ndGgsXG4gICAgfTtcblxuICAgIE9iamVjdC5mcmVlemUodHJhbnNsYXRvcik7XG5cbiAgICByZXR1cm4gdHJhbnNsYXRvcjtcbiAgfTtcblxuICAvLyBFeHBvc2UgdGhlIGNvbnN0YW50cyBmb3Igb3RoZXIgcHVycG9zZXMuXG4gIG1ha2VDb252ZXJ0b3IuY29uc3RhbnRzID0ge1xuICAgIGZsaWNrckJhc2U1OCxcbiAgICBjb29raWVCYXNlOTAsXG4gIH07XG5cbiAgLy8gRXhwb3NlIHRoZSBnZW5lcmljIHY0IFVVSUQgZ2VuZXJhdG9yIGZvciBjb252ZW5pZW5jZVxuICBtYWtlQ29udmVydG9yLnV1aWQgPSB1dWlkdjQ7XG5cbiAgLy8gUHJvdmlkZSBhIGdlbmVyaWMgZ2VuZXJhdG9yXG4gIG1ha2VDb252ZXJ0b3IuZ2VuZXJhdGUgPSAoKSA9PiB7XG4gICAgaWYgKCF0b0ZsaWNrcikge1xuICAgICAgLy8gR2VuZXJhdGUgb24gZmlyc3QgdXNlO1xuICAgICAgdG9GbGlja3IgPSBtYWtlQ29udmVydG9yKGZsaWNrckJhc2U1OCkuZ2VuZXJhdGU7XG4gICAgfVxuICAgIHJldHVybiB0b0ZsaWNrcigpO1xuICB9O1xuXG4gIHJldHVybiBtYWtlQ29udmVydG9yO1xufSkoKTtcbiIsInZhciBlc3MgPSByZXF1aXJlKCdldmVudC1zb3VyY2Utc3RyZWFtJylcbnZhciBuZXRzID0gcmVxdWlyZSgnbmV0cycpXG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJsLCBhcHApIHtcbiAgaWYgKCF1cmwpIHRocm93IG5ldyBFcnJvcignc2lnbmFsaHViIHVybCByZXF1aXJlZCcpXG4gIGlmICghYXBwKSB0aHJvdyBuZXcgRXJyb3IoJ2FwcCBuYW1lIHJlcXVpcmVkIGFzIDJuZCBhcmd1bWVudCcpXG4gIHZhciB0aGF0ID0ge31cblxuICBpZiAodXJsLmluZGV4T2YoJzovLycpID09PSAtMSkgdXJsID0gJ2h0dHA6Ly8nICsgdXJsXG5cbiAgdGhhdC5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgIHJldHVybiBlc3ModXJsICsgJy92MS8nICsgYXBwICsgJy8nICsgY2hhbm5lbCwge2pzb246IHRydWV9KVxuICB9XG5cbiAgdGhhdC5icm9hZGNhc3QgPSBmdW5jdGlvbiAoY2hhbm5lbCwgbWVzc2FnZSwgY2IpIHtcbiAgICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgICBuZXRzKHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAganNvbjogbWVzc2FnZSxcbiAgICAgIHVybDogdXJsICsgJy92MS8nICsgYXBwICsgJy8nICsgY2hhbm5lbFxuICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSAhPT0gMjAwKSByZXR1cm4gY2IobmV3IEVycm9yKCdCYWQgc3RhdHVzOiAnICsgcmVzLnN0YXR1c0NvZGUpKVxuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuIiwidmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgdmFyIGVzID0gbmV3IEV2ZW50U291cmNlKHVybClcbiAgdmFyIHJzID0gbmV3IHN0cmVhbS5SZWFkYWJsZSh7b2JqZWN0TW9kZTp0cnVlfSlcblxuICB2YXIganNvbiA9ICEhb3B0cy5qc29uXG4gIHZhciBkZWNvZGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoanNvbikgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSlcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgcnMuX3JlYWQgPSBmdW5jdGlvbigpIHt9XG5cbiAgZXMub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIHJzLnB1c2goZGVjb2RlKGUuZGF0YSkpXG4gIH1cblxuICBlcy5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKHJzLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGgpIHJzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9XG5cbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlXG4gIHJzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm5cbiAgICBkZXN0cm95ZWQgPSB0cnVlXG4gICAgZXMuY2xvc2UoKVxuICAgIHBhcnNlLmVtaXQoJ2Nsb3NlJylcbiAgfVxuXG4gIHJldHVybiByc1xufSIsInZhciByZXEgPSByZXF1aXJlKCdyZXF1ZXN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBOZXRzXG5cbmZ1bmN0aW9uIE5ldHMgKG9wdHMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIG9wdHMgPSB7IHVyaTogb3B0cyB9XG5cbiAgLy8gaW4gbm9kZSwgaWYgZW5jb2RpbmcgPT09IG51bGwgdGhlbiByZXNwb25zZSB3aWxsIGJlIGEgQnVmZmVyLiB3ZSB3YW50IHRoaXMgdG8gYmUgdGhlIGRlZmF1bHRcbiAgaWYgKCFvcHRzLmhhc093blByb3BlcnR5KCdlbmNvZGluZycpKSBvcHRzLmVuY29kaW5nID0gbnVsbFxuXG4gIC8vIGluIGJyb3dzZXIsIHdlIHNob3VsZCBieSBkZWZhdWx0IGNvbnZlcnQgdGhlIGFycmF5YnVmZmVyIGludG8gYSBCdWZmZXJcbiAgaWYgKHByb2Nlc3MuYnJvd3NlciAmJiAhb3B0cy5oYXNPd25Qcm9wZXJ0eSgnanNvbicpICYmIG9wdHMuZW5jb2RpbmcgPT09IG51bGwpIHtcbiAgICBvcHRzLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgICB2YXIgb3JpZ2luYWxDYiA9IGNiXG4gICAgY2IgPSBidWZmZXJpZnlcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlcmlmeSAoZXJyLCByZXNwLCBib2R5KSB7XG4gICAgaWYgKGJvZHkpIGJvZHkgPSBuZXcgQnVmZmVyKG5ldyBVaW50OEFycmF5KGJvZHkpKVxuICAgIG9yaWdpbmFsQ2IoZXJyLCByZXNwLCBib2R5KVxuICB9XG5cbiAgcmV0dXJuIHJlcShvcHRzLCBjYilcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHdpbmRvdyA9IHJlcXVpcmUoXCJnbG9iYWwvd2luZG93XCIpXG52YXIgb25jZSA9IHJlcXVpcmUoXCJvbmNlXCIpXG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZShcInBhcnNlLWhlYWRlcnNcIilcblxuXG52YXIgWEhSID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0IHx8IG5vb3BcbnZhciBYRFIgPSBcIndpdGhDcmVkZW50aWFsc1wiIGluIChuZXcgWEhSKCkpID8gWEhSIDogd2luZG93LlhEb21haW5SZXF1ZXN0XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlWEhSXG5cbmZ1bmN0aW9uIGNyZWF0ZVhIUihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgbG9hZEZ1bmMoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgICAgICAgLy8gQ2hyb21lIHdpdGggcmVxdWVzdFR5cGU9YmxvYiB0aHJvd3MgZXJyb3JzIGFycm91bmQgd2hlbiBldmVuIHRlc3RpbmcgYWNjZXNzIHRvIHJlc3BvbnNlVGV4dFxuICAgICAgICB2YXIgYm9keSA9IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmICh4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VcbiAgICAgICAgfSBlbHNlIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcInRleHRcIiB8fCAheGhyLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVRleHQgfHwgeGhyLnJlc3BvbnNlWE1MXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNKc29uKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvZHlcbiAgICB9XG4gICAgXG4gICAgdmFyIGZhaWx1cmVSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogMCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgICAgICAgICByYXdSZXF1ZXN0OiB4aHJcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBlcnJvckZ1bmMoZXZ0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpXG4gICAgICAgIGlmKCEoZXZ0IGluc3RhbmNlb2YgRXJyb3IpKXtcbiAgICAgICAgICAgIGV2dCA9IG5ldyBFcnJvcihcIlwiICsgKGV2dCB8fCBcInVua25vd25cIikgKVxuICAgICAgICB9XG4gICAgICAgIGV2dC5zdGF0dXNDb2RlID0gMFxuICAgICAgICBjYWxsYmFjayhldnQsIGZhaWx1cmVSZXNwb25zZSlcbiAgICB9XG5cbiAgICAvLyB3aWxsIGxvYWQgdGhlIGRhdGEgJiBwcm9jZXNzIHRoZSByZXNwb25zZSBpbiBhIHNwZWNpYWwgcmVzcG9uc2Ugb2JqZWN0XG4gICAgZnVuY3Rpb24gbG9hZEZ1bmMoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpXG4gICAgICAgIFxuICAgICAgICB2YXIgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzKVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSBmYWlsdXJlUmVzcG9uc2VcbiAgICAgICAgdmFyIGVyciA9IG51bGxcbiAgICAgICAgXG4gICAgICAgIGlmIChzdGF0dXMgIT09IDApe1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogZ2V0Qm9keSgpLFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgICAgICAgICByYXdSZXF1ZXN0OiB4aHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMpeyAvL3JlbWVtYmVyIHhociBjYW4gaW4gZmFjdCBiZSBYRFIgZm9yIENPUlMgaW4gSUVcbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihcIkludGVybmFsIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpXG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSlcbiAgICAgICAgXG4gICAgfVxuICAgIFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvcHRpb25zID0geyB1cmk6IG9wdGlvbnMgfVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgaWYodHlwZW9mIGNhbGxiYWNrID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FsbGJhY2sgYXJndW1lbnQgbWlzc2luZ1wiKVxuICAgIH1cbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spXG5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgfHwgbnVsbFxuXG4gICAgaWYgKCF4aHIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29ycyB8fCBvcHRpb25zLnVzZVhEUikge1xuICAgICAgICAgICAgeGhyID0gbmV3IFhEUigpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgeGhyID0gbmV3IFhIUigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5XG4gICAgdmFyIHVyaSA9IHhoci51cmwgPSBvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybFxuICAgIHZhciBtZXRob2QgPSB4aHIubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIlxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG9wdGlvbnMuZGF0YVxuICAgIHZhciBoZWFkZXJzID0geGhyLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge31cbiAgICB2YXIgc3luYyA9ICEhb3B0aW9ucy5zeW5jXG4gICAgdmFyIGlzSnNvbiA9IGZhbHNlXG4gICAgdmFyIHRpbWVvdXRUaW1lclxuXG4gICAgaWYgKFwianNvblwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaXNKc29uID0gdHJ1ZVxuICAgICAgICBoZWFkZXJzW1wiQWNjZXB0XCJdIHx8IChoZWFkZXJzW1wiQWNjZXB0XCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIC8vRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYWNjZXB0IGhlYWRlciBkZWNsYXJlZCBieSB1c2VyXG4gICAgICAgIGlmIChtZXRob2QgIT09IFwiR0VUXCIgJiYgbWV0aG9kICE9PSBcIkhFQURcIikge1xuICAgICAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5qc29uKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHJlYWR5c3RhdGVjaGFuZ2VcbiAgICB4aHIub25sb2FkID0gbG9hZEZ1bmNcbiAgICB4aHIub25lcnJvciA9IGVycm9yRnVuY1xuICAgIC8vIElFOSBtdXN0IGhhdmUgb25wcm9ncmVzcyBiZSBzZXQgdG8gYSB1bmlxdWUgZnVuY3Rpb24uXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElFIG11c3QgZGllXG4gICAgfVxuICAgIHhoci5vbnRpbWVvdXQgPSBlcnJvckZ1bmNcbiAgICB4aHIub3BlbihtZXRob2QsIHVyaSwgIXN5bmMpXG4gICAgLy9oYXMgdG8gYmUgYWZ0ZXIgb3BlblxuICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdGlvbnMud2l0aENyZWRlbnRpYWxzXG4gICAgXG4gICAgLy8gQ2Fubm90IHNldCB0aW1lb3V0IHdpdGggc3luYyByZXF1ZXN0XG4gICAgLy8gbm90IHNldHRpbmcgdGltZW91dCBvbiB0aGUgeGhyIG9iamVjdCwgYmVjYXVzZSBvZiBvbGQgd2Via2l0cyBldGMuIG5vdCBoYW5kbGluZyB0aGF0IGNvcnJlY3RseVxuICAgIC8vIGJvdGggbnBtJ3MgcmVxdWVzdCBhbmQganF1ZXJ5IDEueCB1c2UgdGhpcyBraW5kIG9mIHRpbWVvdXQsIHNvIHRoaXMgaXMgYmVpbmcgY29uc2lzdGVudFxuICAgIGlmICghc3luYyAmJiBvcHRpb25zLnRpbWVvdXQgPiAwICkge1xuICAgICAgICB0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB4aHIuYWJvcnQoXCJ0aW1lb3V0XCIpO1xuICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQrMiApO1xuICAgIH1cblxuICAgIGlmICh4aHIuc2V0UmVxdWVzdEhlYWRlcikge1xuICAgICAgICBmb3Ioa2V5IGluIGhlYWRlcnMpe1xuICAgICAgICAgICAgaWYoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiBhbiBYRG9tYWluUmVxdWVzdCBvYmplY3RcIilcbiAgICB9XG5cbiAgICBpZiAoXCJyZXNwb25zZVR5cGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZVxuICAgIH1cbiAgICBcbiAgICBpZiAoXCJiZWZvcmVTZW5kXCIgaW4gb3B0aW9ucyAmJiBcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmVmb3JlU2VuZCA9PT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCh4aHIpXG4gICAgfVxuXG4gICAgeGhyLnNlbmQoYm9keSlcblxuICAgIHJldHVybiB4aHJcblxuXG59XG5cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCJpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNlbGY7XG59IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge307XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG9uY2Vcblxub25jZS5wcm90byA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2UodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuXG4gICAgY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbn1cbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuXG5mdW5jdGlvbiBmb3JFYWNoKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGl0ZXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBjb250ZXh0ID0gdGhpc1xuICAgIH1cbiAgICBcbiAgICBpZiAodG9TdHJpbmcuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJylcbiAgICAgICAgZm9yRWFjaEFycmF5KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgZm9yRWFjaFN0cmluZyhsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlXG4gICAgICAgIGZvckVhY2hPYmplY3QobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG59XG5cbmZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGkpKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGFycmF5W2ldLCBpLCBhcnJheSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBubyBzdWNoIHRoaW5nIGFzIGEgc3BhcnNlIHN0cmluZy5cbiAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpXG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoT2JqZWN0KG9iamVjdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBrIGluIG9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGspKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9iamVjdFtrXSwgaywgb2JqZWN0KVxuICAgICAgICB9XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHN0cmluZyA9IHRvU3RyaW5nLmNhbGwoZm4pXG4gIHJldHVybiBzdHJpbmcgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHxcbiAgICAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHN0cmluZyAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHx8XG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgIC8vIElFOCBhbmQgYmVsb3dcbiAgICAgKGZuID09PSB3aW5kb3cuc2V0VGltZW91dCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5hbGVydCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5jb25maXJtIHx8XG4gICAgICBmbiA9PT0gd2luZG93LnByb21wdCkpXG59O1xuIiwiXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0cmltO1xuXG5mdW5jdGlvbiB0cmltKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpO1xufTtcblxuZXhwb3J0cy5yaWdodCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59O1xuIiwidmFyIHRyaW0gPSByZXF1aXJlKCd0cmltJylcbiAgLCBmb3JFYWNoID0gcmVxdWlyZSgnZm9yLWVhY2gnKVxuICAsIGlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgaWYgKCFoZWFkZXJzKVxuICAgIHJldHVybiB7fVxuXG4gIHZhciByZXN1bHQgPSB7fVxuXG4gIGZvckVhY2goXG4gICAgICB0cmltKGhlYWRlcnMpLnNwbGl0KCdcXG4nKVxuICAgICwgZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgaW5kZXggPSByb3cuaW5kZXhPZignOicpXG4gICAgICAgICAgLCBrZXkgPSB0cmltKHJvdy5zbGljZSgwLCBpbmRleCkpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAsIHZhbHVlID0gdHJpbShyb3cuc2xpY2UoaW5kZXggKyAxKSlcblxuICAgICAgICBpZiAodHlwZW9mKHJlc3VsdFtrZXldKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShyZXN1bHRba2V5XSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gWyByZXN1bHRba2V5XSwgdmFsdWUgXVxuICAgICAgICB9XG4gICAgICB9XG4gIClcblxuICByZXR1cm4gcmVzdWx0XG59IiwiLyohIHNpbXBsZS1wZWVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NpbXBsZS1wZWVyJylcbmNvbnN0IGdldEJyb3dzZXJSVEMgPSByZXF1aXJlKCdnZXQtYnJvd3Nlci1ydGMnKVxuY29uc3QgcmFuZG9tYnl0ZXMgPSByZXF1aXJlKCdyYW5kb21ieXRlcycpXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuY29uc3QgcXVldWVNaWNyb3Rhc2sgPSByZXF1aXJlKCdxdWV1ZS1taWNyb3Rhc2snKSAvLyBUT0RPOiByZW1vdmUgd2hlbiBOb2RlIDEwIGlzIG5vdCBzdXBwb3J0ZWRcbmNvbnN0IGVyckNvZGUgPSByZXF1aXJlKCdlcnItY29kZScpXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxuY29uc3QgTUFYX0JVRkZFUkVEX0FNT1VOVCA9IDY0ICogMTAyNFxuY29uc3QgSUNFQ09NUExFVEVfVElNRU9VVCA9IDUgKiAxMDAwXG5jb25zdCBDSEFOTkVMX0NMT1NJTkdfVElNRU9VVCA9IDUgKiAxMDAwXG5cbi8vIEhBQ0s6IEZpbHRlciB0cmlja2xlIGxpbmVzIHdoZW4gdHJpY2tsZSBpcyBkaXNhYmxlZCAjMzU0XG5mdW5jdGlvbiBmaWx0ZXJUcmlja2xlIChzZHApIHtcbiAgcmV0dXJuIHNkcC5yZXBsYWNlKC9hPWljZS1vcHRpb25zOnRyaWNrbGVcXHNcXG4vZywgJycpXG59XG5cbmZ1bmN0aW9uIHdhcm4gKG1lc3NhZ2UpIHtcbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpXG59XG5cbi8qKlxuICogV2ViUlRDIHBlZXIgY29ubmVjdGlvbi4gU2FtZSBBUEkgYXMgbm9kZSBjb3JlIGBuZXQuU29ja2V0YCwgcGx1cyBhIGZldyBleHRyYSBtZXRob2RzLlxuICogRHVwbGV4IHN0cmVhbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmNsYXNzIFBlZXIgZXh0ZW5kcyBzdHJlYW0uRHVwbGV4IHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBhbGxvd0hhbGZPcGVuOiBmYWxzZVxuICAgIH0sIG9wdHMpXG5cbiAgICBzdXBlcihvcHRzKVxuXG4gICAgdGhpcy5faWQgPSByYW5kb21ieXRlcyg0KS50b1N0cmluZygnaGV4Jykuc2xpY2UoMCwgNylcbiAgICB0aGlzLl9kZWJ1ZygnbmV3IHBlZXIgJW8nLCBvcHRzKVxuXG4gICAgdGhpcy5jaGFubmVsTmFtZSA9IG9wdHMuaW5pdGlhdG9yXG4gICAgICA/IG9wdHMuY2hhbm5lbE5hbWUgfHwgcmFuZG9tYnl0ZXMoMjApLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgOiBudWxsXG5cbiAgICB0aGlzLmluaXRpYXRvciA9IG9wdHMuaW5pdGlhdG9yIHx8IGZhbHNlXG4gICAgdGhpcy5jaGFubmVsQ29uZmlnID0gb3B0cy5jaGFubmVsQ29uZmlnIHx8IFBlZXIuY2hhbm5lbENvbmZpZ1xuICAgIHRoaXMuY2hhbm5lbE5lZ290aWF0ZWQgPSB0aGlzLmNoYW5uZWxDb25maWcubmVnb3RpYXRlZFxuICAgIHRoaXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgUGVlci5jb25maWcsIG9wdHMuY29uZmlnKVxuICAgIHRoaXMub2ZmZXJPcHRpb25zID0gb3B0cy5vZmZlck9wdGlvbnMgfHwge31cbiAgICB0aGlzLmFuc3dlck9wdGlvbnMgPSBvcHRzLmFuc3dlck9wdGlvbnMgfHwge31cbiAgICB0aGlzLnNkcFRyYW5zZm9ybSA9IG9wdHMuc2RwVHJhbnNmb3JtIHx8IChzZHAgPT4gc2RwKVxuICAgIHRoaXMuc3RyZWFtcyA9IG9wdHMuc3RyZWFtcyB8fCAob3B0cy5zdHJlYW0gPyBbb3B0cy5zdHJlYW1dIDogW10pIC8vIHN1cHBvcnQgb2xkIFwic3RyZWFtXCIgb3B0aW9uXG4gICAgdGhpcy50cmlja2xlID0gb3B0cy50cmlja2xlICE9PSB1bmRlZmluZWQgPyBvcHRzLnRyaWNrbGUgOiB0cnVlXG4gICAgdGhpcy5hbGxvd0hhbGZUcmlja2xlID0gb3B0cy5hbGxvd0hhbGZUcmlja2xlICE9PSB1bmRlZmluZWQgPyBvcHRzLmFsbG93SGFsZlRyaWNrbGUgOiBmYWxzZVxuICAgIHRoaXMuaWNlQ29tcGxldGVUaW1lb3V0ID0gb3B0cy5pY2VDb21wbGV0ZVRpbWVvdXQgfHwgSUNFQ09NUExFVEVfVElNRU9VVFxuXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZVxuICAgIHRoaXMuZGVzdHJveWluZyA9IGZhbHNlXG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2VcblxuICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHVuZGVmaW5lZFxuICAgIHRoaXMucmVtb3RlRmFtaWx5ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5yZW1vdGVQb3J0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5sb2NhbEFkZHJlc3MgPSB1bmRlZmluZWRcbiAgICB0aGlzLmxvY2FsRmFtaWx5ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5sb2NhbFBvcnQgPSB1bmRlZmluZWRcblxuICAgIHRoaXMuX3dydGMgPSAob3B0cy53cnRjICYmIHR5cGVvZiBvcHRzLndydGMgPT09ICdvYmplY3QnKVxuICAgICAgPyBvcHRzLndydGNcbiAgICAgIDogZ2V0QnJvd3NlclJUQygpXG5cbiAgICBpZiAoIXRoaXMuX3dydGMpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignTm8gV2ViUlRDIHN1cHBvcnQ6IFNwZWNpZnkgYG9wdHMud3J0Y2Agb3B0aW9uIGluIHRoaXMgZW52aXJvbm1lbnQnKSwgJ0VSUl9XRUJSVENfU1VQUE9SVCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignTm8gV2ViUlRDIHN1cHBvcnQ6IE5vdCBhIHN1cHBvcnRlZCBicm93c2VyJyksICdFUlJfV0VCUlRDX1NVUFBPUlQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3BjUmVhZHkgPSBmYWxzZVxuICAgIHRoaXMuX2NoYW5uZWxSZWFkeSA9IGZhbHNlXG4gICAgdGhpcy5faWNlQ29tcGxldGUgPSBmYWxzZSAvLyBpY2UgY2FuZGlkYXRlIHRyaWNrbGUgZG9uZSAoZ290IG51bGwgY2FuZGlkYXRlKVxuICAgIHRoaXMuX2ljZUNvbXBsZXRlVGltZXIgPSBudWxsIC8vIHNlbmQgYW4gb2ZmZXIvYW5zd2VyIGFueXdheSBhZnRlciBzb21lIHRpbWVvdXRcbiAgICB0aGlzLl9jaGFubmVsID0gbnVsbFxuICAgIHRoaXMuX3BlbmRpbmdDYW5kaWRhdGVzID0gW11cblxuICAgIHRoaXMuX2lzTmVnb3RpYXRpbmcgPSBmYWxzZSAvLyBpcyB0aGlzIHBlZXIgd2FpdGluZyBmb3IgbmVnb3RpYXRpb24gdG8gY29tcGxldGU/XG4gICAgdGhpcy5fZmlyc3ROZWdvdGlhdGlvbiA9IHRydWVcbiAgICB0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb24gPSBmYWxzZSAvLyBiYXRjaCBzeW5jaHJvbm91cyBuZWdvdGlhdGlvbnNcbiAgICB0aGlzLl9xdWV1ZWROZWdvdGlhdGlvbiA9IGZhbHNlIC8vIGlzIHRoZXJlIGEgcXVldWVkIG5lZ290aWF0aW9uIHJlcXVlc3Q/XG4gICAgdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlID0gW11cbiAgICB0aGlzLl9zZW5kZXJNYXAgPSBuZXcgTWFwKClcbiAgICB0aGlzLl9jbG9zaW5nSW50ZXJ2YWwgPSBudWxsXG5cbiAgICB0aGlzLl9yZW1vdGVUcmFja3MgPSBbXVxuICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMgPSBbXVxuXG4gICAgdGhpcy5fY2h1bmsgPSBudWxsXG4gICAgdGhpcy5fY2IgPSBudWxsXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsXG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fcGMgPSBuZXcgKHRoaXMuX3dydGMuUlRDUGVlckNvbm5lY3Rpb24pKHRoaXMuY29uZmlnKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX1BDX0NPTlNUUlVDVE9SJykpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBXZSBwcmVmZXIgZmVhdHVyZSBkZXRlY3Rpb24gd2hlbmV2ZXIgcG9zc2libGUsIGJ1dCBzb21ldGltZXMgdGhhdCdzIG5vdFxuICAgIC8vIHBvc3NpYmxlIGZvciBjZXJ0YWluIGltcGxlbWVudGF0aW9ucy5cbiAgICB0aGlzLl9pc1JlYWN0TmF0aXZlV2VicnRjID0gdHlwZW9mIHRoaXMuX3BjLl9wZWVyQ29ubmVjdGlvbklkID09PSAnbnVtYmVyJ1xuXG4gICAgdGhpcy5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkljZVN0YXRlQ2hhbmdlKClcbiAgICB9XG4gICAgdGhpcy5fcGMub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uSWNlU3RhdGVDaGFuZ2UoKVxuICAgIH1cbiAgICB0aGlzLl9wYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlKClcbiAgICB9XG4gICAgdGhpcy5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uU2lnbmFsaW5nU3RhdGVDaGFuZ2UoKVxuICAgIH1cbiAgICB0aGlzLl9wYy5vbmljZWNhbmRpZGF0ZSA9IGV2ZW50ID0+IHtcbiAgICAgIHRoaXMuX29uSWNlQ2FuZGlkYXRlKGV2ZW50KVxuICAgIH1cblxuICAgIC8vIEhBQ0s6IEZpeCBmb3Igb2RkIEZpcmVmb3ggYmVoYXZpb3IsIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9zaW1wbGUtcGVlci9wdWxsLzc4M1xuICAgIGlmICh0eXBlb2YgdGhpcy5fcGMucGVlcklkZW50aXR5ID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5fcGMucGVlcklkZW50aXR5LmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9QQ19QRUVSX0lERU5USVRZJykpXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIE90aGVyIHNwZWMgZXZlbnRzLCB1bnVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvbjpcbiAgICAvLyAtIG9uY29ubmVjdGlvbnN0YXRlY2hhbmdlXG4gICAgLy8gLSBvbmljZWNhbmRpZGF0ZWVycm9yXG4gICAgLy8gLSBvbmZpbmdlcnByaW50ZmFpbHVyZVxuICAgIC8vIC0gb25uZWdvdGlhdGlvbm5lZWRlZFxuXG4gICAgaWYgKHRoaXMuaW5pdGlhdG9yIHx8IHRoaXMuY2hhbm5lbE5lZ290aWF0ZWQpIHtcbiAgICAgIHRoaXMuX3NldHVwRGF0YSh7XG4gICAgICAgIGNoYW5uZWw6IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKHRoaXMuY2hhbm5lbE5hbWUsIHRoaXMuY2hhbm5lbENvbmZpZylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BjLm9uZGF0YWNoYW5uZWwgPSBldmVudCA9PiB7XG4gICAgICAgIHRoaXMuX3NldHVwRGF0YShldmVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdHJlYW1zKSB7XG4gICAgICB0aGlzLnN0cmVhbXMuZm9yRWFjaChzdHJlYW0gPT4ge1xuICAgICAgICB0aGlzLmFkZFN0cmVhbShzdHJlYW0pXG4gICAgICB9KVxuICAgIH1cbiAgICB0aGlzLl9wYy5vbnRyYWNrID0gZXZlbnQgPT4ge1xuICAgICAgdGhpcy5fb25UcmFjayhldmVudClcbiAgICB9XG5cbiAgICB0aGlzLl9kZWJ1ZygnaW5pdGlhbCBuZWdvdGlhdGlvbicpXG4gICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpXG5cbiAgICB0aGlzLl9vbkZpbmlzaEJvdW5kID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25GaW5pc2goKVxuICAgIH1cbiAgICB0aGlzLm9uY2UoJ2ZpbmlzaCcsIHRoaXMuX29uRmluaXNoQm91bmQpXG4gIH1cblxuICBnZXQgYnVmZmVyU2l6ZSAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9jaGFubmVsICYmIHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQpIHx8IDBcbiAgfVxuXG4gIC8vIEhBQ0s6IGl0J3MgcG9zc2libGUgY2hhbm5lbC5yZWFkeVN0YXRlIGlzIFwiY2xvc2luZ1wiIGJlZm9yZSBwZWVyLmRlc3Ryb3koKSBmaXJlc1xuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04ODI3NDNcbiAgZ2V0IGNvbm5lY3RlZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9jb25uZWN0ZWQgJiYgdGhpcy5fY2hhbm5lbC5yZWFkeVN0YXRlID09PSAnb3BlbicpXG4gIH1cblxuICBhZGRyZXNzICgpIHtcbiAgICByZXR1cm4geyBwb3J0OiB0aGlzLmxvY2FsUG9ydCwgZmFtaWx5OiB0aGlzLmxvY2FsRmFtaWx5LCBhZGRyZXNzOiB0aGlzLmxvY2FsQWRkcmVzcyB9XG4gIH1cblxuICBzaWduYWwgKGRhdGEpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3Qgc2lnbmFsIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRhdGEgPSB7fVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9kZWJ1Zygnc2lnbmFsKCknKVxuXG4gICAgaWYgKGRhdGEucmVuZWdvdGlhdGUgJiYgdGhpcy5pbml0aWF0b3IpIHtcbiAgICAgIHRoaXMuX2RlYnVnKCdnb3QgcmVxdWVzdCB0byByZW5lZ290aWF0ZScpXG4gICAgICB0aGlzLl9uZWVkc05lZ290aWF0aW9uKClcbiAgICB9XG4gICAgaWYgKGRhdGEudHJhbnNjZWl2ZXJSZXF1ZXN0ICYmIHRoaXMuaW5pdGlhdG9yKSB7XG4gICAgICB0aGlzLl9kZWJ1ZygnZ290IHJlcXVlc3QgZm9yIHRyYW5zY2VpdmVyJylcbiAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoZGF0YS50cmFuc2NlaXZlclJlcXVlc3Qua2luZCwgZGF0YS50cmFuc2NlaXZlclJlcXVlc3QuaW5pdClcbiAgICB9XG4gICAgaWYgKGRhdGEuY2FuZGlkYXRlKSB7XG4gICAgICBpZiAodGhpcy5fcGMucmVtb3RlRGVzY3JpcHRpb24gJiYgdGhpcy5fcGMucmVtb3RlRGVzY3JpcHRpb24udHlwZSkge1xuICAgICAgICB0aGlzLl9hZGRJY2VDYW5kaWRhdGUoZGF0YS5jYW5kaWRhdGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcy5wdXNoKGRhdGEuY2FuZGlkYXRlKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5zZHApIHtcbiAgICAgIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG5ldyAodGhpcy5fd3J0Yy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGRhdGEpKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgICAgICAgIHRoaXMuX3BlbmRpbmdDYW5kaWRhdGVzLmZvckVhY2goY2FuZGlkYXRlID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdXG5cbiAgICAgICAgICBpZiAodGhpcy5fcGMucmVtb3RlRGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykgdGhpcy5fY3JlYXRlQW5zd2VyKClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX1NFVF9SRU1PVEVfREVTQ1JJUFRJT04nKSlcbiAgICAgICAgfSlcbiAgICB9XG4gICAgaWYgKCFkYXRhLnNkcCAmJiAhZGF0YS5jYW5kaWRhdGUgJiYgIWRhdGEucmVuZWdvdGlhdGUgJiYgIWRhdGEudHJhbnNjZWl2ZXJSZXF1ZXN0KSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShuZXcgRXJyb3IoJ3NpZ25hbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgc2lnbmFsIGRhdGEnKSwgJ0VSUl9TSUdOQUxJTkcnKSlcbiAgICB9XG4gIH1cblxuICBfYWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBjb25zdCBpY2VDYW5kaWRhdGVPYmogPSBuZXcgdGhpcy5fd3J0Yy5SVENJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICAgIHRoaXMuX3BjLmFkZEljZUNhbmRpZGF0ZShpY2VDYW5kaWRhdGVPYmopXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKCFpY2VDYW5kaWRhdGVPYmouYWRkcmVzcyB8fCBpY2VDYW5kaWRhdGVPYmouYWRkcmVzcy5lbmRzV2l0aCgnLmxvY2FsJykpIHtcbiAgICAgICAgICB3YXJuKCdJZ25vcmluZyB1bnN1cHBvcnRlZCBJQ0UgY2FuZGlkYXRlLicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0FERF9JQ0VfQ0FORElEQVRFJykpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2VuZCB0ZXh0L2JpbmFyeSBkYXRhIHRvIHRoZSByZW1vdGUgcGVlci5cbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd8QXJyYXlCdWZmZXJ8QnVmZmVyfHN0cmluZ3xCbG9ifSBjaHVua1xuICAgKi9cbiAgc2VuZCAoY2h1bmspIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3Qgc2VuZCBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgdGhpcy5fY2hhbm5lbC5zZW5kKGNodW5rKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIFRyYW5zY2VpdmVyIHRvIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2luZFxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5pdFxuICAgKi9cbiAgYWRkVHJhbnNjZWl2ZXIgKGtpbmQsIGluaXQpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgYWRkVHJhbnNjZWl2ZXIgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdhZGRUcmFuc2NlaXZlcigpJylcblxuICAgIGlmICh0aGlzLmluaXRpYXRvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fcGMuYWRkVHJhbnNjZWl2ZXIoa2luZCwgaW5pdClcbiAgICAgICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0FERF9UUkFOU0NFSVZFUicpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoJ3NpZ25hbCcsIHsgLy8gcmVxdWVzdCBpbml0aWF0b3IgdG8gcmVuZWdvdGlhdGVcbiAgICAgICAgdHlwZTogJ3RyYW5zY2VpdmVyUmVxdWVzdCcsXG4gICAgICAgIHRyYW5zY2VpdmVyUmVxdWVzdDogeyBraW5kLCBpbml0IH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIE1lZGlhU3RyZWFtIHRvIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICovXG4gIGFkZFN0cmVhbSAoc3RyZWFtKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IGFkZFN0cmVhbSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgdGhpcy5fZGVidWcoJ2FkZFN0cmVhbSgpJylcblxuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIHRoaXMuYWRkVHJhY2sodHJhY2ssIHN0cmVhbSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIE1lZGlhU3RyZWFtVHJhY2sgdG8gdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gICAqL1xuICBhZGRUcmFjayAodHJhY2ssIHN0cmVhbSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCBhZGRUcmFjayBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgdGhpcy5fZGVidWcoJ2FkZFRyYWNrKCknKVxuXG4gICAgY29uc3Qgc3VibWFwID0gdGhpcy5fc2VuZGVyTWFwLmdldCh0cmFjaykgfHwgbmV3IE1hcCgpIC8vIG5lc3RlZCBNYXBzIG1hcCBbdHJhY2ssIHN0cmVhbV0gdG8gc2VuZGVyXG4gICAgbGV0IHNlbmRlciA9IHN1Ym1hcC5nZXQoc3RyZWFtKVxuICAgIGlmICghc2VuZGVyKSB7XG4gICAgICBzZW5kZXIgPSB0aGlzLl9wYy5hZGRUcmFjayh0cmFjaywgc3RyZWFtKVxuICAgICAgc3VibWFwLnNldChzdHJlYW0sIHNlbmRlcilcbiAgICAgIHRoaXMuX3NlbmRlck1hcC5zZXQodHJhY2ssIHN1Ym1hcClcbiAgICAgIHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKVxuICAgIH0gZWxzZSBpZiAoc2VuZGVyLnJlbW92ZWQpIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdUcmFjayBoYXMgYmVlbiByZW1vdmVkLiBZb3Ugc2hvdWxkIGVuYWJsZS9kaXNhYmxlIHRyYWNrcyB0aGF0IHlvdSB3YW50IHRvIHJlLWFkZC4nKSwgJ0VSUl9TRU5ERVJfUkVNT1ZFRCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdUcmFjayBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoYXQgc3RyZWFtLicpLCAnRVJSX1NFTkRFUl9BTFJFQURZX0FEREVEJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSBhIE1lZGlhU3RyZWFtVHJhY2sgYnkgYW5vdGhlciBpbiB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSBvbGRUcmFja1xuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IG5ld1RyYWNrXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbVxuICAgKi9cbiAgcmVwbGFjZVRyYWNrIChvbGRUcmFjaywgbmV3VHJhY2ssIHN0cmVhbSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCByZXBsYWNlVHJhY2sgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdyZXBsYWNlVHJhY2soKScpXG5cbiAgICBjb25zdCBzdWJtYXAgPSB0aGlzLl9zZW5kZXJNYXAuZ2V0KG9sZFRyYWNrKVxuICAgIGNvbnN0IHNlbmRlciA9IHN1Ym1hcCA/IHN1Ym1hcC5nZXQoc3RyZWFtKSA6IG51bGxcbiAgICBpZiAoIXNlbmRlcikge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ0Nhbm5vdCByZXBsYWNlIHRyYWNrIHRoYXQgd2FzIG5ldmVyIGFkZGVkLicpLCAnRVJSX1RSQUNLX05PVF9BRERFRCcpXG4gICAgfVxuICAgIGlmIChuZXdUcmFjaykgdGhpcy5fc2VuZGVyTWFwLnNldChuZXdUcmFjaywgc3VibWFwKVxuXG4gICAgaWYgKHNlbmRlci5yZXBsYWNlVHJhY2sgIT0gbnVsbCkge1xuICAgICAgc2VuZGVyLnJlcGxhY2VUcmFjayhuZXdUcmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUobmV3IEVycm9yKCdyZXBsYWNlVHJhY2sgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKSwgJ0VSUl9VTlNVUFBPUlRFRF9SRVBMQUNFVFJBQ0snKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgTWVkaWFTdHJlYW1UcmFjayBmcm9tIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IHRyYWNrXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbVxuICAgKi9cbiAgcmVtb3ZlVHJhY2sgKHRyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgcmVtb3ZlVHJhY2sgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIHRoaXMuX2RlYnVnKCdyZW1vdmVTZW5kZXIoKScpXG5cbiAgICBjb25zdCBzdWJtYXAgPSB0aGlzLl9zZW5kZXJNYXAuZ2V0KHRyYWNrKVxuICAgIGNvbnN0IHNlbmRlciA9IHN1Ym1hcCA/IHN1Ym1hcC5nZXQoc3RyZWFtKSA6IG51bGxcbiAgICBpZiAoIXNlbmRlcikge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ0Nhbm5vdCByZW1vdmUgdHJhY2sgdGhhdCB3YXMgbmV2ZXIgYWRkZWQuJyksICdFUlJfVFJBQ0tfTk9UX0FEREVEJylcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHNlbmRlci5yZW1vdmVkID0gdHJ1ZVxuICAgICAgdGhpcy5fcGMucmVtb3ZlVHJhY2soc2VuZGVyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5uYW1lID09PSAnTlNfRVJST1JfVU5FWFBFQ1RFRCcpIHtcbiAgICAgICAgdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlLnB1c2goc2VuZGVyKSAvLyBIQUNLOiBGaXJlZm94IG11c3Qgd2FpdCB1bnRpbCAoc2lnbmFsaW5nU3RhdGUgPT09IHN0YWJsZSkgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEzMzg3NFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX1JFTU9WRV9UUkFDSycpKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9uZWVkc05lZ290aWF0aW9uKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBNZWRpYVN0cmVhbSBmcm9tIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICovXG4gIHJlbW92ZVN0cmVhbSAoc3RyZWFtKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IHJlbW92ZVN0cmVhbSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgdGhpcy5fZGVidWcoJ3JlbW92ZVNlbmRlcnMoKScpXG5cbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICB0aGlzLnJlbW92ZVRyYWNrKHRyYWNrLCBzdHJlYW0pXG4gICAgfSlcbiAgfVxuXG4gIF9uZWVkc05lZ290aWF0aW9uICgpIHtcbiAgICB0aGlzLl9kZWJ1ZygnX25lZWRzTmVnb3RpYXRpb24nKVxuICAgIGlmICh0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb24pIHJldHVybiAvLyBiYXRjaCBzeW5jaHJvbm91cyByZW5lZ290aWF0aW9uc1xuICAgIHRoaXMuX2JhdGNoZWROZWdvdGlhdGlvbiA9IHRydWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICB0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb24gPSBmYWxzZVxuICAgICAgaWYgKHRoaXMuaW5pdGlhdG9yIHx8ICF0aGlzLl9maXJzdE5lZ290aWF0aW9uKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdzdGFydGluZyBiYXRjaGVkIG5lZ290aWF0aW9uJylcbiAgICAgICAgdGhpcy5uZWdvdGlhdGUoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ25vbi1pbml0aWF0b3IgaW5pdGlhbCBuZWdvdGlhdGlvbiByZXF1ZXN0IGRpc2NhcmRlZCcpXG4gICAgICB9XG4gICAgICB0aGlzLl9maXJzdE5lZ290aWF0aW9uID0gZmFsc2VcbiAgICB9KVxuICB9XG5cbiAgbmVnb3RpYXRlICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgbmVnb3RpYXRlIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcblxuICAgIGlmICh0aGlzLmluaXRpYXRvcikge1xuICAgICAgaWYgKHRoaXMuX2lzTmVnb3RpYXRpbmcpIHtcbiAgICAgICAgdGhpcy5fcXVldWVkTmVnb3RpYXRpb24gPSB0cnVlXG4gICAgICAgIHRoaXMuX2RlYnVnKCdhbHJlYWR5IG5lZ290aWF0aW5nLCBxdWV1ZWluZycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kZWJ1Zygnc3RhcnQgbmVnb3RpYXRpb24nKVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgLy8gSEFDSzogQ2hyb21lIGNyYXNoZXMgaWYgd2UgaW1tZWRpYXRlbHkgY2FsbCBjcmVhdGVPZmZlclxuICAgICAgICAgIHRoaXMuX2NyZWF0ZU9mZmVyKClcbiAgICAgICAgfSwgMClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX2lzTmVnb3RpYXRpbmcpIHtcbiAgICAgICAgdGhpcy5fcXVldWVkTmVnb3RpYXRpb24gPSB0cnVlXG4gICAgICAgIHRoaXMuX2RlYnVnKCdhbHJlYWR5IG5lZ290aWF0aW5nLCBxdWV1ZWluZycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kZWJ1ZygncmVxdWVzdGluZyBuZWdvdGlhdGlvbiBmcm9tIGluaXRpYXRvcicpXG4gICAgICAgIHRoaXMuZW1pdCgnc2lnbmFsJywgeyAvLyByZXF1ZXN0IGluaXRpYXRvciB0byByZW5lZ290aWF0ZVxuICAgICAgICAgIHR5cGU6ICdyZW5lZ290aWF0ZScsXG4gICAgICAgICAgcmVuZWdvdGlhdGU6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faXNOZWdvdGlhdGluZyA9IHRydWVcbiAgfVxuXG4gIC8vIFRPRE86IERlbGV0ZSB0aGlzIG1ldGhvZCBvbmNlIHJlYWRhYmxlLXN0cmVhbSBpcyB1cGRhdGVkIHRvIGNvbnRhaW4gYSBkZWZhdWx0XG4gIC8vIGltcGxlbWVudGF0aW9uIG9mIGRlc3Ryb3koKSB0aGF0IGF1dG9tYXRpY2FsbHkgY2FsbHMgX2Rlc3Ryb3koKVxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvcmVhZGFibGUtc3RyZWFtL2lzc3Vlcy8yODNcbiAgZGVzdHJveSAoZXJyKSB7XG4gICAgdGhpcy5fZGVzdHJveShlcnIsICgpID0+IHt9KVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGVyciwgY2IpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQgfHwgdGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICB0aGlzLmRlc3Ryb3lpbmcgPSB0cnVlXG5cbiAgICB0aGlzLl9kZWJ1ZygnZGVzdHJveWluZyAoZXJyb3I6ICVzKScsIGVyciAmJiAoZXJyLm1lc3NhZ2UgfHwgZXJyKSlcblxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHsgLy8gYWxsb3cgZXZlbnRzIGNvbmN1cnJlbnQgd2l0aCB0aGUgY2FsbCB0byBfZGVzdHJveSgpIHRvIGZpcmUgKHNlZSAjNjkyKVxuICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG4gICAgICB0aGlzLmRlc3Ryb3lpbmcgPSBmYWxzZVxuXG4gICAgICB0aGlzLl9kZWJ1ZygnZGVzdHJveSAoZXJyb3I6ICVzKScsIGVyciAmJiAoZXJyLm1lc3NhZ2UgfHwgZXJyKSlcblxuICAgICAgdGhpcy5yZWFkYWJsZSA9IHRoaXMud3JpdGFibGUgPSBmYWxzZVxuXG4gICAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHRoaXMucHVzaChudWxsKVxuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB0aGlzLmVuZCgpXG5cbiAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICB0aGlzLl9wY1JlYWR5ID0gZmFsc2VcbiAgICAgIHRoaXMuX2NoYW5uZWxSZWFkeSA9IGZhbHNlXG4gICAgICB0aGlzLl9yZW1vdGVUcmFja3MgPSBudWxsXG4gICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zID0gbnVsbFxuICAgICAgdGhpcy5fc2VuZGVyTWFwID0gbnVsbFxuXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2Nsb3NpbmdJbnRlcnZhbClcbiAgICAgIHRoaXMuX2Nsb3NpbmdJbnRlcnZhbCA9IG51bGxcblxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbClcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbFxuICAgICAgdGhpcy5fY2h1bmsgPSBudWxsXG4gICAgICB0aGlzLl9jYiA9IG51bGxcblxuICAgICAgaWYgKHRoaXMuX29uRmluaXNoQm91bmQpIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIHRoaXMuX29uRmluaXNoQm91bmQpXG4gICAgICB0aGlzLl9vbkZpbmlzaEJvdW5kID0gbnVsbFxuXG4gICAgICBpZiAodGhpcy5fY2hhbm5lbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuX2NoYW5uZWwuY2xvc2UoKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAgICAgLy8gYWxsb3cgZXZlbnRzIGNvbmN1cnJlbnQgd2l0aCBkZXN0cnVjdGlvbiB0byBiZSBoYW5kbGVkXG4gICAgICAgIHRoaXMuX2NoYW5uZWwub25tZXNzYWdlID0gbnVsbFxuICAgICAgICB0aGlzLl9jaGFubmVsLm9ub3BlbiA9IG51bGxcbiAgICAgICAgdGhpcy5fY2hhbm5lbC5vbmNsb3NlID0gbnVsbFxuICAgICAgICB0aGlzLl9jaGFubmVsLm9uZXJyb3IgPSBudWxsXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcGMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgICAgICAvLyBhbGxvdyBldmVudHMgY29uY3VycmVudCB3aXRoIGRlc3RydWN0aW9uIHRvIGJlIGhhbmRsZWRcbiAgICAgICAgdGhpcy5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICAgIHRoaXMuX3BjLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICAgIHRoaXMuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICAgIHRoaXMuX3BjLm9uaWNlY2FuZGlkYXRlID0gbnVsbFxuICAgICAgICB0aGlzLl9wYy5vbnRyYWNrID0gbnVsbFxuICAgICAgICB0aGlzLl9wYy5vbmRhdGFjaGFubmVsID0gbnVsbFxuICAgICAgfVxuICAgICAgdGhpcy5fcGMgPSBudWxsXG4gICAgICB0aGlzLl9jaGFubmVsID0gbnVsbFxuXG4gICAgICBpZiAoZXJyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgICBjYigpXG4gICAgfSlcbiAgfVxuXG4gIF9zZXR1cERhdGEgKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5jaGFubmVsKSB7XG4gICAgICAvLyBJbiBzb21lIHNpdHVhdGlvbnMgYHBjLmNyZWF0ZURhdGFDaGFubmVsKClgIHJldHVybnMgYHVuZGVmaW5lZGAgKGluIHdydGMpLFxuICAgICAgLy8gd2hpY2ggaXMgaW52YWxpZCBiZWhhdmlvci4gSGFuZGxlIGl0IGdyYWNlZnVsbHkuXG4gICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3Mvc2ltcGxlLXBlZXIvaXNzdWVzLzE2M1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveShlcnJDb2RlKG5ldyBFcnJvcignRGF0YSBjaGFubmVsIGV2ZW50IGlzIG1pc3NpbmcgYGNoYW5uZWxgIHByb3BlcnR5JyksICdFUlJfREFUQV9DSEFOTkVMJykpXG4gICAgfVxuXG4gICAgdGhpcy5fY2hhbm5lbCA9IGV2ZW50LmNoYW5uZWxcbiAgICB0aGlzLl9jaGFubmVsLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG5cbiAgICBpZiAodHlwZW9mIHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID0gTUFYX0JVRkZFUkVEX0FNT1VOVFxuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbE5hbWUgPSB0aGlzLl9jaGFubmVsLmxhYmVsXG5cbiAgICB0aGlzLl9jaGFubmVsLm9ubWVzc2FnZSA9IGV2ZW50ID0+IHtcbiAgICAgIHRoaXMuX29uQ2hhbm5lbE1lc3NhZ2UoZXZlbnQpXG4gICAgfVxuICAgIHRoaXMuX2NoYW5uZWwub25idWZmZXJlZGFtb3VudGxvdyA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uQ2hhbm5lbEJ1ZmZlcmVkQW1vdW50TG93KClcbiAgICB9XG4gICAgdGhpcy5fY2hhbm5lbC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkNoYW5uZWxPcGVuKClcbiAgICB9XG4gICAgdGhpcy5fY2hhbm5lbC5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25DaGFubmVsQ2xvc2UoKVxuICAgIH1cbiAgICB0aGlzLl9jaGFubmVsLm9uZXJyb3IgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBldmVudC5lcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgID8gZXZlbnQuZXJyb3JcbiAgICAgICAgOiBuZXcgRXJyb3IoYERhdGFjaGFubmVsIGVycm9yOiAke2V2ZW50Lm1lc3NhZ2V9ICR7ZXZlbnQuZmlsZW5hbWV9OiR7ZXZlbnQubGluZW5vfToke2V2ZW50LmNvbG5vfWApXG4gICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfREFUQV9DSEFOTkVMJykpXG4gICAgfVxuXG4gICAgLy8gSEFDSzogQ2hyb21lIHdpbGwgc29tZXRpbWVzIGdldCBzdHVjayBpbiByZWFkeVN0YXRlIFwiY2xvc2luZ1wiLCBsZXQncyBjaGVjayBmb3IgdGhpcyBjb25kaXRpb25cbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04ODI3NDNcbiAgICBsZXQgaXNDbG9zaW5nID0gZmFsc2VcbiAgICB0aGlzLl9jbG9zaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7IC8vIE5vIFwib25jbG9zaW5nXCIgZXZlbnRcbiAgICAgIGlmICh0aGlzLl9jaGFubmVsICYmIHRoaXMuX2NoYW5uZWwucmVhZHlTdGF0ZSA9PT0gJ2Nsb3NpbmcnKSB7XG4gICAgICAgIGlmIChpc0Nsb3NpbmcpIHRoaXMuX29uQ2hhbm5lbENsb3NlKCkgLy8gY2xvc2luZyB0aW1lZCBvdXQ6IGVxdWl2YWxlbnQgdG8gb25jbG9zZSBmaXJpbmdcbiAgICAgICAgaXNDbG9zaW5nID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNDbG9zaW5nID0gZmFsc2VcbiAgICAgIH1cbiAgICB9LCBDSEFOTkVMX0NMT1NJTkdfVElNRU9VVClcbiAgfVxuXG4gIF9yZWFkICgpIHt9XG5cbiAgX3dyaXRlIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm4gY2IoZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCB3cml0ZSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZW5kKGNodW5rKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfREFUQV9DSEFOTkVMJykpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCA+IE1BWF9CVUZGRVJFRF9BTU9VTlQpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3N0YXJ0IGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWQnLCB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KVxuICAgICAgICB0aGlzLl9jYiA9IGNiXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihudWxsKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZWJ1Zygnd3JpdGUgYmVmb3JlIGNvbm5lY3QnKVxuICAgICAgdGhpcy5fY2h1bmsgPSBjaHVua1xuICAgICAgdGhpcy5fY2IgPSBjYlxuICAgIH1cbiAgfVxuXG4gIC8vIFdoZW4gc3RyZWFtIGZpbmlzaGVzIHdyaXRpbmcsIGNsb3NlIHNvY2tldC4gSGFsZiBvcGVuIGNvbm5lY3Rpb25zIGFyZSBub3RcbiAgLy8gc3VwcG9ydGVkLlxuICBfb25GaW5pc2ggKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAvLyBXYWl0IGEgYml0IGJlZm9yZSBkZXN0cm95aW5nIHNvIHRoZSBzb2NrZXQgZmx1c2hlcy5cbiAgICAvLyBUT0RPOiBpcyB0aGVyZSBhIG1vcmUgcmVsaWFibGUgd2F5IHRvIGFjY29tcGxpc2ggdGhpcz9cbiAgICBjb25zdCBkZXN0cm95U29vbiA9ICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kZXN0cm95KCksIDEwMDApXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgZGVzdHJveVNvb24oKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uY2UoJ2Nvbm5lY3QnLCBkZXN0cm95U29vbilcbiAgICB9XG4gIH1cblxuICBfc3RhcnRJY2VDb21wbGV0ZVRpbWVvdXQgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKHRoaXMuX2ljZUNvbXBsZXRlVGltZXIpIHJldHVyblxuICAgIHRoaXMuX2RlYnVnKCdzdGFydGVkIGljZUNvbXBsZXRlIHRpbWVvdXQnKVxuICAgIHRoaXMuX2ljZUNvbXBsZXRlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5faWNlQ29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5faWNlQ29tcGxldGUgPSB0cnVlXG4gICAgICAgIHRoaXMuX2RlYnVnKCdpY2VDb21wbGV0ZSB0aW1lb3V0IGNvbXBsZXRlZCcpXG4gICAgICAgIHRoaXMuZW1pdCgnaWNlVGltZW91dCcpXG4gICAgICAgIHRoaXMuZW1pdCgnX2ljZUNvbXBsZXRlJylcbiAgICAgIH1cbiAgICB9LCB0aGlzLmljZUNvbXBsZXRlVGltZW91dClcbiAgfVxuXG4gIF9jcmVhdGVPZmZlciAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgIHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHRoaXMub2ZmZXJPcHRpb25zKVxuICAgICAgLnRoZW4ob2ZmZXIgPT4ge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgICBpZiAoIXRoaXMudHJpY2tsZSAmJiAhdGhpcy5hbGxvd0hhbGZUcmlja2xlKSBvZmZlci5zZHAgPSBmaWx0ZXJUcmlja2xlKG9mZmVyLnNkcClcbiAgICAgICAgb2ZmZXIuc2RwID0gdGhpcy5zZHBUcmFuc2Zvcm0ob2ZmZXIuc2RwKVxuXG4gICAgICAgIGNvbnN0IHNlbmRPZmZlciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24gfHwgb2ZmZXJcbiAgICAgICAgICB0aGlzLl9kZWJ1Zygnc2lnbmFsJylcbiAgICAgICAgICB0aGlzLmVtaXQoJ3NpZ25hbCcsIHtcbiAgICAgICAgICAgIHR5cGU6IHNpZ25hbC50eXBlLFxuICAgICAgICAgICAgc2RwOiBzaWduYWwuc2RwXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9uU3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9kZWJ1ZygnY3JlYXRlT2ZmZXIgc3VjY2VzcycpXG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgICBpZiAodGhpcy50cmlja2xlIHx8IHRoaXMuX2ljZUNvbXBsZXRlKSBzZW5kT2ZmZXIoKVxuICAgICAgICAgIGVsc2UgdGhpcy5vbmNlKCdfaWNlQ29tcGxldGUnLCBzZW5kT2ZmZXIpIC8vIHdhaXQgZm9yIGNhbmRpZGF0ZXNcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9TRVRfTE9DQUxfREVTQ1JJUFRJT04nKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpXG4gICAgICAgICAgLnRoZW4ob25TdWNjZXNzKVxuICAgICAgICAgIC5jYXRjaChvbkVycm9yKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfQ1JFQVRFX09GRkVSJykpXG4gICAgICB9KVxuICB9XG5cbiAgX3JlcXVlc3RNaXNzaW5nVHJhbnNjZWl2ZXJzICgpIHtcbiAgICBpZiAodGhpcy5fcGMuZ2V0VHJhbnNjZWl2ZXJzKSB7XG4gICAgICB0aGlzLl9wYy5nZXRUcmFuc2NlaXZlcnMoKS5mb3JFYWNoKHRyYW5zY2VpdmVyID0+IHtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlci5taWQgJiYgdHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrICYmICF0cmFuc2NlaXZlci5yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci5yZXF1ZXN0ZWQgPSB0cnVlIC8vIEhBQ0s6IFNhZmFyaSByZXR1cm5zIG5lZ290aWF0ZWQgdHJhbnNjZWl2ZXJzIHdpdGggYSBudWxsIG1pZFxuICAgICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIodHJhbnNjZWl2ZXIuc2VuZGVyLnRyYWNrLmtpbmQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUFuc3dlciAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgIHRoaXMuX3BjLmNyZWF0ZUFuc3dlcih0aGlzLmFuc3dlck9wdGlvbnMpXG4gICAgICAudGhlbihhbnN3ZXIgPT4ge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgICBpZiAoIXRoaXMudHJpY2tsZSAmJiAhdGhpcy5hbGxvd0hhbGZUcmlja2xlKSBhbnN3ZXIuc2RwID0gZmlsdGVyVHJpY2tsZShhbnN3ZXIuc2RwKVxuICAgICAgICBhbnN3ZXIuc2RwID0gdGhpcy5zZHBUcmFuc2Zvcm0oYW5zd2VyLnNkcClcblxuICAgICAgICBjb25zdCBzZW5kQW5zd2VyID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbiB8fCBhbnN3ZXJcbiAgICAgICAgICB0aGlzLl9kZWJ1Zygnc2lnbmFsJylcbiAgICAgICAgICB0aGlzLmVtaXQoJ3NpZ25hbCcsIHtcbiAgICAgICAgICAgIHR5cGU6IHNpZ25hbC50eXBlLFxuICAgICAgICAgICAgc2RwOiBzaWduYWwuc2RwXG4gICAgICAgICAgfSlcbiAgICAgICAgICBpZiAoIXRoaXMuaW5pdGlhdG9yKSB0aGlzLl9yZXF1ZXN0TWlzc2luZ1RyYW5zY2VpdmVycygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvblN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgICBpZiAodGhpcy50cmlja2xlIHx8IHRoaXMuX2ljZUNvbXBsZXRlKSBzZW5kQW5zd2VyKClcbiAgICAgICAgICBlbHNlIHRoaXMub25jZSgnX2ljZUNvbXBsZXRlJywgc2VuZEFuc3dlcilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9TRVRfTE9DQUxfREVTQ1JJUFRJT04nKSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKVxuICAgICAgICAgIC50aGVuKG9uU3VjY2VzcylcbiAgICAgICAgICAuY2F0Y2gob25FcnJvcilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0NSRUFURV9BTlNXRVInKSlcbiAgICAgIH0pXG4gIH1cblxuICBfb25Db25uZWN0aW9uU3RhdGVDaGFuZ2UgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKHRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKG5ldyBFcnJvcignQ29ubmVjdGlvbiBmYWlsZWQuJyksICdFUlJfQ09OTkVDVElPTl9GQUlMVVJFJykpXG4gICAgfVxuICB9XG5cbiAgX29uSWNlU3RhdGVDaGFuZ2UgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgY29uc3QgaWNlQ29ubmVjdGlvblN0YXRlID0gdGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlXG4gICAgY29uc3QgaWNlR2F0aGVyaW5nU3RhdGUgPSB0aGlzLl9wYy5pY2VHYXRoZXJpbmdTdGF0ZVxuXG4gICAgdGhpcy5fZGVidWcoXG4gICAgICAnaWNlU3RhdGVDaGFuZ2UgKGNvbm5lY3Rpb246ICVzKSAoZ2F0aGVyaW5nOiAlcyknLFxuICAgICAgaWNlQ29ubmVjdGlvblN0YXRlLFxuICAgICAgaWNlR2F0aGVyaW5nU3RhdGVcbiAgICApXG4gICAgdGhpcy5lbWl0KCdpY2VTdGF0ZUNoYW5nZScsIGljZUNvbm5lY3Rpb25TdGF0ZSwgaWNlR2F0aGVyaW5nU3RhdGUpXG5cbiAgICBpZiAoaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJyB8fCBpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICB0aGlzLl9wY1JlYWR5ID0gdHJ1ZVxuICAgICAgdGhpcy5fbWF5YmVSZWFkeSgpXG4gICAgfVxuICAgIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShuZXcgRXJyb3IoJ0ljZSBjb25uZWN0aW9uIGZhaWxlZC4nKSwgJ0VSUl9JQ0VfQ09OTkVDVElPTl9GQUlMVVJFJykpXG4gICAgfVxuICAgIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShuZXcgRXJyb3IoJ0ljZSBjb25uZWN0aW9uIGNsb3NlZC4nKSwgJ0VSUl9JQ0VfQ09OTkVDVElPTl9DTE9TRUQnKSlcbiAgICB9XG4gIH1cblxuICBnZXRTdGF0cyAoY2IpIHtcbiAgICAvLyBzdGF0cmVwb3J0cyBjYW4gY29tZSB3aXRoIGEgdmFsdWUgYXJyYXkgaW5zdGVhZCBvZiBwcm9wZXJ0aWVzXG4gICAgY29uc3QgZmxhdHRlblZhbHVlcyA9IHJlcG9ydCA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlcG9ydC52YWx1ZXMpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHJlcG9ydC52YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXBvcnQsIHZhbHVlKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcG9ydFxuICAgIH1cblxuICAgIC8vIFByb21pc2UtYmFzZWQgZ2V0U3RhdHMoKSAoc3RhbmRhcmQpXG4gICAgaWYgKHRoaXMuX3BjLmdldFN0YXRzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9pc1JlYWN0TmF0aXZlV2VicnRjKSB7XG4gICAgICB0aGlzLl9wYy5nZXRTdGF0cygpXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgY29uc3QgcmVwb3J0cyA9IFtdXG4gICAgICAgICAgcmVzLmZvckVhY2gocmVwb3J0ID0+IHtcbiAgICAgICAgICAgIHJlcG9ydHMucHVzaChmbGF0dGVuVmFsdWVzKHJlcG9ydCkpXG4gICAgICAgICAgfSlcbiAgICAgICAgICBjYihudWxsLCByZXBvcnRzKVxuICAgICAgICB9LCBlcnIgPT4gY2IoZXJyKSlcblxuICAgIC8vIFNpbmdsZS1wYXJhbWV0ZXIgY2FsbGJhY2stYmFzZWQgZ2V0U3RhdHMoKSAobm9uLXN0YW5kYXJkKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fcGMuZ2V0U3RhdHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fcGMuZ2V0U3RhdHMocmVzID0+IHtcbiAgICAgICAgLy8gSWYgd2UgZGVzdHJveSBjb25uZWN0aW9uIGluIGBjb25uZWN0YCBjYWxsYmFjayB0aGlzIGNvZGUgbWlnaHQgaGFwcGVuIHRvIHJ1biB3aGVuIGFjdHVhbCBjb25uZWN0aW9uIGlzIGFscmVhZHkgY2xvc2VkXG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgcmVwb3J0cyA9IFtdXG4gICAgICAgIHJlcy5yZXN1bHQoKS5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICAgICAgY29uc3QgcmVwb3J0ID0ge31cbiAgICAgICAgICByZXN1bHQubmFtZXMoKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgcmVwb3J0W25hbWVdID0gcmVzdWx0LnN0YXQobmFtZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJlcG9ydC5pZCA9IHJlc3VsdC5pZFxuICAgICAgICAgIHJlcG9ydC50eXBlID0gcmVzdWx0LnR5cGVcbiAgICAgICAgICByZXBvcnQudGltZXN0YW1wID0gcmVzdWx0LnRpbWVzdGFtcFxuICAgICAgICAgIHJlcG9ydHMucHVzaChmbGF0dGVuVmFsdWVzKHJlcG9ydCkpXG4gICAgICAgIH0pXG4gICAgICAgIGNiKG51bGwsIHJlcG9ydHMpXG4gICAgICB9LCBlcnIgPT4gY2IoZXJyKSlcblxuICAgIC8vIFVua25vd24gYnJvd3Nlciwgc2tpcCBnZXRTdGF0cygpIHNpbmNlIGl0J3MgYW55b25lJ3MgZ3Vlc3Mgd2hpY2ggc3R5bGUgb2ZcbiAgICAvLyBnZXRTdGF0cygpIHRoZXkgaW1wbGVtZW50LlxuICAgIH0gZWxzZSB7XG4gICAgICBjYihudWxsLCBbXSlcbiAgICB9XG4gIH1cblxuICBfbWF5YmVSZWFkeSAoKSB7XG4gICAgdGhpcy5fZGVidWcoJ21heWJlUmVhZHkgcGMgJXMgY2hhbm5lbCAlcycsIHRoaXMuX3BjUmVhZHksIHRoaXMuX2NoYW5uZWxSZWFkeSlcbiAgICBpZiAodGhpcy5fY29ubmVjdGVkIHx8IHRoaXMuX2Nvbm5lY3RpbmcgfHwgIXRoaXMuX3BjUmVhZHkgfHwgIXRoaXMuX2NoYW5uZWxSZWFkeSkgcmV0dXJuXG5cbiAgICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZVxuXG4gICAgLy8gSEFDSzogV2UgY2FuJ3QgcmVseSBvbiBvcmRlciBoZXJlLCBmb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pzLXBsYXRmb3JtL25vZGUtd2VicnRjL2lzc3Vlcy8zMzlcbiAgICBjb25zdCBmaW5kQ2FuZGlkYXRlUGFpciA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICAgIHRoaXMuZ2V0U3RhdHMoKGVyciwgaXRlbXMpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgICAgICAvLyBUcmVhdCBnZXRTdGF0cyBlcnJvciBhcyBub24tZmF0YWwuIEl0J3Mgbm90IGVzc2VudGlhbC5cbiAgICAgICAgaWYgKGVycikgaXRlbXMgPSBbXVxuXG4gICAgICAgIGNvbnN0IHJlbW90ZUNhbmRpZGF0ZXMgPSB7fVxuICAgICAgICBjb25zdCBsb2NhbENhbmRpZGF0ZXMgPSB7fVxuICAgICAgICBjb25zdCBjYW5kaWRhdGVQYWlycyA9IHt9XG4gICAgICAgIGxldCBmb3VuZFNlbGVjdGVkQ2FuZGlkYXRlUGFpciA9IGZhbHNlXG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAvLyBUT0RPOiBPbmNlIGFsbCBicm93c2VycyBzdXBwb3J0IHRoZSBoeXBoZW5hdGVkIHN0YXRzIHJlcG9ydCB0eXBlcywgcmVtb3ZlXG4gICAgICAgICAgLy8gdGhlIG5vbi1oeXBlbmF0ZWQgb25lc1xuICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdyZW1vdGVjYW5kaWRhdGUnIHx8IGl0ZW0udHlwZSA9PT0gJ3JlbW90ZS1jYW5kaWRhdGUnKSB7XG4gICAgICAgICAgICByZW1vdGVDYW5kaWRhdGVzW2l0ZW0uaWRdID0gaXRlbVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnbG9jYWxjYW5kaWRhdGUnIHx8IGl0ZW0udHlwZSA9PT0gJ2xvY2FsLWNhbmRpZGF0ZScpIHtcbiAgICAgICAgICAgIGxvY2FsQ2FuZGlkYXRlc1tpdGVtLmlkXSA9IGl0ZW1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2NhbmRpZGF0ZXBhaXInIHx8IGl0ZW0udHlwZSA9PT0gJ2NhbmRpZGF0ZS1wYWlyJykge1xuICAgICAgICAgICAgY2FuZGlkYXRlUGFpcnNbaXRlbS5pZF0gPSBpdGVtXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHNldFNlbGVjdGVkQ2FuZGlkYXRlUGFpciA9IHNlbGVjdGVkQ2FuZGlkYXRlUGFpciA9PiB7XG4gICAgICAgICAgZm91bmRTZWxlY3RlZENhbmRpZGF0ZVBhaXIgPSB0cnVlXG5cbiAgICAgICAgICBsZXQgbG9jYWwgPSBsb2NhbENhbmRpZGF0ZXNbc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLmxvY2FsQ2FuZGlkYXRlSWRdXG5cbiAgICAgICAgICBpZiAobG9jYWwgJiYgKGxvY2FsLmlwIHx8IGxvY2FsLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAvLyBTcGVjXG4gICAgICAgICAgICB0aGlzLmxvY2FsQWRkcmVzcyA9IGxvY2FsLmlwIHx8IGxvY2FsLmFkZHJlc3NcbiAgICAgICAgICAgIHRoaXMubG9jYWxQb3J0ID0gTnVtYmVyKGxvY2FsLnBvcnQpXG4gICAgICAgICAgfSBlbHNlIGlmIChsb2NhbCAmJiBsb2NhbC5pcEFkZHJlc3MpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gbG9jYWwuaXBBZGRyZXNzXG4gICAgICAgICAgICB0aGlzLmxvY2FsUG9ydCA9IE51bWJlcihsb2NhbC5wb3J0TnVtYmVyKVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGVjdGVkQ2FuZGlkYXRlUGFpci5nb29nTG9jYWxBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgb25jZSBDaHJvbWUgNTggaXMgcmVsZWFzZWRcbiAgICAgICAgICAgIGxvY2FsID0gc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLmdvb2dMb2NhbEFkZHJlc3Muc3BsaXQoJzonKVxuICAgICAgICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBsb2NhbFswXVxuICAgICAgICAgICAgdGhpcy5sb2NhbFBvcnQgPSBOdW1iZXIobG9jYWxbMV0pXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmxvY2FsQWRkcmVzcykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbEZhbWlseSA9IHRoaXMubG9jYWxBZGRyZXNzLmluY2x1ZGVzKCc6JykgPyAnSVB2NicgOiAnSVB2NCdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgcmVtb3RlID0gcmVtb3RlQ2FuZGlkYXRlc1tzZWxlY3RlZENhbmRpZGF0ZVBhaXIucmVtb3RlQ2FuZGlkYXRlSWRdXG5cbiAgICAgICAgICBpZiAocmVtb3RlICYmIChyZW1vdGUuaXAgfHwgcmVtb3RlLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAvLyBTcGVjXG4gICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSByZW1vdGUuaXAgfHwgcmVtb3RlLmFkZHJlc3NcbiAgICAgICAgICAgIHRoaXMucmVtb3RlUG9ydCA9IE51bWJlcihyZW1vdGUucG9ydClcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlbW90ZSAmJiByZW1vdGUuaXBBZGRyZXNzKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSByZW1vdGUuaXBBZGRyZXNzXG4gICAgICAgICAgICB0aGlzLnJlbW90ZVBvcnQgPSBOdW1iZXIocmVtb3RlLnBvcnROdW1iZXIpXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLmdvb2dSZW1vdGVBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgb25jZSBDaHJvbWUgNTggaXMgcmVsZWFzZWRcbiAgICAgICAgICAgIHJlbW90ZSA9IHNlbGVjdGVkQ2FuZGlkYXRlUGFpci5nb29nUmVtb3RlQWRkcmVzcy5zcGxpdCgnOicpXG4gICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSByZW1vdGVbMF1cbiAgICAgICAgICAgIHRoaXMucmVtb3RlUG9ydCA9IE51bWJlcihyZW1vdGVbMV0pXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnJlbW90ZUFkZHJlc3MpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3RlRmFtaWx5ID0gdGhpcy5yZW1vdGVBZGRyZXNzLmluY2x1ZGVzKCc6JykgPyAnSVB2NicgOiAnSVB2NCdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICAgICAgICdjb25uZWN0IGxvY2FsOiAlczolcyByZW1vdGU6ICVzOiVzJyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxBZGRyZXNzLFxuICAgICAgICAgICAgdGhpcy5sb2NhbFBvcnQsXG4gICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MsXG4gICAgICAgICAgICB0aGlzLnJlbW90ZVBvcnRcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgIC8vIFNwZWMtY29tcGxpYW50XG4gICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ3RyYW5zcG9ydCcgJiYgaXRlbS5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCkge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRDYW5kaWRhdGVQYWlyKGNhbmRpZGF0ZVBhaXJzW2l0ZW0uc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWRdKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE9sZCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoaXRlbS50eXBlID09PSAnZ29vZ0NhbmRpZGF0ZVBhaXInICYmIGl0ZW0uZ29vZ0FjdGl2ZUNvbm5lY3Rpb24gPT09ICd0cnVlJykgfHxcbiAgICAgICAgICAgICgoaXRlbS50eXBlID09PSAnY2FuZGlkYXRlcGFpcicgfHwgaXRlbS50eXBlID09PSAnY2FuZGlkYXRlLXBhaXInKSAmJiBpdGVtLnNlbGVjdGVkKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRDYW5kaWRhdGVQYWlyKGl0ZW0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIElnbm9yZSBjYW5kaWRhdGUgcGFpciBzZWxlY3Rpb24gaW4gYnJvd3NlcnMgbGlrZSBTYWZhcmkgMTEgdGhhdCBkbyBub3QgaGF2ZSBhbnkgbG9jYWwgb3IgcmVtb3RlIGNhbmRpZGF0ZXNcbiAgICAgICAgLy8gQnV0IHdhaXQgdW50aWwgYXQgbGVhc3QgMSBjYW5kaWRhdGUgcGFpciBpcyBhdmFpbGFibGVcbiAgICAgICAgaWYgKCFmb3VuZFNlbGVjdGVkQ2FuZGlkYXRlUGFpciAmJiAoIU9iamVjdC5rZXlzKGNhbmRpZGF0ZVBhaXJzKS5sZW5ndGggfHwgT2JqZWN0LmtleXMobG9jYWxDYW5kaWRhdGVzKS5sZW5ndGgpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmaW5kQ2FuZGlkYXRlUGFpciwgMTAwKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jaHVuaykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNlbmQodGhpcy5fY2h1bmspXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX0RBVEFfQ0hBTk5FTCcpKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jaHVuayA9IG51bGxcbiAgICAgICAgICB0aGlzLl9kZWJ1Zygnc2VudCBjaHVuayBmcm9tIFwid3JpdGUgYmVmb3JlIGNvbm5lY3RcIicpXG5cbiAgICAgICAgICBjb25zdCBjYiA9IHRoaXMuX2NiXG4gICAgICAgICAgdGhpcy5fY2IgPSBudWxsXG4gICAgICAgICAgY2IobnVsbClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGBidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZGAgYW5kICdvbmJ1ZmZlcmVkYW1vdW50bG93JyBhcmUgdW5zdXBwb3J0ZWQsXG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIHVzaW5nIHNldEludGVydmFsIHRvIGltcGxlbWVudCBiYWNrcHJlc3N1cmUuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX29uSW50ZXJ2YWwoKSwgMTUwKVxuICAgICAgICAgIGlmICh0aGlzLl9pbnRlcnZhbC51bnJlZikgdGhpcy5faW50ZXJ2YWwudW5yZWYoKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGVidWcoJ2Nvbm5lY3QnKVxuICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKVxuICAgICAgfSlcbiAgICB9XG4gICAgZmluZENhbmRpZGF0ZVBhaXIoKVxuICB9XG5cbiAgX29uSW50ZXJ2YWwgKCkge1xuICAgIGlmICghdGhpcy5fY2IgfHwgIXRoaXMuX2NoYW5uZWwgfHwgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCA+IE1BWF9CVUZGRVJFRF9BTU9VTlQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLl9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdygpXG4gIH1cblxuICBfb25TaWduYWxpbmdTdGF0ZUNoYW5nZSAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgIGlmICh0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpIHtcbiAgICAgIHRoaXMuX2lzTmVnb3RpYXRpbmcgPSBmYWxzZVxuXG4gICAgICAvLyBIQUNLOiBGaXJlZm94IGRvZXNuJ3QgeWV0IHN1cHBvcnQgcmVtb3ZpbmcgdHJhY2tzIHdoZW4gc2lnbmFsaW5nU3RhdGUgIT09ICdzdGFibGUnXG4gICAgICB0aGlzLl9kZWJ1ZygnZmx1c2hpbmcgc2VuZGVyIHF1ZXVlJywgdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlKVxuICAgICAgdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlLmZvckVhY2goc2VuZGVyID0+IHtcbiAgICAgICAgdGhpcy5fcGMucmVtb3ZlVHJhY2soc2VuZGVyKVxuICAgICAgICB0aGlzLl9xdWV1ZWROZWdvdGlhdGlvbiA9IHRydWVcbiAgICAgIH0pXG4gICAgICB0aGlzLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUgPSBbXVxuXG4gICAgICBpZiAodGhpcy5fcXVldWVkTmVnb3RpYXRpb24pIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ2ZsdXNoaW5nIG5lZ290aWF0aW9uIHF1ZXVlJylcbiAgICAgICAgdGhpcy5fcXVldWVkTmVnb3RpYXRpb24gPSBmYWxzZVxuICAgICAgICB0aGlzLl9uZWVkc05lZ290aWF0aW9uKCkgLy8gbmVnb3RpYXRlIGFnYWluXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnbmVnb3RpYXRlZCcpXG4gICAgICAgIHRoaXMuZW1pdCgnbmVnb3RpYXRlZCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fZGVidWcoJ3NpZ25hbGluZ1N0YXRlQ2hhbmdlICVzJywgdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUpXG4gICAgdGhpcy5lbWl0KCdzaWduYWxpbmdTdGF0ZUNoYW5nZScsIHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlKVxuICB9XG5cbiAgX29uSWNlQ2FuZGlkYXRlIChldmVudCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSAmJiB0aGlzLnRyaWNrbGUpIHtcbiAgICAgIHRoaXMuZW1pdCgnc2lnbmFsJywge1xuICAgICAgICB0eXBlOiAnY2FuZGlkYXRlJyxcbiAgICAgICAgY2FuZGlkYXRlOiB7XG4gICAgICAgICAgY2FuZGlkYXRlOiBldmVudC5jYW5kaWRhdGUuY2FuZGlkYXRlLFxuICAgICAgICAgIHNkcE1MaW5lSW5kZXg6IGV2ZW50LmNhbmRpZGF0ZS5zZHBNTGluZUluZGV4LFxuICAgICAgICAgIHNkcE1pZDogZXZlbnQuY2FuZGlkYXRlLnNkcE1pZFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoIWV2ZW50LmNhbmRpZGF0ZSAmJiAhdGhpcy5faWNlQ29tcGxldGUpIHtcbiAgICAgIHRoaXMuX2ljZUNvbXBsZXRlID0gdHJ1ZVxuICAgICAgdGhpcy5lbWl0KCdfaWNlQ29tcGxldGUnKVxuICAgIH1cbiAgICAvLyBhcyBzb29uIGFzIHdlJ3ZlIHJlY2VpdmVkIG9uZSB2YWxpZCBjYW5kaWRhdGUgc3RhcnQgdGltZW91dFxuICAgIGlmIChldmVudC5jYW5kaWRhdGUpIHtcbiAgICAgIHRoaXMuX3N0YXJ0SWNlQ29tcGxldGVUaW1lb3V0KClcbiAgICB9XG4gIH1cblxuICBfb25DaGFubmVsTWVzc2FnZSAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIGxldCBkYXRhID0gZXZlbnQuZGF0YVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKVxuICAgIHRoaXMucHVzaChkYXRhKVxuICB9XG5cbiAgX29uQ2hhbm5lbEJ1ZmZlcmVkQW1vdW50TG93ICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQgfHwgIXRoaXMuX2NiKSByZXR1cm5cbiAgICB0aGlzLl9kZWJ1ZygnZW5kaW5nIGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWQnLCB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KVxuICAgIGNvbnN0IGNiID0gdGhpcy5fY2JcbiAgICB0aGlzLl9jYiA9IG51bGxcbiAgICBjYihudWxsKVxuICB9XG5cbiAgX29uQ2hhbm5lbE9wZW4gKCkge1xuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQgfHwgdGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIHRoaXMuX2RlYnVnKCdvbiBjaGFubmVsIG9wZW4nKVxuICAgIHRoaXMuX2NoYW5uZWxSZWFkeSA9IHRydWVcbiAgICB0aGlzLl9tYXliZVJlYWR5KClcbiAgfVxuXG4gIF9vbkNoYW5uZWxDbG9zZSAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICB0aGlzLl9kZWJ1Zygnb24gY2hhbm5lbCBjbG9zZScpXG4gICAgdGhpcy5kZXN0cm95KClcbiAgfVxuXG4gIF9vblRyYWNrIChldmVudCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG5cbiAgICBldmVudC5zdHJlYW1zLmZvckVhY2goZXZlbnRTdHJlYW0gPT4ge1xuICAgICAgdGhpcy5fZGVidWcoJ29uIHRyYWNrJylcbiAgICAgIHRoaXMuZW1pdCgndHJhY2snLCBldmVudC50cmFjaywgZXZlbnRTdHJlYW0pXG5cbiAgICAgIHRoaXMuX3JlbW90ZVRyYWNrcy5wdXNoKHtcbiAgICAgICAgdHJhY2s6IGV2ZW50LnRyYWNrLFxuICAgICAgICBzdHJlYW06IGV2ZW50U3RyZWFtXG4gICAgICB9KVxuXG4gICAgICBpZiAodGhpcy5fcmVtb3RlU3RyZWFtcy5zb21lKHJlbW90ZVN0cmVhbSA9PiB7XG4gICAgICAgIHJldHVybiByZW1vdGVTdHJlYW0uaWQgPT09IGV2ZW50U3RyZWFtLmlkXG4gICAgICB9KSkgcmV0dXJuIC8vIE9ubHkgZmlyZSBvbmUgJ3N0cmVhbScgZXZlbnQsIGV2ZW4gdGhvdWdoIHRoZXJlIG1heSBiZSBtdWx0aXBsZSB0cmFja3MgcGVyIHN0cmVhbVxuXG4gICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zLnB1c2goZXZlbnRTdHJlYW0pXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdvbiBzdHJlYW0nKVxuICAgICAgICB0aGlzLmVtaXQoJ3N0cmVhbScsIGV2ZW50U3RyZWFtKSAvLyBlbnN1cmUgYWxsIHRyYWNrcyBoYXZlIGJlZW4gYWRkZWRcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIF9kZWJ1ZyAoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIGFyZ3NbMF0gPSAnWycgKyB0aGlzLl9pZCArICddICcgKyBhcmdzWzBdXG4gICAgZGVidWcuYXBwbHkobnVsbCwgYXJncylcbiAgfVxufVxuXG5QZWVyLldFQlJUQ19TVVBQT1JUID0gISFnZXRCcm93c2VyUlRDKClcblxuLyoqXG4gKiBFeHBvc2UgcGVlciBhbmQgZGF0YSBjaGFubmVsIGNvbmZpZyBmb3Igb3ZlcnJpZGluZyBhbGwgUGVlclxuICogaW5zdGFuY2VzLiBPdGhlcndpc2UsIGp1c3Qgc2V0IG9wdHMuY29uZmlnIG9yIG9wdHMuY2hhbm5lbENvbmZpZ1xuICogd2hlbiBjb25zdHJ1Y3RpbmcgYSBQZWVyLlxuICovXG5QZWVyLmNvbmZpZyA9IHtcbiAgaWNlU2VydmVyczogW1xuICAgIHtcbiAgICAgIHVybHM6IFtcbiAgICAgICAgJ3N0dW46c3R1bi5sLmdvb2dsZS5jb206MTkzMDInLFxuICAgICAgICAnc3R1bjpnbG9iYWwuc3R1bi50d2lsaW8uY29tOjM0NzgnXG4gICAgICBdXG4gICAgfVxuICBdLFxuICBzZHBTZW1hbnRpY3M6ICd1bmlmaWVkLXBsYW4nXG59XG5cblBlZXIuY2hhbm5lbENvbmZpZyA9IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gUGVlclxuIiwidmFyIGVuZ2luZSA9IHJlcXVpcmUoJy4uL3NyYy9zdG9yZS1lbmdpbmUnKVxuXG52YXIgc3RvcmFnZXMgPSByZXF1aXJlKCcuLi9zdG9yYWdlcy9hbGwnKVxudmFyIHBsdWdpbnMgPSBbcmVxdWlyZSgnLi4vcGx1Z2lucy9qc29uMicpXVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVuZ2luZS5jcmVhdGVTdG9yZShzdG9yYWdlcywgcGx1Z2lucylcbiIsIm1vZHVsZS5leHBvcnRzID0ganNvbjJQbHVnaW5cblxuZnVuY3Rpb24ganNvbjJQbHVnaW4oKSB7XG5cdHJlcXVpcmUoJy4vbGliL2pzb24yJylcblx0cmV0dXJuIHt9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vLyAganNvbjIuanNcbi8vICAyMDE2LTEwLTI4XG4vLyAgUHVibGljIERvbWFpbi5cbi8vICBOTyBXQVJSQU5UWSBFWFBSRVNTRUQgT1IgSU1QTElFRC4gVVNFIEFUIFlPVVIgT1dOIFJJU0suXG4vLyAgU2VlIGh0dHA6Ly93d3cuSlNPTi5vcmcvanMuaHRtbFxuLy8gIFRoaXMgY29kZSBzaG91bGQgYmUgbWluaWZpZWQgYmVmb3JlIGRlcGxveW1lbnQuXG4vLyAgU2VlIGh0dHA6Ly9qYXZhc2NyaXB0LmNyb2NrZm9yZC5jb20vanNtaW4uaHRtbFxuXG4vLyAgVVNFIFlPVVIgT1dOIENPUFkuIElUIElTIEVYVFJFTUVMWSBVTldJU0UgVE8gTE9BRCBDT0RFIEZST00gU0VSVkVSUyBZT1UgRE9cbi8vICBOT1QgQ09OVFJPTC5cblxuLy8gIFRoaXMgZmlsZSBjcmVhdGVzIGEgZ2xvYmFsIEpTT04gb2JqZWN0IGNvbnRhaW5pbmcgdHdvIG1ldGhvZHM6IHN0cmluZ2lmeVxuLy8gIGFuZCBwYXJzZS4gVGhpcyBmaWxlIHByb3ZpZGVzIHRoZSBFUzUgSlNPTiBjYXBhYmlsaXR5IHRvIEVTMyBzeXN0ZW1zLlxuLy8gIElmIGEgcHJvamVjdCBtaWdodCBydW4gb24gSUU4IG9yIGVhcmxpZXIsIHRoZW4gdGhpcyBmaWxlIHNob3VsZCBiZSBpbmNsdWRlZC5cbi8vICBUaGlzIGZpbGUgZG9lcyBub3RoaW5nIG9uIEVTNSBzeXN0ZW1zLlxuXG4vLyAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpXG4vLyAgICAgICAgICB2YWx1ZSAgICAgICBhbnkgSmF2YVNjcmlwdCB2YWx1ZSwgdXN1YWxseSBhbiBvYmplY3Qgb3IgYXJyYXkuXG4vLyAgICAgICAgICByZXBsYWNlciAgICBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBkZXRlcm1pbmVzIGhvdyBvYmplY3Rcbi8vICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBhcmUgc3RyaW5naWZpZWQgZm9yIG9iamVjdHMuIEl0IGNhbiBiZSBhXG4vLyAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxuLy8gICAgICAgICAgc3BhY2UgICAgICAgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuLy8gICAgICAgICAgICAgICAgICAgICAgb2YgbmVzdGVkIHN0cnVjdHVyZXMuIElmIGl0IGlzIG9taXR0ZWQsIHRoZSB0ZXh0IHdpbGxcbi8vICAgICAgICAgICAgICAgICAgICAgIGJlIHBhY2tlZCB3aXRob3V0IGV4dHJhIHdoaXRlc3BhY2UuIElmIGl0IGlzIGEgbnVtYmVyLFxuLy8gICAgICAgICAgICAgICAgICAgICAgaXQgd2lsbCBzcGVjaWZ5IHRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIGluZGVudCBhdCBlYWNoXG4vLyAgICAgICAgICAgICAgICAgICAgICBsZXZlbC4gSWYgaXQgaXMgYSBzdHJpbmcgKHN1Y2ggYXMgXCJcXHRcIiBvciBcIiZuYnNwO1wiKSxcbi8vICAgICAgICAgICAgICAgICAgICAgIGl0IGNvbnRhaW5zIHRoZSBjaGFyYWN0ZXJzIHVzZWQgdG8gaW5kZW50IGF0IGVhY2ggbGV2ZWwuXG4vLyAgICAgICAgICBUaGlzIG1ldGhvZCBwcm9kdWNlcyBhIEpTT04gdGV4dCBmcm9tIGEgSmF2YVNjcmlwdCB2YWx1ZS5cbi8vICAgICAgICAgIFdoZW4gYW4gb2JqZWN0IHZhbHVlIGlzIGZvdW5kLCBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIGEgdG9KU09OXG4vLyAgICAgICAgICBtZXRob2QsIGl0cyB0b0pTT04gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFuZCB0aGUgcmVzdWx0IHdpbGwgYmVcbi8vICAgICAgICAgIHN0cmluZ2lmaWVkLiBBIHRvSlNPTiBtZXRob2QgZG9lcyBub3Qgc2VyaWFsaXplOiBpdCByZXR1cm5zIHRoZVxuLy8gICAgICAgICAgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIG5hbWUvdmFsdWUgcGFpciB0aGF0IHNob3VsZCBiZSBzZXJpYWxpemVkLFxuLy8gICAgICAgICAgb3IgdW5kZWZpbmVkIGlmIG5vdGhpbmcgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSB0b0pTT04gbWV0aG9kXG4vLyAgICAgICAgICB3aWxsIGJlIHBhc3NlZCB0aGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgdmFsdWUsIGFuZCB0aGlzIHdpbGwgYmVcbi8vICAgICAgICAgIGJvdW5kIHRvIHRoZSB2YWx1ZS5cblxuLy8gICAgICAgICAgRm9yIGV4YW1wbGUsIHRoaXMgd291bGQgc2VyaWFsaXplIERhdGVzIGFzIElTTyBzdHJpbmdzLlxuXG4vLyAgICAgICAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKGtleSkge1xuLy8gICAgICAgICAgICAgICAgICBmdW5jdGlvbiBmKG4pIHtcbi8vICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4vLyAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG4gPCAxMClcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiMFwiICsgblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgIDogbjtcbi8vICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRVVENGdWxsWWVhcigpICAgKyBcIi1cIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01vbnRoKCkgKyAxKSArIFwiLVwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDRGF0ZSgpKSAgICAgICsgXCJUXCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSAgICAgKyBcIjpcIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkgICArIFwiOlwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKSAgICsgXCJaXCI7XG4vLyAgICAgICAgICAgICAgfTtcblxuLy8gICAgICAgICAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsIHJlcGxhY2VyIG1ldGhvZC4gSXQgd2lsbCBiZSBwYXNzZWQgdGhlXG4vLyAgICAgICAgICBrZXkgYW5kIHZhbHVlIG9mIGVhY2ggbWVtYmVyLCB3aXRoIHRoaXMgYm91bmQgdG8gdGhlIGNvbnRhaW5pbmdcbi8vICAgICAgICAgIG9iamVjdC4gVGhlIHZhbHVlIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSB5b3VyIG1ldGhvZCB3aWxsIGJlXG4vLyAgICAgICAgICBzZXJpYWxpemVkLiBJZiB5b3VyIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZCwgdGhlbiB0aGUgbWVtYmVyIHdpbGxcbi8vICAgICAgICAgIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIHNlcmlhbGl6YXRpb24uXG5cbi8vICAgICAgICAgIElmIHRoZSByZXBsYWNlciBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgdGhlbiBpdCB3aWxsIGJlXG4vLyAgICAgICAgICB1c2VkIHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZSBzZXJpYWxpemVkLiBJdCBmaWx0ZXJzIHRoZSByZXN1bHRzXG4vLyAgICAgICAgICBzdWNoIHRoYXQgb25seSBtZW1iZXJzIHdpdGgga2V5cyBsaXN0ZWQgaW4gdGhlIHJlcGxhY2VyIGFycmF5IGFyZVxuLy8gICAgICAgICAgc3RyaW5naWZpZWQuXG5cbi8vICAgICAgICAgIFZhbHVlcyB0aGF0IGRvIG5vdCBoYXZlIEpTT04gcmVwcmVzZW50YXRpb25zLCBzdWNoIGFzIHVuZGVmaW5lZCBvclxuLy8gICAgICAgICAgZnVuY3Rpb25zLCB3aWxsIG5vdCBiZSBzZXJpYWxpemVkLiBTdWNoIHZhbHVlcyBpbiBvYmplY3RzIHdpbGwgYmVcbi8vICAgICAgICAgIGRyb3BwZWQ7IGluIGFycmF5cyB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBudWxsLiBZb3UgY2FuIHVzZVxuLy8gICAgICAgICAgYSByZXBsYWNlciBmdW5jdGlvbiB0byByZXBsYWNlIHRob3NlIHdpdGggSlNPTiB2YWx1ZXMuXG5cbi8vICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHVuZGVmaW5lZCkgcmV0dXJucyB1bmRlZmluZWQuXG5cbi8vICAgICAgICAgIFRoZSBvcHRpb25hbCBzcGFjZSBwYXJhbWV0ZXIgcHJvZHVjZXMgYSBzdHJpbmdpZmljYXRpb24gb2YgdGhlXG4vLyAgICAgICAgICB2YWx1ZSB0aGF0IGlzIGZpbGxlZCB3aXRoIGxpbmUgYnJlYWtzIGFuZCBpbmRlbnRhdGlvbiB0byBtYWtlIGl0XG4vLyAgICAgICAgICBlYXNpZXIgdG8gcmVhZC5cblxuLy8gICAgICAgICAgSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG5vbi1lbXB0eSBzdHJpbmcsIHRoZW4gdGhhdCBzdHJpbmcgd2lsbFxuLy8gICAgICAgICAgYmUgdXNlZCBmb3IgaW5kZW50YXRpb24uIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIHRoZW5cbi8vICAgICAgICAgIHRoZSBpbmRlbnRhdGlvbiB3aWxsIGJlIHRoYXQgbWFueSBzcGFjZXMuXG5cbi8vICAgICAgICAgIEV4YW1wbGU6XG5cbi8vICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbXCJlXCIsIHtwbHVyaWJ1czogXCJ1bnVtXCJ9XSk7XG4vLyAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJlXCIse1wicGx1cmlidXNcIjpcInVudW1cIn1dJ1xuXG4vLyAgICAgICAgICB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoW1wiZVwiLCB7cGx1cmlidXM6IFwidW51bVwifV0sIG51bGwsIFwiXFx0XCIpO1xuLy8gICAgICAgICAgLy8gdGV4dCBpcyAnW1xcblxcdFwiZVwiLFxcblxcdHtcXG5cXHRcXHRcInBsdXJpYnVzXCI6IFwidW51bVwiXFxuXFx0fVxcbl0nXG5cbi8vICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbbmV3IERhdGUoKV0sIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5XSBpbnN0YW5jZW9mIERhdGVcbi8vICAgICAgICAgICAgICAgICAgPyBcIkRhdGUoXCIgKyB0aGlzW2tleV0gKyBcIilcIlxuLy8gICAgICAgICAgICAgICAgICA6IHZhbHVlO1xuLy8gICAgICAgICAgfSk7XG4vLyAgICAgICAgICAvLyB0ZXh0IGlzICdbXCJEYXRlKC0tLWN1cnJlbnQgdGltZS0tLSlcIl0nXG5cbi8vICAgICAgSlNPTi5wYXJzZSh0ZXh0LCByZXZpdmVyKVxuLy8gICAgICAgICAgVGhpcyBtZXRob2QgcGFyc2VzIGEgSlNPTiB0ZXh0IHRvIHByb2R1Y2UgYW4gb2JqZWN0IG9yIGFycmF5LlxuLy8gICAgICAgICAgSXQgY2FuIHRocm93IGEgU3ludGF4RXJyb3IgZXhjZXB0aW9uLlxuXG4vLyAgICAgICAgICBUaGUgb3B0aW9uYWwgcmV2aXZlciBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBmaWx0ZXIgYW5kXG4vLyAgICAgICAgICB0cmFuc2Zvcm0gdGhlIHJlc3VsdHMuIEl0IHJlY2VpdmVzIGVhY2ggb2YgdGhlIGtleXMgYW5kIHZhbHVlcyxcbi8vICAgICAgICAgIGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgdmFsdWUuXG4vLyAgICAgICAgICBJZiBpdCByZXR1cm5zIHdoYXQgaXQgcmVjZWl2ZWQsIHRoZW4gdGhlIHN0cnVjdHVyZSBpcyBub3QgbW9kaWZpZWQuXG4vLyAgICAgICAgICBJZiBpdCByZXR1cm5zIHVuZGVmaW5lZCB0aGVuIHRoZSBtZW1iZXIgaXMgZGVsZXRlZC5cblxuLy8gICAgICAgICAgRXhhbXBsZTpcblxuLy8gICAgICAgICAgLy8gUGFyc2UgdGhlIHRleHQuIFZhbHVlcyB0aGF0IGxvb2sgbGlrZSBJU08gZGF0ZSBzdHJpbmdzIHdpbGxcbi8vICAgICAgICAgIC8vIGJlIGNvbnZlcnRlZCB0byBEYXRlIG9iamVjdHMuXG5cbi8vICAgICAgICAgIG15RGF0YSA9IEpTT04ucGFyc2UodGV4dCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbi8vICAgICAgICAgICAgICB2YXIgYTtcbi8vICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4vLyAgICAgICAgICAgICAgICAgIGEgPVxuLy8gICAvXihcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pVChcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0oPzpcXC5cXGQqKT8pWiQvLmV4ZWModmFsdWUpO1xuLy8gICAgICAgICAgICAgICAgICBpZiAoYSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKCthWzFdLCArYVsyXSAtIDEsICthWzNdLCArYVs0XSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICArYVs1XSwgK2FbNl0pKTtcbi8vICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4vLyAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgbXlEYXRhID0gSlNPTi5wYXJzZSgnW1wiRGF0ZSgwOS8wOS8yMDAxKVwiXScsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4vLyAgICAgICAgICAgICAgdmFyIGQ7XG4vLyAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuLy8gICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoMCwgNSkgPT09IFwiRGF0ZShcIiAmJlxuLy8gICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoLTEpID09PSBcIilcIikge1xuLy8gICAgICAgICAgICAgICAgICBkID0gbmV3IERhdGUodmFsdWUuc2xpY2UoNSwgLTEpKTtcbi8vICAgICAgICAgICAgICAgICAgaWYgKGQpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuLy8gICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbi8vICAgICAgICAgIH0pO1xuXG4vLyAgVGhpcyBpcyBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi4gWW91IGFyZSBmcmVlIHRvIGNvcHksIG1vZGlmeSwgb3Jcbi8vICByZWRpc3RyaWJ1dGUuXG5cbi8qanNsaW50XG4gICAgZXZhbCwgZm9yLCB0aGlzXG4qL1xuXG4vKnByb3BlcnR5XG4gICAgSlNPTiwgYXBwbHksIGNhbGwsIGNoYXJDb2RlQXQsIGdldFVUQ0RhdGUsIGdldFVUQ0Z1bGxZZWFyLCBnZXRVVENIb3VycyxcbiAgICBnZXRVVENNaW51dGVzLCBnZXRVVENNb250aCwgZ2V0VVRDU2Vjb25kcywgaGFzT3duUHJvcGVydHksIGpvaW4sXG4gICAgbGFzdEluZGV4LCBsZW5ndGgsIHBhcnNlLCBwcm90b3R5cGUsIHB1c2gsIHJlcGxhY2UsIHNsaWNlLCBzdHJpbmdpZnksXG4gICAgdGVzdCwgdG9KU09OLCB0b1N0cmluZywgdmFsdWVPZlxuKi9cblxuXG4vLyBDcmVhdGUgYSBKU09OIG9iamVjdCBvbmx5IGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LiBXZSBjcmVhdGUgdGhlXG4vLyBtZXRob2RzIGluIGEgY2xvc3VyZSB0byBhdm9pZCBjcmVhdGluZyBnbG9iYWwgdmFyaWFibGVzLlxuXG5pZiAodHlwZW9mIEpTT04gIT09IFwib2JqZWN0XCIpIHtcbiAgICBKU09OID0ge307XG59XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgcnhfb25lID0gL15bXFxdLDp7fVxcc10qJC87XG4gICAgdmFyIHJ4X3R3byA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XG4gICAgdmFyIHJ4X3RocmVlID0gL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nO1xuICAgIHZhciByeF9mb3VyID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nO1xuICAgIHZhciByeF9lc2NhcGFibGUgPSAvW1xcXFxcIlxcdTAwMDAtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nO1xuICAgIHZhciByeF9kYW5nZXJvdXMgPSAvW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZztcblxuICAgIGZ1bmN0aW9uIGYobikge1xuICAgICAgICAvLyBGb3JtYXQgaW50ZWdlcnMgdG8gaGF2ZSBhdCBsZWFzdCB0d28gZGlnaXRzLlxuICAgICAgICByZXR1cm4gbiA8IDEwXG4gICAgICAgICAgICA/IFwiMFwiICsgblxuICAgICAgICAgICAgOiBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRoaXNfdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIERhdGUucHJvdG90eXBlLnRvSlNPTiAhPT0gXCJmdW5jdGlvblwiKSB7XG5cbiAgICAgICAgRGF0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodGhpcy52YWx1ZU9mKCkpXG4gICAgICAgICAgICAgICAgPyB0aGlzLmdldFVUQ0Z1bGxZZWFyKCkgKyBcIi1cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTW9udGgoKSArIDEpICsgXCItXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0RhdGUoKSkgKyBcIlRcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDSG91cnMoKSkgKyBcIjpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTWludXRlcygpKSArIFwiOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENTZWNvbmRzKCkpICsgXCJaXCJcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgQm9vbGVhbi5wcm90b3R5cGUudG9KU09OID0gdGhpc192YWx1ZTtcbiAgICAgICAgTnVtYmVyLnByb3RvdHlwZS50b0pTT04gPSB0aGlzX3ZhbHVlO1xuICAgICAgICBTdHJpbmcucHJvdG90eXBlLnRvSlNPTiA9IHRoaXNfdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGdhcDtcbiAgICB2YXIgaW5kZW50O1xuICAgIHZhciBtZXRhO1xuICAgIHZhciByZXA7XG5cblxuICAgIGZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuXG4vLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG4vLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4vLyBzZXF1ZW5jZXMuXG5cbiAgICAgICAgcnhfZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiByeF9lc2NhcGFibGUudGVzdChzdHJpbmcpXG4gICAgICAgICAgICA/IFwiXFxcIlwiICsgc3RyaW5nLnJlcGxhY2UocnhfZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgPyBjXG4gICAgICAgICAgICAgICAgICAgIDogXCJcXFxcdVwiICsgKFwiMDAwMFwiICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgfSkgKyBcIlxcXCJcIlxuICAgICAgICAgICAgOiBcIlxcXCJcIiArIHN0cmluZyArIFwiXFxcIlwiO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG5cbi8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cblxuICAgICAgICB2YXIgaTsgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgdmFyIGs7ICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICB2YXIgdjsgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgdmFyIG1pbmQgPSBnYXA7XG4gICAgICAgIHZhciBwYXJ0aWFsO1xuICAgICAgICB2YXIgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICAgICAgfVxuXG4vLyBJZiB3ZSB3ZXJlIGNhbGxlZCB3aXRoIGEgcmVwbGFjZXIgZnVuY3Rpb24sIHRoZW4gY2FsbCB0aGUgcmVwbGFjZXIgdG9cbi8vIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4vLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG5cbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcblxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG5cbi8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuXG4gICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcodmFsdWUpXG4gICAgICAgICAgICAgICAgOiBcIm51bGxcIjtcblxuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBjYXNlIFwibnVsbFwiOlxuXG4vLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4vLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlIFwibnVsbFwiLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG4vLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcblxuLy8gSWYgdGhlIHR5cGUgaXMgXCJvYmplY3RcIiwgd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGFuIG9iamVjdCBvciBhbiBhcnJheSBvclxuLy8gbnVsbC5cblxuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG5cbi8vIER1ZSB0byBhIHNwZWNpZmljYXRpb24gYmx1bmRlciBpbiBFQ01BU2NyaXB0LCB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLFxuLy8gc28gd2F0Y2ggb3V0IGZvciB0aGF0IGNhc2UuXG5cbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgICB9XG5cbi8vIE1ha2UgYW4gYXJyYXkgdG8gaG9sZCB0aGUgcGFydGlhbCByZXN1bHRzIG9mIHN0cmluZ2lmeWluZyB0aGlzIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcblxuLy8gSXMgdGhlIHZhbHVlIGFuIGFycmF5P1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuXG4vLyBUaGUgdmFsdWUgaXMgYW4gYXJyYXkuIFN0cmluZ2lmeSBldmVyeSBlbGVtZW50LiBVc2UgbnVsbCBhcyBhIHBsYWNlaG9sZGVyXG4vLyBmb3Igbm9uLUpTT04gdmFsdWVzLlxuXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCBcIm51bGxcIjtcbiAgICAgICAgICAgICAgICB9XG5cbi8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmQgd3JhcCB0aGVtIGluXG4vLyBicmFja2V0cy5cblxuICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICA/IFwiW11cIlxuICAgICAgICAgICAgICAgICAgICA6IGdhcFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIltcXG5cIiArIGdhcCArIHBhcnRpYWwuam9pbihcIixcXG5cIiArIGdhcCkgKyBcIlxcblwiICsgbWluZCArIFwiXVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiW1wiICsgcGFydGlhbC5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG5cbi8vIElmIHRoZSByZXBsYWNlciBpcyBhbiBhcnJheSwgdXNlIGl0IHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZSBzdHJpbmdpZmllZC5cblxuICAgICAgICAgICAgaWYgKHJlcCAmJiB0eXBlb2YgcmVwID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBbaV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSByZXBbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCI6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiOlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIjogXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI6XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbi8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcbi8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuXG4gICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICA/IFwie31cIlxuICAgICAgICAgICAgICAgIDogZ2FwXG4gICAgICAgICAgICAgICAgICAgID8gXCJ7XFxuXCIgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oXCIsXFxuXCIgKyBnYXApICsgXCJcXG5cIiArIG1pbmQgKyBcIn1cIlxuICAgICAgICAgICAgICAgICAgICA6IFwie1wiICsgcGFydGlhbC5qb2luKFwiLFwiKSArIFwifVwiO1xuICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgfVxuXG4vLyBJZiB0aGUgSlNPTiBvYmplY3QgZG9lcyBub3QgeWV0IGhhdmUgYSBzdHJpbmdpZnkgbWV0aG9kLCBnaXZlIGl0IG9uZS5cblxuICAgIGlmICh0eXBlb2YgSlNPTi5zdHJpbmdpZnkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBtZXRhID0geyAgICAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAgICAgXCJcXGJcIjogXCJcXFxcYlwiLFxuICAgICAgICAgICAgXCJcXHRcIjogXCJcXFxcdFwiLFxuICAgICAgICAgICAgXCJcXG5cIjogXCJcXFxcblwiLFxuICAgICAgICAgICAgXCJcXGZcIjogXCJcXFxcZlwiLFxuICAgICAgICAgICAgXCJcXHJcIjogXCJcXFxcclwiLFxuICAgICAgICAgICAgXCJcXFwiXCI6IFwiXFxcXFxcXCJcIixcbiAgICAgICAgICAgIFwiXFxcXFwiOiBcIlxcXFxcXFxcXCJcbiAgICAgICAgfTtcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuXG4vLyBUaGUgc3RyaW5naWZ5IG1ldGhvZCB0YWtlcyBhIHZhbHVlIGFuZCBhbiBvcHRpb25hbCByZXBsYWNlciwgYW5kIGFuIG9wdGlvbmFsXG4vLyBzcGFjZSBwYXJhbWV0ZXIsIGFuZCByZXR1cm5zIGEgSlNPTiB0ZXh0LiBUaGUgcmVwbGFjZXIgY2FuIGJlIGEgZnVuY3Rpb25cbi8vIHRoYXQgY2FuIHJlcGxhY2UgdmFsdWVzLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgd2lsbCBzZWxlY3QgdGhlIGtleXMuXG4vLyBBIGRlZmF1bHQgcmVwbGFjZXIgbWV0aG9kIGNhbiBiZSBwcm92aWRlZC4gVXNlIG9mIHRoZSBzcGFjZSBwYXJhbWV0ZXIgY2FuXG4vLyBwcm9kdWNlIHRleHQgdGhhdCBpcyBtb3JlIGVhc2lseSByZWFkYWJsZS5cblxuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBnYXAgPSBcIlwiO1xuICAgICAgICAgICAgaW5kZW50ID0gXCJcIjtcblxuLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuLy8gbWFueSBzcGFjZXMuXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhY2U7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKz0gXCIgXCI7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50ID0gc3BhY2U7XG4gICAgICAgICAgICB9XG5cbi8vIElmIHRoZXJlIGlzIGEgcmVwbGFjZXIsIGl0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheS5cbi8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG5cbiAgICAgICAgICAgIHJlcCA9IHJlcGxhY2VyO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgcmVwbGFjZXIgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJKU09OLnN0cmluZ2lmeVwiKTtcbiAgICAgICAgICAgIH1cblxuLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiBcIlwiLlxuLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cblxuICAgICAgICAgICAgcmV0dXJuIHN0cihcIlwiLCB7XCJcIjogdmFsdWV9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cblxuLy8gSWYgdGhlIEpTT04gb2JqZWN0IGRvZXMgbm90IHlldCBoYXZlIGEgcGFyc2UgbWV0aG9kLCBnaXZlIGl0IG9uZS5cblxuICAgIGlmICh0eXBlb2YgSlNPTi5wYXJzZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEpTT04ucGFyc2UgPSBmdW5jdGlvbiAodGV4dCwgcmV2aXZlcikge1xuXG4vLyBUaGUgcGFyc2UgbWV0aG9kIHRha2VzIGEgdGV4dCBhbmQgYW4gb3B0aW9uYWwgcmV2aXZlciBmdW5jdGlvbiwgYW5kIHJldHVybnNcbi8vIGEgSmF2YVNjcmlwdCB2YWx1ZSBpZiB0aGUgdGV4dCBpcyBhIHZhbGlkIEpTT04gdGV4dC5cblxuICAgICAgICAgICAgdmFyIGo7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcblxuLy8gVGhlIHdhbGsgbWV0aG9kIGlzIHVzZWQgdG8gcmVjdXJzaXZlbHkgd2FsayB0aGUgcmVzdWx0aW5nIHN0cnVjdHVyZSBzb1xuLy8gdGhhdCBtb2RpZmljYXRpb25zIGNhbiBiZSBtYWRlLlxuXG4gICAgICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICAgICAgdmFyIHY7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG5cbi8vIFBhcnNpbmcgaGFwcGVucyBpbiBmb3VyIHN0YWdlcy4gSW4gdGhlIGZpcnN0IHN0YWdlLCB3ZSByZXBsYWNlIGNlcnRhaW5cbi8vIFVuaWNvZGUgY2hhcmFjdGVycyB3aXRoIGVzY2FwZSBzZXF1ZW5jZXMuIEphdmFTY3JpcHQgaGFuZGxlcyBtYW55IGNoYXJhY3RlcnNcbi8vIGluY29ycmVjdGx5LCBlaXRoZXIgc2lsZW50bHkgZGVsZXRpbmcgdGhlbSwgb3IgdHJlYXRpbmcgdGhlbSBhcyBsaW5lIGVuZGluZ3MuXG5cbiAgICAgICAgICAgIHRleHQgPSBTdHJpbmcodGV4dCk7XG4gICAgICAgICAgICByeF9kYW5nZXJvdXMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGlmIChyeF9kYW5nZXJvdXMudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocnhfZGFuZ2Vyb3VzLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcdVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCIwMDAwXCIgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbi8vIEluIHRoZSBzZWNvbmQgc3RhZ2UsIHdlIHJ1biB0aGUgdGV4dCBhZ2FpbnN0IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBsb29rXG4vLyBmb3Igbm9uLUpTT04gcGF0dGVybnMuIFdlIGFyZSBlc3BlY2lhbGx5IGNvbmNlcm5lZCB3aXRoIFwiKClcIiBhbmQgXCJuZXdcIlxuLy8gYmVjYXVzZSB0aGV5IGNhbiBjYXVzZSBpbnZvY2F0aW9uLCBhbmQgXCI9XCIgYmVjYXVzZSBpdCBjYW4gY2F1c2UgbXV0YXRpb24uXG4vLyBCdXQganVzdCB0byBiZSBzYWZlLCB3ZSB3YW50IHRvIHJlamVjdCBhbGwgdW5leHBlY3RlZCBmb3Jtcy5cblxuLy8gV2Ugc3BsaXQgdGhlIHNlY29uZCBzdGFnZSBpbnRvIDQgcmVnZXhwIG9wZXJhdGlvbnMgaW4gb3JkZXIgdG8gd29yayBhcm91bmRcbi8vIGNyaXBwbGluZyBpbmVmZmljaWVuY2llcyBpbiBJRSdzIGFuZCBTYWZhcmkncyByZWdleHAgZW5naW5lcy4gRmlyc3Qgd2Vcbi8vIHJlcGxhY2UgdGhlIEpTT04gYmFja3NsYXNoIHBhaXJzIHdpdGggXCJAXCIgKGEgbm9uLUpTT04gY2hhcmFjdGVyKS4gU2Vjb25kLCB3ZVxuLy8gcmVwbGFjZSBhbGwgc2ltcGxlIHZhbHVlIHRva2VucyB3aXRoIFwiXVwiIGNoYXJhY3RlcnMuIFRoaXJkLCB3ZSBkZWxldGUgYWxsXG4vLyBvcGVuIGJyYWNrZXRzIHRoYXQgZm9sbG93IGEgY29sb24gb3IgY29tbWEgb3IgdGhhdCBiZWdpbiB0aGUgdGV4dC4gRmluYWxseSxcbi8vIHdlIGxvb2sgdG8gc2VlIHRoYXQgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGFyZSBvbmx5IHdoaXRlc3BhY2Ugb3IgXCJdXCIgb3Jcbi8vIFwiLFwiIG9yIFwiOlwiIG9yIFwie1wiIG9yIFwifVwiLiBJZiB0aGF0IGlzIHNvLCB0aGVuIHRoZSB0ZXh0IGlzIHNhZmUgZm9yIGV2YWwuXG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICByeF9vbmUudGVzdChcbiAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UocnhfdHdvLCBcIkBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJ4X3RocmVlLCBcIl1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJ4X2ZvdXIsIFwiXCIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG5cbi8vIEluIHRoZSB0aGlyZCBzdGFnZSB3ZSB1c2UgdGhlIGV2YWwgZnVuY3Rpb24gdG8gY29tcGlsZSB0aGUgdGV4dCBpbnRvIGFcbi8vIEphdmFTY3JpcHQgc3RydWN0dXJlLiBUaGUgXCJ7XCIgb3BlcmF0b3IgaXMgc3ViamVjdCB0byBhIHN5bnRhY3RpYyBhbWJpZ3VpdHlcbi8vIGluIEphdmFTY3JpcHQ6IGl0IGNhbiBiZWdpbiBhIGJsb2NrIG9yIGFuIG9iamVjdCBsaXRlcmFsLiBXZSB3cmFwIHRoZSB0ZXh0XG4vLyBpbiBwYXJlbnMgdG8gZWxpbWluYXRlIHRoZSBhbWJpZ3VpdHkuXG5cbiAgICAgICAgICAgICAgICBqID0gZXZhbChcIihcIiArIHRleHQgKyBcIilcIik7XG5cbi8vIEluIHRoZSBvcHRpb25hbCBmb3VydGggc3RhZ2UsIHdlIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIG5ldyBzdHJ1Y3R1cmUsIHBhc3Npbmdcbi8vIGVhY2ggbmFtZS92YWx1ZSBwYWlyIHRvIGEgcmV2aXZlciBmdW5jdGlvbiBmb3IgcG9zc2libGUgdHJhbnNmb3JtYXRpb24uXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGVvZiByZXZpdmVyID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgID8gd2Fsayh7XCJcIjogan0sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIDogajtcbiAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHRleHQgaXMgbm90IEpTT04gcGFyc2VhYmxlLCB0aGVuIGEgU3ludGF4RXJyb3IgaXMgdGhyb3duLlxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJKU09OLnBhcnNlXCIpO1xuICAgICAgICB9O1xuICAgIH1cbn0oKSk7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxudmFyIHNsaWNlID0gdXRpbC5zbGljZVxudmFyIHBsdWNrID0gdXRpbC5wbHVja1xudmFyIGVhY2ggPSB1dGlsLmVhY2hcbnZhciBiaW5kID0gdXRpbC5iaW5kXG52YXIgY3JlYXRlID0gdXRpbC5jcmVhdGVcbnZhciBpc0xpc3QgPSB1dGlsLmlzTGlzdFxudmFyIGlzRnVuY3Rpb24gPSB1dGlsLmlzRnVuY3Rpb25cbnZhciBpc09iamVjdCA9IHV0aWwuaXNPYmplY3RcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGNyZWF0ZVN0b3JlOiBjcmVhdGVTdG9yZVxufVxuXG52YXIgc3RvcmVBUEkgPSB7XG5cdHZlcnNpb246ICcyLjAuMTInLFxuXHRlbmFibGVkOiBmYWxzZSxcblx0XG5cdC8vIGdldCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4ga2V5LiBJZiB0aGF0IHZhbHVlXG5cdC8vIGlzIHVuZGVmaW5lZCwgaXQgcmV0dXJucyBvcHRpb25hbERlZmF1bHRWYWx1ZSBpbnN0ZWFkLlxuXHRnZXQ6IGZ1bmN0aW9uKGtleSwgb3B0aW9uYWxEZWZhdWx0VmFsdWUpIHtcblx0XHR2YXIgZGF0YSA9IHRoaXMuc3RvcmFnZS5yZWFkKHRoaXMuX25hbWVzcGFjZVByZWZpeCArIGtleSlcblx0XHRyZXR1cm4gdGhpcy5fZGVzZXJpYWxpemUoZGF0YSwgb3B0aW9uYWxEZWZhdWx0VmFsdWUpXG5cdH0sXG5cblx0Ly8gc2V0IHdpbGwgc3RvcmUgdGhlIGdpdmVuIHZhbHVlIGF0IGtleSBhbmQgcmV0dXJucyB2YWx1ZS5cblx0Ly8gQ2FsbGluZyBzZXQgd2l0aCB2YWx1ZSA9PT0gdW5kZWZpbmVkIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyByZW1vdmUuXG5cdHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmUoa2V5KVxuXHRcdH1cblx0XHR0aGlzLnN0b3JhZ2Uud3JpdGUodGhpcy5fbmFtZXNwYWNlUHJlZml4ICsga2V5LCB0aGlzLl9zZXJpYWxpemUodmFsdWUpKVxuXHRcdHJldHVybiB2YWx1ZVxuXHR9LFxuXG5cdC8vIHJlbW92ZSBkZWxldGVzIHRoZSBrZXkgYW5kIHZhbHVlIHN0b3JlZCBhdCB0aGUgZ2l2ZW4ga2V5LlxuXHRyZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuXHRcdHRoaXMuc3RvcmFnZS5yZW1vdmUodGhpcy5fbmFtZXNwYWNlUHJlZml4ICsga2V5KVxuXHR9LFxuXG5cdC8vIGVhY2ggd2lsbCBjYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBvbmNlIGZvciBlYWNoIGtleS12YWx1ZSBwYWlyXG5cdC8vIGluIHRoaXMgc3RvcmUuXG5cdGVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzXG5cdFx0dGhpcy5zdG9yYWdlLmVhY2goZnVuY3Rpb24odmFsLCBuYW1lc3BhY2VkS2V5KSB7XG5cdFx0XHRjYWxsYmFjay5jYWxsKHNlbGYsIHNlbGYuX2Rlc2VyaWFsaXplKHZhbCksIChuYW1lc3BhY2VkS2V5IHx8ICcnKS5yZXBsYWNlKHNlbGYuX25hbWVzcGFjZVJlZ2V4cCwgJycpKVxuXHRcdH0pXG5cdH0sXG5cblx0Ly8gY2xlYXJBbGwgd2lsbCByZW1vdmUgYWxsIHRoZSBzdG9yZWQga2V5LXZhbHVlIHBhaXJzIGluIHRoaXMgc3RvcmUuXG5cdGNsZWFyQWxsOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3JhZ2UuY2xlYXJBbGwoKVxuXHR9LFxuXG5cdC8vIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSB0aGF0IGNhbid0IGxpdmUgaW4gcGx1Z2luc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHQvLyBoYXNOYW1lc3BhY2UgcmV0dXJucyB0cnVlIGlmIHRoaXMgc3RvcmUgaW5zdGFuY2UgaGFzIHRoZSBnaXZlbiBuYW1lc3BhY2UuXG5cdGhhc05hbWVzcGFjZTogZnVuY3Rpb24obmFtZXNwYWNlKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9uYW1lc3BhY2VQcmVmaXggPT0gJ19fc3RvcmVqc18nK25hbWVzcGFjZSsnXycpXG5cdH0sXG5cblx0Ly8gY3JlYXRlU3RvcmUgY3JlYXRlcyBhIHN0b3JlLmpzIGluc3RhbmNlIHdpdGggdGhlIGZpcnN0XG5cdC8vIGZ1bmN0aW9uaW5nIHN0b3JhZ2UgaW4gdGhlIGxpc3Qgb2Ygc3RvcmFnZSBjYW5kaWRhdGVzLFxuXHQvLyBhbmQgYXBwbGllcyB0aGUgdGhlIGdpdmVuIG1peGlucyB0byB0aGUgaW5zdGFuY2UuXG5cdGNyZWF0ZVN0b3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gY3JlYXRlU3RvcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuXHR9LFxuXHRcblx0YWRkUGx1Z2luOiBmdW5jdGlvbihwbHVnaW4pIHtcblx0XHR0aGlzLl9hZGRQbHVnaW4ocGx1Z2luKVxuXHR9LFxuXHRcblx0bmFtZXNwYWNlOiBmdW5jdGlvbihuYW1lc3BhY2UpIHtcblx0XHRyZXR1cm4gY3JlYXRlU3RvcmUodGhpcy5zdG9yYWdlLCB0aGlzLnBsdWdpbnMsIG5hbWVzcGFjZSlcblx0fVxufVxuXG5mdW5jdGlvbiBfd2FybigpIHtcblx0dmFyIF9jb25zb2xlID0gKHR5cGVvZiBjb25zb2xlID09ICd1bmRlZmluZWQnID8gbnVsbCA6IGNvbnNvbGUpXG5cdGlmICghX2NvbnNvbGUpIHsgcmV0dXJuIH1cblx0dmFyIGZuID0gKF9jb25zb2xlLndhcm4gPyBfY29uc29sZS53YXJuIDogX2NvbnNvbGUubG9nKVxuXHRmbi5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShzdG9yYWdlcywgcGx1Z2lucywgbmFtZXNwYWNlKSB7XG5cdGlmICghbmFtZXNwYWNlKSB7XG5cdFx0bmFtZXNwYWNlID0gJydcblx0fVxuXHRpZiAoc3RvcmFnZXMgJiYgIWlzTGlzdChzdG9yYWdlcykpIHtcblx0XHRzdG9yYWdlcyA9IFtzdG9yYWdlc11cblx0fVxuXHRpZiAocGx1Z2lucyAmJiAhaXNMaXN0KHBsdWdpbnMpKSB7XG5cdFx0cGx1Z2lucyA9IFtwbHVnaW5zXVxuXHR9XG5cblx0dmFyIG5hbWVzcGFjZVByZWZpeCA9IChuYW1lc3BhY2UgPyAnX19zdG9yZWpzXycrbmFtZXNwYWNlKydfJyA6ICcnKVxuXHR2YXIgbmFtZXNwYWNlUmVnZXhwID0gKG5hbWVzcGFjZSA/IG5ldyBSZWdFeHAoJ14nK25hbWVzcGFjZVByZWZpeCkgOiBudWxsKVxuXHR2YXIgbGVnYWxOYW1lc3BhY2VzID0gL15bYS16QS1aMC05X1xcLV0qJC8gLy8gYWxwaGEtbnVtZXJpYyArIHVuZGVyc2NvcmUgYW5kIGRhc2hcblx0aWYgKCFsZWdhbE5hbWVzcGFjZXMudGVzdChuYW1lc3BhY2UpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdzdG9yZS5qcyBuYW1lc3BhY2VzIGNhbiBvbmx5IGhhdmUgYWxwaGFudW1lcmljcyArIHVuZGVyc2NvcmVzIGFuZCBkYXNoZXMnKVxuXHR9XG5cdFxuXHR2YXIgX3ByaXZhdGVTdG9yZVByb3BzID0ge1xuXHRcdF9uYW1lc3BhY2VQcmVmaXg6IG5hbWVzcGFjZVByZWZpeCxcblx0XHRfbmFtZXNwYWNlUmVnZXhwOiBuYW1lc3BhY2VSZWdleHAsXG5cblx0XHRfdGVzdFN0b3JhZ2U6IGZ1bmN0aW9uKHN0b3JhZ2UpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciB0ZXN0U3RyID0gJ19fc3RvcmVqc19fdGVzdF9fJ1xuXHRcdFx0XHRzdG9yYWdlLndyaXRlKHRlc3RTdHIsIHRlc3RTdHIpXG5cdFx0XHRcdHZhciBvayA9IChzdG9yYWdlLnJlYWQodGVzdFN0cikgPT09IHRlc3RTdHIpXG5cdFx0XHRcdHN0b3JhZ2UucmVtb3ZlKHRlc3RTdHIpXG5cdFx0XHRcdHJldHVybiBva1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfYXNzaWduUGx1Z2luRm5Qcm9wOiBmdW5jdGlvbihwbHVnaW5GblByb3AsIHByb3BOYW1lKSB7XG5cdFx0XHR2YXIgb2xkRm4gPSB0aGlzW3Byb3BOYW1lXVxuXHRcdFx0dGhpc1twcm9wTmFtZV0gPSBmdW5jdGlvbiBwbHVnaW5GbigpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDApXG5cdFx0XHRcdHZhciBzZWxmID0gdGhpc1xuXG5cdFx0XHRcdC8vIHN1cGVyX2ZuIGNhbGxzIHRoZSBvbGQgZnVuY3Rpb24gd2hpY2ggd2FzIG92ZXJ3cml0dGVuIGJ5XG5cdFx0XHRcdC8vIHRoaXMgbWl4aW4uXG5cdFx0XHRcdGZ1bmN0aW9uIHN1cGVyX2ZuKCkge1xuXHRcdFx0XHRcdGlmICghb2xkRm4pIHsgcmV0dXJuIH1cblx0XHRcdFx0XHRlYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24oYXJnLCBpKSB7XG5cdFx0XHRcdFx0XHRhcmdzW2ldID0gYXJnXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm4gb2xkRm4uYXBwbHkoc2VsZiwgYXJncylcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdpdmUgbWl4aW5nIGZ1bmN0aW9uIGFjY2VzcyB0byBzdXBlcl9mbiBieSBwcmVmaXhpbmcgYWxsIG1peGluIGZ1bmN0aW9uXG5cdFx0XHRcdC8vIGFyZ3VtZW50cyB3aXRoIHN1cGVyX2ZuLlxuXHRcdFx0XHR2YXIgbmV3Rm5BcmdzID0gW3N1cGVyX2ZuXS5jb25jYXQoYXJncylcblxuXHRcdFx0XHRyZXR1cm4gcGx1Z2luRm5Qcm9wLmFwcGx5KHNlbGYsIG5ld0ZuQXJncylcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKVxuXHRcdH0sXG5cblx0XHRfZGVzZXJpYWxpemU6IGZ1bmN0aW9uKHN0clZhbCwgZGVmYXVsdFZhbCkge1xuXHRcdFx0aWYgKCFzdHJWYWwpIHsgcmV0dXJuIGRlZmF1bHRWYWwgfVxuXHRcdFx0Ly8gSXQgaXMgcG9zc2libGUgdGhhdCBhIHJhdyBzdHJpbmcgdmFsdWUgaGFzIGJlZW4gcHJldmlvdXNseSBzdG9yZWRcblx0XHRcdC8vIGluIGEgc3RvcmFnZSB3aXRob3V0IHVzaW5nIHN0b3JlLmpzLCBtZWFuaW5nIGl0IHdpbGwgYmUgYSByYXdcblx0XHRcdC8vIHN0cmluZyB2YWx1ZSBpbnN0ZWFkIG9mIGEgSlNPTiBzZXJpYWxpemVkIHN0cmluZy4gQnkgZGVmYXVsdGluZ1xuXHRcdFx0Ly8gdG8gdGhlIHJhdyBzdHJpbmcgdmFsdWUgaW4gY2FzZSBvZiBhIEpTT04gcGFyc2UgZXJyb3IsIHdlIGFsbG93XG5cdFx0XHQvLyBmb3IgcGFzdCBzdG9yZWQgdmFsdWVzIHRvIGJlIGZvcndhcmRzLWNvbXBhdGlibGUgd2l0aCBzdG9yZS5qc1xuXHRcdFx0dmFyIHZhbCA9ICcnXG5cdFx0XHR0cnkgeyB2YWwgPSBKU09OLnBhcnNlKHN0clZhbCkgfVxuXHRcdFx0Y2F0Y2goZSkgeyB2YWwgPSBzdHJWYWwgfVxuXG5cdFx0XHRyZXR1cm4gKHZhbCAhPT0gdW5kZWZpbmVkID8gdmFsIDogZGVmYXVsdFZhbClcblx0XHR9LFxuXHRcdFxuXHRcdF9hZGRTdG9yYWdlOiBmdW5jdGlvbihzdG9yYWdlKSB7XG5cdFx0XHRpZiAodGhpcy5lbmFibGVkKSB7IHJldHVybiB9XG5cdFx0XHRpZiAodGhpcy5fdGVzdFN0b3JhZ2Uoc3RvcmFnZSkpIHtcblx0XHRcdFx0dGhpcy5zdG9yYWdlID0gc3RvcmFnZVxuXHRcdFx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9hZGRQbHVnaW46IGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzXG5cblx0XHRcdC8vIElmIHRoZSBwbHVnaW4gaXMgYW4gYXJyYXksIHRoZW4gYWRkIGFsbCBwbHVnaW5zIGluIHRoZSBhcnJheS5cblx0XHRcdC8vIFRoaXMgYWxsb3dzIGZvciBhIHBsdWdpbiB0byBkZXBlbmQgb24gb3RoZXIgcGx1Z2lucy5cblx0XHRcdGlmIChpc0xpc3QocGx1Z2luKSkge1xuXHRcdFx0XHRlYWNoKHBsdWdpbiwgZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHRcdFx0c2VsZi5fYWRkUGx1Z2luKHBsdWdpbilcblx0XHRcdFx0fSlcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2YgYWxsIHBsdWdpbnMgd2UndmUgc2VlbiBzbyBmYXIsIHNvIHRoYXQgd2Vcblx0XHRcdC8vIGRvbid0IGFkZCBhbnkgb2YgdGhlbSB0d2ljZS5cblx0XHRcdHZhciBzZWVuUGx1Z2luID0gcGx1Y2sodGhpcy5wbHVnaW5zLCBmdW5jdGlvbihzZWVuUGx1Z2luKSB7XG5cdFx0XHRcdHJldHVybiAocGx1Z2luID09PSBzZWVuUGx1Z2luKVxuXHRcdFx0fSlcblx0XHRcdGlmIChzZWVuUGx1Z2luKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0dGhpcy5wbHVnaW5zLnB1c2gocGx1Z2luKVxuXG5cdFx0XHQvLyBDaGVjayB0aGF0IHRoZSBwbHVnaW4gaXMgcHJvcGVybHkgZm9ybWVkXG5cdFx0XHRpZiAoIWlzRnVuY3Rpb24ocGx1Z2luKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BsdWdpbnMgbXVzdCBiZSBmdW5jdGlvbiB2YWx1ZXMgdGhhdCByZXR1cm4gb2JqZWN0cycpXG5cdFx0XHR9XG5cblx0XHRcdHZhciBwbHVnaW5Qcm9wZXJ0aWVzID0gcGx1Z2luLmNhbGwodGhpcylcblx0XHRcdGlmICghaXNPYmplY3QocGx1Z2luUHJvcGVydGllcykpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQbHVnaW5zIG11c3QgcmV0dXJuIGFuIG9iamVjdCBvZiBmdW5jdGlvbiBwcm9wZXJ0aWVzJylcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRoZSBwbHVnaW4gZnVuY3Rpb24gcHJvcGVydGllcyB0byB0aGlzIHN0b3JlIGluc3RhbmNlLlxuXHRcdFx0ZWFjaChwbHVnaW5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwbHVnaW5GblByb3AsIHByb3BOYW1lKSB7XG5cdFx0XHRcdGlmICghaXNGdW5jdGlvbihwbHVnaW5GblByb3ApKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCYWQgcGx1Z2luIHByb3BlcnR5OiAnK3Byb3BOYW1lKycgZnJvbSBwbHVnaW4gJytwbHVnaW4ubmFtZSsnLiBQbHVnaW5zIHNob3VsZCBvbmx5IHJldHVybiBmdW5jdGlvbnMuJylcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLl9hc3NpZ25QbHVnaW5GblByb3AocGx1Z2luRm5Qcm9wLCBwcm9wTmFtZSlcblx0XHRcdH0pXG5cdFx0fSxcblx0XHRcblx0XHQvLyBQdXQgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzIGluIHRoZSBwcml2YXRlIEFQSSwgc28gYXMgdG8gbm90IGV4cG9zZSBpdCB0byBhY2NpZGVudGlhbFxuXHRcdC8vIGRpc2NvdmVyeSB0aHJvdWdoIGluc3BlY3Rpb24gb2YgdGhlIHN0b3JlIG9iamVjdC5cblx0XHRcblx0XHQvLyBEZXByZWNhdGVkOiBhZGRTdG9yYWdlXG5cdFx0YWRkU3RvcmFnZTogZnVuY3Rpb24oc3RvcmFnZSkge1xuXHRcdFx0X3dhcm4oJ3N0b3JlLmFkZFN0b3JhZ2Uoc3RvcmFnZSkgaXMgZGVwcmVjYXRlZC4gVXNlIGNyZWF0ZVN0b3JlKFtzdG9yYWdlc10pJylcblx0XHRcdHRoaXMuX2FkZFN0b3JhZ2Uoc3RvcmFnZSlcblx0XHR9XG5cdH1cblxuXHR2YXIgc3RvcmUgPSBjcmVhdGUoX3ByaXZhdGVTdG9yZVByb3BzLCBzdG9yZUFQSSwge1xuXHRcdHBsdWdpbnM6IFtdXG5cdH0pXG5cdHN0b3JlLnJhdyA9IHt9XG5cdGVhY2goc3RvcmUsIGZ1bmN0aW9uKHByb3AsIHByb3BOYW1lKSB7XG5cdFx0aWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcblx0XHRcdHN0b3JlLnJhd1twcm9wTmFtZV0gPSBiaW5kKHN0b3JlLCBwcm9wKVx0XHRcdFxuXHRcdH1cblx0fSlcblx0ZWFjaChzdG9yYWdlcywgZnVuY3Rpb24oc3RvcmFnZSkge1xuXHRcdHN0b3JlLl9hZGRTdG9yYWdlKHN0b3JhZ2UpXG5cdH0pXG5cdGVhY2gocGx1Z2lucywgZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0c3RvcmUuX2FkZFBsdWdpbihwbHVnaW4pXG5cdH0pXG5cdHJldHVybiBzdG9yZVxufVxuIiwidmFyIGFzc2lnbiA9IG1ha2VfYXNzaWduKClcbnZhciBjcmVhdGUgPSBtYWtlX2NyZWF0ZSgpXG52YXIgdHJpbSA9IG1ha2VfdHJpbSgpXG52YXIgR2xvYmFsID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0YXNzaWduOiBhc3NpZ24sXG5cdGNyZWF0ZTogY3JlYXRlLFxuXHR0cmltOiB0cmltLFxuXHRiaW5kOiBiaW5kLFxuXHRzbGljZTogc2xpY2UsXG5cdGVhY2g6IGVhY2gsXG5cdG1hcDogbWFwLFxuXHRwbHVjazogcGx1Y2ssXG5cdGlzTGlzdDogaXNMaXN0LFxuXHRpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuXHRpc09iamVjdDogaXNPYmplY3QsXG5cdEdsb2JhbDogR2xvYmFsXG59XG5cbmZ1bmN0aW9uIG1ha2VfYXNzaWduKCkge1xuXHRpZiAoT2JqZWN0LmFzc2lnbikge1xuXHRcdHJldHVybiBPYmplY3QuYXNzaWduXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNoaW1Bc3NpZ24ob2JqLCBwcm9wczEsIHByb3BzMiwgZXRjKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRlYWNoKE9iamVjdChhcmd1bWVudHNbaV0pLCBmdW5jdGlvbih2YWwsIGtleSkge1xuXHRcdFx0XHRcdG9ialtrZXldID0gdmFsXG5cdFx0XHRcdH0pXG5cdFx0XHR9XHRcdFx0XG5cdFx0XHRyZXR1cm4gb2JqXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIG1ha2VfY3JlYXRlKCkge1xuXHRpZiAoT2JqZWN0LmNyZWF0ZSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGUob2JqLCBhc3NpZ25Qcm9wczEsIGFzc2lnblByb3BzMiwgZXRjKSB7XG5cdFx0XHR2YXIgYXNzaWduQXJnc0xpc3QgPSBzbGljZShhcmd1bWVudHMsIDEpXG5cdFx0XHRyZXR1cm4gYXNzaWduLmFwcGx5KHRoaXMsIFtPYmplY3QuY3JlYXRlKG9iaildLmNvbmNhdChhc3NpZ25BcmdzTGlzdCkpXG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZ1bmN0aW9uIEYoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWlubmVyLWRlY2xhcmF0aW9uc1xuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGUob2JqLCBhc3NpZ25Qcm9wczEsIGFzc2lnblByb3BzMiwgZXRjKSB7XG5cdFx0XHR2YXIgYXNzaWduQXJnc0xpc3QgPSBzbGljZShhcmd1bWVudHMsIDEpXG5cdFx0XHRGLnByb3RvdHlwZSA9IG9ialxuXHRcdFx0cmV0dXJuIGFzc2lnbi5hcHBseSh0aGlzLCBbbmV3IEYoKV0uY29uY2F0KGFzc2lnbkFyZ3NMaXN0KSlcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbWFrZV90cmltKCkge1xuXHRpZiAoU3RyaW5nLnByb3RvdHlwZS50cmltKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyaW0oc3RyKSB7XG5cdFx0XHRyZXR1cm4gU3RyaW5nLnByb3RvdHlwZS50cmltLmNhbGwoc3RyKVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gdHJpbShzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBiaW5kKG9iaiwgZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseShvYmosIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpXG5cdH1cbn1cblxuZnVuY3Rpb24gc2xpY2UoYXJyLCBpbmRleCkge1xuXHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyLCBpbmRleCB8fCAwKVxufVxuXG5mdW5jdGlvbiBlYWNoKG9iaiwgZm4pIHtcblx0cGx1Y2sob2JqLCBmdW5jdGlvbih2YWwsIGtleSkge1xuXHRcdGZuKHZhbCwga2V5KVxuXHRcdHJldHVybiBmYWxzZVxuXHR9KVxufVxuXG5mdW5jdGlvbiBtYXAob2JqLCBmbikge1xuXHR2YXIgcmVzID0gKGlzTGlzdChvYmopID8gW10gOiB7fSlcblx0cGx1Y2sob2JqLCBmdW5jdGlvbih2LCBrKSB7XG5cdFx0cmVzW2tdID0gZm4odiwgaylcblx0XHRyZXR1cm4gZmFsc2Vcblx0fSlcblx0cmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBwbHVjayhvYmosIGZuKSB7XG5cdGlmIChpc0xpc3Qob2JqKSkge1xuXHRcdGZvciAodmFyIGk9MDsgaTxvYmoubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChmbihvYmpbaV0sIGkpKSB7XG5cdFx0XHRcdHJldHVybiBvYmpbaV1cblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdGlmIChmbihvYmpba2V5XSwga2V5KSkge1xuXHRcdFx0XHRcdHJldHVybiBvYmpba2V5XVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGlzTGlzdCh2YWwpIHtcblx0cmV0dXJuICh2YWwgIT0gbnVsbCAmJiB0eXBlb2YgdmFsICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbC5sZW5ndGggPT0gJ251bWJlcicpXG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG5cdHJldHVybiB2YWwgJiYge30udG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nXG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuXHRyZXR1cm4gdmFsICYmIHt9LnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuXHQvLyBMaXN0ZWQgaW4gb3JkZXIgb2YgdXNhZ2UgcHJlZmVyZW5jZVxuXHRyZXF1aXJlKCcuL2xvY2FsU3RvcmFnZScpLFxuXHRyZXF1aXJlKCcuL29sZEZGLWdsb2JhbFN0b3JhZ2UnKSxcblx0cmVxdWlyZSgnLi9vbGRJRS11c2VyRGF0YVN0b3JhZ2UnKSxcblx0cmVxdWlyZSgnLi9jb29raWVTdG9yYWdlJyksXG5cdHJlcXVpcmUoJy4vc2Vzc2lvblN0b3JhZ2UnKSxcblx0cmVxdWlyZSgnLi9tZW1vcnlTdG9yYWdlJylcbl1cbiIsIi8vIGNvb2tpZVN0b3JhZ2UgaXMgdXNlZnVsIFNhZmFyaSBwcml2YXRlIGJyb3dzZXIgbW9kZSwgd2hlcmUgbG9jYWxTdG9yYWdlXG4vLyBkb2Vzbid0IHdvcmsgYnV0IGNvb2tpZXMgZG8uIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYWRvcHRlZCBmcm9tXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3RvcmFnZS9Mb2NhbFN0b3JhZ2VcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi9zcmMvdXRpbCcpXG52YXIgR2xvYmFsID0gdXRpbC5HbG9iYWxcbnZhciB0cmltID0gdXRpbC50cmltXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnY29va2llU3RvcmFnZScsXG5cdHJlYWQ6IHJlYWQsXG5cdHdyaXRlOiB3cml0ZSxcblx0ZWFjaDogZWFjaCxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGNsZWFyQWxsOiBjbGVhckFsbCxcbn1cblxudmFyIGRvYyA9IEdsb2JhbC5kb2N1bWVudFxuXG5mdW5jdGlvbiByZWFkKGtleSkge1xuXHRpZiAoIWtleSB8fCAhX2hhcyhrZXkpKSB7IHJldHVybiBudWxsIH1cblx0dmFyIHJlZ2V4cFN0ciA9IFwiKD86XnwuKjtcXFxccyopXCIgK1xuXHRcdGVzY2FwZShrZXkpLnJlcGxhY2UoL1tcXC1cXC5cXCtcXCpdL2csIFwiXFxcXCQmXCIpICtcblx0XHRcIlxcXFxzKlxcXFw9XFxcXHMqKCg/OlteO10oPyE7KSkqW147XT8pLipcIlxuXHRyZXR1cm4gdW5lc2NhcGUoZG9jLmNvb2tpZS5yZXBsYWNlKG5ldyBSZWdFeHAocmVnZXhwU3RyKSwgXCIkMVwiKSlcbn1cblxuZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuXHR2YXIgY29va2llcyA9IGRvYy5jb29raWUuc3BsaXQoLzsgPy9nKVxuXHRmb3IgKHZhciBpID0gY29va2llcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdGlmICghdHJpbShjb29raWVzW2ldKSkge1xuXHRcdFx0Y29udGludWVcblx0XHR9XG5cdFx0dmFyIGt2cCA9IGNvb2tpZXNbaV0uc3BsaXQoJz0nKVxuXHRcdHZhciBrZXkgPSB1bmVzY2FwZShrdnBbMF0pXG5cdFx0dmFyIHZhbCA9IHVuZXNjYXBlKGt2cFsxXSlcblx0XHRjYWxsYmFjayh2YWwsIGtleSlcblx0fVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIGRhdGEpIHtcblx0aWYoIWtleSkgeyByZXR1cm4gfVxuXHRkb2MuY29va2llID0gZXNjYXBlKGtleSkgKyBcIj1cIiArIGVzY2FwZShkYXRhKSArIFwiOyBleHBpcmVzPVR1ZSwgMTkgSmFuIDIwMzggMDM6MTQ6MDcgR01UOyBwYXRoPS9cIlxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdGlmICgha2V5IHx8ICFfaGFzKGtleSkpIHtcblx0XHRyZXR1cm5cblx0fVxuXHRkb2MuY29va2llID0gZXNjYXBlKGtleSkgKyBcIj07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBHTVQ7IHBhdGg9L1wiXG59XG5cbmZ1bmN0aW9uIGNsZWFyQWxsKCkge1xuXHRlYWNoKGZ1bmN0aW9uKF8sIGtleSkge1xuXHRcdHJlbW92ZShrZXkpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIF9oYXMoa2V5KSB7XG5cdHJldHVybiAobmV3IFJlZ0V4cChcIig/Ol58O1xcXFxzKilcIiArIGVzY2FwZShrZXkpLnJlcGxhY2UoL1tcXC1cXC5cXCtcXCpdL2csIFwiXFxcXCQmXCIpICsgXCJcXFxccypcXFxcPVwiKSkudGVzdChkb2MuY29va2llKVxufVxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi9zcmMvdXRpbCcpXG52YXIgR2xvYmFsID0gdXRpbC5HbG9iYWxcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6ICdsb2NhbFN0b3JhZ2UnLFxuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGUsXG5cdGVhY2g6IGVhY2gsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRjbGVhckFsbDogY2xlYXJBbGwsXG59XG5cbmZ1bmN0aW9uIGxvY2FsU3RvcmFnZSgpIHtcblx0cmV0dXJuIEdsb2JhbC5sb2NhbFN0b3JhZ2Vcbn1cblxuZnVuY3Rpb24gcmVhZChrZXkpIHtcblx0cmV0dXJuIGxvY2FsU3RvcmFnZSgpLmdldEl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIGRhdGEpIHtcblx0cmV0dXJuIGxvY2FsU3RvcmFnZSgpLnNldEl0ZW0oa2V5LCBkYXRhKVxufVxuXG5mdW5jdGlvbiBlYWNoKGZuKSB7XG5cdGZvciAodmFyIGkgPSBsb2NhbFN0b3JhZ2UoKS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdHZhciBrZXkgPSBsb2NhbFN0b3JhZ2UoKS5rZXkoaSlcblx0XHRmbihyZWFkKGtleSksIGtleSlcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdHJldHVybiBsb2NhbFN0b3JhZ2UoKS5yZW1vdmVJdGVtKGtleSlcbn1cblxuZnVuY3Rpb24gY2xlYXJBbGwoKSB7XG5cdHJldHVybiBsb2NhbFN0b3JhZ2UoKS5jbGVhcigpXG59XG4iLCIvLyBtZW1vcnlTdG9yYWdlIGlzIGEgdXNlZnVsIGxhc3QgZmFsbGJhY2sgdG8gZW5zdXJlIHRoYXQgdGhlIHN0b3JlXG4vLyBpcyBmdW5jdGlvbnMgKG1lYW5pbmcgc3RvcmUuZ2V0KCksIHN0b3JlLnNldCgpLCBldGMgd2lsbCBhbGwgZnVuY3Rpb24pLlxuLy8gSG93ZXZlciwgc3RvcmVkIHZhbHVlcyB3aWxsIG5vdCBwZXJzaXN0IHdoZW4gdGhlIGJyb3dzZXIgbmF2aWdhdGVzIHRvXG4vLyBhIG5ldyBwYWdlIG9yIHJlbG9hZHMgdGhlIGN1cnJlbnQgcGFnZS5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6ICdtZW1vcnlTdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG52YXIgbWVtb3J5U3RvcmFnZSA9IHt9XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdHJldHVybiBtZW1vcnlTdG9yYWdlW2tleV1cbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBkYXRhKSB7XG5cdG1lbW9yeVN0b3JhZ2Vba2V5XSA9IGRhdGFcbn1cblxuZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuXHRmb3IgKHZhciBrZXkgaW4gbWVtb3J5U3RvcmFnZSkge1xuXHRcdGlmIChtZW1vcnlTdG9yYWdlLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdGNhbGxiYWNrKG1lbW9yeVN0b3JhZ2Vba2V5XSwga2V5KVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdGRlbGV0ZSBtZW1vcnlTdG9yYWdlW2tleV1cbn1cblxuZnVuY3Rpb24gY2xlYXJBbGwoa2V5KSB7XG5cdG1lbW9yeVN0b3JhZ2UgPSB7fVxufVxuIiwiLy8gb2xkRkYtZ2xvYmFsU3RvcmFnZSBwcm92aWRlcyBzdG9yYWdlIGZvciBGaXJlZm94XG4vLyB2ZXJzaW9ucyA2IGFuZCA3LCB3aGVyZSBubyBsb2NhbFN0b3JhZ2UsIGV0Y1xuLy8gaXMgYXZhaWxhYmxlLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ29sZEZGLWdsb2JhbFN0b3JhZ2UnLFxuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGUsXG5cdGVhY2g6IGVhY2gsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRjbGVhckFsbDogY2xlYXJBbGwsXG59XG5cbnZhciBnbG9iYWxTdG9yYWdlID0gR2xvYmFsLmdsb2JhbFN0b3JhZ2VcblxuZnVuY3Rpb24gcmVhZChrZXkpIHtcblx0cmV0dXJuIGdsb2JhbFN0b3JhZ2Vba2V5XVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIGRhdGEpIHtcblx0Z2xvYmFsU3RvcmFnZVtrZXldID0gZGF0YVxufVxuXG5mdW5jdGlvbiBlYWNoKGZuKSB7XG5cdGZvciAodmFyIGkgPSBnbG9iYWxTdG9yYWdlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0dmFyIGtleSA9IGdsb2JhbFN0b3JhZ2Uua2V5KGkpXG5cdFx0Zm4oZ2xvYmFsU3RvcmFnZVtrZXldLCBrZXkpXG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuXHRyZXR1cm4gZ2xvYmFsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbn1cblxuZnVuY3Rpb24gY2xlYXJBbGwoKSB7XG5cdGVhY2goZnVuY3Rpb24oa2V5LCBfKSB7XG5cdFx0ZGVsZXRlIGdsb2JhbFN0b3JhZ2Vba2V5XVxuXHR9KVxufVxuIiwiLy8gb2xkSUUtdXNlckRhdGFTdG9yYWdlIHByb3ZpZGVzIHN0b3JhZ2UgZm9yIEludGVybmV0IEV4cGxvcmVyXG4vLyB2ZXJzaW9ucyA2IGFuZCA3LCB3aGVyZSBubyBsb2NhbFN0b3JhZ2UsIHNlc3Npb25TdG9yYWdlLCBldGNcbi8vIGlzIGF2YWlsYWJsZS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi9zcmMvdXRpbCcpXG52YXIgR2xvYmFsID0gdXRpbC5HbG9iYWxcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6ICdvbGRJRS11c2VyRGF0YVN0b3JhZ2UnLFxuXHR3cml0ZTogd3JpdGUsXG5cdHJlYWQ6IHJlYWQsXG5cdGVhY2g6IGVhY2gsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRjbGVhckFsbDogY2xlYXJBbGwsXG59XG5cbnZhciBzdG9yYWdlTmFtZSA9ICdzdG9yZWpzJ1xudmFyIGRvYyA9IEdsb2JhbC5kb2N1bWVudFxudmFyIF93aXRoU3RvcmFnZUVsID0gX21ha2VJRVN0b3JhZ2VFbEZ1bmN0aW9uKClcbnZhciBkaXNhYmxlID0gKEdsb2JhbC5uYXZpZ2F0b3IgPyBHbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCA6ICcnKS5tYXRjaCgvIChNU0lFIDh8TVNJRSA5fE1TSUUgMTApXFwuLykgLy8gTVNJRSA5LngsIE1TSUUgMTAueFxuXG5mdW5jdGlvbiB3cml0ZSh1bmZpeGVkS2V5LCBkYXRhKSB7XG5cdGlmIChkaXNhYmxlKSB7IHJldHVybiB9XG5cdHZhciBmaXhlZEtleSA9IGZpeEtleSh1bmZpeGVkS2V5KVxuXHRfd2l0aFN0b3JhZ2VFbChmdW5jdGlvbihzdG9yYWdlRWwpIHtcblx0XHRzdG9yYWdlRWwuc2V0QXR0cmlidXRlKGZpeGVkS2V5LCBkYXRhKVxuXHRcdHN0b3JhZ2VFbC5zYXZlKHN0b3JhZ2VOYW1lKVxuXHR9KVxufVxuXG5mdW5jdGlvbiByZWFkKHVuZml4ZWRLZXkpIHtcblx0aWYgKGRpc2FibGUpIHsgcmV0dXJuIH1cblx0dmFyIGZpeGVkS2V5ID0gZml4S2V5KHVuZml4ZWRLZXkpXG5cdHZhciByZXMgPSBudWxsXG5cdF93aXRoU3RvcmFnZUVsKGZ1bmN0aW9uKHN0b3JhZ2VFbCkge1xuXHRcdHJlcyA9IHN0b3JhZ2VFbC5nZXRBdHRyaWJ1dGUoZml4ZWRLZXkpXG5cdH0pXG5cdHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuXHRfd2l0aFN0b3JhZ2VFbChmdW5jdGlvbihzdG9yYWdlRWwpIHtcblx0XHR2YXIgYXR0cmlidXRlcyA9IHN0b3JhZ2VFbC5YTUxEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0cmlidXRlc1xuXHRcdGZvciAodmFyIGk9YXR0cmlidXRlcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHR2YXIgYXR0ciA9IGF0dHJpYnV0ZXNbaV1cblx0XHRcdGNhbGxiYWNrKHN0b3JhZ2VFbC5nZXRBdHRyaWJ1dGUoYXR0ci5uYW1lKSwgYXR0ci5uYW1lKVxuXHRcdH1cblx0fSlcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKHVuZml4ZWRLZXkpIHtcblx0dmFyIGZpeGVkS2V5ID0gZml4S2V5KHVuZml4ZWRLZXkpXG5cdF93aXRoU3RvcmFnZUVsKGZ1bmN0aW9uKHN0b3JhZ2VFbCkge1xuXHRcdHN0b3JhZ2VFbC5yZW1vdmVBdHRyaWJ1dGUoZml4ZWRLZXkpXG5cdFx0c3RvcmFnZUVsLnNhdmUoc3RvcmFnZU5hbWUpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGNsZWFyQWxsKCkge1xuXHRfd2l0aFN0b3JhZ2VFbChmdW5jdGlvbihzdG9yYWdlRWwpIHtcblx0XHR2YXIgYXR0cmlidXRlcyA9IHN0b3JhZ2VFbC5YTUxEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0cmlidXRlc1xuXHRcdHN0b3JhZ2VFbC5sb2FkKHN0b3JhZ2VOYW1lKVxuXHRcdGZvciAodmFyIGk9YXR0cmlidXRlcy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG5cdFx0XHRzdG9yYWdlRWwucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZXNbaV0ubmFtZSlcblx0XHR9XG5cdFx0c3RvcmFnZUVsLnNhdmUoc3RvcmFnZU5hbWUpXG5cdH0pXG59XG5cbi8vIEhlbHBlcnNcbi8vLy8vLy8vLy9cblxuLy8gSW4gSUU3LCBrZXlzIGNhbm5vdCBzdGFydCB3aXRoIGEgZGlnaXQgb3IgY29udGFpbiBjZXJ0YWluIGNoYXJzLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjdXN3ZXN0aW4vc3RvcmUuanMvaXNzdWVzLzQwXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcmN1c3dlc3Rpbi9zdG9yZS5qcy9pc3N1ZXMvODNcbnZhciBmb3JiaWRkZW5DaGFyc1JlZ2V4ID0gbmV3IFJlZ0V4cChcIlshXFxcIiMkJSYnKCkqKywvXFxcXFxcXFw6Ozw9Pj9AW1xcXFxdXmB7fH1+XVwiLCBcImdcIilcbmZ1bmN0aW9uIGZpeEtleShrZXkpIHtcblx0cmV0dXJuIGtleS5yZXBsYWNlKC9eXFxkLywgJ19fXyQmJykucmVwbGFjZShmb3JiaWRkZW5DaGFyc1JlZ2V4LCAnX19fJylcbn1cblxuZnVuY3Rpb24gX21ha2VJRVN0b3JhZ2VFbEZ1bmN0aW9uKCkge1xuXHRpZiAoIWRvYyB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCB8fCAhZG9jLmRvY3VtZW50RWxlbWVudC5hZGRCZWhhdmlvcikge1xuXHRcdHJldHVybiBudWxsXG5cdH1cblx0dmFyIHNjcmlwdFRhZyA9ICdzY3JpcHQnLFxuXHRcdHN0b3JhZ2VPd25lcixcblx0XHRzdG9yYWdlQ29udGFpbmVyLFxuXHRcdHN0b3JhZ2VFbFxuXG5cdC8vIFNpbmNlICN1c2VyRGF0YSBzdG9yYWdlIGFwcGxpZXMgb25seSB0byBzcGVjaWZpYyBwYXRocywgd2UgbmVlZCB0b1xuXHQvLyBzb21laG93IGxpbmsgb3VyIGRhdGEgdG8gYSBzcGVjaWZpYyBwYXRoLiAgV2UgY2hvb3NlIC9mYXZpY29uLmljb1xuXHQvLyBhcyBhIHByZXR0eSBzYWZlIG9wdGlvbiwgc2luY2UgYWxsIGJyb3dzZXJzIGFscmVhZHkgbWFrZSBhIHJlcXVlc3QgdG9cblx0Ly8gdGhpcyBVUkwgYW55d2F5IGFuZCBiZWluZyBhIDQwNCB3aWxsIG5vdCBodXJ0IHVzIGhlcmUuICBXZSB3cmFwIGFuXG5cdC8vIGlmcmFtZSBwb2ludGluZyB0byB0aGUgZmF2aWNvbiBpbiBhbiBBY3RpdmVYT2JqZWN0KGh0bWxmaWxlKSBvYmplY3Rcblx0Ly8gKHNlZTogaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2FhNzUyNTc0KHY9VlMuODUpLmFzcHgpXG5cdC8vIHNpbmNlIHRoZSBpZnJhbWUgYWNjZXNzIHJ1bGVzIGFwcGVhciB0byBhbGxvdyBkaXJlY3QgYWNjZXNzIGFuZFxuXHQvLyBtYW5pcHVsYXRpb24gb2YgdGhlIGRvY3VtZW50IGVsZW1lbnQsIGV2ZW4gZm9yIGEgNDA0IHBhZ2UuICBUaGlzXG5cdC8vIGRvY3VtZW50IGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgZG9jdW1lbnQgKHdoaWNoIHdvdWxkXG5cdC8vIGhhdmUgYmVlbiBsaW1pdGVkIHRvIHRoZSBjdXJyZW50IHBhdGgpIHRvIHBlcmZvcm0gI3VzZXJEYXRhIHN0b3JhZ2UuXG5cdHRyeSB7XG5cdFx0LyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgKi9cblx0XHRzdG9yYWdlQ29udGFpbmVyID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJylcblx0XHRzdG9yYWdlQ29udGFpbmVyLm9wZW4oKVxuXHRcdHN0b3JhZ2VDb250YWluZXIud3JpdGUoJzwnK3NjcmlwdFRhZysnPmRvY3VtZW50Lnc9d2luZG93PC8nK3NjcmlwdFRhZysnPjxpZnJhbWUgc3JjPVwiL2Zhdmljb24uaWNvXCI+PC9pZnJhbWU+Jylcblx0XHRzdG9yYWdlQ29udGFpbmVyLmNsb3NlKClcblx0XHRzdG9yYWdlT3duZXIgPSBzdG9yYWdlQ29udGFpbmVyLncuZnJhbWVzWzBdLmRvY3VtZW50XG5cdFx0c3RvcmFnZUVsID0gc3RvcmFnZU93bmVyLmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cdH0gY2F0Y2goZSkge1xuXHRcdC8vIHNvbWVob3cgQWN0aXZlWE9iamVjdCBpbnN0YW50aWF0aW9uIGZhaWxlZCAocGVyaGFwcyBzb21lIHNwZWNpYWxcblx0XHQvLyBzZWN1cml0eSBzZXR0aW5ncyBvciBvdGhlcndzZSksIGZhbGwgYmFjayB0byBwZXItcGF0aCBzdG9yYWdlXG5cdFx0c3RvcmFnZUVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cdFx0c3RvcmFnZU93bmVyID0gZG9jLmJvZHlcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbihzdG9yZUZ1bmN0aW9uKSB7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMClcblx0XHRhcmdzLnVuc2hpZnQoc3RvcmFnZUVsKVxuXHRcdC8vIFNlZSBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzEwODEodj1WUy44NSkuYXNweFxuXHRcdC8vIGFuZCBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzE0MjQodj1WUy44NSkuYXNweFxuXHRcdHN0b3JhZ2VPd25lci5hcHBlbmRDaGlsZChzdG9yYWdlRWwpXG5cdFx0c3RvcmFnZUVsLmFkZEJlaGF2aW9yKCcjZGVmYXVsdCN1c2VyRGF0YScpXG5cdFx0c3RvcmFnZUVsLmxvYWQoc3RvcmFnZU5hbWUpXG5cdFx0c3RvcmVGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmdzKVxuXHRcdHN0b3JhZ2VPd25lci5yZW1vdmVDaGlsZChzdG9yYWdlRWwpXG5cdFx0cmV0dXJuXG5cdH1cbn1cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKVxudmFyIEdsb2JhbCA9IHV0aWwuR2xvYmFsXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnc2Vzc2lvblN0b3JhZ2UnLFxuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGUsXG5cdGVhY2g6IGVhY2gsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRjbGVhckFsbDogY2xlYXJBbGxcbn1cblxuZnVuY3Rpb24gc2Vzc2lvblN0b3JhZ2UoKSB7XG5cdHJldHVybiBHbG9iYWwuc2Vzc2lvblN0b3JhZ2Vcbn1cblxuZnVuY3Rpb24gcmVhZChrZXkpIHtcblx0cmV0dXJuIHNlc3Npb25TdG9yYWdlKCkuZ2V0SXRlbShrZXkpXG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgZGF0YSkge1xuXHRyZXR1cm4gc2Vzc2lvblN0b3JhZ2UoKS5zZXRJdGVtKGtleSwgZGF0YSlcbn1cblxuZnVuY3Rpb24gZWFjaChmbikge1xuXHRmb3IgKHZhciBpID0gc2Vzc2lvblN0b3JhZ2UoKS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdHZhciBrZXkgPSBzZXNzaW9uU3RvcmFnZSgpLmtleShpKVxuXHRcdGZuKHJlYWQoa2V5KSwga2V5KVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcblx0cmV0dXJuIHNlc3Npb25TdG9yYWdlKCkucmVtb3ZlSXRlbShrZXkpXG59XG5cbmZ1bmN0aW9uIGNsZWFyQWxsKCkge1xuXHRyZXR1cm4gc2Vzc2lvblN0b3JhZ2UoKS5jbGVhcigpXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG5mb3JFYWNoKG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKVxuICAgIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufSk7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW5kLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbmlmICghRUUubGlzdGVuZXJDb3VudCkgRUUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IDE2ICogMTAyNDtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IGZhbHNlO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBJbiBzdHJlYW1zIHRoYXQgbmV2ZXIgaGF2ZSBhbnkgZGF0YSwgYW5kIGRvIHB1c2gobnVsbCkgcmlnaHQgYXdheSxcbiAgLy8gdGhlIGNvbnN1bWVyIGNhbiBtaXNzIHRoZSAnZW5kJyBldmVudCBpZiB0aGV5IGRvIHNvbWUgSS9PIGJlZm9yZVxuICAvLyBjb25zdW1pbmcgdGhlIHN0cmVhbS4gIFNvLCB3ZSBkb24ndCBlbWl0KCdlbmQnKSB1bnRpbCBzb21lIHJlYWRpbmdcbiAgLy8gaGFwcGVucy5cbiAgdGhpcy5jYWxsZWRSZWFkID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY3Vhc2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMTI4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiByb3VuZFVwVG9OZXh0UG93ZXJPZjIobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxuICAgIG4tLTtcbiAgICBmb3IgKHZhciBwID0gMTsgcCA8IDMyOyBwIDw8PSAxKSBuIHw9IG4gPj4gcDtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSlcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChuID09PSBudWxsIHx8IGlzTmFOKG4pKSB7XG4gICAgLy8gb25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICBpZiAobiA8PSAwKVxuICAgIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUuY2FsbGVkUmVhZCA9IHRydWU7XG4gIHZhciBuT3JpZyA9IG47XG4gIHZhciByZXQ7XG5cbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuID4gMClcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcbiAgICAgIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIHJldCA9IG51bGw7XG5cbiAgICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgZGVjb2RlciBkaWQgbm90IHJlY2VpdmUgZW5vdWdoIGRhdGFcbiAgICAvLyB0byBwcm9kdWNlIGEgZnVsbCBjaHVuaywgdGhlbiBpbW1lZGlhdGVseSByZWNlaXZlZCBhblxuICAgIC8vIEVPRiwgc3RhdGUuYnVmZmVyIHdpbGwgY29udGFpbiBbPEJ1ZmZlciA+LCA8QnVmZmVyIDAwIC4uLj5dLlxuICAgIC8vIGhvd011Y2hUb1JlYWQgd2lsbCBzZWUgdGhpcyBhbmQgY29lcmNlIHRoZSBhbW91bnQgdG9cbiAgICAvLyByZWFkIHRvIHplcm8gKGJlY2F1c2UgaXQncyBsb29raW5nIGF0IHRoZSBsZW5ndGggb2YgdGhlXG4gICAgLy8gZmlyc3QgPEJ1ZmZlciA+IGluIHN0YXRlLmJ1ZmZlciksIGFuZCB3ZSdsbCBlbmQgdXAgaGVyZS5cbiAgICAvL1xuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIHZpYSBzdGF0ZS5kZWNvZGVyIC0tIG5vIG90aGVyIHZlbnVlXG4gICAgLy8gZXhpc3RzIGZvciBwdXNoaW5nIGEgemVyby1sZW5ndGggY2h1bmsgaW50byBzdGF0ZS5idWZmZXJcbiAgICAvLyBhbmQgdHJpZ2dlcmluZyB0aGlzIGJlaGF2aW9yLiBJbiB0aGlzIGNhc2UsIHdlIHJldHVybiBvdXJcbiAgICAvLyByZW1haW5pbmcgZGF0YSBhbmQgZW5kIHRoZSBzdHJlYW0sIGlmIGFwcHJvcHJpYXRlLlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPiAwICYmIHN0YXRlLmRlY29kZXIpIHtcbiAgICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmxlbmd0aCAtPSByZXQubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCAtIG4gPD0gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBkb1JlYWQgPSB0cnVlO1xuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpXG4gICAgZG9SZWFkID0gZmFsc2U7XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgY2FsbGVkIGl0cyBjYWxsYmFjayBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYFxuICAvLyB3aWxsIGJlIGZhbHNlLCBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlXG4gIC8vIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICBpZiAobiA+IDApXG4gICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICBlbHNlXG4gICAgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgaGFwcGVuZWQgdG8gcmVhZCgpIGV4YWN0bHkgdGhlIHJlbWFpbmluZyBhbW91bnQgaW4gdGhlXG4gIC8vIGJ1ZmZlciwgYW5kIHRoZSBFT0YgaGFzIGJlZW4gc2VlbiBhdCB0aGlzIHBvaW50LCB0aGVuIG1ha2Ugc3VyZVxuICAvLyB0aGF0IHdlIGVtaXQgJ2VuZCcgb24gdGhlIHZlcnkgbmV4dCB0aWNrLlxuICBpZiAoc3RhdGUuZW5kZWQgJiYgIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBjaHVuayAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkIGFuZCB3ZSBoYXZlIHNvbWUgZGF0YSBsZWZ0LCB0aGVuIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgZWxzZVxuICAgIGVuZFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5lbWl0dGVkUmVhZGFibGUpXG4gICAgcmV0dXJuO1xuXG4gIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gIGlmIChzdGF0ZS5zeW5jKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfSk7XG4gIGVsc2VcbiAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xufVxuXG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBpZiAocmVhZGFibGUgIT09IHNyYykgcmV0dXJuO1xuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy5cbiAgaWYgKCFkZXN0Ll9ldmVudHMgfHwgIWRlc3QuX2V2ZW50cy5lcnJvcilcbiAgICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBlbHNlIGlmIChpc0FycmF5KGRlc3QuX2V2ZW50cy5lcnJvcikpXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yLnVuc2hpZnQob25lcnJvcik7XG4gIGVsc2VcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcblxuXG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIC8vIHRoZSBoYW5kbGVyIHRoYXQgd2FpdHMgZm9yIHJlYWRhYmxlIGV2ZW50cyBhZnRlciBhbGxcbiAgICAvLyB0aGUgZGF0YSBnZXRzIHN1Y2tlZCBvdXQgaW4gZmxvdy5cbiAgICAvLyBUaGlzIHdvdWxkIGJlIGVhc2llciB0byBmb2xsb3cgd2l0aCBhIC5vbmNlKCkgaGFuZGxlclxuICAgIC8vIGluIGZsb3coKSwgYnV0IHRoYXQgaXMgdG9vIHNsb3cuXG4gICAgdGhpcy5vbigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZXN0ID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwKVxuICAgICAgZmxvdyhzcmMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG93KHNyYykge1xuICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBjaHVuaztcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG5cbiAgZnVuY3Rpb24gd3JpdGUoZGVzdCwgaSwgbGlzdCkge1xuICAgIHZhciB3cml0dGVuID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSB3cml0dGVuKSB7XG4gICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBpcGVzQ291bnQgJiYgbnVsbCAhPT0gKGNodW5rID0gc3JjLnJlYWQoKSkpIHtcblxuICAgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgICAgd3JpdGUoc3RhdGUucGlwZXMsIDAsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIGZvckVhY2goc3RhdGUucGlwZXMsIHdyaXRlKTtcblxuICAgIHNyYy5lbWl0KCdkYXRhJywgY2h1bmspO1xuXG4gICAgLy8gaWYgYW55b25lIG5lZWRzIGEgZHJhaW4sIHRoZW4gd2UgaGF2ZSB0byB3YWl0IGZvciB0aGF0LlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID4gMClcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGlmIGV2ZXJ5IGRlc3RpbmF0aW9uIHdhcyB1bnBpcGVkLCBlaXRoZXIgYmVmb3JlIGVudGVyaW5nIHRoaXNcbiAgLy8gZnVuY3Rpb24sIG9yIGluIHRoZSB3aGlsZSBsb29wLCB0aGVuIHN0b3AgZmxvd2luZy5cbiAgLy9cbiAgLy8gTkI6IFRoaXMgaXMgYSBwcmV0dHkgcmFyZSBlZGdlIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSB7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgdGhlcmUgd2VyZSBkYXRhIGV2ZW50IGxpc3RlbmVycyBhZGRlZCwgdGhlbiBzd2l0Y2ggdG8gb2xkIG1vZGUuXG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpID4gMClcbiAgICAgIGVtaXREYXRhRXZlbnRzKHNyYyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgbm8gb25lIG5lZWRlZCBhIGRyYWluLCBzbyB3ZSBqdXN0IHJhbiBvdXQgb2YgZGF0YVxuICAvLyBvbiB0aGUgbmV4dCByZWFkYWJsZSBldmVudCwgc3RhcnQgaXQgb3ZlciBhZ2Fpbi5cbiAgc3RhdGUucmFuT3V0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGlwZU9uUmVhZGFibGUoKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmFuT3V0ID0gZmFsc2U7XG4gICAgZmxvdyh0aGlzKTtcbiAgfVxufVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdClcbiAgICAgIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpXG4gICAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpXG4gICAgZW1pdERhdGFFdmVudHModGhpcyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICB0aGlzLnJlYWQoMCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuICB0aGlzLnJlYWQoMCk7XG4gIHRoaXMuZW1pdCgncmVzdW1lJyk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZW1pdERhdGFFdmVudHModGhpcywgdHJ1ZSk7XG4gIHRoaXMuZW1pdCgncGF1c2UnKTtcbn07XG5cbmZ1bmN0aW9uIGVtaXREYXRhRXZlbnRzKHN0cmVhbSwgc3RhcnRQYXVzZWQpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9yZWFkYWJsZS1zdHJlYW0vaXNzdWVzLzE2XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dpdGNoIHRvIG9sZCBtb2RlIG5vdy4nKTtcbiAgfVxuXG4gIHZhciBwYXVzZWQgPSBzdGFydFBhdXNlZCB8fCBmYWxzZTtcbiAgdmFyIHJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gY29udmVydCB0byBhbiBvbGQtc3R5bGUgc3RyZWFtLlxuICBzdHJlYW0ucmVhZGFibGUgPSB0cnVlO1xuICBzdHJlYW0ucGlwZSA9IFN0cmVhbS5wcm90b3R5cGUucGlwZTtcbiAgc3RyZWFtLm9uID0gc3RyZWFtLmFkZExpc3RlbmVyID0gU3RyZWFtLnByb3RvdHlwZS5vbjtcblxuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24oKSB7XG4gICAgcmVhZGFibGUgPSB0cnVlO1xuXG4gICAgdmFyIGM7XG4gICAgd2hpbGUgKCFwYXVzZWQgJiYgKG51bGwgIT09IChjID0gc3RyZWFtLnJlYWQoKSkpKVxuICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjKTtcblxuICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBwYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfTtcblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgaWYgKHJlYWRhYmxlKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgfTtcblxuICAvLyBub3cgbWFrZSBpdCBzdGFydCwganVzdCBpbiBjYXNlIGl0IGhhZG4ndCBhbHJlYWR5LlxuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICAvL2lmIChzdGF0ZS5vYmplY3RNb2RlICYmIHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSlcbiAgICAgIHJldHVybjtcbiAgICBlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHRoaXNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24obikge1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cblxuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChsZW5ndGggPT09IDApXG4gICAgcmV0ID0gbnVsbDtcbiAgZWxzZSBpZiAob2JqZWN0TW9kZSlcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIGVsc2UgaWYgKCFuIHx8IG4gPj0gbGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBhcnJheS5cbiAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgIHJldCA9IGxpc3Quam9pbignJyk7XG4gICAgZWxzZVxuICAgICAgcmV0ID0gQnVmZmVyLmNvbmNhdChsaXN0LCBsZW5ndGgpO1xuICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGp1c3Qgc29tZSBvZiBpdC5cbiAgICBpZiAobiA8IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBqdXN0IHRha2UgYSBwYXJ0IG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0uXG4gICAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgcmV0ID0gYnVmLnNsaWNlKDAsIG4pO1xuICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShuKTtcbiAgICB9IGVsc2UgaWYgKG4gPT09IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBmaXJzdCBsaXN0IGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wbGV4IGNhc2UuXG4gICAgICAvLyB3ZSBoYXZlIGVub3VnaCB0byBjb3ZlciBpdCwgYnV0IGl0IHNwYW5zIHBhc3QgdGhlIGZpcnN0IGJ1ZmZlci5cbiAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICByZXQgPSAnJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gbmV3IEJ1ZmZlcihuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBidWYubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgICByZXQgKz0gYnVmLnNsaWNlKDAsIGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBidWYuY29weShyZXQsIGMsIDAsIGNweSk7XG5cbiAgICAgICAgaWYgKGNweSA8IGJ1Zi5sZW5ndGgpXG4gICAgICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuXG4gICAgICAgIGMgKz0gY3B5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcignZW5kUmVhZGFibGUgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUuY2FsbGVkUmVhZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbihlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZClcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBpZiAoY2IpXG4gICAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSlcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5fZmx1c2gpXG4gICAgICB0aGlzLl9mbHVzaChmdW5jdGlvbihlcikge1xuICAgICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHxcbiAgICAgICAgcnMubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgIHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspXG4gICAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY3Vhc2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZS4gTm90IHJlYWRhYmxlLicpKTtcbn07XG5cblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIHN0YXRlLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgY2IoZXIpO1xuICB9KTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgZWxzZSBpZiAoIWVuY29kaW5nKVxuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGlmIChzdGF0ZS5lbmRlZClcbiAgICB3cml0ZUFmdGVyRW5kKHRoaXMsIHN0YXRlLCBjYik7XG4gIGVsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpXG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KVxuICAgIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcpXG4gICAgc3RhdGUuYnVmZmVyLnB1c2gobmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpKTtcbiAgZWxzZVxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIGlmIChzeW5jKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2VcbiAgICBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpXG4gICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7XG4gIGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBjYigpO1xuICBpZiAoZmluaXNoZWQpXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuXG4gIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKSB7XG4gICAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyW2NdO1xuICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgIGMrKztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgaWYgKGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgIHN0YXRlLmJ1ZmZlciA9IHN0YXRlLmJ1ZmZlci5zbGljZShjKTtcbiAgZWxzZVxuICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGggPSAwO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2h1bmsgIT09ICd1bmRlZmluZWQnICYmIGNodW5rICE9PSBudWxsKVxuICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZClcbiAgICBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5lbmRpbmcgJiZcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgICAhc3RhdGUud3JpdGluZyk7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIilcbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtJylcbiAgLCBpbmhlcml0cyAgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbiAgLCB4dGVuZCAgICAgPSByZXF1aXJlKCd4dGVuZCcpXG5cbmZ1bmN0aW9uIERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdHMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0cylcbiAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoRGVzdHJveWFibGVUcmFuc2Zvcm0sIFRyYW5zZm9ybSlcblxuRGVzdHJveWFibGVUcmFuc2Zvcm0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWVcbiAgXG4gIHZhciBzZWxmID0gdGhpc1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGlmIChlcnIpXG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICB9KVxufVxuXG4vLyBhIG5vb3AgX3RyYW5zZm9ybSBmdW5jdGlvblxuZnVuY3Rpb24gbm9vcCAoY2h1bmssIGVuYywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sobnVsbCwgY2h1bmspXG59XG5cblxuLy8gY3JlYXRlIGEgbmV3IGV4cG9ydCBmdW5jdGlvbiwgdXNlZCBieSBib3RoIHRoZSBtYWluIGV4cG9ydCBhbmRcbi8vIHRoZSAuY3RvciBleHBvcnQsIGNvbnRhaW5zIGNvbW1vbiBsb2dpYyBmb3IgZGVhbGluZyB3aXRoIGFyZ3VtZW50c1xuZnVuY3Rpb24gdGhyb3VnaDIgKGNvbnN0cnVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmx1c2ggICAgID0gdHJhbnNmb3JtXG4gICAgICB0cmFuc2Zvcm0gPSBvcHRpb25zXG4gICAgICBvcHRpb25zICAgPSB7fVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtICE9ICdmdW5jdGlvbicpXG4gICAgICB0cmFuc2Zvcm0gPSBub29wXG5cbiAgICBpZiAodHlwZW9mIGZsdXNoICE9ICdmdW5jdGlvbicpXG4gICAgICBmbHVzaCA9IG51bGxcblxuICAgIHJldHVybiBjb25zdHJ1Y3Qob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaClcbiAgfVxufVxuXG5cbi8vIG1haW4gZXhwb3J0LCBqdXN0IG1ha2UgbWUgYSB0cmFuc2Zvcm0gc3RyZWFtIVxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0ob3B0aW9ucylcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuXG5cbi8vIG1ha2UgbWUgYSByZXVzYWJsZSBwcm90b3R5cGUgdGhhdCBJIGNhbiBgbmV3YCwgb3IgaW1wbGljaXRseSBgbmV3YFxuLy8gd2l0aCBhIGNvbnN0cnVjdG9yIGNhbGxcbm1vZHVsZS5leHBvcnRzLmN0b3IgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICBmdW5jdGlvbiBUaHJvdWdoMiAob3ZlcnJpZGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGhyb3VnaDIpKVxuICAgICAgcmV0dXJuIG5ldyBUaHJvdWdoMihvdmVycmlkZSlcblxuICAgIHRoaXMub3B0aW9ucyA9IHh0ZW5kKG9wdGlvbnMsIG92ZXJyaWRlKVxuXG4gICAgRGVzdHJveWFibGVUcmFuc2Zvcm0uY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBpbmhlcml0cyhUaHJvdWdoMiwgRGVzdHJveWFibGVUcmFuc2Zvcm0pXG5cbiAgVGhyb3VnaDIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgVGhyb3VnaDIucHJvdG90eXBlLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIFRocm91Z2gyXG59KVxuXG5cbm1vZHVsZS5leHBvcnRzLm9iaiA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIHZhciB0MiA9IG5ldyBEZXN0cm95YWJsZVRyYW5zZm9ybSh4dGVuZCh7IG9iamVjdE1vZGU6IHRydWUsIGhpZ2hXYXRlck1hcms6IDE2IH0sIG9wdGlvbnMpKVxuXG4gIHQyLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgdDIuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gdDJcbn0pXG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJ1Zikge1xuXHQvLyBJZiB0aGUgYnVmZmVyIGlzIGJhY2tlZCBieSBhIFVpbnQ4QXJyYXksIGEgZmFzdGVyIHZlcnNpb24gd2lsbCB3b3JrXG5cdGlmIChidWYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG5cdFx0Ly8gSWYgdGhlIGJ1ZmZlciBpc24ndCBhIHN1YmFycmF5LCByZXR1cm4gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXJcblx0XHRpZiAoYnVmLmJ5dGVPZmZzZXQgPT09IDAgJiYgYnVmLmJ5dGVMZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGJ1Zi5idWZmZXJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBidWYuYnVmZmVyLnNsaWNlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBnZXQgYSBwcm9wZXIgY29weVxuXHRcdFx0cmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpXG5cdFx0fVxuXHR9XG5cblx0aWYgKEJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG5cdFx0Ly8gVGhpcyBpcyB0aGUgc2xvdyB2ZXJzaW9uIHRoYXQgd2lsbCB3b3JrIHdpdGggYW55IEJ1ZmZlclxuXHRcdC8vIGltcGxlbWVudGF0aW9uIChldmVuIGluIG9sZCBicm93c2Vycylcblx0XHR2YXIgYXJyYXlDb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmxlbmd0aClcblx0XHR2YXIgbGVuID0gYnVmLmxlbmd0aFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGFycmF5Q29weVtpXSA9IGJ1ZltpXVxuXHRcdH1cblx0XHRyZXR1cm4gYXJyYXlDb3B5LmJ1ZmZlclxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG5cdH1cbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjFcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3YuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2M1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdjIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2NFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdjMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2NVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdjQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOSUxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX25pbC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcnNpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3ZlcnNpb24uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdmFsaWRhdGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdHJpbmdpZnlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9wYXJzZS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92MS5qc1wiKSk7XG5cbnZhciBfdjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3YzLmpzXCIpKTtcblxudmFyIF92MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjQuanNcIikpO1xuXG52YXIgX3Y0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92NS5qc1wiKSk7XG5cbnZhciBfbmlsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9uaWwuanNcIikpO1xuXG52YXIgX3ZlcnNpb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZlcnNpb24uanNcIikpO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKSk7XG5cbnZhciBfc3RyaW5naWZ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIikpO1xuXG52YXIgX3BhcnNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbi8qXG4gKiBCcm93c2VyLWNvbXBhdGlibGUgSmF2YVNjcmlwdCBNRDVcbiAqXG4gKiBNb2RpZmljYXRpb24gb2YgSmF2YVNjcmlwdCBNRDVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTUQ1XG4gKlxuICogQ29weXJpZ2h0IDIwMTEsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIEJhc2VkIG9uXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDA5XG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cbmZ1bmN0aW9uIG1kNShieXRlcykge1xuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShtc2cubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlc1tpXSA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZDVUb0hleEVuY29kZWRBcnJheSh3b3Jkc1RvTWQ1KGJ5dGVzVG9Xb3JkcyhieXRlcyksIGJ5dGVzLmxlbmd0aCAqIDgpKTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMgdG8gYW4gYXJyYXkgb2YgYnl0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNVRvSGV4RW5jb2RlZEFycmF5KGlucHV0KSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBjb25zdCBsZW5ndGgzMiA9IGlucHV0Lmxlbmd0aCAqIDMyO1xuICBjb25zdCBoZXhUYWIgPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGgzMjsgaSArPSA4KSB7XG4gICAgY29uc3QgeCA9IGlucHV0W2kgPj4gNV0gPj4+IGkgJSAzMiAmIDB4ZmY7XG4gICAgY29uc3QgaGV4ID0gcGFyc2VJbnQoaGV4VGFiLmNoYXJBdCh4ID4+PiA0ICYgMHgwZikgKyBoZXhUYWIuY2hhckF0KHggJiAweDBmKSwgMTYpO1xuICAgIG91dHB1dC5wdXNoKGhleCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgb3V0cHV0IGxlbmd0aCB3aXRoIHBhZGRpbmcgYW5kIGJpdCBsZW5ndGhcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE91dHB1dExlbmd0aChpbnB1dExlbmd0aDgpIHtcbiAgcmV0dXJuIChpbnB1dExlbmd0aDggKyA2NCA+Pj4gOSA8PCA0KSArIDE0ICsgMTtcbn1cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuICovXG5cblxuZnVuY3Rpb24gd29yZHNUb01kNSh4LCBsZW4pIHtcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCBsZW4gJSAzMjtcbiAgeFtnZXRPdXRwdXRMZW5ndGgobGVuKSAtIDFdID0gbGVuO1xuICBsZXQgYSA9IDE3MzI1ODQxOTM7XG4gIGxldCBiID0gLTI3MTczMzg3OTtcbiAgbGV0IGMgPSAtMTczMjU4NDE5NDtcbiAgbGV0IGQgPSAyNzE3MzM4Nzg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuICAgIGNvbnN0IG9sZGEgPSBhO1xuICAgIGNvbnN0IG9sZGIgPSBiO1xuICAgIGNvbnN0IG9sZGMgPSBjO1xuICAgIGNvbnN0IG9sZGQgPSBkO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2ldLCA3LCAtNjgwODc2OTM2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE3LCA2MDYxMDU4MTkpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgNF0sIDcsIC0xNzY0MTg4OTcpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA1XSwgMTIsIDEyMDAwODA0MjYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNywgMTc3MDAzNTQxNik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE3LCAtNDIwNjMpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNywgMTgwNDYwMzY4Mik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTVdLCAyMiwgMTIzNjUzNTMyOSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA1LCAtMTY1Nzk2NTEwKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgNl0sIDksIC0xMDY5NTAxNjMyKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNCwgNjQzNzE3NzEzKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNSwgLTcwMTU1ODY5MSk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDEwXSwgOSwgMzgwMTYwODMpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgOV0sIDUsIDU2ODQ0NjQzOCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDE0XSwgOSwgLTEwMTk4MDM2OTApO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA4XSwgMjAsIDExNjM1MzE1MDEpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDUsIC0xNDQ0NjgxNDY3KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMl0sIDksIC01MTQwMzc4NCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNCwgMTczNTMyODQ3Myk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgNV0sIDQsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA0LCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDRdLCAxMSwgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCA0LCA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2ldLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDZdLCAyMywgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNCwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE2LCA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2ldLCA2LCAtMTk4NjMwODQ0KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgN10sIDEwLCAxMTI2ODkxNDE1KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNiwgMTcwMDQ4NTU3MSk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNiwgMTg3MzMxMzM1OSk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxM10sIDIxLCAxMzA5MTUxNjQ5KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgNF0sIDYsIC0xNDU1MjMwNzApO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNSwgNzE4Nzg3MjU5KTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcbiAgICBhID0gc2FmZUFkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZUFkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZUFkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZUFkZChkLCBvbGRkKTtcbiAgfVxuXG4gIHJldHVybiBbYSwgYiwgYywgZF07XG59XG4vKlxuICogQ29udmVydCBhbiBhcnJheSBieXRlcyB0byBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gKiBDaGFyYWN0ZXJzID4yNTUgaGF2ZSB0aGVpciBoaWdoLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ5dGVzVG9Xb3JkcyhpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgbGVuZ3RoOCA9IGlucHV0Lmxlbmd0aCAqIDg7XG4gIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50MzJBcnJheShnZXRPdXRwdXRMZW5ndGgobGVuZ3RoOCkpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoODsgaSArPSA4KSB7XG4gICAgb3V0cHV0W2kgPj4gNV0gfD0gKGlucHV0W2kgLyA4XSAmIDB4ZmYpIDw8IGkgJSAzMjtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNhZmVBZGQoeCwgeSkge1xuICBjb25zdCBsc3cgPSAoeCAmIDB4ZmZmZikgKyAoeSAmIDB4ZmZmZik7XG4gIGNvbnN0IG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gbXN3IDw8IDE2IHwgbHN3ICYgMHhmZmZmO1xufVxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpdFJvdGF0ZUxlZnQobnVtLCBjbnQpIHtcbiAgcmV0dXJuIG51bSA8PCBjbnQgfCBudW0gPj4+IDMyIC0gY250O1xufVxuLypcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICByZXR1cm4gc2FmZUFkZChiaXRSb3RhdGVMZWZ0KHNhZmVBZGQoc2FmZUFkZChhLCBxKSwgc2FmZUFkZCh4LCB0KSksIHMpLCBiKTtcbn1cblxuZnVuY3Rpb24gbWQ1ZmYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBjIHwgfmIgJiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1Z2coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBkIHwgYyAmIH5kLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aGgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWlpKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihjIF4gKGIgfCB+ZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBtZDU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfZGVmYXVsdCA9ICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gcGFyc2UodXVpZCkge1xuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgbGV0IHY7XG4gIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gUGFyc2UgIyMjIyMjIyMtLi4uLi0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNDtcbiAgYXJyWzFdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMl0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzNdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLSMjIyMtLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls0XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSg5LCAxMyksIDE2KSkgPj4+IDg7XG4gIGFycls1XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLSMjIyMtLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNl0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE4KSwgMTYpKSA+Pj4gODtcbiAgYXJyWzddID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0jIyMjLS4uLi4uLi4uLi4uLlxuXG4gIGFycls4XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4O1xuICBhcnJbOV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLS4uLi4tIyMjIyMjIyMjIyMjXG4gIC8vIChVc2UgXCIvXCIgdG8gYXZvaWQgMzItYml0IHRydW5jYXRpb24gd2hlbiBiaXQtc2hpZnRpbmcgaGlnaC1vcmRlciBieXRlcylcblxuICBhcnJbMTBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDI0LCAzNiksIDE2KSkgLyAweDEwMDAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzExXSA9IHYgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMl0gPSB2ID4+PiAyNCAmIDB4ZmY7XG4gIGFyclsxM10gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsxNF0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzE1XSA9IHYgJiAweGZmO1xuICByZXR1cm4gYXJyO1xufVxuXG52YXIgX2RlZmF1bHQgPSBwYXJzZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9kZWZhdWx0ID0gL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBybmc7XG4vLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbmxldCBnZXRSYW5kb21WYWx1ZXM7XG5jb25zdCBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcblxuZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4gICAgLy8gZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIChtc0NyeXB0bykgb24gSUUxMS5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pIHx8IHR5cGVvZiBtc0NyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG5cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG4vLyBBZGFwdGVkIGZyb20gQ2hyaXMgVmVuZXNzJyBTSEExIGNvZGUgYXRcbi8vIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvc2hhMS5odG1sXG5mdW5jdGlvbiBmKHMsIHgsIHksIHopIHtcbiAgc3dpdGNoIChzKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHggJiB5IF4gfnggJiB6O1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiB4ICYgeSBeIHggJiB6IF4geSAmIHo7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuICB9XG59XG5cbmZ1bmN0aW9uIFJPVEwoeCwgbikge1xuICByZXR1cm4geCA8PCBuIHwgeCA+Pj4gMzIgLSBuO1xufVxuXG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gIGNvbnN0IEsgPSBbMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhjYTYyYzFkNl07XG4gIGNvbnN0IEggPSBbMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMF07XG5cbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBtc2cgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYnl0ZXMpKTsgLy8gVVRGOCBlc2NhcGVcblxuICAgIGJ5dGVzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXMucHVzaChtc2cuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIC8vIENvbnZlcnQgQXJyYXktbGlrZSB0byBBcnJheVxuICAgIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYnl0ZXMpO1xuICB9XG5cbiAgYnl0ZXMucHVzaCgweDgwKTtcbiAgY29uc3QgbCA9IGJ5dGVzLmxlbmd0aCAvIDQgKyAyO1xuICBjb25zdCBOID0gTWF0aC5jZWlsKGwgLyAxNik7XG4gIGNvbnN0IE0gPSBuZXcgQXJyYXkoTik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICBhcnJbal0gPSBieXRlc1tpICogNjQgKyBqICogNF0gPDwgMjQgfCBieXRlc1tpICogNjQgKyBqICogNCArIDFdIDw8IDE2IHwgYnl0ZXNbaSAqIDY0ICsgaiAqIDQgKyAyXSA8PCA4IHwgYnl0ZXNbaSAqIDY0ICsgaiAqIDQgKyAzXTtcbiAgICB9XG5cbiAgICBNW2ldID0gYXJyO1xuICB9XG5cbiAgTVtOIC0gMV1bMTRdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAvIE1hdGgucG93KDIsIDMyKTtcbiAgTVtOIC0gMV1bMTRdID0gTWF0aC5mbG9vcihNW04gLSAxXVsxNF0pO1xuICBNW04gLSAxXVsxNV0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4ICYgMHhmZmZmZmZmZjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgIGNvbnN0IFcgPSBuZXcgVWludDMyQXJyYXkoODApO1xuXG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCAxNjsgKyt0KSB7XG4gICAgICBXW3RdID0gTVtpXVt0XTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB0ID0gMTY7IHQgPCA4MDsgKyt0KSB7XG4gICAgICBXW3RdID0gUk9UTChXW3QgLSAzXSBeIFdbdCAtIDhdIF4gV1t0IC0gMTRdIF4gV1t0IC0gMTZdLCAxKTtcbiAgICB9XG5cbiAgICBsZXQgYSA9IEhbMF07XG4gICAgbGV0IGIgPSBIWzFdO1xuICAgIGxldCBjID0gSFsyXTtcbiAgICBsZXQgZCA9IEhbM107XG4gICAgbGV0IGUgPSBIWzRdO1xuXG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCA4MDsgKyt0KSB7XG4gICAgICBjb25zdCBzID0gTWF0aC5mbG9vcih0IC8gMjApO1xuICAgICAgY29uc3QgVCA9IFJPVEwoYSwgNSkgKyBmKHMsIGIsIGMsIGQpICsgZSArIEtbc10gKyBXW3RdID4+PiAwO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBST1RMKGIsIDMwKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IFQ7XG4gICAgfVxuXG4gICAgSFswXSA9IEhbMF0gKyBhID4+PiAwO1xuICAgIEhbMV0gPSBIWzFdICsgYiA+Pj4gMDtcbiAgICBIWzJdID0gSFsyXSArIGMgPj4+IDA7XG4gICAgSFszXSA9IEhbM10gKyBkID4+PiAwO1xuICAgIEhbNF0gPSBIWzRdICsgZSA+Pj4gMDtcbiAgfVxuXG4gIHJldHVybiBbSFswXSA+PiAyNCAmIDB4ZmYsIEhbMF0gPj4gMTYgJiAweGZmLCBIWzBdID4+IDggJiAweGZmLCBIWzBdICYgMHhmZiwgSFsxXSA+PiAyNCAmIDB4ZmYsIEhbMV0gPj4gMTYgJiAweGZmLCBIWzFdID4+IDggJiAweGZmLCBIWzFdICYgMHhmZiwgSFsyXSA+PiAyNCAmIDB4ZmYsIEhbMl0gPj4gMTYgJiAweGZmLCBIWzJdID4+IDggJiAweGZmLCBIWzJdICYgMHhmZiwgSFszXSA+PiAyNCAmIDB4ZmYsIEhbM10gPj4gMTYgJiAweGZmLCBIWzNdID4+IDggJiAweGZmLCBIWzNdICYgMHhmZiwgSFs0XSA+PiAyNCAmIDB4ZmYsIEhbNF0gPj4gMTYgJiAweGZmLCBIWzRdID4+IDggJiAweGZmLCBIWzRdICYgMHhmZl07XG59XG5cbnZhciBfZGVmYXVsdCA9IHNoYTE7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICBjb25zdCB1dWlkID0gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCEoMCwgX3ZhbGlkYXRlLmRlZmF1bHQpKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG52YXIgX2RlZmF1bHQgPSBzdHJpbmdpZnk7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9ybmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JuZy5qc1wiKSk7XG5cbnZhciBfc3RyaW5naWZ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5sZXQgX25vZGVJZDtcblxubGV0IF9jbG9ja3NlcTsgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5cblxubGV0IF9sYXN0TVNlY3MgPSAwO1xubGV0IF9sYXN0TlNlY3MgPSAwOyAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkIGZvciBBUEkgZGV0YWlsc1xuXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBsZXQgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgY29uc3QgYiA9IGJ1ZiB8fCBuZXcgQXJyYXkoMTYpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgbGV0IGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTsgLy8gbm9kZSBhbmQgY2xvY2tzZXEgbmVlZCB0byBiZSBpbml0aWFsaXplZCB0byByYW5kb20gdmFsdWVzIGlmIHRoZXkncmUgbm90XG4gIC8vIHNwZWNpZmllZC4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3VlcyByZWxhdGVkIHRvIGluc3VmZmljaWVudFxuICAvLyBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG5cbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgY29uc3Qgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcuZGVmYXVsdCkoKTtcblxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbc2VlZEJ5dGVzWzBdIHwgMHgwMSwgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1dO1xuICAgIH1cblxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfSAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cblxuXG4gIGxldCBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBEYXRlLm5vdygpOyAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG5cbiAgbGV0IG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxOyAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG5cbiAgY29uc3QgZHQgPSBtc2VjcyAtIF9sYXN0TVNlY3MgKyAobnNlY3MgLSBfbGFzdE5TZWNzKSAvIDEwMDAwOyAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG5cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfSAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG5cblxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfSAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG5cblxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTsgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG5cbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7IC8vIGB0aW1lX2xvd2BcblxuICBjb25zdCB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7IC8vIGB0aW1lX21pZGBcblxuICBjb25zdCB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7IC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG5cbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmOyAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcblxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7IC8vIGBjbG9ja19zZXFfbG93YFxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjsgLy8gYG5vZGVgXG5cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmIHx8ICgwLCBfc3RyaW5naWZ5LmRlZmF1bHQpKGIpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2MTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3YzNS5qc1wiKSk7XG5cbnZhciBfbWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL21kNS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IHYzID0gKDAsIF92LmRlZmF1bHQpKCd2MycsIDB4MzAsIF9tZC5kZWZhdWx0KTtcbnZhciBfZGVmYXVsdCA9IHYzO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbmV4cG9ydHMuVVJMID0gZXhwb3J0cy5ETlMgPSB2b2lkIDA7XG5cbnZhciBfc3RyaW5naWZ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIikpO1xuXG52YXIgX3BhcnNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTsgLy8gVVRGOCBlc2NhcGVcblxuICBjb25zdCBieXRlcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmNvbnN0IEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0cy5ETlMgPSBETlM7XG5jb25zdCBVUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydHMuVVJMID0gVVJMO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChuYW1lLCB2ZXJzaW9uLCBoYXNoZnVuYykge1xuICBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQodmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9ICgwLCBfcGFyc2UuZGVmYXVsdCkobmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH0gLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcbiAgICAvLyBGdXR1cmU6IFVzZSBzcHJlYWQgc3ludGF4IHdoZW4gc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMsIGUuZy4gYGJ5dGVzID1cbiAgICAvLyBoYXNoZnVuYyhbLi4ubmFtZXNwYWNlLCAuLi4gdmFsdWVdKWBcblxuXG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfc3RyaW5naWZ5LmRlZmF1bHQpKGJ5dGVzKTtcbiAgfSAvLyBGdW5jdGlvbiNuYW1lIGlzIG5vdCBzZXR0YWJsZSBvbiBzb21lIHBsYXRmb3JtcyAoIzI3MClcblxuXG4gIHRyeSB7XG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgfSBjYXRjaCAoZXJyKSB7fSAvLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxuXG5cbiAgZ2VuZXJhdGVVVUlELkROUyA9IEROUztcbiAgZ2VuZXJhdGVVVUlELlVSTCA9IFVSTDtcbiAgcmV0dXJuIGdlbmVyYXRlVVVJRDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9ybmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JuZy5qc1wiKSk7XG5cbnZhciBfc3RyaW5naWZ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zdHJpbmdpZnkuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcuZGVmYXVsdCkoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gKDAsIF9zdHJpbmdpZnkuZGVmYXVsdCkocm5kcyk7XG59XG5cbnZhciBfZGVmYXVsdCA9IHY0O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjM1LmpzXCIpKTtcblxudmFyIF9zaGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NoYTEuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCB2NSA9ICgwLCBfdi5kZWZhdWx0KSgndjUnLCAweDUwLCBfc2hhLmRlZmF1bHQpO1xudmFyIF9kZWZhdWx0ID0gdjU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWdleCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVnZXguanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgX3JlZ2V4LmRlZmF1bHQudGVzdCh1dWlkKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdmFsaWRhdGU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2ZXJzaW9uKHV1aWQpIHtcbiAgaWYgKCEoMCwgX3ZhbGlkYXRlLmRlZmF1bHQpKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUludCh1dWlkLnN1YnN0cigxNCwgMSksIDE2KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdmVyc2lvbjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuIC8qIGVzbGludC1lbnYgbm9kZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFNoaW1taW5nIHN0YXJ0cyBoZXJlLlxuKGZ1bmN0aW9uKCkge1xuICAvLyBVdGlscy5cbiAgdmFyIGxvZ2dpbmcgPSByZXF1aXJlKCcuL3V0aWxzJykubG9nO1xuICB2YXIgYnJvd3NlckRldGFpbHMgPSByZXF1aXJlKCcuL3V0aWxzJykuYnJvd3NlckRldGFpbHM7XG4gIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gIG1vZHVsZS5leHBvcnRzLmJyb3dzZXJEZXRhaWxzID0gYnJvd3NlckRldGFpbHM7XG4gIG1vZHVsZS5leHBvcnRzLmV4dHJhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi91dGlscycpLmV4dHJhY3RWZXJzaW9uO1xuICBtb2R1bGUuZXhwb3J0cy5kaXNhYmxlTG9nID0gcmVxdWlyZSgnLi91dGlscycpLmRpc2FibGVMb2c7XG5cbiAgLy8gVW5jb21tZW50IHRoZSBsaW5lIGJlbG93IGlmIHlvdSB3YW50IGxvZ2dpbmcgdG8gb2NjdXIsIGluY2x1ZGluZyBsb2dnaW5nXG4gIC8vIGZvciB0aGUgc3dpdGNoIHN0YXRlbWVudCBiZWxvdy4gQ2FuIGFsc28gYmUgdHVybmVkIG9uIGluIHRoZSBicm93c2VyIHZpYVxuICAvLyBhZGFwdGVyLmRpc2FibGVMb2coZmFsc2UpLCBidXQgdGhlbiBsb2dnaW5nIGZyb20gdGhlIHN3aXRjaCBzdGF0ZW1lbnQgYmVsb3dcbiAgLy8gd2lsbCBub3QgYXBwZWFyLlxuICAvLyByZXF1aXJlKCcuL3V0aWxzJykuZGlzYWJsZUxvZyhmYWxzZSk7XG5cbiAgLy8gQnJvd3NlciBzaGltcy5cbiAgdmFyIGNocm9tZVNoaW0gPSByZXF1aXJlKCcuL2Nocm9tZS9jaHJvbWVfc2hpbScpIHx8IG51bGw7XG4gIHZhciBlZGdlU2hpbSA9IHJlcXVpcmUoJy4vZWRnZS9lZGdlX3NoaW0nKSB8fCBudWxsO1xuICB2YXIgZmlyZWZveFNoaW0gPSByZXF1aXJlKCcuL2ZpcmVmb3gvZmlyZWZveF9zaGltJykgfHwgbnVsbDtcbiAgdmFyIHNhZmFyaVNoaW0gPSByZXF1aXJlKCcuL3NhZmFyaS9zYWZhcmlfc2hpbScpIHx8IG51bGw7XG5cbiAgLy8gU2hpbSBicm93c2VyIGlmIGZvdW5kLlxuICBzd2l0Y2ggKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIpIHtcbiAgICBjYXNlICdvcGVyYSc6IC8vIGZhbGx0aHJvdWdoIGFzIGl0IHVzZXMgY2hyb21lIHNoaW1zXG4gICAgY2FzZSAnY2hyb21lJzpcbiAgICAgIGlmICghY2hyb21lU2hpbSB8fCAhY2hyb21lU2hpbS5zaGltUGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgbG9nZ2luZygnQ2hyb21lIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIGNocm9tZS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBtb2R1bGUuZXhwb3J0cy5icm93c2VyU2hpbSA9IGNocm9tZVNoaW07XG5cbiAgICAgIGNocm9tZVNoaW0uc2hpbUdldFVzZXJNZWRpYSgpO1xuICAgICAgY2hyb21lU2hpbS5zaGltTWVkaWFTdHJlYW0oKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbVNvdXJjZU9iamVjdCgpO1xuICAgICAgY2hyb21lU2hpbS5zaGltUGVlckNvbm5lY3Rpb24oKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbU9uVHJhY2soKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ZpcmVmb3gnOlxuICAgICAgaWYgKCFmaXJlZm94U2hpbSB8fCAhZmlyZWZveFNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgIGxvZ2dpbmcoJ0ZpcmVmb3ggc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgZmlyZWZveC4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBtb2R1bGUuZXhwb3J0cy5icm93c2VyU2hpbSA9IGZpcmVmb3hTaGltO1xuXG4gICAgICBmaXJlZm94U2hpbS5zaGltR2V0VXNlck1lZGlhKCk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltU291cmNlT2JqZWN0KCk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltUGVlckNvbm5lY3Rpb24oKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1PblRyYWNrKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlZGdlJzpcbiAgICAgIGlmICghZWRnZVNoaW0gfHwgIWVkZ2VTaGltLnNoaW1QZWVyQ29ubmVjdGlvbikge1xuICAgICAgICBsb2dnaW5nKCdNUyBlZGdlIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIGVkZ2UuJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgbW9kdWxlLmV4cG9ydHMuYnJvd3NlclNoaW0gPSBlZGdlU2hpbTtcblxuICAgICAgZWRnZVNoaW0uc2hpbUdldFVzZXJNZWRpYSgpO1xuICAgICAgZWRnZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzYWZhcmknOlxuICAgICAgaWYgKCFzYWZhcmlTaGltKSB7XG4gICAgICAgIGxvZ2dpbmcoJ1NhZmFyaSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBzYWZhcmkuJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgbW9kdWxlLmV4cG9ydHMuYnJvd3NlclNoaW0gPSBzYWZhcmlTaGltO1xuXG4gICAgICBzYWZhcmlTaGltLnNoaW1HZXRVc2VyTWVkaWEoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsb2dnaW5nKCdVbnN1cHBvcnRlZCBicm93c2VyIScpO1xuICB9XG59KSgpO1xuIiwiXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbiAvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBsb2dnaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMuanMnKS5sb2c7XG52YXIgYnJvd3NlckRldGFpbHMgPSByZXF1aXJlKCcuLi91dGlscy5qcycpLmJyb3dzZXJEZXRhaWxzO1xuXG52YXIgY2hyb21lU2hpbSA9IHtcbiAgc2hpbU1lZGlhU3RyZWFtOiBmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cuTWVkaWFTdHJlYW0gPSB3aW5kb3cuTWVkaWFTdHJlYW0gfHwgd2luZG93LndlYmtpdE1lZGlhU3RyZWFtO1xuICB9LFxuXG4gIHNoaW1PblRyYWNrOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICEoJ29udHJhY2snIGluXG4gICAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ29udHJhY2snLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29udHJhY2s7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZikge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICBpZiAodGhpcy5fb250cmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2spO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbnRyYWNrcG9seSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrID0gZik7XG4gICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbnRyYWNrcG9seSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vIG9uYWRkc3RyZWFtIGRvZXMgbm90IGZpcmUgd2hlbiBhIHRyYWNrIGlzIGFkZGVkIHRvIGFuIGV4aXN0aW5nXG4gICAgICAgICAgICAvLyBzdHJlYW0uIEJ1dCBzdHJlYW0ub25hZGR0cmFjayBpcyBpbXBsZW1lbnRlZCBzbyB3ZSB1c2UgdGhhdC5cbiAgICAgICAgICAgIGUuc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgZnVuY3Rpb24odGUpIHtcbiAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgICBldmVudC50cmFjayA9IHRlLnRyYWNrO1xuICAgICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHt0cmFjazogdGUudHJhY2t9O1xuICAgICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZS5zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgICAgIGV2ZW50LnRyYWNrID0gdHJhY2s7XG4gICAgICAgICAgICAgIGV2ZW50LnJlY2VpdmVyID0ge3RyYWNrOiB0cmFja307XG4gICAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgc2hpbVNvdXJjZU9iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAod2luZG93LkhUTUxNZWRpYUVsZW1lbnQgJiZcbiAgICAgICAgISgnc3JjT2JqZWN0JyBpbiB3aW5kb3cuSFRNTE1lZGlhRWxlbWVudC5wcm90b3R5cGUpKSB7XG4gICAgICAgIC8vIFNoaW0gdGhlIHNyY09iamVjdCBwcm9wZXJ0eSwgb25jZSwgd2hlbiBIVE1MTWVkaWFFbGVtZW50IGlzIGZvdW5kLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LkhUTUxNZWRpYUVsZW1lbnQucHJvdG90eXBlLCAnc3JjT2JqZWN0Jywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3JjT2JqZWN0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIC8vIFVzZSBfc3JjT2JqZWN0IGFzIGEgcHJpdmF0ZSBwcm9wZXJ0eSBmb3IgdGhpcyBzaGltXG4gICAgICAgICAgICB0aGlzLl9zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgICBpZiAodGhpcy5zcmMpIHtcbiAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLnNyYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3RyZWFtKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3JjID0gJyc7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byByZWNyZWF0ZSB0aGUgYmxvYiB1cmwgd2hlbiBhIHRyYWNrIGlzIGFkZGVkIG9yXG4gICAgICAgICAgICAvLyByZW1vdmVkLiBEb2luZyBpdCBtYW51YWxseSBzaW5jZSB3ZSB3YW50IHRvIGF2b2lkIGEgcmVjdXJzaW9uLlxuICAgICAgICAgICAgc3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmLnNyYykge1xuICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc2VsZi5zcmMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGYuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGYuc3JjKSB7XG4gICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChzZWxmLnNyYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VsZi5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBzaGltUGVlckNvbm5lY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRoZSBSVENQZWVyQ29ubmVjdGlvbiBvYmplY3QuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gZnVuY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpIHtcbiAgICAgIC8vIFRyYW5zbGF0ZSBpY2VUcmFuc3BvcnRQb2xpY3kgdG8gaWNlVHJhbnNwb3J0cyxcbiAgICAgIC8vIHNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTQ4NjlcbiAgICAgIGxvZ2dpbmcoJ1BlZXJDb25uZWN0aW9uJyk7XG4gICAgICBpZiAocGNDb25maWcgJiYgcGNDb25maWcuaWNlVHJhbnNwb3J0UG9saWN5KSB7XG4gICAgICAgIHBjQ29uZmlnLmljZVRyYW5zcG9ydHMgPSBwY0NvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3k7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYyA9IG5ldyB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cyk7XG4gICAgICB2YXIgb3JpZ0dldFN0YXRzID0gcGMuZ2V0U3RhdHMuYmluZChwYyk7XG4gICAgICBwYy5nZXRTdGF0cyA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgICAvLyBJZiBzZWxlY3RvciBpcyBhIGZ1bmN0aW9uIHRoZW4gd2UgYXJlIGluIHRoZSBvbGQgc3R5bGUgc3RhdHMgc28ganVzdFxuICAgICAgICAvLyBwYXNzIGJhY2sgdGhlIG9yaWdpbmFsIGdldFN0YXRzIGZvcm1hdCB0byBhdm9pZCBicmVha2luZyBvbGQgdXNlcnMuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ0dldFN0YXRzKHNlbGVjdG9yLCBzdWNjZXNzQ2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpeENocm9tZVN0YXRzXyA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgdmFyIHN0YW5kYXJkUmVwb3J0ID0ge307XG4gICAgICAgICAgdmFyIHJlcG9ydHMgPSByZXNwb25zZS5yZXN1bHQoKTtcbiAgICAgICAgICByZXBvcnRzLmZvckVhY2goZnVuY3Rpb24ocmVwb3J0KSB7XG4gICAgICAgICAgICB2YXIgc3RhbmRhcmRTdGF0cyA9IHtcbiAgICAgICAgICAgICAgaWQ6IHJlcG9ydC5pZCxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiByZXBvcnQudGltZXN0YW1wLFxuICAgICAgICAgICAgICB0eXBlOiByZXBvcnQudHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcG9ydC5uYW1lcygpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICBzdGFuZGFyZFN0YXRzW25hbWVdID0gcmVwb3J0LnN0YXQobmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YW5kYXJkUmVwb3J0W3N0YW5kYXJkU3RhdHMuaWRdID0gc3RhbmRhcmRTdGF0cztcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBzdGFuZGFyZFJlcG9ydDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzaGltIGdldFN0YXRzIHdpdGggbWFwbGlrZSBzdXBwb3J0XG4gICAgICAgIHZhciBtYWtlTWFwU3RhdHMgPSBmdW5jdGlvbihzdGF0cywgbGVnYWN5U3RhdHMpIHtcbiAgICAgICAgICB2YXIgbWFwID0gbmV3IE1hcChPYmplY3Qua2V5cyhzdGF0cykubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuW2tleSwgc3RhdHNba2V5XV07XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGxlZ2FjeVN0YXRzID0gbGVnYWN5U3RhdHMgfHwgc3RhdHM7XG4gICAgICAgICAgT2JqZWN0LmtleXMobGVnYWN5U3RhdHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBtYXBba2V5XSA9IGxlZ2FjeVN0YXRzW2tleV07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgdmFyIHN1Y2Nlc3NDYWxsYmFja1dyYXBwZXJfID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGFyZ3NbMV0obWFrZU1hcFN0YXRzKGZpeENocm9tZVN0YXRzXyhyZXNwb25zZSkpKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBbc3VjY2Vzc0NhbGxiYWNrV3JhcHBlcl8sXG4gICAgICAgICAgICAgIGFyZ3VtZW50c1swXV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJvbWlzZS1zdXBwb3J0XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHNlbGVjdG9yID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3JpZ0dldFN0YXRzLmFwcGx5KHNlbGYsIFtcbiAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG1ha2VNYXBTdGF0cyhmaXhDaHJvbWVTdGF0c18ocmVzcG9uc2UpKSk7XG4gICAgICAgICAgICAgIH0sIHJlamVjdF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBsZWdhY3kgY2hyb21lIHN0YXRzIG9ubHkgb24gbGVnYWN5IGFjY2VzcyBvZiBzdGF0cyBvYmpcbiAgICAgICAgICAgIG9yaWdHZXRTdGF0cy5hcHBseShzZWxmLCBbXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtYWtlTWFwU3RhdHMoZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucmVzdWx0KCkpKTtcbiAgICAgICAgICAgICAgfSwgcmVqZWN0XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcGM7XG4gICAgfTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlID0gd2Via2l0UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuXG4gICAgLy8gd3JhcCBzdGF0aWMgbWV0aG9kcy4gQ3VycmVudGx5IGp1c3QgZ2VuZXJhdGVDZXJ0aWZpY2F0ZS5cbiAgICBpZiAod2Via2l0UlRDUGVlckNvbm5lY3Rpb24uZ2VuZXJhdGVDZXJ0aWZpY2F0ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiwgJ2dlbmVyYXRlQ2VydGlmaWNhdGUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLmdlbmVyYXRlQ2VydGlmaWNhdGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIFsnY3JlYXRlT2ZmZXInLCAnY3JlYXRlQW5zd2VyJ10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHZhciBuYXRpdmVNZXRob2QgPSB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgIHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxIHx8IChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgbmF0aXZlTWV0aG9kLmFwcGx5KHNlbGYsIFtyZXNvbHZlLCByZWplY3QsIG9wdHNdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIHByb21pc2Ugc3VwcG9ydCAtLSBuYXRpdmVseSBhdmFpbGFibGUgaW4gQ2hyb21lIDUxXG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1MSkge1xuICAgICAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJywgJ2FkZEljZUNhbmRpZGF0ZSddXG4gICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlTWV0aG9kID0gd2Via2l0UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICAgICAgICB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIG5hdGl2ZU1ldGhvZC5hcHBseShzZWxmLCBbYXJnc1swXSwgcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhcmdzWzFdLmFwcGx5KG51bGwsIFtdKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbMl0uYXBwbHkobnVsbCwgW2Vycl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNoaW0gaW1wbGljaXQgY3JlYXRpb24gb2YgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uL1JUQ0ljZUNhbmRpZGF0ZVxuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICB2YXIgbmF0aXZlTWV0aG9kID0gd2Via2l0UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICAgICAgd2Via2l0UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAoKG1ldGhvZCA9PT0gJ2FkZEljZUNhbmRpZGF0ZScpID9cbiAgICAgICAgICAgICAgICBSVENJY2VDYW5kaWRhdGUgOiBSVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAvLyBzdXBwb3J0IGZvciBhZGRJY2VDYW5kaWRhdGUobnVsbCBvciB1bmRlZmluZWQpXG4gICAgdmFyIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZSA9XG4gICAgICAgIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGU7XG4gICAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1sxXSkge1xuICAgICAgICAgIGFyZ3VtZW50c1sxXS5hcHBseShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufTtcblxuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hpbU1lZGlhU3RyZWFtOiBjaHJvbWVTaGltLnNoaW1NZWRpYVN0cmVhbSxcbiAgc2hpbU9uVHJhY2s6IGNocm9tZVNoaW0uc2hpbU9uVHJhY2ssXG4gIHNoaW1Tb3VyY2VPYmplY3Q6IGNocm9tZVNoaW0uc2hpbVNvdXJjZU9iamVjdCxcbiAgc2hpbVBlZXJDb25uZWN0aW9uOiBjaHJvbWVTaGltLnNoaW1QZWVyQ29ubmVjdGlvbixcbiAgc2hpbUdldFVzZXJNZWRpYTogcmVxdWlyZSgnLi9nZXR1c2VybWVkaWEnKVxufTtcbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuIC8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGxvZ2dpbmcgPSByZXF1aXJlKCcuLi91dGlscy5qcycpLmxvZztcblxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbnN0cmFpbnRzVG9DaHJvbWVfID0gZnVuY3Rpb24oYykge1xuICAgIGlmICh0eXBlb2YgYyAhPT0gJ29iamVjdCcgfHwgYy5tYW5kYXRvcnkgfHwgYy5vcHRpb25hbCkge1xuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHZhciBjYyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVxdWlyZScgfHwga2V5ID09PSAnYWR2YW5jZWQnIHx8IGtleSA9PT0gJ21lZGlhU291cmNlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgciA9ICh0eXBlb2YgY1trZXldID09PSAnb2JqZWN0JykgPyBjW2tleV0gOiB7aWRlYWw6IGNba2V5XX07XG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByLm1pbiA9IHIubWF4ID0gci5leGFjdDtcbiAgICAgIH1cbiAgICAgIHZhciBvbGRuYW1lXyA9IGZ1bmN0aW9uKHByZWZpeCwgbmFtZSkge1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmFtZSA9PT0gJ2RldmljZUlkJykgPyAnc291cmNlSWQnIDogbmFtZTtcbiAgICAgIH07XG4gICAgICBpZiAoci5pZGVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNjLm9wdGlvbmFsID0gY2Mub3B0aW9uYWwgfHwgW107XG4gICAgICAgIHZhciBvYyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHIuaWRlYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJ21pbicsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgICBvYyA9IHt9O1xuICAgICAgICAgIG9jW29sZG5hbWVfKCdtYXgnLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJycsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHIuZXhhY3QgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygci5leGFjdCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY2MubWFuZGF0b3J5ID0gY2MubWFuZGF0b3J5IHx8IHt9O1xuICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8oJycsIGtleSldID0gci5leGFjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFsnbWluJywgJ21heCddLmZvckVhY2goZnVuY3Rpb24obWl4KSB7XG4gICAgICAgICAgaWYgKHJbbWl4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8obWl4LCBrZXkpXSA9IHJbbWl4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjLmFkdmFuY2VkKSB7XG4gICAgICBjYy5vcHRpb25hbCA9IChjYy5vcHRpb25hbCB8fCBbXSkuY29uY2F0KGMuYWR2YW5jZWQpO1xuICAgIH1cbiAgICByZXR1cm4gY2M7XG4gIH07XG5cbiAgdmFyIHNoaW1Db25zdHJhaW50c18gPSBmdW5jdGlvbihjb25zdHJhaW50cywgZnVuYykge1xuICAgIGNvbnN0cmFpbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIGlmIChjb25zdHJhaW50cyAmJiBjb25zdHJhaW50cy5hdWRpbykge1xuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy5hdWRpbyk7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50cyAmJiB0eXBlb2YgY29uc3RyYWludHMudmlkZW8gPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBTaGltIGZhY2luZ01vZGUgZm9yIG1vYmlsZSwgd2hlcmUgaXQgZGVmYXVsdHMgdG8gXCJ1c2VyXCIuXG4gICAgICB2YXIgZmFjZSA9IGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XG4gICAgICBmYWNlID0gZmFjZSAmJiAoKHR5cGVvZiBmYWNlID09PSAnb2JqZWN0JykgPyBmYWNlIDoge2lkZWFsOiBmYWNlfSk7XG5cbiAgICAgIGlmICgoZmFjZSAmJiAoZmFjZS5leGFjdCA9PT0gJ3VzZXInIHx8IGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHxcbiAgICAgICAgICAgICAgICAgICAgZmFjZS5pZGVhbCA9PT0gJ3VzZXInIHx8IGZhY2UuaWRlYWwgPT09ICdlbnZpcm9ubWVudCcpKSAmJlxuICAgICAgICAgICEobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cyAmJlxuICAgICAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cygpLmZhY2luZ01vZGUpKSB7XG4gICAgICAgIGRlbGV0ZSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xuICAgICAgICBpZiAoZmFjZS5leGFjdCA9PT0gJ2Vudmlyb25tZW50JyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSB7XG4gICAgICAgICAgLy8gTG9vayBmb3IgXCJiYWNrXCIgaW4gbGFiZWwsIG9yIHVzZSBsYXN0IGNhbSAodHlwaWNhbGx5IGJhY2sgY2FtKS5cbiAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKClcbiAgICAgICAgICAudGhlbihmdW5jdGlvbihkZXZpY2VzKSB7XG4gICAgICAgICAgICBkZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZC5raW5kID09PSAndmlkZW9pbnB1dCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBiYWNrID0gZGV2aWNlcy5maW5kKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGQubGFiZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdiYWNrJykgIT09IC0xO1xuICAgICAgICAgICAgfSkgfHwgKGRldmljZXMubGVuZ3RoICYmIGRldmljZXNbZGV2aWNlcy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICBpZiAoYmFjaykge1xuICAgICAgICAgICAgICBjb25zdHJhaW50cy52aWRlby5kZXZpY2VJZCA9IGZhY2UuZXhhY3QgPyB7ZXhhY3Q6IGJhY2suZGV2aWNlSWR9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2lkZWFsOiBiYWNrLmRldmljZUlkfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgICAgICAgICAgbG9nZ2luZygnY2hyb21lOiAnICsgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy52aWRlbyk7XG4gICAgfVxuICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICB9O1xuXG4gIHZhciBzaGltRXJyb3JfID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB7XG4gICAgICAgIFBlcm1pc3Npb25EZW5pZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIENvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvcjogJ092ZXJjb25zdHJhaW5lZEVycm9yJ1xuICAgICAgfVtlLm5hbWVdIHx8IGUubmFtZSxcbiAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgIGNvbnN0cmFpbnQ6IGUuY29uc3RyYWludE5hbWUsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAodGhpcy5tZXNzYWdlICYmICc6ICcpICsgdGhpcy5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGdldFVzZXJNZWRpYV8gPSBmdW5jdGlvbihjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgc2hpbUNvbnN0cmFpbnRzXyhjb25zdHJhaW50cywgZnVuY3Rpb24oYykge1xuICAgICAgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYShjLCBvblN1Y2Nlc3MsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgb25FcnJvcihzaGltRXJyb3JfKGUpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBnZXRVc2VyTWVkaWFfO1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBnZXRVc2VyTWVkaWEgYXMgYSBQcm9taXNlLlxuICB2YXIgZ2V0VXNlck1lZGlhUHJvbWlzZV8gPSBmdW5jdGlvbihjb25zdHJhaW50cykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyA9IHtcbiAgICAgIGdldFVzZXJNZWRpYTogZ2V0VXNlck1lZGlhUHJvbWlzZV8sXG4gICAgICBlbnVtZXJhdGVEZXZpY2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICB2YXIga2luZHMgPSB7YXVkaW86ICdhdWRpb2lucHV0JywgdmlkZW86ICd2aWRlb2lucHV0J307XG4gICAgICAgICAgcmV0dXJuIE1lZGlhU3RyZWFtVHJhY2suZ2V0U291cmNlcyhmdW5jdGlvbihkZXZpY2VzKSB7XG4gICAgICAgICAgICByZXNvbHZlKGRldmljZXMubWFwKGZ1bmN0aW9uKGRldmljZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge2xhYmVsOiBkZXZpY2UubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAga2luZDoga2luZHNbZGV2aWNlLmtpbmRdLFxuICAgICAgICAgICAgICAgICAgICAgIGRldmljZUlkOiBkZXZpY2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogJyd9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQSBzaGltIGZvciBnZXRVc2VyTWVkaWEgbWV0aG9kIG9uIHRoZSBtZWRpYURldmljZXMgb2JqZWN0LlxuICAvLyBUT0RPKEthcHRlbkphbnNzb24pIHJlbW92ZSBvbmNlIGltcGxlbWVudGVkIGluIENocm9tZSBzdGFibGUuXG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzKSB7XG4gICAgICByZXR1cm4gZ2V0VXNlck1lZGlhUHJvbWlzZV8oY29uc3RyYWludHMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gRXZlbiB0aG91Z2ggQ2hyb21lIDQ1IGhhcyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzIGFuZCBhIGdldFVzZXJNZWRpYVxuICAgIC8vIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBQcm9taXNlLCBpdCBkb2VzIG5vdCBhY2NlcHQgc3BlYy1zdHlsZVxuICAgIC8vIGNvbnN0cmFpbnRzLlxuICAgIHZhciBvcmlnR2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuXG4gICAgICAgIGJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbihjcykge1xuICAgICAgcmV0dXJuIHNoaW1Db25zdHJhaW50c18oY3MsIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdHZXRVc2VyTWVkaWEoYykudGhlbihmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICBpZiAoYy5hdWRpbyAmJiAhc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoIHx8XG4gICAgICAgICAgICAgIGMudmlkZW8gJiYgIXN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCcnLCAnTm90Rm91bmRFcnJvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgICB9LCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHNoaW1FcnJvcl8oZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICAvLyBEdW1teSBkZXZpY2VjaGFuZ2UgZXZlbnQgbWV0aG9kcy5cbiAgLy8gVE9ETyhLYXB0ZW5KYW5zc29uKSByZW1vdmUgb25jZSBpbXBsZW1lbnRlZCBpbiBDaHJvbWUgc3RhYmxlLlxuICBpZiAodHlwZW9mIG5hdmlnYXRvci5tZWRpYURldmljZXMuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGxvZ2dpbmcoJ0R1bW15IG1lZGlhRGV2aWNlcy5hZGRFdmVudExpc3RlbmVyIGNhbGxlZC4nKTtcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5yZW1vdmVFdmVudExpc3RlbmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgbG9nZ2luZygnRHVtbXkgbWVkaWFEZXZpY2VzLnJlbW92ZUV2ZW50TGlzdGVuZXIgY2FsbGVkLicpO1xuICAgIH07XG4gIH1cbn07XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbiAvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFNEUFV0aWxzID0gcmVxdWlyZSgnc2RwJyk7XG52YXIgYnJvd3NlckRldGFpbHMgPSByZXF1aXJlKCcuLi91dGlscycpLmJyb3dzZXJEZXRhaWxzO1xuXG52YXIgZWRnZVNoaW0gPSB7XG4gIHNoaW1QZWVyQ29ubmVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHdpbmRvdy5SVENJY2VHYXRoZXJlcikge1xuICAgICAgLy8gT1JUQyBkZWZpbmVzIGFuIFJUQ0ljZUNhbmRpZGF0ZSBvYmplY3QgYnV0IG5vIGNvbnN0cnVjdG9yLlxuICAgICAgLy8gTm90IGltcGxlbWVudGVkIGluIEVkZ2UuXG4gICAgICBpZiAoIXdpbmRvdy5SVENJY2VDYW5kaWRhdGUpIHtcbiAgICAgICAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIE9SVEMgZG9lcyBub3QgaGF2ZSBhIHNlc3Npb24gZGVzY3JpcHRpb24gb2JqZWN0IGJ1dFxuICAgICAgLy8gb3RoZXIgYnJvd3NlcnMgKGkuZS4gQ2hyb21lKSB0aGF0IHdpbGwgc3VwcG9ydCBib3RoIFBDIGFuZCBPUlRDXG4gICAgICAvLyBpbiB0aGUgZnV0dXJlIG1pZ2h0IGhhdmUgdGhpcyBkZWZpbmVkIGFscmVhZHkuXG4gICAgICBpZiAoIXdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pIHtcbiAgICAgICAgd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMgYWRkcyBhbiBhZGRpdGlvbmFsIGV2ZW50IGxpc3RlbmVyIHRvIE1lZGlhU3RyYWNrVHJhY2sgdGhhdCBzaWduYWxzXG4gICAgICAvLyB3aGVuIGEgdHJhY2tzIGVuYWJsZWQgcHJvcGVydHkgd2FzIGNoYW5nZWQuXG4gICAgICB2YXIgb3JpZ01TVEVuYWJsZWQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLCAnZW5hYmxlZCcpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLCAnZW5hYmxlZCcsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIG9yaWdNU1RFbmFibGVkLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICB2YXIgZXYgPSBuZXcgRXZlbnQoJ2VuYWJsZWQnKTtcbiAgICAgICAgICBldi5lbmFibGVkID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHZhciBfZXZlbnRUYXJnZXQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICBbJ2FkZEV2ZW50TGlzdGVuZXInLCAncmVtb3ZlRXZlbnRMaXN0ZW5lcicsICdkaXNwYXRjaEV2ZW50J11cbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgIHNlbGZbbWV0aG9kXSA9IF9ldmVudFRhcmdldFttZXRob2RdLmJpbmQoX2V2ZW50VGFyZ2V0KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgdGhpcy5vbmljZWNhbmRpZGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLm9uYWRkc3RyZWFtID0gbnVsbDtcbiAgICAgIHRoaXMub250cmFjayA9IG51bGw7XG4gICAgICB0aGlzLm9ucmVtb3Zlc3RyZWFtID0gbnVsbDtcbiAgICAgIHRoaXMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMub25uZWdvdGlhdGlvbm5lZWRlZCA9IG51bGw7XG4gICAgICB0aGlzLm9uZGF0YWNoYW5uZWwgPSBudWxsO1xuXG4gICAgICB0aGlzLmxvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgdGhpcy5yZW1vdGVTdHJlYW1zID0gW107XG4gICAgICB0aGlzLmdldExvY2FsU3RyZWFtcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5sb2NhbFN0cmVhbXM7XG4gICAgICB9O1xuICAgICAgdGhpcy5nZXRSZW1vdGVTdHJlYW1zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJlbW90ZVN0cmVhbXM7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmxvY2FsRGVzY3JpcHRpb24gPSBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgdHlwZTogJycsXG4gICAgICAgIHNkcDogJydcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZW1vdGVEZXNjcmlwdGlvbiA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICB0eXBlOiAnJyxcbiAgICAgICAgc2RwOiAnJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNpZ25hbGluZ1N0YXRlID0gJ3N0YWJsZSc7XG4gICAgICB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSA9ICduZXcnO1xuICAgICAgdGhpcy5pY2VHYXRoZXJpbmdTdGF0ZSA9ICduZXcnO1xuXG4gICAgICB0aGlzLmljZU9wdGlvbnMgPSB7XG4gICAgICAgIGdhdGhlclBvbGljeTogJ2FsbCcsXG4gICAgICAgIGljZVNlcnZlcnM6IFtdXG4gICAgICB9O1xuICAgICAgaWYgKGNvbmZpZyAmJiBjb25maWcuaWNlVHJhbnNwb3J0UG9saWN5KSB7XG4gICAgICAgIHN3aXRjaCAoY29uZmlnLmljZVRyYW5zcG9ydFBvbGljeSkge1xuICAgICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgY2FzZSAncmVsYXknOlxuICAgICAgICAgICAgdGhpcy5pY2VPcHRpb25zLmdhdGhlclBvbGljeSA9IGNvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3k7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgIC8vIEZJWE1FOiByZW1vdmUgb25jZSBpbXBsZW1lbnRhdGlvbiBhbmQgc3BlYyBoYXZlIGFkZGVkIHRoaXMuXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpY2VUcmFuc3BvcnRQb2xpY3kgXCJub25lXCIgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBkb24ndCBzZXQgaWNlVHJhbnNwb3J0UG9saWN5LlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudXNpbmdCdW5kbGUgPSBjb25maWcgJiYgY29uZmlnLmJ1bmRsZVBvbGljeSA9PT0gJ21heC1idW5kbGUnO1xuXG4gICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5pY2VTZXJ2ZXJzKSB7XG4gICAgICAgIC8vIEVkZ2UgZG9lcyBub3QgbGlrZVxuICAgICAgICAvLyAxKSBzdHVuOlxuICAgICAgICAvLyAyKSB0dXJuOiB0aGF0IGRvZXMgbm90IGhhdmUgYWxsIG9mIHR1cm46aG9zdDpwb3J0P3RyYW5zcG9ydD11ZHBcbiAgICAgICAgLy8gMykgdHVybjogd2l0aCBpcHY2IGFkZHJlc3Nlc1xuICAgICAgICB2YXIgaWNlU2VydmVycyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uZmlnLmljZVNlcnZlcnMpKTtcbiAgICAgICAgdGhpcy5pY2VPcHRpb25zLmljZVNlcnZlcnMgPSBpY2VTZXJ2ZXJzLmZpbHRlcihmdW5jdGlvbihzZXJ2ZXIpIHtcbiAgICAgICAgICBpZiAoc2VydmVyICYmIHNlcnZlci51cmxzKSB7XG4gICAgICAgICAgICB2YXIgdXJscyA9IHNlcnZlci51cmxzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cmxzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB1cmxzID0gW3VybHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXJscyA9IHVybHMuZmlsdGVyKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICByZXR1cm4gKHVybC5pbmRleE9mKCd0dXJuOicpID09PSAwICYmXG4gICAgICAgICAgICAgICAgICB1cmwuaW5kZXhPZigndHJhbnNwb3J0PXVkcCcpICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgdXJsLmluZGV4T2YoJ3R1cm46WycpID09PSAtMSkgfHxcbiAgICAgICAgICAgICAgICAgICh1cmwuaW5kZXhPZignc3R1bjonKSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDE0MzkzKTtcbiAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgcmV0dXJuICEhdXJscztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcblxuICAgICAgLy8gcGVyLXRyYWNrIGljZUdhdGhlcnMsIGljZVRyYW5zcG9ydHMsIGR0bHNUcmFuc3BvcnRzLCBydHBTZW5kZXJzLCAuLi5cbiAgICAgIC8vIGV2ZXJ5dGhpbmcgdGhhdCBpcyBuZWVkZWQgdG8gZGVzY3JpYmUgYSBTRFAgbS1saW5lLlxuICAgICAgdGhpcy50cmFuc2NlaXZlcnMgPSBbXTtcblxuICAgICAgLy8gc2luY2UgdGhlIGljZUdhdGhlcmVyIGlzIGN1cnJlbnRseSBjcmVhdGVkIGluIGNyZWF0ZU9mZmVyIGJ1dCB3ZVxuICAgICAgLy8gbXVzdCBub3QgZW1pdCBjYW5kaWRhdGVzIHVudGlsIGFmdGVyIHNldExvY2FsRGVzY3JpcHRpb24gd2UgYnVmZmVyXG4gICAgICAvLyB0aGVtIGluIHRoaXMgYXJyYXkuXG4gICAgICB0aGlzLl9sb2NhbEljZUNhbmRpZGF0ZXNCdWZmZXIgPSBbXTtcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fZW1pdEJ1ZmZlcmVkQ2FuZGlkYXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhzZWxmLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgIC8vIEZJWE1FOiBuZWVkIHRvIGFwcGx5IGljZSBjYW5kaWRhdGVzIGluIGEgd2F5IHdoaWNoIGlzIGFzeW5jIGJ1dFxuICAgICAgLy8gaW4tb3JkZXJcbiAgICAgIHRoaXMuX2xvY2FsSWNlQ2FuZGlkYXRlc0J1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBlbmQgPSAhZXZlbnQuY2FuZGlkYXRlIHx8IE9iamVjdC5rZXlzKGV2ZW50LmNhbmRpZGF0ZSkubGVuZ3RoID09PSAwO1xuICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBzZWN0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHNlY3Rpb25zW2pdLmluZGV4T2YoJ1xcclxcbmE9ZW5kLW9mLWNhbmRpZGF0ZXNcXHJcXG4nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgc2VjdGlvbnNbal0gKz0gJ2E9ZW5kLW9mLWNhbmRpZGF0ZXNcXHJcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5jYW5kaWRhdGUuY2FuZGlkYXRlLmluZGV4T2YoJ3R5cCBlbmRPZkNhbmRpZGF0ZXMnKVxuICAgICAgICAgICAgPT09IC0xKSB7XG4gICAgICAgICAgc2VjdGlvbnNbZXZlbnQuY2FuZGlkYXRlLnNkcE1MaW5lSW5kZXggKyAxXSArPVxuICAgICAgICAgICAgICAnYT0nICsgZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSArICdcXHJcXG4nO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYubG9jYWxEZXNjcmlwdGlvbi5zZHAgPSBzZWN0aW9ucy5qb2luKCcnKTtcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaWYgKHNlbGYub25pY2VjYW5kaWRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICBzZWxmLm9uaWNlY2FuZGlkYXRlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV2ZW50LmNhbmRpZGF0ZSAmJiBzZWxmLmljZUdhdGhlcmluZ1N0YXRlICE9PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgdmFyIGNvbXBsZXRlID0gc2VsZi50cmFuc2NlaXZlcnMuZXZlcnkoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5pY2VHYXRoZXJlciAmJlxuICAgICAgICAgICAgICAgIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyLnN0YXRlID09PSAnY29tcGxldGVkJztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgIHNlbGYuaWNlR2F0aGVyaW5nU3RhdGUgPSAnY29tcGxldGUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9sb2NhbEljZUNhbmRpZGF0ZXNCdWZmZXIgPSBbXTtcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRDb25maWd1cmF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgLy8gQ2xvbmUgaXMgbmVjZXNzYXJ5IGZvciBsb2NhbCBkZW1vcyBtb3N0bHksIGF0dGFjaGluZyBkaXJlY3RseVxuICAgICAgLy8gdG8gdHdvIGRpZmZlcmVudCBzZW5kZXJzIGRvZXMgbm90IHdvcmsgKGJ1aWxkIDEwNTQ3KS5cbiAgICAgIHZhciBjbG9uZWRTdHJlYW0gPSBzdHJlYW0uY2xvbmUoKTtcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrLCBpZHgpIHtcbiAgICAgICAgdmFyIGNsb25lZFRyYWNrID0gY2xvbmVkU3RyZWFtLmdldFRyYWNrcygpW2lkeF07XG4gICAgICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuYWJsZWQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIGNsb25lZFRyYWNrLmVuYWJsZWQgPSBldmVudC5lbmFibGVkO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5sb2NhbFN0cmVhbXMucHVzaChjbG9uZWRTdHJlYW0pO1xuICAgICAgdGhpcy5fbWF5YmVGaXJlTmVnb3RpYXRpb25OZWVkZWQoKTtcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHZhciBpZHggPSB0aGlzLmxvY2FsU3RyZWFtcy5pbmRleE9mKHN0cmVhbSk7XG4gICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5sb2NhbFN0cmVhbXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHRoaXMuX21heWJlRmlyZU5lZ290aWF0aW9uTmVlZGVkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNjZWl2ZXJzLmZpbHRlcihmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICByZXR1cm4gISF0cmFuc2NlaXZlci5ydHBTZW5kZXI7XG4gICAgICB9KVxuICAgICAgLm1hcChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIucnRwU2VuZGVyO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2NlaXZlcnMuZmlsdGVyKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiAhIXRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyO1xuICAgICAgfSlcbiAgICAgIC5tYXAoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIERldGVybWluZXMgdGhlIGludGVyc2VjdGlvbiBvZiBsb2NhbCBhbmQgcmVtb3RlIGNhcGFiaWxpdGllcy5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9nZXRDb21tb25DYXBhYmlsaXRpZXMgPVxuICAgICAgICBmdW5jdGlvbihsb2NhbENhcGFiaWxpdGllcywgcmVtb3RlQ2FwYWJpbGl0aWVzKSB7XG4gICAgICAgICAgdmFyIGNvbW1vbkNhcGFiaWxpdGllcyA9IHtcbiAgICAgICAgICAgIGNvZGVjczogW10sXG4gICAgICAgICAgICBoZWFkZXJFeHRlbnNpb25zOiBbXSxcbiAgICAgICAgICAgIGZlY01lY2hhbmlzbXM6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihsQ29kZWMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtb3RlQ2FwYWJpbGl0aWVzLmNvZGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgckNvZGVjID0gcmVtb3RlQ2FwYWJpbGl0aWVzLmNvZGVjc1tpXTtcbiAgICAgICAgICAgICAgaWYgKGxDb2RlYy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IHJDb2RlYy5uYW1lLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICAgICAgICAgIGxDb2RlYy5jbG9ja1JhdGUgPT09IHJDb2RlYy5jbG9ja1JhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBudW1iZXIgb2YgY2hhbm5lbHMgaXMgdGhlIGhpZ2hlc3QgY29tbW9uIG51bWJlciBvZiBjaGFubmVsc1xuICAgICAgICAgICAgICAgIHJDb2RlYy5udW1DaGFubmVscyA9IE1hdGgubWluKGxDb2RlYy5udW1DaGFubmVscyxcbiAgICAgICAgICAgICAgICAgICAgckNvZGVjLm51bUNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICAvLyBwdXNoIHJDb2RlYyBzbyB3ZSByZXBseSB3aXRoIG9mZmVyZXIgcGF5bG9hZCB0eXBlXG4gICAgICAgICAgICAgICAgY29tbW9uQ2FwYWJpbGl0aWVzLmNvZGVjcy5wdXNoKHJDb2RlYyk7XG5cbiAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgY29tbW9uIGZlZWRiYWNrIG1lY2hhbmlzbXNcbiAgICAgICAgICAgICAgICByQ29kZWMucnRjcEZlZWRiYWNrID0gckNvZGVjLnJ0Y3BGZWVkYmFjay5maWx0ZXIoZnVuY3Rpb24oZmIpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbENvZGVjLnJ0Y3BGZWVkYmFjay5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobENvZGVjLnJ0Y3BGZWVkYmFja1tqXS50eXBlID09PSBmYi50eXBlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBsQ29kZWMucnRjcEZlZWRiYWNrW2pdLnBhcmFtZXRlciA9PT0gZmIucGFyYW1ldGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogYWxzbyBuZWVkIHRvIGRldGVybWluZSAucGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgIC8vICBzZWUgaHR0cHM6Ly9naXRodWIuY29tL29wZW5wZWVyL29ydGMvaXNzdWVzLzU2OVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBsb2NhbENhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zXG4gICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGxIZWFkZXJFeHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW90ZUNhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgIGkrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIHJIZWFkZXJFeHRlbnNpb24gPSByZW1vdGVDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgIGlmIChsSGVhZGVyRXh0ZW5zaW9uLnVyaSA9PT0gckhlYWRlckV4dGVuc2lvbi51cmkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnMucHVzaChySGVhZGVyRXh0ZW5zaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEZJWE1FOiBmZWNNZWNoYW5pc21zXG4gICAgICAgICAgcmV0dXJuIGNvbW1vbkNhcGFiaWxpdGllcztcbiAgICAgICAgfTtcblxuICAgIC8vIENyZWF0ZSBJQ0UgZ2F0aGVyZXIsIElDRSB0cmFuc3BvcnQgYW5kIERUTFMgdHJhbnNwb3J0LlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX2NyZWF0ZUljZUFuZER0bHNUcmFuc3BvcnRzID1cbiAgICAgICAgZnVuY3Rpb24obWlkLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHZhciBpY2VHYXRoZXJlciA9IG5ldyBSVENJY2VHYXRoZXJlcihzZWxmLmljZU9wdGlvbnMpO1xuICAgICAgICAgIHZhciBpY2VUcmFuc3BvcnQgPSBuZXcgUlRDSWNlVHJhbnNwb3J0KGljZUdhdGhlcmVyKTtcbiAgICAgICAgICBpY2VHYXRoZXJlci5vbmxvY2FsY2FuZGlkYXRlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2ljZWNhbmRpZGF0ZScpO1xuICAgICAgICAgICAgZXZlbnQuY2FuZGlkYXRlID0ge3NkcE1pZDogbWlkLCBzZHBNTGluZUluZGV4OiBzZHBNTGluZUluZGV4fTtcblxuICAgICAgICAgICAgdmFyIGNhbmQgPSBldnQuY2FuZGlkYXRlO1xuICAgICAgICAgICAgdmFyIGVuZCA9ICFjYW5kIHx8IE9iamVjdC5rZXlzKGNhbmQpLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgIC8vIEVkZ2UgZW1pdHMgYW4gZW1wdHkgb2JqZWN0IGZvciBSVENJY2VDYW5kaWRhdGVDb21wbGV0ZeKApVxuICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAvLyBwb2x5ZmlsbCBzaW5jZSBSVENJY2VHYXRoZXJlci5zdGF0ZSBpcyBub3QgaW1wbGVtZW50ZWQgaW5cbiAgICAgICAgICAgICAgLy8gRWRnZSAxMDU0NyB5ZXQuXG4gICAgICAgICAgICAgIGlmIChpY2VHYXRoZXJlci5zdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWNlR2F0aGVyZXIuc3RhdGUgPSAnY29tcGxldGVkJztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEVtaXQgYSBjYW5kaWRhdGUgd2l0aCB0eXBlIGVuZE9mQ2FuZGlkYXRlcyB0byBtYWtlIHRoZSBzYW1wbGVzXG4gICAgICAgICAgICAgIC8vIHdvcmsuIEVkZ2UgcmVxdWlyZXMgYWRkSWNlQ2FuZGlkYXRlIHdpdGggdGhpcyBlbXB0eSBjYW5kaWRhdGVcbiAgICAgICAgICAgICAgLy8gdG8gc3RhcnQgY2hlY2tpbmcuIFRoZSByZWFsIHNvbHV0aW9uIGlzIHRvIHNpZ25hbFxuICAgICAgICAgICAgICAvLyBlbmQtb2YtY2FuZGlkYXRlcyB0byB0aGUgb3RoZXIgc2lkZSB3aGVuIGdldHRpbmcgdGhlIG51bGxcbiAgICAgICAgICAgICAgLy8gY2FuZGlkYXRlIGJ1dCBzb21lIGFwcHMgKGxpa2UgdGhlIHNhbXBsZXMpIGRvbid0IGRvIHRoYXQuXG4gICAgICAgICAgICAgIGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUgPVxuICAgICAgICAgICAgICAgICAgJ2NhbmRpZGF0ZToxIDEgdWRwIDEgMC4wLjAuMCA5IHR5cCBlbmRPZkNhbmRpZGF0ZXMnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUlRDSWNlQ2FuZGlkYXRlIGRvZXNuJ3QgaGF2ZSBhIGNvbXBvbmVudCwgbmVlZHMgdG8gYmUgYWRkZWRcbiAgICAgICAgICAgICAgY2FuZC5jb21wb25lbnQgPSBpY2VUcmFuc3BvcnQuY29tcG9uZW50ID09PSAnUlRDUCcgPyAyIDogMTtcbiAgICAgICAgICAgICAgZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSA9IFNEUFV0aWxzLndyaXRlQ2FuZGlkYXRlKGNhbmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgbG9jYWwgZGVzY3JpcHRpb24uXG4gICAgICAgICAgICB2YXIgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKHNlbGYubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUuaW5kZXhPZigndHlwIGVuZE9mQ2FuZGlkYXRlcycpXG4gICAgICAgICAgICAgICAgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHNlY3Rpb25zW2V2ZW50LmNhbmRpZGF0ZS5zZHBNTGluZUluZGV4ICsgMV0gKz1cbiAgICAgICAgICAgICAgICAgICdhPScgKyBldmVudC5jYW5kaWRhdGUuY2FuZGlkYXRlICsgJ1xcclxcbic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWN0aW9uc1tldmVudC5jYW5kaWRhdGUuc2RwTUxpbmVJbmRleCArIDFdICs9XG4gICAgICAgICAgICAgICAgICAnYT1lbmQtb2YtY2FuZGlkYXRlc1xcclxcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmxvY2FsRGVzY3JpcHRpb24uc2RwID0gc2VjdGlvbnMuam9pbignJyk7XG5cbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IHNlbGYudHJhbnNjZWl2ZXJzLmV2ZXJ5KGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5pY2VHYXRoZXJlciAmJlxuICAgICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIuc3RhdGUgPT09ICdjb21wbGV0ZWQnO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEVtaXQgY2FuZGlkYXRlIGlmIGxvY2FsRGVzY3JpcHRpb24gaXMgc2V0LlxuICAgICAgICAgICAgLy8gQWxzbyBlbWl0cyBudWxsIGNhbmRpZGF0ZSB3aGVuIGFsbCBnYXRoZXJlcnMgYXJlIGNvbXBsZXRlLlxuICAgICAgICAgICAgc3dpdGNoIChzZWxmLmljZUdhdGhlcmluZ1N0YXRlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ25ldyc6XG4gICAgICAgICAgICAgICAgc2VsZi5fbG9jYWxJY2VDYW5kaWRhdGVzQnVmZmVyLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgJiYgY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX2xvY2FsSWNlQ2FuZGlkYXRlc0J1ZmZlci5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgIG5ldyBFdmVudCgnaWNlY2FuZGlkYXRlJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnZ2F0aGVyaW5nJzpcbiAgICAgICAgICAgICAgICBzZWxmLl9lbWl0QnVmZmVyZWRDYW5kaWRhdGVzKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vbmljZWNhbmRpZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgc2VsZi5vbmljZWNhbmRpZGF0ZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaWNlY2FuZGlkYXRlJykpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNlbGYub25pY2VjYW5kaWRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbmljZWNhbmRpZGF0ZShuZXcgRXZlbnQoJ2ljZWNhbmRpZGF0ZScpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHNlbGYuaWNlR2F0aGVyaW5nU3RhdGUgPSAnY29tcGxldGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBub3QgaGFwcGVuLi4uIGN1cnJlbnRseSFcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDogLy8gbm8tb3AuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpY2VUcmFuc3BvcnQub25pY2VzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlQ29ubmVjdGlvblN0YXRlKCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBkdGxzVHJhbnNwb3J0ID0gbmV3IFJUQ0R0bHNUcmFuc3BvcnQoaWNlVHJhbnNwb3J0KTtcbiAgICAgICAgICBkdGxzVHJhbnNwb3J0Lm9uZHRsc3N0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl91cGRhdGVDb25uZWN0aW9uU3RhdGUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGR0bHNUcmFuc3BvcnQub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gb25lcnJvciBkb2VzIG5vdCBzZXQgc3RhdGUgdG8gZmFpbGVkIGJ5IGl0c2VsZi5cbiAgICAgICAgICAgIGR0bHNUcmFuc3BvcnQuc3RhdGUgPSAnZmFpbGVkJztcbiAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUNvbm5lY3Rpb25TdGF0ZSgpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWNlR2F0aGVyZXI6IGljZUdhdGhlcmVyLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0OiBpY2VUcmFuc3BvcnQsXG4gICAgICAgICAgICBkdGxzVHJhbnNwb3J0OiBkdGxzVHJhbnNwb3J0XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgIC8vIFN0YXJ0IHRoZSBSVFAgU2VuZGVyIGFuZCBSZWNlaXZlciBmb3IgYSB0cmFuc2NlaXZlci5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl90cmFuc2NlaXZlID0gZnVuY3Rpb24odHJhbnNjZWl2ZXIsXG4gICAgICAgIHNlbmQsIHJlY3YpIHtcbiAgICAgIHZhciBwYXJhbXMgPSB0aGlzLl9nZXRDb21tb25DYXBhYmlsaXRpZXModHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXMsXG4gICAgICAgICAgdHJhbnNjZWl2ZXIucmVtb3RlQ2FwYWJpbGl0aWVzKTtcbiAgICAgIGlmIChzZW5kICYmIHRyYW5zY2VpdmVyLnJ0cFNlbmRlcikge1xuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVycztcbiAgICAgICAgcGFyYW1zLnJ0Y3AgPSB7XG4gICAgICAgICAgY25hbWU6IFNEUFV0aWxzLmxvY2FsQ05hbWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgcGFyYW1zLnJ0Y3Auc3NyYyA9IHRyYW5zY2VpdmVyLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYztcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2NlaXZlci5ydHBTZW5kZXIuc2VuZChwYXJhbXMpO1xuICAgICAgfVxuICAgICAgaWYgKHJlY3YgJiYgdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIpIHtcbiAgICAgICAgLy8gcmVtb3ZlIFJUWCBmaWVsZCBpbiBFZGdlIDE0OTQyXG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5raW5kID09PSAndmlkZW8nXG4gICAgICAgICAgICAmJiB0cmFuc2NlaXZlci5yZWN2RW5jb2RpbmdQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIucmVjdkVuY29kaW5nUGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwLnJ0eDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gdHJhbnNjZWl2ZXIucmVjdkVuY29kaW5nUGFyYW1ldGVycztcbiAgICAgICAgcGFyYW1zLnJ0Y3AgPSB7XG4gICAgICAgICAgY25hbWU6IHRyYW5zY2VpdmVyLmNuYW1lXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHBhcmFtcy5ydGNwLnNzcmMgPSB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmM7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIucmVjZWl2ZShwYXJhbXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPVxuICAgICAgICBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICB2YXIgc2VjdGlvbnM7XG4gICAgICAgICAgdmFyIHNlc3Npb25wYXJ0O1xuICAgICAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnb2ZmZXInKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogV2hhdCB3YXMgdGhlIHB1cnBvc2Ugb2YgdGhpcyBlbXB0eSBpZiBzdGF0ZW1lbnQ/XG4gICAgICAgICAgICAvLyBpZiAoIXRoaXMuX3BlbmRpbmdPZmZlcikge1xuICAgICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nT2ZmZXIpIHtcbiAgICAgICAgICAgICAgLy8gVkVSWSBsaW1pdGVkIHN1cHBvcnQgZm9yIFNEUCBtdW5naW5nLiBMaW1pdGVkIHRvOlxuICAgICAgICAgICAgICAvLyAqIGNoYW5naW5nIHRoZSBvcmRlciBvZiBjb2RlY3NcbiAgICAgICAgICAgICAgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGRlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgICAgICAgIHNlc3Npb25wYXJ0ID0gc2VjdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgc2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNkcE1MaW5lSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FwcyA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHNlbGYuX3BlbmRpbmdPZmZlcltzZHBNTGluZUluZGV4XS5sb2NhbENhcGFiaWxpdGllcyA9IGNhcHM7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLnRyYW5zY2VpdmVycyA9IHRoaXMuX3BlbmRpbmdPZmZlcjtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdPZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgICAgICBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoc2VsZi5yZW1vdGVEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAgICAgc2Vzc2lvbnBhcnQgPSBzZWN0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIGlzSWNlTGl0ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KHNlc3Npb25wYXJ0LFxuICAgICAgICAgICAgICAgICdhPWljZS1saXRlJykubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICAgICAgICAgIHZhciB0cmFuc2NlaXZlciA9IHNlbGYudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdO1xuICAgICAgICAgICAgICB2YXIgaWNlR2F0aGVyZXIgPSB0cmFuc2NlaXZlci5pY2VHYXRoZXJlcjtcbiAgICAgICAgICAgICAgdmFyIGljZVRyYW5zcG9ydCA9IHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydDtcbiAgICAgICAgICAgICAgdmFyIGR0bHNUcmFuc3BvcnQgPSB0cmFuc2NlaXZlci5kdGxzVHJhbnNwb3J0O1xuICAgICAgICAgICAgICB2YXIgbG9jYWxDYXBhYmlsaXRpZXMgPSB0cmFuc2NlaXZlci5sb2NhbENhcGFiaWxpdGllcztcbiAgICAgICAgICAgICAgdmFyIHJlbW90ZUNhcGFiaWxpdGllcyA9IHRyYW5zY2VpdmVyLnJlbW90ZUNhcGFiaWxpdGllcztcblxuICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWQgPSBtZWRpYVNlY3Rpb24uc3BsaXQoJ1xcbicsIDEpWzBdXG4gICAgICAgICAgICAgICAgICAuc3BsaXQoJyAnLCAyKVsxXSA9PT0gJzAnO1xuXG4gICAgICAgICAgICAgIGlmICghcmVqZWN0ZWQgJiYgIXRyYW5zY2VpdmVyLmlzRGF0YWNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3RlSWNlUGFyYW1ldGVycyA9IFNEUFV0aWxzLmdldEljZVBhcmFtZXRlcnMoXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ljZUxpdGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjYW5kcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9Y2FuZGlkYXRlOicpXG4gICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGNhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlKGNhbmQpO1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oY2FuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FuZC5jb21wb25lbnQgPT09ICcxJztcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgLy8gaWNlLWxpdGUgb25seSBpbmNsdWRlcyBob3N0IGNhbmRpZGF0ZXMgaW4gdGhlIFNEUCBzbyB3ZSBjYW5cbiAgICAgICAgICAgICAgICAgIC8vIHVzZSBzZXRSZW1vdGVDYW5kaWRhdGVzICh3aGljaCBpbXBsaWVzIGFuXG4gICAgICAgICAgICAgICAgICAvLyBSVENJY2VDYW5kaWRhdGVDb21wbGV0ZSlcbiAgICAgICAgICAgICAgICAgIGlmIChjYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWNlVHJhbnNwb3J0LnNldFJlbW90ZUNhbmRpZGF0ZXMoY2FuZHMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVtb3RlRHRsc1BhcmFtZXRlcnMgPSBTRFBVdGlscy5nZXREdGxzUGFyYW1ldGVycyhcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzSWNlTGl0ZSkge1xuICAgICAgICAgICAgICAgICAgcmVtb3RlRHRsc1BhcmFtZXRlcnMucm9sZSA9ICdzZXJ2ZXInO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghc2VsZi51c2luZ0J1bmRsZSB8fCBzZHBNTGluZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBpY2VUcmFuc3BvcnQuc3RhcnQoaWNlR2F0aGVyZXIsIHJlbW90ZUljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgaXNJY2VMaXRlID8gJ2NvbnRyb2xsaW5nJyA6ICdjb250cm9sbGVkJyk7XG4gICAgICAgICAgICAgICAgICBkdGxzVHJhbnNwb3J0LnN0YXJ0KHJlbW90ZUR0bHNQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIG9mIGNhcGFiaWxpdGllcy5cbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gc2VsZi5fZ2V0Q29tbW9uQ2FwYWJpbGl0aWVzKGxvY2FsQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVDYXBhYmlsaXRpZXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIFJUQ1J0cFNlbmRlci4gVGhlIFJUQ1J0cFJlY2VpdmVyIGZvciB0aGlzXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNjZWl2ZXIgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkIGluIHNldFJlbW90ZURlc2NyaXB0aW9uLlxuICAgICAgICAgICAgICAgIHNlbGYuX3RyYW5zY2VpdmUodHJhbnNjZWl2ZXIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jb2RlY3MubGVuZ3RoID4gMCxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmxvY2FsRGVzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxuICAgICAgICAgICAgc2RwOiBkZXNjcmlwdGlvbi5zZHBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHN3aXRjaCAoZGVzY3JpcHRpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnb2ZmZXInOlxuICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTaWduYWxpbmdTdGF0ZSgnaGF2ZS1sb2NhbC1vZmZlcicpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Fuc3dlcic6XG4gICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlKCdzdGFibGUnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnN1cHBvcnRlZCB0eXBlIFwiJyArIGRlc2NyaXB0aW9uLnR5cGUgK1xuICAgICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgYSBzdWNjZXNzIGNhbGxiYWNrIHdhcyBwcm92aWRlZCwgZW1pdCBJQ0UgY2FuZGlkYXRlcyBhZnRlciBpdFxuICAgICAgICAgIC8vIGhhcyBiZWVuIGV4ZWN1dGVkLiBPdGhlcndpc2UsIGVtaXQgY2FsbGJhY2sgYWZ0ZXIgdGhlIFByb21pc2UgaXNcbiAgICAgICAgICAvLyByZXNvbHZlZC5cbiAgICAgICAgICB2YXIgaGFzQ2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBjYiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICBpZiAoc2VsZi5pY2VHYXRoZXJpbmdTdGF0ZSA9PT0gJ25ldycpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmljZUdhdGhlcmluZ1N0YXRlID0gJ2dhdGhlcmluZyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VsZi5fZW1pdEJ1ZmZlcmVkQ2FuZGlkYXRlcygpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgcC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCFoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICBpZiAoc2VsZi5pY2VHYXRoZXJpbmdTdGF0ZSA9PT0gJ25ldycpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmljZUdhdGhlcmluZ1N0YXRlID0gJ2dhdGhlcmluZyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVXN1YWxseSBjYW5kaWRhdGVzIHdpbGwgYmUgZW1pdHRlZCBlYXJsaWVyLlxuICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChzZWxmLl9lbWl0QnVmZmVyZWRDYW5kaWRhdGVzLmJpbmQoc2VsZiksIDUwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICAgICAgZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAgIHZhciByZWNlaXZlckxpc3QgPSBbXTtcbiAgICAgICAgICB2YXIgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGRlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgICAgdmFyIHNlc3Npb25wYXJ0ID0gc2VjdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICB2YXIgaXNJY2VMaXRlID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoc2Vzc2lvbnBhcnQsXG4gICAgICAgICAgICAgICdhPWljZS1saXRlJykubGVuZ3RoID4gMDtcbiAgICAgICAgICB0aGlzLnVzaW5nQnVuZGxlID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoc2Vzc2lvbnBhcnQsXG4gICAgICAgICAgICAgICdhPWdyb3VwOkJVTkRMRSAnKS5sZW5ndGggPiAwO1xuICAgICAgICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gICAgICAgICAgICB2YXIgbWxpbmUgPSBsaW5lc1swXS5zdWJzdHIoMikuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIHZhciBraW5kID0gbWxpbmVbMF07XG4gICAgICAgICAgICB2YXIgcmVqZWN0ZWQgPSBtbGluZVsxXSA9PT0gJzAnO1xuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IFNEUFV0aWxzLmdldERpcmVjdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KTtcblxuICAgICAgICAgICAgdmFyIG1pZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWlkOicpO1xuICAgICAgICAgICAgaWYgKG1pZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbWlkID0gbWlkWzBdLnN1YnN0cig2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1pZCA9IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWplY3QgZGF0YWNoYW5uZWxzIHdoaWNoIGFyZSBub3QgaW1wbGVtZW50ZWQgeWV0LlxuICAgICAgICAgICAgaWYgKGtpbmQgPT09ICdhcHBsaWNhdGlvbicgJiYgbWxpbmVbMl0gPT09ICdEVExTL1NDVFAnKSB7XG4gICAgICAgICAgICAgIHNlbGYudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdID0ge1xuICAgICAgICAgICAgICAgIG1pZDogbWlkLFxuICAgICAgICAgICAgICAgIGlzRGF0YWNoYW5uZWw6IHRydWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdHJhbnNjZWl2ZXI7XG4gICAgICAgICAgICB2YXIgaWNlR2F0aGVyZXI7XG4gICAgICAgICAgICB2YXIgaWNlVHJhbnNwb3J0O1xuICAgICAgICAgICAgdmFyIGR0bHNUcmFuc3BvcnQ7XG4gICAgICAgICAgICB2YXIgcnRwU2VuZGVyO1xuICAgICAgICAgICAgdmFyIHJ0cFJlY2VpdmVyO1xuICAgICAgICAgICAgdmFyIHNlbmRFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICAgICAgICB2YXIgcmVjdkVuY29kaW5nUGFyYW1ldGVycztcbiAgICAgICAgICAgIHZhciBsb2NhbENhcGFiaWxpdGllcztcblxuICAgICAgICAgICAgdmFyIHRyYWNrO1xuICAgICAgICAgICAgLy8gRklYTUU6IGVuc3VyZSB0aGUgbWVkaWFTZWN0aW9uIGhhcyBydGNwLW11eCBzZXQuXG4gICAgICAgICAgICB2YXIgcmVtb3RlQ2FwYWJpbGl0aWVzID0gU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG4gICAgICAgICAgICB2YXIgcmVtb3RlSWNlUGFyYW1ldGVycztcbiAgICAgICAgICAgIHZhciByZW1vdGVEdGxzUGFyYW1ldGVycztcbiAgICAgICAgICAgIGlmICghcmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgcmVtb3RlSWNlUGFyYW1ldGVycyA9IFNEUFV0aWxzLmdldEljZVBhcmFtZXRlcnMobWVkaWFTZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgc2Vzc2lvbnBhcnQpO1xuICAgICAgICAgICAgICByZW1vdGVEdGxzUGFyYW1ldGVycyA9IFNEUFV0aWxzLmdldER0bHNQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbixcbiAgICAgICAgICAgICAgICAgIHNlc3Npb25wYXJ0KTtcbiAgICAgICAgICAgICAgcmVtb3RlRHRsc1BhcmFtZXRlcnMucm9sZSA9ICdjbGllbnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjdkVuY29kaW5nUGFyYW1ldGVycyA9XG4gICAgICAgICAgICAgICAgU0RQVXRpbHMucGFyc2VSdHBFbmNvZGluZ1BhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcblxuICAgICAgICAgICAgdmFyIGNuYW1lO1xuICAgICAgICAgICAgLy8gR2V0cyB0aGUgZmlyc3QgU1NSQy4gTm90ZSB0aGF0IHdpdGggUlRYIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlXG4gICAgICAgICAgICAvLyBTU1JDcy5cbiAgICAgICAgICAgIHZhciByZW1vdGVTc3JjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5hdHRyaWJ1dGUgPT09ICdjbmFtZSc7XG4gICAgICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICBpZiAocmVtb3RlU3NyYykge1xuICAgICAgICAgICAgICBjbmFtZSA9IHJlbW90ZVNzcmMudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpc0NvbXBsZXRlID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLFxuICAgICAgICAgICAgICAgICdhPWVuZC1vZi1jYW5kaWRhdGVzJywgc2Vzc2lvbnBhcnQpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB2YXIgY2FuZHMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPWNhbmRpZGF0ZTonKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oY2FuZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlKGNhbmQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihjYW5kKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FuZC5jb21wb25lbnQgPT09ICcxJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnb2ZmZXInICYmICFyZWplY3RlZCkge1xuICAgICAgICAgICAgICB2YXIgdHJhbnNwb3J0cyA9IHNlbGYudXNpbmdCdW5kbGUgJiYgc2RwTUxpbmVJbmRleCA+IDAgPyB7XG4gICAgICAgICAgICAgICAgaWNlR2F0aGVyZXI6IHNlbGYudHJhbnNjZWl2ZXJzWzBdLmljZUdhdGhlcmVyLFxuICAgICAgICAgICAgICAgIGljZVRyYW5zcG9ydDogc2VsZi50cmFuc2NlaXZlcnNbMF0uaWNlVHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgIGR0bHNUcmFuc3BvcnQ6IHNlbGYudHJhbnNjZWl2ZXJzWzBdLmR0bHNUcmFuc3BvcnRcbiAgICAgICAgICAgICAgfSA6IHNlbGYuX2NyZWF0ZUljZUFuZER0bHNUcmFuc3BvcnRzKG1pZCwgc2RwTUxpbmVJbmRleCk7XG5cbiAgICAgICAgICAgICAgaWYgKGlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRzLmljZVRyYW5zcG9ydC5zZXRSZW1vdGVDYW5kaWRhdGVzKGNhbmRzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzID0gUlRDUnRwUmVjZWl2ZXIuZ2V0Q2FwYWJpbGl0aWVzKGtpbmQpO1xuXG4gICAgICAgICAgICAgIC8vIGZpbHRlciBSVFggdW50aWwgYWRkaXRpb25hbCBzdHVmZiBuZWVkZWQgZm9yIFJUWCBpcyBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgICAvLyBpbiBhZGFwdGVyLmpzXG4gICAgICAgICAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzLmNvZGVjcyA9IGxvY2FsQ2FwYWJpbGl0aWVzLmNvZGVjcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbihjb2RlYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWMubmFtZSAhPT0gJ3J0eCc7XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzID0gW3tcbiAgICAgICAgICAgICAgICBzc3JjOiAoMiAqIHNkcE1MaW5lSW5kZXggKyAyKSAqIDEwMDFcbiAgICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgICAgcnRwUmVjZWl2ZXIgPSBuZXcgUlRDUnRwUmVjZWl2ZXIodHJhbnNwb3J0cy5kdGxzVHJhbnNwb3J0LCBraW5kKTtcblxuICAgICAgICAgICAgICB0cmFjayA9IHJ0cFJlY2VpdmVyLnRyYWNrO1xuICAgICAgICAgICAgICByZWNlaXZlckxpc3QucHVzaChbdHJhY2ssIHJ0cFJlY2VpdmVyXSk7XG4gICAgICAgICAgICAgIC8vIEZJWE1FOiBub3QgY29ycmVjdCB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBzdHJlYW1zIGJ1dCB0aGF0IGlzXG4gICAgICAgICAgICAgIC8vIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGluIHRoaXMgc2hpbS5cbiAgICAgICAgICAgICAgc3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcblxuICAgICAgICAgICAgICAvLyBGSVhNRTogbG9vayBhdCBkaXJlY3Rpb24uXG4gICAgICAgICAgICAgIGlmIChzZWxmLmxvY2FsU3RyZWFtcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICBzZWxmLmxvY2FsU3RyZWFtc1swXS5nZXRUcmFja3MoKS5sZW5ndGggPj0gc2RwTUxpbmVJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbFRyYWNrO1xuICAgICAgICAgICAgICAgIGlmIChraW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAgICAgICBsb2NhbFRyYWNrID0gc2VsZi5sb2NhbFN0cmVhbXNbMF0uZ2V0QXVkaW9UcmFja3MoKVswXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtpbmQgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICAgICAgICAgIGxvY2FsVHJhY2sgPSBzZWxmLmxvY2FsU3RyZWFtc1swXS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobG9jYWxUcmFjaykge1xuICAgICAgICAgICAgICAgICAgcnRwU2VuZGVyID0gbmV3IFJUQ1J0cFNlbmRlcihsb2NhbFRyYWNrLFxuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydHMuZHRsc1RyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2VsZi50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgaWNlR2F0aGVyZXI6IHRyYW5zcG9ydHMuaWNlR2F0aGVyZXIsXG4gICAgICAgICAgICAgICAgaWNlVHJhbnNwb3J0OiB0cmFuc3BvcnRzLmljZVRyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICBkdGxzVHJhbnNwb3J0OiB0cmFuc3BvcnRzLmR0bHNUcmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXM6IGxvY2FsQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgICAgIHJlbW90ZUNhcGFiaWxpdGllczogcmVtb3RlQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgICAgIHJ0cFNlbmRlcjogcnRwU2VuZGVyLFxuICAgICAgICAgICAgICAgIHJ0cFJlY2VpdmVyOiBydHBSZWNlaXZlcixcbiAgICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICAgIG1pZDogbWlkLFxuICAgICAgICAgICAgICAgIGNuYW1lOiBjbmFtZSxcbiAgICAgICAgICAgICAgICBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzOiBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHJlY3ZFbmNvZGluZ1BhcmFtZXRlcnM6IHJlY3ZFbmNvZGluZ1BhcmFtZXRlcnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIFJUQ1J0cFJlY2VpdmVyIG5vdy4gVGhlIFJUUFNlbmRlciBpcyBzdGFydGVkIGluXG4gICAgICAgICAgICAgIC8vIHNldExvY2FsRGVzY3JpcHRpb24uXG4gICAgICAgICAgICAgIHNlbGYuX3RyYW5zY2VpdmUoc2VsZi50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0sXG4gICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2JyB8fCBkaXJlY3Rpb24gPT09ICdzZW5kb25seScpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnYW5zd2VyJyAmJiAhcmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIgPSBzZWxmLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XTtcbiAgICAgICAgICAgICAgaWNlR2F0aGVyZXIgPSB0cmFuc2NlaXZlci5pY2VHYXRoZXJlcjtcbiAgICAgICAgICAgICAgaWNlVHJhbnNwb3J0ID0gdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0O1xuICAgICAgICAgICAgICBkdGxzVHJhbnNwb3J0ID0gdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydDtcbiAgICAgICAgICAgICAgcnRwU2VuZGVyID0gdHJhbnNjZWl2ZXIucnRwU2VuZGVyO1xuICAgICAgICAgICAgICBydHBSZWNlaXZlciA9IHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyO1xuICAgICAgICAgICAgICBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVycztcbiAgICAgICAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXMgPSB0cmFuc2NlaXZlci5sb2NhbENhcGFiaWxpdGllcztcblxuICAgICAgICAgICAgICBzZWxmLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5yZWN2RW5jb2RpbmdQYXJhbWV0ZXJzID1cbiAgICAgICAgICAgICAgICAgIHJlY3ZFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICAgICAgICAgIHNlbGYudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLnJlbW90ZUNhcGFiaWxpdGllcyA9XG4gICAgICAgICAgICAgICAgICByZW1vdGVDYXBhYmlsaXRpZXM7XG4gICAgICAgICAgICAgIHNlbGYudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLmNuYW1lID0gY25hbWU7XG5cbiAgICAgICAgICAgICAgaWYgKChpc0ljZUxpdGUgfHwgaXNDb21wbGV0ZSkgJiYgY2FuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWNlVHJhbnNwb3J0LnNldFJlbW90ZUNhbmRpZGF0ZXMoY2FuZHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghc2VsZi51c2luZ0J1bmRsZSB8fCBzZHBNTGluZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWNlVHJhbnNwb3J0LnN0YXJ0KGljZUdhdGhlcmVyLCByZW1vdGVJY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgICAgICAnY29udHJvbGxpbmcnKTtcbiAgICAgICAgICAgICAgICBkdGxzVHJhbnNwb3J0LnN0YXJ0KHJlbW90ZUR0bHNQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNlbGYuX3RyYW5zY2VpdmUodHJhbnNjZWl2ZXIsXG4gICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09ICdzZW5kcmVjdicgfHwgZGlyZWN0aW9uID09PSAncmVjdm9ubHknLFxuICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnIHx8IGRpcmVjdGlvbiA9PT0gJ3NlbmRvbmx5Jyk7XG5cbiAgICAgICAgICAgICAgaWYgKHJ0cFJlY2VpdmVyICYmXG4gICAgICAgICAgICAgICAgICAoZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnIHx8IGRpcmVjdGlvbiA9PT0gJ3NlbmRvbmx5JykpIHtcbiAgICAgICAgICAgICAgICB0cmFjayA9IHJ0cFJlY2VpdmVyLnRyYWNrO1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyTGlzdC5wdXNoKFt0cmFjaywgcnRwUmVjZWl2ZXJdKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBhY3R1YWxseSB0aGUgcmVjZWl2ZXIgc2hvdWxkIGJlIGNyZWF0ZWQgbGF0ZXIuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLnJlbW90ZURlc2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgICAgICAgIHNkcDogZGVzY3JpcHRpb24uc2RwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBzd2l0Y2ggKGRlc2NyaXB0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ29mZmVyJzpcbiAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2lnbmFsaW5nU3RhdGUoJ2hhdmUtcmVtb3RlLW9mZmVyJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYW5zd2VyJzpcbiAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2lnbmFsaW5nU3RhdGUoJ3N0YWJsZScpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Vuc3VwcG9ydGVkIHR5cGUgXCInICsgZGVzY3JpcHRpb24udHlwZSArXG4gICAgICAgICAgICAgICAgICAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3RlU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdhZGRzdHJlYW0nKTtcbiAgICAgICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICBpZiAoc2VsZi5vbmFkZHN0cmVhbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgc2VsZi5vbmFkZHN0cmVhbShldmVudCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZWNlaXZlckxpc3QuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gaXRlbVswXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBpdGVtWzFdO1xuICAgICAgICAgICAgICAgIHZhciB0cmFja0V2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgICAgIHRyYWNrRXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAgICAgICB0cmFja0V2ZW50LnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgICAgICAgdHJhY2tFdmVudC5zdHJlYW1zID0gW3N0cmVhbV07XG4gICAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vbnRyYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbnRyYWNrKHRyYWNrRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoYXJndW1lbnRzWzFdLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50cmFuc2NlaXZlcnMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICAvKiBub3QgeWV0XG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5pY2VHYXRoZXJlcikge1xuICAgICAgICAgIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydCkge1xuICAgICAgICAgIHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQpIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci5kdGxzVHJhbnNwb3J0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIucnRwU2VuZGVyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIpIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci5ydHBSZWNlaXZlci5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gRklYTUU6IGNsZWFuIHVwIHRyYWNrcywgbG9jYWwgc3RyZWFtcywgcmVtb3RlIHN0cmVhbXMsIGV0Y1xuICAgICAgdGhpcy5fdXBkYXRlU2lnbmFsaW5nU3RhdGUoJ2Nsb3NlZCcpO1xuICAgIH07XG5cbiAgICAvLyBVcGRhdGUgdGhlIHNpZ25hbGluZyBzdGF0ZS5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl91cGRhdGVTaWduYWxpbmdTdGF0ZSA9XG4gICAgICAgIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgICAgdGhpcy5zaWduYWxpbmdTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnc2lnbmFsaW5nc3RhdGVjaGFuZ2UnKTtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIGlmICh0aGlzLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMub25zaWduYWxpbmdzdGF0ZWNoYW5nZShldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdG8gZmlyZSB0aGUgbmVnb3RpYXRpb25uZWVkZWQgZXZlbnQuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fbWF5YmVGaXJlTmVnb3RpYXRpb25OZWVkZWQgPVxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBGaXJlIGF3YXkgKGZvciBub3cpLlxuICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnKTtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIGlmICh0aGlzLm9ubmVnb3RpYXRpb25uZWVkZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMub25uZWdvdGlhdGlvbm5lZWRlZChldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgLy8gVXBkYXRlIHRoZSBjb25uZWN0aW9uIHN0YXRlLlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3VwZGF0ZUNvbm5lY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIG5ld1N0YXRlO1xuICAgICAgdmFyIHN0YXRlcyA9IHtcbiAgICAgICAgJ25ldyc6IDAsXG4gICAgICAgIGNsb3NlZDogMCxcbiAgICAgICAgY29ubmVjdGluZzogMCxcbiAgICAgICAgY2hlY2tpbmc6IDAsXG4gICAgICAgIGNvbm5lY3RlZDogMCxcbiAgICAgICAgY29tcGxldGVkOiAwLFxuICAgICAgICBmYWlsZWQ6IDBcbiAgICAgIH07XG4gICAgICB0aGlzLnRyYW5zY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHN0YXRlc1t0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQuc3RhdGVdKys7XG4gICAgICAgIHN0YXRlc1t0cmFuc2NlaXZlci5kdGxzVHJhbnNwb3J0LnN0YXRlXSsrO1xuICAgICAgfSk7XG4gICAgICAvLyBJQ0VUcmFuc3BvcnQuY29tcGxldGVkIGFuZCBjb25uZWN0ZWQgYXJlIHRoZSBzYW1lIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICBzdGF0ZXMuY29ubmVjdGVkICs9IHN0YXRlcy5jb21wbGV0ZWQ7XG5cbiAgICAgIG5ld1N0YXRlID0gJ25ldyc7XG4gICAgICBpZiAoc3RhdGVzLmZhaWxlZCA+IDApIHtcbiAgICAgICAgbmV3U3RhdGUgPSAnZmFpbGVkJztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGVzLmNvbm5lY3RpbmcgPiAwIHx8IHN0YXRlcy5jaGVja2luZyA+IDApIHtcbiAgICAgICAgbmV3U3RhdGUgPSAnY29ubmVjdGluZyc7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlcy5kaXNjb25uZWN0ZWQgPiAwKSB7XG4gICAgICAgIG5ld1N0YXRlID0gJ2Rpc2Nvbm5lY3RlZCc7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlcy5uZXcgPiAwKSB7XG4gICAgICAgIG5ld1N0YXRlID0gJ25ldyc7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlcy5jb25uZWN0ZWQgPiAwIHx8IHN0YXRlcy5jb21wbGV0ZWQgPiAwKSB7XG4gICAgICAgIG5ld1N0YXRlID0gJ2Nvbm5lY3RlZCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdTdGF0ZSAhPT0gc2VsZi5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgc2VsZi5pY2VDb25uZWN0aW9uU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5fcGVuZGluZ09mZmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlT2ZmZXIgY2FsbGVkIHdoaWxlIHRoZXJlIGlzIGEgcGVuZGluZyBvZmZlci4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZlck9wdGlvbnM7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9mZmVyT3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBvZmZlck9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFja3MgPSBbXTtcbiAgICAgIHZhciBudW1BdWRpb1RyYWNrcyA9IDA7XG4gICAgICB2YXIgbnVtVmlkZW9UcmFja3MgPSAwO1xuICAgICAgLy8gRGVmYXVsdCB0byBzZW5kcmVjdi5cbiAgICAgIGlmICh0aGlzLmxvY2FsU3RyZWFtcy5sZW5ndGgpIHtcbiAgICAgICAgbnVtQXVkaW9UcmFja3MgPSB0aGlzLmxvY2FsU3RyZWFtc1swXS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aDtcbiAgICAgICAgbnVtVmlkZW9UcmFja3MgPSB0aGlzLmxvY2FsU3RyZWFtc1swXS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIC8vIERldGVybWluZSBudW1iZXIgb2YgYXVkaW8gYW5kIHZpZGVvIHRyYWNrcyB3ZSBuZWVkIHRvIHNlbmQvcmVjdi5cbiAgICAgIGlmIChvZmZlck9wdGlvbnMpIHtcbiAgICAgICAgLy8gUmVqZWN0IENocm9tZSBsZWdhY3kgY29uc3RyYWludHMuXG4gICAgICAgIGlmIChvZmZlck9wdGlvbnMubWFuZGF0b3J5IHx8IG9mZmVyT3B0aW9ucy5vcHRpb25hbCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICdMZWdhY3kgbWFuZGF0b3J5L29wdGlvbmFsIGNvbnN0cmFpbnRzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1BdWRpb1RyYWNrcyA9IG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtVmlkZW9UcmFja3MgPSBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMubG9jYWxTdHJlYW1zLmxlbmd0aCkge1xuICAgICAgICAvLyBQdXNoIGxvY2FsIHN0cmVhbXMuXG4gICAgICAgIHRoaXMubG9jYWxTdHJlYW1zWzBdLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAgICAgICAgICB0cmFja3MucHVzaCh7XG4gICAgICAgICAgICBraW5kOiB0cmFjay5raW5kLFxuICAgICAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICAgICAgd2FudFJlY2VpdmU6IHRyYWNrLmtpbmQgPT09ICdhdWRpbycgP1xuICAgICAgICAgICAgICAgIG51bUF1ZGlvVHJhY2tzID4gMCA6IG51bVZpZGVvVHJhY2tzID4gMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICBudW1BdWRpb1RyYWNrcy0tO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgbnVtVmlkZW9UcmFja3MtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gQ3JlYXRlIE0tbGluZXMgZm9yIHJlY3Zvbmx5IHN0cmVhbXMuXG4gICAgICB3aGlsZSAobnVtQXVkaW9UcmFja3MgPiAwIHx8IG51bVZpZGVvVHJhY2tzID4gMCkge1xuICAgICAgICBpZiAobnVtQXVkaW9UcmFja3MgPiAwKSB7XG4gICAgICAgICAgdHJhY2tzLnB1c2goe1xuICAgICAgICAgICAga2luZDogJ2F1ZGlvJyxcbiAgICAgICAgICAgIHdhbnRSZWNlaXZlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbnVtQXVkaW9UcmFja3MtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtVmlkZW9UcmFja3MgPiAwKSB7XG4gICAgICAgICAgdHJhY2tzLnB1c2goe1xuICAgICAgICAgICAga2luZDogJ3ZpZGVvJyxcbiAgICAgICAgICAgIHdhbnRSZWNlaXZlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbnVtVmlkZW9UcmFja3MtLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc2RwID0gU0RQVXRpbHMud3JpdGVTZXNzaW9uQm9pbGVycGxhdGUoKTtcbiAgICAgIHZhciB0cmFuc2NlaXZlcnMgPSBbXTtcbiAgICAgIHRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKG1saW5lLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICAgIC8vIEZvciBlYWNoIHRyYWNrLCBjcmVhdGUgYW4gaWNlIGdhdGhlcmVyLCBpY2UgdHJhbnNwb3J0LFxuICAgICAgICAvLyBkdGxzIHRyYW5zcG9ydCwgcG90ZW50aWFsbHkgcnRwc2VuZGVyIGFuZCBydHByZWNlaXZlci5cbiAgICAgICAgdmFyIHRyYWNrID0gbWxpbmUudHJhY2s7XG4gICAgICAgIHZhciBraW5kID0gbWxpbmUua2luZDtcbiAgICAgICAgdmFyIG1pZCA9IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuXG4gICAgICAgIHZhciB0cmFuc3BvcnRzID0gc2VsZi51c2luZ0J1bmRsZSAmJiBzZHBNTGluZUluZGV4ID4gMCA/IHtcbiAgICAgICAgICBpY2VHYXRoZXJlcjogdHJhbnNjZWl2ZXJzWzBdLmljZUdhdGhlcmVyLFxuICAgICAgICAgIGljZVRyYW5zcG9ydDogdHJhbnNjZWl2ZXJzWzBdLmljZVRyYW5zcG9ydCxcbiAgICAgICAgICBkdGxzVHJhbnNwb3J0OiB0cmFuc2NlaXZlcnNbMF0uZHRsc1RyYW5zcG9ydFxuICAgICAgICB9IDogc2VsZi5fY3JlYXRlSWNlQW5kRHRsc1RyYW5zcG9ydHMobWlkLCBzZHBNTGluZUluZGV4KTtcblxuICAgICAgICB2YXIgbG9jYWxDYXBhYmlsaXRpZXMgPSBSVENSdHBTZW5kZXIuZ2V0Q2FwYWJpbGl0aWVzKGtpbmQpO1xuICAgICAgICAvLyBmaWx0ZXIgUlRYIHVudGlsIGFkZGl0aW9uYWwgc3R1ZmYgbmVlZGVkIGZvciBSVFggaXMgaW1wbGVtZW50ZWRcbiAgICAgICAgLy8gaW4gYWRhcHRlci5qc1xuICAgICAgICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MgPSBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MuZmlsdGVyKFxuICAgICAgICAgICAgZnVuY3Rpb24oY29kZWMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvZGVjLm5hbWUgIT09ICdydHgnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzLmNvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgICAgICAgLy8gd29yayBhcm91bmQgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTY1NTJcbiAgICAgICAgICAvLyBieSBhZGRpbmcgbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ9MVxuICAgICAgICAgIGlmIChjb2RlYy5uYW1lID09PSAnSDI2NCcgJiZcbiAgICAgICAgICAgICAgY29kZWMucGFyYW1ldGVyc1snbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2RlYy5wYXJhbWV0ZXJzWydsZXZlbC1hc3ltbWV0cnktYWxsb3dlZCddID0gJzEnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJ0cFNlbmRlcjtcbiAgICAgICAgdmFyIHJ0cFJlY2VpdmVyO1xuXG4gICAgICAgIC8vIGdlbmVyYXRlIGFuIHNzcmMgbm93LCB0byBiZSB1c2VkIGxhdGVyIGluIHJ0cFNlbmRlci5zZW5kXG4gICAgICAgIHZhciBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzID0gW3tcbiAgICAgICAgICBzc3JjOiAoMiAqIHNkcE1MaW5lSW5kZXggKyAxKSAqIDEwMDFcbiAgICAgICAgfV07XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgIHJ0cFNlbmRlciA9IG5ldyBSVENSdHBTZW5kZXIodHJhY2ssIHRyYW5zcG9ydHMuZHRsc1RyYW5zcG9ydCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWxpbmUud2FudFJlY2VpdmUpIHtcbiAgICAgICAgICBydHBSZWNlaXZlciA9IG5ldyBSVENSdHBSZWNlaXZlcih0cmFuc3BvcnRzLmR0bHNUcmFuc3BvcnQsIGtpbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdID0ge1xuICAgICAgICAgIGljZUdhdGhlcmVyOiB0cmFuc3BvcnRzLmljZUdhdGhlcmVyLFxuICAgICAgICAgIGljZVRyYW5zcG9ydDogdHJhbnNwb3J0cy5pY2VUcmFuc3BvcnQsXG4gICAgICAgICAgZHRsc1RyYW5zcG9ydDogdHJhbnNwb3J0cy5kdGxzVHJhbnNwb3J0LFxuICAgICAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzOiBsb2NhbENhcGFiaWxpdGllcyxcbiAgICAgICAgICByZW1vdGVDYXBhYmlsaXRpZXM6IG51bGwsXG4gICAgICAgICAgcnRwU2VuZGVyOiBydHBTZW5kZXIsXG4gICAgICAgICAgcnRwUmVjZWl2ZXI6IHJ0cFJlY2VpdmVyLFxuICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgbWlkOiBtaWQsXG4gICAgICAgICAgc2VuZEVuY29kaW5nUGFyYW1ldGVyczogc2VuZEVuY29kaW5nUGFyYW1ldGVycyxcbiAgICAgICAgICByZWN2RW5jb2RpbmdQYXJhbWV0ZXJzOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnVzaW5nQnVuZGxlKSB7XG4gICAgICAgIHNkcCArPSAnYT1ncm91cDpCVU5ETEUgJyArIHRyYW5zY2VpdmVycy5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgICAgIHJldHVybiB0Lm1pZDtcbiAgICAgICAgfSkuam9pbignICcpICsgJ1xcclxcbic7XG4gICAgICB9XG4gICAgICB0cmFja3MuZm9yRWFjaChmdW5jdGlvbihtbGluZSwgc2RwTUxpbmVJbmRleCkge1xuICAgICAgICB2YXIgdHJhbnNjZWl2ZXIgPSB0cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF07XG4gICAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlcixcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLmxvY2FsQ2FwYWJpbGl0aWVzLCAnb2ZmZXInLCBzZWxmLmxvY2FsU3RyZWFtc1swXSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fcGVuZGluZ09mZmVyID0gdHJhbnNjZWl2ZXJzO1xuICAgICAgdmFyIGRlc2MgPSBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgdHlwZTogJ29mZmVyJyxcbiAgICAgICAgc2RwOiBzZHBcbiAgICAgIH0pO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChhcmd1bWVudHNbMF0sIDAsIGRlc2MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZXNjKTtcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgdmFyIHNkcCA9IFNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlKCk7XG4gICAgICBpZiAodGhpcy51c2luZ0J1bmRsZSkge1xuICAgICAgICBzZHAgKz0gJ2E9Z3JvdXA6QlVORExFICcgKyB0aGlzLnRyYW5zY2VpdmVycy5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgICAgIHJldHVybiB0Lm1pZDtcbiAgICAgICAgfSkuam9pbignICcpICsgJ1xcclxcbic7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5pc0RhdGFjaGFubmVsKSB7XG4gICAgICAgICAgc2RwICs9ICdtPWFwcGxpY2F0aW9uIDAgRFRMUy9TQ1RQIDUwMDBcXHJcXG4nICtcbiAgICAgICAgICAgICAgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nICtcbiAgICAgICAgICAgICAgJ2E9bWlkOicgKyB0cmFuc2NlaXZlci5taWQgKyAnXFxyXFxuJztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbiBvZiBjYXBhYmlsaXRpZXMuXG4gICAgICAgIHZhciBjb21tb25DYXBhYmlsaXRpZXMgPSBzZWxmLl9nZXRDb21tb25DYXBhYmlsaXRpZXMoXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5sb2NhbENhcGFiaWxpdGllcyxcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlbW90ZUNhcGFiaWxpdGllcyk7XG5cbiAgICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLCBjb21tb25DYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICAnYW5zd2VyJywgc2VsZi5sb2NhbFN0cmVhbXNbMF0pO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBkZXNjID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgIHR5cGU6ICdhbnN3ZXInLFxuICAgICAgICBzZHA6IHNkcFxuICAgICAgfSk7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGFyZ3VtZW50c1swXSwgMCwgZGVzYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRlc2MpO1xuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGNhbmRpZGF0ZSkge1xuICAgICAgaWYgKCFjYW5kaWRhdGUpIHtcbiAgICAgICAgdGhpcy50cmFuc2NlaXZlcnMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICAgIHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoe30pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtTGluZUluZGV4ID0gY2FuZGlkYXRlLnNkcE1MaW5lSW5kZXg7XG4gICAgICAgIGlmIChjYW5kaWRhdGUuc2RwTWlkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYW5zY2VpdmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNjZWl2ZXJzW2ldLm1pZCA9PT0gY2FuZGlkYXRlLnNkcE1pZCkge1xuICAgICAgICAgICAgICBtTGluZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2NlaXZlciA9IHRoaXMudHJhbnNjZWl2ZXJzW21MaW5lSW5kZXhdO1xuICAgICAgICBpZiAodHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICB2YXIgY2FuZCA9IE9iamVjdC5rZXlzKGNhbmRpZGF0ZS5jYW5kaWRhdGUpLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShjYW5kaWRhdGUuY2FuZGlkYXRlKSA6IHt9O1xuICAgICAgICAgIC8vIElnbm9yZSBDaHJvbWUncyBpbnZhbGlkIGNhbmRpZGF0ZXMgc2luY2UgRWRnZSBkb2VzIG5vdCBsaWtlIHRoZW0uXG4gICAgICAgICAgaWYgKGNhbmQucHJvdG9jb2wgPT09ICd0Y3AnICYmIChjYW5kLnBvcnQgPT09IDAgfHwgY2FuZC5wb3J0ID09PSA5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZ25vcmUgUlRDUCBjYW5kaWRhdGVzLCB3ZSBhc3N1bWUgUlRDUC1NVVguXG4gICAgICAgICAgaWYgKGNhbmQuY29tcG9uZW50ICE9PSAnMScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQSBkaXJ0eSBoYWNrIHRvIG1ha2Ugc2FtcGxlcyB3b3JrLlxuICAgICAgICAgIGlmIChjYW5kLnR5cGUgPT09ICdlbmRPZkNhbmRpZGF0ZXMnKSB7XG4gICAgICAgICAgICBjYW5kID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoY2FuZCk7XG5cbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIHJlbW90ZURlc2NyaXB0aW9uLlxuICAgICAgICAgIHZhciBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnModGhpcy5yZW1vdGVEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAgIHNlY3Rpb25zW21MaW5lSW5kZXggKyAxXSArPSAoY2FuZC50eXBlID8gY2FuZGlkYXRlLmNhbmRpZGF0ZS50cmltKClcbiAgICAgICAgICAgICAgOiAnYT1lbmQtb2YtY2FuZGlkYXRlcycpICsgJ1xcclxcbic7XG4gICAgICAgICAgdGhpcy5yZW1vdGVEZXNjcmlwdGlvbi5zZHAgPSBzZWN0aW9ucy5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoYXJndW1lbnRzWzFdLCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICB0aGlzLnRyYW5zY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIFsncnRwU2VuZGVyJywgJ3J0cFJlY2VpdmVyJywgJ2ljZUdhdGhlcmVyJywgJ2ljZVRyYW5zcG9ydCcsXG4gICAgICAgICAgICAnZHRsc1RyYW5zcG9ydCddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlclttZXRob2RdKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0cmFuc2NlaXZlclttZXRob2RdLmdldFN0YXRzKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGNiID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgIGFyZ3VtZW50c1sxXTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIC8vIHNoaW0gZ2V0U3RhdHMgd2l0aCBtYXBsaWtlIHN1cHBvcnRcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMuc2V0KGlkLCByZXN1bHRbaWRdKTtcbiAgICAgICAgICAgICAgcmVzdWx0c1tpZF0gPSByZXN1bHRbaWRdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYiwgMCwgcmVzdWx0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufTtcblxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNoaW1QZWVyQ29ubmVjdGlvbjogZWRnZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uLFxuICBzaGltR2V0VXNlck1lZGlhOiByZXF1aXJlKCcuL2dldHVzZXJtZWRpYScpXG59O1xuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4gLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzaGltRXJyb3JfID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB7UGVybWlzc2lvbkRlbmllZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJ31bZS5uYW1lXSB8fCBlLm5hbWUsXG4gICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICBjb25zdHJhaW50OiBlLmNvbnN0cmFpbnQsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBnZXRVc2VyTWVkaWEgZXJyb3Igc2hpbS5cbiAgdmFyIG9yaWdHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5cbiAgICAgIGJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBvcmlnR2V0VXNlck1lZGlhKGMpLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChzaGltRXJyb3JfKGUpKTtcbiAgICB9KTtcbiAgfTtcbn07XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbiAvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGJyb3dzZXJEZXRhaWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5icm93c2VyRGV0YWlscztcblxudmFyIGZpcmVmb3hTaGltID0ge1xuICBzaGltT25UcmFjazogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAhKCdvbnRyYWNrJyBpblxuICAgICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdvbnRyYWNrJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9vbnRyYWNrO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICBpZiAodGhpcy5fb250cmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2spO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbnRyYWNrcG9seSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrID0gZik7XG4gICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbnRyYWNrcG9seSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUuc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgICBldmVudC50cmFjayA9IHRyYWNrO1xuICAgICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHt0cmFjazogdHJhY2t9O1xuICAgICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHNoaW1Tb3VyY2VPYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIC8vIEZpcmVmb3ggaGFzIHN1cHBvcnRlZCBtb3pTcmNPYmplY3Qgc2luY2UgRkYyMiwgdW5wcmVmaXhlZCBpbiA0Mi5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh3aW5kb3cuSFRNTE1lZGlhRWxlbWVudCAmJlxuICAgICAgICAhKCdzcmNPYmplY3QnIGluIHdpbmRvdy5IVE1MTWVkaWFFbGVtZW50LnByb3RvdHlwZSkpIHtcbiAgICAgICAgLy8gU2hpbSB0aGUgc3JjT2JqZWN0IHByb3BlcnR5LCBvbmNlLCB3aGVuIEhUTUxNZWRpYUVsZW1lbnQgaXMgZm91bmQuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuSFRNTE1lZGlhRWxlbWVudC5wcm90b3R5cGUsICdzcmNPYmplY3QnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1velNyY09iamVjdDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLm1velNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBzaGltUGVlckNvbm5lY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fFxuICAgICAgICB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgICByZXR1cm47IC8vIHByb2JhYmx5IG1lZGlhLnBlZXJjb25uZWN0aW9uLmVuYWJsZWQ9ZmFsc2UgaW4gYWJvdXQ6Y29uZmlnXG4gICAgfVxuICAgIC8vIFRoZSBSVENQZWVyQ29ubmVjdGlvbiBvYmplY3QuXG4gICAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKSB7XG4gICAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgMzgpIHtcbiAgICAgICAgICAvLyAudXJscyBpcyBub3Qgc3VwcG9ydGVkIGluIEZGIDwgMzguXG4gICAgICAgICAgLy8gY3JlYXRlIFJUQ0ljZVNlcnZlcnMgd2l0aCBhIHNpbmdsZSB1cmwuXG4gICAgICAgICAgaWYgKHBjQ29uZmlnICYmIHBjQ29uZmlnLmljZVNlcnZlcnMpIHtcbiAgICAgICAgICAgIHZhciBuZXdJY2VTZXJ2ZXJzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBjQ29uZmlnLmljZVNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHNlcnZlciA9IHBjQ29uZmlnLmljZVNlcnZlcnNbaV07XG4gICAgICAgICAgICAgIGlmIChzZXJ2ZXIuaGFzT3duUHJvcGVydHkoJ3VybHMnKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VydmVyLnVybHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBuZXdTZXJ2ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogc2VydmVyLnVybHNbal1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBpZiAoc2VydmVyLnVybHNbal0uaW5kZXhPZigndHVybicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlcnZlci51c2VybmFtZSA9IHNlcnZlci51c2VybmFtZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VydmVyLmNyZWRlbnRpYWwgPSBzZXJ2ZXIuY3JlZGVudGlhbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChuZXdTZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2gocGNDb25maWcuaWNlU2VydmVyc1tpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBjQ29uZmlnLmljZVNlcnZlcnMgPSBuZXdJY2VTZXJ2ZXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IG1velJUQ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKTtcbiAgICAgIH07XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlID0gbW96UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuXG4gICAgICAvLyB3cmFwIHN0YXRpYyBtZXRob2RzLiBDdXJyZW50bHkganVzdCBnZW5lcmF0ZUNlcnRpZmljYXRlLlxuICAgICAgaWYgKG1velJUQ1BlZXJDb25uZWN0aW9uLmdlbmVyYXRlQ2VydGlmaWNhdGUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiwgJ2dlbmVyYXRlQ2VydGlmaWNhdGUnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBtb3pSVENQZWVyQ29ubmVjdGlvbi5nZW5lcmF0ZUNlcnRpZmljYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gPSBtb3pSVENTZXNzaW9uRGVzY3JpcHRpb247XG4gICAgICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlID0gbW96UlRDSWNlQ2FuZGlkYXRlO1xuICAgIH1cblxuICAgIC8vIHNoaW0gYXdheSBuZWVkIGZvciBvYnNvbGV0ZSBSVENJY2VDYW5kaWRhdGUvUlRDU2Vzc2lvbkRlc2NyaXB0aW9uLlxuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICB2YXIgbmF0aXZlTWV0aG9kID0gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICAgICAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAoKG1ldGhvZCA9PT0gJ2FkZEljZUNhbmRpZGF0ZScpID9cbiAgICAgICAgICAgICAgICBSVENJY2VDYW5kaWRhdGUgOiBSVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAvLyBzdXBwb3J0IGZvciBhZGRJY2VDYW5kaWRhdGUobnVsbCBvciB1bmRlZmluZWQpXG4gICAgdmFyIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZSA9XG4gICAgICAgIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGU7XG4gICAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1sxXSkge1xuICAgICAgICAgIGFyZ3VtZW50c1sxXS5hcHBseShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNDgpIHtcbiAgICAgIC8vIHNoaW0gZ2V0U3RhdHMgd2l0aCBtYXBsaWtlIHN1cHBvcnRcbiAgICAgIHZhciBtYWtlTWFwU3RhdHMgPSBmdW5jdGlvbihzdGF0cykge1xuICAgICAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBPYmplY3Qua2V5cyhzdGF0cykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBtYXAuc2V0KGtleSwgc3RhdHNba2V5XSk7XG4gICAgICAgICAgbWFwW2tleV0gPSBzdGF0c1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH07XG5cbiAgICAgIHZhciBuYXRpdmVHZXRTdGF0cyA9IFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgICAgIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBvblN1Y2MsIG9uRXJyKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVHZXRTdGF0cy5hcHBseSh0aGlzLCBbc2VsZWN0b3IgfHwgbnVsbF0pXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24oc3RhdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlTWFwU3RhdHMoc3RhdHMpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4ob25TdWNjLCBvbkVycik7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcblxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNoaW1PblRyYWNrOiBmaXJlZm94U2hpbS5zaGltT25UcmFjayxcbiAgc2hpbVNvdXJjZU9iamVjdDogZmlyZWZveFNoaW0uc2hpbVNvdXJjZU9iamVjdCxcbiAgc2hpbVBlZXJDb25uZWN0aW9uOiBmaXJlZm94U2hpbS5zaGltUGVlckNvbm5lY3Rpb24sXG4gIHNoaW1HZXRVc2VyTWVkaWE6IHJlcXVpcmUoJy4vZ2V0dXNlcm1lZGlhJylcbn07XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbiAvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ2dpbmcgPSByZXF1aXJlKCcuLi91dGlscycpLmxvZztcbnZhciBicm93c2VyRGV0YWlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuYnJvd3NlckRldGFpbHM7XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzaGltRXJyb3JfID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB7XG4gICAgICAgIFNlY3VyaXR5RXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBQZXJtaXNzaW9uRGVuaWVkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InXG4gICAgICB9W2UubmFtZV0gfHwgZS5uYW1lLFxuICAgICAgbWVzc2FnZToge1xuICAgICAgICAnVGhlIG9wZXJhdGlvbiBpcyBpbnNlY3VyZS4nOiAnVGhlIHJlcXVlc3QgaXMgbm90IGFsbG93ZWQgYnkgdGhlICcgK1xuICAgICAgICAndXNlciBhZ2VudCBvciB0aGUgcGxhdGZvcm0gaW4gdGhlIGN1cnJlbnQgY29udGV4dC4nXG4gICAgICB9W2UubWVzc2FnZV0gfHwgZS5tZXNzYWdlLFxuICAgICAgY29uc3RyYWludDogZS5jb25zdHJhaW50LFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgKHRoaXMubWVzc2FnZSAmJiAnOiAnKSArIHRoaXMubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIGdldFVzZXJNZWRpYSBjb25zdHJhaW50cyBzaGltLlxuICB2YXIgZ2V0VXNlck1lZGlhXyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICB2YXIgY29uc3RyYWludHNUb0ZGMzdfID0gZnVuY3Rpb24oYykge1xuICAgICAgaWYgKHR5cGVvZiBjICE9PSAnb2JqZWN0JyB8fCBjLnJlcXVpcmUpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgICB2YXIgcmVxdWlyZSA9IFtdO1xuICAgICAgT2JqZWN0LmtleXMoYykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ3JlcXVpcmUnIHx8IGtleSA9PT0gJ2FkdmFuY2VkJyB8fCBrZXkgPT09ICdtZWRpYVNvdXJjZScpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSBjW2tleV0gPSAodHlwZW9mIGNba2V5XSA9PT0gJ29iamVjdCcpID9cbiAgICAgICAgICAgIGNba2V5XSA6IHtpZGVhbDogY1trZXldfTtcbiAgICAgICAgaWYgKHIubWluICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHIubWF4ICE9PSB1bmRlZmluZWQgfHwgci5leGFjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVxdWlyZS5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIuZXhhY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygci5leGFjdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHIuIG1pbiA9IHIubWF4ID0gci5leGFjdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY1trZXldID0gci5leGFjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHIuZXhhY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIuaWRlYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGMuYWR2YW5jZWQgPSBjLmFkdmFuY2VkIHx8IFtdO1xuICAgICAgICAgIHZhciBvYyA9IHt9O1xuICAgICAgICAgIGlmICh0eXBlb2Ygci5pZGVhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG9jW2tleV0gPSB7bWluOiByLmlkZWFsLCBtYXg6IHIuaWRlYWx9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvY1trZXldID0gci5pZGVhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYy5hZHZhbmNlZC5wdXNoKG9jKTtcbiAgICAgICAgICBkZWxldGUgci5pZGVhbDtcbiAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHIpLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVsZXRlIGNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHJlcXVpcmUubGVuZ3RoKSB7XG4gICAgICAgIGMucmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9O1xuICAgIGNvbnN0cmFpbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgMzgpIHtcbiAgICAgIGxvZ2dpbmcoJ3NwZWM6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgICAgaWYgKGNvbnN0cmFpbnRzLmF1ZGlvKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHNUb0ZGMzdfKGNvbnN0cmFpbnRzLmF1ZGlvKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25zdHJhaW50cy52aWRlbykge1xuICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9GRjM3Xyhjb25zdHJhaW50cy52aWRlbyk7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdmZjM3OiAnICsgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEoY29uc3RyYWludHMsIG9uU3VjY2VzcywgZnVuY3Rpb24oZSkge1xuICAgICAgb25FcnJvcihzaGltRXJyb3JfKGUpKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgZ2V0VXNlck1lZGlhIGFzIGEgUHJvbWlzZS5cbiAgdmFyIGdldFVzZXJNZWRpYVByb21pc2VfID0gZnVuY3Rpb24oY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBnZXRVc2VyTWVkaWFfKGNvbnN0cmFpbnRzLCByZXNvbHZlLCByZWplY3QpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFNoaW0gZm9yIG1lZGlhRGV2aWNlcyBvbiBvbGRlciB2ZXJzaW9ucy5cbiAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyA9IHtnZXRVc2VyTWVkaWE6IGdldFVzZXJNZWRpYVByb21pc2VfLFxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7IH0sXG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHsgfVxuICAgIH07XG4gIH1cbiAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzID1cbiAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcyB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICB2YXIgaW5mb3MgPSBbXG4gICAgICAgICAgICB7a2luZDogJ2F1ZGlvaW5wdXQnLCBkZXZpY2VJZDogJ2RlZmF1bHQnLCBsYWJlbDogJycsIGdyb3VwSWQ6ICcnfSxcbiAgICAgICAgICAgIHtraW5kOiAndmlkZW9pbnB1dCcsIGRldmljZUlkOiAnZGVmYXVsdCcsIGxhYmVsOiAnJywgZ3JvdXBJZDogJyd9XG4gICAgICAgICAgXTtcbiAgICAgICAgICByZXNvbHZlKGluZm9zKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNDEpIHtcbiAgICAvLyBXb3JrIGFyb3VuZCBodHRwOi8vYnVnemlsLmxhLzExNjk2NjVcbiAgICB2YXIgb3JnRW51bWVyYXRlRGV2aWNlcyA9XG4gICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcy5iaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG9yZ0VudW1lcmF0ZURldmljZXMoKS50aGVuKHVuZGVmaW5lZCwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5uYW1lID09PSAnTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA0OSkge1xuICAgIHZhciBvcmlnR2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuXG4gICAgICAgIGJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gb3JpZ0dldFVzZXJNZWRpYShjKS50aGVuKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAvLyBXb3JrIGFyb3VuZCBodHRwczovL2J1Z3ppbC5sYS84MDIzMjZcbiAgICAgICAgaWYgKGMuYXVkaW8gJiYgIXN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCB8fFxuICAgICAgICAgICAgYy52aWRlbyAmJiAhc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb2JqZWN0IGNhbiBub3QgYmUgZm91bmQgaGVyZS4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSwgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoc2hpbUVycm9yXyhlKSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbihjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA0NCkge1xuICAgICAgcmV0dXJuIGdldFVzZXJNZWRpYV8oY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcik7XG4gICAgfVxuICAgIC8vIFJlcGxhY2UgRmlyZWZveCA0NCsncyBkZXByZWNhdGlvbiB3YXJuaW5nIHdpdGggdW5wcmVmaXhlZCB2ZXJzaW9uLlxuICAgIGNvbnNvbGUud2FybignbmF2aWdhdG9yLmdldFVzZXJNZWRpYSBoYXMgYmVlbiByZXBsYWNlZCBieSAnICtcbiAgICAgICAgICAgICAgICAgJ25hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhJyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfTtcbn07XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBzYWZhcmlTaGltID0ge1xuICAvLyBUT0RPOiBEckFsZXgsIHNob3VsZCBiZSBoZXJlLCBkb3VibGUgY2hlY2sgYWdhaW5zdCBMYXlvdXRUZXN0c1xuICAvLyBzaGltT25UcmFjazogZnVuY3Rpb24oKSB7IH0sXG5cbiAgLy8gVE9ETzogb25jZSB0aGUgYmFjay1lbmQgZm9yIHRoZSBtYWMgcG9ydCBpcyBkb25lLCBhZGQuXG4gIC8vIFRPRE86IGNoZWNrIGZvciB3ZWJraXRHVEsrXG4gIC8vIHNoaW1QZWVyQ29ubmVjdGlvbjogZnVuY3Rpb24oKSB7IH0sXG5cbiAgc2hpbUdldFVzZXJNZWRpYTogZnVuY3Rpb24oKSB7XG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWE7XG4gIH1cbn07XG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaGltR2V0VXNlck1lZGlhOiBzYWZhcmlTaGltLnNoaW1HZXRVc2VyTWVkaWFcbiAgLy8gVE9ET1xuICAvLyBzaGltT25UcmFjazogc2FmYXJpU2hpbS5zaGltT25UcmFjayxcbiAgLy8gc2hpbVBlZXJDb25uZWN0aW9uOiBzYWZhcmlTaGltLnNoaW1QZWVyQ29ubmVjdGlvblxufTtcbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuIC8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbG9nRGlzYWJsZWRfID0gdHJ1ZTtcblxuLy8gVXRpbGl0eSBtZXRob2RzLlxudmFyIHV0aWxzID0ge1xuICBkaXNhYmxlTG9nOiBmdW5jdGlvbihib29sKSB7XG4gICAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0FyZ3VtZW50IHR5cGU6ICcgKyB0eXBlb2YgYm9vbCArXG4gICAgICAgICAgJy4gUGxlYXNlIHVzZSBhIGJvb2xlYW4uJyk7XG4gICAgfVxuICAgIGxvZ0Rpc2FibGVkXyA9IGJvb2w7XG4gICAgcmV0dXJuIChib29sKSA/ICdhZGFwdGVyLmpzIGxvZ2dpbmcgZGlzYWJsZWQnIDpcbiAgICAgICAgJ2FkYXB0ZXIuanMgbG9nZ2luZyBlbmFibGVkJztcbiAgfSxcblxuICBsb2c6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGxvZ0Rpc2FibGVkXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRXh0cmFjdCBicm93c2VyIHZlcnNpb24gb3V0IG9mIHRoZSBwcm92aWRlZCB1c2VyIGFnZW50IHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHshc3RyaW5nfSB1YXN0cmluZyB1c2VyQWdlbnQgc3RyaW5nLlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGV4cHIgUmVndWxhciBleHByZXNzaW9uIHVzZWQgYXMgbWF0Y2ggY3JpdGVyaWEuXG4gICAqIEBwYXJhbSB7IW51bWJlcn0gcG9zIHBvc2l0aW9uIGluIHRoZSB2ZXJzaW9uIHN0cmluZyB0byBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybiB7IW51bWJlcn0gYnJvd3NlciB2ZXJzaW9uLlxuICAgKi9cbiAgZXh0cmFjdFZlcnNpb246IGZ1bmN0aW9uKHVhc3RyaW5nLCBleHByLCBwb3MpIHtcbiAgICB2YXIgbWF0Y2ggPSB1YXN0cmluZy5tYXRjaChleHByKTtcbiAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID49IHBvcyAmJiBwYXJzZUludChtYXRjaFtwb3NdLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJyb3dzZXIgZGV0ZWN0b3IuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gcmVzdWx0IGNvbnRhaW5pbmcgYnJvd3NlciBhbmQgdmVyc2lvblxuICAgKiAgICAgcHJvcGVydGllcy5cbiAgICovXG4gIGRldGVjdEJyb3dzZXI6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFJldHVybmVkIHJlc3VsdCBvYmplY3QuXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHJlc3VsdC5icm93c2VyID0gbnVsbDtcbiAgICByZXN1bHQudmVyc2lvbiA9IG51bGw7XG5cbiAgICAvLyBGYWlsIGVhcmx5IGlmIGl0J3Mgbm90IGEgYnJvd3NlclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm5hdmlnYXRvcikge1xuICAgICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgYnJvd3Nlci4nO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBGaXJlZm94LlxuICAgIGlmIChuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhKSB7XG4gICAgICByZXN1bHQuYnJvd3NlciA9ICdmaXJlZm94JztcbiAgICAgIHJlc3VsdC52ZXJzaW9uID0gdGhpcy5leHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICAgIC9GaXJlZm94XFwvKFswLTldKylcXC4vLCAxKTtcblxuICAgIC8vIGFsbCB3ZWJraXQtYmFzZWQgYnJvd3NlcnNcbiAgICB9IGVsc2UgaWYgKG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEpIHtcbiAgICAgIC8vIENocm9tZSwgQ2hyb21pdW0sIFdlYnZpZXcsIE9wZXJhLCBhbGwgdXNlIHRoZSBjaHJvbWUgc2hpbSBmb3Igbm93XG4gICAgICBpZiAod2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdC5icm93c2VyID0gJ2Nocm9tZSc7XG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdGhpcy5leHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgICAgIC9DaHJvbShlfGl1bSlcXC8oWzAtOV0rKVxcLi8sIDIpO1xuXG4gICAgICAvLyBTYWZhcmkgb3IgdW5rbm93biB3ZWJraXQtYmFzZWRcbiAgICAgIC8vIGZvciB0aGUgdGltZSBiZWluZyBTYWZhcmkgaGFzIHN1cHBvcnQgZm9yIE1lZGlhU3RyZWFtcyBidXQgbm90IHdlYlJUQ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2FmYXJpIFVBIHN1YnN0cmluZ3Mgb2YgaW50ZXJlc3QgZm9yIHJlZmVyZW5jZTpcbiAgICAgICAgLy8gLSB3ZWJraXQgdmVyc2lvbjogICAgICAgICAgIEFwcGxlV2ViS2l0LzYwMi4xLjI1IChhbHNvIHVzZWQgaW4gT3AsQ3IpXG4gICAgICAgIC8vIC0gc2FmYXJpIFVJIHZlcnNpb246ICAgICAgICBWZXJzaW9uLzkuMC4zICh1bmlxdWUgdG8gU2FmYXJpKVxuICAgICAgICAvLyAtIHNhZmFyaSBVSSB3ZWJraXQgdmVyc2lvbjogU2FmYXJpLzYwMS40LjQgKGFsc28gdXNlZCBpbiBPcCxDcilcbiAgICAgICAgLy9cbiAgICAgICAgLy8gaWYgdGhlIHdlYmtpdCB2ZXJzaW9uIGFuZCBzYWZhcmkgVUkgd2Via2l0IHZlcnNpb25zIGFyZSBlcXVhbHMsXG4gICAgICAgIC8vIC4uLiB0aGlzIGlzIGEgc3RhYmxlIHZlcnNpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIG9ubHkgdGhlIGludGVybmFsIHdlYmtpdCB2ZXJzaW9uIGlzIGltcG9ydGFudCB0b2RheSB0byBrbm93IGlmXG4gICAgICAgIC8vIG1lZGlhIHN0cmVhbXMgYXJlIHN1cHBvcnRlZFxuICAgICAgICAvL1xuICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhcXGQrKS4oXFxkKykvKSkge1xuICAgICAgICAgIHJlc3VsdC5icm93c2VyID0gJ3NhZmFyaSc7XG4gICAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB0aGlzLmV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgICAgICAvQXBwbGVXZWJLaXRcXC8oWzAtOV0rKVxcLi8sIDEpO1xuXG4gICAgICAgIC8vIHVua25vd24gd2Via2l0LWJhc2VkIGJyb3dzZXJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuYnJvd3NlciA9ICdVbnN1cHBvcnRlZCB3ZWJraXQtYmFzZWQgYnJvd3NlciAnICtcbiAgICAgICAgICAgICAgJ3dpdGggR1VNIHN1cHBvcnQgYnV0IG5vIFdlYlJUQyBzdXBwb3J0Lic7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLy8gRWRnZS5cbiAgICB9IGVsc2UgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiZcbiAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS4oXFxkKykkLykpIHtcbiAgICAgIHJlc3VsdC5icm93c2VyID0gJ2VkZ2UnO1xuICAgICAgcmVzdWx0LnZlcnNpb24gPSB0aGlzLmV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgICAgL0VkZ2VcXC8oXFxkKykuKFxcZCspJC8sIDIpO1xuXG4gICAgLy8gRGVmYXVsdCBmYWxsdGhyb3VnaDogbm90IHN1cHBvcnRlZC5cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgc3VwcG9ydGVkIGJyb3dzZXIuJztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLy8gRXhwb3J0LlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvZzogdXRpbHMubG9nLFxuICBkaXNhYmxlTG9nOiB1dGlscy5kaXNhYmxlTG9nLFxuICBicm93c2VyRGV0YWlsczogdXRpbHMuZGV0ZWN0QnJvd3NlcigpLFxuICBleHRyYWN0VmVyc2lvbjogdXRpbHMuZXh0cmFjdFZlcnNpb25cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwidmFyIGJ1cyA9IHJlcXVpcmUoJ3BhZ2UtYnVzJylcbnZhciBzaG9ydCA9IHJlcXVpcmUoJ3Nob3J0LXV1aWQnKVxudmFyIGlkID0gc2hvcnQoKS5nZW5lcmF0ZSgpXG52YXIgZW1pdHRlcnMgPSB7fVxudmFyIG5hbWVzID0gW11cbnZhciBtZXRhID0gYnVzKHtrZXk6ICdfbWV0YV8nfSlcbnZhciBqb2luID0gYnVzKHtrZXk6ICdfam9pbl8nfSlcbnZhciBzZWxmID0gYnVzKHtrZXk6IGlkfSlcbnZhciBzd2FybSA9IHt9IC8vIGlkc1xudmFyIGNvdW50ID0gMFxuXG5qb2luLmVtaXQoJ2RhdGEnLCB7aWQ6IGlkfSlcblxuam9pbi5vbignZGF0YScsIGUgPT4ge1xuICBpZihlLmlkID09IGlkKSByZXR1cm5cbiAgbGV0IGVtID0gc3dhcm1bZS5pZF0gPSBidXMoe2tleTogZS5pZH0pXG4gIGNvdW50KytcbiAgaWYoTWF0aC5yYW5kb20oKSA8PSAxIC8gTWF0aC5wb3coY291bnQsIDIpKSByZXR1cm5cbiAgZWxzZSBlbS5lbWl0KCdkYXRhJywge2V2ZW50czogbmFtZXMsIHN3YW1ybTogT2JqZWN0LmtleXMoc3dhcm0pfSlcbn0pXG5cbnNlbGYub24oJ2RhdGEnLCBlID0+IHtcbiAgZS5ldmVudHMuZm9yRWFjaChldiA9PiB7XG4gICAgaWYoIWVtaXR0ZXJzW2UubmFtZV0pIHtcbiAgICAgIHZhciBlbWl0dGVyID0gZW1pdHRlcnNbZS5uYW1lXSA9IGJ1cyh7a2V5OmUubmFtZX0pXG4gICAgfVxuICB9KVxuICBlLnN3YXJtLmZvckVhY2gocyA9PiB7XG4gICAgaWYoIXN3YXJtW3NdKSBzd2FybVtzXSA9IGJ1cyh7a2V5OiBzfSlcbiAgfSlcbiBjb3VudCA9IHN3YXJtLmxlbmd0aFxufSlcblxubWV0YS5vbignZGF0YScsIGUgPT4ge1xuICBpZighZW1pdHRlcnNbZS5uYW1lXSkgZW1pdHRlcnNbZS5uYW1lXSA9IGJ1cyh7a2V5OmUubmFtZX0pXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtvbiwgb25jZSwgZW1pdH1cblxuZnVuY3Rpb24gb24obmFtZSwgZm4pe1xuICBpZighZW1pdHRlcnNbbmFtZV0pIHtcbiAgICBuYW1lcy5wdXNoKG5hbWUpXG4gICAgbWV0YS5lbWl0KCdkYXRhJywge25hbWU6IG5hbWV9KVxuICAgIHNldFRpbWVvdXQoZSA9PiBvbihuYW1lLCBmbiksIDApXG4gIH0gIFxuICBlbHNlIHtcbiAgICBlbWl0dGVyc1tuYW1lXS5vbihuYW1lLCBmbilcbiAgfVxufVxuXG5mdW5jdGlvbiBvbmNlKG5hbWUsIGZuKXtcbiAgaWYoIWVtaXR0ZXJzW25hbWVdKSB7XG4gICAgbWV0YS5lbWl0KCdkYXRhJywge25hbWU6IG5hbWV9KVxuICAgIHNldFRpbWVvdXQoZSA9PiBvbihuYW1lLCBmbiksIDApXG4gIH0gIFxuICBlbHNlIGVtaXR0ZXJzW25hbWVdLm9uY2UobmFtZSwgZm4pXG59XG5cbmZ1bmN0aW9uIGVtaXQobmFtZSwgZGF0YSl7XG4gIGlmKCFlbWl0dGVyc1tuYW1lXSkge1xuICAgIG1ldGEuZW1pdCgnZGF0YScsIHtuYW1lOiBuYW1lfSlcbiAgICBzZXRUaW1lb3V0KGUgPT4gZW1pdChuYW1lLCBkYXRhLCAwKSlcbiAgfSAgXG4gIGVsc2UgZW1pdHRlcnNbbmFtZV0uZW1pdChuYW1lLCBkYXRhKVxufVxuIiwidmFyIG1zMnMgPSAxLjAgLyAxMDAwLjA7XG52YXIgbnMybXMgPSAxLjAgLyAxMDAwMDAwLjBcbnZhciBuczJzID0gMWUtOVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRcblxuZnVuY3Rpb24gVCgpe1xuXHRpZighcHJvY2Vzcy5ocnRpbWUpeyAvLyBicm93c2VyIGZpbGxcblxuXHRcdHByb2Nlc3MuaHJ0aW1lID0gZnVuY3Rpb24oKXtcblxuXHRcdFx0aWYoYXJndW1lbnRzLmxlbmd0aCl7XG5cdFx0XHRcdGFyZ3VtZW50c1sxXSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdFx0XHRhcmd1bWVudHNbMF0gPSAgYXJndW1lbnRzWzFdIC0gbWlsbGllcyhhcmd1bWVudHNbMF0pXG5cdFx0XHR9XG5cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRhcmd1bWVudHNbMF0gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIFtwYXJzZUludChhcmd1bWVudHNbMF0gKiBtczJzKSwgcGFyc2VJbnQoKChhcmd1bWVudHNbMF0gKiBtczJzKSAlIDEpIC8gbnMycyldO1xuXHRcdFx0XG5cdFx0fVxuXHR9XG4gIGlmKCEodGhpcyBpbnN0YW5jZW9mIFQpKSByZXR1cm4gbmV3IFQoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnN0YXJ0ID0gc2VsZi5sYXN0ID0gc2VsZi5iZWF0ID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgc2VsZi54ID0gW11cbiAgc2VsZi5lbmQgPSBbXVxuICBzZWxmLmJlYXRzID0gIFtdXG4gIHNlbGYuYXZlcmFnZVNldFNpemUgPSAzMzNcbiAgc2VsZi50aHJlc2hvbGQgPSAxZTYgLy8gMTAsMDAwLDAwMCBucyAoIDEwIG1zIClcbiAgc2VsZi5za2lwID0gZmFsc2Vcbn07XG5cblQucHJvdG90eXBlLnNpbmNlQmVnaW4gPSBmdW5jdGlvbigpe1xuICByZXR1cm4gcHJvY2Vzcy5ocnRpbWUodGhpcy5zdGFydClcbn07XG5cblQucHJvdG90eXBlLnNpbmNlTGFzdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMueCA9IHByb2Nlc3MuaHJ0aW1lKHRoaXMubGFzdClcbiAgdGhpcy5sYXN0ID0gcHJvY2Vzcy5ocnRpbWUoKVxuICByZXR1cm4gdGhpcy54XG59XG5cblQucHJvdG90eXBlLnNpbmNlTGFzdE5TID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5hbm9zKHRoaXMuc2luY2VMYXN0KCkpXG59O1xuXG5ULnByb3RvdHlwZS5zaW5jZUJlZ2luTlMgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gbmFub3ModGhpcy5zaW5jZUJlZ2luKCkpXG59O1xuXG5ULnByb3RvdHlwZS5hdmcgPSBmdW5jdGlvbigpe1xuICB2YXIgbnMgPSBuYW5vcyh0aGlzLnNpbmNlTGFzdCgpKVxuICB0aGlzLmJlYXRzLnB1c2gobnMpO1xuICB0aGlzLmJlYXRzID0gdGhpcy5iZWF0cy5zcGxpY2UoLXRoaXMuYXZlcmFnZVNldFNpemUpXG4gIHJldHVybiBhdmcodGhpcy5iZWF0cyk7XG59O1xuXG5ULnByb3RvdHlwZS5ldmVyeVMgPSBmdW5jdGlvbihzLCBmbiwgZ28pe1xuXHR0aGlzLmV2ZXJ5KHMgKiAxZTksIGZuLCBnbylcbn1cblxuVC5wcm90b3R5cGUuZXZlcnkgPSBmdW5jdGlvbihucywgZm4sIGdvKXtcblxuICB2YXIgc2VsZiA9IG5ldyBUKCk7XG4gIHZhciB0aW1lciA9IG5ldyBUKCk7XG5cbiAgdmFyIGludGVyID0gbnMgfHwgMFxuICAgICwgZm4gPSBmbiB8fCBmdW5jdGlvbih0LGMpe2MoKX1cbiAgICA7ICAgXG4gICAgICBcbiAgZnVuY3Rpb24gdGljaygpe1xuXG4gICAgdmFyIG5zID0gbmFub3Moc2VsZi5zaW5jZUxhc3QoKSk7XG4vLyAgdW5uZWNlc3NhcnkgY3V6IG5vIGxvbmdlciB0cnlpbmcgdG8gb3B0aW1pemUgaW4gbG9vcCgpXG4vLyAgICBzZWxmLmJlYXRzLnB1c2gobnMpO1xuICAgIGxvb3AoKVxuXG4gIH07XG5cbiAgZnVuY3Rpb24gbG9vcCgpe1xuICAgIHZhciBkID0gaW50ZXIgLSAobmFub3MocHJvY2Vzcy5ocnRpbWUoKSkgLSBuYW5vcyhzZWxmLmJlYXQpKTtcblxuICAgIGlmKGQgPCAxMDAwMCkge1xuICAgICAgdG9jaygpXG4gICAgfVxuXG4gICAgZWxzZSBpZihzZWxmLnNraXApIHtcbiAgICAgc2V0SW1tZWRpYXRlKGxvb3ApXG4gICAgfVxuXG4gICAgZWxzZSBpZihkIDwgc2VsZi50aHJlc2hvbGQpIHtcbiAgICAgIC8vIHVuZGVyIHRoZSB0aHJlc2hvbGQsIGl0cyBuZXh0VGlja3MgdW50aWwgdGhlIGludGVydmFsIGlzIHVwXG4gICAgICBzZWxmLnNraXAgPSB0cnVlOyBzZXRJbW1lZGlhdGUobG9vcCkgXG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICBpZihmYWxzZSAmJiBzZWxmLmJlYXRzLmxlbmd0aCA+IDkpIHtcbiAgICAgICAgdmFyIHIgPSBzZWxmLmJlYXRzLmxlbmd0aCAvIHNlbGYuYXZlcmFnZVNldFNpemU7XG4gICAgICAgIHNlbGYudGhyZXNob2xkID0gYXZnKHNlbGYuYmVhdHMpICogLjQ1ICogciAqIDJcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGZ1dHVyZSByZWZlcmVuY2U6XG4gICAgICAvLyBjb25zb2xlLmxvZyhhdmcoc2VsZi5iZWF0cyksIHNlbGYuYmVhdHMubGVuZ3RoLCAndGhyZXNob2xkID0gJyArIHNlbGYudGhyZXNob2xkKVxuXG4gICAgICBzZWxmLnNraXAgPSBmYWxzZTsgXG4gICAgICBzZXRUaW1lb3V0KGxvb3AsIHNlbGYudGhyZXNob2xkIC8gMWU2KVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB0b2NrKCl7XG4gICAgc2VsZi5iZWF0ID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICBzZWxmLnNraXAgPSBmYWxzZTtcbiAgICBmbih0aWNrLCBuYW5vcyh0aW1lci5zaW5jZUxhc3QoKSkpXG4gIH07XG4gIFxuICBpZihnbykgdG9jaygpXG5cbiAgZWxzZSBsb29wKClcblxufVxuXG5mdW5jdGlvbiBtaWxsaWVzKGFycil7XG5cdHJldHVybiAoYXJyWzBdICogMWUzKSArIChhcnJbMV0gKiBuczJtcylcbn1cblxuZnVuY3Rpb24gbmFub3MoYXJyKXtcbiAgcmV0dXJuIGFyclswXSAqIDFlOSArIGFyclsxXVxufVxuXG5mdW5jdGlvbiBhZGQoYSwgYil7XG4gIHZhciBucyA9IGFbMV0gKyBiWzFdO1xuICBiWzBdICs9IGFbMF07XG4gIGJbMV0gPSBucyAlIDFlOTtcbiAgaWYobnMgIT09IGJbMV0pIGJbMF0rKztcbiAgcmV0dXJuIGJcbn07XG5cbmZ1bmN0aW9uIGF2Zygpe1xuXG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHNbMF0pLnJlZHVjZShmdW5jdGlvbihhLGkpe3JldHVybiBhICs9IGkgfSwwKSAvIGFyZ3VtZW50c1swXS5sZW5ndGhcblxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcG9zc2libGVOYW1lcyA9IFtcblx0J0JpZ0ludDY0QXJyYXknLFxuXHQnQmlnVWludDY0QXJyYXknLFxuXHQnRmxvYXQzMkFycmF5Jyxcblx0J0Zsb2F0NjRBcnJheScsXG5cdCdJbnQxNkFycmF5Jyxcblx0J0ludDMyQXJyYXknLFxuXHQnSW50OEFycmF5Jyxcblx0J1VpbnQxNkFycmF5Jyxcblx0J1VpbnQzMkFycmF5Jyxcblx0J1VpbnQ4QXJyYXknLFxuXHQnVWludDhDbGFtcGVkQXJyYXknXG5dO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IGdsb2JhbFRoaXM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKSB7XG5cdHZhciBvdXQgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3NzaWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBnW3Bvc3NpYmxlTmFtZXNbaV1dID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvdXRbb3V0Lmxlbmd0aF0gPSBwb3NzaWJsZU5hbWVzW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0O1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyIGNhbGxCaW5kID0gcmVxdWlyZSgnLi8nKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJpbmQoR2V0SW50cmluc2ljKCdTdHJpbmcucHJvdG90eXBlLmluZGV4T2YnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljID0gR2V0SW50cmluc2ljKG5hbWUsICEhYWxsb3dNaXNzaW5nKTtcblx0aWYgKHR5cGVvZiBpbnRyaW5zaWMgPT09ICdmdW5jdGlvbicgJiYgJGluZGV4T2YobmFtZSwgJy5wcm90b3R5cGUuJykgPiAtMSkge1xuXHRcdHJldHVybiBjYWxsQmluZChpbnRyaW5zaWMpO1xuXHR9XG5cdHJldHVybiBpbnRyaW5zaWM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkYXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklJyk7XG52YXIgJGNhbGwgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCUnKTtcbnZhciAkcmVmbGVjdEFwcGx5ID0gR2V0SW50cmluc2ljKCclUmVmbGVjdC5hcHBseSUnLCB0cnVlKSB8fCBiaW5kLmNhbGwoJGNhbGwsICRhcHBseSk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJywgdHJ1ZSk7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmRlZmluZVByb3BlcnR5JScsIHRydWUpO1xudmFyICRtYXggPSBHZXRJbnRyaW5zaWMoJyVNYXRoLm1heCUnKTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcblx0XHQkZGVmaW5lUHJvcGVydHkgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuXHR2YXIgZnVuYyA9ICRyZWZsZWN0QXBwbHkoYmluZCwgJGNhbGwsIGFyZ3VtZW50cyk7XG5cdGlmICgkZ09QRCAmJiAkZGVmaW5lUHJvcGVydHkpIHtcblx0XHR2YXIgZGVzYyA9ICRnT1BEKGZ1bmMsICdsZW5ndGgnKTtcblx0XHRpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcblx0XHRcdC8vIG9yaWdpbmFsIGxlbmd0aCwgcGx1cyB0aGUgcmVjZWl2ZXIsIG1pbnVzIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyAoYWZ0ZXIgdGhlIHJlY2VpdmVyKVxuXHRcdFx0JGRlZmluZVByb3BlcnR5KFxuXHRcdFx0XHRmdW5jLFxuXHRcdFx0XHQnbGVuZ3RoJyxcblx0XHRcdFx0eyB2YWx1ZTogMSArICRtYXgoMCwgb3JpZ2luYWxGdW5jdGlvbi5sZW5ndGggLSAoYXJndW1lbnRzLmxlbmd0aCAtIDEpKSB9XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZnVuYztcbn07XG5cbnZhciBhcHBseUJpbmQgPSBmdW5jdGlvbiBhcHBseUJpbmQoKSB7XG5cdHJldHVybiAkcmVmbGVjdEFwcGx5KGJpbmQsICRhcHBseSwgYXJndW1lbnRzKTtcbn07XG5cbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcblx0JGRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnYXBwbHknLCB7IHZhbHVlOiBhcHBseUJpbmQgfSk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cy5hcHBseSA9IGFwcGx5QmluZDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnKTtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0JGdPUEQgPSBudWxsO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGdPUEQ7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIiwiXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9yRWFjaCAob2JqLCBmbiwgY3R4KSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwoZm4pICE9PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgbCA9IG9iai5sZW5ndGg7XG4gICAgaWYgKGwgPT09ICtsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtrXSwgaywgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdW5kZWZpbmVkO1xuXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGV4cHJlc3Npb25TeW50YXgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gJEZ1bmN0aW9uKCdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgZXhwcmVzc2lvblN5bnRheCArICcpLmNvbnN0cnVjdG9yOycpKCk7XG5cdH0gY2F0Y2ggKGUpIHt9XG59O1xuXG52YXIgJGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoe30sICcnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxuXHR9XG59XG5cbnZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoKTtcbn07XG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxuXHQ/IChmdW5jdGlvbiAoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG5cdFx0XHRhcmd1bWVudHMuY2FsbGVlOyAvLyBJRSA4IGRvZXMgbm90IHRocm93IGhlcmVcblx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHR9IGNhdGNoIChjYWxsZWVUaHJvd3MpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIElFIDggdGhyb3dzIG9uIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXJndW1lbnRzLCAnJylcblx0XHRcdFx0cmV0dXJuICRnT1BEKGFyZ3VtZW50cywgJ2NhbGxlZScpLmdldDtcblx0XHRcdH0gY2F0Y2ggKGdPUER0aHJvd3MpIHtcblx0XHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpKVxuXHQ6IHRocm93VHlwZUVycm9yO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG52YXIgbmVlZHNFdmFsID0ge307XG5cbnZhciBUeXBlZEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHQnJUFnZ3JlZ2F0ZUVycm9yJSc6IHR5cGVvZiBBZ2dyZWdhdGVFcnJvciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBZ2dyZWdhdGVFcnJvcixcblx0JyVBcnJheSUnOiBBcnJheSxcblx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXG5cdCclQXJyYXlJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcblx0JyVBdG9taWNzJSc6IHR5cGVvZiBBdG9taWNzID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEF0b21pY3MsXG5cdCclQmlnSW50JSc6IHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQmlnSW50LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogRXJyb3IsXG5cdCclZXZhbCUnOiBldmFsLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxuXHQnJUZsb2F0MzJBcnJheSUnOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MzJBcnJheSxcblx0JyVGbG9hdDY0QXJyYXklJzogdHlwZW9mIEZsb2F0NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDY0QXJyYXksXG5cdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxuXHQnJUZ1bmN0aW9uJSc6ICRGdW5jdGlvbixcblx0JyVHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxuXHQnJUludDE2QXJyYXklJzogdHlwZW9mIEludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MTZBcnJheSxcblx0JyVJbnQzMkFycmF5JSc6IHR5cGVvZiBJbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDMyQXJyYXksXG5cdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXG5cdCclaXNOYU4lJzogaXNOYU4sXG5cdCclSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpIDogdW5kZWZpbmVkLFxuXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcblx0JyVNYXAlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBNYXAsXG5cdCclTWFwSXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIE1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiBSZWZlcmVuY2VFcnJvcixcblx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXG5cdCclUmVnRXhwJSc6IFJlZ0V4cCxcblx0JyVTZXQlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTZXQsXG5cdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiBVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldFxufTtcblxudmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbChuYW1lKSB7XG5cdHZhciB2YWx1ZTtcblx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2Z1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKSB7XG5cdFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uKiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xuXHRcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHR2YWx1ZSA9IGZuLnByb3RvdHlwZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcblx0XHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XG5cdFx0aWYgKGdlbikge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm90byhnZW4ucHJvdG90eXBlKTtcblx0XHR9XG5cdH1cblxuXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XG5cblx0cmV0dXJuIHZhbHVlO1xufTtcblxudmFyIExFR0FDWV9BTElBU0VTID0ge1xuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhcycpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbnZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChpc1N0YW5kYXJkQXJndW1lbnRzKHZhbHVlKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xufSgpKTtcblxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0ZuUmVnZXggPSAvXlxccyooPzpmdW5jdGlvbik/XFwqLztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgZ2V0R2VuZXJhdG9yRnVuYyA9IGZ1bmN0aW9uICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gZnVuY3Rpb24qKCkge30nKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdH1cbn07XG52YXIgR2VuZXJhdG9yRnVuY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihmbikge1xuXHRpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmIChpc0ZuUmVnZXgudGVzdChmblRvU3RyLmNhbGwoZm4pKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHR2YXIgc3RyID0gdG9TdHIuY2FsbChmbik7XG5cdFx0cmV0dXJuIHN0ciA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJztcblx0fVxuXHRpZiAoIWdldFByb3RvKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGlmICh0eXBlb2YgR2VuZXJhdG9yRnVuY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKCk7XG5cdFx0R2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jID8gZ2V0UHJvdG8oZ2VuZXJhdG9yRnVuYykgOiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gZ2V0UHJvdG8oZm4pID09PSBHZW5lcmF0b3JGdW5jdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuaW5kZXhPZicsIHRydWUpIHx8IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciB0b1N0clRhZ3MgPSB7fTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0dmFyIGFyciA9IG5ldyBnW3R5cGVkQXJyYXldKCk7XG5cdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdGRlc2NyaXB0b3IgPSBnT1BEKHN1cGVyUHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG5cdFx0XHR9XG5cdFx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0XHR9XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgYW55VHJ1ZSA9IGZhbHNlO1xuXHRmb3JFYWNoKHRvU3RyVGFncywgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuXHRcdGlmICghYW55VHJ1ZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YW55VHJ1ZSA9IGdldHRlci5jYWxsKHZhbHVlKSA9PT0gdHlwZWRBcnJheTtcblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGFueVRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcgfHwgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpKSB7XG5cdFx0dmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XG5cdFx0cmV0dXJuICRpbmRleE9mKHR5cGVkQXJyYXlzLCB0YWcpID4gLTE7XG5cdH1cblx0aWYgKCFnT1BEKSB7IHJldHVybiBmYWxzZTsgfVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcblN0cmVhbS5maW5pc2hlZCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJylcblN0cmVhbS5waXBlbGluZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpXG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cbid1c2Ugc3RyaWN0Jztcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcblxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gQWxsb3cgdGhlIGtleXMgYXJyYXkgdG8gYmUgR0MnZWQuXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuXG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcblxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIElmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLCB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuOyAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuXG4gIHByb2Nlc3MubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gRUVsaXN0ZW5lckNvdW50KGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIGRlYnVnO1xuXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UOyAvLyBMYXp5IGxvYWRlZCB0byBpbXByb3ZlIHRoZSBzdGFydHVwIHBlcmZvcm1hbmNlLlxuXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjtcbnZhciBmcm9tO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOyAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cblxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdlbmQnIChhbmQgcG90ZW50aWFsbHkgJ2ZpbmlzaCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcblxuICB0aGlzLmF3YWl0RHJhaW4gPSAwOyAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG5cbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcblxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpOyAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeVxuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyAvLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuXG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07IC8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG5cbiAgICBpZiAoZXIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cblxuXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuXG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuXG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGVyO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB2YXIgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IGRlY29kZXI7IC8vIElmIHNldEVuY29kaW5nKG51bGwpLCBkZWNvZGVyLmVuY29kaW5nIGVxdWFscyB1dGY4XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZzsgLy8gSXRlcmF0ZSBvdmVyIGN1cnJlbnQgYnVmZmVyIHRvIGNvbnZlcnQgYWxyZWFkeSBzdG9yZWQgQnVmZmVyczpcblxuICB2YXIgcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQ7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTtcblxuICBpZiAoY29udGVudCAhPT0gJycpIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLnB1c2goY29udGVudCk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDFHQlxuXG5cbnZhciBNQVhfSFdNID0gMHg0MDAwMDAwMDtcblxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgLy8gVE9ETyhyb25hZyk6IFRocm93IEVSUl9WQUxVRV9PVVRfT0ZfUkFOR0UuXG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuXG4gIHJldHVybiBuO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuXG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9IC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuXG5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47IC8vIERvbid0IGhhdmUgZW5vdWdoXG5cbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufSAvLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOyAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpOyAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG5cblxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7IC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH0gLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuXG5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTsgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcblxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG5cbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7IC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ29uRW9mQ2h1bmsnKTtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3luYykge1xuICAgIC8vIGlmIHdlIGFyZSBzeW5jLCB3YWl0IHVudGlsIG5leHQgdGljayB0byBlbWl0IHRoZSBkYXRhLlxuICAgIC8vIE90aGVyd2lzZSB3ZSByaXNrIGVtaXR0aW5nIGRhdGEgaW4gdGhlIGZsb3coKVxuICAgIC8vIHRoZSByZWFkYWJsZSBjb2RlIHRyaWdnZXJzIGR1cmluZyBhIHJlYWQoKSBjYWxsXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn0gLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cblxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlXycsIHN0YXRlLmRlc3Ryb3llZCwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmxlbmd0aCB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgfSAvLyBUaGUgc3RyZWFtIG5lZWRzIGFub3RoZXIgcmVhZGFibGUgZXZlbnQgaWZcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcbiAgLy8gICAgY2FyZSBvZiBpdC5cbiAgLy8gMi4gSXQgaXMgbm90IGVuZGVkLlxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXG4gIC8vICAgIGFub3RoZXIgcmVhZGFibGUgbGF0ZXIuXG5cblxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn0gLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKSAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufSAvLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ19yZWFkKCknKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuXG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG5cbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfSAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cblxuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTsgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBjbGVhbmVkVXAgPSB0cnVlOyAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgfVxuXG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH0gLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cblxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfSAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG5cblxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7IC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfSAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuXG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTsgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7XG4gICAgaGFzVW5waXBlZDogZmFsc2VcbiAgfTsgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzOyAvLyBnb3QgYSBtYXRjaC5cblxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHtcbiAgICAgICAgaGFzVW5waXBlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG5cblxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIHVwZGF0ZSByZWFkYWJsZUxpc3RlbmluZyBzbyB0aGF0IHJlc3VtZSgpIG1heSBiZSBhIG5vLW9wXG4gICAgLy8gYSBmZXcgbGluZXMgZG93bi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScpLlxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDsgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuXG4gICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyhzZWxmKSB7XG4gIHZhciBzdGF0ZSA9IHNlbGYuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc2VsZi5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDtcblxuICBpZiAoc3RhdGUucmVzdW1lU2NoZWR1bGVkICYmICFzdGF0ZS5wYXVzZWQpIHtcbiAgICAvLyBmbG93aW5nIG5lZWRzIHRvIGJlIHNldCB0byB0cnVlIG5vdywgb3RoZXJ3aXNlXG4gICAgLy8gdGhlIHVwY29taW5nIHJlc3VtZSB3aWxsIG5vdCBmbG93LlxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOyAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufSAvLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7IC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcblxuICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmc7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1ZygncmVzdW1lJywgc3RhdGUucmVhZGluZyk7XG5cbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG5cbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge1xuICAgIDtcbiAgfVxufSAvLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7IC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pOyAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gbWV0aG9kV3JhcChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH0gLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfSAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuXG5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcblxuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpO1xuICB9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlRmxvd2luZycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGU7XG4gICAgfVxuICB9XG59KTsgLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5maXJzdCgpO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbnN1bWUobiwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlJywgc3RhdGUuZW5kRW1pdHRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZU5UJywgc3RhdGUuZW5kRW1pdHRlZCwgc3RhdGUubGVuZ3RoKTsgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUuZnJvbSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgb3B0cykge1xuICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyb20gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZnJvbScpO1xuICAgIH1cblxuICAgIHJldHVybiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuLyogPHJlcGxhY2VtZW50PiAqL1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59IC8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5cblxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0NBTk5PVF9QSVBFLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gICAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXG4gICAgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCxcbiAgICBFUlJfVU5LTk9XTl9FTkNPRElORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9VTktOT1dOX0VOQ09ESU5HO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcbiAgLy8gZS5nLiBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSB2cy4gb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUsIGV0Yy5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcblxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7IC8vIGRyYWluIGV2ZW50IGZsYWcuXG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTsgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcblxuICB0aGlzLmVuZGluZyA9IGZhbHNlOyAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG5cbiAgdGhpcy5lbmRlZCA9IGZhbHNlOyAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcblxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cblxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG5cbiAgdGhpcy5sZW5ndGggPSAwOyAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlOyAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG5cbiAgdGhpcy5jb3JrZWQgPSAwOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOyAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG5cbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG5cblxuICB0aGlzLndyaXRlY2IgPSBudWxsOyAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG5cbiAgdGhpcy5wZW5kaW5nY2IgPSAwOyAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG5cbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZmluaXNoJyAoYW5kIHBvdGVudGlhbGx5ICdlbmQnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7IC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuXG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTsgLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG5cblxudmFyIHJlYWxIYXNJbnN0YW5jZTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gcmVhbEhhc0luc3RhbmNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7IC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICBpZiAoIWlzRHVwbGV4ICYmICFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeS5cblxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59IC8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cblxuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUoKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7IC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG5cbiAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbn0gLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuXG5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciBlcjtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlciddLCBjaHVuayk7XG4gIH1cblxuICBpZiAoZXIpIHtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuICBpZiAoc3RhdGUuZW5kaW5nKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cblxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pOyAvLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7IC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLmRlc3Ryb3llZCkgc3RhdGUub253cml0ZShuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3dyaXRlJykpO2Vsc2UgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcblxuICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTtcbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpIHx8IHN0cmVhbS5kZXN0cm95ZWQ7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufSAvLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cblxuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59IC8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5cblxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7IC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG5cbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07IC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7IC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfSAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG5cblxuICBpZiAoIXN0YXRlLmVuZGluZykgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nICYmICFzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcblxuICAgICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgICAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAgICAgICBpZiAoIXJTdGF0ZSB8fCByU3RhdGUuYXV0b0Rlc3Ryb3kgJiYgclN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuXG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzcy5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcblxuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfSAvLyByZXVzZSB0aGUgZnJlZSBjb3JrUmVxLlxuXG5cbiAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgZmluaXNoZWQgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcblxudmFyIGtMYXN0UmVzb2x2ZSA9IFN5bWJvbCgnbGFzdFJlc29sdmUnKTtcbnZhciBrTGFzdFJlamVjdCA9IFN5bWJvbCgnbGFzdFJlamVjdCcpO1xudmFyIGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcbnZhciBrRW5kZWQgPSBTeW1ib2woJ2VuZGVkJyk7XG52YXIga0xhc3RQcm9taXNlID0gU3ltYm9sKCdsYXN0UHJvbWlzZScpO1xudmFyIGtIYW5kbGVQcm9taXNlID0gU3ltYm9sKCdoYW5kbGVQcm9taXNlJyk7XG52YXIga1N0cmVhbSA9IFN5bWJvbCgnc3RyZWFtJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZG9uZTogZG9uZVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWFkQW5kUmVzb2x2ZShpdGVyKSB7XG4gIHZhciByZXNvbHZlID0gaXRlcltrTGFzdFJlc29sdmVdO1xuXG4gIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgdmFyIGRhdGEgPSBpdGVyW2tTdHJlYW1dLnJlYWQoKTsgLy8gd2UgZGVmZXIgaWYgZGF0YSBpcyBudWxsXG4gICAgLy8gd2UgY2FuIGJlIGV4cGVjdGluZyBlaXRoZXIgJ2VuZCcgb3JcbiAgICAvLyAnZXJyb3InXG5cbiAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgaXRlcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25SZWFkYWJsZShpdGVyKSB7XG4gIC8vIHdlIHdhaXQgZm9yIHRoZSBuZXh0IHRpY2ssIGJlY2F1c2UgaXQgbWlnaHRcbiAgLy8gZW1pdCBhbiBlcnJvciB3aXRoIHByb2Nlc3MubmV4dFRpY2tcbiAgcHJvY2Vzcy5uZXh0VGljayhyZWFkQW5kUmVzb2x2ZSwgaXRlcik7XG59XG5cbmZ1bmN0aW9uIHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCBpdGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGFzdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXRlcltrRW5kZWRdKSB7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpdGVyW2tIYW5kbGVQcm9taXNlXShyZXNvbHZlLCByZWplY3QpO1xuICAgIH0sIHJlamVjdCk7XG4gIH07XG59XG5cbnZhciBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uICgpIHt9KTtcbnZhciBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YoKF9PYmplY3Qkc2V0UHJvdG90eXBlTyA9IHtcbiAgZ2V0IHN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpc1trU3RyZWFtXTtcbiAgfSxcblxuICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGRldGVjdGVkIGFuIGVycm9yIGluIHRoZSBtZWFud2hpbGVcbiAgICAvLyByZWplY3Qgc3RyYWlnaHQgYXdheVxuICAgIHZhciBlcnJvciA9IHRoaXNba0Vycm9yXTtcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRW5kZWRdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba1N0cmVhbV0uZGVzdHJveWVkKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGRlZmVyIHZpYSBuZXh0VGljayBiZWNhdXNlIGlmIC5kZXN0cm95KGVycikgaXNcbiAgICAgIC8vIGNhbGxlZCwgdGhlIGVycm9yIHdpbGwgYmUgZW1pdHRlZCB2aWEgbmV4dFRpY2ssIGFuZFxuICAgICAgLy8gd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IHRoZXJlIGlzIG5vIGVycm9yIGxpbmdlcmluZyBhcm91bmRcbiAgICAgIC8vIHdhaXRpbmcgdG8gYmUgZW1pdHRlZC5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpc1trRXJyb3JdKSB7XG4gICAgICAgICAgICByZWplY3QoX3RoaXNba0Vycm9yXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSAvLyBpZiB3ZSBoYXZlIG11bHRpcGxlIG5leHQoKSBjYWxsc1xuICAgIC8vIHdlIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIFByb21pc2UgdG8gZmluaXNoXG4gICAgLy8gdGhpcyBsb2dpYyBpcyBvcHRpbWl6ZWQgdG8gc3VwcG9ydCBmb3IgYXdhaXQgbG9vcHMsXG4gICAgLy8gd2hlcmUgbmV4dCgpIGlzIG9ubHkgY2FsbGVkIG9uY2UgYXQgYSB0aW1lXG5cblxuICAgIHZhciBsYXN0UHJvbWlzZSA9IHRoaXNba0xhc3RQcm9taXNlXTtcbiAgICB2YXIgcHJvbWlzZTtcblxuICAgIGlmIChsYXN0UHJvbWlzZSkge1xuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhc3QgcGF0aCBuZWVkZWQgdG8gc3VwcG9ydCBtdWx0aXBsZSB0aGlzLnB1c2goKVxuICAgICAgLy8gd2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBuZXh0KCkgcXVldWVcbiAgICAgIHZhciBkYXRhID0gdGhpc1trU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2UodGhpc1trSGFuZGxlUHJvbWlzZV0pO1xuICAgIH1cblxuICAgIHRoaXNba0xhc3RQcm9taXNlXSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn0sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFwicmV0dXJuXCIsIGZ1bmN0aW9uIF9yZXR1cm4oKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIC8vIGRlc3Ryb3koZXJyLCBjYikgaXMgYSBwcml2YXRlIEFQSVxuICAvLyB3ZSBjYW4gZ3VhcmFudGVlIHdlIGhhdmUgdGhhdCBoZXJlLCBiZWNhdXNlIHdlIGNvbnRyb2wgdGhlXG4gIC8vIFJlYWRhYmxlIGNsYXNzIHRoaXMgaXMgYXR0YWNoZWQgdG9cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBfdGhpczJba1N0cmVhbV0uZGVzdHJveShudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9KTtcbiAgfSk7XG59KSwgX09iamVjdCRzZXRQcm90b3R5cGVPKSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG5cbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtKSB7XG4gIHZhciBfT2JqZWN0JGNyZWF0ZTtcblxuICB2YXIgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgKF9PYmplY3QkY3JlYXRlID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga1N0cmVhbSwge1xuICAgIHZhbHVlOiBzdHJlYW0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZXNvbHZlLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZWplY3QsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRXJyb3IsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRW5kZWQsIHtcbiAgICB2YWx1ZTogc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0hhbmRsZVByb21pc2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZGF0YSA9IGl0ZXJhdG9yW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSByZXNvbHZlO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSByZWplY3Q7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX09iamVjdCRjcmVhdGUpKTtcbiAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gIGZpbmlzaGVkKHN0cmVhbSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScpIHtcbiAgICAgIHZhciByZWplY3QgPSBpdGVyYXRvcltrTGFzdFJlamVjdF07IC8vIHJlamVjdCBpZiB3ZSBhcmUgd2FpdGluZyBmb3IgZGF0YSBpbiB0aGUgUHJvbWlzZVxuICAgICAgLy8gcmV0dXJuZWQgYnkgbmV4dCgpIGFuZCBzdG9yZSB0aGUgZXJyb3JcblxuICAgICAgaWYgKHJlamVjdCAhPT0gbnVsbCkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRvcltrRXJyb3JdID0gZXJyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlID0gaXRlcmF0b3Jba0xhc3RSZXNvbHZlXTtcblxuICAgIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpdGVyYXRvcltrRW5kZWRdID0gdHJ1ZTtcbiAgfSk7XG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBvblJlYWRhYmxlLmJpbmQobnVsbCwgaXRlcmF0b3IpKTtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7IiwiJ3VzZSBzdHJpY3QnOyAvLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5cbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfSAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG5cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZiwgZXJyKSB7XG4gIGVtaXRFcnJvck5UKHNlbGYsIGVycik7XG4gIGVtaXRDbG9zZU5UKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGlmIChzZWxmLl93cml0YWJsZVN0YXRlICYmICFzZWxmLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBpZiAoc2VsZi5fcmVhZGFibGVTdGF0ZSAmJiAhc2VsZi5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgc2VsZi5lbWl0KCdjbG9zZScpO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbmZ1bmN0aW9uIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKSB7XG4gIC8vIFdlIGhhdmUgdGVzdHMgdGhhdCByZWx5IG9uIGVycm9ycyBiZWluZyBlbWl0dGVkXG4gIC8vIGluIHRoZSBzYW1lIHRpY2ssIHNvIGNoYW5naW5nIHRoaXMgaXMgc2VtdmVyIG1ham9yLlxuICAvLyBGb3Igbm93IHdoZW4geW91IG9wdC1pbiB0byBhdXRvRGVzdHJveSB3ZSBhbGxvd1xuICAvLyB0aGUgZXJyb3IgdG8gYmUgZW1pdHRlZCBuZXh0VGljay4gSW4gYSBmdXR1cmVcbiAgLy8gc2VtdmVyIG1ham9yIHVwZGF0ZSB3ZSBzaG91bGQgY2hhbmdlIHRoZSBkZWZhdWx0IHRvIHRoaXMuXG4gIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7ZWxzZSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3ksXG4gIGVycm9yT3JEZXN0cm95OiBlcnJvck9yRGVzdHJveVxufTsiLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL3R5cGVzLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcmd1bWVudHNPYmplY3QgPSByZXF1aXJlKCdpcy1hcmd1bWVudHMnKTtcbnZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gcmVxdWlyZSgnaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uJyk7XG52YXIgd2hpY2hUeXBlZEFycmF5ID0gcmVxdWlyZSgnd2hpY2gtdHlwZWQtYXJyYXknKTtcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmLmNhbGwuYmluZChmKTtcbn1cblxudmFyIEJpZ0ludFN1cHBvcnRlZCA9IHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIFN5bWJvbFN1cHBvcnRlZCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgT2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIG51bWJlclZhbHVlID0gdW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBzdHJpbmdWYWx1ZSA9IHVuY3VycnlUaGlzKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgYm9vbGVhblZhbHVlID0gdW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZik7XG5cbmlmIChCaWdJbnRTdXBwb3J0ZWQpIHtcbiAgdmFyIGJpZ0ludFZhbHVlID0gdW5jdXJyeVRoaXMoQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuaWYgKFN5bWJvbFN1cHBvcnRlZCkge1xuICB2YXIgc3ltYm9sVmFsdWUgPSB1bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBwcm90b3R5cGVWYWx1ZU9mKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgcHJvdG90eXBlVmFsdWVPZih2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnRzLmlzQXJndW1lbnRzT2JqZWN0ID0gaXNBcmd1bWVudHNPYmplY3Q7XG5leHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBpc0dlbmVyYXRvckZ1bmN0aW9uO1xuZXhwb3J0cy5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG5cbi8vIFRha2VuIGZyb20gaGVyZSBhbmQgbW9kaWZpZWQgZm9yIGJldHRlciBicm93c2VyIHN1cHBvcnRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcC1pcy1wcm9taXNlL2Jsb2IvY2RhMzVhNTEzYmRhMDNmOTc3YWQ1Y2RlM2EwNzlkMjM3ZTgyZDdlZi9pbmRleC5qc1xuZnVuY3Rpb24gaXNQcm9taXNlKGlucHV0KSB7XG5cdHJldHVybiAoXG5cdFx0KFxuXHRcdFx0dHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRpbnB1dCBpbnN0YW5jZW9mIFByb21pc2Vcblx0XHQpIHx8XG5cdFx0KFxuXHRcdFx0aW5wdXQgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC50aGVuID09PSAnZnVuY3Rpb24nICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQuY2F0Y2ggPT09ICdmdW5jdGlvbidcblx0XHQpXG5cdCk7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIGlzVHlwZWRBcnJheSh2YWx1ZSkgfHxcbiAgICBpc0RhdGFWaWV3KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyVmlldyA9IGlzQXJyYXlCdWZmZXJWaWV3O1xuXG5cbmZ1bmN0aW9uIGlzVWludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4QXJyYXkgPSBpc1VpbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDhDbGFtcGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OENsYW1wZWRBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhDbGFtcGVkQXJyYXkgPSBpc1VpbnQ4Q2xhbXBlZEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQxNkFycmF5ID0gaXNVaW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MzJBcnJheSA9IGlzVWludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQ4QXJyYXkgPSBpc0ludDhBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MTZBcnJheSA9IGlzSW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MzJBcnJheSA9IGlzSW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0MzJBcnJheSA9IGlzRmxvYXQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0NjRBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQ2NEFycmF5ID0gaXNGbG9hdDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnSW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ0ludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ0ludDY0QXJyYXkgPSBpc0JpZ0ludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnVWludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdVaW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnVWludDY0QXJyYXkgPSBpc0JpZ1VpbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcF0nO1xufVxuaXNNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc01hcFRvU3RyaW5nKG5ldyBNYXAoKSlcbik7XG5cbmZ1bmN0aW9uIGlzTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIE1hcDtcbn1cbmV4cG9ydHMuaXNNYXAgPSBpc01hcDtcblxuZnVuY3Rpb24gaXNTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXRdJztcbn1cbmlzU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNTZXRUb1N0cmluZyhuZXcgU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTZXRUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2V0O1xufVxuZXhwb3J0cy5pc1NldCA9IGlzU2V0O1xuXG5mdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrTWFwXSc7XG59XG5pc1dlYWtNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXAoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1dlYWtNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgV2Vha01hcDtcbn1cbmV4cG9ydHMuaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuXG5mdW5jdGlvbiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrU2V0XSc7XG59XG5pc1dlYWtTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cbmlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIoKSlcbik7XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGFWaWV3XSc7XG59XG5pc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzRGF0YVZpZXdUb1N0cmluZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpLCAwLCAxKSlcbik7XG5mdW5jdGlvbiBpc0RhdGFWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3O1xufVxuZXhwb3J0cy5pc0RhdGFWaWV3ID0gaXNEYXRhVmlldztcblxuLy8gU3RvcmUgYSBjb3B5IG9mIFNoYXJlZEFycmF5QnVmZmVyIGluIGNhc2UgaXQncyBkZWxldGVkIGVsc2V3aGVyZVxudmFyIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgPyBTaGFyZWRBcnJheUJ1ZmZlciA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nO1xufVxuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID09PSAndW5kZWZpbmVkJykge1xuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBTaGFyZWRBcnJheUJ1ZmZlckNvcHkoKSk7XG4gIH1cblxuICByZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5O1xufVxuZXhwb3J0cy5pc1NoYXJlZEFycmF5QnVmZmVyID0gaXNTaGFyZWRBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJztcbn1cbmV4cG9ydHMuaXNBc3luY0Z1bmN0aW9uID0gaXNBc3luY0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc01hcEl0ZXJhdG9yID0gaXNNYXBJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXQgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNTZXRJdGVyYXRvciA9IGlzU2V0SXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEdlbmVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc0dlbmVyYXRvck9iamVjdCA9IGlzR2VuZXJhdG9yT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXSc7XG59XG5leHBvcnRzLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSA9IGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtcblxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIG51bWJlclZhbHVlKTtcbn1cbmV4cG9ydHMuaXNOdW1iZXJPYmplY3QgPSBpc051bWJlck9iamVjdDtcblxuZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN0cmluZ1ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTdHJpbmdPYmplY3QgPSBpc1N0cmluZ09iamVjdDtcblxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBib29sZWFuVmFsdWUpO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW5PYmplY3QgPSBpc0Jvb2xlYW5PYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBCaWdJbnRTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYmlnSW50VmFsdWUpO1xufVxuZXhwb3J0cy5pc0JpZ0ludE9iamVjdCA9IGlzQmlnSW50T2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gU3ltYm9sU3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHN5bWJvbFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNTeW1ib2xPYmplY3QgPSBpc1N5bWJvbE9iamVjdDtcblxuZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0JpZ0ludE9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N5bWJvbE9iamVjdCh2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNCb3hlZFByaW1pdGl2ZSA9IGlzQm94ZWRQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHxcbiAgICBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FueUFycmF5QnVmZmVyID0gaXNBbnlBcnJheUJ1ZmZlcjtcblxuWydpc1Byb3h5JywgJ2lzRXh0ZXJuYWwnLCAnaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbWV0aG9kLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArICcgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZCcpO1xuICAgIH1cbiAgfSk7XG59KTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzY3JpcHRvcnNba2V5c1tpXV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfTtcblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZSZWdleCA9IC9eJC87XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSB7XG4gIHZhciBkZWJ1Z0VudiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUc7XG4gIGRlYnVnRW52ID0gZGVidWdFbnYucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCs/Ll0vZywgJ1xcXFwkJicpXG4gICAgLnJlcGxhY2UoL1xcKi9nLCAnLionKVxuICAgIC5yZXBsYWNlKC8sL2csICckfF4nKVxuICAgIC50b1VwcGVyQ2FzZSgpO1xuICBkZWJ1Z0VudlJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBkZWJ1Z0VudiArICckJywgJ2knKTtcbn1cbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAoZGVidWdFbnZSZWdleC50ZXN0KHNldCkpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZXhwb3J0cy50eXBlcyA9IHJlcXVpcmUoJy4vc3VwcG9ydC90eXBlcycpO1xuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuZXhwb3J0cy50eXBlcy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcbmV4cG9ydHMudHlwZXMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5leHBvcnRzLnR5cGVzLmlzTmF0aXZlRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciB0b1N0clRhZ3MgPSB7fTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0aWYgKHR5cGVvZiBnW3R5cGVkQXJyYXldID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRcdGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG5cdFx0XHRcdHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG5cdFx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdFx0dmFyIHN1cGVyUHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG5cdFx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b1N0clRhZ3NbdHlwZWRBcnJheV0gPSBkZXNjcmlwdG9yLmdldDtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgZm91bmROYW1lID0gZmFsc2U7XG5cdGZvckVhY2godG9TdHJUYWdzLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFmb3VuZE5hbWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBuYW1lID0gZ2V0dGVyLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRpZiAobmFtZSA9PT0gdHlwZWRBcnJheSkge1xuXHRcdFx0XHRcdGZvdW5kTmFtZSA9IG5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGZvdW5kTmFtZTtcbn07XG5cbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIWlzVHlwZWRBcnJheSh2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcgfHwgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpKSB7IHJldHVybiAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpOyB9XG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuIl19
