(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// handles audio files and raw, mono, audio buffers

module.exports = function(context, buff, cb){
  
  var name = buff.constructor.name
  //if(Math.random() < .05) console.log(buff)
  if(name == 'ArrayBuffer'){
    context.decodeAudioData(buff).then(function(data){
      var source = context.createBufferSource()
      source.buffer = data
/*      var gain = context.createGain()
      gain.channelCount = 1
      gain.channelCountMode = 'explicit'
      gain.channelInterpretation = 'speakers'
      source.connect(gain)
      source._connect = source.connect
      source.connect = gain.connect
 */     cb(null, source) 
    }).catch(function(err){cb(err, null)})
	
  }else if(name == 'Array'){
  
    var source = context.createBufferSource();
      
    var buffer = context.createBuffer(2, buff[0].length, context.sampleRate)

    try{ // new
      buffer.copyToChannel(buff[0], 0, 0)
      buffer.copyToChannel(buff[1], 1, 0)

    }catch(err){ // old
      //buffer.getChannelData(0).set(buff)
    }
    
    source.buffer = buffer;
    
    /*
    var gain = context.createGain()
    gain.channelCount = 2
    gain.channelCountMode = 'explicit'
    gain.channelInterpretation = 'speakers'
    source.gain = gain
    source.connect(gain)
    source._connect = source.connect
    source.connect = gain.connect
    if(cb) cb(null, source)
    */
    return source
  }
}

},{}],2:[function(require,module,exports){
module.exports = function(master, stream){
    var node = master.createMediaStreamSource(stream)
    var gain = master.createGain()
    gain.channelCount = 1
    gain.channelCountMode = 'explicit'
    gain. channelInterpretation = 'speakers'
    node.connect(gain)
    return gain
}

},{}],3:[function(require,module,exports){
(function (process,Buffer){(function (){

require('domready')(re => {
  const WebAudioContext = window.AudioContext || window.webkitAudioContext
  var master 
  var h = require('hyperscript')
  var ui = require('getids')()
  var bus = require('./sharedEmitter')
  bus.once('iframeLoaded', e => {
    console.log(e)
    bus.emit('pong', {goat: 1})
    bus.on('clock', e => console.log(e))
  })
  //var iframe = require('../iframarfi')
  //var peering = iframe(require('./peering.js'))
  //ui.peering.appendChild(peering)
  
  var Peer = require('simple-peer')
  var signalhub = require('signalhub')
  const {makeAutoObservable,  autorun} = require('mobx')
  const short = require('short-uuid');
  const toa = require('to-arraybuffer')
  const btob = require('blob-to-buffer')
  const thru = require('through2')
  var store = require('store')
  const Time = require('../since-when')
  var jmic = require('../jsynth-mic/stream')
  var sampler = require('../jsynth-file-sample')
  var media 
  var runp =require('run-waterfall')
  var qs = require('querystring')
  var nana = require('nanohref')
  var minimist = require('minimist')
  var argv = minimist(process.argv, {
    default: {
      host: 'folkstack.com',
      port: 80,
      protocol: 'https'
    }
  })
  var debub = signalhub('https://folkstack.com:80', 'debug')
  //var ret=debub.subscribe('return')

  var app 

  window.store = store
  store.clearAll();
  runp([initState, initUI], (err, app)=>{
    app = app

    ui.init.addEventListener('change', e => {
      app._log('init')

      try{
        runp([captureSource, captureSink, captureNetwork, initAudio, initCast(app)].reverse(), (err, app)=>{
          console.log(err, app)
          //app.audio.sourceStream.pipe(app.audio.sinkStream) // heh
          if(app.session.broadcasting) {
            app.network.distance = 1
//            app.network.sourceStream = app.audio.sourceStream
            app.network.isSeekWorthy()
            app.network.allowCalls(app.session.stream)
          
          }
          else app.network.sourceSeek()
      })} catch (err){
        app._log(err)
      }
    })
    
  })

  var ael = ui.player
  var mime = 'audio/ogg;codecs=opus'


  function initState(cb){

    class App {
    
      constructor(){
        this.mic = 1/2
        this.monitor = 0
        this.call = 1/2
        this.track = 1/2
        this.quality = 64000
        this.update = null
        makeAutoObservable(this)
      }

      setGain(dial, value){
        this[dial] = value
        this.update = [dial, value]
      }
    
    }

    const app = new App
    bus.on('appStateChange', e =>{
      app.setGain(e[0], e[1])
    })
    var session = store.get('session')
    if(!session) session = {id: short().generate().split().reverse().join().slice(0,11)}
    session.broadcasting = true
    var q = qs.parse(window.location.search.slice(1))
    if(q.stream) {
      session.stream = q.stream
      session.broadcasting = false 
    }
    else {
      session.stream = session.stream || short().generate().split().reverse().join().slice(0,11)
    }

    app.session = session
  app._log = function(_id) { return e => {
      //ui.debug.appendChild(h('p', e.toString()))    
      debub.broadcast('debug', JSON.stringify({id: _id, log: e}))
  } }(session.id)
    store.set('session', session)
    console.log(app)
    cb(null, app)
  }

  function initAudio(app, cb){
    const audio = {}
    var OpusMediaRecorder = require('opus-media-recorder') 
    window.MediaRecorder = OpusMediaRecorder;
    master = new WebAudioContext({sampleRate: 48000})
    audio.master = master
    audio.broadcastmixer = master.createChannelMerger(2)
    audio.callmixer = master.createChannelMerger(2)
    audio.broadcaststream = master.createMediaStreamDestination()
    audio.callstream = master.createMediaStreamDestination()
    audio.monitor = master.createGain()
    audio.mic = master.createGain()
    audio.call = master.createGain()
    audio.trackmixer = master.createChannelMerger(2)
    audio.track = master.createGain()
    audio.trackmixer.connect(audio.track)

    audio.broadcastmixer.connect(audio.broadcaststream)
    //audio.broadcastmixer.connect(audio.monitor)

    audio.callmixer.connect(audio.callstream)
    //audio.callmixer.connect(audio.monitor)


    audio.mic.connect(audio.monitor)
    audio.call.connect(audio.monitor)
    audio.track.connect(audio.monitor)
    audio.monitor.connect(master.destination)

    audio.mic.connect(audio.broadcastmixer)
    //audio.track.connect(audio.broadcastmixer)
    //audio.call.connect(audio.broadcastmixer)

    //audio.mic.connect(audio.callmixer)
    //audio.track.connect(audio.callmixer)

    audio.broadcastmixer.connect(audio.broadcaststream)
    audio.callmixer.connect(audio.callstream)
    
    const workerOptions = {
      encoderWorkerFactory: function () {
        // UMD should be used if you don't use a web worker bundler for this.
        return new Worker(tob(Buffer("CihmdW5jdGlvbiBPcHVzTWVkaWFXb3JrZXJVTUQocm9vdCwgZmFjdG9yeSkgewogIGlmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmCiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHsKICAgIHZhciBpbml0V29ya2VyID0gZmFjdG9yeSgpOwogICAgaW5pdFdvcmtlcigpOwogIH0KCWVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKQoJCW1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOwoJZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpCgkJZGVmaW5lKFtdLCBmYWN0b3J5KTsKCWVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKQoJCWV4cG9ydHNbImVuY29kZXJXb3JrZXIiXSA9IGZhY3RvcnkoKTsKCWVsc2UKCQlyb290WyJlbmNvZGVyV29ya2VyIl0gPSBmYWN0b3J5KCk7Cn0pKHR5cGVvZiBPcHVzTWVkaWFSZWNvcmRlciAhPT0gJ3VuZGVmaW5lZCcgPyBPcHVzTWVkaWFSZWNvcmRlciA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHsKcmV0dXJuIGZ1bmN0aW9uKCkgeyFmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiBuKHIpe2lmKHRbcl0pcmV0dXJuIHRbcl0uZXhwb3J0czt2YXIgbz10W3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtyXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxuKSxvLmw9ITAsby5leHBvcnRzfW4ubT1lLG4uYz10LG4uZD1mdW5jdGlvbihlLHQscil7bi5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0OnJ9KX0sbi5yPWZ1bmN0aW9uKGUpeyJ1bmRlZmluZWQiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6Ik1vZHVsZSJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSl9LG4udD1mdW5jdGlvbihlLHQpe2lmKDEmdCYmKGU9bihlKSksOCZ0KXJldHVybiBlO2lmKDQmdCYmIm9iamVjdCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHI9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihuLnIociksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJiJzdHJpbmciIT10eXBlb2YgZSlmb3IodmFyIG8gaW4gZSluLmQocixvLGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfS5iaW5kKG51bGwsbykpO3JldHVybiByfSxuLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIG4uZCh0LCJhIix0KSx0fSxuLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LG4ucD0iIixuKG4ucz01KX0oW2Z1bmN0aW9uKGUsdCxuKXsoZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihlLHQpe2Zvcih2YXIgbj0wLHI9ZS5sZW5ndGgtMTtyPj0wO3ItLSl7dmFyIG89ZVtyXTsiLiI9PT1vP2Uuc3BsaWNlKHIsMSk6Ii4uIj09PW8/KGUuc3BsaWNlKHIsMSksbisrKTpuJiYoZS5zcGxpY2UociwxKSxuLS0pfWlmKHQpZm9yKDtuLS07billLnVuc2hpZnQoIi4uIik7cmV0dXJuIGV9ZnVuY3Rpb24gcihlLHQpe2lmKGUuZmlsdGVyKXJldHVybiBlLmZpbHRlcih0KTtmb3IodmFyIG49W10scj0wO3I8ZS5sZW5ndGg7cisrKXQoZVtyXSxyLGUpJiZuLnB1c2goZVtyXSk7cmV0dXJuIG59dC5yZXNvbHZlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PSIiLG89ITEsaT1hcmd1bWVudHMubGVuZ3RoLTE7aT49LTEmJiFvO2ktLSl7dmFyIHU9aT49MD9hcmd1bWVudHNbaV06ZS5jd2QoKTtpZigic3RyaW5nIiE9dHlwZW9mIHUpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MiKTt1JiYodD11KyIvIit0LG89Ii8iPT09dS5jaGFyQXQoMCkpfXJldHVybihvPyIvIjoiIikrKHQ9bihyKHQuc3BsaXQoIi8iKSwoZnVuY3Rpb24oZSl7cmV0dXJuISFlfSkpLCFvKS5qb2luKCIvIikpfHwiLiJ9LHQubm9ybWFsaXplPWZ1bmN0aW9uKGUpe3ZhciBpPXQuaXNBYnNvbHV0ZShlKSx1PSIvIj09PW8oZSwtMSk7cmV0dXJuKGU9bihyKGUuc3BsaXQoIi8iKSwoZnVuY3Rpb24oZSl7cmV0dXJuISFlfSkpLCFpKS5qb2luKCIvIikpfHxpfHwoZT0iLiIpLGUmJnUmJihlKz0iLyIpLChpPyIvIjoiIikrZX0sdC5pc0Fic29sdXRlPWZ1bmN0aW9uKGUpe3JldHVybiIvIj09PWUuY2hhckF0KDApfSx0LmpvaW49ZnVuY3Rpb24oKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cmV0dXJuIHQubm9ybWFsaXplKHIoZSwoZnVuY3Rpb24oZSx0KXtpZigic3RyaW5nIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MiKTtyZXR1cm4gZX0pKS5qb2luKCIvIikpfSx0LnJlbGF0aXZlPWZ1bmN0aW9uKGUsbil7ZnVuY3Rpb24gcihlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoJiYiIj09PWVbdF07dCsrKTtmb3IodmFyIG49ZS5sZW5ndGgtMTtuPj0wJiYiIj09PWVbbl07bi0tKTtyZXR1cm4gdD5uP1tdOmUuc2xpY2UodCxuLXQrMSl9ZT10LnJlc29sdmUoZSkuc3Vic3RyKDEpLG49dC5yZXNvbHZlKG4pLnN1YnN0cigxKTtmb3IodmFyIG89cihlLnNwbGl0KCIvIikpLGk9cihuLnNwbGl0KCIvIikpLHU9TWF0aC5taW4oby5sZW5ndGgsaS5sZW5ndGgpLGE9dSxzPTA7czx1O3MrKylpZihvW3NdIT09aVtzXSl7YT1zO2JyZWFrfXZhciBjPVtdO2ZvcihzPWE7czxvLmxlbmd0aDtzKyspYy5wdXNoKCIuLiIpO3JldHVybihjPWMuY29uY2F0KGkuc2xpY2UoYSkpKS5qb2luKCIvIil9LHQuc2VwPSIvIix0LmRlbGltaXRlcj0iOiIsdC5kaXJuYW1lPWZ1bmN0aW9uKGUpe2lmKCJzdHJpbmciIT10eXBlb2YgZSYmKGUrPSIiKSwwPT09ZS5sZW5ndGgpcmV0dXJuIi4iO2Zvcih2YXIgdD1lLmNoYXJDb2RlQXQoMCksbj00Nz09PXQscj0tMSxvPSEwLGk9ZS5sZW5ndGgtMTtpPj0xOy0taSlpZig0Nz09PSh0PWUuY2hhckNvZGVBdChpKSkpe2lmKCFvKXtyPWk7YnJlYWt9fWVsc2Ugbz0hMTtyZXR1cm4tMT09PXI/bj8iLyI6Ii4iOm4mJjE9PT1yPyIvIjplLnNsaWNlKDAscil9LHQuYmFzZW5hbWU9ZnVuY3Rpb24oZSx0KXt2YXIgbj1mdW5jdGlvbihlKXsic3RyaW5nIiE9dHlwZW9mIGUmJihlKz0iIik7dmFyIHQsbj0wLHI9LTEsbz0hMDtmb3IodD1lLmxlbmd0aC0xO3Q+PTA7LS10KWlmKDQ3PT09ZS5jaGFyQ29kZUF0KHQpKXtpZighbyl7bj10KzE7YnJlYWt9fWVsc2UtMT09PXImJihvPSExLHI9dCsxKTtyZXR1cm4tMT09PXI/IiI6ZS5zbGljZShuLHIpfShlKTtyZXR1cm4gdCYmbi5zdWJzdHIoLTEqdC5sZW5ndGgpPT09dCYmKG49bi5zdWJzdHIoMCxuLmxlbmd0aC10Lmxlbmd0aCkpLG59LHQuZXh0bmFtZT1mdW5jdGlvbihlKXsic3RyaW5nIiE9dHlwZW9mIGUmJihlKz0iIik7Zm9yKHZhciB0PS0xLG49MCxyPS0xLG89ITAsaT0wLHU9ZS5sZW5ndGgtMTt1Pj0wOy0tdSl7dmFyIGE9ZS5jaGFyQ29kZUF0KHUpO2lmKDQ3IT09YSktMT09PXImJihvPSExLHI9dSsxKSw0Nj09PWE/LTE9PT10P3Q9dToxIT09aSYmKGk9MSk6LTEhPT10JiYoaT0tMSk7ZWxzZSBpZighbyl7bj11KzE7YnJlYWt9fXJldHVybi0xPT09dHx8LTE9PT1yfHwwPT09aXx8MT09PWkmJnQ9PT1yLTEmJnQ9PT1uKzE/IiI6ZS5zbGljZSh0LHIpfTt2YXIgbz0iYiI9PT0iYWIiLnN1YnN0cigtMSk/ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlLnN1YnN0cih0LG4pfTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHQ8MCYmKHQ9ZS5sZW5ndGgrdCksZS5zdWJzdHIodCxuKX19KS5jYWxsKHRoaXMsbigyKSl9LGZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbihlKXtyZXR1cm4obj0iZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYic3ltYm9sIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiYiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT8ic3ltYm9sIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIHIoZSx0KXtpZigiZnVuY3Rpb24iIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcigiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24iKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmbyhlLHQpfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4obz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX0pKGUsdCl9ZnVuY3Rpb24gaShlKXt2YXIgdD1mdW5jdGlvbigpe2lmKCJ1bmRlZmluZWQiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoImZ1bmN0aW9uIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBuLHI9YShlKTtpZih0KXt2YXIgbz1hKHRoaXMpLmNvbnN0cnVjdG9yO249UmVmbGVjdC5jb25zdHJ1Y3Qocixhcmd1bWVudHMsbyl9ZWxzZSBuPXIuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB1KHRoaXMsbil9fWZ1bmN0aW9uIHUoZSx0KXtyZXR1cm4hdHx8Im9iamVjdCIhPT1uKHQpJiYiZnVuY3Rpb24iIT10eXBlb2YgdD9mdW5jdGlvbihlKXtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcigidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkIik7cmV0dXJuIGV9KGUpOnR9ZnVuY3Rpb24gYShlKXtyZXR1cm4oYT1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfSkoZSl9ZnVuY3Rpb24gcyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfWZ1bmN0aW9uIGMoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBmKGUsdCxuKXtyZXR1cm4gdCYmYyhlLnByb3RvdHlwZSx0KSxuJiZjKGUsbiksZX12YXIgbD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIsbyl7c3dpdGNoKHModGhpcyxlKSx0aGlzLl9zaXplPW4sdGhpcy5fbW9kdWxlPXQsdGhpcy5fc2l6ZSl7Y2FzZSAxOnRoaXMuX2hlYXBBcnJheT1yP3RoaXMuX21vZHVsZS5IRUFQODp0aGlzLl9tb2R1bGUuSEVBUFU4O2JyZWFrO2Nhc2UgMjp0aGlzLl9oZWFwQXJyYXk9cj90aGlzLl9tb2R1bGUuSEVBUDE2OnRoaXMuX21vZHVsZS5IRUFQVTE2O2JyZWFrO2Nhc2UgNDp0aGlzLl9oZWFwQXJyYXk9cj90aGlzLl9tb2R1bGUuSEVBUDMyOnRoaXMuX21vZHVsZS5IRUFQVTMyO2JyZWFrO2RlZmF1bHQ6dGhpcy5faGVhcEFycmF5PXRoaXMuX21vZHVsZS5IRUFQVTh9byYmKHRoaXMuX3NpemU9NCx0aGlzLl9oZWFwQXJyYXk9dGhpcy5fbW9kdWxlLkhFQVBGMzIpLHRoaXMuX3BvaW50ZXI9dGhpcy5fbW9kdWxlLl9tYWxsb2Mobil9cmV0dXJuIGYoZSxbe2tleToiZnJlZSIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9tb2R1bGUuX2ZyZWUodGhpcy5wb2ludGVyKX19LHtrZXk6InBvaW50ZXIiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wb2ludGVyfX0se2tleToidmFsdWUiLGdldDpmdW5jdGlvbigpe3ZhciBlPTA7c3dpdGNoKHRoaXMuX3NpemUpe2Nhc2UgMjplPTE7YnJlYWs7Y2FzZSA0OmU9MjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiUG9pbnRlciBjYW4gYmUgb25seSBkZWZlcmVuY2VkIGFzIGludGVnZXItc2l6ZWQiKX1yZXR1cm4gdGhpcy5faGVhcEFycmF5W3RoaXMucG9pbnRlcj4+ZV19LHNldDpmdW5jdGlvbihlKXt2YXIgdD0wO3N3aXRjaCh0aGlzLl9zaXplKXtjYXNlIDI6dD0xO2JyZWFrO2Nhc2UgNDp0PTI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIlBvaW50ZXIgY2FuIGJlIG9ubHkgZGVmZXJlbmNlZCBhcyBpbnRlZ2VyLXNpemVkIil9dGhpcy5faGVhcEFycmF5W3RoaXMucG9pbnRlcj4+dF09ZX19XSksZX0oKSxwPWZ1bmN0aW9uKGUpe3IobixlKTt2YXIgdD1pKG4pO2Z1bmN0aW9uIG4oZSxyKXt2YXIgbztyZXR1cm4gcyh0aGlzLG4pLG89dC5jYWxsKHRoaXMsZSw0LCEwLCExKSx2b2lkIDAhPT1yJiYoby52YWx1ZT1yKSxvfXJldHVybiBufShsKSxfPWZ1bmN0aW9uKGUpe3IobixlKTt2YXIgdD1pKG4pO2Z1bmN0aW9uIG4oZSxyKXt2YXIgbztyZXR1cm4gcyh0aGlzLG4pLG89dC5jYWxsKHRoaXMsZSw0LCExLCExKSx2b2lkIDAhPT1yJiYoby52YWx1ZT1yKSxvfXJldHVybiBufShsKSxkPWZ1bmN0aW9uKGUpe3IobixlKTt2YXIgdD1pKG4pO2Z1bmN0aW9uIG4oZSxyLG8saSx1KXt2YXIgYTtzKHRoaXMsbiksYT10LmNhbGwodGhpcyxlLHIqbyxpLHUpO3ZhciBjPTA7c3dpdGNoKG8pe2Nhc2UgMTphLl9oZWFwQXJyYXk9aT9hLl9tb2R1bGUuSEVBUDg6YS5fbW9kdWxlLkhFQVBVOCxjPTA7YnJlYWs7Y2FzZSAyOmEuX2hlYXBBcnJheT1pP2EuX21vZHVsZS5IRUFQMTY6YS5fbW9kdWxlLkhFQVBVMTYsYz0xO2JyZWFrO2Nhc2UgNDphLl9oZWFwQXJyYXk9aT9hLl9tb2R1bGUuSEVBUDMyOmEuX21vZHVsZS5IRUFQVTMyLGM9MjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcigiVW5pdCBzaXplIG11c3QgYmUgYW4gaW50ZWdlci1zaXplIil9dSYmKGEuX2hlYXBBcnJheT1hLl9tb2R1bGUuSEVBUEYzMixjPTIpO3ZhciBmPWEuX3BvaW50ZXI+PmM7cmV0dXJuIGEuX2J1ZmZlcj1hLl9oZWFwQXJyYXkuc3ViYXJyYXkoZixmK3IpLGEuX2xlbmd0aD1yLGF9cmV0dXJuIGYobixbe2tleToic2V0Iix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuX2J1ZmZlci5zZXQoZSx0KX19LHtrZXk6InN1YmFycmF5Iix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9idWZmZXIuc3ViYXJyYXkoZSx0KX19LHtrZXk6Imxlbmd0aCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xlbmd0aH19XSksbn0obCksaD1mdW5jdGlvbihlKXtyKG4sZSk7dmFyIHQ9aShuKTtmdW5jdGlvbiBuKGUscil7cmV0dXJuIHModGhpcyxuKSx0LmNhbGwodGhpcyxlLHIsNCwhMCwhMCl9cmV0dXJuIG59KGQpLG09ZnVuY3Rpb24oZSl7cihuLGUpO3ZhciB0PWkobik7ZnVuY3Rpb24gbihlLHIpe3JldHVybiBzKHRoaXMsbiksdC5jYWxsKHRoaXMsZSxyLDEsITEsITEpfXJldHVybiBufShkKSx5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtzKHRoaXMsZSksdGhpcy5fbW9kdWxlPXR9cmV0dXJuIGYoZSxbe2tleToibWFsbG9jSW50MzIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgcCh0aGlzLl9tb2R1bGUsZSl9fSx7a2V5OiJtYWxsb2NVaW50MzIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgXyh0aGlzLl9tb2R1bGUsZSl9fSx7a2V5OiJtYWxsb2NVaW50OEJ1ZmZlciIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBtKHRoaXMuX21vZHVsZSxlKX19LHtrZXk6Im1hbGxvY0Zsb2F0MzJCdWZmZXIiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgaCh0aGlzLl9tb2R1bGUsZSl9fV0pLGV9KCk7ZS5leHBvcnRzPXt3cml0ZVN0cmluZzpmdW5jdGlvbihlLHQsbil7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspZS5zZXRVaW50OCh0K3Isbi5jaGFyQ29kZUF0KHIpKX0sRW1zY3JpcHRlbk1lbW9yeUFsbG9jYXRvcjp5fX0sZnVuY3Rpb24oZSx0KXt2YXIgbixyLG89ZS5leHBvcnRzPXt9O2Z1bmN0aW9uIGkoKXt0aHJvdyBuZXcgRXJyb3IoInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX1mdW5jdGlvbiB1KCl7dGhyb3cgbmV3IEVycm9yKCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQiKX1mdW5jdGlvbiBhKGUpe2lmKG49PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KGUsMCk7aWYoKG49PT1pfHwhbikmJnNldFRpbWVvdXQpcmV0dXJuIG49c2V0VGltZW91dCxzZXRUaW1lb3V0KGUsMCk7dHJ5e3JldHVybiBuKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlLDApfX19IWZ1bmN0aW9uKCl7dHJ5e249ImZ1bmN0aW9uIj09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDppfWNhdGNoKGUpe249aX10cnl7cj0iZnVuY3Rpb24iPT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDp1fWNhdGNoKGUpe3I9dX19KCk7dmFyIHMsYz1bXSxmPSExLGw9LTE7ZnVuY3Rpb24gcCgpe2YmJnMmJihmPSExLHMubGVuZ3RoP2M9cy5jb25jYXQoYyk6bD0tMSxjLmxlbmd0aCYmXygpKX1mdW5jdGlvbiBfKCl7aWYoIWYpe3ZhciBlPWEocCk7Zj0hMDtmb3IodmFyIHQ9Yy5sZW5ndGg7dDspe2ZvcihzPWMsYz1bXTsrK2w8dDspcyYmc1tsXS5ydW4oKTtsPS0xLHQ9Yy5sZW5ndGh9cz1udWxsLGY9ITEsZnVuY3Rpb24oZSl7aWYocj09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KGUpO2lmKChyPT09dXx8IXIpJiZjbGVhclRpbWVvdXQpcmV0dXJuIHI9Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dChlKTt0cnl7cihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlKX19fShlKX19ZnVuY3Rpb24gZChlLHQpe3RoaXMuZnVuPWUsdGhpcy5hcnJheT10fWZ1bmN0aW9uIGgoKXt9by5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciBuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0W24tMV09YXJndW1lbnRzW25dO2MucHVzaChuZXcgZChlLHQpKSwxIT09Yy5sZW5ndGh8fGZ8fGEoXyl9LGQucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LG8udGl0bGU9ImJyb3dzZXIiLG8uYnJvd3Nlcj0hMCxvLmVudj17fSxvLmFyZ3Y9W10sby52ZXJzaW9uPSIiLG8udmVyc2lvbnM9e30sby5vbj1oLG8uYWRkTGlzdGVuZXI9aCxvLm9uY2U9aCxvLm9mZj1oLG8ucmVtb3ZlTGlzdGVuZXI9aCxvLnJlbW92ZUFsbExpc3RlbmVycz1oLG8uZW1pdD1oLG8ucHJlcGVuZExpc3RlbmVyPWgsby5wcmVwZW5kT25jZUxpc3RlbmVyPWgsby5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119LG8uYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkIil9LG8uY3dkPWZ1bmN0aW9uKCl7cmV0dXJuIi8ifSxvLmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcigicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkIil9LG8udW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBlLndlYnBhY2tQb2x5ZmlsbHx8KGUuZGVwcmVjYXRlPWZ1bmN0aW9uKCl7fSxlLnBhdGhzPVtdLGUuY2hpbGRyZW58fChlLmNoaWxkcmVuPVtdKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwibG9hZGVkIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZS5sfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJpZCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGUuaX19KSxlLndlYnBhY2tQb2x5ZmlsbD0xKSxlfX0sZnVuY3Rpb24oZSx0KXt9LGZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUpe3ZhciB0LHI9big2KSxvPW4oNyksaT1uKDgpO2Uub25tZXNzYWdlPWZ1bmN0aW9uKGUpe3ZhciBuPWUuZGF0YS5jb21tYW5kO3N3aXRjaChuKXtjYXNlImxvYWRFbmNvZGVyIjp2YXIgdSxhPWUuZGF0YSxzPWEubWltZVR5cGUsYz1hLndhc21QYXRoO3N3aXRjaChzKXtjYXNlImF1ZGlvL3dhdiI6Y2FzZSJhdWRpby93YXZlIjp1PXI7YnJlYWs7Y2FzZSJhdWRpby93ZWJtIjp1PW87YnJlYWs7Y2FzZSJhdWRpby9vZ2ciOnU9aX12YXIgZj17fTtjJiYoZi5sb2NhdGVGaWxlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubWF0Y2goLy53YXNtLyk/Yzp0K2V9KSx1KGYpLnRoZW4oKGZ1bmN0aW9uKGUpe3Q9ZSxzZWxmLnBvc3RNZXNzYWdlKHtjb21tYW5kOiJyZWFkeVRvSW5pdCJ9KX0pKTticmVhaztjYXNlImluaXQiOnZhciBsPWUuZGF0YSxwPWwuc2FtcGxlUmF0ZSxfPWwuY2hhbm5lbENvdW50LGQ9bC5iaXRzUGVyU2Vjb25kO3QuaW5pdChwLF8sZCk7YnJlYWs7Y2FzZSJwdXNoSW5wdXREYXRhIjpmb3IodmFyIGg9ZS5kYXRhLG09aC5jaGFubmVsQnVmZmVycyx5PShoLmxlbmd0aCxoLmR1cmF0aW9uLDApO3k8bS5sZW5ndGg7eSsrKW1beV09bmV3IEZsb2F0MzJBcnJheShtW3ldLmJ1ZmZlcik7dC5lbmNvZGUobSk7YnJlYWs7Y2FzZSJnZXRFbmNvZGVkRGF0YSI6Y2FzZSJkb25lIjoiZG9uZSI9PT1uJiZ0LmNsb3NlKCk7dmFyIHY9dC5mbHVzaCgpO3NlbGYucG9zdE1lc3NhZ2Uoe2NvbW1hbmQ6ImRvbmUiPT09bj8ibGFzdEVuY29kZWREYXRhIjoiZW5jb2RlZERhdGEiLGJ1ZmZlcnM6dn0sdiksImRvbmUiPT09biYmc2VsZi5jbG9zZSgpfX19InVuZGVmaW5lZCIhPXR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSYmc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlJiZyKHNlbGYpLGUuZXhwb3J0cz1yfSxmdW5jdGlvbihlLHQsbil7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gbyhlKX0oZSl8fGZ1bmN0aW9uKGUpe2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpKXJldHVybiBBcnJheS5mcm9tKGUpfShlKXx8ZnVuY3Rpb24oZSx0KXtpZighZSlyZXR1cm47aWYoInN0cmluZyI9PXR5cGVvZiBlKXJldHVybiBvKGUsdCk7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpOyJPYmplY3QiPT09biYmZS5jb25zdHJ1Y3RvciYmKG49ZS5jb25zdHJ1Y3Rvci5uYW1lKTtpZigiTWFwIj09PW58fCJTZXQiPT09bilyZXR1cm4gQXJyYXkuZnJvbShlKTtpZigiQXJndW1lbnRzIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKXJldHVybiBvKGUsdCl9KGUpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLiIpfSgpfWZ1bmN0aW9uIG8oZSx0KXsobnVsbD09dHx8dD5lLmxlbmd0aCkmJih0PWUubGVuZ3RoKTtmb3IodmFyIG49MCxyPW5ldyBBcnJheSh0KTtuPHQ7bisrKXJbbl09ZVtuXTtyZXR1cm4gcn1mdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsInZhbHVlImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19dmFyIHU9bigxKS53cml0ZVN0cmluZyxhPUludDE2QXJyYXkuQllURVNfUEVSX0VMRU1FTlQscz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLHIpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfSh0aGlzLGUpLHRoaXMuY29uZmlnPXtpbnB1dFNhbXBsZVJhdGU6dCxjaGFubmVsQ291bnQ6bn0sdGhpcy5lbmNvZGVkQnVmZmVycz1bXX12YXIgdCxuLHI7cmV0dXJuIHQ9ZSwobj1be2tleToiZW5jb2RlIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9ZVswXS5sZW5ndGgsbj1uZXcgQXJyYXlCdWZmZXIodCphKnRoaXMuY29uZmlnLmNoYW5uZWxDb3VudCkscj1uZXcgRGF0YVZpZXcobiksbz0wO288dGhpcy5jb25maWcuY2hhbm5lbENvdW50O28rKylmb3IodmFyIGk9ZVtvXSx1PTA7dTx0O3UrKyl7dmFyIHM9MzI3NjcqaVt1XXwwO3M+MzI3Njc/cz0zMjc2NzpzPC0zMjc2OCYmKHM9LTMyNzY4KTt2YXIgYz0odSp0aGlzLmNvbmZpZy5jaGFubmVsQ291bnQrbykqYTtyLnNldEludDE2KGMsMHxzLCEwKX10aGlzLmVuY29kZWRCdWZmZXJzLnB1c2gobil9fSx7a2V5OiJnZXRIZWFkZXIiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5lbmNvZGVkQnVmZmVycy5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdC5ieXRlTGVuZ3RofSksMCksdD1uZXcgQXJyYXlCdWZmZXIoNDQpLG49bmV3IERhdGFWaWV3KHQpO3JldHVybiB1KG4sMCwiUklGRiIpLG4uc2V0VWludDMyKDQsMzYrZSwhMCksdShuLDgsIldBVkUiKSx1KG4sMTIsImZtdCAiKSxuLnNldFVpbnQzMigxNiwxNiwhMCksbi5zZXRVaW50MTYoMjAsMSwhMCksbi5zZXRVaW50MTYoMjIsdGhpcy5jb25maWcuY2hhbm5lbENvdW50LCEwKSxuLnNldFVpbnQzMigyNCx0aGlzLmNvbmZpZy5pbnB1dFNhbXBsZVJhdGUsITApLG4uc2V0VWludDMyKDI4LHRoaXMuY29uZmlnLmlucHV0U2FtcGxlUmF0ZSphKnRoaXMuY29uZmlnLmNoYW5uZWxDb3VudCwhMCksbi5zZXRVaW50MTYoMzIsYSp0aGlzLmNvbmZpZy5jaGFubmVsQ291bnQsITApLG4uc2V0VWludDE2KDM0LDgqYSwhMCksdShuLDM2LCJkYXRhIiksbi5zZXRVaW50MzIoNDAsZSwhMCksdH19XSkmJmkodC5wcm90b3R5cGUsbiksciYmaSh0LHIpLGV9KCk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxuKXsoZT12b2lkIDAhPT1lJiZlfHx7fSkuaW5pdD1mdW5jdGlvbih0LG4scil7ZS5lbmNvZGVyPW5ldyBzKHQsbixyKX0sZS5lbmNvZGU9ZnVuY3Rpb24odCl7ZS5lbmNvZGVyLmVuY29kZSh0KX0sZS5mbHVzaD1mdW5jdGlvbigpe3ZhciB0PWUuZW5jb2Rlci5nZXRIZWFkZXIoKSxuPWUuZW5jb2Rlci5lbmNvZGVkQnVmZmVycy5zcGxpY2UoMCxlLmVuY29kZXIuZW5jb2RlZEJ1ZmZlcnMubGVuZ3RoKTtyZXR1cm5bdF0uY29uY2F0KHIobikpfSxlLmNsb3NlPWZ1bmN0aW9uKCl7fSx0KGUpfSkpfX0sZnVuY3Rpb24oZSx0LG4peyhmdW5jdGlvbihlLHIsbyxpKXt2YXIgdTtmdW5jdGlvbiBhKGUpe3JldHVybihhPSJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJiJzeW1ib2wiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJiJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlPyJzeW1ib2wiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gcyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbiIpfWZ1bmN0aW9uIGMoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBmKGUsdCxuKXtyZXR1cm4gdCYmYyhlLnByb3RvdHlwZSx0KSxuJiZjKGUsbiksZX12YXIgbCxwPShsPShsPSJ1bmRlZmluZWQiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwKXx8ZSxmdW5jdGlvbihlKXtlPXZvaWQgMCE9PShlPWV8fHt9KT9lOnt9O3ZhciB0PW4oMSksaT10LkVtc2NyaXB0ZW5NZW1vcnlBbGxvY2F0b3IsdT0yMDQ5LGM9NDhlMyxwPTRlMyxfPTIwLGQ9NixoPTQwOTYsbT0wLHk9NDAwMix2PTAsYj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobixyKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dm9pZCAwO3ModGhpcyx0KSx0aGlzLmNvbmZpZz17aW5wdXRTYW1wbGVSYXRlOm4sY2hhbm5lbENvdW50OnJ9LHRoaXMubWVtb3J5PW5ldyBpKGUpLHRoaXMuX29wdXNfZW5jb2Rlcl9jcmVhdGU9ZS5fb3B1c19lbmNvZGVyX2NyZWF0ZSx0aGlzLl9vcHVzX2VuY29kZXJfY3RsPWUuX29wdXNfZW5jb2Rlcl9jdGwsdGhpcy5fb3B1c19lbmNvZGVfZmxvYXQ9ZS5fb3B1c19lbmNvZGVfZmxvYXQsdGhpcy5fb3B1c19lbmNvZGVyX2Rlc3Ryb3k9ZS5fb3B1c19lbmNvZGVyX2Rlc3Ryb3ksdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQsdGhpcy5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQ9ZS5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQsdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3k9ZS5fc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3ksdGhpcy5fY29udGFpbmVyPW5ldyBlLkNvbnRhaW5lcix0aGlzLl9jb250YWluZXIuaW5pdChjLHIsTWF0aC5mbG9vcig0Mjk0OTY3Mjk1Kk1hdGgucmFuZG9tKCkpKSx0aGlzLk9wdXNJbml0Q29kZWMoYyxyLG8pLHRoaXMuU3BlZXhJbml0UmVzYW1wbGVyKG4sYyxyKSx0aGlzLmlucHV0U2FtcGxlc1BlckNoYW5uZWw9bipfLzFlMyx0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWw9YypfLzFlMyx0aGlzLmlucHV0QnVmZmVySW5kZXg9MCx0aGlzLm1JbnB1dEJ1ZmZlcj10aGlzLm1lbW9yeS5tYWxsb2NGbG9hdDMyQnVmZmVyKHRoaXMuaW5wdXRTYW1wbGVzUGVyQ2hhbm5lbCpyKSx0aGlzLm1SZXNhbXBsZWRCdWZmZXI9dGhpcy5tZW1vcnkubWFsbG9jRmxvYXQzMkJ1ZmZlcih0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWwqciksdGhpcy5tT3V0cHV0QnVmZmVyPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQ4QnVmZmVyKHApLHRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzPTEhPT1yP25ldyBGbG9hdDMyQXJyYXkoaCpyKTp2b2lkIDB9cmV0dXJuIGYodCxbe2tleToiZW5jb2RlIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcy5pbnRlcmxlYXZlKGUpLG49MDtuPHQubGVuZ3RoOyl7dmFyIHI9TWF0aC5taW4odGhpcy5tSW5wdXRCdWZmZXIubGVuZ3RoLXRoaXMuaW5wdXRCdWZmZXJJbmRleCx0Lmxlbmd0aC1uKTtpZih0aGlzLm1JbnB1dEJ1ZmZlci5zZXQodC5zdWJhcnJheShuLG4rciksdGhpcy5pbnB1dEJ1ZmZlckluZGV4KSx0aGlzLmlucHV0QnVmZmVySW5kZXgrPXIsdGhpcy5pbnB1dEJ1ZmZlckluZGV4Pj10aGlzLm1JbnB1dEJ1ZmZlci5sZW5ndGgpe3ZhciBvPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih0aGlzLmlucHV0U2FtcGxlc1BlckNoYW5uZWwpLGk9dGhpcy5tZW1vcnkubWFsbG9jVWludDMyKHRoaXMub3V0cHV0U2FtcGxlUGVyQ2hhbm5lbCksdT10aGlzLl9zcGVleF9yZXNhbXBsZXJfcHJvY2Vzc19pbnRlcmxlYXZlZF9mbG9hdCh0aGlzLnJlc2FtcGxlcix0aGlzLm1JbnB1dEJ1ZmZlci5wb2ludGVyLG8ucG9pbnRlcix0aGlzLm1SZXNhbXBsZWRCdWZmZXIucG9pbnRlcixpLnBvaW50ZXIpO2lmKG8uZnJlZSgpLGkuZnJlZSgpLHUhPT12KXRocm93IG5ldyBFcnJvcigiUmVzYW1wbGluZyBlcnJvci4iKTt2YXIgYT10aGlzLl9vcHVzX2VuY29kZV9mbG9hdCh0aGlzLmVuY29kZXIsdGhpcy5tUmVzYW1wbGVkQnVmZmVyLnBvaW50ZXIsdGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsLHRoaXMubU91dHB1dEJ1ZmZlci5wb2ludGVyLHRoaXMubU91dHB1dEJ1ZmZlci5sZW5ndGgpO2lmKGE8MCl0aHJvdyBuZXcgRXJyb3IoIk9wdXMgZW5jb2RpbmcgZXJyb3IuIik7dGhpcy5fY29udGFpbmVyLndyaXRlRnJhbWUodGhpcy5tT3V0cHV0QnVmZmVyLnBvaW50ZXIsYSx0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWwpLHRoaXMuaW5wdXRCdWZmZXJJbmRleD0wfW4rPXJ9fX0se2tleToiY2xvc2UiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuY29uZmlnLmNoYW5uZWxDb3VudCxuPVtdLHI9MDtyPHQ7KytyKW4ucHVzaChuZXcgRmxvYXQzMkFycmF5KGgtdGhpcy5pbnB1dEJ1ZmZlckluZGV4L3QpKTt0aGlzLmVuY29kZShuKSxlLmRlc3Ryb3kodGhpcy5fY29udGFpbmVyKSx0aGlzLm1JbnB1dEJ1ZmZlci5mcmVlKCksdGhpcy5tUmVzYW1wbGVkQnVmZmVyLmZyZWUoKSx0aGlzLm1PdXRwdXRCdWZmZXIuZnJlZSgpLHRoaXMuX29wdXNfZW5jb2Rlcl9kZXN0cm95KHRoaXMuZW5jb2RlciksdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3kodGhpcy5yZXNhbXBsZXIpfX0se2tleToiaW50ZXJsZWF2ZSIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGg7aWYoMT09PXQpcmV0dXJuIGVbMF07Zm9yKHZhciBuPTA7bjx0O24rKylmb3IodmFyIHI9ZVtuXSxvPTA7bzxyLmxlbmd0aDtvKyspdGhpcy5pbnRlcmxlYXZlZEJ1ZmZlcnNbbyp0K25dPXJbb107cmV0dXJuIHRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzfX0se2tleToiT3B1c0luaXRDb2RlYyIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dm9pZCAwLHI9dGhpcy5tZW1vcnkubWFsbG9jVWludDMyKHZvaWQgMCk7dGhpcy5lbmNvZGVyPXRoaXMuX29wdXNfZW5jb2Rlcl9jcmVhdGUoZSx0LHUsci5wb2ludGVyKTt2YXIgbz1yLnZhbHVlO2lmKHIuZnJlZSgpLG8hPT1tKXRocm93IG5ldyBFcnJvcigiT3B1cyBlbmNvZG9yIGluaXRpYWxpemF0aW9uIGZhaWxlZC4iKTtuJiZ0aGlzLk9wdXNTZXRPcHVzQ29udHJvbCh5LG4pfX0se2tleToiT3B1c1NldE9wdXNDb250cm9sIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMubWVtb3J5Lm1hbGxvY0ludDMyKHQpO3RoaXMuX29wdXNfZW5jb2Rlcl9jdGwodGhpcy5lbmNvZGVyLGUsbi5wb2ludGVyKSxuLmZyZWUoKX19LHtrZXk6IlNwZWV4SW5pdFJlc2FtcGxlciIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih2b2lkIDApO3RoaXMucmVzYW1wbGVyPXRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9pbml0KG4sZSx0LGQsci5wb2ludGVyKTt2YXIgbz1yLnZhbHVlO2lmKHIuZnJlZSgpLG8hPT12KXRocm93IG5ldyBFcnJvcigiSW5pdGlhbGl6aW5nIHJlc2FtcGxlciBmYWlsZWQuIil9fV0pLHR9KCk7ZS5pbml0PWZ1bmN0aW9uKHQsbixyKXtlLmVuY29kZWRCdWZmZXJzPVtdLGUuZW5jb2Rlcj1uZXcgYih0LG4scil9LGUuZW5jb2RlPWZ1bmN0aW9uKHQpe2UuZW5jb2Rlci5lbmNvZGUodCl9LGUuZmx1c2g9ZnVuY3Rpb24oKXtyZXR1cm4gZS5lbmNvZGVkQnVmZmVycy5zcGxpY2UoMCxlLmVuY29kZWRCdWZmZXJzLmxlbmd0aCl9LGUuY2xvc2U9ZnVuY3Rpb24oKXtlLmVuY29kZXIuY2xvc2UoKX07dmFyIGcsdz17fTtmb3IoZyBpbiBlKWUuaGFzT3duUHJvcGVydHkoZykmJih3W2ddPWVbZ10pO3ZhciBBPVtdLEM9ITEsUz0hMSx4PSExLFA9ITE7Qz0ib2JqZWN0Ij09PSgidW5kZWZpbmVkIj09dHlwZW9mIHdpbmRvdz8idW5kZWZpbmVkIjphKHdpbmRvdykpLFM9ImZ1bmN0aW9uIj09dHlwZW9mIGltcG9ydFNjcmlwdHMseD0ib2JqZWN0Ij09PSh2b2lkIDA9PT1yPyJ1bmRlZmluZWQiOmEocikpJiYib2JqZWN0Ij09PWEoci52ZXJzaW9ucykmJiJzdHJpbmciPT10eXBlb2Ygci52ZXJzaW9ucy5ub2RlLFA9IUMmJiF4JiYhUzt2YXIgRSxCLEksUixPPSIiO2Z1bmN0aW9uIGoodCl7cmV0dXJuIGUubG9jYXRlRmlsZT9lLmxvY2F0ZUZpbGUodCxPKTpPK3R9eD8oTz1TP24oMCkuZGlybmFtZShPKSsiLyI6bysiLyIsRT1mdW5jdGlvbihlLHQpe3JldHVybiBJfHwoST1uKDQpKSxSfHwoUj1uKDApKSxlPVIubm9ybWFsaXplKGUpLEkucmVhZEZpbGVTeW5jKGUsdD9udWxsOiJ1dGY4Iil9LEI9ZnVuY3Rpb24oZSl7dmFyIHQ9RShlLCEwKTtyZXR1cm4gdC5idWZmZXJ8fCh0PW5ldyBVaW50OEFycmF5KHQpKSxXKHQuYnVmZmVyKSx0fSxyLmFyZ3YubGVuZ3RoPjEmJnIuYXJndlsxXS5yZXBsYWNlKC9cXC9nLCIvIiksQT1yLmFyZ3Yuc2xpY2UoMiksci5vbigidW5jYXVnaHRFeGNlcHRpb24iLChmdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiBxZSkpdGhyb3cgZX0pKSxyLm9uKCJ1bmhhbmRsZWRSZWplY3Rpb24iLF9lKSxlLmluc3BlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4iW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF0ifSk6UD8oInVuZGVmaW5lZCIhPXR5cGVvZiByZWFkJiYoRT1mdW5jdGlvbihlKXtyZXR1cm4gcmVhZChlKX0pLEI9ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHJlYWRidWZmZXI/bmV3IFVpbnQ4QXJyYXkocmVhZGJ1ZmZlcihlKSk6KFcoIm9iamVjdCI9PT1hKHQ9cmVhZChlLCJiaW5hcnkiKSkpLHQpfSwidW5kZWZpbmVkIiE9dHlwZW9mIHNjcmlwdEFyZ3M/QT1zY3JpcHRBcmdzOnZvaWQgMCE9PWFyZ3VtZW50cyYmKEE9YXJndW1lbnRzKSwidW5kZWZpbmVkIiE9dHlwZW9mIHByaW50JiYoInVuZGVmaW5lZCI9PXR5cGVvZiBjb25zb2xlJiYoY29uc29sZT17fSksY29uc29sZS5sb2c9cHJpbnQsY29uc29sZS53YXJuPWNvbnNvbGUuZXJyb3I9InVuZGVmaW5lZCIhPXR5cGVvZiBwcmludEVycj9wcmludEVycjpwcmludCkpOihDfHxTKSYmKFM/Tz1zZWxmLmxvY2F0aW9uLmhyZWY6ZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKE89ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLGwmJihPPWwpLE89MCE9PU8uaW5kZXhPZigiYmxvYjoiKT9PLnN1YnN0cigwLE8ubGFzdEluZGV4T2YoIi8iKSsxKToiIixFPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKCJHRVQiLGUsITEpLHQuc2VuZChudWxsKSx0LnJlc3BvbnNlVGV4dH0sUyYmKEI9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oIkdFVCIsZSwhMSksdC5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIix0LnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkodC5yZXNwb25zZSl9KSk7dmFyIGssVSxUPWUucHJpbnR8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksRj1lLnByaW50RXJyfHxjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtmb3IoZyBpbiB3KXcuaGFzT3duUHJvcGVydHkoZykmJihlW2ddPXdbZ10pO3c9bnVsbCxlLmFyZ3VtZW50cyYmKEE9ZS5hcmd1bWVudHMpLGUudGhpc1Byb2dyYW0mJmUudGhpc1Byb2dyYW0sZS5xdWl0JiZlLnF1aXQsZS53YXNtQmluYXJ5JiYoaz1lLndhc21CaW5hcnkpLGUubm9FeGl0UnVudGltZSYmZS5ub0V4aXRSdW50aW1lLCJvYmplY3QiIT09KCJ1bmRlZmluZWQiPT10eXBlb2YgV2ViQXNzZW1ibHk/InVuZGVmaW5lZCI6YShXZWJBc3NlbWJseSkpJiZGKCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkIik7dmFyIEg9bmV3IFdlYkFzc2VtYmx5LlRhYmxlKHtpbml0aWFsOjYwLG1heGltdW06NjAsZWxlbWVudDoiYW55ZnVuYyJ9KSxNPSExO2Z1bmN0aW9uIFcoZSx0KXtlfHxfZSgiQXNzZXJ0aW9uIGZhaWxlZDogIit0KX12YXIgRD0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcigidXRmOCIpOnZvaWQgMDtmdW5jdGlvbiB6KGUsdCxuKXtmb3IodmFyIHI9dCtuLG89dDtlW29dJiYhKG8+PXIpOykrK287aWYoby10PjE2JiZlLnN1YmFycmF5JiZEKXJldHVybiBELmRlY29kZShlLnN1YmFycmF5KHQsbykpO2Zvcih2YXIgaT0iIjt0PG87KXt2YXIgdT1lW3QrK107aWYoMTI4JnUpe3ZhciBhPTYzJmVbdCsrXTtpZigxOTIhPSgyMjQmdSkpe3ZhciBzPTYzJmVbdCsrXTtpZigodT0yMjQ9PSgyNDAmdSk/KDE1JnUpPDwxMnxhPDw2fHM6KDcmdSk8PDE4fGE8PDEyfHM8PDZ8NjMmZVt0KytdKTw2NTUzNilpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUpO2Vsc2V7dmFyIGM9dS02NTUzNjtpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGM+PjEwLDU2MzIwfDEwMjMmYyl9fWVsc2UgaSs9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmdSk8PDZ8YSl9ZWxzZSBpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUpfXJldHVybiBpfWZ1bmN0aW9uIEwoZSx0KXtyZXR1cm4gZT96KHEsZSx0KToiIn0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHREZWNvZGVyJiZuZXcgVGV4dERlY29kZXIoInV0Zi0xNmxlIik7dmFyIFYscSxOLEc9NjU1MzY7ZnVuY3Rpb24gWCh0KXtWPXQsZS5IRUFQOD1uZXcgSW50OEFycmF5KHQpLGUuSEVBUDE2PW5ldyBJbnQxNkFycmF5KHQpLGUuSEVBUDMyPU49bmV3IEludDMyQXJyYXkodCksZS5IRUFQVTg9cT1uZXcgVWludDhBcnJheSh0KSxlLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KHQpLGUuSEVBUFUzMj1uZXcgVWludDMyQXJyYXkodCksZS5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkodCksZS5IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkodCl9dmFyIFk9NTI4OTAyNCwkPTQ1OTg0LEo9ZS5JTklUSUFMX01FTU9SWXx8MTY3NzcyMTY7ZnVuY3Rpb24gSyh0KXtmb3IoO3QubGVuZ3RoPjA7KXt2YXIgbj10LnNoaWZ0KCk7aWYoImZ1bmN0aW9uIiE9dHlwZW9mIG4pe3ZhciByPW4uZnVuYzsibnVtYmVyIj09dHlwZW9mIHI/dm9pZCAwPT09bi5hcmc/ZS5keW5DYWxsX3Yocik6ZS5keW5DYWxsX3ZpKHIsbi5hcmcpOnIodm9pZCAwPT09bi5hcmc/bnVsbDpuLmFyZyl9ZWxzZSBuKCl9fShVPWUud2FzbU1lbW9yeT9lLndhc21NZW1vcnk6bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpKL0csbWF4aW11bTpKL0d9KSkmJihWPVUuYnVmZmVyKSxKPVYuYnl0ZUxlbmd0aCxYKFYpLE5bJD4+Ml09WTt2YXIgUT1bXSxaPVtdLGVlPVtdLHRlPVtdO2Z1bmN0aW9uIG5lKCl7aWYoZS5wcmVSdW4pZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBlLnByZVJ1biYmKGUucHJlUnVuPVtlLnByZVJ1bl0pO2UucHJlUnVuLmxlbmd0aDspdWUoZS5wcmVSdW4uc2hpZnQoKSk7SyhRKX1mdW5jdGlvbiByZSgpe0soWil9ZnVuY3Rpb24gb2UoKXtLKGVlKX1mdW5jdGlvbiBpZSgpe2lmKGUucG9zdFJ1bilmb3IoImZ1bmN0aW9uIj09dHlwZW9mIGUucG9zdFJ1biYmKGUucG9zdFJ1bj1bZS5wb3N0UnVuXSk7ZS5wb3N0UnVuLmxlbmd0aDspYWUoZS5wb3N0UnVuLnNoaWZ0KCkpO0sodGUpfWZ1bmN0aW9uIHVlKGUpe1EudW5zaGlmdChlKX1mdW5jdGlvbiBhZShlKXt0ZS51bnNoaWZ0KGUpfXZhciBzZT0wLGNlPW51bGwsZmU9bnVsbDtmdW5jdGlvbiBsZSh0KXtzZSsrLGUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKHNlKX1mdW5jdGlvbiBwZSh0KXtpZihzZS0tLGUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmZS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKHNlKSwwPT1zZSYmKG51bGwhPT1jZSYmKGNsZWFySW50ZXJ2YWwoY2UpLGNlPW51bGwpLGZlKSl7dmFyIG49ZmU7ZmU9bnVsbCxuKCl9fWZ1bmN0aW9uIF9lKHQpe3Rocm93IGUub25BYm9ydCYmZS5vbkFib3J0KHQpLFQodCs9IiIpLEYodCksTT0hMCx0PSJhYm9ydCgiK3QrIikuIEJ1aWxkIHdpdGggLXMgQVNTRVJUSU9OUz0xIGZvciBtb3JlIGluZm8uIixuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHQpfWUucHJlbG9hZGVkSW1hZ2VzPXt9LGUucHJlbG9hZGVkQXVkaW9zPXt9O3ZhciBkZT0iZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCI7ZnVuY3Rpb24gaGUoZSl7cmV0dXJuIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aD9lLnN0YXJ0c1dpdGgoZGUpOjA9PT1lLmluZGV4T2YoZGUpfXZhciBtZT0iV2ViTU9wdXNFbmNvZGVyLndhc20iO2Z1bmN0aW9uIHllKCl7dHJ5e2lmKGspcmV0dXJuIG5ldyBVaW50OEFycmF5KGspO2lmKEIpcmV0dXJuIEIobWUpO3Rocm93ImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkIn1jYXRjaChlKXtfZShlKX19ZnVuY3Rpb24gdmUoKXtyZXR1cm4ga3x8IUMmJiFTfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2g/bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7ZSh5ZSgpKX0pKTpmZXRjaChtZSx7Y3JlZGVudGlhbHM6InNhbWUtb3JpZ2luIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKCFlLm9rKXRocm93ImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJyIrbWUrIiciO3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIHllKCl9KSl9ZnVuY3Rpb24gYmUoKXt2YXIgdD17YTpUZX07ZnVuY3Rpb24gbih0LG4pe3ZhciByPXQuZXhwb3J0cztlLmFzbT1yLHBlKCl9ZnVuY3Rpb24gcihlKXtuKGUuaW5zdGFuY2UpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIHZlKCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsdCl9KSkudGhlbihlLChmdW5jdGlvbihlKXtGKCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAiK2UpLF9lKGUpfSkpfWlmKGxlKCksZS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBlLmluc3RhbnRpYXRlV2FzbSh0LG4pfWNhdGNoKGUpe3JldHVybiBGKCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAiK2UpLCExfXJldHVybiBmdW5jdGlvbigpe2lmKGt8fCJmdW5jdGlvbiIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8aGUobWUpfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2gpcmV0dXJuIG8ocik7ZmV0Y2gobWUse2NyZWRlbnRpYWxzOiJzYW1lLW9yaWdpbiJ9KS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZSx0KS50aGVuKHIsKGZ1bmN0aW9uKGUpe0YoIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAiK2UpLEYoImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uIiksbyhyKX0pKX0pKX0oKSx7fX1mdW5jdGlvbiBnZSh0LG4pe3ZhciByPW5ldyBVaW50OEFycmF5KGUuSEVBUFU4LmJ1ZmZlcix0LG4pO2UuZW5jb2RlZEJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShyKS5idWZmZXIpfWZ1bmN0aW9uIHdlKGUsdCxuLHIpe19lKCJBc3NlcnRpb24gZmFpbGVkOiAiK0woZSkrIiwgYXQ6ICIrW3Q/TCh0KToidW5rbm93biBmaWxlbmFtZSIsbixyP0wocik6InVua25vd24gZnVuY3Rpb24iXSl9aGUobWUpfHwobWU9aihtZSkpLFoucHVzaCh7ZnVuYzpmdW5jdGlvbigpe01lKCl9fSk7dmFyIEFlPXttYXBwaW5nczp7fSxidWZmZXJzOltudWxsLFtdLFtdXSxwcmludENoYXI6ZnVuY3Rpb24oZSx0KXt2YXIgbj1BZS5idWZmZXJzW2VdOzA9PT10fHwxMD09PXQ/KCgxPT09ZT9UOkYpKHoobiwwKSksbi5sZW5ndGg9MCk6bi5wdXNoKHQpfSx2YXJhcmdzOnZvaWQgMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQWUudmFyYXJncys9NCxOW0FlLnZhcmFyZ3MtND4+Ml19LGdldFN0cjpmdW5jdGlvbihlKXtyZXR1cm4gTChlKX0sZ2V0NjQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZX19O2Z1bmN0aW9uIENlKGUsdCxuKXtyZXR1cm4gQWUudmFyYXJncz1uLDB9ZnVuY3Rpb24gU2UoZSx0LG4pe0FlLnZhcmFyZ3M9bn1mdW5jdGlvbiB4ZShlLHQsbil7cmV0dXJuIEFlLnZhcmFyZ3M9biwwfWZ1bmN0aW9uIFBlKCl7X2UoKX1mdW5jdGlvbiBFZShlLHQsbil7cS5jb3B5V2l0aGluKGUsdCx0K24pfWZ1bmN0aW9uIEJlKGUpe19lKCJPT00iKX1mdW5jdGlvbiBJZShlKXtCZSgpfWZ1bmN0aW9uIFJlKGUpe3JldHVybiAwfWZ1bmN0aW9uIE9lKGUsdCxuLHIpe3ZhciBvPUFlLmdldFN0cmVhbUZyb21GRChlKSxpPUFlLmRvUmVhZHYobyx0LG4pO3JldHVybiBOW3I+PjJdPWksMH1mdW5jdGlvbiBqZShlLHQsbixyLG8pe31mdW5jdGlvbiBrZShlLHQsbixyKXtmb3IodmFyIG89MCxpPTA7aTxuO2krKyl7Zm9yKHZhciB1PU5bdCs4Kmk+PjJdLGE9Tlt0Kyg4KmkrNCk+PjJdLHM9MDtzPGE7cysrKUFlLnByaW50Q2hhcihlLHFbdStzXSk7bys9YX1yZXR1cm4gTltyPj4yXT1vLDB9ZnVuY3Rpb24gVWUoZSl7dmFyIHQ9RGF0ZS5ub3coKS8xZTN8MDtyZXR1cm4gZSYmKE5bZT4+Ml09dCksdH12YXIgVGU9e2E6d2UsZTpDZSxoOlNlLGc6eGUsYjpQZSxtOmdlLGs6RWUsbDpJZSxjOlJlLGY6T2UsajpqZSxkOmtlLG1lbW9yeTpVLHRhYmxlOkgsaTpVZX0sRmU9YmUoKTtlLmFzbT1GZTt2YXIgSGUsTWU9ZS5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4oTWU9ZS5fX193YXNtX2NhbGxfY3RvcnM9ZS5hc20ubikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxXZT0oZS5fX19lbV9qc19fZW1zY3JpcHRlblB1c2hCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fX19lbV9qc19fZW1zY3JpcHRlblB1c2hCdWZmZXI9ZS5hc20ubykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9lbXNjcmlwdGVuX2JpbmRfVm9pZFB0cl9fX2Rlc3Ryb3lfX18wPWZ1bmN0aW9uKCl7cmV0dXJuKFdlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Wb2lkUHRyX19fZGVzdHJveV9fXzA9ZS5hc20ucCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSksRGU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9Db250YWluZXJfMD1mdW5jdGlvbigpe3JldHVybihEZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX0NvbnRhaW5lcl8wPWUuYXNtLnEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0semU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9pbml0XzM9ZnVuY3Rpb24oKXtyZXR1cm4oemU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9pbml0XzM9ZS5hc20ucikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxMZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX3dyaXRlRnJhbWVfMz1mdW5jdGlvbigpe3JldHVybihMZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX3dyaXRlRnJhbWVfMz1lLmFzbS5zKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFZlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfX19kZXN0cm95X19fMD1mdW5jdGlvbigpe3JldHVybihWZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX19fZGVzdHJveV9fXzA9ZS5hc20udCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBxZShlKXt0aGlzLm5hbWU9IkV4aXRTdGF0dXMiLHRoaXMubWVzc2FnZT0iUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgiK2UrIikiLHRoaXMuc3RhdHVzPWV9ZnVuY3Rpb24gTmUodCl7ZnVuY3Rpb24gbigpe0hlfHwoSGU9ITAsZS5jYWxsZWRSdW49ITAsTXx8KHJlKCksb2UoKSxlLm9uUnVudGltZUluaXRpYWxpemVkJiZlLm9uUnVudGltZUluaXRpYWxpemVkKCksaWUoKSkpfXQ9dHx8QSxzZT4wfHwobmUoKSxzZT4wfHwoZS5zZXRTdGF0dXM/KGUuc2V0U3RhdHVzKCJSdW5uaW5nLi4uIiksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe2Uuc2V0U3RhdHVzKCIiKX0pLDEpLG4oKX0pLDEpKTpuKCkpKX1pZihlLl9vcHVzX2VuY29kZXJfY3JlYXRlPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX29wdXNfZW5jb2Rlcl9jcmVhdGU9ZS5hc20udSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9vcHVzX2VuY29kZV9mbG9hdD1mdW5jdGlvbigpe3JldHVybihlLl9vcHVzX2VuY29kZV9mbG9hdD1lLmFzbS52KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX29wdXNfZW5jb2Rlcl9jdGw9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fb3B1c19lbmNvZGVyX2N0bD1lLmFzbS53KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX29wdXNfZW5jb2Rlcl9kZXN0cm95PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX29wdXNfZW5jb2Rlcl9kZXN0cm95PWUuYXNtLngpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZS5hc20ueSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1mdW5jdGlvbigpe3JldHVybihlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1lLmFzbS56KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWUuYXNtLkEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fZnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9mcmVlPWUuYXNtLkIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fbWFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKGUuX21hbGxvYz1lLmFzbS5DKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuZHluQ2FsbF92aT1mdW5jdGlvbigpe3JldHVybihlLmR5bkNhbGxfdmk9ZS5hc20uRCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLmR5bkNhbGxfdj1mdW5jdGlvbigpe3JldHVybihlLmR5bkNhbGxfdj1lLmFzbS5FKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuYXNtPUZlLGUudGhlbj1mdW5jdGlvbih0KXtpZihIZSl0KGUpO2Vsc2V7dmFyIG49ZS5vblJ1bnRpbWVJbml0aWFsaXplZDtlLm9uUnVudGltZUluaXRpYWxpemVkPWZ1bmN0aW9uKCl7biYmbigpLHQoZSl9fXJldHVybiBlfSxmZT1mdW5jdGlvbiBlKCl7SGV8fE5lKCksSGV8fChmZT1lKX0sZS5ydW49TmUsZS5wcmVJbml0KWZvcigiZnVuY3Rpb24iPT10eXBlb2YgZS5wcmVJbml0JiYoZS5wcmVJbml0PVtlLnByZUluaXRdKTtlLnByZUluaXQubGVuZ3RoPjA7KWUucHJlSW5pdC5wb3AoKSgpO2Z1bmN0aW9uIEdlKCl7fWZ1bmN0aW9uIFhlKGUpe3JldHVybihlfHxHZSkuX19jYWNoZV9ffWZ1bmN0aW9uIFllKGUsdCl7dmFyIG49WGUodCkscj1uW2VdO3JldHVybiByfHwoKHI9T2JqZWN0LmNyZWF0ZSgodHx8R2UpLnByb3RvdHlwZSkpLnB0cj1lLG5bZV09cil9ZnVuY3Rpb24gJGUoZSx0KXtyZXR1cm4gWWUoZS5wdHIsdCl9ZnVuY3Rpb24gSmUoZSl7aWYoIWUuX19kZXN0cm95X18pdGhyb3ciRXJyb3I6IENhbm5vdCBkZXN0cm95IG9iamVjdC4gKERpZCB5b3UgY3JlYXRlIGl0IHlvdXJzZWxmPykiO2UuX19kZXN0cm95X18oKSxkZWxldGUgWGUoZS5fX2NsYXNzX18pW2UucHRyXX1mdW5jdGlvbiBLZShlLHQpe3JldHVybiBlLnB0cj09PXQucHRyfWZ1bmN0aW9uIFFlKGUpe3JldHVybiBlLnB0cn1mdW5jdGlvbiBaZShlKXtyZXR1cm4gZS5fX2NsYXNzX199ZnVuY3Rpb24gZXQoKXt0aHJvdyJjYW5ub3QgY29uc3RydWN0IGEgVm9pZFB0ciwgbm8gY29uc3RydWN0b3IgaW4gSURMIn1mdW5jdGlvbiB0dCgpe3RoaXMucHRyPURlKCksWGUodHQpW3RoaXMucHRyXT10aGlzfXJldHVybiBOZSgpLEdlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEdlLnByb3RvdHlwZSksR2UucHJvdG90eXBlLmNvbnN0cnVjdG9yPUdlLEdlLnByb3RvdHlwZS5fX2NsYXNzX189R2UsR2UuX19jYWNoZV9fPXt9LGUuV3JhcHBlck9iamVjdD1HZSxlLmdldENhY2hlPVhlLGUud3JhcFBvaW50ZXI9WWUsZS5jYXN0T2JqZWN0PSRlLGUuTlVMTD1ZZSgwKSxlLmRlc3Ryb3k9SmUsZS5jb21wYXJlPUtlLGUuZ2V0UG9pbnRlcj1RZSxlLmdldENsYXNzPVplLGV0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEdlLnByb3RvdHlwZSksZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yPWV0LGV0LnByb3RvdHlwZS5fX2NsYXNzX189ZXQsZXQuX19jYWNoZV9fPXt9LGUuVm9pZFB0cj1ldCxldC5wcm90b3R5cGUuX19kZXN0cm95X189ZXQucHJvdG90eXBlLl9fZGVzdHJveV9fPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wdHI7V2UoZSl9LHR0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEdlLnByb3RvdHlwZSksdHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXR0LHR0LnByb3RvdHlwZS5fX2NsYXNzX189dHQsdHQuX19jYWNoZV9fPXt9LGUuQ29udGFpbmVyPXR0LHR0LnByb3RvdHlwZS5pbml0PXR0LnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLnB0cjtlJiYib2JqZWN0Ij09PWEoZSkmJihlPWUucHRyKSx0JiYib2JqZWN0Ij09PWEodCkmJih0PXQucHRyKSxuJiYib2JqZWN0Ij09PWEobikmJihuPW4ucHRyKSx6ZShyLGUsdCxuKX0sdHQucHJvdG90eXBlLndyaXRlRnJhbWU9dHQucHJvdG90eXBlLndyaXRlRnJhbWU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMucHRyO2UmJiJvYmplY3QiPT09YShlKSYmKGU9ZS5wdHIpLHQmJiJvYmplY3QiPT09YSh0KSYmKHQ9dC5wdHIpLG4mJiJvYmplY3QiPT09YShuKSYmKG49bi5wdHIpLExlKHIsZSx0LG4pfSx0dC5wcm90b3R5cGUuX19kZXN0cm95X189dHQucHJvdG90eXBlLl9fZGVzdHJveV9fPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wdHI7VmUoZSl9LGV9KTsib2JqZWN0Ij09PWEodCkmJiJvYmplY3QiPT09YShpKT9pLmV4cG9ydHM9cDp2b2lkIDA9PT0odT1mdW5jdGlvbigpe3JldHVybiBwfS5hcHBseSh0LFtdKSl8fChpLmV4cG9ydHM9dSl9KS5jYWxsKHRoaXMsIi9pbmRleC5qcyIsbigyKSwiLyIsbigzKShlKSl9LGZ1bmN0aW9uKGUsdCxuKXsoZnVuY3Rpb24oZSxyLG8saSl7dmFyIHU7ZnVuY3Rpb24gYShlKXtyZXR1cm4oYT0iZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYic3ltYm9sIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiYiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT8ic3ltYm9sIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIHMoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKX1mdW5jdGlvbiBjKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsInZhbHVlImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19ZnVuY3Rpb24gZihlLHQsbil7cmV0dXJuIHQmJmMoZS5wcm90b3R5cGUsdCksbiYmYyhlLG4pLGV9dmFyIGwscD0obD0obD0idW5kZWZpbmVkIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCl8fGUsZnVuY3Rpb24oZSl7ZT12b2lkIDAhPT0oZT1lfHx7fSk/ZTp7fTt2YXIgdD1uKDEpLGk9dC5FbXNjcmlwdGVuTWVtb3J5QWxsb2NhdG9yLHU9MjA0OSxjPTQ4ZTMscD00ZTMsXz0yMCxkPTYsaD00MDk2LG09MCx5PTQwMDIsdj0wLGI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KG4scil7dmFyIG89YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnZvaWQgMDtzKHRoaXMsdCksdGhpcy5jb25maWc9e2lucHV0U2FtcGxlUmF0ZTpuLGNoYW5uZWxDb3VudDpyfSx0aGlzLm1lbW9yeT1uZXcgaShlKSx0aGlzLl9vcHVzX2VuY29kZXJfY3JlYXRlPWUuX29wdXNfZW5jb2Rlcl9jcmVhdGUsdGhpcy5fb3B1c19lbmNvZGVyX2N0bD1lLl9vcHVzX2VuY29kZXJfY3RsLHRoaXMuX29wdXNfZW5jb2RlX2Zsb2F0PWUuX29wdXNfZW5jb2RlX2Zsb2F0LHRoaXMuX29wdXNfZW5jb2Rlcl9kZXN0cm95PWUuX29wdXNfZW5jb2Rlcl9kZXN0cm95LHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9pbml0PWUuX3NwZWV4X3Jlc2FtcGxlcl9pbml0LHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0LHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95PWUuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95LHRoaXMuX2NvbnRhaW5lcj1uZXcgZS5Db250YWluZXIsdGhpcy5fY29udGFpbmVyLmluaXQoYyxyLE1hdGguZmxvb3IoNDI5NDk2NzI5NSpNYXRoLnJhbmRvbSgpKSksdGhpcy5PcHVzSW5pdENvZGVjKGMscixvKSx0aGlzLlNwZWV4SW5pdFJlc2FtcGxlcihuLGMsciksdGhpcy5pbnB1dFNhbXBsZXNQZXJDaGFubmVsPW4qXy8xZTMsdGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsPWMqXy8xZTMsdGhpcy5pbnB1dEJ1ZmZlckluZGV4PTAsdGhpcy5tSW5wdXRCdWZmZXI9dGhpcy5tZW1vcnkubWFsbG9jRmxvYXQzMkJ1ZmZlcih0aGlzLmlucHV0U2FtcGxlc1BlckNoYW5uZWwqciksdGhpcy5tUmVzYW1wbGVkQnVmZmVyPXRoaXMubWVtb3J5Lm1hbGxvY0Zsb2F0MzJCdWZmZXIodGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsKnIpLHRoaXMubU91dHB1dEJ1ZmZlcj10aGlzLm1lbW9yeS5tYWxsb2NVaW50OEJ1ZmZlcihwKSx0aGlzLmludGVybGVhdmVkQnVmZmVycz0xIT09cj9uZXcgRmxvYXQzMkFycmF5KGgqcik6dm9pZCAwfXJldHVybiBmKHQsW3trZXk6ImVuY29kZSIsdmFsdWU6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMuaW50ZXJsZWF2ZShlKSxuPTA7bjx0Lmxlbmd0aDspe3ZhciByPU1hdGgubWluKHRoaXMubUlucHV0QnVmZmVyLmxlbmd0aC10aGlzLmlucHV0QnVmZmVySW5kZXgsdC5sZW5ndGgtbik7aWYodGhpcy5tSW5wdXRCdWZmZXIuc2V0KHQuc3ViYXJyYXkobixuK3IpLHRoaXMuaW5wdXRCdWZmZXJJbmRleCksdGhpcy5pbnB1dEJ1ZmZlckluZGV4Kz1yLHRoaXMuaW5wdXRCdWZmZXJJbmRleD49dGhpcy5tSW5wdXRCdWZmZXIubGVuZ3RoKXt2YXIgbz10aGlzLm1lbW9yeS5tYWxsb2NVaW50MzIodGhpcy5pbnB1dFNhbXBsZXNQZXJDaGFubmVsKSxpPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih0aGlzLm91dHB1dFNhbXBsZVBlckNoYW5uZWwpLHU9dGhpcy5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQodGhpcy5yZXNhbXBsZXIsdGhpcy5tSW5wdXRCdWZmZXIucG9pbnRlcixvLnBvaW50ZXIsdGhpcy5tUmVzYW1wbGVkQnVmZmVyLnBvaW50ZXIsaS5wb2ludGVyKTtpZihvLmZyZWUoKSxpLmZyZWUoKSx1IT09dil0aHJvdyBuZXcgRXJyb3IoIlJlc2FtcGxpbmcgZXJyb3IuIik7dmFyIGE9dGhpcy5fb3B1c19lbmNvZGVfZmxvYXQodGhpcy5lbmNvZGVyLHRoaXMubVJlc2FtcGxlZEJ1ZmZlci5wb2ludGVyLHRoaXMub3V0cHV0U2FtcGxlUGVyQ2hhbm5lbCx0aGlzLm1PdXRwdXRCdWZmZXIucG9pbnRlcix0aGlzLm1PdXRwdXRCdWZmZXIubGVuZ3RoKTtpZihhPDApdGhyb3cgbmV3IEVycm9yKCJPcHVzIGVuY29kaW5nIGVycm9yLiIpO3RoaXMuX2NvbnRhaW5lci53cml0ZUZyYW1lKHRoaXMubU91dHB1dEJ1ZmZlci5wb2ludGVyLGEsdGhpcy5vdXRwdXRTYW1wbGVQZXJDaGFubmVsKSx0aGlzLmlucHV0QnVmZmVySW5kZXg9MH1uKz1yfX19LHtrZXk6ImNsb3NlIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmNvbmZpZy5jaGFubmVsQ291bnQsbj1bXSxyPTA7cjx0OysrciluLnB1c2gobmV3IEZsb2F0MzJBcnJheShoLXRoaXMuaW5wdXRCdWZmZXJJbmRleC90KSk7dGhpcy5lbmNvZGUobiksZS5kZXN0cm95KHRoaXMuX2NvbnRhaW5lciksdGhpcy5tSW5wdXRCdWZmZXIuZnJlZSgpLHRoaXMubVJlc2FtcGxlZEJ1ZmZlci5mcmVlKCksdGhpcy5tT3V0cHV0QnVmZmVyLmZyZWUoKSx0aGlzLl9vcHVzX2VuY29kZXJfZGVzdHJveSh0aGlzLmVuY29kZXIpLHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95KHRoaXMucmVzYW1wbGVyKX19LHtrZXk6ImludGVybGVhdmUiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoO2lmKDE9PT10KXJldHVybiBlWzBdO2Zvcih2YXIgbj0wO248dDtuKyspZm9yKHZhciByPWVbbl0sbz0wO288ci5sZW5ndGg7bysrKXRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzW28qdCtuXT1yW29dO3JldHVybiB0aGlzLmludGVybGVhdmVkQnVmZmVyc319LHtrZXk6Ik9wdXNJbml0Q29kZWMiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnZvaWQgMCxyPXRoaXMubWVtb3J5Lm1hbGxvY1VpbnQzMih2b2lkIDApO3RoaXMuZW5jb2Rlcj10aGlzLl9vcHVzX2VuY29kZXJfY3JlYXRlKGUsdCx1LHIucG9pbnRlcik7dmFyIG89ci52YWx1ZTtpZihyLmZyZWUoKSxvIT09bSl0aHJvdyBuZXcgRXJyb3IoIk9wdXMgZW5jb2RvciBpbml0aWFsaXphdGlvbiBmYWlsZWQuIik7biYmdGhpcy5PcHVzU2V0T3B1c0NvbnRyb2woeSxuKX19LHtrZXk6Ik9wdXNTZXRPcHVzQ29udHJvbCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLm1lbW9yeS5tYWxsb2NJbnQzMih0KTt0aGlzLl9vcHVzX2VuY29kZXJfY3RsKHRoaXMuZW5jb2RlcixlLG4ucG9pbnRlciksbi5mcmVlKCl9fSx7a2V5OiJTcGVleEluaXRSZXNhbXBsZXIiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLm1lbW9yeS5tYWxsb2NVaW50MzIodm9pZCAwKTt0aGlzLnJlc2FtcGxlcj10aGlzLl9zcGVleF9yZXNhbXBsZXJfaW5pdChuLGUsdCxkLHIucG9pbnRlcik7dmFyIG89ci52YWx1ZTtpZihyLmZyZWUoKSxvIT09dil0aHJvdyBuZXcgRXJyb3IoIkluaXRpYWxpemluZyByZXNhbXBsZXIgZmFpbGVkLiIpfX1dKSx0fSgpO2UuaW5pdD1mdW5jdGlvbih0LG4scil7ZS5lbmNvZGVkQnVmZmVycz1bXSxlLmVuY29kZXI9bmV3IGIodCxuLHIpfSxlLmVuY29kZT1mdW5jdGlvbih0KXtlLmVuY29kZXIuZW5jb2RlKHQpfSxlLmZsdXNoPWZ1bmN0aW9uKCl7cmV0dXJuIGUuZW5jb2RlZEJ1ZmZlcnMuc3BsaWNlKDAsZS5lbmNvZGVkQnVmZmVycy5sZW5ndGgpfSxlLmNsb3NlPWZ1bmN0aW9uKCl7ZS5lbmNvZGVyLmNsb3NlKCl9O3ZhciBnLHc9e307Zm9yKGcgaW4gZSllLmhhc093blByb3BlcnR5KGcpJiYod1tnXT1lW2ddKTt2YXIgQT1bXSxDPSExLFM9ITEseD0hMSxQPSExO0M9Im9iamVjdCI9PT0oInVuZGVmaW5lZCI9PXR5cGVvZiB3aW5kb3c/InVuZGVmaW5lZCI6YSh3aW5kb3cpKSxTPSJmdW5jdGlvbiI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLHg9Im9iamVjdCI9PT0odm9pZCAwPT09cj8idW5kZWZpbmVkIjphKHIpKSYmIm9iamVjdCI9PT1hKHIudmVyc2lvbnMpJiYic3RyaW5nIj09dHlwZW9mIHIudmVyc2lvbnMubm9kZSxQPSFDJiYheCYmIVM7dmFyIEUsQixJLFIsTz0iIjtmdW5jdGlvbiBqKHQpe3JldHVybiBlLmxvY2F0ZUZpbGU/ZS5sb2NhdGVGaWxlKHQsTyk6Tyt0fXg/KE89Uz9uKDApLmRpcm5hbWUoTykrIi8iOm8rIi8iLEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gSXx8KEk9big0KSksUnx8KFI9bigwKSksZT1SLm5vcm1hbGl6ZShlKSxJLnJlYWRGaWxlU3luYyhlLHQ/bnVsbDoidXRmOCIpfSxCPWZ1bmN0aW9uKGUpe3ZhciB0PUUoZSwhMCk7cmV0dXJuIHQuYnVmZmVyfHwodD1uZXcgVWludDhBcnJheSh0KSksVyh0LmJ1ZmZlciksdH0sci5hcmd2Lmxlbmd0aD4xJiZyLmFyZ3ZbMV0ucmVwbGFjZSgvXFwvZywiLyIpLEE9ci5hcmd2LnNsaWNlKDIpLHIub24oInVuY2F1Z2h0RXhjZXB0aW9uIiwoZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgV2UpKXRocm93IGV9KSksci5vbigidW5oYW5kbGVkUmVqZWN0aW9uIixfZSksZS5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdIn0pOlA/KCJ1bmRlZmluZWQiIT10eXBlb2YgcmVhZCYmKEU9ZnVuY3Rpb24oZSl7cmV0dXJuIHJlYWQoZSl9KSxCPWZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiByZWFkYnVmZmVyP25ldyBVaW50OEFycmF5KHJlYWRidWZmZXIoZSkpOihXKCJvYmplY3QiPT09YSh0PXJlYWQoZSwiYmluYXJ5IikpKSx0KX0sInVuZGVmaW5lZCIhPXR5cGVvZiBzY3JpcHRBcmdzP0E9c2NyaXB0QXJnczp2b2lkIDAhPT1hcmd1bWVudHMmJihBPWFyZ3VtZW50cyksInVuZGVmaW5lZCIhPXR5cGVvZiBwcmludCYmKCJ1bmRlZmluZWQiPT10eXBlb2YgY29uc29sZSYmKGNvbnNvbGU9e30pLGNvbnNvbGUubG9nPXByaW50LGNvbnNvbGUud2Fybj1jb25zb2xlLmVycm9yPSJ1bmRlZmluZWQiIT10eXBlb2YgcHJpbnRFcnI/cHJpbnRFcnI6cHJpbnQpKTooQ3x8UykmJihTP089c2VsZi5sb2NhdGlvbi5ocmVmOmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihPPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxsJiYoTz1sKSxPPTAhPT1PLmluZGV4T2YoImJsb2I6Iik/Ty5zdWJzdHIoMCxPLmxhc3RJbmRleE9mKCIvIikrMSk6IiIsRT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbigiR0VUIixlLCExKSx0LnNlbmQobnVsbCksdC5yZXNwb25zZVRleHR9LFMmJihCPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKCJHRVQiLGUsITEpLHQucmVzcG9uc2VUeXBlPSJhcnJheWJ1ZmZlciIsdC5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KHQucmVzcG9uc2UpfSkpO3ZhciBrLFUsVD1lLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLEY9ZS5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7Zm9yKGcgaW4gdyl3Lmhhc093blByb3BlcnR5KGcpJiYoZVtnXT13W2ddKTt3PW51bGwsZS5hcmd1bWVudHMmJihBPWUuYXJndW1lbnRzKSxlLnRoaXNQcm9ncmFtJiZlLnRoaXNQcm9ncmFtLGUucXVpdCYmZS5xdWl0LGUud2FzbUJpbmFyeSYmKGs9ZS53YXNtQmluYXJ5KSxlLm5vRXhpdFJ1bnRpbWUmJmUubm9FeGl0UnVudGltZSwib2JqZWN0IiE9PSgidW5kZWZpbmVkIj09dHlwZW9mIFdlYkFzc2VtYmx5PyJ1bmRlZmluZWQiOmEoV2ViQXNzZW1ibHkpKSYmRigibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCIpO3ZhciBIPW5ldyBXZWJBc3NlbWJseS5UYWJsZSh7aW5pdGlhbDozNixtYXhpbXVtOjM2LGVsZW1lbnQ6ImFueWZ1bmMifSksTT0hMTtmdW5jdGlvbiBXKGUsdCl7ZXx8X2UoIkFzc2VydGlvbiBmYWlsZWQ6ICIrdCl9dmFyIEQ9InVuZGVmaW5lZCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoInV0ZjgiKTp2b2lkIDA7ZnVuY3Rpb24geihlLHQsbil7Zm9yKHZhciByPXQrbixvPXQ7ZVtvXSYmIShvPj1yKTspKytvO2lmKG8tdD4xNiYmZS5zdWJhcnJheSYmRClyZXR1cm4gRC5kZWNvZGUoZS5zdWJhcnJheSh0LG8pKTtmb3IodmFyIGk9IiI7dDxvOyl7dmFyIHU9ZVt0KytdO2lmKDEyOCZ1KXt2YXIgYT02MyZlW3QrK107aWYoMTkyIT0oMjI0JnUpKXt2YXIgcz02MyZlW3QrK107aWYoKHU9MjI0PT0oMjQwJnUpPygxNSZ1KTw8MTJ8YTw8NnxzOig3JnUpPDwxOHxhPDwxMnxzPDw2fDYzJmVbdCsrXSk8NjU1MzYpaSs9U3RyaW5nLmZyb21DaGFyQ29kZSh1KTtlbHNle3ZhciBjPXUtNjU1MzY7aSs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjPj4xMCw1NjMyMHwxMDIzJmMpfX1lbHNlIGkrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJnUpPDw2fGEpfWVsc2UgaSs9U3RyaW5nLmZyb21DaGFyQ29kZSh1KX1yZXR1cm4gaX1mdW5jdGlvbiBMKGUsdCl7cmV0dXJuIGU/eihxLGUsdCk6IiJ9InVuZGVmaW5lZCIhPXR5cGVvZiBUZXh0RGVjb2RlciYmbmV3IFRleHREZWNvZGVyKCJ1dGYtMTZsZSIpO3ZhciBWLHEsTixHPTY1NTM2O2Z1bmN0aW9uIFgodCl7Vj10LGUuSEVBUDg9bmV3IEludDhBcnJheSh0KSxlLkhFQVAxNj1uZXcgSW50MTZBcnJheSh0KSxlLkhFQVAzMj1OPW5ldyBJbnQzMkFycmF5KHQpLGUuSEVBUFU4PXE9bmV3IFVpbnQ4QXJyYXkodCksZS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheSh0KSxlLkhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KHQpLGUuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KHQpLGUuSEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KHQpfXZhciBZPTUyODk3MjgsJD00NjY4OCxKPWUuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2Z1bmN0aW9uIEsodCl7Zm9yKDt0Lmxlbmd0aD4wOyl7dmFyIG49dC5zaGlmdCgpO2lmKCJmdW5jdGlvbiIhPXR5cGVvZiBuKXt2YXIgcj1uLmZ1bmM7Im51bWJlciI9PXR5cGVvZiByP3ZvaWQgMD09PW4uYXJnP2UuZHluQ2FsbF92KHIpOmUuZHluQ2FsbF92aShyLG4uYXJnKTpyKHZvaWQgMD09PW4uYXJnP251bGw6bi5hcmcpfWVsc2UgbigpfX0oVT1lLndhc21NZW1vcnk/ZS53YXNtTWVtb3J5Om5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6Si9HLG1heGltdW06Si9HfSkpJiYoVj1VLmJ1ZmZlciksSj1WLmJ5dGVMZW5ndGgsWChWKSxOWyQ+PjJdPVk7dmFyIFE9W10sWj1bXSxlZT1bXSx0ZT1bXTtmdW5jdGlvbiBuZSgpe2lmKGUucHJlUnVuKWZvcigiZnVuY3Rpb24iPT10eXBlb2YgZS5wcmVSdW4mJihlLnByZVJ1bj1bZS5wcmVSdW5dKTtlLnByZVJ1bi5sZW5ndGg7KXVlKGUucHJlUnVuLnNoaWZ0KCkpO0soUSl9ZnVuY3Rpb24gcmUoKXtLKFopfWZ1bmN0aW9uIG9lKCl7SyhlZSl9ZnVuY3Rpb24gaWUoKXtpZihlLnBvc3RSdW4pZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBlLnBvc3RSdW4mJihlLnBvc3RSdW49W2UucG9zdFJ1bl0pO2UucG9zdFJ1bi5sZW5ndGg7KWFlKGUucG9zdFJ1bi5zaGlmdCgpKTtLKHRlKX1mdW5jdGlvbiB1ZShlKXtRLnVuc2hpZnQoZSl9ZnVuY3Rpb24gYWUoZSl7dGUudW5zaGlmdChlKX12YXIgc2U9MCxjZT1udWxsLGZlPW51bGw7ZnVuY3Rpb24gbGUodCl7c2UrKyxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhzZSl9ZnVuY3Rpb24gcGUodCl7aWYoc2UtLSxlLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmUubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhzZSksMD09c2UmJihudWxsIT09Y2UmJihjbGVhckludGVydmFsKGNlKSxjZT1udWxsKSxmZSkpe3ZhciBuPWZlO2ZlPW51bGwsbigpfX1mdW5jdGlvbiBfZSh0KXt0aHJvdyBlLm9uQWJvcnQmJmUub25BYm9ydCh0KSxUKHQrPSIiKSxGKHQpLE09ITAsdD0iYWJvcnQoIit0KyIpLiBCdWlsZCB3aXRoIC1zIEFTU0VSVElPTlM9MSBmb3IgbW9yZSBpbmZvLiIsbmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih0KX1lLnByZWxvYWRlZEltYWdlcz17fSxlLnByZWxvYWRlZEF1ZGlvcz17fTt2YXIgZGU9ImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCwiO2Z1bmN0aW9uIGhlKGUpe3JldHVybiBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGg/ZS5zdGFydHNXaXRoKGRlKTowPT09ZS5pbmRleE9mKGRlKX12YXIgbWU9Ik9nZ09wdXNFbmNvZGVyLndhc20iO2Z1bmN0aW9uIHllKCl7dHJ5e2lmKGspcmV0dXJuIG5ldyBVaW50OEFycmF5KGspO2lmKEIpcmV0dXJuIEIobWUpO3Rocm93ImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkIn1jYXRjaChlKXtfZShlKX19ZnVuY3Rpb24gdmUoKXtyZXR1cm4ga3x8IUMmJiFTfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2g/bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7ZSh5ZSgpKX0pKTpmZXRjaChtZSx7Y3JlZGVudGlhbHM6InNhbWUtb3JpZ2luIn0pLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKCFlLm9rKXRocm93ImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJyIrbWUrIiciO3JldHVybiBlLmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIHllKCl9KSl9ZnVuY3Rpb24gYmUoKXt2YXIgdD17YTpSZX07ZnVuY3Rpb24gbih0LG4pe3ZhciByPXQuZXhwb3J0cztlLmFzbT1yLHBlKCl9ZnVuY3Rpb24gcihlKXtuKGUuaW5zdGFuY2UpfWZ1bmN0aW9uIG8oZSl7cmV0dXJuIHZlKCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsdCl9KSkudGhlbihlLChmdW5jdGlvbihlKXtGKCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAiK2UpLF9lKGUpfSkpfWlmKGxlKCksZS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBlLmluc3RhbnRpYXRlV2FzbSh0LG4pfWNhdGNoKGUpe3JldHVybiBGKCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAiK2UpLCExfXJldHVybiBmdW5jdGlvbigpe2lmKGt8fCJmdW5jdGlvbiIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8aGUobWUpfHwiZnVuY3Rpb24iIT10eXBlb2YgZmV0Y2gpcmV0dXJuIG8ocik7ZmV0Y2gobWUse2NyZWRlbnRpYWxzOiJzYW1lLW9yaWdpbiJ9KS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZSx0KS50aGVuKHIsKGZ1bmN0aW9uKGUpe0YoIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAiK2UpLEYoImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uIiksbyhyKX0pKX0pKX0oKSx7fX1mdW5jdGlvbiBnZSh0LG4pe3ZhciByPW5ldyBVaW50OEFycmF5KGUuSEVBUFU4LmJ1ZmZlcix0LG4pO2UuZW5jb2RlZEJ1ZmZlcnMucHVzaChuZXcgVWludDhBcnJheShyKS5idWZmZXIpfWZ1bmN0aW9uIHdlKGUsdCxuLHIpe19lKCJBc3NlcnRpb24gZmFpbGVkOiAiK0woZSkrIiwgYXQ6ICIrW3Q/TCh0KToidW5rbm93biBmaWxlbmFtZSIsbixyP0wocik6InVua25vd24gZnVuY3Rpb24iXSl9ZnVuY3Rpb24gQWUoKXtfZSgpfWZ1bmN0aW9uIENlKGUsdCxuKXtxLmNvcHlXaXRoaW4oZSx0LHQrbil9ZnVuY3Rpb24gU2UoZSl7X2UoIk9PTSIpfWZ1bmN0aW9uIHhlKGUpe1NlKCl9aGUobWUpfHwobWU9aihtZSkpLFoucHVzaCh7ZnVuYzpmdW5jdGlvbigpe2tlKCl9fSk7dmFyIFBlPXttYXBwaW5nczp7fSxidWZmZXJzOltudWxsLFtdLFtdXSxwcmludENoYXI6ZnVuY3Rpb24oZSx0KXt2YXIgbj1QZS5idWZmZXJzW2VdOzA9PT10fHwxMD09PXQ/KCgxPT09ZT9UOkYpKHoobiwwKSksbi5sZW5ndGg9MCk6bi5wdXNoKHQpfSx2YXJhcmdzOnZvaWQgMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUGUudmFyYXJncys9NCxOW1BlLnZhcmFyZ3MtND4+Ml19LGdldFN0cjpmdW5jdGlvbihlKXtyZXR1cm4gTChlKX0sZ2V0NjQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZX19O2Z1bmN0aW9uIEVlKGUpe3JldHVybiAwfWZ1bmN0aW9uIEJlKGUsdCxuLHIsbyl7fWZ1bmN0aW9uIEllKGUsdCxuLHIpe2Zvcih2YXIgbz0wLGk9MDtpPG47aSsrKXtmb3IodmFyIHU9Tlt0KzgqaT4+Ml0sYT1OW3QrKDgqaSs0KT4+Ml0scz0wO3M8YTtzKyspUGUucHJpbnRDaGFyKGUscVt1K3NdKTtvKz1hfXJldHVybiBOW3I+PjJdPW8sMH12YXIgUmU9e2E6d2UsYzpBZSxkOmdlLGY6Q2UsZzp4ZSxoOkVlLGU6QmUsYjpJZSxtZW1vcnk6VSx0YWJsZTpIfSxPZT1iZSgpO2UuYXNtPU9lO3ZhciBqZSxrZT1lLl9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihrZT1lLl9fX3dhc21fY2FsbF9jdG9ycz1lLmFzbS5pKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFVlPShlLl9fX2VtX2pzX19lbXNjcmlwdGVuUHVzaEJ1ZmZlcj1mdW5jdGlvbigpe3JldHVybihlLl9fX2VtX2pzX19lbXNjcmlwdGVuUHVzaEJ1ZmZlcj1lLmFzbS5qKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX2Vtc2NyaXB0ZW5fYmluZF9Wb2lkUHRyX19fZGVzdHJveV9fXzA9ZnVuY3Rpb24oKXtyZXR1cm4oVWU9ZS5fZW1zY3JpcHRlbl9iaW5kX1ZvaWRQdHJfX19kZXN0cm95X19fMD1lLmFzbS5rKS5hcHBseShudWxsLGFyZ3VtZW50cyl9KSxUZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX0NvbnRhaW5lcl8wPWZ1bmN0aW9uKCl7cmV0dXJuKFRlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfQ29udGFpbmVyXzA9ZS5hc20ubCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxGZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX2luaXRfMz1mdW5jdGlvbigpe3JldHVybihGZT1lLl9lbXNjcmlwdGVuX2JpbmRfQ29udGFpbmVyX2luaXRfMz1lLmFzbS5tKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfd3JpdGVGcmFtZV8zPWZ1bmN0aW9uKCl7cmV0dXJuKEhlPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfd3JpdGVGcmFtZV8zPWUuYXNtLm4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTWU9ZS5fZW1zY3JpcHRlbl9iaW5kX0NvbnRhaW5lcl9fX2Rlc3Ryb3lfX18wPWZ1bmN0aW9uKCl7cmV0dXJuKE1lPWUuX2Vtc2NyaXB0ZW5fYmluZF9Db250YWluZXJfX19kZXN0cm95X19fMD1lLmFzbS5vKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIFdlKGUpe3RoaXMubmFtZT0iRXhpdFN0YXR1cyIsdGhpcy5tZXNzYWdlPSJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCIrZSsiKSIsdGhpcy5zdGF0dXM9ZX1mdW5jdGlvbiBEZSh0KXtmdW5jdGlvbiBuKCl7amV8fChqZT0hMCxlLmNhbGxlZFJ1bj0hMCxNfHwocmUoKSxvZSgpLGUub25SdW50aW1lSW5pdGlhbGl6ZWQmJmUub25SdW50aW1lSW5pdGlhbGl6ZWQoKSxpZSgpKSl9dD10fHxBLHNlPjB8fChuZSgpLHNlPjB8fChlLnNldFN0YXR1cz8oZS5zZXRTdGF0dXMoIlJ1bm5pbmcuLi4iKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS5zZXRTdGF0dXMoIiIpfSksMSksbigpfSksMSkpOm4oKSkpfWlmKGUuX29wdXNfZW5jb2Rlcl9jcmVhdGU9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fb3B1c19lbmNvZGVyX2NyZWF0ZT1lLmFzbS5wKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX29wdXNfZW5jb2RlX2Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX29wdXNfZW5jb2RlX2Zsb2F0PWUuYXNtLnEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fb3B1c19lbmNvZGVyX2N0bD1mdW5jdGlvbigpe3JldHVybihlLl9vcHVzX2VuY29kZXJfY3RsPWUuYXNtLnIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fb3B1c19lbmNvZGVyX2Rlc3Ryb3k9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fb3B1c19lbmNvZGVyX2Rlc3Ryb3k9ZS5hc20ucykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fbWFsbG9jPWUuYXNtLnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fZnJlZT1mdW5jdGlvbigpe3JldHVybihlLl9mcmVlPWUuYXNtLnUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ9ZS5hc20udikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1mdW5jdGlvbigpe3JldHVybihlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveT1lLmFzbS53KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuKGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0PWUuYXNtLngpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5keW5DYWxsX3ZpPWZ1bmN0aW9uKCl7cmV0dXJuKGUuZHluQ2FsbF92aT1lLmFzbS55KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGUuZHluQ2FsbF92PWZ1bmN0aW9uKCl7cmV0dXJuKGUuZHluQ2FsbF92PWUuYXNtLnopLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZS5hc209T2UsZS50aGVuPWZ1bmN0aW9uKHQpe2lmKGplKXQoZSk7ZWxzZXt2YXIgbj1lLm9uUnVudGltZUluaXRpYWxpemVkO2Uub25SdW50aW1lSW5pdGlhbGl6ZWQ9ZnVuY3Rpb24oKXtuJiZuKCksdChlKX19cmV0dXJuIGV9LGZlPWZ1bmN0aW9uIGUoKXtqZXx8RGUoKSxqZXx8KGZlPWUpfSxlLnJ1bj1EZSxlLnByZUluaXQpZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBlLnByZUluaXQmJihlLnByZUluaXQ9W2UucHJlSW5pdF0pO2UucHJlSW5pdC5sZW5ndGg+MDspZS5wcmVJbml0LnBvcCgpKCk7ZnVuY3Rpb24gemUoKXt9ZnVuY3Rpb24gTGUoZSl7cmV0dXJuKGV8fHplKS5fX2NhY2hlX199ZnVuY3Rpb24gVmUoZSx0KXt2YXIgbj1MZSh0KSxyPW5bZV07cmV0dXJuIHJ8fCgocj1PYmplY3QuY3JlYXRlKCh0fHx6ZSkucHJvdG90eXBlKSkucHRyPWUsbltlXT1yKX1mdW5jdGlvbiBxZShlLHQpe3JldHVybiBWZShlLnB0cix0KX1mdW5jdGlvbiBOZShlKXtpZighZS5fX2Rlc3Ryb3lfXyl0aHJvdyJFcnJvcjogQ2Fubm90IGRlc3Ryb3kgb2JqZWN0LiAoRGlkIHlvdSBjcmVhdGUgaXQgeW91cnNlbGY/KSI7ZS5fX2Rlc3Ryb3lfXygpLGRlbGV0ZSBMZShlLl9fY2xhc3NfXylbZS5wdHJdfWZ1bmN0aW9uIEdlKGUsdCl7cmV0dXJuIGUucHRyPT09dC5wdHJ9ZnVuY3Rpb24gWGUoZSl7cmV0dXJuIGUucHRyfWZ1bmN0aW9uIFllKGUpe3JldHVybiBlLl9fY2xhc3NfX31mdW5jdGlvbiAkZSgpe3Rocm93ImNhbm5vdCBjb25zdHJ1Y3QgYSBWb2lkUHRyLCBubyBjb25zdHJ1Y3RvciBpbiBJREwifWZ1bmN0aW9uIEplKCl7dGhpcy5wdHI9VGUoKSxMZShKZSlbdGhpcy5wdHJdPXRoaXN9cmV0dXJuIERlKCksemUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoemUucHJvdG90eXBlKSx6ZS5wcm90b3R5cGUuY29uc3RydWN0b3I9emUsemUucHJvdG90eXBlLl9fY2xhc3NfXz16ZSx6ZS5fX2NhY2hlX189e30sZS5XcmFwcGVyT2JqZWN0PXplLGUuZ2V0Q2FjaGU9TGUsZS53cmFwUG9pbnRlcj1WZSxlLmNhc3RPYmplY3Q9cWUsZS5OVUxMPVZlKDApLGUuZGVzdHJveT1OZSxlLmNvbXBhcmU9R2UsZS5nZXRQb2ludGVyPVhlLGUuZ2V0Q2xhc3M9WWUsJGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoemUucHJvdG90eXBlKSwkZS5wcm90b3R5cGUuY29uc3RydWN0b3I9JGUsJGUucHJvdG90eXBlLl9fY2xhc3NfXz0kZSwkZS5fX2NhY2hlX189e30sZS5Wb2lkUHRyPSRlLCRlLnByb3RvdHlwZS5fX2Rlc3Ryb3lfXz0kZS5wcm90b3R5cGUuX19kZXN0cm95X189ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnB0cjtVZShlKX0sSmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoemUucHJvdG90eXBlKSxKZS5wcm90b3R5cGUuY29uc3RydWN0b3I9SmUsSmUucHJvdG90eXBlLl9fY2xhc3NfXz1KZSxKZS5fX2NhY2hlX189e30sZS5Db250YWluZXI9SmUsSmUucHJvdG90eXBlLmluaXQ9SmUucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMucHRyO2UmJiJvYmplY3QiPT09YShlKSYmKGU9ZS5wdHIpLHQmJiJvYmplY3QiPT09YSh0KSYmKHQ9dC5wdHIpLG4mJiJvYmplY3QiPT09YShuKSYmKG49bi5wdHIpLEZlKHIsZSx0LG4pfSxKZS5wcm90b3R5cGUud3JpdGVGcmFtZT1KZS5wcm90b3R5cGUud3JpdGVGcmFtZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcy5wdHI7ZSYmIm9iamVjdCI9PT1hKGUpJiYoZT1lLnB0ciksdCYmIm9iamVjdCI9PT1hKHQpJiYodD10LnB0ciksbiYmIm9iamVjdCI9PT1hKG4pJiYobj1uLnB0ciksSGUocixlLHQsbil9LEplLnByb3RvdHlwZS5fX2Rlc3Ryb3lfXz1KZS5wcm90b3R5cGUuX19kZXN0cm95X189ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnB0cjtNZShlKX0sZX0pOyJvYmplY3QiPT09YSh0KSYmIm9iamVjdCI9PT1hKGkpP2kuZXhwb3J0cz1wOnZvaWQgMD09PSh1PWZ1bmN0aW9uKCl7cmV0dXJuIHB9LmFwcGx5KHQsW10pKXx8KGkuZXhwb3J0cz11KX0pLmNhbGwodGhpcywiL2luZGV4LmpzIixuKDIpLCIvIixuKDMpKGUpKX1dKTt9fSk7","base64")))
      },
      OggOpusEncoderWasmPath: tob(Buffer("AGFzbQEAAAABtwVDYAF/AX9gBH9/f38AYAN/f38AYAF/AGACf38Bf2AFf39/f38AYAJ/fwBgA39/fwF/YAZ/f39/f38AYAZ/f39/f38Bf2AFf39/f38Bf2AEf39/fwF/YAAAYAd/f39/f39/AGABfAF8YAh/f39/f39/fwBgC39/f39/f39/f39/AGAHf39/f39/fwF/YAR/f39/AX1gCX9/f39/f39/fwBgCn9/f39/f39/f38AYA9/f39/f39/f39/f39/f38AYAR/f31/AGAEf35+fwBgAAF/YAp/f39/f39/f39/AX9gC39/f39/f39/f39/AX9gBn98f39/fwF/YAJ+fwF/YAJ8fwF8YAJ8fAF8YAx/f39/f39/f39/f38AYBF/f39/f39/f39/f39/f39/fwBgFn9/f39/f39/f39/f39/f39/f39/f38AYBp/f39/f39/f39/f39/f39/f39/f39/f39/fwBgDH9/f39/fX1/f39/fwBgBH9/f30AYAN/f30AYAV/f31/fwBgCX9/fX1/f39/fwBgA399fwBgCX9/f39/f39/fwF/YAx/f39/f39/f39/f38Bf2ASf39/f39/f39/f39/f39/f39/AX9gD39/f39/f39/f39/f399fwF/YAp/f39/f39/f31/AX9gC39/f39/f39/fX9/AX9gCX9/f39/f399fwF/YAd/f39/f399AX9gCX9/f39/f31/fwF/YAt/f39/f399fX9/fwF/YAR/f39+AX9gA35/fwF/YAF9AX9gAn1/AX9gAnx/AX9gA39+fwF+YAN/f38BfWAJf39/f39/f39/AX1gE39/f39/f39/f39/f39/f39/f38BfWAGf39/f31/AX1gBn9/fX9/fwF9YAR9fX9/AX1gAn9/AXxgA39/fwF8YAJ+fgF8YAN8fH8BfAJMCgFhAWEAAQFhAWIACwFhAWMADAFhAWQABgFhAWUACgFhAWYABwFhAWcAAAFhAWgAAAFhBm1lbW9yeQIBgAKAAgFhBXRhYmxlAXAAJAPRAs8CBwEHBwMANQI/BQIHBwACLgAHAAsdHAADAAAJL0IeDgAAQAYGAgQFAwADBAUABh4MDgUFJQEAAQQACAIBAgAKAAATBhoNCAgHAAUBAg4OBQUBCwUHAAEEBAQDAgAdBAcIPgAnKgcKBwQ6AQAQAQIA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ACACRQ0AGiAEQQh1IgEgBEEBcUUNABogAigCACABaigCAAsgAmogA0ECIARBAnEbIAAoAgAoAhwRAQALHAAgABDFAiABBEAgACABEMICIAAgARC+AgsgAAsLACAAIAE2AgAgAAsjACAAQQA2AgwgACABNgIEIAAgATYCACAAIAFBAWo2AgggAAspAQF/IwBBEGsiASQAIAFBADYCDEGIGigCACIBIAAQugEgARCuARACAAujAgACQAJAIAFBFEsNACABQXdqIgFBCUsNAAJAAkACQAJAAkACQAJAAkAgAUEBaw4JAQIJAwQFBgkHAAsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgACACQQoRBgALDwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC0IBA38gACgCACwAABAhBEADQCAAKAIAIgIsAAAhAyAAIAJBAWo2AgAgAyABQQpsakFQaiEBIAIsAAEQIQ0ACwsgAQt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARBkIQAgASgCAEFAags2AgAgAA8LIAEgAkGCeGo2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLEgAgAEUEQEEADwsgACABEL4BC+4FAgp/AX4CQCAARQ0AIAAoAhwiB0H/ASAHQf8BSBsiA0UNACAAKAIAIghFDQACQAJAAkAgACgCzAIiCQRAIAdBAU4NAUJ/IQ1BACEDDAILIANBACADQQBKGyEDA0AgAyAFRg0CIAVBAnQhBiAFQQFqIgQhBSAGIAAoAhBqLQAAQf8BRg0ACyAEIQMMAQsgA0EBIANBAUobIQRCfyENQQAhAwJAA0AgBUGAIEwgBkEDTHJFBEBBASECDAILQQAhBiAAKAIQIANBAnRqLQAAIgpB/wFHBEAg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BUGBAiAFQYECSBshBkEBIARB6QdHDQEaIA1BwANqIAZBfmpBgAIQLEEBDAELIABBADYCwG5BACEGQQALIQUCfyASKAIAIgdB6AdGBEAgDSgC3AMhBCANKALUAyEIIA1BwANqEJYBIAggBGdqQWdqQQN1IgwMAQsgDUHAA2ogGCAGayIMECtBAAshCAJAAkAgBUUEQCASKAIAQegHRg0BCyANIA1BqARqNgLwASAOQabOACANQfABahALGiASKAIAQekHRw0AIA0gACgCZDYCuAMgDSAAKAJoNgK8AyANIA1BuANqNgLQASAOQazOACANQdABahALGgwBCyANQQA2AuABIA5BrM4AIA1B4AFqEAsaCyAUQQBHIAVxIgRBAUYEQCANQQA2AsABIA5Bms4AIA1BwAFqEAsaIA1BADYCsAEgDkGmHyANQbABahALGiANQX82AqABIA5Boh8gDUGgAWoQCxpBfSAOIBEgACgCkAFByAFtIAwgF2ogBkEAECJBAEgNARogDSANQegEajYCkAEgDkG/HyANQZABahALGiAOQbwfQQAQCxoLIA1BAEERIAdB6gdGGzYCgAEgDkGazgAgDUGAAWoQCxoCQCASKAIAIgdB6AdGDQAgByAAKAKsbiILRiALQQFIckUEQCAOQbwfQQAQCxogDiAJIAAoApABQZADbSANQbgDakECQQAQIhogDUEANgJwIA5Bks4AIA1B8ABqEAsaCyANKALUAyANKALcA2dqQWBqIAxBA3RKDQACQCAERQ0AIBIoAgBB6QdHDQAgACgClAFFDQAgDSAAKAKgASAAKAIkazYCYCAOQaIfIA1B4ABqEAsaCyANIAAoApQBNgJQIA5Bph8gDUHQAGoQCxpBfSAOIBEgAkEAIAwgDUHAA2oQIiIIQQBIDQEaIARFDQAgEigCAEHpB0cNACAAKAKUAUUNACAIIBdqIAwgF2ogBhATGiAGIAxqIQwLAkAgFCAFRXJFBEAgACgCkAEhBCAOQbwfQQAQCxogDUEANgJAIA5Bms4AIA1BQGsQCxogDUEANgIwIA5Bks4AIA1BMGoQCxogDUEANgIgIA5Bph8gDUEgahALGiANQX82AhAgDkGiHyANQRBqEAsaIARBkANtIQcgBEHIAW0hBCAAKAKobkHpB0YEQCANQcADaiAIECsgCCEMCyAOIBEgACgC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ABAUBEAgASACIAMQRA8LIAAoAgwhBCAAQRBqIgUgASACIAMQXQJAIARBAkgNACAFIARBA3RqIQQgAEEYaiEAA0AgACABIAIgAxBdIAEtADYNASAAQQhqIgAgBEkNAAsLCzEAIAAgASgCCEEAEBQEQCABIAIgAxBEDwsgACgCCCIAIAEgAiADIAAoAgAoAhwRAQALGAAgACABKAIIQQAQFARAIAEgAiADEEQLC6gCAQR/IwBBQGoiASQAIAAoAgAiAkF8aigCACEDIAJBeGooAgAhBCABQQA2AhQgAUH0GzYCECABIAA2AgwgAUGkHDYCCEEAIQIgAUEYakEAQScQChogACAEaiEAAkAgA0GkHEEAEBQEQCABQQE2AjggAyABQQhqIAAgAEEBQQAgAygCACgCFBEIACAAQQAgASgCIEEBRhshAgwBCyADIAFBCGogAEEBQQAgAygCACgCGBEFACABKAIsIgBBAUsNACAAQQFrBEAgASgCHEEAIAEoAihBAUYbQQAgASgCJEEBRhtBACABKAIwQQFGGyECDAELIAEoAiBBAUcEQCABKAIwDQEgASgCJEEBRw0BIAEoAihBAUcNAQsgASgCGCECCyABQUBrJAAgAgueAQEBfyMAQUBqIgMkAAJ/QQEgACABQQAQFA0AGkEAIAFFDQAaQQAgARCmASIBRQ0AGiADQX82AhQgAyAANgIQIANBADYCDCADIAE2AgggA0EYakEAQScQChogA0EBNgI4IAEgA0EIaiACKAIAQQEgASgCACgCHBEBAEEAIAMoAiBBAUcNABogAiADKAIYNgIAQQELIQAgA0FAayQAIAALSgECfwJAIAAtAAAiAkUgAiABLQAAIgNHcg0AA0AgAS0AASEDIAAtAAEiAkUNASABQQFqIQEgAEEBaiEAIAIgA0YNAAsLIAIgA2sLCABBmhsQYQALMgEBfyMAQRBrIgEkACABQQhqIAAoAgQQXygCAEEBOgAAIAAoAghBAToAACABQRBqJAALMwECfwJAIAAoAggiAC0AACICQQFHBH8gAkECcQ0BIABBAjoAAEEBBUEACw8LQeQaEGEACzUBAn8jAEEQayIBJAAgAUEIaiAAKAIEEF8oAgAtAABBAUcEQCAAEKsBIQILIAFBEGokACACC1ABA38jAEEQayIBJAAgAUE2EF4iAigCACIDEMoB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CyAAQSAgAiALIBEgCUEQamsgD2sgB2ogAyARaiAPa0ECaiADRSAHIAlrQW5qIANOchsiA2oiDCAEEBEgACANIAsQDyAAQTAgAiAMIARBgIAEcxARIAAgCUEQaiAHIAlBEGprIgUQDyAAQTAgAyAFIBEgD2siA2prQQBBABARIAAgDyADEA8LIABBICACIAwgBEGAwABzEBEgCUGwBGokACACIAwgDCACSBsLNAAgAFBFBEADQCABQX9qIgEgAKdBD3FB0BlqLQAAIAJyOgAAIABCBIgiAEIAUg0ACwsgAQstACAAUEUEQANAIAFBf2oiASAAp0EHcUEwcjoAACAAQgOIIgBCAFINAAsLIAELWQAgACABIAIgAxBxIABBEGogAxDGAQRAQagJQbQJQR5B0AkQAAALIABCADcDiAMgAEIANwKUAyAAQQE2ApADIABCADcCnAMgAEEANgKkAyAAELMBIAAQrQELyAIBBH8jAEHQAWsiAiQAIAJBADYCzAEgAkGgAWpBAEEoEAoaIAIgAigCzAE2AsgBAkBBACABIAJByAFqIAJB0ABqIAJBoAFqEEZBAEgNACAAKAJMQQBOBEBBASEECyAAKAIAIQMgACwASkEATARAIAAgA0FfcTYCAAsgA0EgcSEFAn8gACgCMARAIAAgASACQcgBaiACQdAAaiACQaABahBGDAELIABB0AA2AjAgACACQdAAajYCECAAIAI2AhwgACACNgIUIAAoAiwhAyAAIAI2AiwgACABIAJByAFqIAJB0ABqIAJBoAFqEEYgA0UNABogAEEAQQAgACgCJBEHABogAEEANgIwIAAgAzYCLCAAQQA2AhwgAEEANgIQIAAoAhQaIABBADYCFEEACxogACAAKAIAIAVyNgIAIARFDQALIAJB0AFqJAAL2QMCAn8CfiMAQSBrIgIkAAJAIAFC////////////AIMiBUKAgICAgIDA/0N8IAVCgICAgICAwIC8f3xUBEAgAUIEhiAAQjyIhCEEIABC//////////8PgyIAQoGAgICAgICACFoEQCAEQoGAgICAgICAwAB8IQQMAgsgBEKAgICAgICAgEB9IQQgAEKAgICAgICAgAiFQgBSDQEgBEIBgyAEfCEEDAELIABQIAVCgICAgICAwP//AFQgBUKAgICAgIDA//8AURtFBEAgAUIEhiAAQjyIhEL/////////A4NCgICAgICAgPz/AIQhBAwBC0KAgICAgICA+P8AIQQgBUL///////+//8MAVg0AQgAhBCAFQjCIpyIDQZH3AEkNACACQRBqIAAgAUL///////8/g0KAgICAgIDAAIQiBCADQf+If2oQvQEgAiAAIARBgfgAIANrELwBIAIpAwhCBIYgAikDACIAQjyIhCEEIAIpAxAgAikDGIRCAFKtIABC//////////8Pg4QiAEKBgICAgICAgAhaBEAgBEIBfCEEDAELIABCgICAgICAgIAIhUIAUg0AIARCAYMgBHwhBAsgAkEgaiQAIAQgAUKAgICAgICAgIB/g4S/C1ABAX4CQCADQcAAcQRAIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC1ABAX4CQCADQcAAcQRAIAEgA0FAaq2GIQJCACEBDAELIANFDQAgAiADrSIEhiABQcAAIANrrYiEIQIgASAEhiEBCyAAIAE3AwAgACACNwMIC4sCAAJAIAAEfyABQf8ATQ0BAkBB4OECKAIAKAIARQRAIAFBgH9xQYC/A0YNAwwBCyABQf8PTQRAIAAgAUE/cUGAAXI6AAEgACABQQZ2QcABcjoAAEECDwsgAUGAsANPQQAgAUGAQHFBgMADRxtFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAw8LIAFBgIB8akH//z9NBEAgACABQT9xQYABcjoAAyAAIAFBEnZB8AFyOgAAIAAgAUEGdkE/cUGAAXI6AAIgACABQQx2QT9xQYABcjoAAUEEDwsLQfDjAkEZNgIAQX8FQQELDwsgACABOgAAQQELvAEBAX8gAUEARyECAkACQAJAAkAgAUUgAEEDcUVyDQADQCAALQAARQ0CIABBAWohACABQX9qIgFBAEchAiABRQ0BIABBA3ENAAsLIAJFDQELIAAtAABFDQECQCABQQRPBEADQCAAKAIAIgJBf3MgAkH//ft3anFBgIGChHhxDQIgAEEEaiEAIAFBfGoiAUEDSw0ACwsgAUUNAQsDQCAALQAARQ0CIABBAWohACABQX9qIgENAAsLQQAPCyAAC00BAn8CQCAARQ0AIAAo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BygCSBAMIAcoAkwQDCAHKAI8EAwgBygCRBAMIAcoAkAQDCAHEAxBACEHCyAGRQ0AIAYgADYCAAsgBwsTACAAIAEgAiABIAIgAyAEENYBC84BAQJ/IwBBEGsiASQAAkAgAL1CIIinQf////8HcSICQfvDpP8DTQRAIAJBgIDA8gNJDQEgAEQAAAAAAAAAAEEAECQhAAwBCyACQYCAwP8HTwRAIAAgAKEhAAwBCyAAIAEQeEEDcSICQQJNBEACQAJAAkAgAkEBaw4CAQIACyABKwMAIAErAwhBARAkIQAMAwsgASsDACABKwMIECUhAAwCCyABKwMAIAErAwhBARAkmiEADAELIAErAwAgASsDCBAlmiEACyABQRBqJAAgAAu6FwEDfyMAQeABayIDJAAgAyACNgLcASAAIAAoAgBqIQRBeyECAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQeBgaiIFQS9LBEAgAUHhsX9qIgVBC00NASABQYaqf2oiAUERSw0mAkACQAJAIAFBAWsOESkpKSkpKSkpKSkpKSkpKQABAgsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFqQeUASw0oIAAgATYCjAFBACECDCgLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwoCyABIAAoAowBNgIAQQAhAgwnCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUGYeGpBA08EQEF/IQIgAUGYeEcNJwsgACABNgKIAUEAIQIMJgsgBUEBaw4vIyIhHh0SERwbGBcWFRQTGhklJRAPIB8ODSUMAQslCiUlJSUJCCUlBwYFBCUlAwIkCwJAAkACQCAFQQFrDgsnJycnJycnJwInAQALIAMgAygC3AEiAEEEajYC3AEgACgCACIARQRAQX8hAgwnCyADIAA2AnAgBEGfzgAgA0HwAGoQCyECDCYLIAMgAygC3AEiAUEEajYC3AEgACABKAIAIgA2AshuIAMgADYCYCAEQarOACADQeAAahALIQIMJQsgAyADKALcASIBQQRqNgLcASAAIAEoAgAiADYCsAEgAyAANgJQIARBqM4AIANB0ABqEAshAgwkCyAAKAIEIQEg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BCACIApqIAxqQQF0ai4BAEEDdSIOIA5saiEDIAJBAWoiAiAFRw0ACyABIANqIgFB/////wcgAUH/////B0kbIQEgCEEDbCEIIAYoAgAhBkEAIQJBACEDA0AgAyAEIAIgCGogBmpBAXRqLgEAQQN1IgogCmxqIQMgAkEBaiICIAVHDQALCyALIAEgA0EBdmoiAUH/////ByABQf////8HSRs2AgAgDSADNgI4IAlBAWoiCUEERw0AC0EAIQUgACgCjAEiCUHnB0wEQEH//wEgCUEEdUEBam0hBQtB/////wcgBygCICIIIAAoAnxqIgFB/////wcgAUH/////B0kbIgRuIQNBgAEhASAAAn9BgAEgBCAAKAJcIgJBA3RKDQAaQYAIIAQgAkgNABogAkEQdEEQdSIEIANBEHZsIAMgAkEPdUEBakEBdWxqIANB//8DcSAEbEEQdWoiAkEQdUELdCACQQV2Qf8PcXILIgIgBSACIAVKG0EQdEEQdSICIAMgACgCbCIDayIEQRB1bCADaiACIARB//8DcWxBEHVqIgM2AmwgAEH/////ByADbSIDQf///wcgA0H///8HSBsiAzYCXEH/////ByAHKAIkIgogACgCgAFqIgJB/////wcgAkH/////B0kbIgZuIQICQCAGIAAoAmAiBEEDdEoNAEGACCEBIAYgBEgNACAEQRB0QRB1IgEgAkEQdmwgAiAEQQ91QQFqQQF1bGogAkH//wNxIAFsQRB1aiIBQRB1QQt0IAFBBXZB/w9xciEBCyAAIAEgBSABIAVKG0EQdEEQdSIBIAIgACgCcCICayIEQRB1bCACaiABIARB//8DcWxBEHVqIgE2AnAgAEH/////ByABbSIBQf///wcgAUH///8HSBs2AmBB/////wcgBygCKCIMIAAoAoQBaiIBQf////8HIAFB/////wdJGyIGbiECQYABIQEgAAJ/QYABIAYgACgCZCIEQQN0Sg0AGkGACCAGIARIDQAaIARBEHRBEHUiBiACQRB2bCACIARBD3VBAWpBAXVsaiACQf//A3EgBmxBEHVqIgRBEHVBC3QgBEEFdkH/D3FyCyIEIAUgBCAFShtBEHRBEHUiBCACIAAoAnQiAmsiBkEQdWwgAmogBCAGQf//A3FsQRB1aiICNgJ0IABB/////wcgAm0iAkH///8HIAJB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TW9kdWxlLkhFQVBVOC5idWZmZXIsIGJ1ZiwgbGVuKTsgTW9kdWxlLmVuY29kZWRCdWZmZXJzLnB1c2gobmV3IFVpbnQ4QXJyYXkoYXJyYXkpLmJ1ZmZlcik7IH0AAAAAAIwFAAABAAAAAgAAAHJlc3VsdCA9PSAwAC9idWlsZC9zcmMvT2dnQ29udGFpbmVyLmNwcABpbml0AHJlc3VsdCAhPSAwAHByb2R1Y2VJRFBhZ2UAcHJvZHVjZUNvbW1lbnRQYWdlACFvZ2dfc3RyZWFtX2NoZWNrKCZzdHJlYW1fc3RhdGVfKQBwcm9kdWNlUGFja2V0UGFnZQAhKGRhdGEgPT0gbnVsbHB0ciAmJiBzaXplID4gMCkAd3JpdGVQYWNrZXQAIW9nZ19zdHJlYW1fZW9zKCZzdHJlYW1fc3RhdGVfKQA5Q29udGFpbmVyALwOAACBBQAAAAAAAAEAAADYBgAAAAAAAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAAAAAANgGAAAHAAAACAAAAHNhbXBsZV9yYXRlID09IDQ4MDAwAC9idWlsZC9zcmMvQ29udGFpbmVySW50ZXJmYWNlLmNwcABpbml0AGNoYW5uZWxfY291bnQgPiAwICYmIGNoYW5uZWxfY291bnQgPD0gMgBoZWFkZXIAd3JpdGVPcHVzSWRIZWFkZXIAT3B1c0hlYWQAd3JpdGVPcHVzQ29tbWVudEhlYWRlcgBPcHVzVGFncwBvcHVzLW1lZGlhLXJlY29yZGVyAFRJVExFPXJlY29yZGluZwAxOENvbnRhaW5lckludGVyZmFjZQAAOA4AAMIGAAAAAAAAtx3BBG47ggnZJkMN3HYEE2trxReyTYYaBVBHHrjtCCYP8Mki1taKL2HLSytkmww104bNMQqgjjy9vU84cNsRTMfG0Ege4JNFqf1SQaytFV8bsNRbwpaXVnWLVlLINhlqfyvYbqYNm2MREFpnFEAdeaNd3H16e59wzWZedOC2I5hXq+Kcjo2hkTmQYJU8wCeLi93mj1L7pYLl5mSGWFsrvu9G6ro2YKm3gX1os4QtL60zMO6p6hatpF0LbKCQbTLUJ3Dz0P5WsN1JS3HZTBs2x/sG98MiILTOlT11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ycm8vLCNQijBwcHBwcHBwcHBwcHCwsK4uK2LQSfMzMzMzMzMzMnJycnGxsa7u6+MQigAQcK7AQu5KWAAwAAgAYABIACAAOAAQAGgAUAAoAAAAWABwAEIAGgAyAAoAYgBKACIAOgASAGoAUgAqAAIAWgByAEQAHAA0AAwAZABMACQAPAAUAGwAVAAsAAQAXAB0AEYAHgA2AA4AZgBOACYAPgAWAG4AVgAuAAYAXgB2AEEAGQAxAAkAYQBJACEAOQARAGkAUQApAAEAWQBxAEMAGwAzAAsAYwBLACMAOwATAGsAUwArAAMAWwBzAEUAHQA1AA0AZQBNACUAPQAVAG0AVQAtAAUAXQB1AEcAHwA3AA8AZwBPACcAPwAXAG8AVwAvAAcAXwB3AEBAGEAwQAhAYEBIQCBAOEAQQGhAUEAoQABAWEBwQEJAGkAyQApAYkBKQCJAOkASQGpAUkAqQAJAWkByQERAHEA0QAxAZEBMQCRAPEAUQGxAVEAsQARAXEB0QEZAHkA2QA5AZkBOQCZAPkAWQG5AVkAuQAZAXkB2QEFAGUAxQAlAYUBJQCFAOUARQGlAUUApQAFAWUBxQENAG0AzQAtAY0BLQCNAO0ATQGtAU0ArQANAW0BzQEVAHUA1QA1AZUBNQCVAPUAVQG1AVUAtQAVAXUB1QEdAH0A3QA9AZ0BPQCdAP0AXQG9AV0AvQAdAX0B3QECAGIAwgAiAYIBIgCCAOIAQgGiAUIAogACAWIBwgEKAGoAygAqAYoBKgCKAOoASgGqAUoAqgAKAWoBygESAHIA0gAyAZIBMgCSAPIAUgGyAVIAsgASAXIB0gEaAHoA2gA6AZoBOgCaAPoAWgG6AVoAugAaAXoB2gEGAGYAxgAmAYYBJgCGAOYARgGmAUYApgAGAWYBxgEOAG4AzgAuAY4BLgCOAO4ATgGuAU4ArgAOAW4BzgEWAHYA1gA2AZYBNgCWAPYAVgG2AVYAtgAWAXYB1gEeAH4A3gA+AZ4BPgCeAP4AXgG+AV4AvgAeAX4B3gEDAGMAwwAjAYMBIwCDAOMAQwGjAUMAowADAWMBwwELAGsAywArAYsBKwCLAOsASwGrAUsAqwALAWsBywETAHMA0wAzAZMBMwCTAPMAUwGzAVMAswATAXMB0wEbAHsA2wA7AZsBOwCbAPsAWwG7AVsAuwAbAXsB2wEHAGcA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aAAQACgAQABYAHAABAAcADQATABkAAwAJAA8AFQAbAAUACwARABcAHQAAQAZADEASQBhAAkAIQA5AFEAaQARACkAQQBZAHEABQAdADUATQBlAA0AJQA9AFUAbQAVAC0ARQBdAHUAAgAaADIASgBiAAoAIgA6AFIAagASACoAQgBaAHIABgAeADYATgBmAA4AJgA+AFYAbgAWAC4ARgBeAHYAAwAbADMASwBjAAsAIwA7AFMAawATACsAQwBbAHMABwAfADcATwBnAA8AJwA/AFcAbwAXAC8ARwBfAHcAeAAAAIiICDwCAAAABQAYAAMACAACAAQABAABAEG85wELBqByAACAYQBB0ucBC40BDAAYACQAMAAEABAAHAAoADQACAAUACAALAA4AAEADQAZACUAMQAFABEAHQApADUACQAVACEALQA5AAIADgAaACYAMgAGABIAHgAqADYACgAWACIALgA6AAMADwAbACcAMwAHABMAHwArADcACwAXACMALwA7ADwAAACJiIg8AwAAAAUADAADAAQABAABAEH06AELLNBzAACAYQAAAAAAAAAAnT4AQF4+AMAEPgCA7T4AQIk+AAAAAADATD8AAM09AEGx6QELowH/AP8A/wD/AP8A/gEAAf8A/gD9AgAB/wD+AP0DAAH/lYsAADeYAAD/pQAABLUAAGfFAABF1wAAweoAAP//AAAAAM5AAADIQAAAuEAAAKpAAACiQAAAmkAAAJBAAACMQAAAnEAAAJZAAACSQAAAjkAAAJxAAACUQAAAikAAAJBAAACMQAAAlEAAAJhAAACOQAAAcEAAAHBAAABwQAAAcEAAAHBAAEHg6gEL8gJIf0GBQoBBgECAPoBAgECAXE5cT1xOWk90KXMociiEGoQakRGhDLAKsQsYszCKNoc2hDWGOIU3hDeEPXJGYEpYS1hXSllCW0NkO2wyeCh6JWErTjJTTlRRWEtWSldHWkldSl1KbShyJHUidSKPEZESkhOiDKUKsge9Br4IsQkXsjZzP2ZCYkVjSllHW0lbTllWUFxCXUBmO2c8aDx1NHssiiOFH2EmTS09Wl08aSprKW4tdCZxJnAmfBqEG4gTjBSbDp8QnhKqDbEKuwjABq8JnwoVsjtuR1ZLVVRTW0JYSVdIXEtiSGk6azZzNHI3cDiBM4QoliGMHWIjTSoqeWBCbCtv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","base64")),
      WebMOpusEncoderWasmPath: tob(Buffer("AGFzbQEAAAABngZTYAF/AX5gA39/fwF/YAF/AX9gBH9/f38AYAF/AGACf38Bf2ADf39/AGAFf39/f38AYAJ/fwBgAn9+AX9gBn9/f39/fwBgA39+fgBgBn9/f39/fwF/YAR/f39/AX9gBX9/f39/AX9gAABgB39/f39/f38AYAF8AXxgAn9/AX5gAAF/YAh/f39/f39/fwBgC39/f39/f39/f39/AGAHf39/f39/fwF/YAN/fn4Bf2AEf39/fwF9YAl/f39/f39/f38AYAp/f39/f39/f39/AGAPf39/f39/f39/f39/f39/AGAEf399fwBgBH9+fn8AYAp/f39/f39/f39/AX9gC39/f39/f39/f39/AX9gBn98f39/fwF/YAJ+fwF/YAN/f38BfmADf35/AX5gAn5+AX5gAnx/AXxgAnx8AXxgDH9/f39/f39/f39/fwBgEX9/f39/f39/f39/f39/f39/AGAWf39/f39/f39/f39/f39/f39/f39/fwBgGn9/f39/f39/f39/f39/f39/f39/f39/f39/AGAMf39/f399fX9/f39/AGAEf39/fQBgBX9/fn5+AGADf399AGAFf399f38AYAl/f319f39/f38AYAJ/fgBgA399fwBgCX9/f39/f39/fwF/YAx/f39/f39/f39/f38Bf2ASf39/f39/f39/f39/f39/f39/AX9gD39/f39/f39/f39/f399fwF/YAp/f39/f39/f31/AX9gC39/f39/f39/fX9/AX9gCX9/f39/f399fwF/YAd/f39/f399AX9gCX9/f39/f31/fwF/YAt/f39/f399fX9/fwF/YAN/fn8Bf2AEf35/fgF/YAR/fn5/AX9gA39+fQF/YAN+f38Bf2ABfQF/YAJ9fwF/YAJ8fwF/YAJ/fgF+YAJ+fwF+YAN+f34BfmACfn0BfmADf39/AX1gCX9/f39/f39/fwF9YBN/f39/f39/f39/f39/f39/f39/AX1gBn9/f399fwF9YAZ/f31/f38BfWAEfX1/fwF9YAJ/fwF8YAN/f38BfGACfn4BfGADfHx/AXwCag8BYQFhAAMBYQFiAA8BYQFjAAIBYQFkAA0BYQFlAAEBYQFmAA0BYQFnAAEBYQFoAAEBYQFpAAIBYQFqAA4BYQFrAAEBYQFsAAIBYQFtAAgBYQZtZW1vcnkC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NgI8DAULIAMgAygCDCIBQQRqNgIMIAEoAgAiAUH0A0wEQEF/IQIgAUF/Rw0GCyAAIAEgACgCBEGg7w9sIgAgASAASBs2AigMBAsgAyADKAIMIgFBBGo2AgwgACABKAIANgIsDAMLIAMgAygCDCIBQQRqNgIMIAAgASgCADYCNAwCCyADIAMoAgwiAUEEajYCDEF/IQIgASgCACIBQeQASw0CIAAgATYCOAwBCyADIAMoAgwiAUEEajYCDEF/IQIgASgCACIBQQpLDQEgACABNgIYC0EAIQILIANBEGokACACC4YEAgR/An4jAEEQayIFJAACQCAARQ0AIAAgASAAIAAoAgAoAgQRAAAgACgCACgCEBELAEEBIQMCQCABQoACVA0AQQIhAyABQoCABFQNAEEDIQMgAUKAgIAIVA0AQQQhAyABQoCAgIAQVA0AQQUhAyABQoCAgICAIFQNAEEGIQMgAUKAgICAgIDAAFQNAEEHQQggAUKAgICAgICAgAFUGyIDQX9qQQdLDQELIANBAWqtIQhCASEHAkADQAJAIAUgASADIAena0EDdK2HPAANIAAgBUENakEBIAAoAgAoAgARAQAiBCAGIARBAEgbIQYgBEF/TA0AIAggB0IBfCIHUg0BDAILC0EAIQQgBg0BCyAFAn9BASACQoACVA0AGkECIAJCgIAEVA0AGkEDIAJCgICACFQNABpBBCACQoCAgIAQVA0AGkEFIAJCgICAgIAgVA0AGkEGIAJCgICAgICAwABUDQAaQQdBCCACQoCAgICAgICAAVQbCyIDQYABcjoADkEAIQQgACAFQQ5qQQEgACgCACgCABEBAEEASA0AIANBAWqtIQFCASEHAkADQCAFIAIgAyAHp2tBA3SthzwADyAAIAVBD2pBASAAKAIAKAIAEQEAIgQgBiAEQQBIGyEGIARBf0wNASAHQgF8IgcgAVINAAtBACEGCyAGRSEECyAFQRBqJAAgBAvfAQEBfkIBIQICfkIBIABCgAJUDQAaQgIgAEKAgARUDQAaQgMgAEKAgIAIVA0AGkIEIABCgICAgBBUDQAaQgUgAEKAgICAgCBUDQAaQgYgAEKAgICAgIDAAFQNABpCB0IIIABCgICAgICAgIABVBsLIQACQCABQv8AVA0AQgIhAiABQv//AFQNAEIDIQIgAUL///8AVA0AQgQhAiABQv////8AVA0AQgUhAiABQv//////AFQNAEIGIQIgAUL///////8AVA0AQgdCCCABQv////////8AVBshAgsgACACfAv6AwIEfwJ+IwBBEGsiBiQAAkAgAEUNACAAIAEgACAAKAIAKAIEEQAAIAAoAgAoAhARCwBBASEDAkAgAUKAAlQNAEECIQMgAUKAgARUDQBBAyEDIAFCgICACFQNAEEEIQMgAUKAgICAEFQNAEEFIQMgAUKAgICAgCBUDQBBBiEDIAFCgICAgICAwABUDQBBB0EIIAFCgICAgICAgIABVBsiA0F/akEHSw0BCyADQQFqrSEIQgEhBwJAA0ACQCAGIAEgAyAHp2tBA3SthzwADiAAIAZBDmpBASAAKAIAKAIAEQEAIgQgBSAEQQBIGyEFIARBf0wNACAIIAdCAXwiB1INAQwCCwtBACEEIAUNAQtBfyEFAkBCAQJ/QQEgAkL/AFQNABpBAiACQv//AFQNABpBAyACQv///wBUDQAaQQQgAkL/////AFQNABpBBSACQv//////AFQNABpBBiACQv///////wBUDQAaQQdBCCACQv////////8AVBsLIgNBB2ythiIBQn58IAJUDQAgASAChCEBIANBAWqtIQJCASEHA0AgBiABIAMgB6drQQN0rYc8AA8gACAGQQ9qQQEgACgCACgCABEBACIEIAUgBEEASBshBSAEQX9MDQEgB0IBfCIHIAJSDQALQQAhBQsgBUUhBAsgBkEQaiQAIAQLZQECfwJAQRggAGciAWsiAkUNACAAQf8ATQRAIAAgAUFoanQgAEE4IAFrdnIhAAwBCyAAIAFBCGp0IAAgAnZyIQALIABB/wBxIgAgAUEHdGsgAEGAASAAa2xBswFsQRB2akGAH2oLMAECfyAAQQEgABshAANAAkAgABApIgENAEH83gIoAgAiAkUNACACEQ8ADAELCyABCxsAIACQIgCLQwAAAE9dBEAgAKgPC0GAgICAeAt4ACABRQRAQgAPCwJ+QgIgAEKAAlQNABpCAyAAQoCABFQNABpCBCAAQoCAgAhUDQAaQgUgAEKAgICAEFQNABpCBiAAQoCAgICAIFQNABpCByAAQoCAgICAgMAAVA0AGkIIQgkgAEKAgICAgICAgAFUGwsgARAirXwLFwAgAC0AAEEgcUUEQCABIAIgABDq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CxgBAX8gABApIgEEQCABQQAgABARGgsgAQtJAQJ/IAAoAgQiBUEIdSEGIAAoAgAiACABIAVBAXEEfyACKAIAIAZqKAIABSAGCyACaiADQQIgBUECcRsgBCAAKAIAKAIYEQcACxYAIABFBEBBAA8LQfDeAiAANgIAQX8LmwQCBH8CfiMAQRBrIgYkAAJAIANQIABFIAJFcnINACAAIAEgACAAKAIAKAIEEQAAIAAoAgAoAhARCwBBASEFAkAgAUKAAlQNAEECIQUgAUKAgARUDQBBAyEFIAFCgICACFQNAEEEIQUgAUKAgICAEFQNAEEFIQUgAUKAgICAgCBUDQBBBiEFIAFCgICAgICAwABUDQBBB0EIIAFCgICAgICAgIABVBsiBUF/akEHSw0BCyAFQQFqrSEJQgEhCAJAA0ACQCAGIAEgBSAIp2tBA3SthzwADiAAIAZBDmpBASAAKAIAKAIAEQEAIgQgByAEQQBIGyEHIARBf0wNACAJIAhCAXwiCFINAQwCCwtBACEEIAcNAQtBACEEQgECf0EBIANC/wBUDQAaQQIgA0L//wBUDQAaQQMgA0L///8AVA0AGkEEIANC/////wBUDQAaQQUgA0L//////wBUDQAaQQYgA0L///////8AVA0AGkEHQQggA0L/////////AFQbCyIFQQdsrYYiAUJ+fCADVA0AIAEgA4QhASAFQQFqrSEJQgEhCAJAA0ACQCAGIAEgBSAIp2tBA3SthzwADyAAIAZBD2pBASAAKAIAKAIAEQEAIgQgByAEQQBIGyEHIARBf0wNACAJIAhCAXwiCFINAQwCCwtBACEEIAcNAQsgACACIAOnIAAoAgAoAgARAQBFIQQLIAZBEGokACAEC/QDAgV/An4jAEEQayIEJAACQCAARQ0AIAAgASAAIAAoAgAoAgQRAAAgACgCACgCEBELAEEBIQUCQCABQoACVA0AQQIhBSABQoCABFQNAEEDIQUgAUKAgIAIVA0AQQQhBSABQoCAgIAQVA0AQQUhBSABQoCAgICAIFQNAEEGIQUgAUKAgICAgIDAAFQNAEEHQQggAUKAgICAgICAgAFUGyIFQX9qQQdLDQELIAVBAWqtIQlCASEIAkADQAJAIAQgASAFIAina0EDdK2HPAANIAAgBEENakEBIAAoAgAoAgARAQAiAyAGIANBAEgb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CyAAQSAgDCAGIAlrIgogCCAIIApIGyIOaiIGIAsgCyAGSBsiASAGIAcQHSAAIA8gDBAaIABBMCABIAYgB0GAgARzEB0gAEEwIA4gCkEAEB0gACAJIAoQGiAAQSAgASAGIAdBgMAAcxAdDAELC0EAIQwMAQtBfyEMCyAFQdAAaiQAIAwLaQECfwJAIAAoAhQgACgCHE0NACAAQQBBACAAKAIkEQEAGiAAKAIUDQBBfw8LIAAoAgQiASAAKAIIIgJJBEAgACABIAJrrEEBIAAoAigRIwAaCyAAQQA2AhwgAEIANwMQIABCADcCBEEAC54FAgR/Bn4jAEEQayIDJAACQCAARQ0AAn5CASABQn98IgZC/wBUDQAaQgIgBkL//wBUDQAaQgMgBkL///8AVA0AGkIEIAZC/////wBUDQAaQgUgBkL//////wBUDQAaQgYgBkL///////8AVA0AGkIHQgggBkL/////////AFQbCyEHAn5CAiAGIAd9IgZC/wBUDQAaQgMgBkL//wBUDQAaQgQgBkL///8AVA0AGkIFIAZC/////wBUDQAaQgYgBkL//////wBUDQAaQgcgBkL///////8AVA0AGkIIQgkgBkL/////////AFQbCyAGfCABUg0AIAAgACgCACgCBBEAACIJQgBTDQAgAELsASAAIAAoAgAoAgQRAAAgACgCACgCEBELACADQewBOgAOQQEhAiAAIANBDmpBASAAKAIAKAIAEQEAQQBIDQACQCAGQv8AVA0AQQIhAiAGQv//AFQNAEEDIQIgBkL///8AVA0AQQQhAiAGQv////8AVA0AQQUhAiAGQv//////AFQNAEEGIQIgBkL///////8AVA0AQQdBCCAGQv////////8AVBshAgtCASACQQdsrYYiB0J+fCAGVA0AIAYgB4QhCiACQQFqrSELQgEhBwJAA0ACQCADIAogAiAHp2tBA3SthzwADyAAIANBD2pBASAAKAIAKAIAEQEAIgQgBSAEQQBIGyEFIARBf0wNACALIAdCAXwiB1INAQwCCwsgBQ0BC0EAIQIgA0EAOgANAkAgBqciBEEATA0AA0AgACADQQ1qQQEgACgCACgCABEBAEUEQCACQQFqIgIgBEgNAQwCCwsMAQsgAUIAIAEgACAAKAIAKAIEEQAAIgEgCX1RG0IAIAFCf1UbIQgL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AkACQAJAAkACQAJAAkAgAUEBaw4JAQIJAwQFBgkHAAsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgACACQSARCAALDwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC0IBA38gACgCACwAABA6BEADQCAAKAIAIgIsAAAhAyAAIAJBAWo2AgAgAyABQQpsakFQaiEBIAIsAAEQOg0ACwsgAQsDAAELdgEBfyAABEAgACgCTEF/TARAIAAQag8LIAAQag8LQaDeAigCAARAQaDeAigCABDBASEBC0Gs3gIoAgAiAARAA0AgACgCTEEATgR/QQEFQQALGiAAKAIUIAAoAhxLBEAgABBqIAFyIQELIAAoAjgiAA0ACwsgAQsmAQF/IwBBEGsiBCQAIAQgAzYCDCAAIAEgAiADEJcDIARBEGokAAsoAQF/AkAgAUUNACAAKAIEDQAgACABEI8DIgA2AgQgAEEARyECCyACC2UAIAAQKkEEdEGA/gNxIAAQKkEEdkH/AXFyQRB0IAAQKkEEdEGA/gNxciAAECpBBHZB/wFxcq1CEIYgABAqQQR0QYD+A3GthCAAECpBBHZB/wFxrYRCCIYgABAqQQR2Qf8Bca2EC9wTAgR/C34jAEEQayIDJAACQCAARSABRXINACACRSABEK4CIgRFcg0AIAIpAygiB1ANAEJ/IAEpAzggB4AgAikDIH0iByAHQv//AVYbIhBC//8BVg0AAn8CQCABKAIIDQAgASkDQEIAUg0AIAEpAxhQIQULIAULBEAgAEKjASAAIAAoAgAoAgQRAAAgACgCACgCEBELACADQaMBOgALQQEhAiAAIANBC2pBASAAKAIAKAIAEQEAQQBIDQECQCABKQMoQiCGQoCAgIBAfUIghyIIQv8AVA0AQQIhAiAIQv//AFQNAEEDIQIgCEL///8AVA0AQQQhAiAIQv////8AVA0AQQVBCCAIQv//////AFQbIQILQgEgAkEHbK2GIgdCfnwgCFQNASAHIAiEIQkgAkEBaq0hCkIBIQcCQANAAkAgAyAJIAIgB6drQQN0rYc8AAwgACADQQxqQQEgACgCACgCABEBACIFIAQgBUEASBshBCAFQX9MDQAgCiAHQgF8IgdSDQEMAgsLIAQNAgtCAQJ/QQEgASkDMCIHQv8AVA0AGkECIAdC//8AVA0AGkEDIAdC////AFQNABpBBCAHQv////8AVA0AGkEFIAdC//////8AVA0AGkEGIAdC////////AFQNABpBB0EIIAdC/////////wBUGwsiAkEHbK2GIglCfnwgB1QNASAHIAmEIQkgAkEBaq0hCkIBIQcCQANAAkAgAyAJIAIgB6drQQN0rYc8AA0gACADQQ1qQQEgACgCACgCABEBACIFIAQgBUEASBshBCAFQX9MDQAgCiAHQgF8IgdSDQEMAgsLIAQNAgsgAyAQQgiIPAAOIAAgA0EOakEBIAAoAgAoAgARAQAiBEEASA0BIAMgEDwADiAAIANBDmpBASAAKAIAKAIAEQEAIgJBf0xBACACIAQgAkEASBsbDQEgAyABLQAkQQBHQQd0OgAPIAAgA0EPakEBIAAoAgAoAgARAQBBAEgNASAAIAEoAiAgASgCKCAAKAIAKAIAEQEADQECfkIGIAhC/wBUDQAaQgcgCEL//wBUDQAaQgggCEL///8AVA0AGkIJIAhC/////wBUDQAaQgogCEL//////wBUDQAaQgsgCEL///////8AVA0AGkIMQg0gCEL/////////AFQbCyABKQMofCENDAELIAIpAyghDSABKAIIBEBCASEHAn5CASABKQMQIglC/wBUDQAaQgIgCUL//wBUDQAaQgMgCUL///8AVA0AGkIEIAlC/////wBUDQAaQgUgCUL//////wBUDQAaQgYgCUL///////8AVA0AGkIHQgggCUL/////////AFQbCyEKAkAgASkDACIIQoACVA0AQgIhByAIQoCABFQNAEIDIQcgCEKAgIAIVA0AQgQhByAIQoCAgIAQVA0AQgUhByAIQoCAgICAIFQNAEIGIQcgCEKAgICAgIDAAFQNAEIHQgggCEKAgICAgICAgAFUGyEHC0IBIQgCfkIBIAkgCnwgB3xCA3wiCUL/AFQNABpCAiAJQv//AFQNABpCAyAJQv///wBUDQAaQgQgCUL/////AFQNABpCBSAJQv//////AFQNABpCBiAJQv///////wBUDQAaQgdCCCAJQv////////8AVBsLIQcCQCAHIAl8QgF8IgpC/wBUDQBCAiEIIApC//8AVA0AQgMhCCAKQv///wBUDQBCBCEIIApC/////wBUDQBCBSEIIApC//////8AVA0AQgYhCCAKQv///////wBUDQBCB0IIIApC/////////wBUGyEICyAIIAp8QgJ8IQgLIAEpA0AiB1BFBEACfkIBIAdCP4cgB4VCAYYiB0KAAlQNABpCAiAHQoCABFQNABpCAyAHQoCAgAhUDQAaQgQgB0KAgICAEFQNABpCBSAHQoCAgICAIFQNABpCBiAHQoCAgICAgMAAVA0AGkIHQgggB0KAgICAgICAgAFUGwtCA3whEQsgASkDSCANgCELIAEtACRFBEACfkIBIAtCgAJUDQAaQgIgC0KAgARUDQAaQgMgC0KAgIAIVA0AGkIEIAtCgICAgBBUDQAaQgUgC0KAgICAgCBUDQAaQgYgC0KAgICAgIDAAFQNABpCB0IIIAtCgICAgICAgIABVBsLQgJ8IQ8LIAEpAxgiByANgCEMIAcgDVQiBkUEQAJ+QgEgDEKAAlQNABpCAiAMQoCABFQNABpCAyAMQoCAgAhUDQAaQgQgDEKAgICAEFQNABpCBSAMQoCAgICAIFQNABpCBiAMQoCAgICAgMAAVA0AGkIHQgggDEKAgICAgICAgAFUGwtCAnwhDgtCACENIABCoAECfkIBIAEpAyhCBHwiB0L/AFQNABpCAiAHQv//AFQNABpCAyAHQv///wBUDQAaQgQgB0L/////AFQNABpCBSAHQv//////AFQNABpCBiAHQv///////wBUDQAaQgdCCCAHQv////////8AVBsLIAggEXwgD3wgDnwgB3x8QgF8IggQFUUNACAAQqEBIAcQFUUNAEIBAn9BASABKQMwIgdC/wBUDQAaQQIgB0L//wBUDQAaQQMgB0L///8AVA0AGkEEIAdC/////wBUDQAaQQUgB0L//////wBUDQAaQQYgB0L///////8AVA0AGkEHQQggB0L/////////AFQbCyICQQdsrYYiDkJ+fCAHVA0AIAcgDoQhDiACQQFqrSEPQgEhBwJAA0ACQCADIA4gAiAHp2tBA3SthzwACiAAIANBCmpBASAAKAIAKAIAEQEAIgUgBCAFQQBIGyEEIAVBf0wNACAPIAdCAXwiB1INAQwCCwsgBA0BCyADIBBCCIg8AAkgACADQQlqQQEgACgCACgCABEBACIEQQBIDQAgAyAQPAAJIAAgA0EJakEBIAAoAgAoAgARAQAiAkF/TEEAIAIgBCACQQBIGxsNACADQQA6AAggACADQQhqQQEgACgCACgCABEBAEEASA0AIAAgASgCICABKAIoIAAoAgAoAgARAQANACABKAIIBEAgAEKh6wEgChAVRQ0BIABCpgEgCRAVRQ0BIABC7gEgASkDABATRQ0BIABCpQEgASgCCCABKQMQEEhFDQELIAEpA0AiB1BFBEAgACAHEMcBRQ0BCyABLQAkRQRAIABC+wEgCxATRQ0BCyAGRQRAIABCmwEgDBATRQ0BCwJ+QgIgCEL/AFQNABpCAyAIQv//AFQNABpCBCAIQv///wBUDQAaQgUgCEL/////AFQNABpCBiAIQv//////AFQNABpCByAIQv///////wBUDQAaQghCCSAIQv////////8AVBsLIAh8IQ0LIANBEGokACANC5QEAgR/AX4jAEEQayIDJAACQCAARQ0AIABC4YgBIAAgACgCACgCBBEAACAAKAIAKAIQEQsAQgEhBgJAA0ACQCADQuGIAUECIAana0EDdK2HPAANIAAgA0ENakEBIAAoAgAoAgARAQAiBCACIARBAEgbIQIgBEF/TA0AIAZCAXwiBkIDUg0BDAILCyACDQELIANBiAE6AA4gACADQQ5qQQEgACgCACgCABEBAEEASA0AIAMgAUI4iDwADwJAIAAgA0EPakEBIAAoAgAoAgARAQAiBEEASA0AIAMgAUIwiDwADyAAIANBD2pBASAAKAIAKAIAEQEAIgIgBCACQQBIGyEEIAJBf0wNACADIAFCKIg8AA8gACADQQ9qQQEgACgCACgCABEBACICIAQgAkEASCICGyEEIAINACADIAFCIIg8AA8gACADQQ9qQQEgACgCACgCABEBACICIAQgAkEASCICGyEEIAINACADIAFCGIg8AA8gACADQQ9qQQEgACgCACgCABEBACICIAQgAkEASCICGyEEIAINACADIAFCEIg8AA8gACADQQ9qQQEgACgCACgCABEB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BEH/////A3EgBEcbEBciAwR/An8CQAJAQTgQFyIBBEAgAUIANwMwIAFCATcDKCABQgE3AyAgAUIBNwMYIAFCADcDECABQQA2AgggAUIFNwMAIAAoAlghAiAFRQ0BA0AgAyAGQQJ0IgdqIAIgB2ooAgA2AgAgBkEBaiIGIAVHDQALDAILIAMQDkEADwsgAg0AQQAMAQsgAhAOIAAoAlwLIQIgACADNgJYIAMgAkECdGogATYCACAAIAQ2AlxBAQVBAAsLzwEBAn8jAEEQayIBJAACQCAAvUIgiKdB/////wdxIgJB+8Ok/wNNBEAgAkGAgMDyA0kNASAARAAAAAAAAAAAQQAQMiEADAELIAJBgIDA/wdPBEAgACAAoSEADAELIAAgARCEAUEDcSICQQJNBEACQAJAAkAgAkEBaw4CAQIACyABKwMAIAErAwhBARAyIQAMAwsgASsDACABKwMIEDMhAAwCCyABKwMAIAErAwhBARAymiEADAELIAErAwAgASsDCBAzmiEACyABQRBqJAAgAAu6FwEDfyMAQeABayIDJAAgAyACNgLcASAAIAAoAgBqIQRBeyECAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQeBgaiIFQS9LBEAgAUHhsX9qIgVBC00NASABQYaqf2oiAUERSw0mAkACQAJAIAFBAWsOESkpKSkpKSkpKSkpKSkpKQABAgsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFqQeUASw0oIAAgATYCjAFBACECDCgLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwoCyABIAAoAowBNgIAQQAhAgwnCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUGYeGpBA08EQEF/IQIgAUGYeEcNJwsgACABNgKIAUEAIQIMJgsgBUEBaw4vIyIhHh0SERwbGBcWFRQTGhklJRAPIB8ODSUMAQslCiUlJSUJCCUlBwYFBCUlAwIkCwJAAkACQCAFQQFrDgsnJycnJycnJwInAQALIAMgAygC3AEiAEEEajYC3AEgACgCACIARQRAQX8hAgwnCyADIAA2AnAgBEGfzgAgA0HwAGoQEiECDCYLIAMgAygC3AEiAUEEajYC3AEgACABKAIAIgA2AshuIAMgADYCYCAEQarOACADQeAAahASIQIMJQsgAyADKALcASIBQQRqNgLcASAAIAEoAgAiADYCsAEgAyAANgJQIARBqM4AIANB0ABqEBIhAgwkCyAAKAIEIQEgAEG8AWoiAkEMakEAQcDsABARGiACQs2Zs+7jzJmzPzcCwEBBACECIABBiO4AakEAQeweEBEaIARBvB9BABASGiAAIAFqIAAoArQBIANB+ABqEFcaIABBATYCxG4gAEGAgID8AzYClG4gAEGAgAE7AYxuIABB0Qg2ArhuIABB6Qc2AqhuIAAgACgCcDYCiG4gAEE8EBZBCHQ2ApBuDCMLIAMgAygC3AEiAEEEajYC3AEgACgCACIARQRAQX8hAgwjCyADIAA2AkAgBEHPHyADQUBrEBIaQQAhAgwiCyADIAMoAtwBIgBBBGo2AtwBQX8hAiAAKAIAIgBBAUsNISADIAA2AjAgBEHOHyADQTBqEBIaQQAhAgwhCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMIQsgASAAKAJMNgIAQQAhAgwgCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFBAUsNHyAAIAE2AkxBACECDB8LIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwfCyABIAAoApwBNgIAQQAhAgweCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFB+FhqQQlLDR0gACABNgKcASADIAE2AiAgBEHIHyADQSBqEBIaQQAhAgwdCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMHQsgASAAKAKoATYCAEEAIQIMHAsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQXhqQRBLDRsgACABNgKoAUEAIQIMGwsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDBsLIAEgACgC8IwBNgIAQQAhAgwaCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMGgsgASAAKAKQATYCAEEAIQIMGQsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDBkLIAEgACgCkAFBkANtIgQ2AgBBACECIAAoAmxBgxBGDRggASAAKAJ0IARqNgIADBgLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwYCyABIAAoAnw2AgBBACECDBcLIAMgAygC3AEiAUEEajYC3AEgASgCACIBQcdoakECTwRAQX8hAiABQZh4Rw0XCyAAIAE2AnxBACECDBYLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwWCyABIAAoApgBNgIAQQAhAgwVCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFBAUsNFCAAIAE2ApgBQQAhAgwUCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMFAsgASAAKAKUATYCAEEAIQIMEwsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFLDRIgACABNgKUASAAQQEgAWs2AjxBACECDBILIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwSCyABIAAoAig2AgBBACECDBELIAMgAygC3AEiAUEEajYC3AFBfyECIAEoAgAiAUHkAEsNECAAIAE2AiggAyABNgIQIARBrh8gA0EQahASGkEAIQIMEAsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDBALIAEgACgCMDYCAEEAIQIMDwsgAyADKALcASIBQQRqNgLcAUF/IQIgASgCACIBQQFLDQ4gACABNgIwQQAhAgwOCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUUEQEF/IQIMDgsgASAAKAIsNgIAQQAhAgwNCyADIAMoAtwBIgFBBGo2AtwBQX8hAiABKAIAIgFBCksNDCAAIAE2AiwgAyABNgIAIARBqh8gAxASGkEAIQIMDAsgAyADKALcASIBQQRqNgLcASABKAIAIgFFBEBBfyECDAwLIAEgACgCuAE2AgBBACECDAsLIAMgAygC3AEiAUEEajYC3AFBfyECIAEoAgAiAUEBSw0KIAAgATYCuAFBACECDAoLIAMgAygC3AEiAUEEajYC3AEgASgCACIBRQRAQX8hAgwKCyABIAAoArhuNgIAQQAhAgwJCyADIAMoAtwBIgFBBGo2AtwBIAEoAgAiAUGzd2pBBU8EQEF/IQIgAUGYeEcNCQsgACABNgKAASABQc0IRgRAIABBwD42AhRBACECDAkLIAFBzghGBEAg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IApqQQF0ai4BAEEDdSIMIAxsaiEDIAJBAWoiAiAFRw0ACyABIANqIgFB/////wcgAUH/////B0kbIQEgCEEBdCEKIAYoAgAhDEEAIQJBACEDA0AgAyAEIAIgCmogDGpBAXRqLgEAQQN1Ig4gDmxqIQMgAkEBaiICIAVHDQALIAEgA2oiAUH/////ByABQf////8HSRshASAIQQNsIQggBigCACEGQQAhAkEAIQMDQCADIAQgAiAIaiAGakEBdGouAQBBA3UiCiAKbGohAyACQQFqIgIgBUcNAAsLIAsgASADQQF2aiIBQf////8HIAFB/////wdJGzYCACANIAM2AjggCUEBaiIJQQRHDQALQQAhBSAAKAKMASIJQecHTARAQf//ASAJQQR1QQFqbSEFC0H/////ByAHKAIgIgggACgCfGoiAUH/////ByABQf////8HSRsiBG4hA0GAASEBIAACf0GAASAEIAAoAlwiAkEDdEoNABpBgAggBCACSA0AGiACQRB0QRB1IgQgA0EQdmwgAyACQQ91QQFqQQF1bGogA0H//wNxIARsQRB1aiICQRB1QQt0IAJBBXZB/w9xcgsiAiAFIAIgBUobQRB0QRB1IgIgAyAAKAJsIgNrIgRBEHVsIANqIAIgBEH//wNxbEEQdWoiAzYCbCAAQf////8HIANtIgNB////ByADQf///wdIGyIDNgJcQf////8HIAcoAiQiCiAAKAKAAWoiAkH/////ByACQf////8HSRsiBm4hAgJAIAYgACgCYCIEQQN0Sg0AQYAIIQEgBiAESA0AIARBEHRBEHUiASACQRB2bCACIARBD3VBAWpBAXVsaiACQf//A3EgAWxBEHVqIgFBEHVBC3QgAUEFdkH/D3FyIQELIAAgASAFIAEgBUobQRB0QRB1IgEgAiAAKAJwIgJrIgRBEHVsIAJqIAEgBEH//wNxbEEQdWoiATYCcCAAQf////8HIAFtIgFB////ByABQf///wdIGzYCYEH/////ByAHKAIoIgwgACgChAFqIgFB/////wcgAUH/////B0kbIgZuIQJBgAEhASAAAn9BgAEgBiAAKAJkIgRBA3RKDQAaQYAIIAYgBEgNABogBEEQdEEQdSIGIAJBEHZsIAIgBEEPdUEBakEBdWxqIAJB//8DcSAGbEEQdWoiBEEQdUELdCAE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GkEAIAFFDQAaQQAgARD6AiIBRQ0AGiADQX82AhQgAyAANgIQIANBADYCDCADIAE2AgggA0EYakEAQScQERogA0EBNgI4IAEgA0EIaiACKAIAQQEgASgCACgCHBEDAEEAIAMoAiBBAUcNABogAiADKAIYNgIAQQELIQAgA0FAayQAIAALCQBB7xUQtwEACzMBAX8jAEEQayIBJAAgAUEIaiAAKAIEELUBKAIAQQE6AAAgACgCCEEBOgAAIAFBEGokAAs0AQJ/AkAgACgCCCIALQAAIgJBAUcEfyACQQJxDQEgAEECOgAAQQEFQQALDwtBuRUQtwEACzYBAn8jAEEQayIBJAAgAUEIaiAAKAIEELUBKAIALQAAQQFHBEAgABD+AiECCyABQRBqJAAgAgt6AQF/IAAoAkxBAEgEQAJAIAAsAEtBCkYNACAAKAIUIgEgACgCEE8NACAAIAFBAWo2AhQgAUEKOgAADwsgABCuAQ8LAkACQCAALABLQQpGDQAgACgCFCIBIAAoAhBPDQAgACABQQFqNgIUIAFBCjoAAAwBCyAAEK4BCwskACAAQQtPBH8gAEEQakFwcSIAIABBf2oiACAAQQtGGwVBCgsLnAEBA38jAEEQayICJABBbyAATwRAAkAgAEEKTQRAQZveAiAAOgAAQZDeAiEBDAELQX8gABCBA0EBaiIDIgFJBEAQuQEAC0GQ3gIgARAXIgE2AgBBmN4CIANBgICAgHhyNgIAQZTeAiAANgIACyAABEAgAUH5DCAAEA0aCyACQQA6AA8gACABaiACLQAPOgAAIAJBEGokAA8LELkBAAvZAwICfwJ+IwBBIGsiAiQAAkAgAUL///////////8AgyIFQoCAgICAgMD/Q3wgBUKAgICAgIDAgLx/fFQEQCABQgSGIABCPIiEIQQgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhBAwCCyAEQoCAgICAgICAQH0hBCAAQoCAgICAgICACIVCAFINASAEQgGDIAR8IQQMAQsgAFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCABQgSGIABCPIiEQv////////8Dg0KAgICAgICA/P8AhCEEDAELQoCAgICAgID4/wAhBCAFQv///////7//wwBWDQBCACEEIAVCMIin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","base64"))
    };

    audio.broadcastencoder = new MediaRecorder(audio.broadcaststream.stream, {audioBitsPerSecond:40000, mimeType:mime}, workerOptions)
    audio.callencoder = new MediaRecorder(audio.callstream.stream, {audioBitsPerSecond:40000, mimeType:mime}, workerOptions)

    audio.broadcastencoder.addEventListener('dataavailable', e => {
      btob(e.data, (err, buf) => {
      if(app.session.broadcasting) app._log(buf.length)
        //bufr.push(new Uint8Array(buf))
    //    app.audio.decoder.decode(buf)     
        app.network.broadcast(buf)
        //strSrc.write(buf)
      })

    })

    audio.callencoder.addEventListener('dataavailable', e => {
      btob(e.data, (err, buf) => {
        //bufr.push(new Uint8Array(buf))
        app.audio.decoder.decode(buf)     
        //app.network.send(buf)
        //strSrc.write(buf)
      })
    })

    
    audio.broadcastencoder.start(1000)

    autorun(()=>{
      if(app.update) {
        audio[app.update[0]].gain.value = Math.max(0, app.update[1])//.monitor
      } 
    })

    app._log(`mediaRecorder added? ${(!!audio.broadcastencoder)}`)

    app.audio = audio
    master.resume()
    cb(null, app)
  }

  function initUI(app, cb){

    ui.livelink.innerText = 'https://gabr.vercel.app?stream='+app.session.stream
    ui.copybutton.onchange = e => {
      navigator.clipboard.writeText(ui.link.innerText)
    }
    ui.request.addEventListener('change', e => {
      app.network.initCall(app.session.stream)
    })
    ui.file.addEventListener('change', e => {
      console.log(e.target.files[0])
      var a = h('audio.invert', {controls: true, src : URL.createObjectURL(e.target.files[0])})
      ui.tracks.appendChild(a)
      var c= app.audio.master.createMediaElementSource(a)
      console.log(a)
      c.connect(app.audio.trackmixer)
      btob(e.target.files[0], (err, buf) => {
        sampler(app.audio.master, buf.buffer, (err, node) =>{
          //node.connect(app.audio.master.destination)
          //node.start(0)
        })      
      })
    })

    ;[].forEach.call(document.querySelectorAll('input[type=range]'), e => {
      e.addEventListener('input', ev => {
        bus.emit('appStateChange', [ev.target.name, Number(ev.target.value)])
      })
    })

    ;[].forEach.call(document.querySelectorAll('[data-mute]'), e => {
      e.addEventListener('change', ev => {
        bus.emit('appStateChange', [ev.target.dataset.mute, - app[ev.target.dataset.mute]])
      })
    })


    ui.monitorRange.addEventListener('change', e => {
      console.log(e.target.value)
      //bus.emit('appStateChange', ['monitor', Number(e.target.value)])
      //app.setGain('monitor', Number(e.target.value))
    })

    cb(null,app)

  }


  function initCast(app){
  
    return function(cb){
      app._log('stateInit')
      cb(null, app)
    
    }
  }
  function captureNetwork(app, cb) {
    var network = new Network(app, argv.protocol + '://' + argv.host + ':' + argv.port)
    app._log('netCap')
    app.network = network

    cb(null, app)
  }

  function captureSource (app, cb) {
    // TODO source is either the mediastream or a peer connection
    
    if(true || app.session.broadcasting){
      addMedia((err, stream) =>{
        app._log(`mediaStream added? ${(!!stream)}`)
        app._log(`mediaStream error? ${(err)}`)

        console.log(err)
        console.log(stream)

        const mic = app.audio.master.createMediaStreamSource(stream) 
        mic.connect(app.audio.mic)

        app.audio.mediastream = stream
        app.audio.micnode = mic
    
        /*
        var bufr = []
        app.audio.buffer = bufr
        const strSrc = thru((b, r, cb)=>{
            console.log('source', b)
          cb(null, b)
        },e=>{
          console.log(e)
        } )
        app.audio.sourceStream = strSrc
        */
        // do same for host monitoring:
        //for(var smith in phonebook) mediaStream.pipe(phonebook[smith]) 
        //ui.monitor.srcObject = stream// = URL.createObjectURL(stream)      
        // Delete the encoder when finished with it (Emscripten does not automatically call C++ object destructors)
        //encoder.delete();
       app._log('sourceCap')
        cb(err, app)
        
      
      })
    }




  }

  function captureSink(app, cb){
    var {OggOpusDecoder} = require('ogg-opus-decoder')

    async function wsm(log){
    
      const decoder = new OggOpusDecoder({onDecode, onDecodeAll})

      function onDecode () {
      }

      function onDecodeAll ({channelData, samplesDecoded, sampleRate}) {
        //console.log(channelData)
        let sam = sampler(app.audio.master, channelData)
        sam.connect(app.audio.master.destination)
        sam.start(0)
      }

      await decoder.ready

      /*
      const sinkStream = thru((buf, enc, cb) => {
        console.log('sink', buf)
        decoder.decode(buf)
        cb()
      }, e =>{
        console.log(e)
      
      })

      var sinkState = {
        sink: sinkStream,
      }
      */
      log(decoder)
      //app.audio.sinkStream = sinkStream
      
    }

    bus.on("sourcePeerCaptured", id => {
        wsm(function(decoder){
          console.log('WASM')
          app._log('sinkCap')
          app.audio.decoder = decoder
          let peer = app.network.connections[id]
          peer.on('data', buf => {
            app._log(buf.length)
            try{
              decoder.ready.then(() => decoder.decode(buf), err => {
                app._log(err.toString())
                decoder.ready.then(()=>decoder.free())
              })
            } catch(err){
                app._log(err.toString())
              
            }
          })
        })
      })


      cb(null, app)
    

  }



  function tob(buf, type="application/wasm"){
    return URL.createObjectURL(new Blob([new Buffer(buf).buffer], {type}))
  }
   
  var peers = {}

  //ui.addMic.onclick = e => addMedia()

  function mute(torf){
    micStream.getAudioTracks()[0].enabled = torf
  }


  var connecting = {}
  function initBroadcast(){
    // source cap then broadcast
    session.broadcastId = short().generate()
    sessios.distance = 0
    session.maxConnections = 20
    session.offersOut = 0
    // be seekable when..
    seekable(session)
    return session
  }



  class Network { 

    constructor(app, addr){
      const self = this
      //console.log(state, addr)
      this.app = app
      this.hub = signalhub(addr, app.session.stream)
      this.channel = app.session.stream
      this.id = app.session.id
      this.state = app.state
      this.connections = {}
      this.hubs = {} 
      this.peers = {}
      this.callers = {}
      this.connecting = {}
      this.distance = 1
      this.offersOut = 0
      this.maxConnections = 4 // start low, test high, also helps spread early pcast testing
      this.duration = null // since-when
      this.channels = {}
      this.duration = new Time
      this.sinkStream = thru(buf => {
        for(var n in this.peers){
          let p = this.peers[n]
          if(p.writable) p.write(buf)
        }
      }, function close(){})
    }

    broadcast(buf){
      for(var n in this.peers) this.peers[n].write(buf)
    }

    send(buf){
      for(var n in this.callers) this.callers[n].write(buf)
    }

    log(){
      console.log.apply(this, arguments)
    }

    closePeerSignal(addr){
      this.hub.unsubscribe(addr)
      //delete this.connections[addr]
    }

    disallowCalls(id){
      this.hub.unsubscribe('caller:'+id)
    }

    allowCalls(id){
      let calls = this.hub.subscribe('caller:'+id)
      calls.on('data', msg=>{
        msg=JSON.parse(msg)
        bus.emit('caller', msg)
      })
      bus.on('call', msg =>{
        this.callDirect(msg.peerId)
      })

    }

    initCall(id){
      
      this.hub.broadcast('caller:'+id, {peerId: this.id})
      let peer = this.initConnect(id, false, this.id)
      peer.once('connected', e =>{
        this.callers[id] = peer
        bus.emit('Call Source Captured', peer)

      })
      
      
    }

    callDirect(id){
      let peer = this.initConnect(id, true, this.id)
      peer.once('connected', e =>{
        this.callers[id] = peer
        bus.emit('Call Source Captured', peer)

      })
    }

    sourceSeek(){ // id for a peer stream
      var self = this 
      let mask = short().generate()
      let offerings = this.hub.subscribe(mask)
      var best = 0//Infinity
      var chosen
      var start = new Time
      offerings.on('data', offer => {
        offer = JSON.parse(offer)
        self.app._log(offer)
        let score = (1 / offer.distance) * offer.duration
        if(score > best) {
          best = score //offer.distance
          chosen = offer
        }
      console.log(chosen)
      })
      let t0 = setTimeout(e => {
      console.log(chosen)
        if(chosen) {
    //      this.hub.unsubscribe(mask)
          // do chosen
          bus.emit('sourcePeerIdCaptured', chosen.peerId)
          //self.sourceCap(chosen)
          let peer = this.initConnect(chosen.peerId, true, mask)
          peer.once('connect', e => {
            bus.emit('sourcePeerCaptured', chosen.peerId)
            this.distance = chosen.distance + 1
            this.sourceStream = peer
            self.app._log('Source Peer Captured.')

          })
          peer.on('close', e => {
            self.app._log('Source Peer Closed')

          })
        } else {
          self.app._log('Err: No source peer found.')    
        }
      }, 13000)
      

      this.hub.broadcast('source', 
        JSON.stringify({
          peerId: mask
        })
      )
      
    }

    set sourceStream(stream){
      this._sourceStream = stream
      this.duration = new Time()
      //stream.pipe(this.sinkStream)
      //stream.pipe(app.audio.sinkStream)
    }

    get sourceStream(){
      return this._sourceStream
    }

    unseekable(session){
      if(sesion) this.hub.unsubscribe(session)
    }

    isSeekWorthy(){
      let r = this.offersOut < this.maxConnections
      let s = this.maxConnections > Object.keys(this.connections).length  
      let q = r && s 
      this._seekable = q
      if(q) {
        this.sourcer = this.hub.subscribe('source')
        this.sourcer.on('data', msg => this.seekable(JSON.parse(msg)))
      }
      else {
        if(this.sourcer) this.sourcer.close()
        
      }
      return this._seekable
    }

    setsub(id){
      if(this.hubs[id]) return this.hubs[id]
      else this.hubs[id] = this.hub.subscribe(id)
    }
    getsub(id){
      return this.hubs[id]
    }

    unsub(id){
      if(this.hubs[id]) {
        this.hub.unsubscribe(id) 
        delete this.hubs[id] 
      }
    }

    seekable(msg){ 
    this.app._log(msg)
      let self = this
      if(false) return // || Math.random() < 1 / Math.pow(self.distance, 2)) return
      else{
        self.offersOut += 1
        setTimeout(e=>{
          this.offersOut--
          //this.disnit(msg.peerId, mask)
        }, 1111*3)
        let mask = short().generate()
        let peer = this.initConnect(msg.peerId, false, mask)
        peer.once('connect', e =>{
          self.peers[msg.peerId] = peer
        })
        peer.once('close', e =>{
          delete self.peers[msg.peerId]
          self.isSeekWorthy()
        })
        this.hub.broadcast(msg.peerId, JSON.stringify({
          peerId: mask,
          to: msg.peerId,
          distance: this.distance,
          duration: this.duration.sinceBeginNS()
        }))
      }
    }

    disnit(id, mask){
      //delete this.connecting[id]
      //this.hub.unsubscribe(mask)
    }

    initConnect(id, init, mask){
      var self = this
      let pipe = this.hub.subscribe(mask)
      var caller = new Peer({initiator: init, trickle: false, objectMode: false})
      this.connecting[id] = caller
      pipe.on('error', e => console.log.apply(this, arguments))
      pipe.on('data', function(data){
        data = JSON.parse(data)
        // callerID
        var peer = self.connecting[data.peerId]
        peer.signal(data.signal)
        peer.once('connect', e => {
          // close mask hub
        })
        //ui.callers.appendChild(h('div.caller', h('button.connect', `Connect to ${data.name || from}`, {onclick: _connect})))  
      })
      caller._debug = console.log
      caller.on('signal', sig => this.hub.broadcast(id, JSON.stringify({peerId: mask, to: id, signal: sig })))
      caller.once('connect', e => {
        this.connections[id] = caller
        this.connecting[id] = null
        console.log(`connected to ${Object.keys(this.connections).length} peers`)
      })
      caller.on('close', e => {
        this.disnit(id, mask)
      })
      caller.on('error', e => console.log(e))
      return caller
    }

  }

  function addMedia(cb, audio=true, video=false){
    var gam = require('getusermedia')
    // Web worker and .wasm configuration. Note: This is NOT a part of W3C standard.
    gam({video, audio}, function(err, stream){
      //console.log(stream.getAudioTracks())


      cb(err, stream)
    })
   }    
})


}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

},{"../jsynth-file-sample":1,"../jsynth-mic/stream":2,"../since-when":113,"./sharedEmitter":112,"_process":136,"blob-to-buffer":6,"buffer":117,"domready":13,"getids":17,"getusermedia":18,"hyperscript":19,"minimist":22,"mobx":23,"nanohref":28,"ogg-opus-decoder":29,"opus-media-recorder":30,"querystring":139,"run-waterfall":49,"short-uuid":52,"signalhub":53,"simple-peer":63,"store":64,"through2":84,"to-arraybuffer":85}],4:[function(require,module,exports){
var Converter = require('./src/converter');

/**
 * Function get source and destination alphabet and return convert function
 *
 * @param {string|Array} srcAlphabet
 * @param {string|Array} dstAlphabet
 *
 * @returns {function(number|Array)}
 */
function anyBase(srcAlphabet, dstAlphabet) {
    var converter = new Converter(srcAlphabet, dstAlphabet);
    /**
     * Convert function
     *
     * @param {string|Array} number
     *
     * @return {string|Array} number
     */
    return function (number) {
        return converter.convert(number);
    }
};

anyBase.BIN = '01';
anyBase.OCT = '01234567';
anyBase.DEC = '0123456789';
anyBase.HEX = '0123456789abcdef';

module.exports = anyBase;
},{"./src/converter":5}],5:[function(require,module,exports){
'use strict';

/**
 * Converter
 *
 * @param {string|Array} srcAlphabet
 * @param {string|Array} dstAlphabet
 * @constructor
 */
function Converter(srcAlphabet, dstAlphabet) {
    if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
        throw new Error('Bad alphabet');
    }
    this.srcAlphabet = srcAlphabet;
    this.dstAlphabet = dstAlphabet;
}

/**
 * Convert number from source alphabet to destination alphabet
 *
 * @param {string|Array} number - number represented as a string or array of points
 *
 * @returns {string|Array}
 */
Converter.prototype.convert = function(number) {
    var i, divide, newlen,
    numberMap = {},
    fromBase = this.srcAlphabet.length,
    toBase = this.dstAlphabet.length,
    length = number.length,
    result = typeof number === 'string' ? '' : [];

    if (!this.isValid(number)) {
        throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ')');
    }

    if (this.srcAlphabet === this.dstAlphabet) {
        return number;
    }

    for (i = 0; i < length; i++) {
        numberMap[i] = this.srcAlphabet.indexOf(number[i]);
    }
    do {
        divide = 0;
        newlen = 0;
        for (i = 0; i < length; i++) {
            divide = divide * fromBase + numberMap[i];
            if (divide >= toBase) {
                numberMap[newlen++] = parseInt(divide / toBase, 10);
                divide = divide % toBase;
            } else if (newlen > 0) {
                numberMap[newlen++] = 0;
            }
        }
        length = newlen;
        result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
    } while (newlen !== 0);

    return result;
};

/**
 * Valid number with source alphabet
 *
 * @param {number} number
 *
 * @returns {boolean}
 */
Converter.prototype.isValid = function(number) {
    var i = 0;
    for (; i < number.length; ++i) {
        if (this.srcAlphabet.indexOf(number[i]) === -1) {
            return false;
        }
    }
    return true;
};

module.exports = Converter;
},{}],6:[function(require,module,exports){
(function (Buffer){(function (){
/*! blob-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* global Blob, FileReader */

module.exports = function blobToBuffer (blob, cb) {
  if (typeof Blob === 'undefined' || !(blob instanceof Blob)) {
    throw new Error('first argument must be a Blob')
  }
  if (typeof cb !== 'function') {
    throw new Error('second argument must be a function')
  }

  const reader = new FileReader()

  function onLoadEnd (e) {
    reader.removeEventListener('loadend', onLoadEnd, false)
    if (e.error) cb(e.error)
    else cb(null, Buffer.from(reader.result))
  }

  reader.addEventListener('loadend', onLoadEnd, false)
  reader.readAsArrayBuffer(blob)
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":117}],7:[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],8:[function(require,module,exports){
// contains, add, remove, toggle
var indexof = require('indexof')

module.exports = ClassList

function ClassList(elem) {
    var cl = elem.classList

    if (cl) {
        return cl
    }

    var classList = {
        add: add
        , remove: remove
        , contains: contains
        , toggle: toggle
        , toString: $toString
        , length: 0
        , item: item
    }

    return classList

    function add(token) {
        var list = getTokens()
        if (indexof(list, token) > -1) {
            return
        }
        list.push(token)
        setTokens(list)
    }

    function remove(token) {
        var list = getTokens()
            , index = indexof(list, token)

        if (index === -1) {
            return
        }

        list.splice(index, 1)
        setTokens(list)
    }

    function contains(token) {
        return indexof(getTokens(), token) > -1
    }

    function toggle(token) {
        if (contains(token)) {
            remove(token)
            return false
        } else {
            add(token)
            return true
        }
    }

    function $toString() {
        return elem.className
    }

    function item(index) {
        var tokens = getTokens()
        return tokens[index] || null
    }

    function getTokens() {
        var className = elem.className

        return filter(className.split(" "), isTruthy)
    }

    function setTokens(list) {
        var length = list.length

        elem.className = list.join(" ")
        classList.length = length

        for (var i = 0; i < list.length; i++) {
            classList[i] = list[i]
        }

        delete list[length]
    }
}

function filter (arr, fn) {
    var ret = []
    for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i])) ret.push(arr[i])
    }
    return ret
}

function isTruthy(value) {
    return !!value
}

},{"indexof":20}],9:[function(require,module,exports){
(function (Buffer){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this)}).call(this,{"isBuffer":require("../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js")})

},{"../../../../../../../usr/local/lib/node_modules/browserify/node_modules/is-buffer/index.js":133}],10:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))

},{"./common":11,"_process":136}],11:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":26}],12:[function(require,module,exports){
(function (process){(function (){
"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var BrowserInfo = /** @class */ (function () {
    function BrowserInfo(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
    }
    return BrowserInfo;
}());
exports.BrowserInfo = BrowserInfo;
var NodeInfo = /** @class */ (function () {
    function NodeInfo(version) {
        this.version = version;
        this.name = 'node';
        this.os = process.platform;
    }
    return NodeInfo;
}());
exports.NodeInfo = NodeInfo;
var BotInfo = /** @class */ (function () {
    function BotInfo() {
        this.bot = true; // NOTE: deprecated test name instead
        this.name = 'bot';
        this.version = null;
        this.os = null;
    }
    return BotInfo;
}());
exports.BotInfo = BotInfo;
// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk)|(Googlebot)|(Yammybot)|(Openbot)|(Slurp)|(MSNBot)|(Ask Jeeves\/Teoma)|(ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
    ['aol', /AOLShield\/([0-9\._]+)/],
    ['edge', /Edge\/([0-9\._]+)/],
    ['edge-ios', /EdgiOS\/([0-9\._]+)/],
    ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
    ['vivaldi', /Vivaldi\/([0-9\.]+)/],
    ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
    ['samsung', /SamsungBrowser\/([0-9\.]+)/],
    ['silk', /\bSilk\/([0-9._-]+)\b/],
    ['miui', /MiuiBrowser\/([0-9\.]+)$/],
    ['beaker', /BeakerBrowser\/([0-9\.]+)/],
    ['edge-chromium', /Edg\/([0-9\.]+)/],
    [
        'chromium-webview',
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
    ['fxios', /FxiOS\/([0-9\.]+)/],
    ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
    ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
    ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ['android', /Android\s([0-9\.]+)/],
    ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9\._]+).*Safari/],
    ['facebook', /FBAV\/([0-9\.]+)/],
    ['instagram', /Instagram\s([0-9\.]+)/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ['searchbot', SEARCHBOX_UA_REGEX],
];
var operatingSystemRules = [
    ['iOS', /iP(hone|od|ad)/],
    ['Android OS', /Android/],
    ['BlackBerry OS', /BlackBerry|BB10/],
    ['Windows Mobile', /IEMobile/],
    ['Amazon OS', /Kindle/],
    ['Windows 3.11', /Win16/],
    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
    ['Windows 98', /(Windows 98)|(Win98)/],
    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
    ['Windows Server 2003', /(Windows NT 5.2)/],
    ['Windows Vista', /(Windows NT 6.0)/],
    ['Windows 7', /(Windows NT 6.1)/],
    ['Windows 8', /(Windows NT 6.2)/],
    ['Windows 8.1', /(Windows NT 6.3)/],
    ['Windows 10', /(Windows NT 10.0)/],
    ['Windows ME', /Windows ME/],
    ['Open BSD', /OpenBSD/],
    ['Sun OS', /SunOS/],
    ['Chrome OS', /CrOS/],
    ['Linux', /(Linux)|(X11)/],
    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
    ['QNX', /QNX/],
    ['BeOS', /BeOS/],
    ['OS/2', /OS\/2/],
    ['Search Bot', SEARCHBOT_OS_REGEX],
];
function detect(userAgent) {
    if (!!userAgent) {
        return parseUserAgent(userAgent);
    }
    if (typeof navigator !== 'undefined') {
        return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
}
exports.detect = detect;
function parseUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    var matchedRule = ua !== '' &&
        userAgentRules.reduce(function (matched, _a) {
            var browser = _a[0], regex = _a[1];
            if (matched) {
                return matched;
            }
            var uaMatch = regex.exec(ua);
            return !!uaMatch && [browser, uaMatch];
        }, false);
    if (!matchedRule) {
        return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === 'searchbot') {
        return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
    if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
            versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
        }
    }
    else {
        versionParts = [];
    }
    return new BrowserInfo(name, versionParts.join('.'), detectOS(ua));
}
exports.parseUserAgent = parseUserAgent;
function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.test(ua);
        if (match) {
            return os;
        }
    }
    return null;
}
exports.detectOS = detectOS;
function getNodeVersion() {
    var isNode = typeof process !== 'undefined' && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
exports.getNodeVersion = getNodeVersion;
function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
        output.push('0');
    }
    return output;
}

}).call(this)}).call(this,require('_process'))

},{"_process":136}],13:[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? setTimeout(fn, 0) : fns.push(fn)
  }

});

},{}],14:[function(require,module,exports){
'use strict';

/**
 * @typedef {{ [key: string]: any }} Extensions
 * @typedef {Error} Err
 * @property {string} message
 */

/**
 *
 * @param {Error} obj
 * @param {Extensions} props
 * @returns {Error & Extensions}
 */
function assign(obj, props) {
    for (const key in props) {
        Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true,
        });
    }

    return obj;
}

/**
 *
 * @param {any} err - An Error
 * @param {string|Extensions} code - A string code or props to set on the error
 * @param {Extensions} [props] - Props to set on the error
 * @returns {Error & Extensions}
 */
function createError(err, code, props) {
    if (!err || typeof err === 'string') {
        throw new TypeError('Please pass an Error to err-code');
    }

    if (!props) {
        props = {};
    }

    if (typeof code === 'object') {
        props = code;
        code = '';
    }

    if (code) {
        props.code = code;
    }

    try {
        return assign(err, props);
    } catch (_) {
        props.message = err.message;
        props.stack = err.stack;

        const ErrClass = function () {};

        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));

        // @ts-ignore
        const output = assign(new ErrClass(), props);

        return output;
    }
}

module.exports = createError;

},{}],15:[function(require,module,exports){
/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * @typedef {object} PrivateData
 * @property {EventTarget} eventTarget The event target.
 * @property {{type:string}} event The original event object.
 * @property {number} eventPhase The current event phase.
 * @property {EventTarget|null} currentTarget The current event target.
 * @property {boolean} canceled The flag to prevent default.
 * @property {boolean} stopped The flag to stop propagation immediately.
 * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.
 * @property {number} timeStamp The unix time.
 * @private
 */

/**
 * Private data for event wrappers.
 * @type {WeakMap<Event, PrivateData>}
 * @private
 */
const privateData = new WeakMap();

/**
 * Cache for wrapper classes.
 * @type {WeakMap<Object, Function>}
 * @private
 */
const wrappers = new WeakMap();

/**
 * Get private data.
 * @param {Event} event The event object to get private data.
 * @returns {PrivateData} The private data of the event.
 * @private
 */
function pd(event) {
    const retv = privateData.get(event);
    console.assert(retv != null, "'this' is expected an Event object, but got", event);
    return retv
}

/**
 * @see https://dom.spec.whatwg.org/#interface-event
 * @private
 */
/**
 * The event wrapper.
 * @constructor
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Event|{type:string}} event The original event to wrap.
 */
function Event(eventTarget, event) {
    privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now(),
    });

    // https://heycam.github.io/webidl/#Unforgeable
    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });

    // Define accessors
    const keys = Object.keys(event);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
            Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
    }
}

// Should be enumerable, but class methods are not enumerable.
Event.prototype = {
    /**
     * The type of this event.
     * @type {string}
     */
    get type() {
        return pd(this).event.type
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get target() {
        return pd(this).eventTarget
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get currentTarget() {
        return pd(this).currentTarget
    },

    /**
     * @returns {EventTarget[]} The composed path of this event.
     */
    composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
            return []
        }
        return [currentTarget]
    },

    /**
     * Constant of NONE.
     * @type {number}
     */
    get NONE() {
        return 0
    },

    /**
     * Constant of CAPTURING_PHASE.
     * @type {number}
     */
    get CAPTURING_PHASE() {
        return 1
    },

    /**
     * Constant of AT_TARGET.
     * @type {number}
     */
    get AT_TARGET() {
        return 2
    },

    /**
     * Constant of BUBBLING_PHASE.
     * @type {number}
     */
    get BUBBLING_PHASE() {
        return 3
    },

    /**
     * The target of this event.
     * @type {number}
     */
    get eventPhase() {
        return pd(this).eventPhase
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopPropagation() {
        const data = pd(this);
        if (typeof data.event.stopPropagation === "function") {
            data.event.stopPropagation();
        }
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopImmediatePropagation() {
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
            data.event.stopImmediatePropagation();
        }
    },

    /**
     * The flag to be bubbling.
     * @type {boolean}
     */
    get bubbles() {
        return Boolean(pd(this).event.bubbles)
    },

    /**
     * The flag to be cancelable.
     * @type {boolean}
     */
    get cancelable() {
        return Boolean(pd(this).event.cancelable)
    },

    /**
     * Cancel this event.
     * @returns {void}
     */
    preventDefault() {
        const data = pd(this);
        if (data.passiveListener != null) {
            console.warn("Event#preventDefault() was called from a passive listener:", data.passiveListener);
            return
        }
        if (!data.event.cancelable) {
            return
        }

        data.canceled = true;
        if (typeof data.event.preventDefault === "function") {
            data.event.preventDefault();
        }
    },

    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     */
    get defaultPrevented() {
        return pd(this).canceled
    },

    /**
     * The flag to be composed.
     * @type {boolean}
     */
    get composed() {
        return Boolean(pd(this).event.composed)
    },

    /**
     * The unix time of this event.
     * @type {number}
     */
    get timeStamp() {
        return pd(this).timeStamp
    },
};

// `constructor` is not enumerable.
Object.defineProperty(Event.prototype, "constructor", { value: Event, configurable: true, writable: true });

// Ensure `event instanceof window.Event` is `true`.
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);

    // Make association for wrappers.
    wrappers.set(window.Event.prototype, Event);
}

/**
 * Get the property descriptor to redirect a given property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to redirect the property.
 * @private
 */
function defineRedirectDescriptor(key) {
    return {
        get() {
            return pd(this).event[key]
        },
        set(value) {
            pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Get the property descriptor to call a given method property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to call the method property.
 * @private
 */
function defineCallDescriptor(key) {
    return {
        value() {
            const event = pd(this).event;
            return event[key].apply(event, arguments)
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define new wrapper class.
 * @param {Function} BaseEvent The base wrapper class.
 * @param {Object} proto The prototype of the original event.
 * @returns {Function} The defined wrapper class.
 * @private
 */
function defineWrapper(BaseEvent, proto) {
    const keys = Object.keys(proto);
    if (keys.length === 0) {
        return BaseEvent
    }

    /** CustomEvent */
    function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
    }

    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true },
    });

    // Define accessors.
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(proto, key);
            const isFunc = (typeof descriptor.value === "function");
            Object.defineProperty(
                CustomEvent.prototype,
                key,
                isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
            );
        }
    }

    return CustomEvent
}

/**
 * Get the wrapper class of a given prototype.
 * @param {Object} proto The prototype of the original event to get its wrapper.
 * @returns {Function} The wrapper class.
 * @private
 */
function getWrapper(proto) {
    if (proto == null || proto === Object.prototype) {
        return Event
    }

    let wrapper = wrappers.get(proto);
    if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
    }
    return wrapper
}

/**
 * Wrap a given event to management a dispatching.
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Object} event The event to wrap.
 * @returns {Event} The wrapper instance.
 * @private
 */
function wrapEvent(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event)
}

/**
 * Get the stopped flag of a given event.
 * @param {Event} event The event to get.
 * @returns {boolean} The flag to stop propagation immediately.
 * @private
 */
function isStopped(event) {
    return pd(event).stopped
}

/**
 * Set the current event phase of a given event.
 * @param {Event} event The event to set current target.
 * @param {number} eventPhase New event phase.
 * @returns {void}
 * @private
 */
function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
}

/**
 * Set the current target of a given event.
 * @param {Event} event The event to set current target.
 * @param {EventTarget|null} currentTarget New current target.
 * @returns {void}
 * @private
 */
function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
}

/**
 * Set a passive listener of a given event.
 * @param {Event} event The event to set current target.
 * @param {Function|null} passiveListener New passive listener.
 * @returns {void}
 * @private
 */
function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
}

/**
 * @typedef {object} ListenerNode
 * @property {Function} listener
 * @property {1|2|3} listenerType
 * @property {boolean} passive
 * @property {boolean} once
 * @property {ListenerNode|null} next
 * @private
 */

/**
 * @type {WeakMap<object, Map<string, ListenerNode>>}
 * @private
 */
const listenersMap = new WeakMap();

// Listener types
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;

/**
 * Check whether a given value is an object or not.
 * @param {any} x The value to check.
 * @returns {boolean} `true` if the value is an object.
 */
function isObject(x) {
    return x !== null && typeof x === "object" //eslint-disable-line no-restricted-syntax
}

/**
 * Get listeners.
 * @param {EventTarget} eventTarget The event target to get.
 * @returns {Map<string, ListenerNode>} The listeners.
 * @private
 */
function getListeners(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
        throw new TypeError("'this' is expected an EventTarget object, but got another value.")
    }
    return listeners
}

/**
 * Get the property descriptor for the event attribute of a given event.
 * @param {string} eventName The event name to get property descriptor.
 * @returns {PropertyDescriptor} The property descriptor.
 * @private
 */
function defineEventAttributeDescriptor(eventName) {
    return {
        get() {
            const listeners = getListeners(this);
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    return node.listener
                }
                node = node.next;
            }
            return null
        },

        set(listener) {
            if (typeof listener !== "function" && !isObject(listener)) {
                listener = null; // eslint-disable-line no-param-reassign
            }
            const listeners = getListeners(this);

            // Traverse to the tail while removing old value.
            let prev = null;
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    // Remove old value.
                    if (prev !== null) {
                        prev.next = node.next;
                    }
                    else if (node.next !== null) {
                        listeners.set(eventName, node.next);
                    }
                    else {
                        listeners.delete(eventName);
                    }
                }
                else {
                    prev = node;
                }

                node = node.next;
            }

            // Add new value.
            if (listener !== null) {
                const newNode = {
                    listener,
                    listenerType: ATTRIBUTE,
                    passive: false,
                    once: false,
                    next: null,
                };
                if (prev === null) {
                    listeners.set(eventName, newNode);
                }
                else {
                    prev.next = newNode;
                }
            }
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define an event attribute (e.g. `eventTarget.onclick`).
 * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.
 * @param {string} eventName The event name to define.
 * @returns {void}
 */
function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
}

/**
 * Define a custom EventTarget with event attributes.
 * @param {string[]} eventNames Event names for event attributes.
 * @returns {EventTarget} The custom EventTarget.
 * @private
 */
function defineCustomEventTarget(eventNames) {
    /** CustomEventTarget */
    function CustomEventTarget() {
        EventTarget.call(this);
    }

    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: { value: CustomEventTarget, configurable: true, writable: true },
    });

    for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    }

    return CustomEventTarget
}

/**
 * EventTarget.
 *
 * - This is constructor if no arguments.
 * - This is a function which returns a CustomEventTarget constructor if there are arguments.
 *
 * For example:
 *
 *     class A extends EventTarget {}
 *     class B extends EventTarget("message") {}
 *     class C extends EventTarget("message", "error") {}
 *     class D extends EventTarget(["message", "error"]) {}
 */
function EventTarget() {
    /*eslint-disable consistent-return */
    if (this instanceof EventTarget) {
        listenersMap.set(this, new Map());
        return
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0])
    }
    if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
            types[i] = arguments[i];
        }
        return defineCustomEventTarget(types)
    }
    throw new TypeError("Cannot call a class as a function")
    /*eslint-enable consistent-return */
}

// Should be enumerable, but class methods are not enumerable.
EventTarget.prototype = {
    /**
     * Add a given listener to this event target.
     * @param {string} eventName The event name to add.
     * @param {Function} listener The listener to add.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {boolean} `true` if the listener was added actually.
     */
    addEventListener(eventName, listener, options) {
        if (listener == null) {
            return false
        }
        if (typeof listener !== "function" && !isObject(listener)) {
            throw new TypeError("'listener' should be a function or an object.")
        }

        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
        const listenerType = (capture ? CAPTURE : BUBBLE);
        const newNode = {
            listener,
            listenerType,
            passive: optionsIsObj && Boolean(options.passive),
            once: optionsIsObj && Boolean(options.once),
            next: null,
        };

        // Set it as the first node if the first node is null.
        let node = listeners.get(eventName);
        if (node === undefined) {
            listeners.set(eventName, newNode);
            return true
        }

        // Traverse to the tail while checking duplication..
        let prev = null;
        while (node != null) {
            if (node.listener === listener && node.listenerType === listenerType) {
                // Should ignore duplication.
                return false
            }
            prev = node;
            node = node.next;
        }

        // Add it.
        prev.next = newNode;
        return true
    },

    /**
     * Remove a given listener from this event target.
     * @param {string} eventName The event name to remove.
     * @param {Function} listener The listener to remove.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {boolean} `true` if the listener was removed actually.
     */
    removeEventListener(eventName, listener, options) {
        if (listener == null) {
            return false
        }

        const listeners = getListeners(this);
        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
        const listenerType = (capture ? CAPTURE : BUBBLE);

        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
            if (node.listener === listener && node.listenerType === listenerType) {
                if (prev !== null) {
                    prev.next = node.next;
                }
                else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                }
                else {
                    listeners.delete(eventName);
                }
                return true
            }

            prev = node;
            node = node.next;
        }

        return false
    },

    /**
     * Dispatch a given event.
     * @param {Event|{type:string}} event The event to dispatch.
     * @returns {boolean} `false` if canceled.
     */
    dispatchEvent(event) { //eslint-disable-line complexity
        if (event == null || typeof event.type !== "string") {
            throw new TypeError("\"event.type\" should be a string.")
        }

        // If listeners aren't registered, terminate.
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
            return true
        }

        // Since we cannot rewrite several properties, so wrap object.
        const wrappedEvent = wrapEvent(this, event);

        // This doesn't process capturing phase and bubbling phase.
        // This isn't participating in a tree.
        let prev = null;
        while (node != null) {
            // Remove this listener if it's once
            if (node.once) {
                if (prev !== null) {
                    prev.next = node.next;
                }
                else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                }
                else {
                    listeners.delete(eventName);
                }
            }
            else {
                prev = node;
            }

            // Call this listener
            setPassiveListener(wrappedEvent, (node.passive ? node.listener : null));
            if (typeof node.listener === "function") {
                try {
                    node.listener.call(this, wrappedEvent);
                }
                catch (err) {
                    /*eslint-disable no-console */
                    if (typeof console !== "undefined" && typeof console.error === "function") {
                        console.error(err);
                    }
                    /*eslint-enable no-console */
                }
            }
            else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
                node.listener.handleEvent(wrappedEvent);
            }

            // Break if `event.stopImmediatePropagation` was called.
            if (isStopped(wrappedEvent)) {
                break
            }

            node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);

        return !wrappedEvent.defaultPrevented
    },
};

// `constructor` is not enumerable.
Object.defineProperty(EventTarget.prototype, "constructor", { value: EventTarget, configurable: true, writable: true });

// Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}

exports.defineEventAttribute = defineEventAttribute;
exports.EventTarget = EventTarget;
exports.default = EventTarget;

module.exports = EventTarget
module.exports.EventTarget = module.exports["default"] = EventTarget
module.exports.defineEventAttribute = defineEventAttribute


},{}],16:[function(require,module,exports){
// originally pulled out of simple-peer

module.exports = function getBrowserRTC () {
  if (typeof globalThis === 'undefined') return null
  var wrtc = {
    RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection ||
      globalThis.webkitRTCPeerConnection,
    RTCSessionDescription: globalThis.RTCSessionDescription ||
      globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
    RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate ||
      globalThis.webkitRTCIceCandidate
  }
  if (!wrtc.RTCPeerConnection) return null
  return wrtc
}

},{}],17:[function(require,module,exports){
module.exports = function(el){

    var ids = {};

    if('string' == typeof el) el = document.getElementById(el);

    if(!el) el = document;

    var children = el.getElementsByTagName('*');

    Array.prototype.forEach.call(children, function(e){

	if(e.id.length > 0){

	    ids[e.id] = e

	}

    })

    return ids

}

},{}],18:[function(require,module,exports){
// getUserMedia helper by @HenrikJoreteg used for navigator.getUserMedia shim
var adapter = require('webrtc-adapter');

module.exports = function (constraints, cb) {
    var error;
    var haveOpts = arguments.length === 2;
    var defaultOpts = {video: true, audio: true};

    var denied = 'PermissionDeniedError';
    var altDenied = 'PERMISSION_DENIED';
    var notSatisfied = 'ConstraintNotSatisfiedError';

    // make constraints optional
    if (!haveOpts) {
        cb = constraints;
        constraints = defaultOpts;
    }

    // treat lack of browser support like an error
    if (typeof navigator === 'undefined' || !navigator.mediaDevices){ //getUserMedia) {
        // throw proper error per spec
        error = new Error('MediaStreamError');
        error.name = 'NotSupportedError';

        // keep all callbacks async
        return setTimeout(function () {
            cb(error);
        }, 0);
    }

    // normalize error handling when no media types are requested
    if (!constraints.audio && !constraints.video) {
        error = new Error('MediaStreamError');
        error.name = 'NoMediaRequestedError';

        // keep all callbacks async
        return setTimeout(function () {
            cb(error);
        }, 0);
    }

    navigator.mediaDevices.getUserMedia(constraints)
    .then(function (stream) {
        cb(null, stream);
    }).catch(function (err) {
        var error;
        // coerce into an error object since FF gives us a string
        // there are only two valid names according to the spec
        // we coerce all non-denied to "constraint not satisfied".
        if (typeof err === 'string') {
            error = new Error('MediaStreamError');
            if (err === denied || err === altDenied) {
                error.name = denied;
            } else {
                error.name = notSatisfied;
            }
        } else {
            // if we get an error object make sure '.name' property is set
            // according to spec: http://dev.w3.org/2011/webrtc/editor/getusermedia.html#navigatorusermediaerror-and-navigatorusermediaerrorcallback
            error = err;
            if (!error.name) {
                // this is likely chrome which
                // sets a property called "ERROR_DENIED" on the error object
                // if so we make sure to set a name
                if (error[denied]) {
                    err.name = denied;
                } else {
                    err.name = notSatisfied;
                }
            }
        }

        cb(error);
    });
};

},{"webrtc-adapter":102}],19:[function(require,module,exports){
var split = require('browser-split')
var ClassList = require('class-list')

var w = typeof window === 'undefined' ? require('html-element') : window
var document = w.document
var Text = w.Text

function context () {

  var cleanupFuncs = []

  function h() {
    var args = [].slice.call(arguments), e = null
    function item (l) {
      var r
      function parseClass (string) {
        // Our minimal parser doesnt understand escaping CSS special
        // characters like `#`. Dont use them. More reading:
        // https://mathiasbynens.be/notes/css-escapes .

        var m = split(string, /([\.#]?[^\s#.]+)/)
        if(/^\.|#/.test(m[1]))
          e = document.createElement('div')
        forEach(m, function (v) {
          var s = v.substring(1,v.length)
          if(!v) return
          if(!e)
            e = document.createElement(v)
          else if (v[0] === '.')
            ClassList(e).add(s)
          else if (v[0] === '#')
            e.setAttribute('id', s)
        })
      }

      if(l == null)
        ;
      else if('string' === typeof l) {
        if(!e)
          parseClass(l)
        else
          e.appendChild(r = document.createTextNode(l))
      }
      else if('number' === typeof l
        || 'boolean' === typeof l
        || l instanceof Date
        || l instanceof RegExp ) {
          e.appendChild(r = document.createTextNode(l.toString()))
      }
      //there might be a better way to handle this...
      else if (isArray(l))
        forEach(l, item)
      else if(isNode(l))
        e.appendChild(r = l)
      else if(l instanceof Text)
        e.appendChild(r = l)
      else if ('object' === typeof l) {
        for (var k in l) {
          if('function' === typeof l[k]) {
            if(/^on\w+/.test(k)) {
              (function (k, l) { // capture k, l in the closure
                if (e.addEventListener){
                  e.addEventListener(k.substring(2), l[k], false)
                  cleanupFuncs.push(function(){
                    e.removeEventListener(k.substring(2), l[k], false)
                  })
                }else{
                  e.attachEvent(k, l[k])
                  cleanupFuncs.push(function(){
                    e.detachEvent(k, l[k])
                  })
                }
              })(k, l)
            } else {
              // observable
              e[k] = l[k]()
              cleanupFuncs.push(l[k](function (v) {
                e[k] = v
              }))
            }
          }
          else if(k === 'style') {
            if('string' === typeof l[k]) {
              e.style.cssText = l[k]
            }else{
              for (var s in l[k]) (function(s, v) {
                if('function' === typeof v) {
                  // observable
                  e.style.setProperty(s, v())
                  cleanupFuncs.push(v(function (val) {
                    e.style.setProperty(s, val)
                  }))
                } else
                  var match = l[k][s].match(/(.*)\W+!important\W*$/);
                  if (match) {
                    e.style.setProperty(s, match[1], 'important')
                  } else {
                    e.style.setProperty(s, l[k][s])
                  }
              })(s, l[k][s])
            }
          } else if(k === 'attrs') {
            for (var v in l[k]) {
              e.setAttribute(v, l[k][v])
            }
          }
          else if (k.substr(0, 5) === "data-") {
            e.setAttribute(k, l[k])
          } else {
            e[k] = l[k]
          }
        }
      } else if ('function' === typeof l) {
        //assume it's an observable!
        var v = l()
        e.appendChild(r = isNode(v) ? v : document.createTextNode(v))

        cleanupFuncs.push(l(function (v) {
          if(isNode(v) && r.parentElement)
            r.parentElement.replaceChild(v, r), r = v
          else
            r.textContent = v
        }))
      }

      return r
    }
    while(args.length)
      item(args.shift())

    return e
  }

  h.cleanup = function () {
    for (var i = 0; i < cleanupFuncs.length; i++){
      cleanupFuncs[i]()
    }
    cleanupFuncs.length = 0
  }

  return h
}

var h = module.exports = context()
h.context = context

function isNode (el) {
  return el && el.nodeName && el.nodeType
}

function forEach (arr, fn) {
  if (arr.forEach) return arr.forEach(fn)
  for (var i = 0; i < arr.length; i++) fn(arr[i], i)
}

function isArray (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]'
}



},{"browser-split":7,"class-list":8,"html-element":116}],20:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],21:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],22:[function(require,module,exports){
module.exports = function (args, opts) {
    if (!opts) opts = {};
    
    var flags = { bools : {}, strings : {}, unknownFn: null };

    if (typeof opts['unknown'] === 'function') {
        flags.unknownFn = opts['unknown'];
    }

    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
      flags.allBools = true;
    } else {
      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
          flags.bools[key] = true;
      });
    }
    
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function (key) {
        aliases[key] = [].concat(opts.alias[key]);
        aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
                return x !== y;
            }));
        });
    });

    [].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true;
        if (aliases[key]) {
            flags.strings[aliases[key]] = true;
        }
     });

    var defaults = opts['default'] || {};
    
    var argv = { _ : [] };
    Object.keys(flags.bools).forEach(function (key) {
        setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });
    
    var notFlags = [];

    if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--')+1);
        args = args.slice(0, args.indexOf('--'));
    }

    function argDefined(key, arg) {
        return (flags.allBools && /^--[^=]+$/.test(arg)) ||
            flags.strings[key] || flags.bools[key] || aliases[key];
    }

    function setArg (key, val, arg) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg) === false) return;
        }

        var value = !flags.strings[key] && isNumber(val)
            ? Number(val) : val
        ;
        setKey(argv, key.split('.'), value);
        
        (aliases[key] || []).forEach(function (x) {
            setKey(argv, x.split('.'), value);
        });
    }

    function setKey (obj, keys, value) {
        var o = obj;
        for (var i = 0; i < keys.length-1; i++) {
            var key = keys[i];
            if (key === '__proto__') return;
            if (o[key] === undefined) o[key] = {};
            if (o[key] === Object.prototype || o[key] === Number.prototype
                || o[key] === String.prototype) o[key] = {};
            if (o[key] === Array.prototype) o[key] = [];
            o = o[key];
        }

        var key = keys[keys.length - 1];
        if (key === '__proto__') return;
        if (o === Object.prototype || o === Number.prototype
            || o === String.prototype) o = {};
        if (o === Array.prototype) o = [];
        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
            o[key] = value;
        }
        else if (Array.isArray(o[key])) {
            o[key].push(value);
        }
        else {
            o[key] = [ o[key], value ];
        }
    }
    
    function aliasIsBoolean(key) {
      return aliases[key].some(function (x) {
          return flags.bools[x];
      });
    }

    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        
        if (/^--.+=/.test(arg)) {
            // Using [\s\S] instead of . because js doesn't support the
            // 'dotall' regex modifier. See:
            // http://stackoverflow.com/a/1068308/13216
            var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
            var key = m[1];
            var value = m[2];
            if (flags.bools[key]) {
                value = value !== 'false';
            }
            setArg(key, value, arg);
        }
        else if (/^--no-.+/.test(arg)) {
            var key = arg.match(/^--no-(.+)/)[1];
            setArg(key, false, arg);
        }
        else if (/^--.+/.test(arg)) {
            var key = arg.match(/^--(.+)/)[1];
            var next = args[i + 1];
            if (next !== undefined && !/^-/.test(next)
            && !flags.bools[key]
            && !flags.allBools
            && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i++;
            }
            else if (/^(true|false)$/.test(next)) {
                setArg(key, next === 'true', arg);
                i++;
            }
            else {
                setArg(key, flags.strings[key] ? '' : true, arg);
            }
        }
        else if (/^-[^-]+/.test(arg)) {
            var letters = arg.slice(1,-1).split('');
            
            var broken = false;
            for (var j = 0; j < letters.length; j++) {
                var next = arg.slice(j+2);
                
                if (next === '-') {
                    setArg(letters[j], next, arg)
                    continue;
                }
                
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split('=')[1], arg);
                    broken = true;
                    break;
                }
                
                if (/[A-Za-z]/.test(letters[j])
                && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                
                if (letters[j+1] && letters[j+1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j+2), arg);
                    broken = true;
                    break;
                }
                else {
                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                }
            }
            
            var key = arg.slice(-1)[0];
            if (!broken && key !== '-') {
                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                && !flags.bools[key]
                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i+1], arg);
                    i++;
                }
                else if (args[i+1] && /^(true|false)$/.test(args[i+1])) {
                    setArg(key, args[i+1] === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
        }
        else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(
                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                );
            }
            if (opts.stopEarly) {
                argv._.push.apply(argv._, args.slice(i + 1));
                break;
            }
        }
    }
    
    Object.keys(defaults).forEach(function (key) {
        if (!hasKey(argv, key.split('.'))) {
            setKey(argv, key.split('.'), defaults[key]);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), defaults[key]);
            });
        }
    });
    
    if (opts['--']) {
        argv['--'] = new Array();
        notFlags.forEach(function(key) {
            argv['--'].push(key);
        });
    }
    else {
        notFlags.forEach(function(key) {
            argv._.push(key);
        });
    }

    return argv;
};

function hasKey (obj, keys) {
    var o = obj;
    keys.slice(0,-1).forEach(function (key) {
        o = (o[key] || {});
    });

    var key = keys[keys.length - 1];
    return key in o;
}

function isNumber (x) {
    if (typeof x === 'number') return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}


},{}],23:[function(require,module,exports){
(function (process){(function (){

'use strict'

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./mobx.cjs.production.min.js')
} else {
  module.exports = require('./mobx.cjs.development.js')
}

}).call(this)}).call(this,require('_process'))

},{"./mobx.cjs.development.js":24,"./mobx.cjs.production.min.js":25,"_process":136}],24:[function(require,module,exports){
(function (global){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var niceErrors = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function _(annotationType, key) {
    return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
  },

  /*
  2(prop) {
      return `invalid decorator for '${prop.toString()}'`
  },
  3(prop) {
      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
  },
  4(prop) {
      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
  },
  */
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function _(index, length) {
    return "[mobx.array] Index out of bounds, " + index + " is larger than " + length;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function _(other) {
    return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
  },
  20: function _(other) {
    return "Cannot initialize map from " + other;
  },
  21: function _(dataStructure) {
    return "Cannot convert to map from '" + dataStructure + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function _(thing) {
    return "Cannot obtain administration from " + thing;
  },
  25: function _(property, name) {
    return "the entry '" + property + "' does not exist in the observable map '" + name + "'";
  },
  26: "please specify a property",
  27: function _(property, name) {
    return "no observable property '" + property.toString() + "' found on the observable object '" + name + "'";
  },
  28: function _(thing) {
    return "Cannot obtain atom from " + thing;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function _(name, derivation) {
    return "Cycle detected in computation " + name + ": " + derivation;
  },
  33: function _(name) {
    return "The setter of computed value '" + name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function _(name) {
    return "[ComputedValue '" + name + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function _(method) {
    return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
  },
  38: "'ownKeys()' can only be used on observable objects",
  39: "'defineProperty()' can only be used on observable objects"
};
var errors =  niceErrors ;
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  {
    var e = typeof error === "string" ? error : errors[error];
    if (typeof e === "function") e = e.apply(null, args);
    throw new Error("[MobX] " + e);
  }
}

var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }

  if (typeof window !== "undefined") {
    return window;
  }

  if (typeof global !== "undefined") {
    return global;
  }

  if (typeof self !== "undefined") {
    return self;
  }

  return mockGlobal;
}

var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = /*#__PURE__*/Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die( "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" );
  }
}
function warnAboutProxyRequirement(msg) {
  if ( globalState.verifyProxies) {
    die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + msg);
  }
}
function getNextId() {
  return ++globalState.mobxGuid;
}
/**
 * Makes sure that the provided function is invoked at most once.
 */

function once(func) {
  var invoked = false;
  return function () {
    if (invoked) return;
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop = function noop() {};
function isFunction(fn) {
  return typeof fn === "function";
}
function isStringish(value) {
  var t = typeof value;

  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }

  return false;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  var _proto$constructor;

  if (!isObject(value)) return false;
  var proto = Object.getPrototypeOf(value);
  if (proto == null) return true;
  return ((_proto$constructor = proto.constructor) == null ? void 0 : _proto$constructor.toString()) === plainObjectString;
} // https://stackoverflow.com/a/37865170

function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) return false;
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) return true;
  return false;
}
function addHiddenProp(object, propName, value) {
  defineProperty(object, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value: value
  });
}
function addHiddenFinalProp(object, propName, value) {
  defineProperty(object, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value: value
  });
}
function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function (x) {
    return isObject(x) && x[propName] === true;
  };
}
function isES6Map(thing) {
  return thing instanceof Map;
}
function isES6Set(thing) {
  return thing instanceof Set;
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
/**
 * Returns the following: own enumerable keys and symbols.
 */

function getPlainObjectKeys(object) {
  var keys = Object.keys(object); // Not supported in IE, so there are not going to be symbol props anyway...

  if (!hasGetOwnPropertySymbols) return keys;
  var symbols = Object.getOwnPropertySymbols(object);
  if (!symbols.length) return keys;
  return [].concat(keys, symbols.filter(function (s) {
    return objectPrototype.propertyIsEnumerable.call(object, s);
  }));
} // From Immer utils
// Returns all own keys, including non-enumerable and symbolic

var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function (obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} :
/* istanbul ignore next */
Object.getOwnPropertyNames;
function stringifyKey(key) {
  if (typeof key === "string") return key;
  if (typeof key === "symbol") return key.toString();
  return new String(key).toString();
}
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
} // From Immer utils

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274
  var res = {}; // Note: without polyfill for ownKeys, symbols won't be picked up

  ownKeys(target).forEach(function (key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

var storedAnnotationsSymbol = /*#__PURE__*/Symbol("mobx-stored-annotations");
/**
 * Creates a function that acts as
 * - decorator
 * - annotation object
 */

function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    storeAnnotation(target, property, annotation);
  }

  return Object.assign(decorator, annotation);
}
/**
 * Stores annotation to prototype,
 * so it can be inspected later by `makeObservable` called from constructor
 */

function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
  } // @override must override something


  if ( isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    die("'" + fieldName + "' is decorated with 'override', " + "but no such decorated member was found on prototype.");
  } // Cannot re-decorate


  assertNotDecorated(prototype, annotation, key); // Ignore override

  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}

function assertNotDecorated(prototype, annotation, key) {
  if ( !isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed." + "\nUse '@override' decorator for methods overriden by subclass.");
  }
}
/**
 * Collects annotations from prototypes and stores them on target (instance)
 */


function collectStoredAnnotations(target) {
  if (!hasProp(target, storedAnnotationsSymbol)) {
    if ( !target[storedAnnotationsSymbol]) {
      die("No annotations were passed to makeObservable, but no decorated members have been found either");
    } // We need a copy as we will remove annotation from the list once it's applied.


    addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
  }

  return target[storedAnnotationsSymbol];
}

var $mobx = /*#__PURE__*/Symbol("mobx administration");
var Atom = /*#__PURE__*/function () {
  // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed

  /**
   * Create a new atom. For debugging purposes it is recommended to give it a name.
   * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
   */
  function Atom(name_) {
    if (name_ === void 0) {
      name_ =  "Atom@" + getNextId() ;
    }

    this.name_ = void 0;
    this.isPendingUnobservation_ = false;
    this.isBeingObserved_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
  } // onBecomeObservedListeners


  var _proto = Atom.prototype;

  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function (listener) {
        return listener();
      });
    }
  };

  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function (listener) {
        return listener();
      });
    }
  }
  /**
   * Invoke this method to notify mobx that your atom has been used somehow.
   * Returns true if there is currently a reactive context.
   */
  ;

  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  }
  /**
   * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
   */
  ;

  _proto.reportChanged = function reportChanged() {
    startBatch();
    propagateChanged(this);
    endBatch();
  };

  _proto.toString = function toString() {
    return this.name_;
  };

  return Atom;
}();
var isAtom = /*#__PURE__*/createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }

  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }

  var atom = new Atom(name); // default `noop` listener will not initialize the hook Set

  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }

  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }

  return atom;
}

function identityComparer(a, b) {
  return a === b;
}

function structuralComparer(a, b) {
  return deepEqual(a, b);
}

function shallowComparer(a, b) {
  return deepEqual(a, b, 1);
}

function defaultComparer(a, b) {
  if (Object.is) return Object.is(a, b);
  return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;
}

var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};

function deepEnhancer(v, _, name) {
  // it is an observable already, done
  if (isObservable(v)) return v; // something that can be converted and mutated?

  if (Array.isArray(v)) return observable.array(v, {
    name: name
  });
  if (isPlainObject(v)) return observable.object(v, undefined, {
    name: name
  });
  if (isES6Map(v)) return observable.map(v, {
    name: name
  });
  if (isES6Set(v)) return observable.set(v, {
    name: name
  });

  if (typeof v === "function" && !isAction(v) && !isFlow(v)) {
    if (isGenerator(v)) {
      return flow(v);
    } else {
      return autoAction(name, v);
    }
  }

  return v;
}
function shallowEnhancer(v, _, name) {
  if (v === undefined || v === null) return v;
  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) return v;
  if (Array.isArray(v)) return observable.array(v, {
    name: name,
    deep: false
  });
  if (isPlainObject(v)) return observable.object(v, undefined, {
    name: name,
    deep: false
  });
  if (isES6Map(v)) return observable.map(v, {
    name: name,
    deep: false
  });
  if (isES6Set(v)) return observable.set(v, {
    name: name,
    deep: false
  });
  die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
}
function referenceEnhancer(newValue) {
  // never turn into an observable
  return newValue;
}
function refStructEnhancer(v, oldValue) {
  if ( isObservable(v)) die("observable.struct should not be used with observable values");
  if (deepEqual(v, oldValue)) return oldValue;
  return v;
}

var OVERRIDE = "override";
var override = /*#__PURE__*/createDecoratorAnnotation({
  annotationType_: OVERRIDE,
  make_: make_,
  extend_: extend_
});
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}

function make_(adm, key) {
  // Must not be plain object
  if ( adm.isPlainObject_) {
    die("Cannot apply '" + this.annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + this.annotationType_ + "' cannot be used on plain objects."));
  } // Must override something


  if ( !hasProp(adm.appliedAnnotations_, key)) {
    die("'" + adm.name_ + "." + key.toString() + "' is annotated with '" + this.annotationType_ + "', " + "but no such annotated member was found on prototype.");
  }

  return 0
  /* Cancel */
  ;
}

function extend_(adm, key, descriptor, proxyTrap) {
  die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}

function createActionAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$1,
    extend_: extend_$1
  };
}

function make_$1(adm, key, descriptor, source) {
  var _this$options_;

  // bound
  if ((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0
    /* Cancel */
    : 1
    /* Break */
    ;
  } // own


  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0
    /* Cancel */
    : 2
    /* Continue */
    ;
  } // prototype


  if (isAction(descriptor.value)) {
    // A prototype could have been annotated already by other constructor,
    // rest of the proto chain must be annotated already
    return 1
    /* Break */
    ;
  }

  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2
  /* Continue */
  ;
}

function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}

function assertActionDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;

  if ( !isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
  }
}

function createActionDescriptor(adm, annotation, key, descriptor, // provides ability to disable safeDescriptors for prototypes
safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3;

  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }

  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;

  if ((_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.bound) {
    var _adm$proxy_;

    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }

  return {
    value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}

function createFlowAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$2,
    extend_: extend_$2
  };
}

function make_$2(adm, key, descriptor, source) {
  var _this$options_;

  // own
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0
    /* Cancel */
    : 2
    /* Continue */
    ;
  } // prototype
  // bound - must annotate protos to support super.flow()


  if (((_this$options_ = this.options_) == null ? void 0 : _this$options_.bound) && !isFlow(adm.target_[key])) {
    if (this.extend_(adm, key, descriptor, false) === null) return 0
    /* Cancel */
    ;
  }

  if (isFlow(descriptor.value)) {
    // A prototype could have been annotated already by other constructor,
    // rest of the proto chain must be annotated already
    return 1
    /* Break */
    ;
  }

  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2
  /* Continue */
  ;
}

function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;

  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}

function assertFlowDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;

  if ( !isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
  }
}

function createFlowDescriptor(adm, annotation, key, descriptor, bound, // provides ability to disable safeDescriptors for prototypes
safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }

  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;

  if (bound) {
    var _adm$proxy_;

    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }

  return {
    value: flow(value),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}

function createComputedAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$3,
    extend_: extend_$3
  };
}

function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0
  /* Cancel */
  : 1
  /* Break */
  ;
}

function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}

function assertComputedDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var get = _ref2.get;

  if ( !get) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
  }
}

function createObservableAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$4,
    extend_: extend_$4
  };
}

function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0
  /* Cancel */
  : 1
  /* Break */
  ;
}

function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;

  assertObservableDescriptor(adm, this, key, descriptor);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}

function assertObservableDescriptor(adm, _ref, key, descriptor) {
  var annotationType_ = _ref.annotationType_;

  if ( !("value" in descriptor)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
  }
}

var AUTO = "true";
var autoAnnotation = /*#__PURE__*/createAutoAnnotation();
function createAutoAnnotation(options) {
  return {
    annotationType_: AUTO,
    options_: options,
    make_: make_$5,
    extend_: extend_$5
  };
}

function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;

  // getter -> computed
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  } // lone setter -> action setter


  if (descriptor.set) {
    // TODO make action applicable to setter and delegate to action.make_
    var set = createAction(key.toString(), descriptor.set); // own

    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set
      }) === null ? 0
      /* Cancel */
      : 2
      /* Continue */
      ;
    } // proto


    defineProperty(source, key, {
      configurable: true,
      set: set
    });
    return 2
    /* Continue */
    ;
  } // function on proto -> autoAction/flow


  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;

    if (isGenerator(descriptor.value)) {
      var _this$options_;

      var flowAnnotation = ((_this$options_ = this.options_) == null ? void 0 : _this$options_.autoBind) ? flow.bound : flow;
      return flowAnnotation.make_(adm, key, descriptor, source);
    }

    var actionAnnotation = ((_this$options_2 = this.options_) == null ? void 0 : _this$options_2.autoBind) ? autoAction.bound : autoAction;
    return actionAnnotation.make_(adm, key, descriptor, source);
  } // other -> observable
  // Copy props from proto as well, see test:
  // "decorate should work with Object.create"


  var observableAnnotation = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable; // if function respect autoBind option

  if (typeof descriptor.value === "function" && ((_this$options_4 = this.options_) == null ? void 0 : _this$options_4.autoBind)) {
    var _adm$proxy_;

    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }

  return observableAnnotation.make_(adm, key, descriptor, source);
}

function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;

  // getter -> computed
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  } // lone setter -> action setter


  if (descriptor.set) {
    // TODO make action applicable to setter and delegate to action.extend_
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  } // other -> observable
  // if function respect autoBind option


  if (typeof descriptor.value === "function" && ((_this$options_5 = this.options_) == null ? void 0 : _this$options_5.autoBind)) {
    var _adm$proxy_2;

    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }

  var observableAnnotation = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
  return observableAnnotation.extend_(adm, key, descriptor, proxyTrap);
}

var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct"; // Predefined bags of create observable options, to avoid allocating temporarily option objects
// in the majority of cases

var defaultCreateObservableOptions = {
  deep: true,
  name: undefined,
  defaultDecorator: undefined,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = /*#__PURE__*/createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = /*#__PURE__*/createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options) {
  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
}
function getAnnotationFromOptions(options) {
  var _options$defaultDecor;

  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : undefined;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;

  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
/**
 * Turns an object, array or function into a reactive structure.
 * @param v the value which should become observable.
 */

function createObservable(v, arg2, arg3) {
  // @observable someProp;
  if (isStringish(arg2)) {
    storeAnnotation(v, arg2, observableAnnotation);
    return;
  } // already observable - ignore


  if (isObservable(v)) return v; // plain object

  if (isPlainObject(v)) return observable.object(v, arg2, arg3); // Array

  if (Array.isArray(v)) return observable.array(v, arg2); // Map

  if (isES6Map(v)) return observable.map(v, arg2); // Set

  if (isES6Set(v)) return observable.set(v, arg2); // other object - ignore

  if (typeof v === "object" && v !== null) return v; // anything else

  return observable.box(v, arg2);
}

Object.assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
  },
  array: function array(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
  },
  map: function map(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
  },
  set: function set(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
  },
  object: function object(props, decorators, options) {
    return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
  },
  ref: /*#__PURE__*/createDecoratorAnnotation(observableRefAnnotation),
  shallow: /*#__PURE__*/createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: /*#__PURE__*/createDecoratorAnnotation(observableStructAnnotation)
}; // eslint-disable-next-line

var observable = /*#__PURE__*/assign(createObservable, observableFactories);

var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED);
var computedStructAnnotation = /*#__PURE__*/createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
/**
 * Decorator for class properties: @computed get value() { return expr; }.
 * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
 */

var computed = function computed(arg1, arg2) {
  if (isStringish(arg2)) {
    // @computed
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }

  if (isPlainObject(arg1)) {
    // @computed({ options })
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  } // computed(expr, options?)


  {
    if (!isFunction(arg1)) die("First argument to `computed` should be an expression.");
    if (isFunction(arg2)) die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
  }

  var opts = isPlainObject(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  /* for generated name */

  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = /*#__PURE__*/createDecoratorAnnotation(computedStructAnnotation);

var _getDescriptor$config, _getDescriptor;
// mobx versions

var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /*#__PURE__*/getDescriptor(function () {}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false; // we can safely recycle this object

var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn, autoAction, ref) {
  if (autoAction === void 0) {
    autoAction = false;
  }

  {
    if (!isFunction(fn)) die("`action` can only be invoked on functions");
    if (typeof actionName !== "string" || !actionName) die("actions should have valid names, got: '" + actionName + "'");
  }

  function res() {
    return executeAction(actionName, autoAction, fn, ref || this, arguments);
  }

  res.isMobxAction = true;

  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    Object.defineProperty(res, "name", tmpNameDescriptor);
  }

  return res;
}
function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);

  try {
    return fn.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, // true for autoAction
scope, args) {
  var notifySpy_ =  isSpyEnabled() && !!actionName;
  var startTime_ = 0;

  if ( notifySpy_) {
    startTime_ = Date.now();
    var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: actionName,
      object: scope,
      arguments: flattenedArgs
    });
  }

  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges; // by default preserve previous allow

  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }

  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_: prevDerivation_,
    prevAllowStateChanges_: prevAllowStateChanges_,
    prevAllowStateReads_: prevAllowStateReads_,
    notifySpy_: notifySpy_,
    startTime_: startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }

  currentActionId = runInfo.parentActionId_;

  if (runInfo.error_ !== undefined) {
    globalState.suppressReactionErrors = true;
  }

  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) untrackedEnd(runInfo.prevDerivation_);

  if ( runInfo.notifySpy_) {
    spyReportEnd({
      time: Date.now() - runInfo.startTime_
    });
  }

  globalState.suppressReactionErrors = false;
}
function allowStateChanges(allowStateChanges, func) {
  var prev = allowStateChangesStart(allowStateChanges);

  try {
    return func();
  } finally {
    allowStateChangesEnd(prev);
  }
}
function allowStateChangesStart(allowStateChanges) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}

var _Symbol$toPrimitive;
var CREATE = "create";
_Symbol$toPrimitive = Symbol.toPrimitive;
var ObservableValue = /*#__PURE__*/function (_Atom) {
  _inheritsLoose(ObservableValue, _Atom);

  function ObservableValue(value, enhancer, name_, notifySpy, equals) {
    var _this;

    if (name_ === void 0) {
      name_ =  "ObservableValue@" + getNextId() ;
    }

    if (notifySpy === void 0) {
      notifySpy = true;
    }

    if (equals === void 0) {
      equals = comparer["default"];
    }

    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, undefined, name_);

    if ( notifySpy && isSpyEnabled()) {
      // only notify spy if this is a stand-alone observable
      spyReport({
        type: CREATE,
        object: _assertThisInitialized(_this),
        observableKind: "value",
        debugObjectName: _this.name_,
        newValue: "" + _this.value_
      });
    }

    return _this;
  }

  var _proto = ObservableValue.prototype;

  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== undefined) return this.dehancer(value);
    return value;
  };

  _proto.set = function set(newValue) {
    var oldValue = this.value_;
    newValue = this.prepareNewValue_(newValue);

    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();

      if ( notifySpy) {
        spyReportStart({
          type: UPDATE,
          object: this,
          observableKind: "value",
          debugObjectName: this.name_,
          newValue: newValue,
          oldValue: oldValue
        });
      }

      this.setNewValue_(newValue);
      if ( notifySpy) spyReportEnd();
    }
  };

  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    checkIfStateModificationsAreAllowed(this);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue: newValue
      });
      if (!change) return globalState.UNCHANGED;
      newValue = change.newValue;
    } // apply modifier


    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };

  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();

    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue: newValue,
        oldValue: oldValue
      });
    }
  };

  _proto.get = function get() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately) listener({
      observableKind: "value",
      debugObjectName: this.name_,
      object: this,
      type: UPDATE,
      newValue: this.value_,
      oldValue: undefined
    });
    return registerListener(this, listener);
  };

  _proto.raw = function raw() {
    // used by MST ot get undehanced value
    return this.value_;
  };

  _proto.toJSON = function toJSON() {
    return this.get();
  };

  _proto.toString = function toString() {
    return this.name_ + "[" + this.value_ + "]";
  };

  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };

  _proto[_Symbol$toPrimitive] = function () {
    return this.valueOf();
  };

  return ObservableValue;
}(Atom);
var isObservableValue = /*#__PURE__*/createInstanceofPredicate("ObservableValue", ObservableValue);

var _Symbol$toPrimitive$1;
/**
 * A node in the state dependency root that observes other nodes, and can be observed itself.
 *
 * ComputedValue will remember the result of the computation for the duration of the batch, or
 * while being observed.
 *
 * During this time it will recompute only when one of its direct dependencies changed,
 * but only when it is being accessed with `ComputedValue.get()`.
 *
 * Implementation description:
 * 1. First time it's being accessed it will compute and remember result
 *    give back remembered result until 2. happens
 * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
 * 3. When it's being accessed, recompute if any shallow dependency changed.
 *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
 *    go to step 2. either way
 *
 * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
 */

_Symbol$toPrimitive$1 = Symbol.toPrimitive;
var ComputedValue = /*#__PURE__*/function () {
  // nodes we are looking at. Our value depends on these nodes
  // during tracking it's an array with new observed observers
  // to check for cycles
  // N.B: unminified as it is used by MST

  /**
   * Create a new computed value based on a function expression.
   *
   * The `name` property is for debug purposes only.
   *
   * The `equals` property specifies the comparer function to use to determine if a newly produced
   * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
   * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.
   * Structural comparison can be convenient if you always produce a new aggregated object and
   * don't want to notify observers if it is structurally the same.
   * This is useful for working with vectors, mouse coordinates etc.
   */
  function ComputedValue(options) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.isBeingObserved_ = false;
    this.isPendingUnobservation_ = false;
    this.observers_ = new Set();
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.isComputing_ = false;
    this.isRunningSetter_ = false;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options.get) die(31);
    this.derivation = options.get;
    this.name_ = options.name || ( "ComputedValue@" + getNextId() );

    if (options.set) {
      this.setter_ = createAction( this.name_ + "-setter" , options.set);
    }

    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options.context;
    this.requiresReaction_ = !!options.requiresReaction;
    this.keepAlive_ = !!options.keepAlive;
  }

  var _proto = ComputedValue.prototype;

  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };

  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function (listener) {
        return listener();
      });
    }
  };

  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function (listener) {
        return listener();
      });
    }
  }
  /**
   * Returns the current value of this computed value.
   * Will evaluate its computation first if needed.
   */
  ;

  _proto.get = function get() {
    if (this.isComputing_) die(32, this.name_, this.derivation);

    if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch(); // See perf test 'computed memoization'

        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);

      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext) globalState.trackingContext = this;
        if (this.trackAndCompute()) propagateChangeConfirmed(this);
        globalState.trackingContext = prevTrackingContext;
      }
    }

    var result = this.value_;
    if (isCaughtException(result)) throw result.cause;
    return result;
  };

  _proto.set = function set(value) {
    if (this.setter_) {
      if (this.isRunningSetter_) die(33, this.name_);
      this.isRunningSetter_ = true;

      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter_ = false;
      }
    } else die(34, this.name_);
  };

  _proto.trackAndCompute = function trackAndCompute() {
    // N.B: unminified as it is used by MST
    var oldValue = this.value_;
    var wasSuspended =
    /* see #1208 */
    this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;
    var newValue = this.computeValue_(true);

    if ( isSpyEnabled()) {
      spyReport({
        observableKind: "computed",
        debugObjectName: this.name_,
        object: this.scope_,
        type: "update",
        oldValue: this.value_,
        newValue: newValue
      });
    }

    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);

    if (changed) {
      this.value_ = newValue;
    }

    return changed;
  };

  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing_ = true; // don't allow state changes during computation

    var prev = allowStateChangesStart(false);
    var res;

    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e) {
          res = new CaughtException(e);
        }
      }
    }

    allowStateChangesEnd(prev);
    this.isComputing_ = false;
    return res;
  };

  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = undefined; // don't hold on to computed value!

      if ( this.isTracing_ !== TraceMode.NONE) {
        console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
      }
    }
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;

    var firstTime = true;
    var prevValue = undefined;
    return autorun(function () {
      // TODO: why is this in a different place than the spyReport() function? in all other observables it's called in the same place
      var newValue = _this.get();

      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue: newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }

      firstTime = false;
      prevValue = newValue;
    });
  };

  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {

    if (this.isTracing_ !== TraceMode.NONE) {
      console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }

    if (globalState.computedRequiresReaction || this.requiresReaction_) {
      console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
  };

  _proto.toString = function toString() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };

  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };

  _proto[_Symbol$toPrimitive$1] = function () {
    return this.valueOf();
  };

  return ComputedValue;
}();
var isComputedValue = /*#__PURE__*/createInstanceofPredicate("ComputedValue", ComputedValue);

var IDerivationState_;

(function (IDerivationState_) {
  // before being run or (outside batch and not being observed)
  // at this point derivation is not holding any data about dependency tree
  IDerivationState_[IDerivationState_["NOT_TRACKING_"] = -1] = "NOT_TRACKING_"; // no shallow dependency changed since last computation
  // won't recalculate derivation
  // this is what makes mobx fast

  IDerivationState_[IDerivationState_["UP_TO_DATE_"] = 0] = "UP_TO_DATE_"; // some deep dependency changed, but don't know if shallow dependency changed
  // will require to check first if UP_TO_DATE or POSSIBLY_STALE
  // currently only ComputedValue will propagate POSSIBLY_STALE
  //
  // having this state is second big optimization:
  // don't have to recompute on every dependency change, but only when it's needed

  IDerivationState_[IDerivationState_["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_"; // A shallow dependency has changed since last computation and the derivation
  // will need to recompute when it's needed next.

  IDerivationState_[IDerivationState_["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));

var TraceMode;

(function (TraceMode) {
  TraceMode[TraceMode["NONE"] = 0] = "NONE";
  TraceMode[TraceMode["LOG"] = 1] = "LOG";
  TraceMode[TraceMode["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));

var CaughtException = function CaughtException(cause) {
  this.cause = void 0;
  this.cause = cause; // Empty
};
function isCaughtException(e) {
  return e instanceof CaughtException;
}
/**
 * Finds out whether any dependency of the derivation has actually changed.
 * If dependenciesState is 1 then it will recalculate dependencies,
 * if any dependency changed it will propagate it by changing dependenciesState to 2.
 *
 * By iterating over the dependencies in the same order that they were reported and
 * stopping on the first change, all the recalculations are only called for ComputedValues
 * that will be tracked by derivation. That is because we assume that if the first x
 * dependencies of the derivation doesn't change then the derivation should run the same way
 * up until accessing x-th dependency.
 */

function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;

    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;

    case IDerivationState_.POSSIBLY_STALE_:
      {
        // state propagation can occur outside of action/reactive context #2195
        var prevAllowStateReads = allowStateReadsStart(true);
        var prevUntracked = untrackedStart(); // no need for those computeds to be reported, they will be picked up in trackDerivedFunction.

        var obs = derivation.observing_,
            l = obs.length;

        for (var i = 0; i < l; i++) {
          var obj = obs[i];

          if (isComputedValue(obj)) {
            if (globalState.disableErrorBoundaries) {
              obj.get();
            } else {
              try {
                obj.get();
              } catch (e) {
                // we are not interested in the value *or* exception at this moment, but if there is one, notify all
                untrackedEnd(prevUntracked);
                allowStateReadsEnd(prevAllowStateReads);
                return true;
              }
            } // if ComputedValue `obj` actually changed it will be computed and propagated to its observers.
            // and `derivation` is an observer of `obj`
            // invariantShouldCompute(derivation)


            if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
        }

        changeDependenciesStateTo0(derivation);
        untrackedEnd(prevUntracked);
        allowStateReadsEnd(prevAllowStateReads);
        return false;
      }
  }
}
function isComputingDerivation() {
  return globalState.trackingDerivation !== null; // filter out actions inside computations
}
function checkIfStateModificationsAreAllowed(atom) {

  var hasObservers = atom.observers_.size > 0; // Should not be possible to change observed state outside strict mode, except during initialization, see #563

  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "always")) console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
}
function checkIfStateReadsAreAllowed(observable) {
  if ( !globalState.allowStateReads && globalState.observableRequiresReaction) {
    console.warn("[mobx] Observable '" + observable.name_ + "' being read outside a reactive context.");
  }
}
/**
 * Executes the provided function `f` and tracks which observables are being accessed.
 * The tracking information is stored on the `derivation` object and the derivation is registered
 * as observer of any of the accessed observables.
 */

function trackDerivedFunction(derivation, f, context) {
  var prevAllowStateReads = allowStateReadsStart(true); // pre allocate array allocation + room for variation in deps
  // array will be trimmed by bindDependencies

  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(derivation.observing_.length + 100);
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;

  if (globalState.disableErrorBoundaries === true) {
    result = f.call(context);
  } else {
    try {
      result = f.call(context);
    } catch (e) {
      result = new CaughtException(e);
    }
  }

  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  warnAboutDerivationWithoutDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}

function warnAboutDerivationWithoutDependencies(derivation) {
  if (derivation.observing_.length !== 0) return;

  if (globalState.reactionRequiresObservable || derivation.requiresObservable_) {
    console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
  }
}
/**
 * diffs newObserving with observing.
 * update observing to be newObserving with unique observables
 * notify observers that become observed/unobserved
 */


function bindDependencies(derivation) {
  // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_; // Go through all new observables and check diffValue: (this list can contain duplicates):
  //   0: first occurrence, change to 1 and keep it
  //   1: extra occurrence, drop it

  var i0 = 0,
      l = derivation.unboundDepsCount_;

  for (var i = 0; i < l; i++) {
    var dep = observing[i];

    if (dep.diffValue_ === 0) {
      dep.diffValue_ = 1;
      if (i0 !== i) observing[i0] = dep;
      i0++;
    } // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,
    // not hitting the condition


    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }

  observing.length = i0;
  derivation.newObserving_ = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)
  // Go through all old observables and check diffValue: (it is unique after last bindDependencies)
  //   0: it's not in new observables, unobserve it
  //   1: it keeps being observed, don't want to notify it. change to 0

  l = prevObserving.length;

  while (l--) {
    var _dep = prevObserving[l];

    if (_dep.diffValue_ === 0) {
      removeObserver(_dep, derivation);
    }

    _dep.diffValue_ = 0;
  } // Go through all new observables and check diffValue: (now it should be unique)
  //   0: it was set to 0 in last loop. don't need to do anything.
  //   1: it wasn't observed, let's observe it. set back to 0


  while (i0--) {
    var _dep2 = observing[i0];

    if (_dep2.diffValue_ === 1) {
      _dep2.diffValue_ = 0;
      addObserver(_dep2, derivation);
    }
  } // Some new observed derivations may become stale during this derivation computation
  // so they have had no chance to propagate staleness (#916)


  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}

function clearObserving(derivation) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR clearObserving should be called only inside batch");
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i = obs.length;

  while (i--) {
    removeObserver(obs[i], derivation);
  }

  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action) {
  var prev = untrackedStart();

  try {
    return action();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
/**
 * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
 *
 */

function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) return;
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i = obs.length;

  while (i--) {
    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}

/**
 * These values will persist if global state is reset
 */

var persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"];
var MobXGlobals = function MobXGlobals() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
};
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = /*#__PURE__*/function () {
  var global = /*#__PURE__*/getGlobal();
  if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals) canMergeGlobalState = false;
  if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version) canMergeGlobalState = false;

  if (!canMergeGlobalState) {
    setTimeout(function () {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global.__mobxGlobals) {
    global.__mobxInstanceCount += 1;
    if (!global.__mobxGlobals.UNCHANGED) global.__mobxGlobals.UNCHANGED = {}; // make merge backward compatible

    return global.__mobxGlobals;
  } else {
    global.__mobxInstanceCount = 1;
    return global.__mobxGlobals = /*#__PURE__*/new MobXGlobals();
  }
}();
function isolateGlobalState() {
  if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) die(36);
  isolateCalled = true;

  if (canMergeGlobalState) {
    var global = getGlobal();
    if (--global.__mobxInstanceCount === 0) global.__mobxGlobals = undefined;
    globalState = new MobXGlobals();
  }
}
function getGlobalState() {
  return globalState;
}
/**
 * For testing purposes only; this will break the internal state of existing observables,
 * but can be used to get back at a stable state after throwing errors
 */

function resetGlobalState() {
  var defaultGlobals = new MobXGlobals();

  for (var key in defaultGlobals) {
    if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];
  }

  globalState.allowStateChanges = !globalState.enforceActions;
}

function hasObservers(observable) {
  return observable.observers_ && observable.observers_.size > 0;
}
function getObservers(observable) {
  return observable.observers_;
} // function invariantObservers(observable: IObservable) {
//     const list = observable.observers
//     const map = observable.observersIndexes
//     const l = list.length
//     for (let i = 0; i < l; i++) {
//         const id = list[i].__mapid
//         if (i) {
//             invariant(map[id] === i, "INTERNAL ERROR maps derivation.__mapid to index in list") // for performance
//         } else {
//             invariant(!(id in map), "INTERNAL ERROR observer on index 0 shouldn't be held in map.") // for performance
//         }
//     }
//     invariant(
//         list.length === 0 || Object.keys(map).length === list.length - 1,
//         "INTERNAL ERROR there is no junk in map"
//     )
// }

function addObserver(observable, node) {
  // invariant(node.dependenciesState !== -1, "INTERNAL ERROR, can add only dependenciesState !== -1");
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR add already added node");
  // invariantObservers(observable);
  observable.observers_.add(node);
  if (observable.lowestObserverState_ > node.dependenciesState_) observable.lowestObserverState_ = node.dependenciesState_; // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR didn't add node");
}
function removeObserver(observable, node) {
  // invariant(globalState.inBatch > 0, "INTERNAL ERROR, remove should be called only inside batch");
  // invariant(observable._observers.indexOf(node) !== -1, "INTERNAL ERROR remove already removed node");
  // invariantObservers(observable);
  observable.observers_["delete"](node);

  if (observable.observers_.size === 0) {
    // deleting last observer
    queueForUnobservation(observable);
  } // invariantObservers(observable);
  // invariant(observable._observers.indexOf(node) === -1, "INTERNAL ERROR remove already removed node2");

}
function queueForUnobservation(observable) {
  if (observable.isPendingUnobservation_ === false) {
    // invariant(observable._observers.length === 0, "INTERNAL ERROR, should only queue for unobservation unobserved observables");
    observable.isPendingUnobservation_ = true;
    globalState.pendingUnobservations.push(observable);
  }
}
/**
 * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
 * During a batch `onBecomeUnobserved` will be called at most once per observable.
 * Avoids unnecessary recalculations.
 */

function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions(); // the batch is actually about to finish, all unobserving should happen here.

    var list = globalState.pendingUnobservations;

    for (var i = 0; i < list.length; i++) {
      var observable = list[i];
      observable.isPendingUnobservation_ = false;

      if (observable.observers_.size === 0) {
        if (observable.isBeingObserved_) {
          // if this observable had reactive observers, trigger the hooks
          observable.isBeingObserved_ = false;
          observable.onBUO();
        }

        if (observable instanceof ComputedValue) {
          // computed values are automatically teared down when the last observer leaves
          // this process happens recursively, this computed might be the last observabe of another, etc..
          observable.suspend_();
        }
      }
    }

    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable) {
  checkIfStateReadsAreAllowed(observable);
  var derivation = globalState.trackingDerivation;

  if (derivation !== null) {
    /**
     * Simple optimization, give each derivation run an unique id (runId)
     * Check if last time this observable was accessed the same runId is used
     * if this is the case, the relation is already known
     */
    if (derivation.runId_ !== observable.lastAccessedBy_) {
      observable.lastAccessedBy_ = derivation.runId_; // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...

      derivation.newObserving_[derivation.unboundDepsCount_++] = observable;

      if (!observable.isBeingObserved_ && globalState.trackingContext) {
        observable.isBeingObserved_ = true;
        observable.onBO();
      }
    }

    return true;
  } else if (observable.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable);
  }

  return false;
} // function invariantLOS(observable: IObservable, msg: string) {
//     // it's expensive so better not run it in produciton. but temporarily helpful for testing
//     const min = getObservers(observable).reduce((a, b) => Math.min(a, b.dependenciesState), 2)
//     if (min >= observable.lowestObserverState) return // <- the only assumption about `lowestObserverState`
//     throw new Error(
//         "lowestObserverState is wrong for " +
//             msg +
//             " because " +
//             min +
//             " < " +
//             observable.lowestObserverState
//     )
// }

/**
 * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
 * It will propagate changes to observers from previous run
 * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
 * Hopefully self reruning autoruns aren't a feature people should depend on
 * Also most basic use cases should be ok
 */
// Called by Atom when its value changes

function propagateChanged(observable) {
  // invariantLOS(observable, "changed start");
  if (observable.lowestObserverState_ === IDerivationState_.STALE_) return;
  observable.lowestObserverState_ = IDerivationState_.STALE_; // Ideally we use for..of here, but the downcompiled version is really slow...

  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      if ( d.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d, observable);
      }

      d.onBecomeStale_();
    }

    d.dependenciesState_ = IDerivationState_.STALE_;
  }); // invariantLOS(observable, "changed end");
} // Called by ComputedValue when it recalculate and its value changed

function propagateChangeConfirmed(observable) {
  // invariantLOS(observable, "confirmed start");
  if (observable.lowestObserverState_ === IDerivationState_.STALE_) return;
  observable.lowestObserverState_ = IDerivationState_.STALE_;
  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d.dependenciesState_ = IDerivationState_.STALE_;

      if ( d.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d, observable);
      }
    } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ // this happens during computing of `d`, just keep lowestObserverState up to date.
    ) {
        observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
      }
  }); // invariantLOS(observable, "confirmed end");
} // Used by computed when its dependency changed, but we don't wan't to immediately recompute.

function propagateMaybeChanged(observable) {
  // invariantLOS(observable, "maybe start");
  if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) return;
  observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable.observers_.forEach(function (d) {
    if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d.onBecomeStale_();
    }
  }); // invariantLOS(observable, "maybe end");
}

function logTraceInfo(derivation, observable) {
  console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable.name_ + "'");

  if (derivation.isTracing_ === TraceMode.BREAK) {
    var lines = [];
    printDepTree(getDependencyTree(derivation), lines, 1); // prettier-ignore

    new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
}

function printDepTree(tree, lines, depth) {
  if (lines.length >= 1000) {
    lines.push("(and many more)");
    return;
  }

  lines.push("" + new Array(depth).join("\t") + tree.name); // MWE: not the fastest, but the easiest way :)

  if (tree.dependencies) tree.dependencies.forEach(function (child) {
    return printDepTree(child, lines, depth + 1);
  });
}

var Reaction = /*#__PURE__*/function () {
  // nodes we are looking at. Our value depends on these nodes
  function Reaction(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ =  "Reaction@" + getNextId() ;
    }

    if (requiresObservable_ === void 0) {
      requiresObservable_ = false;
    }

    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.diffValue_ = 0;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.isDisposed_ = false;
    this.isScheduled_ = false;
    this.isTrackPending_ = false;
    this.isRunning_ = false;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }

  var _proto = Reaction.prototype;

  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };

  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled_) {
      this.isScheduled_ = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };

  _proto.isScheduled = function isScheduled() {
    return this.isScheduled_;
  }
  /**
   * internal, use schedule() if you intend to kick off a reaction
   */
  ;

  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed_) {
      startBatch();
      this.isScheduled_ = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;

      if (shouldCompute(this)) {
        this.isTrackPending_ = true;

        try {
          this.onInvalidate_();

          if ("development" !== "production" && this.isTrackPending_ && isSpyEnabled()) {
            // onInvalidate didn't trigger track right away..
            spyReport({
              name: this.name_,
              type: "scheduled-reaction"
            });
          }
        } catch (e) {
          this.reportExceptionInDerivation_(e);
        }
      }

      globalState.trackingContext = prev;
      endBatch();
    }
  };

  _proto.track = function track(fn) {
    if (this.isDisposed_) {
      return; // console.warn("Reaction already disposed") // Note: Not a warning / error in mobx 4 either
    }

    startBatch();
    var notify = isSpyEnabled();
    var startTime;

    if ( notify) {
      startTime = Date.now();
      spyReportStart({
        name: this.name_,
        type: "reaction"
      });
    }

    this.isRunning_ = true;
    var prevReaction = globalState.trackingContext; // reactions could create reactions...

    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn, undefined);
    globalState.trackingContext = prevReaction;
    this.isRunning_ = false;
    this.isTrackPending_ = false;

    if (this.isDisposed_) {
      // disposed during last run. Clean up everything that was bound after the dispose call.
      clearObserving(this);
    }

    if (isCaughtException(result)) this.reportExceptionInDerivation_(result.cause);

    if ( notify) {
      spyReportEnd({
        time: Date.now() - startTime
      });
    }

    endBatch();
  };

  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;

    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }

    if (globalState.disableErrorBoundaries) throw error;
    var message =  "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" ;

    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
      /** If debugging brought you here, please, read the above message :-). Tnx! */
    } else console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)"); // prettier-ignore


    if ( isSpyEnabled()) {
      spyReport({
        type: "error",
        name: this.name_,
        message: message,
        error: "" + error
      });
    }

    globalState.globalReactionErrorHandlers.forEach(function (f) {
      return f(error, _this);
    });
  };

  _proto.dispose = function dispose() {
    if (!this.isDisposed_) {
      this.isDisposed_ = true;

      if (!this.isRunning_) {
        // if disposed while running, clean up later. Maybe not optimal, but rare case
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };

  _proto.getDisposer_ = function getDisposer_() {
    var r = this.dispose.bind(this);
    r[$mobx] = this;
    return r;
  };

  _proto.toString = function toString() {
    return "Reaction[" + this.name_ + "]";
  };

  _proto.trace = function trace$1(enterBreakPoint) {
    if (enterBreakPoint === void 0) {
      enterBreakPoint = false;
    }

    trace(this, enterBreakPoint);
  };

  return Reaction;
}();
function onReactionError(handler) {
  globalState.globalReactionErrorHandlers.push(handler);
  return function () {
    var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
    if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);
  };
}
/**
 * Magic number alert!
 * Defines within how many times a reaction is allowed to re-trigger itself
 * until it is assumed that this is gonna be a never ending loop...
 */

var MAX_REACTION_ITERATIONS = 100;

var reactionScheduler = function reactionScheduler(f) {
  return f();
};

function runReactions() {
  // Trampolining, if runReactions are already running, new reactions will be picked up
  if (globalState.inBatch > 0 || globalState.isRunningReactions) return;
  reactionScheduler(runReactionsHelper);
}

function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0; // While running reactions, new reactions might be triggered.
  // Hence we work with two variables and check whether
  // we converge to no remaining reactions after a while.

  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error( "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) );
      allReactions.splice(0); // clear reactions
    }

    var remainingReactions = allReactions.splice(0);

    for (var i = 0, l = remainingReactions.length; i < l; i++) {
      remainingReactions[i].runReaction_();
    }
  }

  globalState.isRunningReactions = false;
}

var isReaction = /*#__PURE__*/createInstanceofPredicate("Reaction", Reaction);
function setReactionScheduler(fn) {
  var baseScheduler = reactionScheduler;

  reactionScheduler = function reactionScheduler(f) {
    return fn(function () {
      return baseScheduler(f);
    });
  };
}

function isSpyEnabled() {
  return  !!globalState.spyListeners.length;
}
function spyReport(event) {

  if (!globalState.spyListeners.length) return;
  var listeners = globalState.spyListeners;

  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](event);
  }
}
function spyReportStart(event) {

  var change = _extends({}, event, {
    spyReportStart: true
  });

  spyReport(change);
}
var END_EVENT = {
  type: "report-end",
  spyReportEnd: true
};
function spyReportEnd(change) {
  if (change) spyReport(_extends({}, change, {
    type: "report-end",
    spyReportEnd: true
  }));else spyReport(END_EVENT);
}
function spy(listener) {
  {
    globalState.spyListeners.push(listener);
    return once(function () {
      globalState.spyListeners = globalState.spyListeners.filter(function (l) {
        return l !== listener;
      });
    });
  }
}

var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = /*#__PURE__*/createActionAnnotation(ACTION);
var actionBoundAnnotation = /*#__PURE__*/createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = /*#__PURE__*/createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});

function createActionFactory(autoAction) {
  var res = function action(arg1, arg2) {
    // action(fn() {})
    if (isFunction(arg1)) return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction); // action("name", fn() {})

    if (isFunction(arg2)) return createAction(arg1, arg2, autoAction); // @action

    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation);
    } // action("name") & @action("name")


    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction
      }));
    }

    die("Invalid arguments for `action`");
  };

  return res;
}

var action = /*#__PURE__*/createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = /*#__PURE__*/createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = /*#__PURE__*/createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = /*#__PURE__*/createDecoratorAnnotation(autoActionBoundAnnotation);
function runInAction(fn) {
  return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined);
}
function isAction(thing) {
  return isFunction(thing) && thing.isMobxAction === true;
}

/**
 * Creates a named reactive view and keeps it alive, so that the view is always
 * updated if one of the dependencies changes, even when the view is not further used by something else.
 * @param view The reactive view
 * @returns disposer function, which can be used to stop the view from being updated in the future.
 */

function autorun(view, opts) {
  var _opts$name, _opts;

  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }

  {
    if (!isFunction(view)) die("Autorun expects a function as first argument");
    if (isAction(view)) die("Autorun does not accept actions since actions are untrackable");
  }

  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name :  view.name || "Autorun@" + getNextId() ;
  var runSync = !opts.scheduler && !opts.delay;
  var reaction;

  if (runSync) {
    // normal autorun
    reaction = new Reaction(name, function () {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts); // debounced autorun

    var isScheduled = false;
    reaction = new Reaction(name, function () {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function () {
          isScheduled = false;
          if (!reaction.isDisposed_) reaction.track(reactionRunner);
        });
      }
    }, opts.onError, opts.requiresObservable);
  }

  function reactionRunner() {
    view(reaction);
  }

  reaction.schedule_();
  return reaction.getDisposer_();
}

var run = function run(f) {
  return f();
};

function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function (f) {
    return setTimeout(f, opts.delay);
  } : run;
}

function reaction(expression, effect, opts) {
  var _opts$name2;

  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }

  {
    if (!isFunction(expression) || !isFunction(effect)) die("First and second argument to reaction should be functions");
    if (!isPlainObject(opts)) die("Third argument of reactions should be an object");
  }

  var name = (_opts$name2 = opts.name) != null ? _opts$name2 :  "Reaction@" + getNextId() ;
  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var oldValue = undefined; // only an issue with fireImmediately

  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
  var r = new Reaction(name, function () {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);

  function reactionRunner() {
    isScheduled = false;
    if (r.isDisposed_) return;
    var changed = false;
    r.track(function () {
      var nextValue = allowStateChanges(false, function () {
        return expression(r);
      });
      changed = firstTime || !equals(value, nextValue);
      oldValue = value;
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately) effectAction(value, oldValue, r);else if (!firstTime && changed) effectAction(value, oldValue, r);
    firstTime = false;
  }

  r.schedule_();
  return r.getDisposer_();
}

function wrapErrorHandler(errorHandler, baseFn) {
  return function () {
    try {
      return baseFn.apply(this, arguments);
    } catch (e) {
      errorHandler.call(this, e);
    }
  };
}

var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}

function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";

  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = new Set([cb]);
  }

  return function () {
    var hookListeners = atom[listenersKey];

    if (hookListeners) {
      hookListeners["delete"](cb);

      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}

var NEVER = "never";
var ALWAYS = "always";
var OBSERVED = "observed"; // const IF_AVAILABLE = "ifavailable"

function configure(options) {
  if (options.isolateGlobalState === true) {
    isolateGlobalState();
  }

  var useProxies = options.useProxies,
      enforceActions = options.enforceActions;

  if (useProxies !== undefined) {
    globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
  }

  if (useProxies === "ifavailable") globalState.verifyProxies = true;

  if (enforceActions !== undefined) {
    var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
    globalState.enforceActions = ea;
    globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
  }
  ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function (key) {
    if (key in options) globalState[key] = !!options[key];
  });
  globalState.allowStateReads = !globalState.observableRequiresReaction;

  if ( globalState.disableErrorBoundaries === true) {
    console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
  }

  if (options.reactionScheduler) {
    setReactionScheduler(options.reactionScheduler);
  }
}

function extendObservable(target, properties, annotations, options) {
  {
    if (arguments.length > 4) die("'extendObservable' expected 2-4 arguments");
    if (typeof target !== "object") die("'extendObservable' expects an object as first argument");
    if (isObservableMap(target)) die("'extendObservable' should not be used on maps, use map.merge instead");
    if (!isPlainObject(properties)) die("'extendObservabe' only accepts plain objects as second argument");
    if (isObservable(properties) || isObservable(annotations)) die("Extending an object with another observable (object) is not supported");
  } // Pull descriptors first, so we don't have to deal with props added by administration ($mobx)


  var descriptors = getOwnPropertyDescriptors(properties);
  var adm = asObservableObject(target, options)[$mobx];
  startBatch();

  try {
    ownKeys(descriptors).forEach(function (key) {
      adm.extend_(key, descriptors[key], // must pass "undefined" for { key: undefined }
      !annotations ? true : key in annotations ? annotations[key] : true);
    });
  } finally {
    endBatch();
  }

  return target;
}

function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}

function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0) result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  return result;
}

function getObserverTree(thing, property) {
  return nodeToObserverTree(getAtom(thing, property));
}

function nodeToObserverTree(node) {
  var result = {
    name: node.name_
  };
  if (hasObservers(node)) result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);
  return result;
}

function unique(list) {
  return Array.from(new Set(list));
}

var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = /*#__PURE__*/Object.create(Error.prototype);
function isFlowCancellationError(error) {
  return error instanceof FlowCancellationError;
}
var flowAnnotation = /*#__PURE__*/createFlowAnnotation("flow");
var flowBoundAnnotation = /*#__PURE__*/createFlowAnnotation("flow.bound", {
  bound: true
});
var flow = /*#__PURE__*/Object.assign(function flow(arg1, arg2) {
  // @flow
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  } // flow(fn)


  if ( arguments.length !== 1) die("Flow expects single argument with generator function");
  var generator = arg1;
  var name = generator.name || "<unnamed flow>"; // Implementation based on https://github.com/tj/co/blob/master/index.js

  var res = function res() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = undefined;
    var promise = new Promise(function (resolve, reject) {
      var stepId = 0;
      rejector = reject;

      function onFulfilled(res) {
        pendingPromise = undefined;
        var ret;

        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res);
        } catch (e) {
          return reject(e);
        }

        next(ret);
      }

      function onRejected(err) {
        pendingPromise = undefined;
        var ret;

        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e) {
          return reject(e);
        }

        next(ret);
      }

      function next(ret) {
        if (isFunction(ret == null ? void 0 : ret.then)) {
          // an async iterator
          ret.then(next, reject);
          return;
        }

        if (ret.done) return resolve(ret.value);
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }

      onFulfilled(undefined); // kick off the process
    });
    promise.cancel = action(name + " - runid: " + runId + " - cancel", function () {
      try {
        if (pendingPromise) cancelPromise(pendingPromise); // Finally block can return (or yield) stuff..

        var _res = gen["return"](undefined); // eat anything that promise would do, it's cancelled!


        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop, noop);
        cancelPromise(yieldedPromise); // maybe it can be cancelled :)
        // reject our original promise

        rejector(new FlowCancellationError());
      } catch (e) {
        rejector(e); // there could be a throwing finally block
      }
    });
    return promise;
  };

  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow.bound = /*#__PURE__*/createDecoratorAnnotation(flowBoundAnnotation);

function cancelPromise(promise) {
  if (isFunction(promise.cancel)) promise.cancel();
}

function flowResult(result) {
  return result; // just tricking TypeScript :)
}
function isFlow(fn) {
  return (fn == null ? void 0 : fn.isMobXFlow) === true;
}

function interceptReads(thing, propOrHandler, handler) {
  var target;

  if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
    target = getAdministration(thing);
  } else if (isObservableObject(thing)) {
    if ( !isStringish(propOrHandler)) return die("InterceptReads can only be used with a specific property, not with an object in general");
    target = getAdministration(thing, propOrHandler);
  } else {
    return die("Expected observable map, object or array as first array");
  }

  if ( target.dehancer !== undefined) return die("An intercept reader was already established");
  target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
  return function () {
    target.dehancer = undefined;
  };
}

function intercept(thing, propOrHandler, handler) {
  if (isFunction(handler)) return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);
}

function interceptInterceptable(thing, handler) {
  return getAdministration(thing).intercept_(handler);
}

function interceptProperty(thing, property, handler) {
  return getAdministration(thing, property).intercept_(handler);
}

function _isComputed(value, property) {
  if (property !== undefined) {
    if (isObservableObject(value) === false) return false;
    if (!value[$mobx].values_.has(property)) return false;
    var atom = getAtom(value, property);
    return isComputedValue(atom);
  }

  return isComputedValue(value);
}
function isComputed(value) {
  if ( arguments.length > 1) return die("isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property");
  return _isComputed(value);
}
function isComputedProp(value, propName) {
  if ( !isStringish(propName)) return die("isComputed expected a property name as second argument");
  return _isComputed(value, propName);
}

function _isObservable(value, property) {
  if (!value) return false;

  if (property !== undefined) {
    if ( (isObservableMap(value) || isObservableArray(value))) return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");

    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }

    return false;
  } // For first check, see #701


  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}

function isObservable(value) {
  if ( arguments.length !== 1) die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  return _isObservable(value);
}
function isObservableProp(value, propName) {
  if ( !isStringish(propName)) return die("expected a property name as second argument");
  return _isObservable(value, propName);
}

function keys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].keys_();
  }

  if (isObservableMap(obj) || isObservableSet(obj)) {
    return Array.from(obj.keys());
  }

  if (isObservableArray(obj)) {
    return obj.map(function (_, index) {
      return index;
    });
  }

  die(5);
}
function values(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return obj[key];
    });
  }

  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return obj.get(key);
    });
  }

  if (isObservableSet(obj)) {
    return Array.from(obj.values());
  }

  if (isObservableArray(obj)) {
    return obj.slice();
  }

  die(6);
}
function entries(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj[key]];
    });
  }

  if (isObservableMap(obj)) {
    return keys(obj).map(function (key) {
      return [key, obj.get(key)];
    });
  }

  if (isObservableSet(obj)) {
    return Array.from(obj.entries());
  }

  if (isObservableArray(obj)) {
    return obj.map(function (key, index) {
      return [index, key];
    });
  }

  die(7);
}
function set(obj, key, value) {
  if (arguments.length === 2 && !isObservableSet(obj)) {
    startBatch();
    var _values = key;

    try {
      for (var _key in _values) {
        set(obj, _key, _values[_key]);
      }
    } finally {
      endBatch();
    }

    return;
  }

  if (isObservableObject(obj)) {
    obj[$mobx].set_(key, value);
  } else if (isObservableMap(obj)) {
    obj.set(key, value);
  } else if (isObservableSet(obj)) {
    obj.add(key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") key = parseInt(key, 10);
    if (key < 0) die("Invalid index: '" + key + "'");
    startBatch();
    if (key >= obj.length) obj.length = key + 1;
    obj[key] = value;
    endBatch();
  } else die(8);
}
function remove(obj, key) {
  if (isObservableObject(obj)) {
    obj[$mobx].delete_(key);
  } else if (isObservableMap(obj)) {
    obj["delete"](key);
  } else if (isObservableSet(obj)) {
    obj["delete"](key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number") key = parseInt(key, 10);
    obj.splice(key, 1);
  } else {
    die(9);
  }
}
function has(obj, key) {
  if (isObservableObject(obj)) {
    return obj[$mobx].has_(key);
  } else if (isObservableMap(obj)) {
    return obj.has(key);
  } else if (isObservableSet(obj)) {
    return obj.has(key);
  } else if (isObservableArray(obj)) {
    return key >= 0 && key < obj.length;
  }

  die(10);
}
function get(obj, key) {
  if (!has(obj, key)) return undefined;

  if (isObservableObject(obj)) {
    return obj[$mobx].get_(key);
  } else if (isObservableMap(obj)) {
    return obj.get(key);
  } else if (isObservableArray(obj)) {
    return obj[key];
  }

  die(11);
}
function apiDefineProperty(obj, key, descriptor) {
  if (isObservableObject(obj)) {
    return obj[$mobx].defineProperty_(key, descriptor);
  }

  die(39);
}
function apiOwnKeys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].ownKeys_();
  }

  die(38);
}

function observe(thing, propOrCb, cbOrFire, fireImmediately) {
  if (isFunction(cbOrFire)) return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);
}

function observeObservable(thing, listener, fireImmediately) {
  return getAdministration(thing).observe_(listener, fireImmediately);
}

function observeObservableProperty(thing, property, listener, fireImmediately) {
  return getAdministration(thing, property).observe_(listener, fireImmediately);
}

function cache(map, key, value) {
  map.set(key, value);
  return value;
}

function toJSHelper(source, __alreadySeen) {
  if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source)) return source;
  if (isObservableValue(source) || isComputedValue(source)) return toJSHelper(source.get(), __alreadySeen);

  if (__alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }

  if (isObservableArray(source)) {
    var res = cache(__alreadySeen, source, new Array(source.length));
    source.forEach(function (value, idx) {
      res[idx] = toJSHelper(value, __alreadySeen);
    });
    return res;
  }

  if (isObservableSet(source)) {
    var _res = cache(__alreadySeen, source, new Set());

    source.forEach(function (value) {
      _res.add(toJSHelper(value, __alreadySeen));
    });
    return _res;
  }

  if (isObservableMap(source)) {
    var _res2 = cache(__alreadySeen, source, new Map());

    source.forEach(function (value, key) {
      _res2.set(key, toJSHelper(value, __alreadySeen));
    });
    return _res2;
  } else {
    // must be observable object
    var _res3 = cache(__alreadySeen, source, {});

    apiOwnKeys(source).forEach(function (key) {
      if (objectPrototype.propertyIsEnumerable.call(source, key)) {
        _res3[key] = toJSHelper(source[key], __alreadySeen);
      }
    });
    return _res3;
  }
}
/**
 * Basically, a deep clone, so that no reactive property will exist anymore.
 */


function toJS(source, options) {
  if ( options) die("toJS no longer supports options");
  return toJSHelper(source, new Map());
}

function trace() {
  var enterBreakPoint = false;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (typeof args[args.length - 1] === "boolean") enterBreakPoint = args.pop();
  var derivation = getAtomFromArgs(args);

  if (!derivation) {
    return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }

  if (derivation.isTracing_ === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
  }

  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}

function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;

    case 1:
      return getAtom(args[0]);

    case 2:
      return getAtom(args[0], args[1]);
  }
}

/**
 * During a transaction no views are updated until the end of the transaction.
 * The transaction will be run synchronously nonetheless.
 *
 * @param action a function that updates some reactive state
 * @returns any value that was returned by the 'action' parameter.
 */

function transaction(action, thisArg) {
  if (thisArg === void 0) {
    thisArg = undefined;
  }

  startBatch();

  try {
    return action.apply(thisArg);
  } finally {
    endBatch();
  }
}

function when(predicate, arg1, arg2) {
  if (arguments.length === 1 || arg1 && typeof arg1 === "object") return whenPromise(predicate, arg1);
  return _when(predicate, arg1, arg2 || {});
}

function _when(predicate, effect, opts) {
  var timeoutHandle;

  if (typeof opts.timeout === "number") {
    var error = new Error("WHEN_TIMEOUT");
    timeoutHandle = setTimeout(function () {
      if (!disposer[$mobx].isDisposed_) {
        disposer();
        if (opts.onError) opts.onError(error);else throw error;
      }
    }, opts.timeout);
  }

  opts.name =  opts.name || "When@" + getNextId() ;
  var effectAction = createAction( opts.name + "-effect" , effect); // eslint-disable-next-line

  var disposer = autorun(function (r) {
    // predicate should not change state
    var cond = allowStateChanges(false, predicate);

    if (cond) {
      r.dispose();
      if (timeoutHandle) clearTimeout(timeoutHandle);
      effectAction();
    }
  }, opts);
  return disposer;
}

function whenPromise(predicate, opts) {
  if ( opts && opts.onError) return die("the options 'onError' and 'promise' cannot be combined");
  var cancel;
  var res = new Promise(function (resolve, reject) {
    var disposer = _when(predicate, resolve, _extends({}, opts, {
      onError: reject
    }));

    cancel = function cancel() {
      disposer();
      reject("WHEN_CANCELLED");
    };
  });
  res.cancel = cancel;
  return res;
}

function getAdm(target) {
  return target[$mobx];
} // Optimization: we don't need the intermediate objects and could have a completely custom administration for DynamicObjects,
// and skip either the internal values map, or the base object with its property descriptors!


var objectProxyTraps = {
  has: function has(target, name) {
    if ( globalState.trackingDerivation) warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
    return getAdm(target).has_(name);
  },
  get: function get(target, name) {
    return getAdm(target).get_(name);
  },
  set: function set(target, name, value) {
    var _getAdm$set_;

    if (!isStringish(name)) return false;

    if ( !getAdm(target).values_.has(name)) {
      warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
    } // null (intercepted) -> true (success)


    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name) {
    var _getAdm$delete_;

    {
      warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
    }

    if (!isStringish(name)) return false; // null (intercepted) -> true (success)

    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty(target, name, descriptor) {
    var _getAdm$definePropert;

    {
      warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
    } // null (intercepted) -> true (success)


    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys(target) {
    if ( globalState.trackingDerivation) warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options) {
  var _target$$mobx, _target$$mobx$proxy_;

  assertProxies();
  target = asObservableObject(target, options);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}

function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function () {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) interceptors.splice(idx, 1);
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();

  try {
    // Interceptor can modify the array, copy it to avoid concurrent modification, see #1950
    var interceptors = [].concat(interceptable.interceptors_ || []);

    for (var i = 0, l = interceptors.length; i < l; i++) {
      change = interceptors[i](change);
      if (change && !change.type) die(14);
      if (!change) break;
    }

    return change;
  } finally {
    untrackedEnd(prevU);
  }
}

function hasListeners(listenable) {
  return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function () {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) listeners.splice(idx, 1);
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) return;
  listeners = listeners.slice();

  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](change);
  }

  untrackedEnd(prevU);
}

function makeObservable(target, annotations, options) {
  var adm = asObservableObject(target, options)[$mobx];
  startBatch();

  try {
    var _annotations;

    // Default to decorators
    (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target); // Annotate

    ownKeys(annotations).forEach(function (key) {
      return adm.make_(key, annotations[key]);
    });
  } finally {
    endBatch();
  }

  return target;
} // proto[keysSymbol] = new Set<PropertyKey>()

var keysSymbol = /*#__PURE__*/Symbol("mobx-keys");
function makeAutoObservable(target, overrides, options) {
  {
    if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target))) die("'makeAutoObservable' can only be used for classes that don't have a superclass");
    if (isObservableObject(target)) die("makeAutoObservable can only be used on objects not already made observable");
  } // Optimization: avoid visiting protos
  // Assumes that annotation.make_/.extend_ works the same for plain objects


  if (isPlainObject(target)) {
    return extendObservable(target, target, overrides, options);
  }

  var adm = asObservableObject(target, options)[$mobx]; // Optimization: cache keys on proto
  // Assumes makeAutoObservable can be called only once per object and can't be used in subclass

  if (!target[keysSymbol]) {
    var proto = Object.getPrototypeOf(target);
    var keys = new Set([].concat(ownKeys(target), ownKeys(proto)));
    keys["delete"]("constructor");
    keys["delete"]($mobx);
    addHiddenProp(proto, keysSymbol, keys);
  }

  startBatch();

  try {
    target[keysSymbol].forEach(function (key) {
      return adm.make_(key, // must pass "undefined" for { key: undefined }
      !overrides ? true : key in overrides ? overrides[key] : true);
    });
  } finally {
    endBatch();
  }

  return target;
}

var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 10000; // See e.g. https://github.com/mobxjs/mobx/issues/859

var arrayTraps = {
  get: function get(target, name) {
    var adm = target[$mobx];
    if (name === $mobx) return adm;
    if (name === "length") return adm.getArrayLength_();

    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }

    if (hasProp(arrayExtensions, name)) {
      return arrayExtensions[name];
    }

    return target[name];
  },
  set: function set(target, name, value) {
    var adm = target[$mobx];

    if (name === "length") {
      adm.setArrayLength_(value);
    }

    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      // numeric string
      adm.set_(parseInt(name), value);
    }

    return true;
  },
  preventExtensions: function preventExtensions() {
    die(15);
  }
};
var ObservableArrayAdministration = /*#__PURE__*/function () {
  // this is the prop that gets proxied, so can't replace it!
  function ObservableArrayAdministration(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name =  "ObservableArray@" + getNextId() ;
    }

    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name);

    this.enhancer_ = function (newV, oldV) {
      return enhancer(newV, oldV,  name + "[..]" );
    };
  }

  var _proto = ObservableArrayAdministration.prototype;

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) return this.dehancer(value);
    return value;
  };

  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== undefined && values.length > 0) return values.map(this.dehancer);
    return values;
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }

    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }

    return registerListener(this, listener);
  };

  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };

  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || newLength < 0) die("Out of range: " + newLength);
    var currentLength = this.values_.length;
    if (newLength === currentLength) return;else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);

      for (var i = 0; i < newLength - currentLength; i++) {
        newItems[i] = undefined;
      } // No Array.fill everywhere...


      this.spliceWithArray_(currentLength, 0, newItems);
    } else this.spliceWithArray_(newLength, currentLength - newLength);
  };

  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_) die(16);
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0) reserveArrayBuffer(oldLength + delta + 1);
  };

  _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {
    var _this = this;

    checkIfStateModificationsAreAllowed(this.atom_);
    var length = this.values_.length;
    if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);
    if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));
    if (newItems === undefined) newItems = EMPTY_ARRAY;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index: index,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) return EMPTY_ARRAY;
      deleteCount = change.removedCount;
      newItems = change.added;
    }

    newItems = newItems.length === 0 ? newItems : newItems.map(function (v) {
      return _this.enhancer_(v, undefined);
    });

    if (this.legacyMode_ || "development" !== "production") {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length, lengthDelta); // checks if internal array wasn't modified
    }

    var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice_(index, newItems, res);
    return this.dehanceValues_(res);
  };

  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;

      return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index, index + deleteCount);
      var oldItems = this.values_.slice(index + deleteCount);
      this.values_.length = index + newItems.length - deleteCount;

      for (var i = 0; i < newItems.length; i++) {
        this.values_[index + i] = newItems[i];
      }

      for (var _i = 0; _i < oldItems.length; _i++) {
        this.values_[index + newItems.length + _i] = oldItems[_i];
      }

      return res;
    }
  };

  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index: index,
      newValue: newValue,
      oldValue: oldValue
    } : null; // The reason why this is on right hand side here (and not above), is this way the uglifier will drop it, but it won't
    // cause any runtime overhead in development mode without NODE_ENV set, unless spying is enabled

    if ( notifySpy) spyReportStart(change);
    this.atom_.reportChanged();
    if (notify) notifyListeners(this, change);
    if ( notifySpy) spyReportEnd();
  };

  _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index: index,
      removed: removed,
      added: added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    if ( notifySpy) spyReportStart(change);
    this.atom_.reportChanged(); // conform: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe

    if (notify) notifyListeners(this, change);
    if ( notifySpy) spyReportEnd();
  };

  _proto.get_ = function get_(index) {
    if (index < this.values_.length) {
      this.atom_.reportObserved();
      return this.dehanceValue_(this.values_[index]);
    }

    console.warn( "[mobx] Out of bounds read: " + index );
  };

  _proto.set_ = function set_(index, newValue) {
    var values = this.values_;

    if (index < values.length) {
      // update at index in range
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values[index];

      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          index: index,
          newValue: newValue
        });
        if (!change) return;
        newValue = change.newValue;
      }

      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;

      if (changed) {
        values[index] = newValue;
        this.notifyArrayChildUpdate_(index, newValue, oldValue);
      }
    } else if (index === values.length) {
      // add a new item
      this.spliceWithArray_(index, 0, [newValue]);
    } else {
      // out of bounds
      die(17, index, values.length);
    }
  };

  return ObservableArrayAdministration;
}();
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name =  "ObservableArray@" + getNextId() ;
  }

  if (owned === void 0) {
    owned = false;
  }

  assertProxies();
  var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
  addHiddenFinalProp(adm.values_, $mobx, adm);
  var proxy = new Proxy(adm.values_, arrayTraps);
  adm.proxy_ = proxy;

  if (initialValues && initialValues.length) {
    var prev = allowStateChangesStart(true);
    adm.spliceWithArray_(0, 0, initialValues);
    allowStateChangesEnd(prev);
  }

  return proxy;
} // eslint-disable-next-line

var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  // Used by JSON.stringify
  toJSON: function toJSON() {
    return this.slice();
  },

  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function splice(index, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }

    var adm = this[$mobx];

    switch (arguments.length) {
      case 0:
        return [];

      case 1:
        return adm.spliceWithArray_(index);

      case 2:
        return adm.spliceWithArray_(index, deleteCount);
    }

    return adm.spliceWithArray_(index, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];

    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }

    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];

    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }

    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    // reverse by default mutates in place before returning the result
    // which makes it both a 'derivation' and a 'mutation'.
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }

    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    // sort by default mutates in place before returning the result
    // which goes against all good practices. Let's not change the array in place!
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }

    var copy = this.slice();
    copy.sort.apply(copy, arguments);
    this.replace(copy);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);

    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }

    return false;
  }
};
/**
 * Wrap function from prototype
 * Without this, everything works as well, but this works
 * faster as everything works on unproxied values
 */

addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc); // map

addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc); // reduce

addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);

function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
} // Report and delegate to dehanced array


function simpleFunc(funcName) {
  return function () {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
} // Make sure callbacks recieve correct array arg #2326


function mapLikeFunc(funcName) {
  return function (callback, thisArg) {
    var _this2 = this;

    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function (element, index) {
      return callback.call(thisArg, element, index, _this2);
    });
  };
} // Make sure callbacks recieve correct array arg #2326


function reduceLikeFunc(funcName) {
  return function () {
    var _this3 = this;

    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_); // #2432 - reduce behavior depends on arguments.length

    var callback = arguments[0];

    arguments[0] = function (accumulator, currentValue, index) {
      return callback(accumulator, currentValue, index, _this3);
    };

    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}

var isObservableArrayAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}

var _Symbol$iterator, _Symbol$toStringTag;
var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete"; // just extend Map? See also https://gist.github.com/nestharus/13b4d74f2ef4a2f4357dbd3fc23c1e54
// But: https://github.com/mobxjs/mobx/issues/1556

_Symbol$iterator = Symbol.iterator;
_Symbol$toStringTag = Symbol.toStringTag;
var ObservableMap = /*#__PURE__*/function () {
  // hasMap, not hashMap >-).
  function ObservableMap(initialData, enhancer_, name_) {
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }

    if (name_ === void 0) {
      name_ =  "ObservableMap@" + getNextId() ;
    }

    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;

    if (!isFunction(Map)) {
      die(18);
    }

    this.keysAtom_ = createAtom( this.name_ + ".keys()" );
    this.data_ = new Map();
    this.hasMap_ = new Map();
    this.merge(initialData);
  }

  var _proto = ObservableMap.prototype;

  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };

  _proto.has = function has(key) {
    var _this = this;

    if (!globalState.trackingDerivation) return this.has_(key);
    var entry = this.hasMap_.get(key);

    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer,  this.name_ + "." + stringifyKey(key) + "?" , false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function () {
        return _this.hasMap_["delete"](key);
      });
    }

    return entry.get();
  };

  _proto.set = function set(key, value) {
    var hasKey = this.has_(key);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change) return this;
      value = change.newValue;
    }

    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }

    return this;
  };

  _proto["delete"] = function _delete(key) {
    var _this2 = this;

    checkIfStateModificationsAreAllowed(this.keysAtom_);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change) return false;
    }

    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);

      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;

      if ( notifySpy) spyReportStart(_change);
      transaction(function () {
        _this2.keysAtom_.reportChanged();

        _this2.updateHasMapEntry_(key, false);

        var observable = _this2.data_.get(key);

        observable.setNewValue_(undefined);

        _this2.data_["delete"](key);
      });
      if (notify) notifyListeners(this, _change);
      if ( notifySpy) spyReportEnd();
      return true;
    }

    return false;
  };

  _proto.updateHasMapEntry_ = function updateHasMapEntry_(key, value) {
    var entry = this.hasMap_.get(key);

    if (entry) {
      entry.setNewValue_(value);
    }
  };

  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable = this.data_.get(key);
    newValue = observable.prepareNewValue_(newValue);

    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable.value_,
        name: key,
        newValue: newValue
      } : null;
      if ( notifySpy) spyReportStart(change);
      observable.setNewValue_(newValue);
      if (notify) notifyListeners(this, change);
      if ( notifySpy) spyReportEnd();
    }
  };

  _proto.addValue_ = function addValue_(key, newValue) {
    var _this3 = this;

    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function () {
      var observable = new ObservableValue(newValue, _this3.enhancer_,  _this3.name_ + "." + stringifyKey(key) , false);

      _this3.data_.set(key, observable);

      newValue = observable.value_; // value might have been changed

      _this3.updateHasMapEntry_(key, true);

      _this3.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue: newValue
    } : null;
    if ( notifySpy) spyReportStart(change);
    if (notify) notifyListeners(this, change);
    if ( notifySpy) spyReportEnd();
  };

  _proto.get = function get(key) {
    if (this.has(key)) return this.dehanceValue_(this.data_.get(key).get());
    return this.dehanceValue_(undefined);
  };

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }

    return value;
  };

  _proto.keys = function keys() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };

  _proto.values = function values() {
    var self = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next = keys.next(),
            done = _keys$next.done,
            value = _keys$next.value;

        return {
          done: done,
          value: done ? undefined : self.get(value)
        };
      }
    });
  };

  _proto.entries = function entries() {
    var self = this;
    var keys = this.keys();
    return makeIterable({
      next: function next() {
        var _keys$next2 = keys.next(),
            done = _keys$next2.done,
            value = _keys$next2.value;

        return {
          done: done,
          value: done ? undefined : [value, self.get(value)]
        };
      }
    });
  };

  _proto[_Symbol$iterator] = function () {
    return this.entries();
  };

  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          key = _step$value[0],
          value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  }
  /** Merge another object into this object, returns this. */
  ;

  _proto.merge = function merge(other) {
    var _this4 = this;

    if (isObservableMap(other)) {
      other = new Map(other);
    }

    transaction(function () {
      if (isPlainObject(other)) getPlainObjectKeys(other).forEach(function (key) {
        return _this4.set(key, other[key]);
      });else if (Array.isArray(other)) other.forEach(function (_ref) {
        var key = _ref[0],
            value = _ref[1];
        return _this4.set(key, value);
      });else if (isES6Map(other)) {
        if (other.constructor !== Map) die(19, other);
        other.forEach(function (value, key) {
          return _this4.set(key, value);
        });
      } else if (other !== null && other !== undefined) die(20, other);
    });
    return this;
  };

  _proto.clear = function clear() {
    var _this5 = this;

    transaction(function () {
      untracked(function () {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this5.keys()), _step2; !(_step2 = _iterator2()).done;) {
          var key = _step2.value;

          _this5["delete"](key);
        }
      });
    });
  };

  _proto.replace = function replace(values) {
    var _this6 = this;

    // Implementation requirements:
    // - respect ordering of replacement map
    // - allow interceptors to run and potentially prevent individual operations
    // - don't recreate observables that already exist in original map (so we don't destroy existing subscriptions)
    // - don't _keysAtom.reportChanged if the keys of resulting map are indentical (order matters!)
    // - note that result map may differ from replacement map due to the interceptors
    transaction(function () {
      // Convert to map so we can do quick key lookups
      var replacementMap = convertToMap(values);
      var orderedData = new Map(); // Used for optimization

      var keysReportChangedCalled = false; // Delete keys that don't exist in replacement map
      // if the key deletion is prevented by interceptor
      // add entry at the beginning of the result map

      for (var _iterator3 = _createForOfIteratorHelperLoose(_this6.data_.keys()), _step3; !(_step3 = _iterator3()).done;) {
        var key = _step3.value;

        // Concurrently iterating/deleting keys
        // iterator should handle this correctly
        if (!replacementMap.has(key)) {
          var deleted = _this6["delete"](key); // Was the key removed?


          if (deleted) {
            // _keysAtom.reportChanged() was already called
            keysReportChangedCalled = true;
          } else {
            // Delete prevented by interceptor
            var value = _this6.data_.get(key);

            orderedData.set(key, value);
          }
        }
      } // Merge entries


      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done;) {
        var _step4$value = _step4.value,
            _key = _step4$value[0],
            _value = _step4$value[1];

        // We will want to know whether a new key is added
        var keyExisted = _this6.data_.has(_key); // Add or update value


        _this6.set(_key, _value); // The addition could have been prevent by interceptor


        if (_this6.data_.has(_key)) {
          // The update could have been prevented by interceptor
          // and also we want to preserve existing values
          // so use value from _data map (instead of replacement map)
          var _value2 = _this6.data_.get(_key);

          orderedData.set(_key, _value2); // Was a new key added?

          if (!keyExisted) {
            // _keysAtom.reportChanged() was already called
            keysReportChangedCalled = true;
          }
        }
      } // Check for possible key order change


      if (!keysReportChangedCalled) {
        if (_this6.data_.size !== orderedData.size) {
          // If size differs, keys are definitely modified
          _this6.keysAtom_.reportChanged();
        } else {
          var iter1 = _this6.data_.keys();

          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();

          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this6.keysAtom_.reportChanged();

              break;
            }

            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      } // Use correctly ordered map


      _this6.data_ = orderedData;
    });
    return this;
  };

  _proto.toString = function toString() {
    return "[object ObservableMap]";
  };

  _proto.toJSON = function toJSON() {
    return Array.from(this);
  };

  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if ( fireImmediately === true) die("`observe` doesn't support fireImmediately=true in combination with maps.");
    return registerListener(this, listener);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _createClass(ObservableMap, [{
    key: "size",
    get: function get() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return "Map";
    }
  }]);

  return ObservableMap;
}(); // eslint-disable-next-line

var isObservableMap = /*#__PURE__*/createInstanceofPredicate("ObservableMap", ObservableMap);

function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map = new Map();

    for (var key in dataStructure) {
      map.set(key, dataStructure[key]);
    }

    return map;
  } else {
    return die(21, dataStructure);
  }
}

var _Symbol$iterator$1, _Symbol$toStringTag$1;
var ObservableSetMarker = {};
_Symbol$iterator$1 = Symbol.iterator;
_Symbol$toStringTag$1 = Symbol.toStringTag;
var ObservableSet = /*#__PURE__*/function () {
  function ObservableSet(initialData, enhancer, name_) {
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }

    if (name_ === void 0) {
      name_ =  "ObservableSet@" + getNextId() ;
    }

    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;

    if (!isFunction(Set)) {
      die(22);
    }

    this.atom_ = createAtom(this.name_);

    this.enhancer_ = function (newV, oldV) {
      return enhancer(newV, oldV, name_);
    };

    if (initialData) {
      this.replace(initialData);
    }
  }

  var _proto = ObservableSet.prototype;

  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== undefined) {
      return this.dehancer(value);
    }

    return value;
  };

  _proto.clear = function clear() {
    var _this = this;

    transaction(function () {
      untracked(function () {
        for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done;) {
          var value = _step.value;

          _this["delete"](value);
        }
      });
    });
  };

  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done;) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };

  _proto.add = function add(value) {
    var _this2 = this;

    checkIfStateModificationsAreAllowed(this.atom_);

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change) return this; // ideally, value = change.value would be done here, so that values can be
      // changed by interceptor. Same applies for other Set and Map api's.
    }

    if (!this.has(value)) {
      transaction(function () {
        _this2.data_.add(_this2.enhancer_(value, undefined));

        _this2.atom_.reportChanged();
      });
      var notifySpy =  isSpyEnabled();
      var notify = hasListeners(this);

      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;

      if (notifySpy && "development" !== "production") spyReportStart(_change);
      if (notify) notifyListeners(this, _change);
      if (notifySpy && "development" !== "production") spyReportEnd();
    }

    return this;
  };

  _proto["delete"] = function _delete(value) {
    var _this3 = this;

    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change) return false;
    }

    if (this.has(value)) {
      var notifySpy =  isSpyEnabled();
      var notify = hasListeners(this);

      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;

      if (notifySpy && "development" !== "production") spyReportStart(_change2);
      transaction(function () {
        _this3.atom_.reportChanged();

        _this3.data_["delete"](value);
      });
      if (notify) notifyListeners(this, _change2);
      if (notifySpy && "development" !== "production") spyReportEnd();
      return true;
    }

    return false;
  };

  _proto.has = function has(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };

  _proto.entries = function entries() {
    var nextIndex = 0;
    var keys = Array.from(this.keys());
    var values = Array.from(this.values());
    return makeIterable({
      next: function next() {
        var index = nextIndex;
        nextIndex += 1;
        return index < values.length ? {
          value: [keys[index], values[index]],
          done: false
        } : {
          done: true
        };
      }
    });
  };

  _proto.keys = function keys() {
    return this.values();
  };

  _proto.values = function values() {
    this.atom_.reportObserved();
    var self = this;
    var nextIndex = 0;
    var observableValues = Array.from(this.data_.values());
    return makeIterable({
      next: function next() {
        return nextIndex < observableValues.length ? {
          value: self.dehanceValue_(observableValues[nextIndex++]),
          done: false
        } : {
          done: true
        };
      }
    });
  };

  _proto.replace = function replace(other) {
    var _this4 = this;

    if (isObservableSet(other)) {
      other = new Set(other);
    }

    transaction(function () {
      if (Array.isArray(other)) {
        _this4.clear();

        other.forEach(function (value) {
          return _this4.add(value);
        });
      } else if (isES6Set(other)) {
        _this4.clear();

        other.forEach(function (value) {
          return _this4.add(value);
        });
      } else if (other !== null && other !== undefined) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };

  _proto.observe_ = function observe_(listener, fireImmediately) {
    // ... 'fireImmediately' could also be true?
    if ( fireImmediately === true) die("`observe` doesn't support fireImmediately=true in combination with sets.");
    return registerListener(this, listener);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.toJSON = function toJSON() {
    return Array.from(this);
  };

  _proto.toString = function toString() {
    return "[object ObservableSet]";
  };

  _proto[_Symbol$iterator$1] = function () {
    return this.values();
  };

  _createClass(ObservableSet, [{
    key: "size",
    get: function get() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: _Symbol$toStringTag$1,
    get: function get() {
      return "Set";
    }
  }]);

  return ObservableSet;
}(); // eslint-disable-next-line

var isObservableSet = /*#__PURE__*/createInstanceofPredicate("ObservableSet", ObservableSet);

var descriptorCache = /*#__PURE__*/Object.create(null);
var REMOVE = "remove";
var ObservableObjectAdministration = /*#__PURE__*/function () {
  function ObservableObjectAdministration(target_, values_, name_, // Used anytime annotation is not explicitely provided
  defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = new Map();
    }

    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }

    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom( this.name_ + ".keys" ); // Optimization: we use this frequently

    this.isPlainObject_ = isPlainObject(this.target_);

    if ( !isAnnotation(this.defaultAnnotation_)) {
      die("defaultAnnotation must be valid annotation");
    }

    {
      // Prepare structure for tracking which fields were already annotated
      this.appliedAnnotations_ = {};
    }
  }

  var _proto = ObservableObjectAdministration.prototype;

  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };

  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable = this.values_.get(key);

    if (observable instanceof ComputedValue) {
      observable.set(newValue);
      return true;
    } // intercept


    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: newValue
      });
      if (!change) return null;
      newValue = change.newValue;
    }

    newValue = observable.prepareNewValue_(newValue); // notify spy & observers

    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy =  isSpyEnabled();

      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable.value_,
        name: key,
        newValue: newValue
      } : null;

      if ( notifySpy) spyReportStart(_change);
      observable.setNewValue_(newValue);
      if (notify) notifyListeners(this, _change);
      if ( notifySpy) spyReportEnd();
    }

    return true;
  };

  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      // Key doesn't exist yet, subscribe for it in case it's added later
      this.has_(key);
    }

    return this.target_[key];
  }
  /**
   * @param {PropertyKey} key
   * @param {any} value
   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    // Don't use .has(key) - we care about own
    if (hasProp(this.target_, key)) {
      // Existing prop
      if (this.values_.has(key)) {
        // Observable (can be intercepted)
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        // Non-observable - proxy
        return Reflect.set(this.target_, key, value);
      } else {
        // Non-observable
        this.target_[key] = value;
        return true;
      }
    } else {
      // New prop
      return this.extend_(key, {
        value: value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  } // Trap for "in"
  ;

  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      // Skip key subscription outside derivation
      return key in this.target_;
    }

    this.pendingKeys_ || (this.pendingKeys_ = new Map());
    var entry = this.pendingKeys_.get(key);

    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer,  this.name_ + "." + stringifyKey(key) + "?" , false);
      this.pendingKeys_.set(key, entry);
    }

    return entry.get();
  }
  /**
   * @param {PropertyKey} key
   * @param {Annotation|boolean} annotation true - use default annotation, false - ignore prop
   */
  ;

  _proto.make_ = function make_(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }

    if (annotation === false) {
      return;
    }

    assertAnnotable(this, annotation, key);

    if (!(key in this.target_)) {
      var _this$target_$storedA;

      // Throw on missing key, except for decorators:
      // Decorator annotations are collected from whole prototype chain.
      // When called from super() some props may not exist yet.
      // However we don't have to worry about missing prop,
      // because the decorator must have been applied to something.
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) == null ? void 0 : _this$target_$storedA[key]) {
        return; // will be annotated by subclass constructor
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }

    var source = this.target_;

    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key);

      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0
        /* Cancel */
        ) return;
        if (outcome === 1
        /* Break */
        ) break;
      }

      source = Object.getPrototypeOf(source);
    }

    recordAnnotationApplied(this, annotation, key);
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {Annotation|boolean} annotation true - use default annotation, false - copy as is
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }

    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }

    assertAnnotable(this, annotation, key);
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);

    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }

    return outcome;
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change) return null;
        var newValue = change.newValue;

        if (descriptor.value !== newValue) {
          descriptor = _extends({}, descriptor, {
            value: newValue
          });
        }
      } // Define


      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      } // Notify


      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }

    return true;
  } // If original descriptor becomes relevant, move this to annotation directly
  ;

  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change) return null;
        value = change.newValue;
      }

      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      }; // Define

      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }

      var observable = new ObservableValue(value, enhancer, "development" !== "production" ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
      this.values_.set(key, observable); // Notify (value possibly changed by ObservableValue)

      this.notifyPropertyAddition_(key, observable.value_);
    } finally {
      endBatch();
    }

    return true;
  } // If original descriptor becomes relevant, move this to annotation directly
  ;

  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    try {
      startBatch(); // Delete

      var deleteOutcome = this.delete_(key);

      if (!deleteOutcome) {
        // Failure or intercepted
        return deleteOutcome;
      } // ADD interceptor


      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: undefined
        });
        if (!change) return null;
      }

      options.name || (options.name = "development" !== "production" ? this.name_ + "." + key.toString() : "ObservableObject.key");
      options.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      }; // Define

      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }

      this.values_.set(key, new ComputedValue(options)); // Notify

      this.notifyPropertyAddition_(key, undefined);
    } finally {
      endBatch();
    }

    return true;
  }
  /**
   * @param {PropertyKey} key
   * @param {PropertyDescriptor} descriptor
   * @param {boolean} proxyTrap whether it's called from proxy trap
   * @returns {boolean|null} true on success, false on failure (proxyTrap + non-configurable), null when cancelled by interceptor
   */
  ;

  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }

    // No such prop
    if (!hasProp(this.target_, key)) {
      return true;
    } // Intercept


    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      }); // Cancelled

      if (!change) return null;
    } // Delete


    try {
      var _this$pendingKeys_, _this$pendingKeys_$ge;

      startBatch();
      var notify = hasListeners(this);
      var notifySpy = "development" !== "production" && isSpyEnabled();
      var observable = this.values_.get(key); // Value needed for spies/listeners

      var value = undefined; // Optimization: don't pull the value unless we will need it

      if (!observable && (notify || notifySpy)) {
        var _getDescriptor;

        value = (_getDescriptor = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor.value;
      } // delete prop (do first, may fail)


      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      } // Allow re-annotating this field


      if ("development" !== "production") {
        delete this.appliedAnnotations_[key];
      } // Clear observable


      if (observable) {
        this.values_["delete"](key); // for computed, value is undefined

        if (observable instanceof ObservableValue) {
          value = observable.value_;
        } // Notify: autorun(() => obj[key]), see #1796


        propagateChanged(observable);
      } // Notify "keys/entries/values" observers


      this.keysAtom_.reportChanged(); // Notify "has" observers
      // "in" as it may still exist in proto

      (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_); // Notify spies/listeners

      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if ("development" !== "production" && notifySpy) spyReportStart(_change2);
        if (notify) notifyListeners(this, _change2);
        if ("development" !== "production" && notifySpy) spyReportEnd();
      }
    } finally {
      endBatch();
    }

    return true;
  }
  /**
   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
   * for callback details
   */
  ;

  _proto.observe_ = function observe_(callback, fireImmediately) {
    if ( fireImmediately === true) die("`observe` doesn't support the fire immediately property for observable objects.");
    return registerListener(this, callback);
  };

  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };

  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2, _this$pendingKeys_2$g;

    var notify = hasListeners(this);
    var notifySpy =  isSpyEnabled();

    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if ( notifySpy) spyReportStart(change);
      if (notify) notifyListeners(this, change);
      if ( notifySpy) spyReportEnd();
    }

    (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true); // Notify "keys/entries/values" observers

    this.keysAtom_.reportChanged();
  };

  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };

  _proto.keys_ = function keys_() {
    // Returns enumerable && own, but unfortunately keysAtom will report on ANY key change.
    // There is no way to distinguish between Object.keys(object) and Reflect.ownKeys(object) - both are handled by ownKeys trap.
    // We can either over-report in Object.keys(object) or under-report in Reflect.ownKeys(object)
    // We choose to over-report in Object.keys(object), because:
    // - typically it's used with simple data objects
    // - when symbolic/non-enumerable keys are relevant Reflect.ownKeys works as expected
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };

  return ObservableObjectAdministration;
}();
function asObservableObject(target, options) {
  var _options$name;

  if ( options && isObservableObject(target)) {
    die("Options can't be provided for already observable objects.");
  }

  if (hasProp(target, $mobx)) {
    if ( !(getAdministration(target) instanceof ObservableObjectAdministration)) {
      die("Cannot convert '" + getDebugName(target) + "' into observable object:" + "\nThe target is already observable of different type." + "\nExtending builtins is not supported.");
    }

    return target;
  }

  if ( !Object.isExtensible(target)) die("Cannot make the designated object observable; it is not extensible");
  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name :  (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() ;
  var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options));
  addHiddenProp(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = /*#__PURE__*/createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);

function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}

function isObservableObject(thing) {
  if (isObject(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }

  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;

  {
    adm.appliedAnnotations_[key] = annotation;
  } // Remove applied decorator annotation so we don't try to apply it again in subclass constructor


  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];
}

function assertAnnotable(adm, annotation, key) {
  // Valid annotation
  if ( !isAnnotation(annotation)) {
    die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
  }
  /*
  // Configurable, not sealed, not frozen
  // Possibly not needed, just a little better error then the one thrown by engine.
  // Cases where this would be useful the most (subclass field initializer) are not interceptable by this.
  if (__DEV__) {
      const configurable = getDescriptor(adm.target_, key)?.configurable
      const frozen = Object.isFrozen(adm.target_)
      const sealed = Object.isSealed(adm.target_)
      if (!configurable || frozen || sealed) {
          const fieldName = `${adm.name_}.${key.toString()}`
          const requestedAnnotationType = annotation.annotationType_
          let error = `Cannot apply '${requestedAnnotationType}' to '${fieldName}':`
          if (frozen) {
              error += `\nObject is frozen.`
          }
          if (sealed) {
              error += `\nObject is sealed.`
          }
          if (!configurable) {
              error += `\nproperty is not configurable.`
              // Mention only if caused by us to avoid confusion
              if (hasProp(adm.appliedAnnotations!, key)) {
                  error += `\nTo prevent accidental re-definition of a field by a subclass, `
                  error += `all annotated fields of non-plain objects (classes) are not configurable.`
              }
          }
          die(error)
      }
  }
  */
  // Not annotated


  if ( !isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {
    var fieldName = adm.name_ + "." + key.toString();
    var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed." + "\nUse 'override' annotation for methods overriden by subclass.");
  }
}

/**
 * This array buffer contains two lists of properties, so that all arrays
 * can recycle their property definitions, which significantly improves performance of creating
 * properties on the fly.
 */

var OBSERVABLE_ARRAY_BUFFER_SIZE = 0; // Typescript workaround to make sure ObservableArray extends Array

var StubArray = function StubArray() {};

function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== undefined) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}

inherit(StubArray, Array.prototype); // Weex proto freeze protection was here,
// but it is unclear why the hack is need as MobX never changed the prototype
// anyway, so removed it in V6

var LegacyObservableArray = /*#__PURE__*/function (_StubArray) {
  _inheritsLoose(LegacyObservableArray, _StubArray);

  function LegacyObservableArray(initialValues, enhancer, name, owned) {
    var _this;

    if (name === void 0) {
      name =  "ObservableArray@" + getNextId() ;
    }

    if (owned === void 0) {
      owned = false;
    }

    _this = _StubArray.call(this) || this;
    var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
    adm.proxy_ = _assertThisInitialized(_this);
    addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);

    if (initialValues && initialValues.length) {
      var prev = allowStateChangesStart(true); // @ts-ignore

      _this.spliceWithArray(0, 0, initialValues);

      allowStateChangesEnd(prev);
    }

    return _this;
  }

  var _proto = LegacyObservableArray.prototype;

  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();

    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }

    return Array.prototype.concat.apply(this.slice(), //@ts-ignore
    arrays.map(function (a) {
      return isObservableArray(a) ? a.slice() : a;
    }));
  };

  _proto[Symbol.iterator] = function () {
    var self = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        // @ts-ignore
        return nextIndex < self.length ? {
          value: self[nextIndex++],
          done: false
        } : {
          done: true,
          value: undefined
        };
      }
    });
  };

  _createClass(LegacyObservableArray, [{
    key: "length",
    get: function get() {
      return this[$mobx].getArrayLength_();
    },
    set: function set(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return "Array";
    }
  }]);

  return LegacyObservableArray;
}(StubArray);

Object.entries(arrayExtensions).forEach(function (_ref) {
  var prop = _ref[0],
      fn = _ref[1];
  if (prop !== "concat") addHiddenProp(LegacyObservableArray.prototype, prop, fn);
});

function createArrayEntryDescriptor(index) {
  return {
    enumerable: false,
    configurable: true,
    get: function get() {
      return this[$mobx].get_(index);
    },
    set: function set(value) {
      this[$mobx].set_(index, value);
    }
  };
}

function createArrayBufferItem(index) {
  defineProperty(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
}

function reserveArrayBuffer(max) {
  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {
      createArrayBufferItem(index);
    }

    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
  }
}
reserveArrayBuffer(1000);
function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}

function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== undefined) die(23);
      return thing[$mobx].atom_;
    }

    if (isObservableSet(thing)) {
      return thing[$mobx];
    }

    if (isObservableMap(thing)) {
      if (property === undefined) return thing.keysAtom_;
      var observable = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable) die(25, property, getDebugName(thing));
      return observable;
    }

    if (isObservableObject(thing)) {
      if (!property) return die(26);

      var _observable = thing[$mobx].values_.get(property);

      if (!_observable) die(27, property, getDebugName(thing));
      return _observable;
    }

    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction(thing)) {
    if (isReaction(thing[$mobx])) {
      // disposer function
      return thing[$mobx];
    }
  }

  die(28);
}
function getAdministration(thing, property) {
  if (!thing) die(29);
  if (property !== undefined) return getAdministration(getAtom(thing, property));
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;
  if (isObservableMap(thing) || isObservableSet(thing)) return thing;
  if (thing[$mobx]) return thing[$mobx];
  die(24, thing);
}
function getDebugName(thing, property) {
  var named;

  if (property !== undefined) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    // valid for arrays as well
    named = getAtom(thing);
  }

  return named.name_;
}

var toString = objectPrototype.toString;
function deepEqual(a, b, depth) {
  if (depth === void 0) {
    depth = -1;
  }

  return eq(a, b, depth);
} // Copied from https://github.com/jashkenas/underscore/blob/5c237a7c682fb68fd5378203f0bf22dce1624854/underscore.js#L1186-L1289
// Internal recursive comparison function for `isEqual`.

function eq(a, b, depth, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) return a !== 0 || 1 / a === 1 / b; // `null` or `undefined` only equal to itself (strict comparison).

  if (a == null || b == null) return false; // `NaN`s are equivalent, but non-reflexive.

  if (a !== a) return b !== b; // Exhaust primitive checks

  var type = typeof a;
  if (!isFunction(type) && type !== "object" && typeof b != "object") return false; // Compare `[[Class]]` names.

  var className = toString.call(a);
  if (className !== toString.call(b)) return false;

  switch (className) {
    // Strings, numbers, regular expressions, dates, and booleans are compared by value.
    case "[object RegExp]": // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')

    case "[object String]":
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return "" + a === "" + b;

    case "[object Number]":
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values.

      return +a === 0 ? 1 / +a === 1 / b : +a === +b;

    case "[object Date]":
    case "[object Boolean]":
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;

    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);

    case "[object Map]":
    case "[object Set]":
      // Maps and Sets are unwrapped to arrays of entry-pairs, adding an incidental level.
      // Hide this extra level by increasing the depth.
      if (depth >= 0) {
        depth++;
      }

      break;
  } // Unwrap any wrapped objects.


  a = unwrap(a);
  b = unwrap(b);
  var areArrays = className === "[object Array]";

  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.

    var aCtor = a.constructor,
        bCtor = b.constructor;

    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
      return false;
    }
  }

  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  } // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.


  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;

  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) return bStack[length] === b;
  } // Add the first object to the stack of traversed objects.


  aStack.push(a);
  bStack.push(b); // Recursively compare objects and arrays.

  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties.

    while (length--) {
      if (!eq(a[length], b[length], depth - 1, aStack, bStack)) return false;
    }
  } else {
    // Deep compare objects.
    var keys = Object.keys(a);
    var key;
    length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality.

    if (Object.keys(b).length !== length) return false;

    while (length--) {
      // Deep compare each member
      key = keys[length];
      if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) return false;
    }
  } // Remove the first object from the stack of traversed objects.


  aStack.pop();
  bStack.pop();
  return true;
}

function unwrap(a) {
  if (isObservableArray(a)) return a.slice();
  if (isES6Map(a) || isObservableMap(a)) return Array.from(a.entries());
  if (isES6Set(a) || isObservableSet(a)) return Array.from(a.entries());
  return a;
}

function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return iterator;
}

function getSelf() {
  return this;
}

function isAnnotation(thing) {
  return (// Can be function
    thing instanceof Object && typeof thing.annotationType_ === "string" && isFunction(thing.make_) && isFunction(thing.extend_)
  );
}

/**
 * (c) Michel Weststrate 2015 - 2020
 * MIT Licensed
 *
 * Welcome to the mobx sources! To get an global overview of how MobX internally works,
 * this is a good place to start:
 * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
 *
 * Source folders:
 * ===============
 *
 * - api/     Most of the public static methods exposed by the module can be found here.
 * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
 * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
 * - utils/   Utility stuff.
 *
 */
["Symbol", "Map", "Set"].forEach(function (m) {
  var g = getGlobal();

  if (typeof g[m] === "undefined") {
    die("MobX requires global '" + m + "' to be available or polyfilled");
  }
});

if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  // See: https://github.com/andykog/mobx-devtools/
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy: spy,
    extras: {
      getDebugName: getDebugName
    },
    $mobx: $mobx
  });
}

exports.$mobx = $mobx;
exports.FlowCancellationError = FlowCancellationError;
exports.ObservableMap = ObservableMap;
exports.ObservableSet = ObservableSet;
exports.Reaction = Reaction;
exports._allowStateChanges = allowStateChanges;
exports._allowStateChangesInsideComputed = runInAction;
exports._allowStateReadsEnd = allowStateReadsEnd;
exports._allowStateReadsStart = allowStateReadsStart;
exports._autoAction = autoAction;
exports._endAction = _endAction;
exports._getAdministration = getAdministration;
exports._getGlobalState = getGlobalState;
exports._interceptReads = interceptReads;
exports._isComputingDerivation = isComputingDerivation;
exports._resetGlobalState = resetGlobalState;
exports._startAction = _startAction;
exports.action = action;
exports.autorun = autorun;
exports.comparer = comparer;
exports.computed = computed;
exports.configure = configure;
exports.createAtom = createAtom;
exports.defineProperty = apiDefineProperty;
exports.entries = entries;
exports.extendObservable = extendObservable;
exports.flow = flow;
exports.flowResult = flowResult;
exports.get = get;
exports.getAtom = getAtom;
exports.getDebugName = getDebugName;
exports.getDependencyTree = getDependencyTree;
exports.getObserverTree = getObserverTree;
exports.has = has;
exports.intercept = intercept;
exports.isAction = isAction;
exports.isBoxedObservable = isObservableValue;
exports.isComputed = isComputed;
exports.isComputedProp = isComputedProp;
exports.isFlow = isFlow;
exports.isFlowCancellationError = isFlowCancellationError;
exports.isObservable = isObservable;
exports.isObservableArray = isObservableArray;
exports.isObservableMap = isObservableMap;
exports.isObservableObject = isObservableObject;
exports.isObservableProp = isObservableProp;
exports.isObservableSet = isObservableSet;
exports.keys = keys;
exports.makeAutoObservable = makeAutoObservable;
exports.makeObservable = makeObservable;
exports.observable = observable;
exports.observe = observe;
exports.onBecomeObserved = onBecomeObserved;
exports.onBecomeUnobserved = onBecomeUnobserved;
exports.onReactionError = onReactionError;
exports.override = override;
exports.ownKeys = apiOwnKeys;
exports.reaction = reaction;
exports.remove = remove;
exports.runInAction = runInAction;
exports.set = set;
exports.spy = spy;
exports.toJS = toJS;
exports.trace = trace;
exports.transaction = transaction;
exports.untracked = untracked;
exports.values = values;
exports.when = when;


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],25:[function(require,module,exports){
(function (global){(function (){
function t(t){for(var n=arguments.length,i=new Array(n>1?n-1:0),r=1;r<n;r++)i[r-1]=arguments[r];throw new Error("number"==typeof t?"[MobX] minified error nr: "+t+(i.length?" "+i.map(String).join(","):"")+". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts":"[MobX] "+t)}function n(){return"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:xn}function i(){Vn||t("Proxy not available")}function r(t){var n=!1;return function(){if(!n)return n=!0,t.apply(this,arguments)}}function e(t){return"function"==typeof t}function o(t){switch(typeof t){case"string":case"symbol":case"number":return!0}return!1}function u(t){return null!==t&&"object"==typeof t}function s(t){var n;if(!u(t))return!1;var i=Object.getPrototypeOf(t);return null==i||(null==(n=i.constructor)?void 0:n.toString())===Nn}function f(t){var n=null==t?void 0:t.constructor;return!!n&&("GeneratorFunction"===n.name||"GeneratorFunction"===n.displayName)}function a(t,n,i){gn(t,n,{enumerable:!1,writable:!0,configurable:!0,value:i})}function c(t,n,i){gn(t,n,{enumerable:!1,writable:!1,configurable:!0,value:i})}function h(t,n){var i="isMobX"+t;return n.prototype[i]=!0,function(t){return u(t)&&!0===t[i]}}function v(t){return t instanceof Map}function l(t){return t instanceof Set}function d(t){return null===t?null:"object"==typeof t?""+t:t}function b(t,n){return _n.hasOwnProperty.call(t,n)}function p(t,n){for(var i=0;i<n.length;i++){var r=n[i];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function y(t,n,i){return n&&p(t.prototype,n),i&&p(t,i),t}function m(){return(m=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var i=arguments[n];for(var r in i)Object.prototype.hasOwnProperty.call(i,r)&&(t[r]=i[r])}return t}).apply(this,arguments)}function w(t,n){t.prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n}function j(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function x(t,n){(null==n||n>t.length)&&(n=t.length);for(var i=0,r=new Array(n);i<n;i++)r[i]=t[i];return r}function O(t,n){var i;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(i=function(t){if(t){if("string"==typeof t)return x(t,void 0);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?x(t,void 0):void 0}}(t))||n&&t&&"number"==typeof t.length){i&&(t=i);var r=0;return function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}return(i=t[Symbol.iterator]()).next.bind(i)}function A(t){return Object.assign((function(n,i){g(n,i,t)}),t)}function g(t,n,i){b(t,Cn)||a(t,Cn,m({},t[Cn])),function(t){return"override"===t.t}(i)||(t[Cn][n]=i)}function _(t,n,i){void 0===n&&(n=Rn),void 0===i&&(i=Rn);var r=new Ln(t);return n!==Rn&&St(r,n),i!==Rn&&Mt(r,i),r}function S(t,n,i){return It(t)?t:Array.isArray(t)?$n.array(t,{name:i}):s(t)?$n.object(t,void 0,{name:i}):v(t)?$n.map(t,{name:i}):l(t)?$n.set(t,{name:i}):"function"!=typeof t||At(t)||Ct(t)?t:f(t)?Ri(t):_i(i,t)}function M(t){return t}function V(t,n){return{t:t,i:n,o:N,u:R}}function N(t,n,i,r){var e;if(null==(e=this.i)?void 0:e.bound)return null===this.u(t,n,i,!1)?0:1;if(r===t.s)return null===this.u(t,n,i,!1)?0:2;if(At(i.value))return 1;var o=k(t,this,n,i,!1);return gn(r,n,o),2}function R(t,n,i,r){var e=k(t,this,n,i);return t.h(n,e,r)}function k(t,n,i,r,e){var o,u,s,f,a;void 0===e&&(e=pi.safeDescriptors);var c,h=r.value;return(null==(o=n.i)?void 0:o.bound)&&(h=h.bind(null!=(c=t.v)?c:t.s)),{value:z(null!=(u=null==(s=n.i)?void 0:s.name)?u:i.toString(),h,null!=(f=null==(a=n.i)?void 0:a.autoAction)&&f),configurable:!e||t.l,enumerable:!1,writable:!e}}function E(t,n){return{t:t,i:n,o:T,u:C}}function T(t,n,i,r){var e;if(r===t.s)return null===this.u(t,n,i,!1)?0:2;if((null==(e=this.i)?void 0:e.bound)&&!Ct(t.s[n])&&null===this.u(t,n,i,!1))return 0;if(Ct(i.value))return 1;var o=K(t,0,0,i,!1,!1);return gn(r,n,o),2}function C(t,n,i,r){var e,o=K(t,0,0,i,null==(e=this.i)?void 0:e.bound);return t.h(n,o,r)}function K(t,n,i,r,e,o){void 0===o&&(o=pi.safeDescriptors);var u,s=r.value;return e&&(s=s.bind(null!=(u=t.v)?u:t.s)),{value:Ri(s),configurable:!o||t.l,enumerable:!1,writable:!o}}function L(t,n){return{t:t,i:n,o:I,u:P}}function I(t,n,i){return null===this.u(t,n,i,!1)?0:1}function P(t,n,i,r){return t.p(n,m({},this.i,{get:i.get,set:i.set}),r)}function D(t,n){return{t:t,i:n,o:B,u:q}}function B(t,n,i){return null===this.u(t,n,i,!1)?0:1}function q(t,n,i,r){var e,o;return t.m(n,i.value,null!=(e=null==(o=this.i)?void 0:o.enhancer)?e:S,r)}function G(t){return{t:"true",i:t,o:X,u:W}}function X(t,n,i,r){var e,o,u,s;if(i.get)return Qn.o(t,n,i,r);if(i.set){var a=z(n.toString(),i.set);return r===t.s?null===t.h(n,{configurable:!pi.safeDescriptors||t.l,set:a})?0:2:(gn(r,n,{configurable:!0,set:a}),2)}if(r!==t.s&&"function"==typeof i.value)return f(i.value)?((null==(s=this.i)?void 0:s.autoBind)?Ri.bound:Ri).o(t,n,i,r):((null==(u=this.i)?void 0:u.autoBind)?_i.bound:_i).o(t,n,i,r);var c,h=!1===(null==(e=this.i)?void 0:e.deep)?$n.ref:$n;return"function"==typeof i.value&&(null==(o=this.i)?void 0:o.autoBind)&&(i.value=i.value.bind(null!=(c=t.v)?c:t.s)),h.o(t,n,i,r)}function W(t,n,i,r){var e,o,u;return i.get?Qn.u(t,n,i,r):i.set?t.h(n,{configurable:!pi.safeDescriptors||t.l,set:z(n.toString(),i.set)},r):("function"==typeof i.value&&(null==(e=this.i)?void 0:e.autoBind)&&(i.value=i.value.bind(null!=(u=t.v)?u:t.s)),(!1===(null==(o=this.i)?void 0:o.deep)?$n.ref:$n).u(t,n,i,r))}function H(t){return t||qn}function U(t){return!0===t.deep?S:!1===t.deep?M:(n=t.defaultDecorator)&&null!=(i=null==(r=n.i)?void 0:r.enhancer)?i:S;var n,i,r}function F(t,n,i){if(!o(n))return It(t)?t:s(t)?$n.object(t,n,i):Array.isArray(t)?$n.array(t,n):v(t)?$n.map(t,n):l(t)?$n.set(t,n):"object"==typeof t&&null!==t?t:$n.box(t,n);g(t,n,Gn)}function z(t,n,i,r){function e(){return $(0,i,n,r||this,arguments)}return void 0===i&&(i=!1),e.isMobxAction=!0,ii&&(ri.value=t,Object.defineProperty(e,"name",ri)),e}function $(t,n,i,r,e){var o=J(0,n);try{return i.apply(r,e)}catch(t){throw o.j=t,t}finally{Y(o)}}function J(t,n){var i=pi.trackingDerivation,r=!n||!i;dt();var e=pi.allowStateChanges;r&&(ut(),e=Z(!0));var o={O:r,A:i,g:e,_:ft(!0),S:!1,M:0,V:ni++,N:ti};return ti=o.V,o}function Y(n){ti!==n.V&&t(30),ti=n.N,void 0!==n.j&&(pi.suppressReactionErrors=!0),tt(n.g),at(n._),bt(),n.O&&st(n.A),pi.suppressReactionErrors=!1}function Q(t,n){var i=Z(t);try{return n()}finally{tt(i)}}function Z(t){var n=pi.allowStateChanges;return pi.allowStateChanges=t,n}function tt(t){pi.allowStateChanges=t}function nt(t){return t instanceof hi}function it(t){switch(t.R){case si.k:return!1;case si.T:case si.C:return!0;case si.K:for(var n=ft(!0),i=ut(),r=t.L,e=r.length,o=0;o<e;o++){var u=r[o];if(ci(u)){if(pi.disableErrorBoundaries)u.get();else try{u.get()}catch(t){return st(i),at(n),!0}if(t.R===si.C)return st(i),at(n),!0}}return ct(t),st(i),at(n),!1}}function rt(t,n,i){var r=ft(!0);ct(t),t.I=new Array(t.L.length+100),t.P=0,t.D=++pi.runId;var e,o=pi.trackingDerivation;if(pi.trackingDerivation=t,pi.inBatch++,!0===pi.disableErrorBoundaries)e=n.call(i);else try{e=n.call(i)}catch(t){e=new hi(t)}return pi.inBatch--,pi.trackingDerivation=o,function(t){for(var n=t.L,i=t.L=t.I,r=si.k,e=0,o=t.P,u=0;u<o;u++){var s=i[u];0===s.B&&(s.B=1,e!==u&&(i[e]=s),e++),s.R>r&&(r=s.R)}for(i.length=e,t.I=null,o=n.length;o--;){var f=n[o];0===f.B&&vt(f,t),f.B=0}for(;e--;){var a=i[e];1===a.B&&(a.B=0,ht(a,t))}r!==si.k&&(t.R=r,t.q())}(t),at(r),e}function et(t){var n=t.L;t.L=[];for(var i=n.length;i--;)vt(n[i],t);t.R=si.T}function ot(t){var n=ut();try{return t()}finally{st(n)}}function ut(){var t=pi.trackingDerivation;return pi.trackingDerivation=null,t}function st(t){pi.trackingDerivation=t}function ft(t){var n=pi.allowStateReads;return pi.allowStateReads=t,n}function at(t){pi.allowStateReads=t}function ct(t){if(t.R!==si.k){t.R=si.k;for(var n=t.L,i=n.length;i--;)n[i].G=si.k}}function ht(t,n){t.X.add(n),t.G>n.R&&(t.G=n.R)}function vt(t,n){t.X.delete(n),0===t.X.size&&lt(t)}function lt(t){!1===t.W&&(t.W=!0,pi.pendingUnobservations.push(t))}function dt(){pi.inBatch++}function bt(){if(0==--pi.inBatch){mt();for(var t=pi.pendingUnobservations,n=0;n<t.length;n++){var i=t[n];i.W=!1,0===i.X.size&&(i.H&&(i.H=!1,i.onBUO()),i instanceof ai&&i.U())}pi.pendingUnobservations=[]}}function pt(t){var n=pi.trackingDerivation;return null!==n?(n.D!==t.F&&(t.F=n.D,n.I[n.P++]=t,!t.H&&pi.trackingContext&&(t.H=!0,t.onBO())),!0):(0===t.X.size&&pi.inBatch>0&&lt(t),!1)}function yt(t){t.G!==si.C&&(t.G=si.C,t.X.forEach((function(t){t.R===si.k&&t.q(),t.R=si.C})))}function mt(){pi.inBatch>0||pi.isRunningReactions||mi(wt)}function wt(){pi.isRunningReactions=!0;for(var t=pi.pendingReactions,n=0;t.length>0;){100==++n&&(console.error("[mobx] cycle in reaction: "+t[0]),t.splice(0));for(var i=t.splice(0),r=0,e=i.length;r<e;r++)i[r].$()}pi.isRunningReactions=!1}function jt(){return console.warn("[mobx.spy] Is a no-op in production builds"),function(){}}function xt(t){return function(n,i){return e(n)?z(n.name||"<unnamed action>",n,t):e(i)?z(n,i,t):o(i)?g(n,i,t?Oi:ji):o(n)?A(V(t?"autoAction":"action",{name:n,autoAction:t})):void 0}}function Ot(t){return $(0,!1,t,this,void 0)}function At(t){return e(t)&&!0===t.isMobxAction}function gt(t,n){function i(){t(o)}var r,e;void 0===n&&(n=Mn);var o,u=null!=(r=null==(e=n)?void 0:e.name)?r:"Autorun";if(n.scheduler||n.delay){var s=_t(n),f=!1;o=new yi(u,(function(){f||(f=!0,s((function(){f=!1,o.J||o.track(i)})))}),n.onError,n.requiresObservable)}else o=new yi(u,(function(){this.track(i)}),n.onError,n.requiresObservable);return o.Y(),o.Z()}function _t(t){return t.scheduler?t.scheduler:t.delay?function(n){return setTimeout(n,t.delay)}:Si}function St(t,n,i){return Vt("onBO",t,n,i)}function Mt(t,n,i){return Vt("onBUO",t,n,i)}function Vt(t,n,i,r){var o="function"==typeof r?dn(n,i):dn(n),u=e(r)?r:i,s=t+"L";return o[s]?o[s].add(u):o[s]=new Set([u]),function(){var t=o[s];t&&(t.delete(u),0===t.size&&delete o[s])}}function Nt(t,n,i,r){var e=Tn(n),o=sn(t,r)[Kn];dt();try{En(e).forEach((function(t){o.u(t,e[t],!i||!(t in i)||i[t])}))}finally{bt()}return t}function Rt(t){var n,i={name:t.tt};return t.L&&t.L.length>0&&(i.dependencies=(n=t.L,Array.from(new Set(n))).map(Rt)),i}function kt(t){var n={name:t.tt};return function(t){return t.X&&t.X.size>0}(t)&&(n.observers=Array.from(function(t){return t.X}(t)).map(kt)),n}function Et(){this.message="FLOW_CANCELLED"}function Tt(t){e(t.cancel)&&t.cancel()}function Ct(t){return!0===(null==t?void 0:t.isMobXFlow)}function Kt(t,n){if(void 0!==n){if(!1===an(t))return!1;if(!t[Kn].nt.has(n))return!1;var i=dn(t,n);return ci(i)}return ci(t)}function Lt(t,n){return!!t&&(void 0!==n?!!an(t)&&t[Kn].nt.has(n):an(t)||!!t[Kn]||In(t)||wi(t)||ci(t))}function It(t){return Lt(t)}function Pt(n){return an(n)?n[Kn].it():Hi(n)||Ji(n)?Array.from(n.keys()):un(n)?n.map((function(t,n){return n})):void t(5)}function Dt(n,i){return an(n)?n[Kn].rt(i):Hi(n)||Ji(n)?n.has(i):un(n)?i>=0&&i<n.length:void t(10)}function Bt(n){if(an(n))return n[Kn].et();t(38)}function qt(t,n,i){return t.set(n,i),i}function Gt(){t("trace() is not available in production builds");for(var n=!1,i=arguments.length,r=new Array(i),e=0;e<i;e++)r[e]=arguments[e];"boolean"==typeof r[r.length-1]&&(n=r.pop());var o=Xt(r);if(!o)return t("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");o.ot===fi.NONE&&console.log("[mobx.trace] '"+o.tt+"' tracing enabled"),o.ot=n?fi.BREAK:fi.LOG}function Xt(t){switch(t.length){case 0:return pi.trackingDerivation;case 1:return dn(t[0]);case 2:return dn(t[0],t[1])}}function Wt(t,n){void 0===n&&(n=void 0),dt();try{return t.apply(n)}finally{bt()}}function Ht(t,n,i){var r;if("number"==typeof i.timeout){var e=new Error("WHEN_TIMEOUT");r=setTimeout((function(){if(!u[Kn].J){if(u(),!i.onError)throw e;i.onError(e)}}),i.timeout)}i.name="When";var o=z("When-effect",n),u=gt((function(n){Q(!1,t)&&(n.dispose(),r&&clearTimeout(r),o())}),i);return u}function Ut(t,n){var i,r=new Promise((function(r,e){var o=Ht(t,r,m({},n,{onError:e}));i=function(){o(),e("WHEN_CANCELLED")}}));return r.cancel=i,r}function Ft(t){return t[Kn]}function zt(t){return void 0!==t.ut&&t.ut.length>0}function $t(t,n){var i=t.ut||(t.ut=[]);return i.push(n),r((function(){var t=i.indexOf(n);-1!==t&&i.splice(t,1)}))}function Jt(n,i){var r=ut();try{for(var e=[].concat(n.ut||[]),o=0,u=e.length;o<u&&((i=e[o](i))&&!i.type&&t(14),i);o++);return i}finally{st(r)}}function Yt(t){return void 0!==t.st&&t.st.length>0}function Qt(t,n){var i=t.st||(t.st=[]);return i.push(n),r((function(){var t=i.indexOf(n);-1!==t&&i.splice(t,1)}))}function Zt(t,n){var i=ut(),r=t.st;if(r){for(var e=0,o=(r=r.slice()).length;e<o;e++)r[e](n);st(i)}}function tn(t,n,r,e){void 0===r&&(r="ObservableArray"),void 0===e&&(e=!1),i();var o=new Ki(r,n,e,!1);c(o.nt,Kn,o);var u=new Proxy(o.nt,Ci);if(o.v=u,t&&t.length){var s=Z(!0);o.ft(0,0,t),tt(s)}return u}function nn(t,n){"function"==typeof Array.prototype[t]&&(Li[t]=n(t))}function rn(t){return function(){var n=this[Kn];n.at.reportObserved();var i=n.ct(n.nt);return i[t].apply(i,arguments)}}function en(t){return function(n,i){var r=this,e=this[Kn];return e.at.reportObserved(),e.ct(e.nt)[t]((function(t,e){return n.call(i,t,e,r)}))}}function on(t){return function(){var n=this,i=this[Kn];i.at.reportObserved();var r=i.ct(i.nt),e=arguments[0];return arguments[0]=function(t,i,r){return e(t,i,r,n)},r[t].apply(r,arguments)}}function un(t){return u(t)&&Di(t[Kn])}function sn(t,n){var i;if(b(t,Kn))return t;var r=null!=(i=null==n?void 0:n.name)?i:"ObservableObject",e=new Qi(t,new Map,String(r),function(t){var n;return t?null!=(n=t.defaultDecorator)?n:G(t):void 0}(n));return a(t,Kn,e),t}function fn(t){return Yi[t]||(Yi[t]={get:function(){return this[Kn].ht(t)},set:function(n){return this[Kn].vt(t,n)}})}function an(t){return!!u(t)&&Zi(t[Kn])}function cn(t,n,i){var r;null==(r=t.s[Cn])||delete r[i]}function hn(t){gn(ir.prototype,""+t,function(t){return{enumerable:!1,configurable:!0,get:function(){return this[Kn].lt(t)},set:function(n){this[Kn].dt(t,n)}}}(t))}function vn(t){if(t>tr){for(var n=tr;n<t+100;n++)hn(n);tr=t}}function ln(t,n,i){return new ir(t,n,i)}function dn(n,i){if("object"==typeof n&&null!==n){if(un(n))return void 0!==i&&t(23),n[Kn].at;if(Ji(n))return n[Kn];if(Hi(n)){if(void 0===i)return n.bt;var r=n.pt.get(i)||n.yt.get(i);return r||t(25,i,pn(n)),r}if(an(n)){if(!i)return t(26);var o=n[Kn].nt.get(i);return o||t(27,i,pn(n)),o}if(In(n)||ci(n)||wi(n))return n}else if(e(n)&&wi(n[Kn]))return n[Kn];t(28)}function bn(n,i){return n||t(29),void 0!==i?bn(dn(n,i)):In(n)||ci(n)||wi(n)||Hi(n)||Ji(n)?n:n[Kn]?n[Kn]:void t(24,n)}function pn(t,n){var i;if(void 0!==n)i=dn(t,n);else{if(At(t))return t.name;i=an(t)||Hi(t)||Ji(t)?bn(t):dn(t)}return i.tt}function yn(t,n,i){return void 0===i&&(i=-1),function t(n,i,r,o,u){if(n===i)return 0!==n||1/n==1/i;if(null==n||null==i)return!1;if(n!=n)return i!=i;var s=typeof n;if(!e(s)&&"object"!==s&&"object"!=typeof i)return!1;var f=rr.call(n);if(f!==rr.call(i))return!1;switch(f){case"[object RegExp]":case"[object String]":return""+n==""+i;case"[object Number]":return+n!=+n?+i!=+i:0==+n?1/+n==1/i:+n==+i;case"[object Date]":case"[object Boolean]":return+n==+i;case"[object Symbol]":return"undefined"!=typeof Symbol&&Symbol.valueOf.call(n)===Symbol.valueOf.call(i);case"[object Map]":case"[object Set]":r>=0&&r++}n=mn(n),i=mn(i);var a="[object Array]"===f;if(!a){if("object"!=typeof n||"object"!=typeof i)return!1;var c=n.constructor,h=i.constructor;if(c!==h&&!(e(c)&&c instanceof c&&e(h)&&h instanceof h)&&"constructor"in n&&"constructor"in i)return!1}if(0===r)return!1;r<0&&(r=-1),u=u||[];for(var v=(o=o||[]).length;v--;)if(o[v]===n)return u[v]===i;if(o.push(n),u.push(i),a){if((v=n.length)!==i.length)return!1;for(;v--;)if(!t(n[v],i[v],r-1,o,u))return!1}else{var l,d=Object.keys(n);if(v=d.length,Object.keys(i).length!==v)return!1;for(;v--;)if(!b(i,l=d[v])||!t(n[l],i[l],r-1,o,u))return!1}return o.pop(),u.pop(),!0}(t,n,i)}function mn(t){return un(t)?t.slice():v(t)||Hi(t)||l(t)||Ji(t)?Array.from(t.entries()):t}function wn(t){return t[Symbol.iterator]=jn,t}function jn(){return this}Object.defineProperty(exports,"__esModule",{value:!0});var xn={},On=Object.assign,An=Object.getOwnPropertyDescriptor,gn=Object.defineProperty,_n=Object.prototype,Sn=[];Object.freeze(Sn);var Mn={};Object.freeze(Mn);var Vn="undefined"!=typeof Proxy,Nn=Object.toString(),Rn=function(){},kn=void 0!==Object.getOwnPropertySymbols,En="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:kn?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:Object.getOwnPropertyNames,Tn=Object.getOwnPropertyDescriptors||function(t){var n={};return En(t).forEach((function(i){n[i]=An(t,i)})),n},Cn=Symbol("mobx-stored-annotations"),Kn=Symbol("mobx administration"),Ln=function(){function t(t){void 0===t&&(t="Atom"),this.tt=void 0,this.W=!1,this.H=!1,this.X=new Set,this.B=0,this.F=0,this.G=si.T,this.onBOL=void 0,this.onBUOL=void 0,this.tt=t}var n=t.prototype;return n.onBO=function(){this.onBOL&&this.onBOL.forEach((function(t){return t()}))},n.onBUO=function(){this.onBUOL&&this.onBUOL.forEach((function(t){return t()}))},n.reportObserved=function(){return pt(this)},n.reportChanged=function(){dt(),yt(this),bt()},n.toString=function(){return this.tt},t}(),In=h("Atom",Ln),Pn={identity:function(t,n){return t===n},structural:function(t,n){return yn(t,n)},default:function(t,n){return Object.is?Object.is(t,n):t===n?0!==t||1/t==1/n:t!=t&&n!=n},shallow:function(t,n){return yn(t,n,1)}},Dn=A({t:"override",o:function(){return 0},u:function(){t("'"+this.t+"' can only be used with 'makeObservable'")}}),Bn=G(),qn={deep:!0,name:void 0,defaultDecorator:void 0,proxy:!0};Object.freeze(qn);var Gn=D("observable"),Xn=D("observable.ref",{enhancer:M}),Wn=D("observable.shallow",{enhancer:function(t,n,i){return null==t||an(t)||un(t)||Hi(t)||Ji(t)?t:Array.isArray(t)?$n.array(t,{name:i,deep:!1}):s(t)?$n.object(t,void 0,{name:i,deep:!1}):v(t)?$n.map(t,{name:i,deep:!1}):l(t)?$n.set(t,{name:i,deep:!1}):void 0}}),Hn=D("observable.struct",{enhancer:function(t,n){return yn(t,n)?n:t}}),Un=A(Gn);Object.assign(F,Un);var Fn,zn,$n=On(F,{box:function(t,n){var i=H(n);return new oi(t,U(i),i.name,!0,i.equals)},array:function(t,n){var i=H(n);return(!1===pi.useProxies||!1===i.proxy?ln:tn)(t,U(i),i.name)},map:function(t,n){var i=H(n);return new Wi(t,U(i),i.name)},set:function(t,n){var i=H(n);return new $i(t,U(i),i.name)},object:function(t,n,r){return Nt(!1===pi.useProxies||!1===(null==r?void 0:r.proxy)?sn({},r):function(t,n){var r,e;return i(),null!=(e=(r=(t=sn(t,n))[Kn]).v)?e:r.v=new Proxy(t,ki)}({},r),t,n)},ref:A(Xn),shallow:A(Wn),deep:Un,struct:A(Hn)}),Jn=L("computed"),Yn=L("computed.struct",{equals:Pn.structural}),Qn=function(t,n){if(o(n))return g(t,n,Jn);if(s(t))return A(L("computed",t));var i=s(n)?n:{};return i.get=t,i.name||(i.name=t.name||""),new ai(i)};Object.assign(Qn,Jn),Qn.struct=A(Yn);var Zn,ti=0,ni=1,ii=null!=(Fn=null==(zn=An((function(){}),"name"))?void 0:zn.configurable)&&Fn,ri={value:"action",configurable:!0,writable:!1,enumerable:!1};Zn=Symbol.toPrimitive;var ei,oi=function(t){function n(n,i,r,e,o){var u;return void 0===r&&(r="ObservableValue"),void 0===o&&(o=Pn.default),(u=t.call(this,r)||this).enhancer=void 0,u.tt=void 0,u.equals=void 0,u.wt=!1,u.ut=void 0,u.st=void 0,u.jt=void 0,u.dehancer=void 0,u.enhancer=i,u.tt=r,u.equals=o,u.jt=i(n,void 0,r),u}w(n,t);var i=n.prototype;return i.dehanceValue=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.set=function(t){(t=this.xt(t))!==pi.UNCHANGED&&this.Ot(t)},i.xt=function(t){if(zt(this)){var n=Jt(this,{object:this,type:Ti,newValue:t});if(!n)return pi.UNCHANGED;t=n.newValue}return t=this.enhancer(t,this.jt,this.tt),this.equals(this.jt,t)?pi.UNCHANGED:t},i.Ot=function(t){var n=this.jt;this.jt=t,this.reportChanged(),Yt(this)&&Zt(this,{type:Ti,object:this,newValue:t,oldValue:n})},i.get=function(){return this.reportObserved(),this.dehanceValue(this.jt)},i.At=function(t){return $t(this,t)},i.gt=function(t,n){return n&&t({observableKind:"value",debugObjectName:this.tt,object:this,type:Ti,newValue:this.jt,oldValue:void 0}),Qt(this,t)},i.raw=function(){return this.jt},i.toJSON=function(){return this.get()},i.toString=function(){return this.tt+"["+this.jt+"]"},i.valueOf=function(){return d(this.get())},i[Zn]=function(){return this.valueOf()},n}(Ln),ui=h("ObservableValue",oi);ei=Symbol.toPrimitive;var si,fi,ai=function(){function n(n){this.R=si.T,this.L=[],this.I=null,this.H=!1,this.W=!1,this.X=new Set,this.B=0,this.D=0,this.F=0,this.G=si.k,this.P=0,this.jt=new hi(null),this.tt=void 0,this._t=void 0,this.St=!1,this.Mt=!1,this.derivation=void 0,this.Vt=void 0,this.ot=fi.NONE,this.Nt=void 0,this.Rt=void 0,this.kt=void 0,this.Et=void 0,this.onBOL=void 0,this.onBUOL=void 0,n.get||t(31),this.derivation=n.get,this.tt=n.name||"ComputedValue",n.set&&(this.Vt=z("ComputedValue-setter",n.set)),this.Rt=n.equals||(n.compareStructural||n.struct?Pn.structural:Pn.default),this.Nt=n.context,this.kt=!!n.requiresReaction,this.Et=!!n.keepAlive}var i=n.prototype;return i.q=function(){!function(t){t.G===si.k&&(t.G=si.K,t.X.forEach((function(t){t.R===si.k&&(t.R=si.K,t.q())})))}(this)},i.onBO=function(){this.onBOL&&this.onBOL.forEach((function(t){return t()}))},i.onBUO=function(){this.onBUOL&&this.onBUOL.forEach((function(t){return t()}))},i.get=function(){if(this.St&&t(32,this.tt,this.derivation),0!==pi.inBatch||0!==this.X.size||this.Et){if(pt(this),it(this)){var n=pi.trackingContext;this.Et&&!n&&(pi.trackingContext=this),this.trackAndCompute()&&function(t){t.G!==si.C&&(t.G=si.C,t.X.forEach((function(n){n.R===si.K?n.R=si.C:n.R===si.k&&(t.G=si.k)})))}(this),pi.trackingContext=n}}else it(this)&&(this.Tt(),dt(),this.jt=this.Ct(!1),bt());var i=this.jt;if(nt(i))throw i.cause;return i},i.set=function(n){if(this.Vt){this.Mt&&t(33,this.tt),this.Mt=!0;try{this.Vt.call(this.Nt,n)}finally{this.Mt=!1}}else t(34,this.tt)},i.trackAndCompute=function(){var t=this.jt,n=this.R===si.T,i=this.Ct(!0),r=n||nt(t)||nt(i)||!this.Rt(t,i);return r&&(this.jt=i),r},i.Ct=function(t){this.St=!0;var n,i=Z(!1);if(t)n=rt(this,this.derivation,this.Nt);else if(!0===pi.disableErrorBoundaries)n=this.derivation.call(this.Nt);else try{n=this.derivation.call(this.Nt)}catch(t){n=new hi(t)}return tt(i),this.St=!1,n},i.U=function(){this.Et||(et(this),this.jt=void 0)},i.gt=function(t,n){var i=this,r=!0,e=void 0;return gt((function(){var o=i.get();if(!r||n){var u=ut();t({observableKind:"computed",debugObjectName:i.tt,type:Ti,object:i,newValue:o,oldValue:e}),st(u)}r=!1,e=o}))},i.Tt=function(){},i.toString=function(){return this.tt+"["+this.derivation.toString()+"]"},i.valueOf=function(){return d(this.get())},i[ei]=function(){return this.valueOf()},n}(),ci=h("ComputedValue",ai);!function(t){t[t.T=-1]="NOT_TRACKING_",t[t.k=0]="UP_TO_DATE_",t[t.K=1]="POSSIBLY_STALE_",t[t.C=2]="STALE_"}(si||(si={})),function(t){t[t.NONE=0]="NONE",t[t.LOG=1]="LOG",t[t.BREAK=2]="BREAK"}(fi||(fi={}));var hi=function(t){this.cause=void 0,this.cause=t},vi=["mobxGuid","spyListeners","enforceActions","computedRequiresReaction","reactionRequiresObservable","observableRequiresReaction","allowStateReads","disableErrorBoundaries","runId","UNCHANGED","useProxies"],li=function(){this.version=6,this.UNCHANGED={},this.trackingDerivation=null,this.trackingContext=null,this.runId=0,this.mobxGuid=0,this.inBatch=0,this.pendingUnobservations=[],this.pendingReactions=[],this.isRunningReactions=!1,this.allowStateChanges=!1,this.allowStateReads=!0,this.enforceActions=!0,this.spyListeners=[],this.globalReactionErrorHandlers=[],this.computedRequiresReaction=!1,this.reactionRequiresObservable=!1,this.observableRequiresReaction=!1,this.disableErrorBoundaries=!1,this.suppressReactionErrors=!1,this.useProxies=!0,this.verifyProxies=!1,this.safeDescriptors=!0},di=!0,bi=!1,pi=function(){var i=n();return i.__mobxInstanceCount>0&&!i.__mobxGlobals&&(di=!1),i.__mobxGlobals&&i.__mobxGlobals.version!==(new li).version&&(di=!1),di?i.__mobxGlobals?(i.__mobxInstanceCount+=1,i.__mobxGlobals.UNCHANGED||(i.__mobxGlobals.UNCHANGED={}),i.__mobxGlobals):(i.__mobxInstanceCount=1,i.__mobxGlobals=new li):(setTimeout((function(){bi||t(35)}),1),new li)}(),yi=function(){function t(t,n,i,r){void 0===t&&(t="Reaction"),void 0===r&&(r=!1),this.tt=void 0,this.Kt=void 0,this.Lt=void 0,this.It=void 0,this.L=[],this.I=[],this.R=si.T,this.B=0,this.D=0,this.P=0,this.J=!1,this.Pt=!1,this.Dt=!1,this.Bt=!1,this.ot=fi.NONE,this.tt=t,this.Kt=n,this.Lt=i,this.It=r}var n=t.prototype;return n.q=function(){this.Y()},n.Y=function(){this.Pt||(this.Pt=!0,pi.pendingReactions.push(this),mt())},n.isScheduled=function(){return this.Pt},n.$=function(){if(!this.J){dt(),this.Pt=!1;var t=pi.trackingContext;if(pi.trackingContext=this,it(this)){this.Dt=!0;try{this.Kt()}catch(t){this.qt(t)}}pi.trackingContext=t,bt()}},n.track=function(t){if(!this.J){dt(),this.Bt=!0;var n=pi.trackingContext;pi.trackingContext=this;var i=rt(this,t,void 0);pi.trackingContext=n,this.Bt=!1,this.Dt=!1,this.J&&et(this),nt(i)&&this.qt(i.cause),bt()}},n.qt=function(t){var n=this;if(this.Lt)this.Lt(t,this);else{if(pi.disableErrorBoundaries)throw t;pi.suppressReactionErrors||console.error("[mobx] uncaught error in '"+this+"'",t),pi.globalReactionErrorHandlers.forEach((function(i){return i(t,n)}))}},n.dispose=function(){this.J||(this.J=!0,this.Bt||(dt(),et(this),bt()))},n.Z=function(){var t=this.dispose.bind(this);return t[Kn]=this,t},n.toString=function(){return"Reaction["+this.tt+"]"},n.trace=function(t){void 0===t&&(t=!1),Gt(this,t)},t}(),mi=function(t){return t()},wi=h("Reaction",yi),ji=V("action"),xi=V("action.bound",{bound:!0}),Oi=V("autoAction",{autoAction:!0}),Ai=V("autoAction.bound",{autoAction:!0,bound:!0}),gi=xt(!1);Object.assign(gi,ji);var _i=xt(!0);Object.assign(_i,Oi),gi.bound=A(xi),_i.bound=A(Ai);var Si=function(t){return t()},Mi=0;Et.prototype=Object.create(Error.prototype);var Vi=E("flow"),Ni=E("flow.bound",{bound:!0}),Ri=Object.assign((function(t,n){if(o(n))return g(t,n,Vi);var i=t,r=i.name||"<unnamed flow>",u=function(){var t,n=this,o=arguments,u=++Mi,s=gi(r+" - runid: "+u+" - init",i).apply(n,o),f=void 0,a=new Promise((function(n,i){function o(t){var n;f=void 0;try{n=gi(r+" - runid: "+u+" - yield "+h++,s.next).call(s,t)}catch(t){return i(t)}c(n)}function a(t){var n;f=void 0;try{n=gi(r+" - runid: "+u+" - yield "+h++,s.throw).call(s,t)}catch(t){return i(t)}c(n)}function c(t){if(!e(null==t?void 0:t.then))return t.done?n(t.value):(f=Promise.resolve(t.value)).then(o,a);t.then(c,i)}var h=0;t=i,o(void 0)}));return a.cancel=gi(r+" - runid: "+u+" - cancel",(function(){try{f&&Tt(f);var n=s.return(void 0),i=Promise.resolve(n.value);i.then(Rn,Rn),Tt(i),t(new Et)}catch(n){t(n)}})),a};return u.isMobXFlow=!0,u}),Vi);Ri.bound=A(Ni);var ki={has:function(t,n){return Ft(t).rt(n)},get:function(t,n){return Ft(t).lt(n)},set:function(t,n,i){var r;return!!o(n)&&(null==(r=Ft(t).dt(n,i,!0))||r)},deleteProperty:function(t,n){var i;return!!o(n)&&(null==(i=Ft(t).Gt(n,!0))||i)},defineProperty:function(t,n,i){var r;return null==(r=Ft(t).h(n,i))||r},ownKeys:function(t){return Ft(t).et()},preventExtensions:function(){t(13)}},Ei=Symbol("mobx-keys"),Ti="update",Ci={get:function(t,n){var i=t[Kn];return n===Kn?i:"length"===n?i.Xt():"string"!=typeof n||isNaN(n)?b(Li,n)?Li[n]:t[n]:i.lt(parseInt(n))},set:function(t,n,i){var r=t[Kn];return"length"===n&&r.Wt(i),"symbol"==typeof n||isNaN(n)?t[n]=i:r.dt(parseInt(n),i),!0},preventExtensions:function(){t(15)}},Ki=function(){function n(t,n,i,r){void 0===t&&(t="ObservableArray"),this.Ht=void 0,this.Ut=void 0,this.at=void 0,this.nt=[],this.ut=void 0,this.st=void 0,this.Ft=void 0,this.dehancer=void 0,this.v=void 0,this.zt=0,this.Ht=i,this.Ut=r,this.at=new Ln(t),this.Ft=function(t,i){return n(t,i,"ObservableArray[..]")}}var i=n.prototype;return i.$t=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.ct=function(t){return void 0!==this.dehancer&&t.length>0?t.map(this.dehancer):t},i.At=function(t){return $t(this,t)},i.gt=function(t,n){return void 0===n&&(n=!1),n&&t({observableKind:"array",object:this.v,debugObjectName:this.at.tt,type:"splice",index:0,added:this.nt.slice(),addedCount:this.nt.length,removed:[],removedCount:0}),Qt(this,t)},i.Xt=function(){return this.at.reportObserved(),this.nt.length},i.Wt=function(n){("number"!=typeof n||n<0)&&t("Out of range: "+n);var i=this.nt.length;if(n!==i)if(n>i){for(var r=new Array(n-i),e=0;e<n-i;e++)r[e]=void 0;this.ft(i,0,r)}else this.ft(n,i-n)},i.Jt=function(n,i){n!==this.zt&&t(16),this.zt+=i,this.Ut&&i>0&&vn(n+i+1)},i.ft=function(t,n,i){var r=this,e=this.nt.length;if(void 0===t?t=0:t>e?t=e:t<0&&(t=Math.max(0,e+t)),n=1===arguments.length?e-t:null==n?0:Math.max(0,Math.min(n,e-t)),void 0===i&&(i=Sn),zt(this)){var o=Jt(this,{object:this.v,type:"splice",index:t,removedCount:n,added:i});if(!o)return Sn;n=o.removedCount,i=o.added}if(i=0===i.length?i:i.map((function(t){return r.Ft(t,void 0)})),this.Ut){var u=i.length-n;this.Jt(e,u)}var s=this.Yt(t,n,i);return 0===n&&0===i.length||this.Qt(t,i,s),this.ct(s)},i.Yt=function(t,n,i){var r;if(i.length<1e4)return(r=this.nt).splice.apply(r,[t,n].concat(i));var e=this.nt.slice(t,t+n),o=this.nt.slice(t+n);this.nt.length=t+i.length-n;for(var u=0;u<i.length;u++)this.nt[t+u]=i[u];for(var s=0;s<o.length;s++)this.nt[t+i.length+s]=o[s];return e},i.Zt=function(t,n,i){var r=!this.Ht&&!1,e=Yt(this),o=e||r?{observableKind:"array",object:this.v,type:Ti,debugObjectName:this.at.tt,index:t,newValue:n,oldValue:i}:null;this.at.reportChanged(),e&&Zt(this,o)},i.Qt=function(t,n,i){var r=!this.Ht&&!1,e=Yt(this),o=e||r?{observableKind:"array",object:this.v,debugObjectName:this.at.tt,type:"splice",index:t,removed:i,added:n,removedCount:i.length,addedCount:n.length}:null;this.at.reportChanged(),e&&Zt(this,o)},i.lt=function(t){if(t<this.nt.length)return this.at.reportObserved(),this.$t(this.nt[t]);console.warn("[mobx.array] Attempt to read an array index ("+t+") that is out of bounds ("+this.nt.length+"). Please check length first. Out of bound indices will not be tracked by MobX")},i.dt=function(n,i){var r=this.nt;if(n<r.length){var e=r[n];if(zt(this)){var o=Jt(this,{type:Ti,object:this.v,index:n,newValue:i});if(!o)return;i=o.newValue}(i=this.Ft(i,e))!==e&&(r[n]=i,this.Zt(n,i,e))}else n===r.length?this.ft(n,0,[i]):t(17,n,r.length)},n}(),Li={clear:function(){return this.splice(0)},replace:function(t){var n=this[Kn];return n.ft(0,n.nt.length,t)},toJSON:function(){return this.slice()},splice:function(t,n){for(var i=arguments.length,r=new Array(i>2?i-2:0),e=2;e<i;e++)r[e-2]=arguments[e];var o=this[Kn];switch(arguments.length){case 0:return[];case 1:return o.ft(t);case 2:return o.ft(t,n)}return o.ft(t,n,r)},spliceWithArray:function(t,n,i){return this[Kn].ft(t,n,i)},push:function(){for(var t=this[Kn],n=arguments.length,i=new Array(n),r=0;r<n;r++)i[r]=arguments[r];return t.ft(t.nt.length,0,i),t.nt.length},pop:function(){return this.splice(Math.max(this[Kn].nt.length-1,0),1)[0]},shift:function(){return this.splice(0,1)[0]},unshift:function(){for(var t=this[Kn],n=arguments.length,i=new Array(n),r=0;r<n;r++)i[r]=arguments[r];return t.ft(0,0,i),t.nt.length},reverse:function(){return pi.trackingDerivation&&t(37,"reverse"),this.replace(this.slice().reverse()),this},sort:function(){pi.trackingDerivation&&t(37,"sort");var n=this.slice();return n.sort.apply(n,arguments),this.replace(n),this},remove:function(t){var n=this[Kn],i=n.ct(n.nt).indexOf(t);return i>-1&&(this.splice(i,1),!0)}};nn("concat",rn),nn("flat",rn),nn("includes",rn),nn("indexOf",rn),nn("join",rn),nn("lastIndexOf",rn),nn("slice",rn),nn("toString",rn),nn("toLocaleString",rn),nn("every",en),nn("filter",en),nn("find",en),nn("findIndex",en),nn("flatMap",en),nn("forEach",en),nn("map",en),nn("some",en),nn("reduce",on),nn("reduceRight",on);var Ii,Pi,Di=h("ObservableArrayAdministration",Ki),Bi={},qi="add";Ii=Symbol.iterator,Pi=Symbol.toStringTag;var Gi,Xi,Wi=function(){function n(n,i,r){void 0===i&&(i=S),void 0===r&&(r="ObservableMap"),this.Ft=void 0,this.tt=void 0,this[Kn]=Bi,this.pt=void 0,this.yt=void 0,this.bt=void 0,this.ut=void 0,this.st=void 0,this.dehancer=void 0,this.Ft=i,this.tt=r,e(Map)||t(18),this.bt=_("ObservableMap.keys()"),this.pt=new Map,this.yt=new Map,this.merge(n)}var i=n.prototype;return i.rt=function(t){return this.pt.has(t)},i.has=function(t){var n=this;if(!pi.trackingDerivation)return this.rt(t);var i=this.yt.get(t);if(!i){var r=i=new oi(this.rt(t),M,"ObservableMap.key?",!1);this.yt.set(t,r),Mt(r,(function(){return n.yt.delete(t)}))}return i.get()},i.set=function(t,n){var i=this.rt(t);if(zt(this)){var r=Jt(this,{type:i?Ti:qi,object:this,newValue:n,name:t});if(!r)return this;n=r.newValue}return i?this.tn(t,n):this.nn(t,n),this},i.delete=function(t){var n=this;if(zt(this)&&!Jt(this,{type:"delete",object:this,name:t}))return!1;if(this.rt(t)){var i=Yt(this),r=i?{observableKind:"map",debugObjectName:this.tt,type:"delete",object:this,oldValue:this.pt.get(t).jt,name:t}:null;return Wt((function(){n.bt.reportChanged(),n.in(t,!1),n.pt.get(t).Ot(void 0),n.pt.delete(t)})),i&&Zt(this,r),!0}return!1},i.in=function(t,n){var i=this.yt.get(t);i&&i.Ot(n)},i.tn=function(t,n){var i=this.pt.get(t);if((n=i.xt(n))!==pi.UNCHANGED){var r=Yt(this),e=r?{observableKind:"map",debugObjectName:this.tt,type:Ti,object:this,oldValue:i.jt,name:t,newValue:n}:null;i.Ot(n),r&&Zt(this,e)}},i.nn=function(t,n){var i=this;Wt((function(){var r=new oi(n,i.Ft,"ObservableMap.key",!1);i.pt.set(t,r),n=r.jt,i.in(t,!0),i.bt.reportChanged()}));var r=Yt(this);r&&Zt(this,r?{observableKind:"map",debugObjectName:this.tt,type:qi,object:this,name:t,newValue:n}:null)},i.get=function(t){return this.has(t)?this.$t(this.pt.get(t).get()):this.$t(void 0)},i.$t=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.keys=function(){return this.bt.reportObserved(),this.pt.keys()},i.values=function(){var t=this,n=this.keys();return wn({next:function(){var i=n.next(),r=i.done;return{done:r,value:r?void 0:t.get(i.value)}}})},i.entries=function(){var t=this,n=this.keys();return wn({next:function(){var i=n.next(),r=i.done,e=i.value;return{done:r,value:r?void 0:[e,t.get(e)]}}})},i[Ii]=function(){return this.entries()},i.forEach=function(t,n){for(var i,r=O(this);!(i=r()).done;){var e=i.value;t.call(n,e[1],e[0],this)}},i.merge=function(n){var i=this;return Hi(n)&&(n=new Map(n)),Wt((function(){s(n)?function(t){var n=Object.keys(t);if(!kn)return n;var i=Object.getOwnPropertySymbols(t);return i.length?[].concat(n,i.filter((function(n){return _n.propertyIsEnumerable.call(t,n)}))):n}(n).forEach((function(t){return i.set(t,n[t])})):Array.isArray(n)?n.forEach((function(t){return i.set(t[0],t[1])})):v(n)?(n.constructor!==Map&&t(19,n),n.forEach((function(t,n){return i.set(n,t)}))):null!=n&&t(20,n)})),this},i.clear=function(){var t=this;Wt((function(){ot((function(){for(var n,i=O(t.keys());!(n=i()).done;)t.delete(n.value)}))}))},i.replace=function(n){var i=this;return Wt((function(){for(var r,e=function(n){if(v(n)||Hi(n))return n;if(Array.isArray(n))return new Map(n);if(s(n)){var i=new Map;for(var r in n)i.set(r,n[r]);return i}return t(21,n)}(n),o=new Map,u=!1,f=O(i.pt.keys());!(r=f()).done;){var a=r.value;if(!e.has(a))if(i.delete(a))u=!0;else{var c=i.pt.get(a);o.set(a,c)}}for(var h,l=O(e.entries());!(h=l()).done;){var d=h.value,b=d[0],p=d[1],y=i.pt.has(b);if(i.set(b,p),i.pt.has(b)){var m=i.pt.get(b);o.set(b,m),y||(u=!0)}}if(!u)if(i.pt.size!==o.size)i.bt.reportChanged();else for(var w=i.pt.keys(),j=o.keys(),x=w.next(),A=j.next();!x.done;){if(x.value!==A.value){i.bt.reportChanged();break}x=w.next(),A=j.next()}i.pt=o})),this},i.toString=function(){return"[object ObservableMap]"},i.toJSON=function(){return Array.from(this)},i.gt=function(t){return Qt(this,t)},i.At=function(t){return $t(this,t)},y(n,[{key:"size",get:function(){return this.bt.reportObserved(),this.pt.size}},{key:Pi,get:function(){return"Map"}}]),n}(),Hi=h("ObservableMap",Wi),Ui={};Gi=Symbol.iterator,Xi=Symbol.toStringTag;var Fi,zi,$i=function(){function n(n,i,r){void 0===i&&(i=S),void 0===r&&(r="ObservableSet"),this.tt=void 0,this[Kn]=Ui,this.pt=new Set,this.at=void 0,this.st=void 0,this.ut=void 0,this.dehancer=void 0,this.Ft=void 0,this.tt=r,e(Set)||t(22),this.at=_(this.tt),this.Ft=function(t,n){return i(t,n,r)},n&&this.replace(n)}var i=n.prototype;return i.$t=function(t){return void 0!==this.dehancer?this.dehancer(t):t},i.clear=function(){var t=this;Wt((function(){ot((function(){for(var n,i=O(t.pt.values());!(n=i()).done;)t.delete(n.value)}))}))},i.forEach=function(t,n){for(var i,r=O(this);!(i=r()).done;){var e=i.value;t.call(n,e,e,this)}},i.add=function(t){var n=this;if(zt(this)&&!Jt(this,{type:qi,object:this,newValue:t}))return this;if(!this.has(t)){Wt((function(){n.pt.add(n.Ft(t,void 0)),n.at.reportChanged()}));var i=Yt(this);i&&Zt(this,i?{observableKind:"set",debugObjectName:this.tt,type:qi,object:this,newValue:t}:null)}return this},i.delete=function(t){var n=this;if(zt(this)&&!Jt(this,{type:"delete",object:this,oldValue:t}))return!1;if(this.has(t)){var i=Yt(this),r=i?{observableKind:"set",debugObjectName:this.tt,type:"delete",object:this,oldValue:t}:null;return Wt((function(){n.at.reportChanged(),n.pt.delete(t)})),i&&Zt(this,r),!0}return!1},i.has=function(t){return this.at.reportObserved(),this.pt.has(this.$t(t))},i.entries=function(){var t=0,n=Array.from(this.keys()),i=Array.from(this.values());return wn({next:function(){var r=t;return t+=1,r<i.length?{value:[n[r],i[r]],done:!1}:{done:!0}}})},i.keys=function(){return this.values()},i.values=function(){this.at.reportObserved();var t=this,n=0,i=Array.from(this.pt.values());return wn({next:function(){return n<i.length?{value:t.$t(i[n++]),done:!1}:{done:!0}}})},i.replace=function(n){var i=this;return Ji(n)&&(n=new Set(n)),Wt((function(){Array.isArray(n)||l(n)?(i.clear(),n.forEach((function(t){return i.add(t)}))):null!=n&&t("Cannot initialize set from "+n)})),this},i.gt=function(t){return Qt(this,t)},i.At=function(t){return $t(this,t)},i.toJSON=function(){return Array.from(this)},i.toString=function(){return"[object ObservableSet]"},i[Gi]=function(){return this.values()},y(n,[{key:"size",get:function(){return this.at.reportObserved(),this.pt.size}},{key:Xi,get:function(){return"Set"}}]),n}(),Ji=h("ObservableSet",$i),Yi=Object.create(null),Qi=function(){function n(t,n,i,r){void 0===n&&(n=new Map),void 0===r&&(r=Bn),this.s=void 0,this.nt=void 0,this.tt=void 0,this.rn=void 0,this.bt=void 0,this.st=void 0,this.ut=void 0,this.v=void 0,this.l=void 0,this.en=void 0,this.on=void 0,this.s=t,this.nt=n,this.tt=i,this.rn=r,this.bt=new Ln("ObservableObject.keys"),this.l=s(this.s)}var i=n.prototype;return i.ht=function(t){return this.nt.get(t).get()},i.vt=function(t,n){var i=this.nt.get(t);if(i instanceof ai)return i.set(n),!0;if(zt(this)){var r=Jt(this,{type:Ti,object:this.v||this.s,name:t,newValue:n});if(!r)return null;n=r.newValue}if((n=i.xt(n))!==pi.UNCHANGED){var e=Yt(this),o=e?{type:Ti,observableKind:"object",debugObjectName:this.tt,object:this.v||this.s,oldValue:i.jt,name:t,newValue:n}:null;i.Ot(n),e&&Zt(this,o)}return!0},i.lt=function(t){return pi.trackingDerivation&&!b(this.s,t)&&this.rt(t),this.s[t]},i.dt=function(t,n,i){return void 0===i&&(i=!1),b(this.s,t)?this.nt.has(t)?this.vt(t,n):i?Reflect.set(this.s,t,n):(this.s[t]=n,!0):this.u(t,{value:n,enumerable:!0,writable:!0,configurable:!0},this.rn,i)},i.rt=function(t){if(!pi.trackingDerivation)return t in this.s;this.on||(this.on=new Map);var n=this.on.get(t);return n||(n=new oi(t in this.s,M,"ObservableObject.key?",!1),this.on.set(t,n)),n.get()},i.o=function(n,i){if(!0===i&&(i=this.rn),!1!==i){if(!(n in this.s)){var r;if(null==(r=this.s[Cn])?void 0:r[n])return;t(1,i.t,this.tt+"."+n.toString())}for(var e=this.s;e&&e!==_n;){var o=An(e,n);if(o){var u=i.o(this,n,o,e);if(0===u)return;if(1===u)break}e=Object.getPrototypeOf(e)}cn(this,0,n)}},i.u=function(t,n,i,r){if(void 0===r&&(r=!1),!0===i&&(i=this.rn),!1===i)return this.h(t,n,r);var e=i.u(this,t,n,r);return e&&cn(this,0,t),e},i.h=function(t,n,i){void 0===i&&(i=!1);try{dt();var r=this.Gt(t);if(!r)return r;if(zt(this)){var e=Jt(this,{object:this.v||this.s,name:t,type:qi,newValue:n.value});if(!e)return null;var o=e.newValue;n.value!==o&&(n=m({},n,{value:o}))}if(i){if(!Reflect.defineProperty(this.s,t,n))return!1}else gn(this.s,t,n);this.un(t,n.value)}finally{bt()}return!0},i.m=function(t,n,i,r){void 0===r&&(r=!1);try{dt();var e=this.Gt(t);if(!e)return e;if(zt(this)){var o=Jt(this,{object:this.v||this.s,name:t,type:qi,newValue:n});if(!o)return null;n=o.newValue}var u=fn(t),s={configurable:!pi.safeDescriptors||this.l,enumerable:!0,get:u.get,set:u.set};if(r){if(!Reflect.defineProperty(this.s,t,s))return!1}else gn(this.s,t,s);var f=new oi(n,i,"ObservableObject.key",!1);this.nt.set(t,f),this.un(t,f.jt)}finally{bt()}return!0},i.p=function(t,n,i){void 0===i&&(i=!1);try{dt();var r=this.Gt(t);if(!r)return r;if(zt(this)&&!Jt(this,{object:this.v||this.s,name:t,type:qi,newValue:void 0}))return null;n.name||(n.name="ObservableObject.key"),n.context=this.v||this.s;var e=fn(t),o={configurable:!pi.safeDescriptors||this.l,enumerable:!1,get:e.get,set:e.set};if(i){if(!Reflect.defineProperty(this.s,t,o))return!1}else gn(this.s,t,o);this.nt.set(t,new ai(n)),this.un(t,void 0)}finally{bt()}return!0},i.Gt=function(t,n){if(void 0===n&&(n=!1),!b(this.s,t))return!0;if(zt(this)&&!Jt(this,{object:this.v||this.s,name:t,type:"remove"}))return null;try{var i,r;dt();var e,o=Yt(this),u=this.nt.get(t),s=void 0;if(!u&&o&&(s=null==(e=An(this.s,t))?void 0:e.value),n){if(!Reflect.deleteProperty(this.s,t))return!1}else delete this.s[t];u&&(this.nt.delete(t),u instanceof oi&&(s=u.jt),yt(u)),this.bt.reportChanged(),null==(i=this.on)||null==(r=i.get(t))||r.set(t in this.s),o&&o&&Zt(this,{type:"remove",observableKind:"object",object:this.v||this.s,debugObjectName:this.tt,oldValue:s,name:t})}finally{bt()}return!0},i.gt=function(t){return Qt(this,t)},i.At=function(t){return $t(this,t)},i.un=function(t,n){var i,r,e=Yt(this);e&&e&&Zt(this,e?{type:qi,observableKind:"object",debugObjectName:this.tt,object:this.v||this.s,name:t,newValue:n}:null),null==(i=this.on)||null==(r=i.get(t))||r.set(!0),this.bt.reportChanged()},i.et=function(){return this.bt.reportObserved(),En(this.s)},i.it=function(){return this.bt.reportObserved(),Object.keys(this.s)},n}(),Zi=h("ObservableObjectAdministration",Qi),tr=0,nr=function(){};Fi=nr,zi=Array.prototype,Object.setPrototypeOf?Object.setPrototypeOf(Fi.prototype,zi):void 0!==Fi.prototype.__proto__?Fi.prototype.__proto__=zi:Fi.prototype=zi;var ir=function(t){function n(n,i,r,e){var o;void 0===r&&(r="ObservableArray"),void 0===e&&(e=!1),o=t.call(this)||this;var u=new Ki(r,i,e,!0);if(u.v=j(o),c(j(o),Kn,u),n&&n.length){var s=Z(!0);o.spliceWithArray(0,0,n),tt(s)}return o}w(n,t);var i=n.prototype;return i.concat=function(){this[Kn].at.reportObserved();for(var t=arguments.length,n=new Array(t),i=0;i<t;i++)n[i]=arguments[i];return Array.prototype.concat.apply(this.slice(),n.map((function(t){return un(t)?t.slice():t})))},i[Symbol.iterator]=function(){var t=this,n=0;return wn({next:function(){return n<t.length?{value:t[n++],done:!1}:{done:!0,value:void 0}}})},y(n,[{key:"length",get:function(){return this[Kn].Xt()},set:function(t){this[Kn].Wt(t)}},{key:Symbol.toStringTag,get:function(){return"Array"}}]),n}(nr);Object.entries(Li).forEach((function(t){var n=t[0];"concat"!==n&&a(ir.prototype,n,t[1])})),vn(1e3);var rr=_n.toString;["Symbol","Map","Set"].forEach((function(i){void 0===n()[i]&&t("MobX requires global '"+i+"' to be available or polyfilled")})),"object"==typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__&&__MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({spy:jt,extras:{getDebugName:pn},$mobx:Kn}),exports.$mobx=Kn,exports.FlowCancellationError=Et,exports.ObservableMap=Wi,exports.ObservableSet=$i,exports.Reaction=yi,exports._allowStateChanges=Q,exports._allowStateChangesInsideComputed=Ot,exports._allowStateReadsEnd=at,exports._allowStateReadsStart=ft,exports._autoAction=_i,exports._endAction=Y,exports._getAdministration=bn,exports._getGlobalState=function(){return pi},exports._interceptReads=function(t,n,i){var r;return Hi(t)||un(t)||ui(t)?r=bn(t):an(t)&&(r=bn(t,n)),r.dehancer="function"==typeof n?n:i,function(){r.dehancer=void 0}},exports._isComputingDerivation=function(){return null!==pi.trackingDerivation},exports._resetGlobalState=function(){var t=new li;for(var n in t)-1===vi.indexOf(n)&&(pi[n]=t[n]);pi.allowStateChanges=!pi.enforceActions},exports._startAction=J,exports.action=gi,exports.autorun=gt,exports.comparer=Pn,exports.computed=Qn,exports.configure=function(i){!0===i.isolateGlobalState&&function(){if((pi.pendingReactions.length||pi.inBatch||pi.isRunningReactions)&&t(36),bi=!0,di){var i=n();0==--i.__mobxInstanceCount&&(i.__mobxGlobals=void 0),pi=new li}}();var r,e,o=i.useProxies,u=i.enforceActions;if(void 0!==o&&(pi.useProxies="always"===o||"never"!==o&&"undefined"!=typeof Proxy),"ifavailable"===o&&(pi.verifyProxies=!0),void 0!==u){var s="always"===u?"always":"observed"===u;pi.enforceActions=s,pi.allowStateChanges=!0!==s&&"always"!==s}["computedRequiresReaction","reactionRequiresObservable","observableRequiresReaction","disableErrorBoundaries","safeDescriptors"].forEach((function(t){t in i&&(pi[t]=!!i[t])})),pi.allowStateReads=!pi.observableRequiresReaction,i.reactionScheduler&&(r=i.reactionScheduler,e=mi,mi=function(t){return r((function(){return e(t)}))})},exports.createAtom=_,exports.defineProperty=function(n,i,r){if(an(n))return n[Kn].h(i,r);t(39)},exports.entries=function(n){return an(n)?Pt(n).map((function(t){return[t,n[t]]})):Hi(n)?Pt(n).map((function(t){return[t,n.get(t)]})):Ji(n)?Array.from(n.entries()):un(n)?n.map((function(t,n){return[n,t]})):void t(7)},exports.extendObservable=Nt,exports.flow=Ri,exports.flowResult=function(t){return t},exports.get=function(n,i){if(Dt(n,i))return an(n)?n[Kn].lt(i):Hi(n)?n.get(i):un(n)?n[i]:void t(11)},exports.getAtom=dn,exports.getDebugName=pn,exports.getDependencyTree=function(t,n){return Rt(dn(t,n))},exports.getObserverTree=function(t,n){return kt(dn(t,n))},exports.has=Dt,exports.intercept=function(t,n,i){return e(i)?function(t,n,i){return bn(t,n).At(i)}(t,n,i):function(t,n){return bn(t).At(n)}(t,n)},exports.isAction=At,exports.isBoxedObservable=ui,exports.isComputed=function(t){return Kt(t)},exports.isComputedProp=function(t,n){return Kt(t,n)},exports.isFlow=Ct,exports.isFlowCancellationError=function(t){return t instanceof Et},exports.isObservable=It,exports.isObservableArray=un,exports.isObservableMap=Hi,exports.isObservableObject=an,exports.isObservableProp=function(t,n){return Lt(t,n)},exports.isObservableSet=Ji,exports.keys=Pt,exports.makeAutoObservable=function(t,n,i){if(s(t))return Nt(t,t,n,i);var r=sn(t,i)[Kn];if(!t[Ei]){var e=Object.getPrototypeOf(t),o=new Set([].concat(En(t),En(e)));o.delete("constructor"),o.delete(Kn),a(e,Ei,o)}dt();try{t[Ei].forEach((function(t){return r.o(t,!n||!(t in n)||n[t])}))}finally{bt()}return t},exports.makeObservable=function(t,n,i){var r=sn(t,i)[Kn];dt();try{null!=n||(n=function(t){return b(t,Cn)||a(t,Cn,m({},t[Cn])),t[Cn]}(t)),En(n).forEach((function(t){return r.o(t,n[t])}))}finally{bt()}return t},exports.observable=$n,exports.observe=function(t,n,i,r){return e(i)?function(t,n,i,r){return bn(t,n).gt(i,r)}(t,n,i,r):function(t,n,i){return bn(t).gt(n,i)}(t,n,i)},exports.onBecomeObserved=St,exports.onBecomeUnobserved=Mt,exports.onReactionError=function(t){return pi.globalReactionErrorHandlers.push(t),function(){var n=pi.globalReactionErrorHandlers.indexOf(t);n>=0&&pi.globalReactionErrorHandlers.splice(n,1)}},exports.override=Dn,exports.ownKeys=Bt,exports.reaction=function(t,n,i){function r(){if(l=!1,!p.J){var n=!1;p.track((function(){var i=Q(!1,(function(){return t(p)}));n=v||!b(s,i),d=s,s=i})),(v&&i.fireImmediately||!v&&n)&&a(s,d,p),v=!1}}var e;void 0===i&&(i=Mn);var o,u,s,f=null!=(e=i.name)?e:"Reaction",a=gi(f,i.onError?(o=i.onError,u=n,function(){try{return u.apply(this,arguments)}catch(t){o.call(this,t)}}):n),c=!i.scheduler&&!i.delay,h=_t(i),v=!0,l=!1,d=void 0,b=i.compareStructural?Pn.structural:i.equals||Pn.default,p=new yi(f,(function(){v||c?r():l||(l=!0,h(r))}),i.onError,i.requiresObservable);return p.Y(),p.Z()},exports.remove=function(n,i){an(n)?n[Kn].Gt(i):Hi(n)||Ji(n)?n.delete(i):un(n)?("number"!=typeof i&&(i=parseInt(i,10)),n.splice(i,1)):t(9)},exports.runInAction=Ot,exports.set=function n(i,r,e){if(2!==arguments.length||Ji(i))an(i)?i[Kn].dt(r,e):Hi(i)?i.set(r,e):Ji(i)?i.add(r):un(i)?("number"!=typeof r&&(r=parseInt(r,10)),r<0&&t("Invalid index: '"+r+"'"),dt(),r>=i.length&&(i.length=r+1),i[r]=e,bt()):t(8);else{dt();var o=r;try{for(var u in o)n(i,u,o[u])}finally{bt()}}},exports.spy=jt,exports.toJS=function(t){return function t(n,i){if(null==n||"object"!=typeof n||n instanceof Date||!It(n))return n;if(ui(n)||ci(n))return t(n.get(),i);if(i.has(n))return i.get(n);if(un(n)){var r=qt(i,n,new Array(n.length));return n.forEach((function(n,e){r[e]=t(n,i)})),r}if(Ji(n)){var e=qt(i,n,new Set);return n.forEach((function(n){e.add(t(n,i))})),e}if(Hi(n)){var o=qt(i,n,new Map);return n.forEach((function(n,r){o.set(r,t(n,i))})),o}var u=qt(i,n,{});return Bt(n).forEach((function(r){_n.propertyIsEnumerable.call(n,r)&&(u[r]=t(n[r],i))})),u}(t,new Map)},exports.trace=Gt,exports.transaction=Wt,exports.untracked=ot,exports.values=function(n){return an(n)?Pt(n).map((function(t){return n[t]})):Hi(n)?Pt(n).map((function(t){return n.get(t)})):Ji(n)?Array.from(n.values()):un(n)?n.slice():void t(6)},exports.when=function(t,n,i){return 1===arguments.length||n&&"object"==typeof n?Ut(t,n):Ht(t,n,i||{})};


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],26:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],27:[function(require,module,exports){
assert.notEqual = notEqual
assert.notOk = notOk
assert.equal = equal
assert.ok = assert

module.exports = assert

function equal (a, b, m) {
  assert(a == b, m) // eslint-disable-line eqeqeq
}

function notEqual (a, b, m) {
  assert(a != b, m) // eslint-disable-line eqeqeq
}

function notOk (t, m) {
  assert(!t, m)
}

function assert (t, m) {
  if (!t) throw new Error(m || 'AssertionError')
}

},{}],28:[function(require,module,exports){
var assert = require('assert')

var safeExternalLink = /(noopener|noreferrer) (noopener|noreferrer)/
var protocolLink = /^[\w-_]+:/

module.exports = href

function href (cb, root) {
  assert.notEqual(typeof window, 'undefined', 'nanohref: expected window to exist')

  root = root || window.document

  assert.equal(typeof cb, 'function', 'nanohref: cb should be type function')
  assert.equal(typeof root, 'object', 'nanohref: root should be type object')

  window.addEventListener('click', function (e) {
    if ((e.button && e.button !== 0) ||
      e.ctrlKey || e.metaKey || e.altKey || e.shiftKey ||
      e.defaultPrevented) return

    var anchor = (function traverse (node) {
      if (!node || node === root) return
      if (node.localName !== 'a' || node.href === undefined) {
        return traverse(node.parentNode)
      }
      return node
    })(e.target)

    if (!anchor) return

    if (window.location.protocol !== anchor.protocol ||
        window.location.hostname !== anchor.hostname ||
        window.location.port !== anchor.port ||
      anchor.hasAttribute('data-nanohref-ignore') ||
      anchor.hasAttribute('download') ||
      (anchor.getAttribute('target') === '_blank' &&
        safeExternalLink.test(anchor.getAttribute('rel'))) ||
      protocolLink.test(anchor.getAttribute('href'))) return

    e.preventDefault()
    cb(anchor)
  })
}

},{"assert":27}],29:[function(require,module,exports){
(function (global){(function (){
!function(){function t(){this.table=new Uint16Array(16),this.t=new Uint16Array(288)}function f(f,v){this.source=f,this.sourceIndex=0,this.tag=0,this.v=0,this.M=v,this.J=0,this.o=new t,this.u=new t}var v=new t,b=new t,M=new Uint8Array(30),J=new Uint16Array(30),r=new Uint8Array(30),e=new Uint16Array(30),a=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),n=new t,i=new Uint8Array(320);function o(t,f,v,b){var M,J;for(M=0;M<v;++M)t[M]=0;for(M=0;M<30-v;++M)t[M+v]=M/v|0;for(J=b,M=0;M<30;++M)f[M]=J,J+=1<<t[M]}var s=new Uint16Array(16);function u(t,f,v,b){var M,J;for(M=0;M<16;++M)t.table[M]=0;for(M=0;M<b;++M)t.table[f[v+M]]++;for(t.table[0]=0,J=0,M=0;M<16;++M)s[M]=J,J+=t.table[M];for(M=0;M<b;++M)f[v+M]&&(t.t[s[f[v+M]]++]=M)}function c(t){t.v--||(t.tag=t.source[t.sourceIndex++],t.v=7);var f=1&t.tag;return t.tag>>>=1,f}function h(t,f,v){if(!f)return v;for(;t.v<24;)t.tag|=t.source[t.sourceIndex++]<<t.v,t.v+=8;var b=t.tag&65535>>>16-f;return t.tag>>>=f,t.v-=f,b+v}function d(t,f){for(;t.v<24;)t.tag|=t.source[t.sourceIndex++]<<t.v,t.v+=8;var v=0,b=0,M=0,J=t.tag;do{b=2*b+(1&J),J>>>=1,++M,v+=f.table[M],b-=f.table[M]}while(b>=0);return t.tag=J,t.v-=M,f.t[v+b]}function w(t,f,v){var b,M,J,r,e,o;for(b=h(t,5,257),M=h(t,5,1),J=h(t,4,4),r=0;r<19;++r)i[r]=0;for(r=0;r<J;++r){var s=h(t,3,0);i[a[r]]=s}for(u(n,i,0,19),e=0;e<b+M;){var c=d(t,n);switch(c){case 16:var w=i[e-1];for(o=h(t,2,3);o;--o)i[e++]=w;break;case 17:for(o=h(t,3,3);o;--o)i[e++]=0;break;case 18:for(o=h(t,7,11);o;--o)i[e++]=0;break;default:i[e++]=c}}u(f,i,0,b),u(v,i,b,M)}function l(t,f,v){for(;;){var b,a,n,i,o=d(t,f);if(256===o)return 0;if(o<256)t.M[t.J++]=o;else for(b=h(t,M[o-=257],J[o]),a=d(t,v),i=n=t.J-h(t,r[a],e[a]);i<n+b;++i)t.M[t.J++]=t.M[i]}}function y(t){for(var f,v;t.v>8;)t.sourceIndex--,t.v-=8;if((f=256*(f=t.source[t.sourceIndex+1])+t.source[t.sourceIndex])!==(65535&~(256*t.source[t.sourceIndex+3]+t.source[t.sourceIndex+2])))return-3;for(t.sourceIndex+=4,v=f;v;--v)t.M[t.J++]=t.source[t.sourceIndex++];return t.v=0,0}!function(t,f){var v;for(v=0;v<7;++v)t.table[v]=0;for(t.table[7]=24,t.table[8]=152,t.table[9]=112,v=0;v<24;++v)t.t[v]=256+v;for(v=0;v<144;++v)t.t[24+v]=v;for(v=0;v<8;++v)t.t[168+v]=280+v;for(v=0;v<112;++v)t.t[176+v]=144+v;for(v=0;v<5;++v)f.table[v]=0;for(f.table[5]=32,v=0;v<32;++v)f.t[v]=v}(v,b),o(M,J,4,3),o(r,e,2,1),M[28]=0,J[28]=258;var p,Q,O=O;function g(){}O=module;for(var A=new Uint8Array(123),S=25;S>=0;--S)A[48+S]=52+S,A[65+S]=S,A[97+S]=26+S;A[43]=62,A[47]=63,O.wasm=function(t,M){var J,r,e=new f(t,new Uint8Array(116210));do{switch(J=c(e),h(e,2,0)){case 0:r=y(e);break;case 1:r=l(e,v,b);break;case 2:w(e,e.o,e.u),r=l(e,e.o,e.u);break;default:r=-3}if(0!==r)throw Error("Data error")}while(!J);return e.J<e.M.length?"function"==typeof e.M.slice?e.M.slice(0,e.J):e.M.subarray(0,e.J):e.M}((t=>{const f=new Uint8Array(72374);let v,b=!1,M=0;for(let J=0;J<72374;J++)v=t.charCodeAt(J),13!==v&&10!==v&&(61!==v||b?(b&&(b=!1,v-=64),f[M++]=v<42&&v>0?v+214:v-42):b=!0);return f.subarray(0,M)})("5GQ0]-\f-.N2L^\",DJow@1+8z\b?mu[?||<~t\\?&(\t$GVv!h'[Wss^~^H|{sr,AX!{|kz}5?\\~]o(, v:ydXoIWtat=@\t!]p'QsWp|^#la\b=}u N_re__)]\\{e=@^WMwPiSu \b&&^yYN\tt3u\tQ\\O\"^h)DsUQDmWNKzMGh=@bIAyvx)\f|iH~6|bz=@\vvR:Dk6S!\by+l\v=M'#&du\tA=@=J%'#\tGy9%\tGy$\"+Yao$3yvPey*=JSR1;su(u4d7=Mfq[}/w{C:Wpr0^?EWL4P/:K7oWg5+&l$\"-dW[(!:,\"1BA-D>v9?_X7sI?gT2H,,``iDw3]h.$\"ndGl*Xfz?-uUd^[>'A!-{U<\fD<7-Sl/Un,Im:0rd*\v6wo\b>l]!Ia/mygN=MT)7(\b\by=@n_k}w%\tBYgUJw9#`!`8_0j{'Q(aouz:B#Lr[a2Y\\uK[aP`qp$=@&uoK5hy})&pTt|xJ&@@BD>9QQ%Do%=}ipqWi=@vH'=@\v`UzE`?A7\v[7tcR6=@Zs5/)V0^jl[B~E7=@gK4!.x\fl8uX'Y2~%nx\\i>*Zmu+wt_\b'$*d/(|.1aByUk{_L7j!^'\v+B,LS@W1Z:iFX\"\faT)|\bxY=@\vv9Z:ECFZP:eg\byYTXHb/r(e\f(&h{%[Q$$H4=J+3=@Ufl.S.V7%-s;!MwO;99VQ}o0Qf'uH 7%ADq#L,dSt9dQ=Jo:a\\+:=@]]s7_O2.bD=@ka.kU_EU!jfB\\@H^`lwu{\"s1NvlR`B8o2GK?Wna0G9l?6~1k#Rj_\v\".*z@<}@/3{w^|iMi$}n'>y$MyK?($x\t\\rD~@VQg.g}p\bOn0F!S)])=J8)_(;x-Ng1OFi_eN<N_?S_y\bXhv-H(\"e!qi[\\cf*km&s sk*wZjCfhq=}qw3RE\fgQ~7Y1dW.hgI'IL'jv:i%6=}=J=@5m9 _7*xdeCD\tw!5l]u +]% -/z(wKTp\"9+Mpb3EJD:P`C=@'Z8]$_D^KxibTC:9')*sISw|RoY//lBD@EXlPr1[N].EsI$'8l_7^n;gIP^n!bw.WYS)BMvP~zRQ|s\bgBW('L{iTI8rnp\tvxX[@h\f;0GlB6g^NGLX-;]N?AQ>_({=JVc$^=@=}-g)prks=M6}c}t=}tn\vK=M,9*N0[=@VP=}RuR)\t$=}Q(&f>@7qXrH?1=}pU-wj_k!#Nx?\f{gqVKF;_7aoN&)/l}C3\\RF_k3}roXkRV^No;2@6ql8J%pibIlFDW[K\t?1(%N3>#?&lao;UACrtf-O\fpm2=}M7}rizfx7!V)#)\f$\"6(&CU\bj[+\\>lFRl5&VE w1o*Tx=M6tz~Z+=@t`iwS[|\v$]QK\t#qYA4j^v\f|@Y!=Jab8hZ`.\t=}$\bpft+t[ZwY=}|Z`=JSZo*;HYQ\tY~tomWp<sy.KfVo-)\"cv,m71@Tt<!5~Xt\boS9_VN=MY{M&WA>uelA{[A1~Yb\bAvQ#K-=@n,{`R^9Xuvb$n}o7~K?b\"N[ZLsIEG#!}F\bv%5Qks;<A=MDct_H\v<JB)=@RPM\b$C'pJ0;m3B70t:QwvPvO(am_FloprqJ\\v=@Rt=}W=}]pY\fs]M$|x4>\vd5`\bdvPV3zn#58_gHzZ]ch gxe?k:QaVo\v=Mn7S\\g8/}Dd.g>V=}:9uoJ -Z74|=}=}@~=})FvdSIlc-=JwHpZM14,W<vI(Eh\\GSzsD-y; >=Mcw,Oh?Ns@DR0\"fV}{Up_\"Lw{qxH@t1Jyu:WLC*D;<b({5=@ZI=}a#hX\fUP`)K348\faI?hYYQ,.2G6nCN#@|\"^gWoS8>6aG@Y4=Jpl=J?9^R}dPv=}NUt7YZKV`#Y@_Fv{.Dc *A}G#}TV`\v jgAU+#4WEsxIPjld?BFC,rX/{@7qA=Mo{v5\b^5;9d0#WJwsg1=}-~U=MD@_fi=}=@axqjT36>Cvw8+\\I+Aed]yE*.[2vf/B]%-0 Q,^?E'i\b(0e]j5~=@H=}?XPRm!=MUPIH6?0;]TB;]!L5Y\\ex/+#|7(LkIZ\\6=}s[=}K=@\vp\vj=Md2E]H52l\f>=M:\"7A?Dz2V8$`H]#/O30Al\fpk4kM0.dwcMz=Jstse#=J@s.`g{YJfc\fm)a)c$'fZV.+1)=@}&X.Nc#Dl>'j8B<=M{ak8Y#lL{Vr!caFHO]S{pZ_\tO$i24U\\l|a=}e)$Q2,YOoM1qxAav|]9x8^CX#U$\b!`;q\tII+v[FqjFY7[A%kq\b:7mTQ\\fjm=@DoN+[T6=J<H7j4TpI-%vK\fl\")d[F@:7ZO't-}=MCp=@bH-wwz>p(;D*2S,\tV&\\r0Z3P{9R`gVR2e02*o,]G7\f1&=@+Y_F>T\feKC=M`e.N\bZb7;Mx@b\v9aU=}|9\vv&K#q+L5aj\t'\tO$t>Q4{>;`,ZV.\tHH|W.]b1GG@lzeU)W9\tI`?1a?\"aY}k9x:J1ph+l.d\t$=}.F@ex7skBR9@>S'R1g'LHtP&0Y`L|Smr\\\\Emz^aR\t1-6B#oyX\f(P9_IC=J+\t]$dW94hxc ''\b&0sS\"\\:u*`=@oiA`Hgwa0V*\vuYDuQ{*;_t=M'od9WXE=Ji>2S.\\O+2/xuX\\EwLx\taZ3#k!U=@E=@8\tL\f=MFX)gf`qVFX)bzWeqEJf0{k g9=@$,Q\fY\bfCQHs=J=}t}Y$wYVg''=@A-'Yxee|,U\\F[SKKPosPNT6xzN^QM`\vGQ&$c\\=JSc+7Bd|\t4J#q=MqY\bQ_/7SgeZ}\\\"ae2N-mA\te6cR^]OLH`Z[xENii\tW6mr];^IznY-d0&[{XjM=MN.X=JM+-!)q0b&]S?+[t.BKLXvjXa1\fP~MJX=MmzZ i:pN7Us9WMERv$<D\"REZmE&#@=J1^+G3@OvIt\bd>';G/P`YX{\t]Nk)4a-p|0EpOp7E>IAaL-\v9Jj['Ti;.k6Ov30#pH;7x>tb[D)\b3W99#0z5%$tFO[X&;xzLdT#8ra;rTZQHW=}}=@4]NR9-RlD#cT%B=JY]Nt%CcR[/n_cc^S!KAMe1}'/D@u\fu,uR6~CRy\f!C>DI1WZG&T\tuHK)!{Fi4R\tp{W*=JQV #=}.I=@0{. 8a c^!$p\vG9YK.P(WV]>\v9uTZ}V2xzW=Jtki*9D#\"!:_,Y7{z;aj.kb-l%+qC3Tvt}9h+5/U3MmuS\b3Rj)L\f2B =M.BY1/x3G$XK33=J5KYx|u=Mg'^-keKTl@*a?w=}HMFcz=};I/BTw=}9c:MFH(O\bA@*q\f=M=}C9Z{P,~UiB%kJ#j=@*=}X\tVL\"4iq_a530dw=}A@t/&pQ&%b^.~C\vca5wg\vt6=@XB|S/}lf5Dw<kW]xZ:m%51=}H^Lt\t+1?/s\tK AnPA$c\v[T`%29bU( <Hw*O=MUGPewr>hE=MKWR%qH<G`OseJ#n}\t\\043i=}@$@6l\t^@VM:PmD\feGW?VSPBsGbtU3[Sky=}j\f*cDcEG01kMM?wJ5Tp=}d?x&5d,PhhR`pLxeRZ\t&A\f3:>'q/NoVC/ U''9\b>\baj=}&=@JK|>S{V%KB\"xqFkb|SZ$w/%\t4A~t8[&7DDq\f=}S{J)tsBU\t;<yZw&4/<!l,3>>(_FVP?H#()'#,fK3IC`&i?JZye%]S=M(=JfB8*#C6{Kd<yCdK\"kwJ4?# \fgW#=@do{nISvUO[JR@A3S=}T(~G+tzNCo8/@Za4@}\"lKJ{;>?`=MFxqb}=M6REQ \bs\vf\b;\fgoE\v:hZDKDfJ~y\f/M?!+}{m/@@; *cY\v=}=M=MK\v=};3jqApJ4_\t4N7l\vC|y;Y\t~UZ/2M1YG3HCHn\"%=};9l=@Ql0m7/<b_4)`8oSH~c%$=JfEn=Mw/@bB*%BF=JZB@-Htt|os-^Ew->\t+94=}6V>*`|I'm\\@OB838_*u-XF/[V|}\\SeHg2X'cWvbA[o(b.5$in5x]gU}~V:;R)ZR0\t|X#q9\\\tuiu&d#[#'^1s1M`hi? Sp=@k=@;=@1a^`k9$&LHAQ/@T|Q~yI=J^Hi:Qb\b'rgh`|S'H#.[=M\v$e\f]epI5'ZH!q\fWUGa\bp#>?\bKjm[Zbpt45r<\vfX4l\f=M{[]Bho;=}2uCaR+q#[J\bo:!\bw99Sm;=@48s%J[o6JZWun7-^<.O4Nk):q{pB}\"AG;K\"'getUEGJ9`ms  \ftY[C?1n@Rk=}HAE0{&p&#$7h[|n WP2aRA#7;>?\bm<%[Z~M5*8[\to)SVUb=M<f7eAVdQ*{UV3/BiM=Mvl+=@Z5tPI[0/&4}\fb>\\t|Kr[I=J;Rd#KWe]\\~}p!,{yw Z&K9#5lQFPy(R;F^0Uv#s}_{Ra=JRqGH`[r2ucQ/}\fTUW=MU\vwgME:wnliBMXQ*A=@bXV1nqG=JLu>(dX'&@Pz-:#X7nh>TuM9Y=Mz1O<=@VsE\vvl2<>A{!xuB8z{8{\"XK_.22DXO5C34bA8ebP@n{'<JJi$tv}MK!=@^Ye'>%\tE%>'A\fH}kO9TPL4=}|3m7o}\bm3%UI$^'hQj`fY8 2``V NpO6 <Toc!i6g?Hxe|=@R%=}gfA\b^=JJ'g`NWClEJr\fOdq[5Q2wx9&e886j=JiB9\fW}rSmyv['RM$O l=M~DxZn=M!_=}^y]ex++diTK`*=M7=J%omN\\_ye%oNTRtL 7gt2=J?@G\tF_Q0uG`2U1\b5\v(\b@z?I.3b3Cm$iFs%14<cv'xm>D=@KC<=}$D0D,j:A.P_2>^ J$,k: \f0+h.z[Nlxz}Hx=MG#8K W}$}S%?^M&,^DRzxoQ6V%0\bNkIeHnld*4V+F\vp`D:3k}P\\M]@l(K>=}3,:=@k?/\f!=}k=}a$J=MqXWmF4BMLvP!Ly^\vwQLC$?\bnbPqvmpWZ=@i6ftAkaAaRoRln6\b%=Jb,>t=}w}z73bJ \b,c(1.EgIG:0{M1f7W/G*+/[4z<\"J,(N2)AUT`Z&H/$C1<%#e.|v?TI7A`}oz^uknl3\"?W^h0NNl!?ovS>5i>=M}7f}QvX]85I``!|_dSC=}(mXk^3JF'\fD}4b+'m26!bPF |CD(%=@Z<As: _\vd&[aX?fV=J=}rW\"Zb/8Gu}&C[${`(El\v=@c|L]S25 p1B\"oQ[=JRwqJ#'r.gf=}=J$\bpo2I=@8HZdlnar~y1Xk#0j>Ncob[N8=@\b(U4cGd'Z\vk'S##7E:ZrdYW~PSq%Fqe^G6*|,x_;M;LZJKp:lV*`\b%]\"xrI\"eQ;=}CF=M\v &(=}(=@i?un9;M{x>\bq<KBf=}=@(=Jgf}]F{#,w~y#fVN3@\t;}Q\foOx9}>I Fv3M{b.FBoTwI=M<iZ`$XVOa7Sk\t4>?4\\=J+{o#<si=JZ|=MmSFZTfQK\tKEjtWv#rtUV#x]b}U}s!|=}nv44'xQ(r&NwWG\f> \ts\\j*@Ul%g\v?qcI}z=M$0r}9\fVvU_\"?~=M%}tWUNum[!smQk\fu&&TYZsLA%g% F<P{a6x\\5~u.}SU_\b7\b4eLWy=@-7AOVXtSJgr${^=J#*S\"f$6 cJp5tMONSVErlEUoV<\bHWHQIDegEo]O?0fy}(s/`V-7B`1Q}cwqtiPPEr0RtXn=}]$\"*v@{B~F[D?.v,A#=M-7|sgQzp\b=Jq\f(\f99__?=JKI=J^=JrG=}{SSV9#s=}\f>qY6hfa5O!_rhYs<\bU#y'iX!S%qT,Cps[Mr>E<- --$+%\bvk/of=}\tm7B GV1J=}`xju87.\f0nYF!SaARi]Gbiu61=MDu/Y,\t<l.^[<|^L4Nu=MO}$GULo\\aFbM>H=@;SMFgft~b471M1Ph\":`=M2>v\t'&lU)K&u( hY`T!=JK(li9j\t\"N\fQP`\\0O3[SG94t+AlsdJSaDf;y+pINuW_h_1qvX\\\";IbG+bn,3Hv8ZZYAbd0|W+=}2\\O>%.k3C6E4c)_tEY7=Jdxn.rUm{{nrD=}AuL!T\\k&pFiV%b0r=Js,WRJJyZkFOu-YM\bR@OQosJu4Y7 iH\v=M\"sP/|*t@JS](Lm\v=JD40_4'\\/O$c8ebDtio7%8R8$OJz0Sk>8f$^~$Ue:90ufDg4no6/Gq%\fny$Rhh0N[vJH[:4&{4K YR?gZ.f\f=J7q)!r>!&\v)`wTCsObE#XW>EZAhqw=@,PF{6 k%8v#V|QTL.&XDX\bn4!8Cia3yE(F/su-\"eC7zXG~bP\"__#,\"mufudi$V'=}K=M\va>xjLISt+6~c0GyW*OHj:hWK<U<L=}iQKHC\tqq>=}I7-k+&V)m?4.rMM&RumVq;'V}DJcmQ\"RH9Qh\fc7[O#iJJ?\b~wxe3c(TgEP^T2;6\\mY6V]d=@^J0W0\b^}9F[cn7e=MHpSjkvf5a=M[AoUW`sKv@=@bc,7&YX=}zW'C.t'9B.(j24h.2?=@].?hU=@m\"1^H0BvH!&'znK'Vw#i[\"Qbm?f]\fl/($\bYHCa H#!#?I)d#y||HC#39y88y8y]Q\vQ5)3Q=}#}\v&b\"=}Blscv/U}\"7-f$$h}uY ^')y&ZQbK(\tv^r#9sc&\tawa bi'$)w=}28J+x|a#fLg~9=@HAD'Cp^44`C?n(MP}|\bI-=M2`5i=@=@%Q=Jl~\tCE+d3[)m#@F0B \v\b\b^+@(\v|%K\f6~a{C^9hRx&&a~-ptk-\fTTzDpu=}25+zG|-#{\t\v]_RrJuF\fSaX]p#:t\f)$$d&+g\vX eP|f(LP%v;+&4p=}\f=}/mz8%:8#1m&}C=@b>34Q4@QQ'=}$88CDH\"7]ih=M=@xi CE-l9:<th6|NVw`^V{\\r=M=}*G=Moqa,uQFgZ+td,f'NF#'Oox=@ lv=M$!jl/|F8@%u<=@!,uNURB2V=}qoQUKg$SbT@6k\t1e;W],!5CSJ]`7n\"A?buDc@/Mq\b-`cXQc;-xg;[Bw6@0qo7k4=}*\"6j=J=},H\fa(]qo[f!'Afo{\"y4m7k7~?$G1l&rdwtww=}0-_.]O8+Q9?p_9;@ULB7cf#%P)>$=@jC'cI2\\8(.=M\bkdvF}H=}z\"6C\v1D=M+}3P%*;!t\bTho>%p9a1<\f\fL=Md:~\t[#08U1P82vd{l.@#NQ)]fqBlin\t;,1?O~f.H0!8^v\v\"\f0]$=M4T}YE]hy@=MRo[\\J+Jb\\d\bL2v%jChr\tQ1jcV]=@_GR\f_\ti>=}b-fMK=}\tD?\t\tj54Csdy#i^X}!@*)=}a#l8-\fq+9JLS_=@)K/e=}$_]]B+$M\\v\f/c Z;iJ!cLA/r<T\tlOnwBBq\\=J JHy~R)a1R8q*gJR&uF1z&Y#*}lC_=}fn:yv88`|<1N:i\v]l&DMWDg2u 0&JPONG`+EpA<a7(\bN=}Hhb>\\4KZ<GJqh|5O|.1{H^s%RX33yjvhc)\fQ\"&@s8h'*sr;sK=MQy^\\f9hM=MPPFZW\tKs)c;\f`\t$u~YTD,I\tX=MJ'\vse\tC5E\f)=MPH9bL~GPal1@*8Ot;5U}=@E2;6i=JT$7fdI=}6ucc*\\R+D\b*\v2G9BSUu&z9Uh`D=MHS]dd;=}uWOn=}<02eeWu76#,PWYc{%NP,hBx0(2'<zh=}bVht|2\tU6r4]I\tMMG=@X=M_Z\t?aRH-u S\vR77c#_DHvT.TE(6O[e0=}=Ms8C@dJ0R\b=MtlJv7u8w\bs\"XqN52GzWgP*0x(UX^GDS8sERr9pSHk(?6YX*GgNZB?O.E\\3c9iQq=} RH\\Y3\"iNl/LQ9~\b9gbI\v@\vs\\spw{ym*~\bH{MsVdr\t[ }o9Kw/D1(@^=}(xUcnhKT5=@y3c=}yu82{J=@=M4!ZF9,K_-fThF#1<Ba@tDh`\\]x~~I\f=J:*;K:& Q/C6Qv0o\fe?bBN&|s3O<6341K1mCmCiQM=J<:z3s1:g.<gS8?%AmU>S\vJ5`la-B$Q=J(L;?gle7cm`V;rF%+hG\b:Nc6U|L2Aq'CFfQi>nRc%=@[lxCi8~sW'L*5$2/Hh\b5r$RQ,egF=M,-9>-e8K2l6EzXb;~jZ,,~=}[R\v`y.o)a)f\t_`,@8K)\bmal08c,>|vh9w*Ap^\"Z&~ u?=MY3}6r\vktgKn\\LA]I5Uq{c\f~/9_-q\"`6{_\tLO0\\\\+:(\vt;r\"&#\\_oc1=Mpf\"8L\bswRZl=JKtG|^ZYZT4N;6&ZM1.sA=J+\vJ@]8,76)M0|CV\vcj=M)g\\F7(_\\6{PEDi{i?yGj6tY[-k/\vBR[sp7`;?8Ax!|k]X\\6=}Ze:\b\tDi_u/b}P=@X!l%H&uC5\"A+tDD\v62dlffd,>=@\\\"{y\\Tzq>F6a(;W/e,bu^K17m\"=}5eAQN\tjfGE>9slN*p7Y|^z?NlOd>2=@tS\\V~%oQ9 u\bO? <=@;o4.rS&I=@V#8GYFStv'{>\v&>OEi:&;r&Rwn7ZdnOisPxu=J&=}*O^ExzbWI-lV[TC^;Q|Lg=}7>C)\f1K/Lj':#-wfA8\f~c,C'5a\ta=Mf \":8xl<v2swGQ+l2|,/FboX;n7=M@KO@uEplU`<t%)!=MKLX\b)'q0^ZKN8?\vrWzl(j$qaS\fWl)J&o4};0HSV'\"Ju'p^[fcwlkqFMjVNiU;=@DsJ~'wf7h\t,wJ]8gCakWAAV?+gu<5y4|9Wp|D`S7e9>XzR+U2Y7vduwb=}|ev5BMMrO~2+k}=Jbs(z7T+{Ro;?#?Qn+ya|b:kG[M*.U\f_[[r]=@*\"p-=J+Rl~=JT@mLao@q 8yP!4HzC$0jFko:_GK0x<F% g =@_T8=J>D!Knk7?8#-/c\\AI%\"@b)T$T8UW^2OwUMqo~qQ)v7HS[qk|A WD=JWb`dw\\,Nk'TjdB5X|X+6hZ#^@:).tyV/=M7RUOS|vk\vo!ub1=M&oR)E\v@1\\a{d\"${Ac_U+zCtb?d\v=}TJ4H4\\p=}> J'iLBu6=}~v}=}&$+lopHRM|~>}%w0.FAa\\n=@;X8x ?u=J\f2\\G=}3QQ&tkvNd<N\vX4U]$r!;lN/RF7@c.Ti!*F\b1>=}A!~g?55.\"i)O%Ohd(*\\ZIsP3Sj\vR3?a&vG8k}1\"'\"=JJLh@ *~=JQ-,Ur\b)!\tZ0#\\Hm'oQ1X\v\v+N!xcbk[?F\v=J3#d.Cb!|SAKH<)?f*&-B[D?OdXBK\tr2\tWkVdEEges>M`tf>;Bh3J\\NR4Yk'+1R&-,4I}m:`gw'P^tRc9\t=@14FtcI*Ufn\";Z\b1?&4>\vIm=MK\\jMGN;.Avq>=M_9Q&mGKL/{.W`5(-g=}d}sX=@%I['\v,Tn:1?^k+I!'6OIMQ3Z/R66ooF<Yy=MS53u[\\[To+Vi-`#XZ!SZZl SS|7S!;G)hK2\"i8xx=@EAAqezN=}(Du -=}^|m}t+rm+^?`a094vS-ExVR?&j`*kn)NCM =@K>-e~{abXW)pC\\R`'HR6iS&Q?X{=M\t|\fp?rMe7\vq48%2y'Qcj\bB=}\"RDq#!f1dIK4IHIW\v=McGUMbS9\bFU|EN4;H7B=J{SL?sGBKM6P{OmX&\\3B4m\tXHi-!%\"/G\b=M\fIQGaUy\"*\"Z$nTd^@Im{\bR f=JQc>S_,1rOQ^_?g1BHO{K\be;8Hp\"`dJw`*5}u%=McpQJ=}=JKzFJgR;Cj\"~e|;\f2\"=MnV]b/?H p\\\t6qP4j2da-{\t#*p o=JuOpklMbcToXc_/D;3cp!He`jp~.`loI>Y!?vWJ|nCV$;prHP<t'-o;WI!w~aOynsg}E$O6S\tPn;*_bDE*T.f/K~\f\v*&Xc=}a0>+\f|xbZ=}BIobQ!4FkQA=}NA\v~4GgN=@w\b.}LWWFr`*0)-|}%K')f\"!X+.M\bQ+#7u@s0Odnp5HZSL1\t\"'#Qn=MMe*z5x5'\b8~^5Zbu 3?IF2y#5i]LPwSimf\\f=M9Q:=M7`],Pe%d%&6Ms'u2'7w\vR{lvl7{mA5nY*i[\tfv\t\"[Z/ac=}>K,YUF_)}@<F1~[H=Jq^p#.Vt3[+=Jfc^8h6E^+:\\;'A[3Ow&+rV,maEbK `{@mM=}XX(V!s8K;.!*=MEm=M<aQr\v=}$Aof;rX8FR<:9!=J9.y\bW*vo]\t=Jjf!JpIqS<0RYb)[.f02b)=@q+^H7ehO~\\^$NF=J(;'\b\\!cO^N`}!8i\t-q\\KI'\vgiYQQf\"Z\\}c9#'b\"nH%-Igc`k'dHm&)M\tS8&Wh>=MeS9Nuk,w=}r+eFZv*!GX\\s~J1N5i]\v.Q+HzjJ?l)TpY9D3-3ouP%[5z^5i\t2\\6*\\*^\tnKR7k1sona0m=JJ-.uko:\\Z\\ \bo_#w\fI!Nuoe2G\b-q.<lp@/9!5}D\fl8n1G~,tsV\b@k=M+bEzqHsV2U!tsyRk?jK-K24NlEB>TR3LgZqL\\gnlk8B:Bi\vT1F/>3Qc76@FCz4sEP~l[y.=JISdjLE}W! HfC?BZnR^0{\\=MT1=@m6/uFmQ\\fT2Rih8m6j6\b\tJ>L{$[#0E]kD\v\v=M/m2qN*d2=@Ax\td?PK*M!esiUoOuZhu)Xk2*oq(U-jc+\fL50h>vl#*o=J9=MZ(jZm;{P3nWI'wEzi?|h\v$6sFyKH8\b+\\OGp7Gpbhq=J1ok\b;OhlI.E_S,7ssK3SknUUo`r&U[?8T95@?0}VW4o[KvRT4EJrWCSryePVhqfv0\"j=}Z/D,Dgq:p+ x{zJ;kS*INf@QP\"SS1\blSZb\t,4:i/\fv*bd8)_a~qcRO*Zl=J\"Z.r2g=@/(67P=M8Kv44\tQ1mU=J2bBJ:Z0*qC5~`1?'.9X$B\\\\*~~1L~k'XO-v1o=Mz2>(h=JFq)\b%nWe.RD \f-=@WFR\tw|=@;\f5.pPE`jT}jax*{kd3Q=J\bry=M3t{5N,X@!WMx%O>\v.X$E=}oMLM)(:F{~_ByixhITIzC^\"2;mco%^>\fQ\\8:&QK\b.O}R]lI,'&f!/U7]]U>ok7aJk/MDlc/4CuP:u:od}:Q2E$nhrJ$nhi3hd|g%U3<iZg&m(D^sB_yo\v6RX$NCS([aj{43[}%=M Vv8~g:Y7wkT 5\\xpB'Ejd<7'tF#,=@\b[eF>qI]#-$5U*pie\fqJYMld=M\\D\fZmkA*4]:!}e7W=}Jq#\bo}A0|v\bze{.evIz#d?\"8Qg?DEhxEz~Ihw<>\brVjc$GfSpQr~a1pcoeB&vaJI`Pb\\=}}@_M>OU1w/8t(7F||\tjMG((dj&YP?5.r_hf=}L^Bx&C:'.OWT/-GUy>=Jru/4\\H ldke7=@XCt@&z^V_mex]P9'r}%@f6%r}g+$uh\\&o5AL?G0n?gZu@n9O'3r>6g}jZv{g]\bI%\bwov\\\\8r>@,F)rEBw$jJ \b;A\vJ\vBRi\"p y`CMK3w#I6KJCy9\"%9k]\t*>2l(ZY*&Z#@t=MKWgAlx?=JdG2{a&Ec&LBO9\fOp=@=@wE]~5@bsBa~\bYY[fsO[p}-i uf#e\tkCw|E ldSZtGD6\fq0-2=}zjO$6/tHC?]*>VzXE\\_C]f$\tQ=@R3n=JcNl{dM!F[3=@Mq'o\"zcXsh~\b!'t%66Uu`Fps|u\t\\p0p'A1rK8N/oYFh.%=J*3TB=@^Rk~+9:=@~x51C_^jx%gH#AL|r{FY}\f.gPkd)p!b\vAau~+00\t%rWCD=J.\tXC|QgK\b3bB&0+L]YObn\fy- iIqfW=M%HcyF\tGW)uGpUOc\b2#v/8znJqoJk|0<JhdoYTBo\bBnT]=Jw8Q^@JJX\\%{<\b{MSxV4x94XdK _H6];b.v/7\vLydlL=}%DIv3\vYd8~j/.7S3% &/_ ;!A[)Y&PU=@o7<>r'=MHi?B{L%%#q8sxh`gmb\fNC!wD_\t/\veE^7^(_eyI\ta4H~3Ea(Y6=J9=MuOx\b8\"qL'Pk\boDV++M.U\"yuG8\fV4W2PAS'GHi5ma~bq#\vna;+SvAW)S}7B|N`pV\\/1h,\tQ7>=@C{t@lw&X{G\\;SB^p\tR'}5y=MxmP9dOvp6.7I5Fy5|XMN[/i^O&3ND-=@s=@gXbdXw`Jtj1aiE3x%+*awlC-L6-!>=MfvX73QwR(e`D\b5@KePQFl[T&q >eomY{HtyY~p:4`wP.Oc!}_fr=M\fK~z8vcy-o\b/%a=J\\\fuvxu5=JC9g+vkue'F9`(=Mgza~fTvAC_|x:Pw)peoeq6bd]%@Fs>/\"6A\\#`D=@kcStiM[mj)\t'b=}:nb4fc{24[N)]@EXqouaTyHe\"K<{0@\fs'#s*!{M%f=MQvx)h,|XixpRo^w\"c,uw`Sr-P/FnEq\bukj1_ajw]=M;L?x/rt\"PhQ^A$D< oWe\"<].OJ[|w=J|}(hy8\vx/AFO1LMZP/\\N\t|lcWmLs*mwBXDd;z2+=@\tRU=}N,W>W\b#GY=@LGb(tQ{|i4MMND+&Ay`HI#=@\\mV\v=@M%nIc=@t`E8'+M9{O=}NS\bixWeC (*LG}\"<B\v33m>vH6Y^^lG?\"?\"?\"?\"?\"=MuE@uE@6g&@e_S/nNWT'1>r=@7Jq!|q\\#x=M.Nr.=MPp..=M.3Y0r.*U/0TLJ&=Jq=@vj6e\f3d3.&r.=M3PM_=}hG`fy%D\t`3@_+t9JAtZuM/WON}C_O?t'KF9>Z=}^A3!c31>@%2~[L0n\b/v8\v}4-y@8qeyX)h_Bc >9hap\bNB_{>LWqg;_ .enUF@,uM'.Eo%w\t+Ah]9PA9=}!&**<r=}(\\6*%BRdH{c:<5I/aeq\bm(&:@bT&(\v)I(RU/Sgcz|dY79.Ehh|7w[01dvQ!=@V\f^[}*va=}B5x\b5>7qc~Z!ppS8JDw~q9Ev.SD/L;P=}9rRRW=@&/id<pi<1ld5+LR<f\b(\b(&#)]qBWR^#3FQ#*eZfIEN+Zbq40WTOQ~VNRLaMaN\b&5E}&6D1Njbq;7]+aB=J}<\"\\YqE|fmSA\\i2~.V2gAjse3BOfO=}Bl,\t[X;U:d^l\b@=@O/}u[/OV$[3W6h{[@0vC|;'g52~^'#u1<=MaHXXc_Y_N$'E}l:EG&Yf]u%QDa\"'\t#,J`OwKN9=@i\t\bz8E~\vvbe\t=@n&zup>+5%y$SwC9\\LcIOU@8:U=J*k=M{5=Jsj=JBlg3xo{>XZ+*wEe*z5pEuUq+z=MR'%/z`~=M,<\fo\"v=J\bVz&*@\\.s04BE&Laf?4g--ZAh[yZJ<aJ!` %B\tNFz\t3W#'rXqlwEAy.d.6fd{go4P=}%gR+!6ww$;W3_I=@/D4v#wI+jt!XZM]J/f3|jc(#`mjL!'zdj {gGq=ME9ZdLz6k0nZ9 parsH4[8w 9w}VQ~kf\b=J4*I.qO;DLucP:4brd_9Am&Ishjm\b<hO2s:=}\v=Jqofr\t\v(Pf|e$;&qTnV\"&J_VLskYw7\bnj?5M\"mT1w=M2p95&4hYbRFq;F5X|GfIxGJnlI`e9L;{c\"7b>^e3\bt- F0O\f}(Q\vboUME;r6n74[W+Q,?$z)(QmvUK\tn\vrUWXZlPy'Z;[ysf\b-rmo\v[V6dVAw\"y[<Rh!sL@fuBGoEO\\v1DO\b<=@noH\bzP8L9`nBVDb'C&.^su:o\v:\fonHOFh|@ l>dl6[>=@4OdvS885h5#>Sl\"^x}XZW0dO\\EF]YAj~^:&$x@rl9\v\\Gbyhfx<C@E'&M-=}jB9''4)4/[/\v/zb--~dSL0.ya'4x\\/25/X*\v(AE=M#Q1rCF`whuJS)pqX0`\b=@AcUOj+FE<m z`\t#mUW&::zo*vh#3c2'pt\tRoQ%&<&J\"lu(,2+O4S1w.\tI7rRVcxJtt(%VLIbiA$,|xD!![xMorLtYQqw85S3tuz,T\"dF>F8QzrlYscOX=}BF<=@-+@|EjyN|9*\tm<9{.c(\t,iIHr^'KC:`*U;gM=MHf.UIwrqhTPf',HOA\tB=@M\\0=J8]:;|LI_>au(@WdlY>;X@UaI.71@;WeXRu,S4{!R-_n0H6`XvMz=@ftdUEq/KPL=M=Jg2ZE?T\tA:L\fLY)gt?}-%QI$~N5=}nry`/H;1WH(T9Y#rRg'Yx5|RFGy~;v\b~YF=}\f:/KP+xb%]Qr0,Nw.*:{ {ZD,h`vfFcFL=J,lFx|]D\\l;Z@i*q@Qmpu<nq\\|Z\v/ :~JNAN;rNY1w:R\fw3en}T#G1L_Q]\"8jTnT\bABldFKr|0TMr7~?l>t\\=M=}bz~{5t#1Thy>>JyB+>$W},#U,9UTp3g=Jyw=@~_z<#lIfuSgQ\vFaoJVwUfBdh*%eX5Dlvl$?t2jlSUoYy<+{qkwYAbE cXr;L{ ?,{]nT&d}#U3]vjhc\bjk0V0iLB@St];i57>7?]0W=}=JRQd[Tnk^5<'BzR X_RTm[P &X\vH!y0yAsg@~#{+JK\tU=Mn=@HuNwc`4>XM<[72w!&atHt=}e:3$ap'?r~)'z7~i~r*~WjO/CA;^TZ;j=}w$|\b:5em\\s-CfFE>,6?=}4$\\7flOVz7D=JdM6TH8=M=@VTzN,{)Uf<H7=}?%8y@X:V\b*&?-X{Wgnf9fw5^Wf->\f%\\\fGe=MG[9vlK3YCYs_{VX15y=}bI,N]]e/o&.(<)YP#.GSI5--@'Mm~9QSLt&h [A.2-Mp&=}fRl0G<=MJ)]I~5i#3+!Tr<VQujn2=MWs]ltSGY[T/sV 9O[_ 0f'q^SV>W3\t`z\v^\"@#q:st,><g_Th\\BUi]2&<=}f${Dx;c2=}dZh` |8^LNB6wMn-d\vE0/N>%838?L$$ck=JouE-j1p=}b$;>SzZwv\b$zX[Ep/M|hs4{_'n`oph5Rc9p7O9R(5yq}*n6~vQFc\\Dtngo=@;gp^*?uEKsMn#3L=MJ<\tE[qdLfTq|VK-=}\b}OTLIy1pe_V>MUwW5bV+Cwr+\\t\f<{SyxT}qzPbM'ya9?u>+gNRb04~OYy*e3|nwP/!1k(m.S\"*q>r(\v=J0h*It%lB#ZLwkD}ELQgTakC6Q_v n#z9ks)q^2iH8wj6z4F7(^0C5?S\v^\\t\bycQzYrE\t4%am\t%;T}!R=M?\"KU-Jjp&6=MaXD34XQD {{-dOGt-y;0wp#T7cga;\\RL=M=Jw2E/6HJ2Qj)LX<fE-!u*O 5TfOvU&=J!TMEy=@Sr{L1e\\C\"}WsHL}-t5SwFDXQ}8:n8*t2p+=MxW &19J=@-N00e+{\fdxtR/.=J?AiW$,.g0uTJjFk,lxrt8YEI\\uSz+?n5}1E915p[&W.c@@J7U);=JH.T-b$UEJyET=ME=M+#%h//29;!l~{#Y\f2]M!s%N)m[zC9HeoRi^+nhI_RBS^a^E2lD<xiwf!i1=MRK=}oO>oe(%{5-\"q\v\"N-N#_xH6>8)aK\vzcH?m2[e5KSdr1EX}f`!=JG<k9\v}mrT_&!jO5!&Ky-{K$uhzW$q[Xc1_!\\z#UC\f;P\",=@p'6pDa)G&}+|aDt)XU4q8{4k\b\t ej\"h>A(b ib<=M[P=J.][yd3jp+bsp)ud:wjhaCg82{s6\f\\Jxe\"[41CJ_~$\"}O$R:h\b0Cm=J:=}4&'%] RY~kFg-j1MN9=@-fO?=@j/j3T-P}2OAX-MxLi{6.xSMsv]:r-5Dvjs\\\\x>4k\b]5O=}SS*E>TPanSS\"W =@na^36M|MI}~SO\f^cQJEzq3GC\\5l=M26>SE0jMD?+{F}x=M3p;Z7=@o=J=Jt@*Rl=@^/=}\f\bHPD=@)TjY=}|k@W0<oNv$X><pdCwxt4y1\t=}1@Y]N'D]Rg]9)^qf(t>IJJNl,@-No)_z=ML=JJP:8ky\"Y:vT!Hzk!=MgJQB^o[w=}4SL7`~,;&^Ca`TYkQyPxjs\v-9k^<mPo0=}t=J(h-gjR88q\f0L\f]jz\\#v^oar**#S\b\bJ!c3lmuT{Ot4f<O\f\t 5h[`1|x%w{p=}kVPS=J,BvU=@t:UJCzkx\bXr\f\f\v83{:\bM1W\vu:;ouR)\fZ&?\tVX.AavB5r\fG:A6~Sz\f=}ON3~4A\f3hbV<A7@BSzz,+g=@2T<0`/RHJ=}k~8Z=}5dNwl\f=@r}o|f5(*OyUYM.\fM$]es7ZbIe2&7,lNAenWJHtugYkW'R,sz/<\bsfLNm58v'd&\bS^Y`\v\vmz`g.\"_nB5[=}`FK(Y^w5)4N\b^[nGi}Q<:6n/J,B+h8\fZ=MFHb~D,T5\v1cmJ+Jc(^fsR0fx.=}9nC=M{EC.S}!8I@0Qy4\bH&&@+xpnz@U]\fxizE, BX1y\fo-qMOZ6?-%bK;m4c2974con=@#s+S\"a/'v%&\tYH5+\\crc2dC\\W|+(wSIq8f2%aE:3;NJ8G{n1*i11}Lv7N2Q!J%#Fo G4};4dE\"im_UPeh/R[7#S&pmM=@*z4`JSQ\vDYH-Zj6o])\t~{EGC|{bU6D\brgdu%<\"eL\f~Pv@. Lsf-j=@-B57<=}*6\v1-0-$\vO8WJ3=@7JO1]O~[D\tF1<`FC,A]/B>(>rO=J\b0S=JzSuFsJ;9cFJa$8(,v1}[\v?K|f1qj8L/9=@ B^%S#o^jLS,FL;3hf=@%w|E}0Q`L#-_`)=JI\fa3m5D=@u&?]R\tN[xyM$)!{.IZdm\bcMN.??kzj<N2OVRl[1~@0=}?Jc)%\b9!$WKO\\.k_KE3B19pk\vlqWfj'07;xT*U/X$-FsVI251@ux=Jew &jSy|%EXZ\"!Oe[%&Tsol\b zZ2?N^plvQ90B>:5{RWf3~cx+.sr@`J<bY`TvB1isd.VRfQGrj$l:im:av8J\tR<!M?H7sM9dK|>2C`J=}\v)])}xEYL=J6[#(Fb_Aq<,\b/Csq_\\vcUq~Q5=J`fOn-C5<05\vNvs0D<6(:C1[\f=@3@bQ/dtogy#&U8':<o\fM+\f`N>{jYc>u/g+>HFp!L\t0U=ME+QH5J!N|C0}TR1w.?\vbNE/tTve8GX~;fJzer2&\"O7y=}Sau8 X-V)d\f/]kCEUKt6E(_W_=M\\}OCVv=@$[0p=}\bKh9s*T<\\1s(OP\v~3[NO`5JgsVz:y6\bp&)Z{!\\8|Na+EY=}0uAV\f.uVLV)yMQuZxLU2gN 5xzgLGNv6{Z\"{)><t*\fO&)\b\firE')9h6MxPJ&byAoq}')\"t(-2\\=Jk=}UwW+*ckBriLhH[N_S4Tzn\"M\vOM=JmI[=J)k\f@V1+|5'Al+)N*M;xLV6GDSW@zJtx,t@LTinU9uOmQ!~)P'sfDvUZf&ZLi)@@S\f[cQ:tbM\\6TnD)D`O6~g|\\7=}^faGL3$A}>OL<F$=JsQ!=MIQC\f4%=MN)QP)y6pjiHl=Jr,=@`AZX0L)#Jv&w)Pk$N)E42]1\\+g_\f3N=}KGB#.SNcc1:T&_ T7[>s=M\f?Hb::G<\\S+5/K;7f1/r|1+6X+AT=}qQCN}_@\fq05/mr|}J<=}2Y,u-6h</W-3Fa9RS\"{i0KH.\fNrOXBW=@:|}r$i0u.))zKs))]m=MUT9m[]#v>A/ MRR,J5r1@ge,r][/]IpzOdp6a<DTn@.;BP)WQ=MXsmoLk~DnQprQ~5PPmca\v4SHk|-u?uf6O\f(\\`Y9R7VB-=JT\fZ^1}tbP:aw=MJKSC[/Q1v5=J&`:V~~3;9G{@b7?%V\f[MPMa8dY=@?~YcL{KWNxP&ZT.].l=J=}SqjM10/e|OGk8,=Mx/G#Q-CFw+J'vFc=J=}kRE6s?*x/4\vE =};eO`WyuG<e@r!+w26CR4/{Ojz1^2PPx\\F}gq\\kKrr\f9rIns:Q5bzuwi\\wWP4+P&;?~=MsB5L~_\f.(LFmj+=J5,j.'cu,s*JkT<n\tr_JB~jr\fEJHmLGK^gmHwAB<YFkF+ZbKOIB.[sNN5!;@U]q`|?L\f\fY)L\bvz\vW$kquY}8'BnAkjI0E3j)k^2RkDCo2VNI\vF&\\Zqn&=}8>wFjM07+_i9Y,N2MoQs+tf,p1N:{[C|`:d|Or_\v7NfEKjvb,S0;&zX3|=M,-rIa~8J\\=J+}X$LO5$z>BK\vo73be{8s5kw}{,7^Ta1 xLAiJoo ]L7=}|{9-\\iDN7r{j=@j _d%_>~-$lHH>z8[\ffycJ;$R=J<X'yd@<)\t\\ZT,MNuw+).5[(q'=@n'n/n5@z(Yt<l*16][:pxO$)D*Uz8M=@u,E}194kd&M(7l.q]-m\t1vG\f,jb}{E?M7=}a9&K0O\fC2YLEFDu1pe0VBR[xvhVxV0]@9X1\fsV.OhXO<\\^h)4H1t/)aM3CQ>5)[\fK=MPY:y=}q{8m10q0=@c\tTCI=Mp@\vPZkQmfp\v=J@TneGi>.{T4\\:#Y=MS>yxpi|st4f6:3t%%h|\vFF9(}/c5>7AN9&!{>mb_.)tts! r!&(MOQY-/n4H\"-!pFsOLC(%ApXQ/'%pqqx l!XHVk+SRo:=MH'A%R_TY'QqzRG9%|$H/?M{\voIa:obxw]![zW\"^S5i%=@;\t\\\\w]\thOuguo}i|x-#?)!Lt ^m\thSt,e5sygL%(OC=}*$!1&Y7atrw#)l]aTtqKJ ]iywSiHx=J\"Uh.WeYgt$'h&$U_92RPiw\b_cs3\td=Mn=Mp5&hCX]\\Z\t)\b3md'=@FqmM'c?t?>/A\"(z\bV|h|uzlI!!\"]%~\t\t5G$#QSE'hi%9h%C$7(\\#Ab!HiD) G7GGe888~1i4Z=@|Nz?I;Na{{f(\"wUxsIeTLydRy{Qf2E~x\\'%4p) yt`dh01_VIm1'$h&lHz+^u!(%~7`i$(^PB'>>h)0>nI'\bSez\v/i4>(GR}O%uvCbMuSUB#w\\-|i(A%HG!=@Iawj\f\f}jjyefY~vmQY\t\tSE<zQ$'ny=J}OkPw=J5?hxX`C%pbflEBbh(935;BeQ3/5\fIqP/=JG#_71XC0pwT'gkh\v/Uf_Z!\t=M|XfZ:Bidp3`(50[=JFd)ePW\t\vq]\vOD7%-MYuUY4=}\v,-q,w^94\fLfu\"OqYh%vs_e:Y?X>\fUzFr\b;&>RP/afo=@};>a?'t\"=JKA5Yc%=My=J1\bmSF|V9!4M?\f5@(y(Jy.m(TU_#>P\"&|f*#'`|KA>=JC!#6'ta>#c&Ri4tt/H0#P3UUR\",|4IS_Q.yb\b<!058QkiUFFw8{UA-f5[:VR,(UC5Hf%SR~ojA,\vk+Obi\vKwpe\vHH\b\t^>$z\v\v\bT/M6%~Cg\\~b3~%'!Xdttv!j15mw7oV=@O[\t=J=J\f=J_tNiuuu9F<B:QOJvj(?IiS++%Ig'%=Mi&$Mq9'hi(%9ii$=J>I\twi)\t\t\by'KhEVG&f?Q1gI8=J8\bIM1eNBh^msmQOZWI1H7KE=J%po=}FV9 01mfEt-r6h0|8\b\fhZ\")q{c.mp+,#R},JGKY\bOge!K\vcF&4;Tx5DC[w}qI^1B{G?})\"7wHzG[(U;{g#17}u[]b\vq`IbAc(\b]taHg\t(~=}R'Dp'gPAY&d@'glQ=@jf(b27Ed{;^`id8tY%I>PqI63Gb M]&yh#fCC{~X !D\v[OiSb9RUhRb646y\\S)\vq_5;=Mi}kifS$LtKUfA_gt{DP-5V\"66Bz[Npx\v=JgZN\\K!iR3(i@QuVDxSm<tBh\"~@T=@T@g,A0\bzf3xRU<RQ(wbDItRSV~fIWz7Ed\t7O@(WYmr(f/i#\t-1/>5\\^=JE??`5rX4\vSh_YvDR\fj\vR0\"Y#fs@\b,N4KNgTgZYs(\\:\by|~|N@^#TTptQ;c/f26z-wTt3[tts\\WO9k1JlN1i&g)zZitwF/,ls]*bD0y,=JL4aE]f6)03MQVrJyDt\tNN\t3&M);)n>P6JcOIc&kw:W&Z!,z$vb)bqD?TY$\f;(Tw~+rA/k>)* MLnfF+dm3$N,xi.S}\\\fNoU\tMmb`TLR?4nM/1Zs\fi\v7=@@OO6B\f$(\fmhVeWK,cC! _mxH4&5nAh!=J>,&1xwU=@r|{M\\x<\"^Rrjtz_q8!#OC-=J!u=@N=@GthPcZJ*u=J$=@CC{S9=@?yu\t[}%#q^AWS4P@wo&=@2S\fL\"!1!:e9(!>8\ty9\v8(c<Kf@G\bAVu_=J6S28T<G87(j87amdIIk8u'&\\x;iz#i;/20tChbL7gaHkBz|U=@3,,`qxi?|Iy1[R'/\tIX1BCD2E/zY <!T(Z%_DSpmw'`7$!aXH's\\9CNGd>5\b^qQ9le\\[d3tF=MjC9( \bG`bev!*}g7?OWuEdj}YQmV\"pi=}6f$BTU?y=J`A<dj,=JroFU(9e)\t]a9ZEx$f)\b'n<'U}'0ST6A\t#K^tqUI\bV4{9ava~Lk.{mQWv{QT=M~g|$Nj'ihty$\v^'@T~!T8hgN]' &y=}O8Y4hc1~2{ (.yigd\\=@leR\\;\\+9F'[j$ ^p}(Xs732\tKNF8'GCx/<D&syj ((\"=J0r?c|5EEt$Ny\t\b^ot}Af~\b!`wJ-pv&)[xDMgdJt-=@\\eI`Y~OYMO 1hB^AhrLh+ SH|JqQRjg8aaNc:X&# =}Dg&(\td.k]7I0,_#\v <%hAr_7V$#p?g.-&mqydQz_aLlgwrU&gS) ^VNW'\fx#bi9ExsF)C3JrgTpOj6'=MF!FJ7\t*um6!@imp+oR36|Tib~VtyqRU=JdJH;Ny'N\tZ..r}?K2{jRuiQ->5`89jj\f/\t]QSGC)$))Y<+R+Z+V+P+U+P+D0:tZo;oC*+R=}\\?o+REJeJ:31*i.]UJJJyj.Z/L*/+*7-4/D3>0>8^0R4Fz6jIR8Rb\bP,,-*+w0/u4;2.MjLTj]FzGj@,W04FOzgDj`,04r_Pj -G.d6>ba~0M,*0duX,044GPej!H*g,,>cuj\b-.$6/E9JBe(*+~G*#-k-pk=}u:oJJ_J7JWJGJgJ-JMJ=}J]J|++*+c*c,Tl*JkjB3.KIAI2z:z2Zzjj\vj+;fzFnQ\b;Llxpx\"nn\b/CSad=}l*.*kuAr5j{8@F*re5>418WY|**-2jO*Pq.9tz1+h,G(rG*fk0+kj$}**C*T*\"l=M<*2*\v@06C9,BJR*Q^3*XA*M*72=J^,@41+-u/-r#k-*~*uZR.d8$.>6$U+JI=J[3je;j02r0k\f0\\.,=JH.=JX.=J:**e*H*3U5+l|*O*H*8U.=J+=J,A,F.=Jh,=JeeE=JJ9**P*A`QA9G*Aq2B.;?d6'F*@D70f, ,r\b/\b+j\f?*y+A+O**\fg.O.5w$h0g,;vH[00C0KW\v=JH3\vd5\"+m(\vz{~kOt*2Ew}#uW*=MQ&v}\tk15$(|~StBP8Zt{>TwIu}D\\RnIkiVoA|Zjql~VcWcvlcZ,jw|$>RmHq\v{Lyhy?tYuj\v,8|ItFRS}=}W}\t~DnmS#\b>743^jW@}Hd~5Gt3g,H$hj0D|7S#p\b4]N_Yp\vM~5*un\v=@~7$F\v1t\bI\vr(~=}dTDj0AA%1|~\ta\fovNKO:$|iIN2JE69R{Qh8$2t(Btn>h@p}&=MSPv*(Q{S^\tNJ<MS9m:95D9puG=J1,kpJ\t^t}Z86=}>Yx},dsjU|#~Tx_|~XjpI]zeGR\bpQU_\f3Se'q7\fmrFm=M+>Y\\n#?{|@| z=MTPk_x%rt(zWhq/^IucyoG^yl}|GP|]|5MlDRO)6ykXDKwv_V%V(< m{0QY=MVk{r'2mfW=MK!F#3?,<>=ME?D'S\" \\O9qhy!d4d..h=@TU=}R7~fCT\\?5~szY9FWs!G?6p(\tO\bdq$fK>m\tp.\"1`=@xeg7?\t[kq~\\06r1l30pU\\peMSEAzA)T}G;_OQI8!|k(>@{zXz`A{BQrdd]&8Pbv#bm=MHrQ.)lR=@`)V&s4'=M#I\tK#)SxTc\bj]\b0yp5fBh!K, gy=M=@k87=M#3:A$c`4S!GS!\bLh2-@lEw}=}?o7J<0$Tk58}S\t&+T$GI'pCg=M$\f[|qGu8o'XL8I<w{ |s-l_G#s=M|FG\vf3m=@b\"s?x=@10cr}DRr2#VYg~6o~4}pW9~=M_4m\v4!NpiTwi<mxmw5i7!?e\\s'n^RthL3\t#=J%A5\v-A`n/Co`@<C|PRpfvE`wW!Xg\"d!dwt3|l\\1ys9^W2{H??u%gk\tP-!r{} ^87y;uP9WC|].d\\W}hU].4NnDQ AdO'}\fzL!SIt}-WP1LOESVbKhbj6?}M/OkqD`.6_a~QTYecdn\"{,19_{KHYRQW\"iaQE}g_otlBe5MGh1$l$Tu5PQpDYI=Js\\NY]OhdL^2\b\t\b&cQnve&c7U~k!<Stq%qAd 3>\tNHESi [ \b9g9Zo\bEEg''8$~Z&z\vMlYoB%z=@Yfd=}as=Mb8nZbRX\f]UXtH^ZcZ7]\f9][=}cSVc({6f(\"%|N8{0GPCP57YjR3k\"+r?_MZO],lK_+ujN=}{~KG=MR%&Ft4Hv=@M*oRn@aGOR~}ToPk#~c[jT?/=}[Lx?Uoh;fYln;k8=}oI;?K#h;60A-^\\Pu-VJf>+9*.L*l-+w$UlJy;(.\t=J!]b):\t<UL^)^2_@n22;;Tv<;LGJlo2~?\b4/X~?)4>Xj|Uz4,`jUT&F/XTq##F=@Xq\bi\\>6Vm9C&-u|zfu^|Nc?/I`l=}\v~nTOr3?-n[5Wpo};TTl2?zK5Fl'*#Yj4+'q%~%W9zHa/=}J\v>NXk8JFN<wpPM}$q`l{`dSp_QVhn0OP\\R6h3Qka\f>YcDf?~^4Ghvnxn{'Qq\\Ns)rLGsjo\v3R f~=}pb,d+wjE=MlVD!g0d[MDZ8nmYDpKR^}Nnk(U;n.ZF\v2E\bpB$a4xIqEM{NZ.f,\bN^F7g6gB6oL{o2$?J[W2g5n!-;2Id.3jXH+i\vm?'t)1vk!:c>K=}6k5DoKu{izy=Jfz]e7&k!jNIg:WoA!*Eg*]g3#I cwq}9jH8 4$8m8LAW_pO=@R<_jC4]m[!=}DM~zKh7hxZg`sA=@kWdR_sEf4o0<'m{T_$T=M\\$\"Ln,-IO\fDyH4jeRL{8oJ?6<pTz>Im7=JQ\bG){%6]WTZP\t\\789h]51@F'p\ta=@=})l)v8=}C&e%8SaY{Y]U\t\fYZ[m\\y]Iy[`[dsii3cbGgcbW\bHa[m\\x]5D\\hX^Z+a[5\\]uBEB%lha3ubap{HD\\}CQ,p}`E[!au=}=@{=}Bk6v>f54J*&9~[[=M\\mCiS\t\"O]5VPlmH6~g=}ZARZ;Vgd!4'>h%VUF-\vk\v\f58;v$P@\v4UtA3W>B:=@\bS=}0@x@v>:HG;N~SyLPAOMf\"&wq/yC'|\t\f=J19\bpGI\t\\n\"=}y=}x\b\fmY)Qdi[cDGx+`\v(c`#xo^Q\t#1Y(%~ oAY2M\ba9=JA=M\\uM\t)H|{P[/ b7 H`7hDwq *=@j =J{R!0'(;(9b=@J_[_# yM8wQ'TnT\b \vv7eW%kG\t`8SHYK%[3RCOOWrQe=M^k0e{GI w%c1m]A |=}#@=@SC\v!}Au p& =J`=@!=@{X\b%I=MivHaWEY=Mu #=@'E\\'x$-i!&)k\f=M>{q=M|>HD)N\"g&F 2pg/hBUIX?DOctCr=Ja%n}40\b-Y=@t@ZyEU=Jq|FI\\Usi-*X]shpb;(B=JywoS\\c6u4L_`@5\fhGXay1\t6c\f'=}h37c{*/f\tj&p:p1ja'79\f=JH\"Q=}%\b\v\"a%:aQ6H#=JGA'i&m*(#f*F6Q,EJaU2{7k2`.yB6_G=MfV>\f(M2\vZ<`q\vEp\vAZ_DI\veFI<\to=JQ$[rO<o> ]DiI)=M\bbfbKLDS[\"$BO@\v\"C%w{P=J3YW8bf(PPE3W;UQ\fl<d3!t_\f\\9qt=J3S\"TQB\f~pT8v^f]G\b=M<Wu\\OC6fPaa=}9qd\vVfW5A=MQ'\\i\\(\\`\"ZCYcFDb4a4hf/AP9Iux\v]#bNJI=M{7*m/\"p+H*'Rm5lf}K\b:A\vo\";d>Mf_BU8W&[`TOb.gRD}TbYTT=@he?i#f?)=@U3(i>YS}q6d\v\\6V_qbC[=M\"V8=Ma\f?b,i~=J?p/tU1?4ztn_fnZ2A;]LFyyLf=M2qLf(25\tL&&2a(<\v=M2#5L7y%`k?$\tJl=MXz;;RloPqq:HJlo7/XN4pRqMdR^6ToHG8xo)<.Rp9@\vr;V^5l+$c*?q+#\f%fi_9d/De/of0k%^~`Y5P|8/z2\"`f{'^^yTd e/[Srn^#~\\nONJ;7\tFg+sF>[Aqi=MzL4Dks;'^d6?lOpgM\t\vZ^!z)Dp7p=}I1y:~Q*v'^9nhM'QOaN%JTt+ryCIDF{i>/E%3`RDnd5Yr3[B*gqaSgw1G2p\bD\tjTD&q\b\v4WWt0sIl?+^\\I[d\\YhdCyvm7{=MO}4H\\[ wIZI\\pI=Jy]}x\\6c^)ZedU=}Q\\fBnD]I\\zS=M1}z.y]3;N5,=MBOU3=MX}/6u[;x{$Ve~ubl'z\v{\voA4-}5C9\v,MS\vr\b3K\bHIVDA\"$=}g\v#5vm=M\tw=@ Km{^\f<' ['e-EDCioZa6EcN=@o9Q\\`?xs8T'=@hf8`AgDFGC@=@C`P'fzg F\bK8\f=ME# yY&&`i{D'dfHk+ET+6R\v>s/e }e=M/_WsE(QMh8\\B\b#3<5-5Qg`#WHF&'Z$3*5=@9\v1=MA}Q<Cf<\vhbYh9&*VWA0\vrK.iG8[9\f*.@8He1'f~aF\fo=JMNc<E\f=M\"=J,%U@`HYb+@vM+\to=}<B*L8tY}q{DX7r=MPC\"6&Px \vob\\xhCFM1\tx[4]kh4p+\t}SURLL[BITO\"\b<TuXwxP\\>gYT\v\\F6ye{lc8}q=M?,DT=M4&=Mu/X;eY;@L;XR ;\tTIq}Ib`\"GY2c>L^}tFo\t4/<bJ|p9WqA=J\\mST.C\tTpf\vz,-5,^L`In_4o4c\v`]{J-uqMS$nsl=}RP8q6>Hf@VnpJ$R\v2&bR:1(,I`1\"SZunwrjJxr;wq/d\b>_p6`yjwGt~mf>zVUF-%X#=@C'y\vI)`MY\\yy]cyZ!I(]X\\=@ZAZG[q9vy[bD(yeZD]kv~^{#;\v=M_iU3yFSYu%[=}{Bn=@wM.\txU^x@`|2EdUXG8TEXf@Sf]\t8`Y: 19dXm/Yls(9(a]Hh\"F)5obDH=MK=@8Cu_aG(\"\"6'/IH_2)m=MD0If%]=M=J,J2H=Ml(37[r LD\f=Mb=M}yP\fK\"\"Z?i\tP\"6F]=}}P=M&d4@/:YuVdBe=JOTXIW~,U\v4/8n~;hmA)9L*Z/.Uu;!M6Yo\tt;$9m4`n5(>>b3Y=Jr%bNnL\f;tpJ3Q|De ?l#R*O=@ltM{{h:((\\\bFvf=@x<[G[|vO&=}V^%{\v=}yP_\t&$,Q1@F=@M_ x=@Rc$;e &IZ!n8S\f8h=@1FCH9C]IR3NYFsc=M3ch+vw]|&sPF`C/2)^XulI>X4IRTo\"Q;()@&S`{A/W1=}dShj&)>9-8q)&\ted [#Z=M>d()\b[*yF/g$@F))o\bQ+X-17 @\\2#$#16364^HSE<>\\\"{n:b[_gM]etk{so33SC4uTa5+MOvSc\va=J\b\"i(vSmY\b((I_5>c =@(\"g=}![/@e&eXg!a^#x'hEh)=}~Y$'&d& t$RaZQ8\f=MG\b'm2rL^O=J% ;'e3G=Ju\vGWmA#M$eN\f=}$t=J(xdrEe!FimMWbAy<^C9/=}$Nj+>wv7?6}W/d*z]*A!gTmZIXkg?VH5u(\b(CA~*8*Cz'ci8Dx}e[v$4s}<J$xo12*smr_mQ.2}fIlbk,^ZY4=}ZWgCNW^9\f]XljG8?lpd.Pd%+5+Z)5'\tuk.DuJ=MH=Msl>pAn,FkfHl\tK,VnKJ=MO=}j~VghuUkfs5}lnRV@4[Dt@=@:H.HiJ=@=JJg01,$`.LJ7Wfm&;V 2 |tx]-V\\+l<}^ng_q7mzwYEAXLU_\bq {z1o{$BGwGt{=@7wjbJ8zzDq!{;X.|`r,aC9KtX,TC+PVgS?I:DLh@:aFa`(:+MwQ+\b\"-nrGZ;C-Ll^?kdF^f$P* -71mIbxj+tiKfn`:Dok:My,T:4PQ#6M:lyG&-Q\v#/NRe3+g^hTFL$3kpP^A: ;\fRTl`e;K3nr=MkL$4d4N\b,GHY=MR=@w7WmiG?.!|:%VT$TSk(P\bI{\fBS\t/@yl4aK\t@7S\fw!{rF_p@0Zg=}hHHEIYumTm`ngCuOar\fQ=@eH\"m5$ Q&T|=J>ABx\fT/i<?31;\\(_DT<=@0M`(Fd\ve0Pi.S]&6;,!=J=JuC6pd 5\f7X\"J.\vBc6:\v.@kDBlP;-:=};+m:3m\b:;m;Cm\b;+m:3reDm;Cm;*-Y:.-:2-:K=JK0\\}6B*[+C/-\\JE0k66BK0\\J}6jB[+G56.0jq+e6:0jZ@-dkBc68o0<\\B+6Z0j[`-dkC6*0Z+v0-B?K0-K6<,Zu2B_K8- k6>,P[EZ+\bvc!3QO!=}3s.NhIi|H|h||9IYiyL9LILYLiLyLLL9.ni2:<'KO$nuEXi.ni3c/<'OO$vueX19AIQYa8qylMg6kLeesHrrr\brHsss\bsCrrrrCsss392Y2y22222293Y3y333336Vv6Vv8:Jdk2?]n8;LdoB_n!8<NdsRn8=}Pdwbn!302@2P2`2p222222222=@22 203@3P3`3p333\tF3O!QNgJk:s&7N#L|QsrP\v9dyiXNsv3)<#WO=M|QusX9Qn3<'\f4rurLyKns<'TsrP1=@`yIWN.sv3(<WO\"Pu=JsXI#$/wJb6$OwKbF$owL\tbV$wMIcf$wNcv$wOc$wP\tc$wQIb /wRb OwSb owT\tb wUIc wVc&@v=}6%swQBP;63%2%3s2s(juZvyZvmZvqZvuZvyZv\"kZv\"mZv\"oZv\"qZv\"sZv\"uZv\"wZv\"yZvkZvmZvoZvqZvsZvuZvwZvyZv1ZAi.n2;6=}MBP$qi.ni3<6=}'OBP$vZveZ19AIQYaiqyN ^MsD<umP\brHO h|0sUESj=JmNMfqb\b<Hu$UF6N'Cx`np(8QeLmsWi0;sGm(BnN'_x!8t$<G!bOdV9wjkZLKBqc;s$F 20O'@r/=J|o0kL1\\j]W+yP?*w=JaL=M*x41\"u40`|.:3HU:_Fte/3rr,/<51C0|/(:_2&gu=M/U>`j\\0fi1!pq;2+{M\"d@?M=J7-(JMFj=JA0>,Ho=J{'Q0.n0\th{=J0AT:Rwo1:\"\"z)N\"!e\"c(=J1[6DY6?=JvP/9^.i\"s`,h8(:8(=J+|1,y2o6A1\"{F=Jg9J/)3L,=}O8&NBfO>+aP-6#z9afVl/|yZ,1kD5[@m0Nc:6.p_k+Jry9D,|NgkJebVr:L4N^0/C,S*\"J7YNgrRDN1F-*=JJ:t*G0?*q1-y]8B=JfG\"4+xo+J\fAF1P;]TOk)3E}3[e%=Jl\vT@*FZ/H=}t5-JO_RG1^|lzpRFB0 tm6J7-*#80x\\@=Moacx5 jnNzX*G+8+?,cj+W,Q#.=@)m#GT}*#~GCeL>''?!!4!eH~=M[bOZyH|eTu\"Lp/oId>,,#5Az\tQ\tVTmSm53C[X~\t\b\b/-u%GRHZ}0t#?xEG>cvn\t=JC-~X];<Z=@?7_H{d^oI\\n~Phb\brp\v-51[@4jup@g^P-Cj%/vLc4L<|=J3*Ab\t\vl=Mmpq IP(=J+W\foP^\bg\\DCC =@4\\h{%VF?1dr15`fPbgxWHZe/asL~}_t`h3#GVn\b5gAYh] q)f[8\fE9(\"xk/X'R\v0)'d=J|Ot&#C&Yt$)$aI04=@EPM?=@^Em-l)>@%=@_Uq\t&%>>XRm5I=J\fQIRW/1:]K${~t&N$Kt,kMdIgi_\f cc^\vc$yy\ta6sPO840)$bbc@$hDfOi`g!8TIia\\CY`{.2t4}`PMUekp=}'lHn9#&ruA`|$Iw Z`{\"3!,=My{\\i)h(#\fxFi't`W)oP/`3}c/!eG4;hXD\bp8B$\f'oM-S4/_m\\AeNd\"Fgx]<Z<%=MD_Mw\"Wdp8=@{XHH=My9XH)ehC_X#w$\bMq9(~\t\f=Mw!W=M^E|8n-h@ET7irk#@(o%)=JG)\v\t<]`@BU=@9}8hR]<GUB| q$0E\t=@{M,\tW'$wj9u`)d =JQaFUbEE%-u\t}Io5<~@C#%&Y3 l#yG=}7Wp5486>)PSPalQh%Cq@F=@=}!uQ{Y=@(+St1\fHY2sah\f\ve.v/IPovb~\t\fCDuVw'%A97IBq/7t'|=}IFv_V5KxjoyT<r=Mjg#^~#'rl=MHUU@4-)sx)=J$]4z`|'=M,^)Ic_Zyzgu7q\"? \t7P%!icrrT`V$S=@c%K&p=MX\"7YgS=};'|U{.&pAHp-xU>~N)\b#y_Mov;BN%$$9\t\"w1i`7}A\b(cc,<@_or/b(\\w=}7xu\b\tij5`w:g[uYf[\v+m\t]?Pf\"P  |u=J9muy'x$GQvAYYYhV=@WY76Hq\vn#=MV7<NA~#tA~\tbi\tw?51E3x)J\b#eq|-&C@\t9d\b1V,5fQ AW&8?[E>a}B'v=JhA)Yr92)=@d\tD(wiW_=}.xi=@`/v(f9Q(=}c^R6%#9AcaX'\\P^!yOi7=Mt!xRSP\fXg9S{w^]Y7|}Pgn?=}_tu\fs|8QBF3)aq^0nGZK184=@' h5wA#627]~{wZ7a\vXTq$Wtb=J[p=}hu3bc(E&D=MsHe\b[(Ii%by)\bK7a\\=M\tH&6H &z#+ae`W' UhF=M'uv\tEuT8%=J(\t\"\bD$e&%\\(\t\bG){ \b\tXuZ%$>/aV3[ Q0=}p*AyaiCDe97X=@z\b?x']y>#PE_%(mfcK\t\f&M0`_9H\v\vMu$YW=MW)$-!Ai^%Ad)#@^pie8%x\t&_#Wh{@dcG!`Ey\"6(h=M1Gv=}7OPg}8ge;#|bHd\\\"ZxIr#P&)U#=}'h8I&IdT\vg'=}%\f)RQ](x]Vy%_Ub\\ HEG_HXTf<%]Qt>'E9(`M3BNT\\Y\t/h(@ (5dd\v+iY%:$'`h\\d/W'!afpKf?quodYhy^=@af\f&W(Hj=M$]Mqgd!H_P\vbXa[+;IIQ'=JiPeW_lOQ+CQo\vM?vvi}!\v)fa'TJT=@M~yTaXt\vsmO\f>%h@g)s9}9=@ts\\_X\bB/YK\"=J\t)r}N%=@}xa=M(!?W=MS<'n>[&#=MPsa%}x5=@s\b!P~T\" 9TPXB>c=}`}eH6UX!W'k&pMM7)|a#(7@Y&p''D\\YUEyaKq{%G5)vmz@@Uz\f@Le>/Ny\\&3gCO5,Rl\t'uDP|;KNk=J8f(=J;ZWJ*Du>QFfsS@=J/CImh(kOe\"E=}Ax9P<L@!Je\vS&\v&+ReL%h1*\v1*[iT|j(x=}E($bE`,sAJ\vuOB563||/cghGLH2vfhz;DlwM#eb?2QUX*i=MG71TzygYBlH]d&{yCq|DB]btuI=M(3&k3~=@=Ja\fp7Sz9=MPc=M@,*=@\vTG-gk3P7L'1ksLc\f~ uGhF.z\\c*rZv'\vk53U\"nO=@|\"L,D{Hj;(Lg\v2y y-\t|)(`N[\\a[4_2h#41i|-_Wjw642Bq:TFQ0{-=Mx/#g\tekaq2=}=M9QsBFpcvV^VZ42=M@UV=@,k\tl>h]aLub99<,FZr4A|?`v2'R=@chV*#}U=MK'`)\\?|g=}It;Oy=@#k_+F~<=}tE*!6TP9jVL]U4]vv>:=}\\_B4gI6+H, ,'ZB\"=@;FJpv<U=@ wPcU#Y3@<=@%t~ta6D;PASn/;HQz!9)G70$\"Ad=MOdb?\vvkpR\\@UQO=@\v8{GG$}b>jOn(\"H1HiQ~Nzhp<\"r\"]8.:w@+$Y !5jHE1HBy~M*HVf&;WSk`5gxQ\\h&A$iQOu\"JpksQa$HmO5y)pyj|Hmfc55\fK=@B\f5t3J?C6pQa\v3#{-R1x<UStv'D\b/\b=JqZF3NwDE\f?xf{K7p;qJ|^gNnF:(\vk3N_mYI/2abmeQHN\\59sTB=MNz/U\ved$xIo!o\v}{mIh6`=M>0PVQ_&7ac%n'J\tq_ z+tBP_kV)q`]=Mhuvy/a7Vw\b=M{>RhiIvt\"[AS}Mo?EG~DLO!<2g'4 Whga0#{Afq\tc-!]$%6p)}j}=@w1pA?A/`nc(U5T&I2Ov_xz9=Mj.SQ.Bf=@jP,t#)h8uCS(.>^#Sh5h=JpJQL[c<sZzO`y=JL-/<I=}\b\f6dKXR`Z5.3Wg7EHHA\tDIa=@YHt1/nR=}GQ[=@8g^{M\\aOd6=@B{*n&Lhe' \b>Dr7Q=J:=@)Qq'v\\6]Idg0_,209~]Y}8ViS}x_\t(d<C%WDLUr8$6W^ 8w[IQZTUufsB2'6BWVspY[cG1eH,3NP&&=M[_bf~\fjIJ:w`97.w=@]eB Q2*@NE+.i1g&&-Se?v)${pNNXZXNO=@#Br!uf/ohO.wy(`<kb2ZXi+\\^5Ns3dPbhy%[\b*G\b<Bp]?5p GL`glm}R)n8\by@/1\\:XOFjG6i'Tt$v%>}#@cROV\"-k}\vho+i!=JI'$9Gb|I=MFWRO\fE2qXmI]hA,qg\f1]{q@,~\fVHY4Wqi@(SG@'^JHo{[:'{pHA=@YJ6X_\"l:'I(_.wAtIFBdd\vFu7kwv0HY5#dwU.7x(\vfQ?fDY[r!A0pHRmlW\fvfs:# $'.tR/hx[vj\tQT\\J PN2_SUo5Vap/<#!v1~iY>Z7i]7Obw@fWyx|n$$G8cZ=J/6ug-1_<4^Rq:[gwJ\vSs5BJvG|Wdz^b'/)=MYmW[_wVHfa3>0.jL_lZ YuCz&>8Hz|[gv}$ONnS8j?,]+y>.~+\fG;H,>\fr^=JW|W=JDsIy[Xt\f7*=ME;}NFi6s\v#\feiikL=M\\wU\t13VG!\\;v\fF}L[>#9@vf 0kt5g|7=J_3Et> *-)E_/39KSTf\vm=Jkjd|7shVcBy>]\t\v9lRfYDtJ|i1Om0.:7LGqcg=M]w}/#WeX{.0^\b*D9k=@_XM{\vLcY'7=JtzZxT\"4JlipU`=@NO\"\b#8=MlSB1|jbl&BD$',GOY>(u09f$%J/ij\\/svc<rn)Nk\\uby\fntew8=@=}wZDaQdLw\bK=JGt2c{@_\bw)<z]4SyMFBgmYstRP!MR1&E^)%A%]Cl]N=}qHGW\t+\bD0ht!]=@mlI+Z@mS2m_W$\f\v=JE;D\"jr0) \\Qi(.,g\vj\b*\bm@*\vo*C=J5Y$#WFO=}\"b!/:5YA8d6o)Yyx0\bOZ$A'\t)=J6(1"));var $,m,H,I,q,R,k={a:{b:function(t){return Math.cos(t)},a:function(t){return Math.exp(t)},c:function(t,f,v){p.copyWithin(t,f,f+v)},d:function(t){p.length,function(t){throw"OOM"}()}}};WebAssembly.instantiate(O.wasm,k).then((function(t){var f,v=t.instance.exports;$=v.g,m=v.h,H=v.i,I=v.j,q=v.k,R=v.l,v.m,f=v.e.buffer,new Int8Array(f),new Int16Array(f),new Int32Array(f),p=new Uint8Array(f),new Uint16Array(f),new Uint32Array(f),Q=new Float32Array(f),new Float64Array(f),function(t){t.f()}(v),g()}));const T=new Promise((t=>{g=t})),Y=(t,f)=>{const v=new Float32Array(f);let b=0;for(const M of t)v.set(M,b),b+=M.length;return v};class Z{constructor(t,f){this.channelData=t,this.samplesDecoded=f,this.sampleRate=48e3}}class N{constructor(t){this.ready=T,this.onDecode=t.onDecode,this.onDecodeAll=t.onDecodeAll}p(t){const f=I(Float32Array.BYTES_PER_ELEMENT*t);return[f,new Float32Array(Q.buffer,f,t)]}decode(t){if(!(t instanceof Uint8Array))throw Error("Data to decode must be Uint8Array");this.O||(this.O=H());let f,v,b,M,J,r,e,a=[],n=[],i=0;try{const o=11520;[v,b]=this.p(o),[M,J]=this.p(o/2),[r,e]=this.p(o/2);let s,u=65536,c=0;const h=t.byteLength;for(f=I(t.BYTES_PER_ELEMENT*u);c<h;){if(s=Math.min(u,h-c),p.set(t.subarray(c,c+s),f),c+=s,!$(this.O,f,s))throw Error("Could not enqueue bytes for decoding.  You may also have invalid Ogg Opus file.");let b;for(;(b=m(this.O,v,o,M,r))>0;){const t=J.slice(0,b),f=e.slice(0,b);this.onDecode&&this.onDecode(new Z([t,f],b)),this.onDecodeAll&&(a.push(t),n.push(f),i+=b)}if(b<0)throw Error(`libopusfile ${b}: ${{[-1]:"A request did not succeed.",[-3]:"There was a hole in the page sequence numbers (e.g., a page was corrupt or missing).",[-128]:"An underlying read, seek, or tell operation failed when it should have succeeded.",[-129]:"A NULL pointer was passed where one was unexpected, or an internal memory allocation failed, or an internal library error was encountered.",[-130]:"The stream used a feature that is not implemented, such as an unsupported channel family.",[-131]:"One or more parameters to a function were invalid.",[-132]:'A purported Ogg Opus stream did not begin with an Ogg page, a purported header packet did not start with one of the required strings, "OpusHead" or "OpusTags", or a link in a chained file was encountered that did not contain any logical Opus streams.',[-133]:"A required header packet was not properly formatted, contained illegal values, or was missing altogether.",[-134]:"The ID header contained an unrecognized version number.",[-136]:"An audio packet failed to decode properly. This is usually caused by a multistream Ogg packet where the durations of the individual Opus packets contained in it are not all the same.",[-137]:"We failed to find data we had seen before, or the bitstream structure was sufficiently malformed that seeking to the target destination was impossible.",[-138]:"An operation that requires seeking was requested on an unseekable stream.",[-139]:"The first or last granule position of a link failed basic validity checks."}[b]||"Unknown Error"}`)}this.onDecodeAll&&i&&this.onDecodeAll(new Z([Y(a,i),Y(n,i)],i))}catch(o){throw o}finally{R(f),R(v),R(M),R(r)}}free(){this.O&&q(this.O)}}O.OggOpusDecoder=N,"undefined"!=typeof global&&exports&&(module.exports.OggOpusDecoder=N)}();

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],30:[function(require,module,exports){
(function (global){(function (){
const { EventTarget, defineEventAttribute } = require('event-target-shim');
const { detect } = require('detect-browser');
const browser = detect();

const AudioContext = global.AudioContext || global.webkitAudioContext;
const BUFFER_SIZE = 4096;

/**
 * Reference: https://w3c.github.io/mediacapture-record/#mediarecorder-api
 * @extends EventTarget
 */
class OpusMediaRecorder extends EventTarget {
  /**
   * A function that returns the encoder web worker
   * @name workerFactory
   * @function
   * @returns {worker} An instance of ./encoderWorker.js web worker.
   */

  /**
   *
   * @param {MediaStream} stream - The MediaStream to be recorded. This will
   *          be the value of the stream attribute.
   * @param {MediaRecorderOptions} [options] - A dictionary of options to for
   *          the UA instructing how the recording will take part.
   *          options.mimeType, if present, will become the value of mimeType
   *          attribute.
   * @param {Object} [workerOptions] This is a NON-STANDARD options to
   *          configure how to import the web worker .wasm compiled binaries
   *          used for encoding.
   * @param {workerFactory} [workerOptions.encoderWorkerFactory] A factory
   *          function that create a web worker instance of ./encoderWorker.js
   *          and returns it. function(){return new Worker('./encoderWorker.umd.js')}
   *          is used by default. This is NON-STANDARD.
   * @param {string} [workerOptions.OggOpusEncoderWasmPath]
   *          Path of ./OggOpusEncoder.wasm which is used for OGG Opus encoding
   *          by the encoder worker. This is NON-STANDARD.
   * @param {string} [workerOptions.WebMOpusEncoderWasmPath]
   *          Path of ./WebMOpusEncoder.wasm which is used for WebM Opus encoding
   *          by the encoder worker. This is NON-STANDARD.
   */
  constructor (stream, options = {}, workerOptions = {}) {
    const { mimeType, audioBitsPerSecond, videoBitsPerSecond, bitsPerSecond } = options; // eslint-disable-line
    // NON-STANDARD options
    const { encoderWorkerFactory, OggOpusEncoderWasmPath, WebMOpusEncoderWasmPath } = workerOptions;

    super();
    // Attributes for the specification conformance. These have their own getters.
    this._stream = stream;
    this._state = 'inactive';
    this._mimeType = mimeType || '';
    this._audioBitsPerSecond = audioBitsPerSecond || bitsPerSecond;
    /** @type {'inactive'|'readyToInit'|'encoding'|'closed'} */
    this.workerState = 'inactive';

    // Parse MIME Type
    if (!OpusMediaRecorder.isTypeSupported(this._mimeType)) {
      throw new TypeError('invalid arguments, a MIME Type is not supported');
    }
    switch (OpusMediaRecorder._parseType(this._mimeType).subtype) {
      case 'wave':
      case 'wav':
        this._mimeType = 'audio/wave';
        break;

      case 'webm':
        this._mimeType = 'audio/webm';
        break;

      case 'ogg':
        this._mimeType = 'audio/ogg';
        break;

      default:
        // Select a type depending on OS.
        switch (browser && browser.name) {
          case 'chrome':
            this._mimeType = 'audio/webm';
            break;

          case 'firefox':
            this._mimeType = 'audio/ogg';
            break;

          case 'edge':
            this._mimeType = 'audio/webm';
            break;

          case 'ios':
          case 'safari':
            this._mimeType = 'audio/wave';
            break;

          default:
            this._mimeType = 'audio/webm';
        }
    }
    switch (this._mimeType) {
      case 'audio/wave':
        this._wasmPath = ''; // wasm is not used
        break;

      case 'audio/webm':
        this._wasmPath = WebMOpusEncoderWasmPath || '';
        break;

      case 'audio/ogg':
        this._wasmPath = OggOpusEncoderWasmPath || '';
        break;

      default:
        throw new Error(`Internal Error: Unexpected MIME Type: ${this._mimeType}`);
    }

    // Get current directory for worker
    let workerDir = '';
    if (document.currentScript) {
      workerDir = document.currentScript.src;
    } else if (self.location) {
      workerDir = self.location.href;
    }
    workerDir = workerDir.substr(0, workerDir.lastIndexOf('/')) +
                '/encoderWorker.umd.js';
    // If worker function is imported via <script> tag, make it blob to get URL.
    if (typeof OpusMediaRecorder.encoderWorker === 'function') {
      workerDir = URL.createObjectURL(new Blob([`(${OpusMediaRecorder.encoderWorker})()`]));
    }

    // Spawn a encoder worker
    this._workerFactory = typeof encoderWorkerFactory === 'function'
                            ? encoderWorkerFactory
                            : _ => new Worker(workerDir);
    this._spawnWorker();
  }

  /**
   * The MediaStream [GETUSERMEDIA] to be recorded.
   * @return {MediaStream}
   */
  get stream () {
    return this._stream;
  }

  /**
   * The MIME type [RFC2046] that has been selected as the container for
   * recording. This entry includes all the parameters to the base
   * mimeType. The UA should be able to play back any of the MIME types
   * it supports for recording. For example, it should be able to display
   * a video recording in the HTML <video> tag. The default value for
   * this property is platform-specific.
   * @return {string}
   */
  get mimeType () {
    return this._mimeType;
  }

  /**
   * The current state of the OpusMediaRecorder object. When the OpusMediaRecorder
   * is created, the UA MUST set this attribute to inactive.
   * @return {"inactive"|"recording"|"paused"}
   */
  get state () {
    return this._state;
  }

  /**
   * The value of the Video encoding. Unsupported.
   * @return {undefined}
   */
  get videoBitsPerSecond () {
    // Video encoding is not supported
    return undefined;
  }

  /**
   * The value of the Audio encoding target bit rate that was passed to
   * the Platform (potentially truncated, rounded, etc), or the calculated one
   * if the user has specified bitsPerSecond.
   * @return {number|undefined}
   */
  get audioBitsPerSecond () {
    return this._audioBitsPerSecond;
  }

  /**
   * Initialize worker
   */
  _spawnWorker () {
    this.worker = this._workerFactory();
    this.worker.onmessage = (e) => this._onmessageFromWorker(e);
    this.worker.onerror = (e) => this._onerrorFromWorker(e);

    this._postMessageToWorker('loadEncoder',
                              { mimeType: this._mimeType,
                                wasmPath: this._wasmPath });
  }

  /**
   * Post message to the encoder web worker.
   * @param {"init"|"pushInputData"|"getEncodedData"|"done"} command - Type of message to send to the worker
   * @param {object} message - Payload to the worker
   */
  _postMessageToWorker (command, message = {}) {
    switch (command) {
      case 'loadEncoder':
        let { mimeType, wasmPath } = message;
        this.worker.postMessage({ command, mimeType, wasmPath });
        break;

      case 'init':
        // Initialize the worker
        let { sampleRate, channelCount, bitsPerSecond } = message;
        this.worker.postMessage({ command, sampleRate, channelCount, bitsPerSecond });
        this.workerState = 'encoding';

        // Start streaming
        this.source.connect(this.processor);
        this.processor.connect(this.context.destination);
        let eventToPush = new global.Event('start');
        this.dispatchEvent(eventToPush);
        break;

      case 'pushInputData':
        // Pass input audio buffer to the encoder to encode.
        // The worker MAY trigger 'encodedData'.
        let { channelBuffers, length, duration } = message;
        this.worker.postMessage({
          command, channelBuffers, length, duration
        });
        break;

      case 'getEncodedData':
        // Request encoded result.
        // Expected 'encodedData' event from the worker
        this.worker.postMessage({ command });
        break;

      case 'done':
        // Tell encoder finallize the job and destory itself.
        // Expected 'lastEncodedData' event from the worker.
        this.worker.postMessage({ command });
        break;

      default:
        // This is an error case
        throw new Error('Internal Error: Incorrect postMessage requested.');
    }
  }

  /**
   * onmessage() callback from the worker.
   * @param {message} event - message from the worker
   */
  _onmessageFromWorker (event) {
    const { command, buffers } = event.data;
    let eventToPush;
    switch (command) {
      case 'readyToInit':
        const { sampleRate, channelCount } = this;
        this.workerState = 'readyToInit';

        // If start() is already called initialize worker
        if (this.state === 'recording') {
          this._postMessageToWorker('init',
                                    { sampleRate,
                                      channelCount,
                                      bitsPerSecond: this.audioBitsPerSecond});
        }
        break;

      case 'encodedData':
      case 'lastEncodedData':
        let data = new Blob(buffers, {'type': this._mimeType});
        eventToPush = new global.Event('dataavailable');
        eventToPush.data = data;
        this.dispatchEvent(eventToPush);

        // Detect of stop() called before
        if (command === 'lastEncodedData') {
          eventToPush = new global.Event('stop');
          this.dispatchEvent(eventToPush);

          this.workerState = 'closed';
        }
        break;

      default:
        break; // Ignore
    }
  }

  /**
   * onerror() callback from the worker.
   * @param {ErrorEvent} error - error object from the worker
   */
  _onerrorFromWorker (error) {
    // Stop stream first
    this.source.disconnect();
    this.processor.disconnect();

    this.worker.terminate();
    this.workerState = 'closed';

    // Send message to host
    let message = [
      'FileName: ' + error.filename,
      'LineNumber: ' + error.lineno,
      'Message: ' + error.message
    ].join(' - ');
    let errorToPush = new global.Event('error');
    errorToPush.name = 'UnknownError';
    errorToPush.message = message;
    this.dispatchEvent(errorToPush);
  }

  /**
   * Enable onaudioprocess() callback.
   * @param {number} timeslice - In seconds. OpusMediaRecorder should request data
   *                              from the worker every timeslice seconds.
   */
  _enableAudioProcessCallback (timeslice) {
    // pass frame buffers to the worker
    let elapsedTime = 0;
    this.processor.onaudioprocess = (e) => {
      const { inputBuffer, playbackTime } = e; // eslint-disable-line
      const { sampleRate, length, duration, numberOfChannels } = inputBuffer; // eslint-disable-line

      // Create channel buffers to pass to the worker
      const channelBuffers = new Array(numberOfChannels);
      for (let i = 0; i < numberOfChannels; i++) {
        channelBuffers[i] = inputBuffer.getChannelData(i);
      }

      // Pass data to the worker
      const message = { channelBuffers, length, duration };
      this._postMessageToWorker('pushInputData', message);

      // Calculate time
      elapsedTime += duration;
      if (elapsedTime >= timeslice) {
        this._postMessageToWorker('getEncodedData');
        elapsedTime = 0;
      }
    };
  }

  /**
   * Begins recording media; this method can optionally be passed a timeslice
   * argument with a value in milliseconds.
   * @param {number} timeslice - If this is specified, the media will be captured
   *        in separate chunks of that duration, rather than the default behavior
   *        of recording the media in a single large chunk. In other words, an
   *        undefined value of timeslice will be understood as the largest long value.
   */
  start (timeslice = Number.MAX_SAFE_INTEGER) {
    if (this.state !== 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must be inactive.');
    }
    if (timeslice < 0) {
      throw new TypeError('invalid arguments, timeslice should be 0 or higher.');
    }
    timeslice /= 1000; // Convert milliseconds to seconds

    // Check worker is closed (usually by stop()) and init.
    if (this.workerState === 'closed') {
      this._spawnWorker();
    }

    // Get channel count and sampling rate
    // channelCount: https://www.w3.org/TR/mediacapture-streams/#media-track-settings
    // sampleRate: https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/sampleRate
    this.context = new AudioContext();
    let tracks = this.stream.getAudioTracks();
    if (!tracks[0]) {
      throw new Error('DOMException: UnkownError, media track not found.');
    }
    this.channelCount = tracks[0].getSettings().channelCount || 1;
    this.sampleRate = this.context.sampleRate;

    /** @type {MediaStreamAudioSourceNode} */
    this.source = this.context.createMediaStreamSource(this.stream);
    /** @type {ScriptProcessorNode} */
    this.processor = this.context.createScriptProcessor(BUFFER_SIZE, this.channelCount, this.channelCount);

    // Start recording
    this._state = 'recording';
    this._enableAudioProcessCallback(timeslice);

    // If the worker is already loaded then start
    if (this.workerState === 'readyToInit') {
      const { sampleRate, channelCount } = this;
      this._postMessageToWorker('init',
                                { sampleRate,
                                  channelCount,
                                  bitsPerSecond: this.audioBitsPerSecond });
    }
  }

  /**
   * Stops recording, at which point a dataavailable event containing
   * the final Blob of saved data is fired. No more recording occurs.
   */
  stop () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // Stop stream first
    this.source.disconnect();
    this.processor.disconnect();
    this.context.close();

    // Stop event will be triggered at _onmessageFromWorker(),
    this._postMessageToWorker('done');

    this._state = 'inactive';
  }

  /**
   * Pauses the recording of media.
   */
  pause () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // Stop stream first
    this.source.disconnect();
    this.processor.disconnect();

    let event = new global.Event('pause');
    this.dispatchEvent(event);
    this._state = 'paused';
  }

  /**
   * Resumes recording of media after having been paused.
   */
  resume () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // Restart streaming data
    this.source.connect(this.processor);
    this.processor.connect(this.context.destination);

    let event = new global.Event('resume');
    this.dispatchEvent(event);
    this._state = 'recording';
  }

  /**
   * Requests a Blob containing the saved data received thus far (or since
   * the last time requestData() was called. After calling this method,
   * recording continues, but in a new Blob.
   */
  requestData () {
    if (this.state === 'inactive') {
      throw new Error('DOMException: INVALID_STATE_ERR, state must NOT be inactive.');
    }

    // dataavailable event will be triggerd at _onmessageFromWorker()
    this._postMessageToWorker('getEncodedData');
  }

  /**
   * Returns a Boolean value indicating if the given MIME type is supported
   * by the current user agent .
   * @param {string} typeType - A MIME Type, including parameters when needed,
   *          specifying a container and/or codec formats for recording.
   * @return {boolean}
   */
  static isTypeSupported (mimeType) {
    // See: https://w3c.github.io/mediacapture-record/#dom-mediarecorder-istypesupported

    // 1. If empty string, return true.
    if (typeof mimeType === 'string' && !mimeType) {
      return true;
    }
    try {
      var {type, subtype, codec} = OpusMediaRecorder._parseType(mimeType);
    } catch (error) {
      // 2. If not a valid string, return false.
      return false;
    }
    if (type !== 'audio' ||
      !(subtype === 'ogg' || subtype === 'webm' ||
        subtype === 'wave' || subtype === 'wav')) {
      // 3,4. If type and subtype are unsupported the return false.
      return false;
    }
    // 5. If codec is unsupported then return false.
    // 6. If the specified combination of all is not supported than return false.
    switch (subtype) {
      case 'ogg':
        if (codec !== 'opus' && codec) {
          return false;
        }
        break;
      case 'webm':
        if (codec !== 'opus' && codec) {
          return false;
        }
        break;
      case 'wave':
      case 'wav':
        if (codec) {
          return false; // Currently only supports signed 16 bits
        }
        break;
    }
    // 7. return true.
    return true;
  }

  /**
   * Parse MIME. A helper function for isTypeSupported() and etc.
   * @param {string} mimeType - typeType - A MIME Type, including parameters when needed,
   *          specifying a container and/or codec formats for recording.
   * @return {?object} - An object with type, subtype, codec attributes
   *          if parsed correctly. null is returned if parsing failed.
   *          If mimeType is an empty string then return an object with attributes
   *          are empty strings
   */
  static _parseType (mimeType) {
    try {
      const regex = /^(\w+)\/(\w+)(;\s*codecs=(\w+))?$/;
      var [, type, subtype, , codec] = mimeType.match(regex);
    } catch (error) {
      if (typeof mimeType === 'string' && !mimeType) {
        return {type: '', subtype: '', codec: ''};
      }
      return null;
    }
    return {type, subtype, codec};
  }
}

// EventHandler attributes.
// This code is a non-standard EventTarget but required by event-target-shim.
[
  'start', // Called to handle the {@link MediaRecorder#start} event.
  'stop', // Called to handle the stop event.
  'dataavailable', /* Called to handle the dataavailable event. The Blob of
                        recorded data is contained in this event and can be
                        accessed via its data attribute. */
  'pause', // Called to handle the pause event.
  'resume', // Called to handle the resume event.
  'error' // Called to handle a MediaRecorderErrorEvent.
].forEach(name => defineEventAttribute(OpusMediaRecorder.prototype, name));

// MS Edge specific monkey patching:
// onaudioprocess callback cannot be triggered more than twice when postMessage
// uses the seconde transfer argument. So disable the transfer argument only in Edge.
if (browser && browser.name === 'edge') {
  (function () {
    var original = Worker.prototype.postMessage;
    Worker.prototype.postMessage = function (message, transfer = null) {
      original.apply(this, [message]);
    };
  })();
}

module.exports = OpusMediaRecorder;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"detect-browser":12,"event-target-shim":15}],31:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');

module.exports = PageBus;
inherits(PageBus, EventEmitter);

var emit = EventEmitter.prototype.emit;
var on = EventEmitter.prototype.on;
var once = EventEmitter.prototype.once;

function PageBus (opts) {
    if (!(this instanceof PageBus)) return new PageBus(opts);
    if (!opts) opts = {};
    var self = this;
    EventEmitter.call(this);
    if (typeof opts === 'string') opts = { key: opts };
    this._key = opts.key || 'page-bus';
    localStorage.setItem(this._key, JSON.stringify([]));
    window.addEventListener('storage', function (ev) {
        if (ev.key === self._key) {
            try { var value = JSON.parse(ev.newValue) }
            catch (err) { return }
            if (Array.isArray(value)) emit.apply(self, value);
        }
    });
}


PageBus.prototype.emit = function (name) {
    emit.apply(this, arguments);
    var args = [].slice.call(arguments);
    localStorage.setItem(this._key, JSON.stringify(args));
    return this;
};

},{"events":121,"inherits":21}],32:[function(require,module,exports){
(function (global){(function (){
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise

module.exports = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0))

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],33:[function(require,module,exports){
(function (process,global){(function (){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":136,"safe-buffer":50}],34:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],35:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":37,"./_stream_writable":39,"_process":136,"inherits":21}],36:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":38,"inherits":21}],37:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":34,"./_stream_duplex":35,"./internal/streams/async_iterator":40,"./internal/streams/buffer_list":41,"./internal/streams/destroy":42,"./internal/streams/from":44,"./internal/streams/state":46,"./internal/streams/stream":47,"_process":136,"buffer":117,"events":121,"inherits":21,"string_decoder/":76,"util":116}],38:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":34,"./_stream_duplex":35,"inherits":21}],39:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":34,"./_stream_duplex":35,"./internal/streams/destroy":42,"./internal/streams/state":46,"./internal/streams/stream":47,"_process":136,"buffer":117,"inherits":21,"util-deprecate":86}],40:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

},{"./end-of-stream":43,"_process":136}],41:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":117,"util":116}],42:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

},{"_process":136}],43:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":34}],44:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],45:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":34,"./end-of-stream":43}],46:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":34}],47:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":121}],48:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":35,"./lib/_stream_passthrough.js":36,"./lib/_stream_readable.js":37,"./lib/_stream_transform.js":38,"./lib/_stream_writable.js":39,"./lib/internal/streams/end-of-stream.js":43,"./lib/internal/streams/pipeline.js":45}],49:[function(require,module,exports){
(function (process){(function (){
/*! run-waterfall. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = runWaterfall

function runWaterfall (tasks, cb) {
  var current = 0
  var isSync = true

  function done (err, args) {
    function end () {
      args = args ? [].concat(err, args) : [err]
      if (cb) cb.apply(undefined, args)
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (err) {
    var args = Array.prototype.slice.call(arguments, 1)
    if (++current >= tasks.length || err) {
      done(err, args)
    } else {
      tasks[current].apply(undefined, [].concat(args, each))
    }
  }

  if (tasks.length) {
    tasks[0](each)
  } else {
    done(null)
  }

  isSync = false
}

}).call(this)}).call(this,require('_process'))

},{"_process":136}],50:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":117}],51:[function(require,module,exports){
 /* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parts[1],
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress); // was: relAddr
    sdp.push('rport');
    sdp.push(candidate.relatedPort); // was: relPort
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
}

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  // was: channels
  parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      params.push(param + '=' + codec.parameters[param]);
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
}

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  caps.headerExtensions.forEach(function(extension) {
    sdp += SDPUtils.writeExtmap(extension);
  });
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.split(' ');
    parts.shift();
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
        rtx: {
          ssrc: secondarySsrc
        }
      };
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: secondarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(5), 10);
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  var cname;
  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

SDPUtils.writeSessionBoilerplate = function() {
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

// Expose public methods.
module.exports = SDPUtils;

},{}],52:[function(require,module,exports){
/**
 * Created by Samuel on 6/4/2016.
 * Simple wrapper functions to produce shorter UUIDs for cookies, maybe everything?
 */

const { v4: uuidv4 } = require('uuid');
const anyBase = require('any-base');

const flickrBase58 = '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ';
const cookieBase90 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&'()*+-./:<=>?@[]^_`{|}~";

const baseOptions = {
  consistentLength: true,
};

// A default generator, instantiated only if used.
let toFlickr;

/**
 * Takes a UUID, strips the dashes, and translates.
 * @param {string} longId
 * @param {function(string)} translator
 * @param {Object} [paddingParams]
 * @returns {string}
 */
const shortenUUID = (longId, translator, paddingParams) => {
  const translated = translator(longId.toLowerCase().replace(/-/g, ''));

  if (!paddingParams || !paddingParams.consistentLength) return translated;

  return translated.padStart(
    paddingParams.shortIdLength,
    paddingParams.paddingChar,
  );
};

/**
 * Translate back to hex and turn back into UUID format, with dashes
 * @param {string} shortId
 * @param {function(string)} translator
 * @returns {string}
 */
const enlargeUUID = (shortId, translator) => {
  const uu1 = translator(shortId).padStart(32, '0');

  // Join the zero padding and the UUID and then slice it up with match
  const m = uu1.match(/(\w{8})(\w{4})(\w{4})(\w{4})(\w{12})/);

  // Accumulate the matches and join them.
  return [m[1], m[2], m[3], m[4], m[5]].join('-');
};

// Calculate length for the shortened ID
const getShortIdLength = (alphabetLength) => (
  Math.ceil(Math.log(2 ** 128) / Math.log(alphabetLength)));

module.exports = (() => {
  /**
   * @param {string} toAlphabet - Defaults to flickrBase58 if not provided
   * @param {Object} [options]
   *
   * @returns {{new: (function()),
   *  uuid: (function()),
   *  fromUUID: (function(string)),
   *  toUUID: (function(string)),
   *  alphabet: (string)}}
   */
  const makeConvertor = (toAlphabet, options) => {
    // Default to Flickr 58
    const useAlphabet = toAlphabet || flickrBase58;

    // Default to baseOptions
    const selectedOptions = { ...baseOptions, ...options };

    // Check alphabet for duplicate entries
    if ([...new Set(Array.from(useAlphabet))].length !== useAlphabet.length) {
      throw new Error('The provided Alphabet has duplicate characters resulting in unreliable results');
    }

    const shortIdLength = getShortIdLength(useAlphabet.length);

    // Padding Params
    const paddingParams = {
      shortIdLength,
      consistentLength: selectedOptions.consistentLength,
      paddingChar: useAlphabet[0],
    };

    // UUIDs are in hex, so we translate to and from.
    const fromHex = anyBase(anyBase.HEX, useAlphabet);
    const toHex = anyBase(useAlphabet, anyBase.HEX);
    const generate = () => shortenUUID(uuidv4(), fromHex, paddingParams);

    const translator = {
      new: generate,
      generate,
      uuid: uuidv4,
      fromUUID: (uuid) => shortenUUID(uuid, fromHex, paddingParams),
      toUUID: (shortUuid) => enlargeUUID(shortUuid, toHex),
      alphabet: useAlphabet,
      maxLength: shortIdLength,
    };

    Object.freeze(translator);

    return translator;
  };

  // Expose the constants for other purposes.
  makeConvertor.constants = {
    flickrBase58,
    cookieBase90,
  };

  // Expose the generic v4 UUID generator for convenience
  makeConvertor.uuid = uuidv4;

  // Provide a generic generator
  makeConvertor.generate = () => {
    if (!toFlickr) {
      // Generate on first use;
      toFlickr = makeConvertor(flickrBase58).generate;
    }
    return toFlickr();
  };

  return makeConvertor;
})();

},{"any-base":4,"uuid":87}],53:[function(require,module,exports){
var ess = require('event-source-stream')
var nets = require('nets')

var noop = function () {}

module.exports = function (url, app) {
  if (!url) throw new Error('signalhub url required')
  if (!app) throw new Error('app name required as 2nd argument')
  var that = {}

  if (url.indexOf('://') === -1) url = 'http://' + url

  that.subscribe = function (channel) {
    return ess(url + '/v1/' + app + '/' + channel, {json: true})
  }

  that.broadcast = function (channel, message, cb) {
    if (!cb) cb = noop
    nets({
      method: 'POST',
      json: message,
      url: url + '/v1/' + app + '/' + channel
    }, function (err, res) {
      if (err) return cb(err)
      if (res.statusCode !== 200) return cb(new Error('Bad status: ' + res.statusCode))
      cb()
    })
  }

  return that
}

},{"event-source-stream":54,"nets":55}],54:[function(require,module,exports){
var stream = require('stream')

module.exports = function(url, opts) {
  if (!opts) opts = {}

  var es = new EventSource(url)
  var rs = new stream.Readable({objectMode:true})

  var json = !!opts.json
  var decode = function (data) {
    try {
      if (json) return JSON.parse(data)
      return data
    } catch (err) {
      return undefined
    }
  }

  rs._read = function() {}

  es.onmessage = function(e) {
    rs.push(decode(e.data))
  }

  es.onerror = function(err) {
    if (rs.listeners('error').length) rs.emit('error', err)
  }

  var destroyed = false
  rs.destroy = function() {
    if (destroyed) return
    destroyed = true
    es.close()
    parse.emit('close')
  }

  return rs
}
},{"stream":141}],55:[function(require,module,exports){
(function (process,Buffer){(function (){
var req = require('request')

module.exports = Nets

function Nets (opts, cb) {
  if (typeof opts === 'string') opts = { uri: opts }

  // in node, if encoding === null then response will be a Buffer. we want this to be the default
  if (!opts.hasOwnProperty('encoding')) opts.encoding = null

  // in browser, we should by default convert the arraybuffer into a Buffer
  if (process.browser && !opts.hasOwnProperty('json') && opts.encoding === null) {
    opts.responseType = 'arraybuffer'
    var originalCb = cb
    cb = bufferify
  }

  function bufferify (err, resp, body) {
    if (body) body = new Buffer(new Uint8Array(body))
    originalCb(err, resp, body)
  }

  return req(opts, cb)
}

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

},{"_process":136,"buffer":117,"request":56}],56:[function(require,module,exports){
"use strict";
var window = require("global/window")
var once = require("once")
var parseHeaders = require("parse-headers")


var XHR = window.XMLHttpRequest || noop
var XDR = "withCredentials" in (new XHR()) ? XHR : window.XDomainRequest

module.exports = createXHR

function createXHR(options, callback) {
    function readystatechange() {
        if (xhr.readyState === 4) {
            loadFunc()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === "text" || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }
    
    var failureResponse = {
                body: undefined,
                headers: {},
                statusCode: 0,
                method: method,
                url: uri,
                rawRequest: xhr
            }
    
    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "unknown") )
        }
        evt.statusCode = 0
        callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        clearTimeout(timeoutTimer)
        
        var status = (xhr.status === 1223 ? 204 : xhr.status)
        var response = failureResponse
        var err = null
        
        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        callback(err, response, response.body)
        
    }
    
    if (typeof options === "string") {
        options = { uri: options }
    }

    options = options || {}
    if(typeof callback === "undefined"){
        throw new Error("callback argument missing")
    }
    callback = once(callback)

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new XDR()
        }else{
            xhr = new XHR()
        }
    }

    var key
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer

    if ("json" in options) {
        isJson = true
        headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["Content-Type"] = "application/json"
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync)
    //has to be after open
    xhr.withCredentials = !!options.withCredentials
    
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            xhr.abort("timeout");
        }, options.timeout+2 );
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }
    
    if ("beforeSend" in options && 
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr


}


function noop() {}

},{"global/window":57,"once":58,"parse-headers":62}],57:[function(require,module,exports){
(function (global){(function (){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],58:[function(require,module,exports){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

},{}],59:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":60}],60:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],61:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],62:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":59,"trim":61}],63:[function(require,module,exports){
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
const debug = require('debug')('simple-peer')
const getBrowserRTC = require('get-browser-rtc')
const randombytes = require('randombytes')
const stream = require('readable-stream')
const queueMicrotask = require('queue-microtask') // TODO: remove when Node 10 is not supported
const errCode = require('err-code')
const { Buffer } = require('buffer')

const MAX_BUFFERED_AMOUNT = 64 * 1024
const ICECOMPLETE_TIMEOUT = 5 * 1000
const CHANNEL_CLOSING_TIMEOUT = 5 * 1000

// HACK: Filter trickle lines when trickle is disabled #354
function filterTrickle (sdp) {
  return sdp.replace(/a=ice-options:trickle\s\n/g, '')
}

function warn (message) {
  console.warn(message)
}

/**
 * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.
 * Duplex stream.
 * @param {Object} opts
 */
class Peer extends stream.Duplex {
  constructor (opts) {
    opts = Object.assign({
      allowHalfOpen: false
    }, opts)

    super(opts)

    this._id = randombytes(4).toString('hex').slice(0, 7)
    this._debug('new peer %o', opts)

    this.channelName = opts.initiator
      ? opts.channelName || randombytes(20).toString('hex')
      : null

    this.initiator = opts.initiator || false
    this.channelConfig = opts.channelConfig || Peer.channelConfig
    this.channelNegotiated = this.channelConfig.negotiated
    this.config = Object.assign({}, Peer.config, opts.config)
    this.offerOptions = opts.offerOptions || {}
    this.answerOptions = opts.answerOptions || {}
    this.sdpTransform = opts.sdpTransform || (sdp => sdp)
    this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old "stream" option
    this.trickle = opts.trickle !== undefined ? opts.trickle : true
    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false
    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT

    this.destroyed = false
    this.destroying = false
    this._connected = false

    this.remoteAddress = undefined
    this.remoteFamily = undefined
    this.remotePort = undefined
    this.localAddress = undefined
    this.localFamily = undefined
    this.localPort = undefined

    this._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')
      ? opts.wrtc
      : getBrowserRTC()

    if (!this._wrtc) {
      if (typeof window === 'undefined') {
        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')
      } else {
        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')
      }
    }

    this._pcReady = false
    this._channelReady = false
    this._iceComplete = false // ice candidate trickle done (got null candidate)
    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout
    this._channel = null
    this._pendingCandidates = []

    this._isNegotiating = false // is this peer waiting for negotiation to complete?
    this._firstNegotiation = true
    this._batchedNegotiation = false // batch synchronous negotiations
    this._queuedNegotiation = false // is there a queued negotiation request?
    this._sendersAwaitingStable = []
    this._senderMap = new Map()
    this._closingInterval = null

    this._remoteTracks = []
    this._remoteStreams = []

    this._chunk = null
    this._cb = null
    this._interval = null

    try {
      this._pc = new (this._wrtc.RTCPeerConnection)(this.config)
    } catch (err) {
      this.destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))
      return
    }

    // We prefer feature detection whenever possible, but sometimes that's not
    // possible for certain implementations.
    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'

    this._pc.oniceconnectionstatechange = () => {
      this._onIceStateChange()
    }
    this._pc.onicegatheringstatechange = () => {
      this._onIceStateChange()
    }
    this._pc.onconnectionstatechange = () => {
      this._onConnectionStateChange()
    }
    this._pc.onsignalingstatechange = () => {
      this._onSignalingStateChange()
    }
    this._pc.onicecandidate = event => {
      this._onIceCandidate(event)
    }

    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783
    if (typeof this._pc.peerIdentity === 'object') {
      this._pc.peerIdentity.catch(err => {
        this.destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))
      })
    }

    // Other spec events, unused by this implementation:
    // - onconnectionstatechange
    // - onicecandidateerror
    // - onfingerprintfailure
    // - onnegotiationneeded

    if (this.initiator || this.channelNegotiated) {
      this._setupData({
        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
      })
    } else {
      this._pc.ondatachannel = event => {
        this._setupData(event)
      }
    }

    if (this.streams) {
      this.streams.forEach(stream => {
        this.addStream(stream)
      })
    }
    this._pc.ontrack = event => {
      this._onTrack(event)
    }

    this._debug('initial negotiation')
    this._needsNegotiation()

    this._onFinishBound = () => {
      this._onFinish()
    }
    this.once('finish', this._onFinishBound)
  }

  get bufferSize () {
    return (this._channel && this._channel.bufferedAmount) || 0
  }

  // HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
  get connected () {
    return (this._connected && this._channel.readyState === 'open')
  }

  address () {
    return { port: this.localPort, family: this.localFamily, address: this.localAddress }
  }

  signal (data) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data)
      } catch (err) {
        data = {}
      }
    }
    this._debug('signal()')

    if (data.renegotiate && this.initiator) {
      this._debug('got request to renegotiate')
      this._needsNegotiation()
    }
    if (data.transceiverRequest && this.initiator) {
      this._debug('got request for transceiver')
      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)
    }
    if (data.candidate) {
      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
        this._addIceCandidate(data.candidate)
      } else {
        this._pendingCandidates.push(data.candidate)
      }
    }
    if (data.sdp) {
      this._pc.setRemoteDescription(new (this._wrtc.RTCSessionDescription)(data))
        .then(() => {
          if (this.destroyed) return

          this._pendingCandidates.forEach(candidate => {
            this._addIceCandidate(candidate)
          })
          this._pendingCandidates = []

          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()
        })
        .catch(err => {
          this.destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))
        })
    }
    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
      this.destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))
    }
  }

  _addIceCandidate (candidate) {
    const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate)
    this._pc.addIceCandidate(iceCandidateObj)
      .catch(err => {
        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {
          warn('Ignoring unsupported ICE candidate.')
        } else {
          this.destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))
        }
      })
  }

  /**
   * Send text/binary data to the remote peer.
   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
   */
  send (chunk) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')
    this._channel.send(chunk)
  }

  /**
   * Add a Transceiver to the connection.
   * @param {String} kind
   * @param {Object} init
   */
  addTransceiver (kind, init) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot addTransceiver after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('addTransceiver()')

    if (this.initiator) {
      try {
        this._pc.addTransceiver(kind, init)
        this._needsNegotiation()
      } catch (err) {
        this.destroy(errCode(err, 'ERR_ADD_TRANSCEIVER'))
      }
    } else {
      this.emit('signal', { // request initiator to renegotiate
        type: 'transceiverRequest',
        transceiverRequest: { kind, init }
      })
    }
  }

  /**
   * Add a MediaStream to the connection.
   * @param {MediaStream} stream
   */
  addStream (stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot addStream after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('addStream()')

    stream.getTracks().forEach(track => {
      this.addTrack(track, stream)
    })
  }

  /**
   * Add a MediaStreamTrack to the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */
  addTrack (track, stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot addTrack after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('addTrack()')

    const submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender
    let sender = submap.get(stream)
    if (!sender) {
      sender = this._pc.addTrack(track, stream)
      submap.set(stream, sender)
      this._senderMap.set(track, submap)
      this._needsNegotiation()
    } else if (sender.removed) {
      throw errCode(new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'), 'ERR_SENDER_REMOVED')
    } else {
      throw errCode(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED')
    }
  }

  /**
   * Replace a MediaStreamTrack by another in the connection.
   * @param {MediaStreamTrack} oldTrack
   * @param {MediaStreamTrack} newTrack
   * @param {MediaStream} stream
   */
  replaceTrack (oldTrack, newTrack, stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot replaceTrack after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('replaceTrack()')

    const submap = this._senderMap.get(oldTrack)
    const sender = submap ? submap.get(stream) : null
    if (!sender) {
      throw errCode(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED')
    }
    if (newTrack) this._senderMap.set(newTrack, submap)

    if (sender.replaceTrack != null) {
      sender.replaceTrack(newTrack)
    } else {
      this.destroy(errCode(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK'))
    }
  }

  /**
   * Remove a MediaStreamTrack from the connection.
   * @param {MediaStreamTrack} track
   * @param {MediaStream} stream
   */
  removeTrack (track, stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot removeTrack after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('removeSender()')

    const submap = this._senderMap.get(track)
    const sender = submap ? submap.get(stream) : null
    if (!sender) {
      throw errCode(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED')
    }
    try {
      sender.removed = true
      this._pc.removeTrack(sender)
    } catch (err) {
      if (err.name === 'NS_ERROR_UNEXPECTED') {
        this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874
      } else {
        this.destroy(errCode(err, 'ERR_REMOVE_TRACK'))
      }
    }
    this._needsNegotiation()
  }

  /**
   * Remove a MediaStream from the connection.
   * @param {MediaStream} stream
   */
  removeStream (stream) {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot removeStream after peer is destroyed'), 'ERR_DESTROYED')
    this._debug('removeSenders()')

    stream.getTracks().forEach(track => {
      this.removeTrack(track, stream)
    })
  }

  _needsNegotiation () {
    this._debug('_needsNegotiation')
    if (this._batchedNegotiation) return // batch synchronous renegotiations
    this._batchedNegotiation = true
    queueMicrotask(() => {
      this._batchedNegotiation = false
      if (this.initiator || !this._firstNegotiation) {
        this._debug('starting batched negotiation')
        this.negotiate()
      } else {
        this._debug('non-initiator initial negotiation request discarded')
      }
      this._firstNegotiation = false
    })
  }

  negotiate () {
    if (this.destroying) return
    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')

    if (this.initiator) {
      if (this._isNegotiating) {
        this._queuedNegotiation = true
        this._debug('already negotiating, queueing')
      } else {
        this._debug('start negotiation')
        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer
          this._createOffer()
        }, 0)
      }
    } else {
      if (this._isNegotiating) {
        this._queuedNegotiation = true
        this._debug('already negotiating, queueing')
      } else {
        this._debug('requesting negotiation from initiator')
        this.emit('signal', { // request initiator to renegotiate
          type: 'renegotiate',
          renegotiate: true
        })
      }
    }
    this._isNegotiating = true
  }

  // TODO: Delete this method once readable-stream is updated to contain a default
  // implementation of destroy() that automatically calls _destroy()
  // See: https://github.com/nodejs/readable-stream/issues/283
  destroy (err) {
    this._destroy(err, () => {})
  }

  _destroy (err, cb) {
    if (this.destroyed || this.destroying) return
    this.destroying = true

    this._debug('destroying (error: %s)', err && (err.message || err))

    queueMicrotask(() => { // allow events concurrent with the call to _destroy() to fire (see #692)
      this.destroyed = true
      this.destroying = false

      this._debug('destroy (error: %s)', err && (err.message || err))

      this.readable = this.writable = false

      if (!this._readableState.ended) this.push(null)
      if (!this._writableState.finished) this.end()

      this._connected = false
      this._pcReady = false
      this._channelReady = false
      this._remoteTracks = null
      this._remoteStreams = null
      this._senderMap = null

      clearInterval(this._closingInterval)
      this._closingInterval = null

      clearInterval(this._interval)
      this._interval = null
      this._chunk = null
      this._cb = null

      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)
      this._onFinishBound = null

      if (this._channel) {
        try {
          this._channel.close()
        } catch (err) {}

        // allow events concurrent with destruction to be handled
        this._channel.onmessage = null
        this._channel.onopen = null
        this._channel.onclose = null
        this._channel.onerror = null
      }
      if (this._pc) {
        try {
          this._pc.close()
        } catch (err) {}

        // allow events concurrent with destruction to be handled
        this._pc.oniceconnectionstatechange = null
        this._pc.onicegatheringstatechange = null
        this._pc.onsignalingstatechange = null
        this._pc.onicecandidate = null
        this._pc.ontrack = null
        this._pc.ondatachannel = null
      }
      this._pc = null
      this._channel = null

      if (err) this.emit('error', err)
      this.emit('close')
      cb()
    })
  }

  _setupData (event) {
    if (!event.channel) {
      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),
      // which is invalid behavior. Handle it gracefully.
      // See: https://github.com/feross/simple-peer/issues/163
      return this.destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))
    }

    this._channel = event.channel
    this._channel.binaryType = 'arraybuffer'

    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {
      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT
    }

    this.channelName = this._channel.label

    this._channel.onmessage = event => {
      this._onChannelMessage(event)
    }
    this._channel.onbufferedamountlow = () => {
      this._onChannelBufferedAmountLow()
    }
    this._channel.onopen = () => {
      this._onChannelOpen()
    }
    this._channel.onclose = () => {
      this._onChannelClose()
    }
    this._channel.onerror = event => {
      const err = event.error instanceof Error
        ? event.error
        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)
      this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
    }

    // HACK: Chrome will sometimes get stuck in readyState "closing", let's check for this condition
    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
    let isClosing = false
    this._closingInterval = setInterval(() => { // No "onclosing" event
      if (this._channel && this._channel.readyState === 'closing') {
        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing
        isClosing = true
      } else {
        isClosing = false
      }
    }, CHANNEL_CLOSING_TIMEOUT)
  }

  _read () {}

  _write (chunk, encoding, cb) {
    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))

    if (this._connected) {
      try {
        this.send(chunk)
      } catch (err) {
        return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
      }
      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)
        this._cb = cb
      } else {
        cb(null)
      }
    } else {
      this._debug('write before connect')
      this._chunk = chunk
      this._cb = cb
    }
  }

  // When stream finishes writing, close socket. Half open connections are not
  // supported.
  _onFinish () {
    if (this.destroyed) return

    // Wait a bit before destroying so the socket flushes.
    // TODO: is there a more reliable way to accomplish this?
    const destroySoon = () => {
      setTimeout(() => this.destroy(), 1000)
    }

    if (this._connected) {
      destroySoon()
    } else {
      this.once('connect', destroySoon)
    }
  }

  _startIceCompleteTimeout () {
    if (this.destroyed) return
    if (this._iceCompleteTimer) return
    this._debug('started iceComplete timeout')
    this._iceCompleteTimer = setTimeout(() => {
      if (!this._iceComplete) {
        this._iceComplete = true
        this._debug('iceComplete timeout completed')
        this.emit('iceTimeout')
        this.emit('_iceComplete')
      }
    }, this.iceCompleteTimeout)
  }

  _createOffer () {
    if (this.destroyed) return

    this._pc.createOffer(this.offerOptions)
      .then(offer => {
        if (this.destroyed) return
        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)
        offer.sdp = this.sdpTransform(offer.sdp)

        const sendOffer = () => {
          if (this.destroyed) return
          const signal = this._pc.localDescription || offer
          this._debug('signal')
          this.emit('signal', {
            type: signal.type,
            sdp: signal.sdp
          })
        }

        const onSuccess = () => {
          this._debug('createOffer success')
          if (this.destroyed) return
          if (this.trickle || this._iceComplete) sendOffer()
          else this.once('_iceComplete', sendOffer) // wait for candidates
        }

        const onError = err => {
          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))
        }

        this._pc.setLocalDescription(offer)
          .then(onSuccess)
          .catch(onError)
      })
      .catch(err => {
        this.destroy(errCode(err, 'ERR_CREATE_OFFER'))
      })
  }

  _requestMissingTransceivers () {
    if (this._pc.getTransceivers) {
      this._pc.getTransceivers().forEach(transceiver => {
        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
          transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid
          this.addTransceiver(transceiver.sender.track.kind)
        }
      })
    }
  }

  _createAnswer () {
    if (this.destroyed) return

    this._pc.createAnswer(this.answerOptions)
      .then(answer => {
        if (this.destroyed) return
        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)
        answer.sdp = this.sdpTransform(answer.sdp)

        const sendAnswer = () => {
          if (this.destroyed) return
          const signal = this._pc.localDescription || answer
          this._debug('signal')
          this.emit('signal', {
            type: signal.type,
            sdp: signal.sdp
          })
          if (!this.initiator) this._requestMissingTransceivers()
        }

        const onSuccess = () => {
          if (this.destroyed) return
          if (this.trickle || this._iceComplete) sendAnswer()
          else this.once('_iceComplete', sendAnswer)
        }

        const onError = err => {
          this.destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))
        }

        this._pc.setLocalDescription(answer)
          .then(onSuccess)
          .catch(onError)
      })
      .catch(err => {
        this.destroy(errCode(err, 'ERR_CREATE_ANSWER'))
      })
  }

  _onConnectionStateChange () {
    if (this.destroyed) return
    if (this._pc.connectionState === 'failed') {
      this.destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))
    }
  }

  _onIceStateChange () {
    if (this.destroyed) return
    const iceConnectionState = this._pc.iceConnectionState
    const iceGatheringState = this._pc.iceGatheringState

    this._debug(
      'iceStateChange (connection: %s) (gathering: %s)',
      iceConnectionState,
      iceGatheringState
    )
    this.emit('iceStateChange', iceConnectionState, iceGatheringState)

    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
      this._pcReady = true
      this._maybeReady()
    }
    if (iceConnectionState === 'failed') {
      this.destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))
    }
    if (iceConnectionState === 'closed') {
      this.destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))
    }
  }

  getStats (cb) {
    // statreports can come with a value array instead of properties
    const flattenValues = report => {
      if (Object.prototype.toString.call(report.values) === '[object Array]') {
        report.values.forEach(value => {
          Object.assign(report, value)
        })
      }
      return report
    }

    // Promise-based getStats() (standard)
    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
      this._pc.getStats()
        .then(res => {
          const reports = []
          res.forEach(report => {
            reports.push(flattenValues(report))
          })
          cb(null, reports)
        }, err => cb(err))

    // Single-parameter callback-based getStats() (non-standard)
    } else if (this._pc.getStats.length > 0) {
      this._pc.getStats(res => {
        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed
        if (this.destroyed) return

        const reports = []
        res.result().forEach(result => {
          const report = {}
          result.names().forEach(name => {
            report[name] = result.stat(name)
          })
          report.id = result.id
          report.type = result.type
          report.timestamp = result.timestamp
          reports.push(flattenValues(report))
        })
        cb(null, reports)
      }, err => cb(err))

    // Unknown browser, skip getStats() since it's anyone's guess which style of
    // getStats() they implement.
    } else {
      cb(null, [])
    }
  }

  _maybeReady () {
    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)
    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return

    this._connecting = true

    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339
    const findCandidatePair = () => {
      if (this.destroyed) return

      this.getStats((err, items) => {
        if (this.destroyed) return

        // Treat getStats error as non-fatal. It's not essential.
        if (err) items = []

        const remoteCandidates = {}
        const localCandidates = {}
        const candidatePairs = {}
        let foundSelectedCandidatePair = false

        items.forEach(item => {
          // TODO: Once all browsers support the hyphenated stats report types, remove
          // the non-hypenated ones
          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {
            remoteCandidates[item.id] = item
          }
          if (item.type === 'localcandidate' || item.type === 'local-candidate') {
            localCandidates[item.id] = item
          }
          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {
            candidatePairs[item.id] = item
          }
        })

        const setSelectedCandidatePair = selectedCandidatePair => {
          foundSelectedCandidatePair = true

          let local = localCandidates[selectedCandidatePair.localCandidateId]

          if (local && (local.ip || local.address)) {
            // Spec
            this.localAddress = local.ip || local.address
            this.localPort = Number(local.port)
          } else if (local && local.ipAddress) {
            // Firefox
            this.localAddress = local.ipAddress
            this.localPort = Number(local.portNumber)
          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {
            // TODO: remove this once Chrome 58 is released
            local = selectedCandidatePair.googLocalAddress.split(':')
            this.localAddress = local[0]
            this.localPort = Number(local[1])
          }
          if (this.localAddress) {
            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'
          }

          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]

          if (remote && (remote.ip || remote.address)) {
            // Spec
            this.remoteAddress = remote.ip || remote.address
            this.remotePort = Number(remote.port)
          } else if (remote && remote.ipAddress) {
            // Firefox
            this.remoteAddress = remote.ipAddress
            this.remotePort = Number(remote.portNumber)
          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {
            // TODO: remove this once Chrome 58 is released
            remote = selectedCandidatePair.googRemoteAddress.split(':')
            this.remoteAddress = remote[0]
            this.remotePort = Number(remote[1])
          }
          if (this.remoteAddress) {
            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'
          }

          this._debug(
            'connect local: %s:%s remote: %s:%s',
            this.localAddress,
            this.localPort,
            this.remoteAddress,
            this.remotePort
          )
        }

        items.forEach(item => {
          // Spec-compliant
          if (item.type === 'transport' && item.selectedCandidatePairId) {
            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])
          }

          // Old implementations
          if (
            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||
            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)
          ) {
            setSelectedCandidatePair(item)
          }
        })

        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates
        // But wait until at least 1 candidate pair is available
        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
          setTimeout(findCandidatePair, 100)
          return
        } else {
          this._connecting = false
          this._connected = true
        }

        if (this._chunk) {
          try {
            this.send(this._chunk)
          } catch (err) {
            return this.destroy(errCode(err, 'ERR_DATA_CHANNEL'))
          }
          this._chunk = null
          this._debug('sent chunk from "write before connect"')

          const cb = this._cb
          this._cb = null
          cb(null)
        }

        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,
        // fallback to using setInterval to implement backpressure.
        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {
          this._interval = setInterval(() => this._onInterval(), 150)
          if (this._interval.unref) this._interval.unref()
        }

        this._debug('connect')
        this.emit('connect')
      })
    }
    findCandidatePair()
  }

  _onInterval () {
    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      return
    }
    this._onChannelBufferedAmountLow()
  }

  _onSignalingStateChange () {
    if (this.destroyed) return

    if (this._pc.signalingState === 'stable') {
      this._isNegotiating = false

      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'
      this._debug('flushing sender queue', this._sendersAwaitingStable)
      this._sendersAwaitingStable.forEach(sender => {
        this._pc.removeTrack(sender)
        this._queuedNegotiation = true
      })
      this._sendersAwaitingStable = []

      if (this._queuedNegotiation) {
        this._debug('flushing negotiation queue')
        this._queuedNegotiation = false
        this._needsNegotiation() // negotiate again
      } else {
        this._debug('negotiated')
        this.emit('negotiated')
      }
    }

    this._debug('signalingStateChange %s', this._pc.signalingState)
    this.emit('signalingStateChange', this._pc.signalingState)
  }

  _onIceCandidate (event) {
    if (this.destroyed) return
    if (event.candidate && this.trickle) {
      this.emit('signal', {
        type: 'candidate',
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      })
    } else if (!event.candidate && !this._iceComplete) {
      this._iceComplete = true
      this.emit('_iceComplete')
    }
    // as soon as we've received one valid candidate start timeout
    if (event.candidate) {
      this._startIceCompleteTimeout()
    }
  }

  _onChannelMessage (event) {
    if (this.destroyed) return
    let data = event.data
    if (data instanceof ArrayBuffer) data = Buffer.from(data)
    this.push(data)
  }

  _onChannelBufferedAmountLow () {
    if (this.destroyed || !this._cb) return
    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)
    const cb = this._cb
    this._cb = null
    cb(null)
  }

  _onChannelOpen () {
    if (this._connected || this.destroyed) return
    this._debug('on channel open')
    this._channelReady = true
    this._maybeReady()
  }

  _onChannelClose () {
    if (this.destroyed) return
    this._debug('on channel close')
    this.destroy()
  }

  _onTrack (event) {
    if (this.destroyed) return

    event.streams.forEach(eventStream => {
      this._debug('on track')
      this.emit('track', event.track, eventStream)

      this._remoteTracks.push({
        track: event.track,
        stream: eventStream
      })

      if (this._remoteStreams.some(remoteStream => {
        return remoteStream.id === eventStream.id
      })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream

      this._remoteStreams.push(eventStream)
      queueMicrotask(() => {
        this._debug('on stream')
        this.emit('stream', eventStream) // ensure all tracks have been added
      })
    })
  }

  _debug () {
    const args = [].slice.call(arguments)
    args[0] = '[' + this._id + '] ' + args[0]
    debug.apply(null, args)
  }
}

Peer.WEBRTC_SUPPORT = !!getBrowserRTC()

/**
 * Expose peer and data channel config for overriding all Peer
 * instances. Otherwise, just set opts.config or opts.channelConfig
 * when constructing a Peer.
 */
Peer.config = {
  iceServers: [
    {
      urls: [
        'stun:stun.l.google.com:19302',
        'stun:global.stun.twilio.com:3478'
      ]
    }
  ],
  sdpSemantics: 'unified-plan'
}

Peer.channelConfig = {}

module.exports = Peer

},{"buffer":117,"debug":10,"err-code":14,"get-browser-rtc":16,"queue-microtask":32,"randombytes":33,"readable-stream":48}],64:[function(require,module,exports){
var engine = require('../src/store-engine')

var storages = require('../storages/all')
var plugins = [require('../plugins/json2')]

module.exports = engine.createStore(storages, plugins)

},{"../plugins/json2":65,"../src/store-engine":67,"../storages/all":69}],65:[function(require,module,exports){
module.exports = json2Plugin

function json2Plugin() {
	require('./lib/json2')
	return {}
}

},{"./lib/json2":66}],66:[function(require,module,exports){
/* eslint-disable */

//  json2.js
//  2016-10-28
//  Public Domain.
//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
//  See http://www.JSON.org/js.html
//  This code should be minified before deployment.
//  See http://javascript.crockford.com/jsmin.html

//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
//  NOT CONTROL.

//  This file creates a global JSON object containing two methods: stringify
//  and parse. This file provides the ES5 JSON capability to ES3 systems.
//  If a project might run on IE8 or earlier, then this file should be included.
//  This file does nothing on ES5 systems.

//      JSON.stringify(value, replacer, space)
//          value       any JavaScript value, usually an object or array.
//          replacer    an optional parameter that determines how object
//                      values are stringified for objects. It can be a
//                      function or an array of strings.
//          space       an optional parameter that specifies the indentation
//                      of nested structures. If it is omitted, the text will
//                      be packed without extra whitespace. If it is a number,
//                      it will specify the number of spaces to indent at each
//                      level. If it is a string (such as "\t" or "&nbsp;"),
//                      it contains the characters used to indent at each level.
//          This method produces a JSON text from a JavaScript value.
//          When an object value is found, if the object contains a toJSON
//          method, its toJSON method will be called and the result will be
//          stringified. A toJSON method does not serialize: it returns the
//          value represented by the name/value pair that should be serialized,
//          or undefined if nothing should be serialized. The toJSON method
//          will be passed the key associated with the value, and this will be
//          bound to the value.

//          For example, this would serialize Dates as ISO strings.

//              Date.prototype.toJSON = function (key) {
//                  function f(n) {
//                      // Format integers to have at least two digits.
//                      return (n < 10)
//                          ? "0" + n
//                          : n;
//                  }
//                  return this.getUTCFullYear()   + "-" +
//                       f(this.getUTCMonth() + 1) + "-" +
//                       f(this.getUTCDate())      + "T" +
//                       f(this.getUTCHours())     + ":" +
//                       f(this.getUTCMinutes())   + ":" +
//                       f(this.getUTCSeconds())   + "Z";
//              };

//          You can provide an optional replacer method. It will be passed the
//          key and value of each member, with this bound to the containing
//          object. The value that is returned from your method will be
//          serialized. If your method returns undefined, then the member will
//          be excluded from the serialization.

//          If the replacer parameter is an array of strings, then it will be
//          used to select the members to be serialized. It filters the results
//          such that only members with keys listed in the replacer array are
//          stringified.

//          Values that do not have JSON representations, such as undefined or
//          functions, will not be serialized. Such values in objects will be
//          dropped; in arrays they will be replaced with null. You can use
//          a replacer function to replace those with JSON values.

//          JSON.stringify(undefined) returns undefined.

//          The optional space parameter produces a stringification of the
//          value that is filled with line breaks and indentation to make it
//          easier to read.

//          If the space parameter is a non-empty string, then that string will
//          be used for indentation. If the space parameter is a number, then
//          the indentation will be that many spaces.

//          Example:

//          text = JSON.stringify(["e", {pluribus: "unum"}]);
//          // text is '["e",{"pluribus":"unum"}]'

//          text = JSON.stringify(["e", {pluribus: "unum"}], null, "\t");
//          // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

//          text = JSON.stringify([new Date()], function (key, value) {
//              return this[key] instanceof Date
//                  ? "Date(" + this[key] + ")"
//                  : value;
//          });
//          // text is '["Date(---current time---)"]'

//      JSON.parse(text, reviver)
//          This method parses a JSON text to produce an object or array.
//          It can throw a SyntaxError exception.

//          The optional reviver parameter is a function that can filter and
//          transform the results. It receives each of the keys and values,
//          and its return value is used instead of the original value.
//          If it returns what it received, then the structure is not modified.
//          If it returns undefined then the member is deleted.

//          Example:

//          // Parse the text. Values that look like ISO date strings will
//          // be converted to Date objects.

//          myData = JSON.parse(text, function (key, value) {
//              var a;
//              if (typeof value === "string") {
//                  a =
//   /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
//                  if (a) {
//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
//                          +a[5], +a[6]));
//                  }
//              }
//              return value;
//          });

//          myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
//              var d;
//              if (typeof value === "string" &&
//                      value.slice(0, 5) === "Date(" &&
//                      value.slice(-1) === ")") {
//                  d = new Date(value.slice(5, -1));
//                  if (d) {
//                      return d;
//                  }
//              }
//              return value;
//          });

//  This is a reference implementation. You are free to copy, modify, or
//  redistribute.

/*jslint
    eval, for, this
*/

/*property
    JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== "object") {
    JSON = {};
}

(function () {
    "use strict";

    var rx_one = /^[\],:{}\s]*$/;
    var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
    var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
    var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10
            ? "0" + n
            : n;
    }

    function this_value() {
        return this.valueOf();
    }

    if (typeof Date.prototype.toJSON !== "function") {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear() + "-" +
                        f(this.getUTCMonth() + 1) + "-" +
                        f(this.getUTCDate()) + "T" +
                        f(this.getUTCHours()) + ":" +
                        f(this.getUTCMinutes()) + ":" +
                        f(this.getUTCSeconds()) + "Z"
                : null;
        };

        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
    }

    var gap;
    var indent;
    var meta;
    var rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string)
            ? "\"" + string.replace(rx_escapable, function (a) {
                var c = meta[a];
                return typeof c === "string"
                    ? c
                    : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }) + "\""
            : "\"" + string + "\"";
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i;          // The loop counter.
        var k;          // The member key.
        var v;          // The member value.
        var length;
        var mind = gap;
        var partial;
        var value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === "object" &&
                typeof value.toJSON === "function") {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === "function") {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case "string":
            return quote(value);

        case "number":

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value)
                ? String(value)
                : "null";

        case "boolean":
        case "null":

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce "null". The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is "object", we might be dealing with an object or an array or
// null.

        case "object":

// Due to a specification blunder in ECMAScript, typeof null is "object",
// so watch out for that case.

            if (!value) {
                return "null";
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === "[object Array]") {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || "null";
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? "[]"
                    : gap
                        ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
                        : "[" + partial.join(",") + "]";
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === "object") {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === "string") {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? "{}"
                : gap
                    ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                    : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== "function") {
        meta = {    // table of character substitutions
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\"": "\\\"",
            "\\": "\\\\"
        };
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = "";
            indent = "";

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === "number") {
                for (i = 0; i < space; i += 1) {
                    indent += " ";
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === "string") {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== "function" &&
                    (typeof replacer !== "object" ||
                    typeof replacer.length !== "number")) {
                throw new Error("JSON.stringify");
            }

// Make a fake root object containing our value under the key of "".
// Return the result of stringifying the value.

            return str("", {"": value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== "function") {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k;
                var v;
                var value = holder[key];
                if (value && typeof value === "object") {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return "\\u" +
                            ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with "()" and "new"
// because they can cause invocation, and "=" because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with "@" (a non-JSON character). Second, we
// replace all simple value tokens with "]" characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or "]" or
// "," or ":" or "{" or "}". If that is so, then the text is safe for eval.

            if (
                rx_one.test(
                    text
                        .replace(rx_two, "@")
                        .replace(rx_three, "]")
                        .replace(rx_four, "")
                )
            ) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The "{" operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval("(" + text + ")");

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return (typeof reviver === "function")
                    ? walk({"": j}, "")
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError("JSON.parse");
        };
    }
}());
},{}],67:[function(require,module,exports){
var util = require('./util')
var slice = util.slice
var pluck = util.pluck
var each = util.each
var bind = util.bind
var create = util.create
var isList = util.isList
var isFunction = util.isFunction
var isObject = util.isObject

module.exports = {
	createStore: createStore
}

var storeAPI = {
	version: '2.0.12',
	enabled: false,
	
	// get returns the value of the given key. If that value
	// is undefined, it returns optionalDefaultValue instead.
	get: function(key, optionalDefaultValue) {
		var data = this.storage.read(this._namespacePrefix + key)
		return this._deserialize(data, optionalDefaultValue)
	},

	// set will store the given value at key and returns value.
	// Calling set with value === undefined is equivalent to calling remove.
	set: function(key, value) {
		if (value === undefined) {
			return this.remove(key)
		}
		this.storage.write(this._namespacePrefix + key, this._serialize(value))
		return value
	},

	// remove deletes the key and value stored at the given key.
	remove: function(key) {
		this.storage.remove(this._namespacePrefix + key)
	},

	// each will call the given callback once for each key-value pair
	// in this store.
	each: function(callback) {
		var self = this
		this.storage.each(function(val, namespacedKey) {
			callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''))
		})
	},

	// clearAll will remove all the stored key-value pairs in this store.
	clearAll: function() {
		this.storage.clearAll()
	},

	// additional functionality that can't live in plugins
	// ---------------------------------------------------

	// hasNamespace returns true if this store instance has the given namespace.
	hasNamespace: function(namespace) {
		return (this._namespacePrefix == '__storejs_'+namespace+'_')
	},

	// createStore creates a store.js instance with the first
	// functioning storage in the list of storage candidates,
	// and applies the the given mixins to the instance.
	createStore: function() {
		return createStore.apply(this, arguments)
	},
	
	addPlugin: function(plugin) {
		this._addPlugin(plugin)
	},
	
	namespace: function(namespace) {
		return createStore(this.storage, this.plugins, namespace)
	}
}

function _warn() {
	var _console = (typeof console == 'undefined' ? null : console)
	if (!_console) { return }
	var fn = (_console.warn ? _console.warn : _console.log)
	fn.apply(_console, arguments)
}

function createStore(storages, plugins, namespace) {
	if (!namespace) {
		namespace = ''
	}
	if (storages && !isList(storages)) {
		storages = [storages]
	}
	if (plugins && !isList(plugins)) {
		plugins = [plugins]
	}

	var namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '')
	var namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null)
	var legalNamespaces = /^[a-zA-Z0-9_\-]*$/ // alpha-numeric + underscore and dash
	if (!legalNamespaces.test(namespace)) {
		throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes')
	}
	
	var _privateStoreProps = {
		_namespacePrefix: namespacePrefix,
		_namespaceRegexp: namespaceRegexp,

		_testStorage: function(storage) {
			try {
				var testStr = '__storejs__test__'
				storage.write(testStr, testStr)
				var ok = (storage.read(testStr) === testStr)
				storage.remove(testStr)
				return ok
			} catch(e) {
				return false
			}
		},

		_assignPluginFnProp: function(pluginFnProp, propName) {
			var oldFn = this[propName]
			this[propName] = function pluginFn() {
				var args = slice(arguments, 0)
				var self = this

				// super_fn calls the old function which was overwritten by
				// this mixin.
				function super_fn() {
					if (!oldFn) { return }
					each(arguments, function(arg, i) {
						args[i] = arg
					})
					return oldFn.apply(self, args)
				}

				// Give mixing function access to super_fn by prefixing all mixin function
				// arguments with super_fn.
				var newFnArgs = [super_fn].concat(args)

				return pluginFnProp.apply(self, newFnArgs)
			}
		},

		_serialize: function(obj) {
			return JSON.stringify(obj)
		},

		_deserialize: function(strVal, defaultVal) {
			if (!strVal) { return defaultVal }
			// It is possible that a raw string value has been previously stored
			// in a storage without using store.js, meaning it will be a raw
			// string value instead of a JSON serialized string. By defaulting
			// to the raw string value in case of a JSON parse error, we allow
			// for past stored values to be forwards-compatible with store.js
			var val = ''
			try { val = JSON.parse(strVal) }
			catch(e) { val = strVal }

			return (val !== undefined ? val : defaultVal)
		},
		
		_addStorage: function(storage) {
			if (this.enabled) { return }
			if (this._testStorage(storage)) {
				this.storage = storage
				this.enabled = true
			}
		},

		_addPlugin: function(plugin) {
			var self = this

			// If the plugin is an array, then add all plugins in the array.
			// This allows for a plugin to depend on other plugins.
			if (isList(plugin)) {
				each(plugin, function(plugin) {
					self._addPlugin(plugin)
				})
				return
			}

			// Keep track of all plugins we've seen so far, so that we
			// don't add any of them twice.
			var seenPlugin = pluck(this.plugins, function(seenPlugin) {
				return (plugin === seenPlugin)
			})
			if (seenPlugin) {
				return
			}
			this.plugins.push(plugin)

			// Check that the plugin is properly formed
			if (!isFunction(plugin)) {
				throw new Error('Plugins must be function values that return objects')
			}

			var pluginProperties = plugin.call(this)
			if (!isObject(pluginProperties)) {
				throw new Error('Plugins must return an object of function properties')
			}

			// Add the plugin function properties to this store instance.
			each(pluginProperties, function(pluginFnProp, propName) {
				if (!isFunction(pluginFnProp)) {
					throw new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')
				}
				self._assignPluginFnProp(pluginFnProp, propName)
			})
		},
		
		// Put deprecated properties in the private API, so as to not expose it to accidential
		// discovery through inspection of the store object.
		
		// Deprecated: addStorage
		addStorage: function(storage) {
			_warn('store.addStorage(storage) is deprecated. Use createStore([storages])')
			this._addStorage(storage)
		}
	}

	var store = create(_privateStoreProps, storeAPI, {
		plugins: []
	})
	store.raw = {}
	each(store, function(prop, propName) {
		if (isFunction(prop)) {
			store.raw[propName] = bind(store, prop)			
		}
	})
	each(storages, function(storage) {
		store._addStorage(storage)
	})
	each(plugins, function(plugin) {
		store._addPlugin(plugin)
	})
	return store
}

},{"./util":68}],68:[function(require,module,exports){
(function (global){(function (){
var assign = make_assign()
var create = make_create()
var trim = make_trim()
var Global = (typeof window !== 'undefined' ? window : global)

module.exports = {
	assign: assign,
	create: create,
	trim: trim,
	bind: bind,
	slice: slice,
	each: each,
	map: map,
	pluck: pluck,
	isList: isList,
	isFunction: isFunction,
	isObject: isObject,
	Global: Global
}

function make_assign() {
	if (Object.assign) {
		return Object.assign
	} else {
		return function shimAssign(obj, props1, props2, etc) {
			for (var i = 1; i < arguments.length; i++) {
				each(Object(arguments[i]), function(val, key) {
					obj[key] = val
				})
			}			
			return obj
		}
	}
}

function make_create() {
	if (Object.create) {
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1)
			return assign.apply(this, [Object.create(obj)].concat(assignArgsList))
		}
	} else {
		function F() {} // eslint-disable-line no-inner-declarations
		return function create(obj, assignProps1, assignProps2, etc) {
			var assignArgsList = slice(arguments, 1)
			F.prototype = obj
			return assign.apply(this, [new F()].concat(assignArgsList))
		}
	}
}

function make_trim() {
	if (String.prototype.trim) {
		return function trim(str) {
			return String.prototype.trim.call(str)
		}
	} else {
		return function trim(str) {
			return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
		}
	}
}

function bind(obj, fn) {
	return function() {
		return fn.apply(obj, Array.prototype.slice.call(arguments, 0))
	}
}

function slice(arr, index) {
	return Array.prototype.slice.call(arr, index || 0)
}

function each(obj, fn) {
	pluck(obj, function(val, key) {
		fn(val, key)
		return false
	})
}

function map(obj, fn) {
	var res = (isList(obj) ? [] : {})
	pluck(obj, function(v, k) {
		res[k] = fn(v, k)
		return false
	})
	return res
}

function pluck(obj, fn) {
	if (isList(obj)) {
		for (var i=0; i<obj.length; i++) {
			if (fn(obj[i], i)) {
				return obj[i]
			}
		}
	} else {
		for (var key in obj) {
			if (obj.hasOwnProperty(key)) {
				if (fn(obj[key], key)) {
					return obj[key]
				}
			}
		}
	}
}

function isList(val) {
	return (val != null && typeof val != 'function' && typeof val.length == 'number')
}

function isFunction(val) {
	return val && {}.toString.call(val) === '[object Function]'
}

function isObject(val) {
	return val && {}.toString.call(val) === '[object Object]'
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],69:[function(require,module,exports){
module.exports = [
	// Listed in order of usage preference
	require('./localStorage'),
	require('./oldFF-globalStorage'),
	require('./oldIE-userDataStorage'),
	require('./cookieStorage'),
	require('./sessionStorage'),
	require('./memoryStorage')
]

},{"./cookieStorage":70,"./localStorage":71,"./memoryStorage":72,"./oldFF-globalStorage":73,"./oldIE-userDataStorage":74,"./sessionStorage":75}],70:[function(require,module,exports){
// cookieStorage is useful Safari private browser mode, where localStorage
// doesn't work but cookies do. This implementation is adopted from
// https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage

var util = require('../src/util')
var Global = util.Global
var trim = util.trim

module.exports = {
	name: 'cookieStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var doc = Global.document

function read(key) {
	if (!key || !_has(key)) { return null }
	var regexpStr = "(?:^|.*;\\s*)" +
		escape(key).replace(/[\-\.\+\*]/g, "\\$&") +
		"\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"
	return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"))
}

function each(callback) {
	var cookies = doc.cookie.split(/; ?/g)
	for (var i = cookies.length - 1; i >= 0; i--) {
		if (!trim(cookies[i])) {
			continue
		}
		var kvp = cookies[i].split('=')
		var key = unescape(kvp[0])
		var val = unescape(kvp[1])
		callback(val, key)
	}
}

function write(key, data) {
	if(!key) { return }
	doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/"
}

function remove(key) {
	if (!key || !_has(key)) {
		return
	}
	doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/"
}

function clearAll() {
	each(function(_, key) {
		remove(key)
	})
}

function _has(key) {
	return (new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(doc.cookie)
}

},{"../src/util":68}],71:[function(require,module,exports){
var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'localStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

function localStorage() {
	return Global.localStorage
}

function read(key) {
	return localStorage().getItem(key)
}

function write(key, data) {
	return localStorage().setItem(key, data)
}

function each(fn) {
	for (var i = localStorage().length - 1; i >= 0; i--) {
		var key = localStorage().key(i)
		fn(read(key), key)
	}
}

function remove(key) {
	return localStorage().removeItem(key)
}

function clearAll() {
	return localStorage().clear()
}

},{"../src/util":68}],72:[function(require,module,exports){
// memoryStorage is a useful last fallback to ensure that the store
// is functions (meaning store.get(), store.set(), etc will all function).
// However, stored values will not persist when the browser navigates to
// a new page or reloads the current page.

module.exports = {
	name: 'memoryStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var memoryStorage = {}

function read(key) {
	return memoryStorage[key]
}

function write(key, data) {
	memoryStorage[key] = data
}

function each(callback) {
	for (var key in memoryStorage) {
		if (memoryStorage.hasOwnProperty(key)) {
			callback(memoryStorage[key], key)
		}
	}
}

function remove(key) {
	delete memoryStorage[key]
}

function clearAll(key) {
	memoryStorage = {}
}

},{}],73:[function(require,module,exports){
// oldFF-globalStorage provides storage for Firefox
// versions 6 and 7, where no localStorage, etc
// is available.

var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'oldFF-globalStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var globalStorage = Global.globalStorage

function read(key) {
	return globalStorage[key]
}

function write(key, data) {
	globalStorage[key] = data
}

function each(fn) {
	for (var i = globalStorage.length - 1; i >= 0; i--) {
		var key = globalStorage.key(i)
		fn(globalStorage[key], key)
	}
}

function remove(key) {
	return globalStorage.removeItem(key)
}

function clearAll() {
	each(function(key, _) {
		delete globalStorage[key]
	})
}

},{"../src/util":68}],74:[function(require,module,exports){
// oldIE-userDataStorage provides storage for Internet Explorer
// versions 6 and 7, where no localStorage, sessionStorage, etc
// is available.

var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'oldIE-userDataStorage',
	write: write,
	read: read,
	each: each,
	remove: remove,
	clearAll: clearAll,
}

var storageName = 'storejs'
var doc = Global.document
var _withStorageEl = _makeIEStorageElFunction()
var disable = (Global.navigator ? Global.navigator.userAgent : '').match(/ (MSIE 8|MSIE 9|MSIE 10)\./) // MSIE 9.x, MSIE 10.x

function write(unfixedKey, data) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey)
	_withStorageEl(function(storageEl) {
		storageEl.setAttribute(fixedKey, data)
		storageEl.save(storageName)
	})
}

function read(unfixedKey) {
	if (disable) { return }
	var fixedKey = fixKey(unfixedKey)
	var res = null
	_withStorageEl(function(storageEl) {
		res = storageEl.getAttribute(fixedKey)
	})
	return res
}

function each(callback) {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes
		for (var i=attributes.length-1; i>=0; i--) {
			var attr = attributes[i]
			callback(storageEl.getAttribute(attr.name), attr.name)
		}
	})
}

function remove(unfixedKey) {
	var fixedKey = fixKey(unfixedKey)
	_withStorageEl(function(storageEl) {
		storageEl.removeAttribute(fixedKey)
		storageEl.save(storageName)
	})
}

function clearAll() {
	_withStorageEl(function(storageEl) {
		var attributes = storageEl.XMLDocument.documentElement.attributes
		storageEl.load(storageName)
		for (var i=attributes.length-1; i>=0; i--) {
			storageEl.removeAttribute(attributes[i].name)
		}
		storageEl.save(storageName)
	})
}

// Helpers
//////////

// In IE7, keys cannot start with a digit or contain certain chars.
// See https://github.com/marcuswestin/store.js/issues/40
// See https://github.com/marcuswestin/store.js/issues/83
var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g")
function fixKey(key) {
	return key.replace(/^\d/, '___$&').replace(forbiddenCharsRegex, '___')
}

function _makeIEStorageElFunction() {
	if (!doc || !doc.documentElement || !doc.documentElement.addBehavior) {
		return null
	}
	var scriptTag = 'script',
		storageOwner,
		storageContainer,
		storageEl

	// Since #userData storage applies only to specific paths, we need to
	// somehow link our data to a specific path.  We choose /favicon.ico
	// as a pretty safe option, since all browsers already make a request to
	// this URL anyway and being a 404 will not hurt us here.  We wrap an
	// iframe pointing to the favicon in an ActiveXObject(htmlfile) object
	// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)
	// since the iframe access rules appear to allow direct access and
	// manipulation of the document element, even for a 404 page.  This
	// document can be used instead of the current document (which would
	// have been limited to the current path) to perform #userData storage.
	try {
		/* global ActiveXObject */
		storageContainer = new ActiveXObject('htmlfile')
		storageContainer.open()
		storageContainer.write('<'+scriptTag+'>document.w=window</'+scriptTag+'><iframe src="/favicon.ico"></iframe>')
		storageContainer.close()
		storageOwner = storageContainer.w.frames[0].document
		storageEl = storageOwner.createElement('div')
	} catch(e) {
		// somehow ActiveXObject instantiation failed (perhaps some special
		// security settings or otherwse), fall back to per-path storage
		storageEl = doc.createElement('div')
		storageOwner = doc.body
	}

	return function(storeFunction) {
		var args = [].slice.call(arguments, 0)
		args.unshift(storageEl)
		// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx
		// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx
		storageOwner.appendChild(storageEl)
		storageEl.addBehavior('#default#userData')
		storageEl.load(storageName)
		storeFunction.apply(this, args)
		storageOwner.removeChild(storageEl)
		return
	}
}

},{"../src/util":68}],75:[function(require,module,exports){
var util = require('../src/util')
var Global = util.Global

module.exports = {
	name: 'sessionStorage',
	read: read,
	write: write,
	each: each,
	remove: remove,
	clearAll: clearAll
}

function sessionStorage() {
	return Global.sessionStorage
}

function read(key) {
	return sessionStorage().getItem(key)
}

function write(key, data) {
	return sessionStorage().setItem(key, data)
}

function each(fn) {
	for (var i = sessionStorage().length - 1; i >= 0; i--) {
		var key = sessionStorage().key(i)
		fn(read(key), key)
	}
}

function remove(key) {
	return sessionStorage().removeItem(key)
}

function clearAll() {
	return sessionStorage().clear()
}

},{"../src/util":68}],76:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":50}],77:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":78,"./_stream_writable":80,"_process":136,"core-util-is":9,"inherits":21}],78:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;
  var ret;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    ret = null;

    // In cases where the decoder did not receive enough data
    // to produce a full chunk, then immediately received an
    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
    // howMuchToRead will see this and coerce the amount to
    // read to zero (because it's looking at the length of the
    // first <Buffer > in state.buffer), and we'll end up here.
    //
    // This can only happen via state.decoder -- no other venue
    // exists for pushing a zero-length chunk into state.buffer
    // and triggering this behavior. In this case, we return our
    // remaining data and end the stream, if appropriate.
    if (state.length > 0 && state.decoder) {
      ret = fromList(n, state);
      state.length -= ret.length;
    }

    if (state.length === 0)
      endReadable(this);

    return ret;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    //if (state.objectMode && util.isNullOrUndefined(chunk))
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this)}).call(this,require('_process'))

},{"_process":136,"buffer":117,"core-util-is":9,"events":121,"inherits":21,"isarray":81,"stream":141,"string_decoder/":82}],79:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":77,"core-util-is":9,"inherits":21}],80:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this)}).call(this,require('_process'))

},{"./_stream_duplex":77,"_process":136,"buffer":117,"core-util-is":9,"inherits":21,"stream":141}],81:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],82:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":117}],83:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":79}],84:[function(require,module,exports){
(function (process){(function (){
var Transform = require('readable-stream/transform')
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

},{"_process":136,"readable-stream/transform":83,"util":161,"xtend":111}],85:[function(require,module,exports){
var Buffer = require('buffer').Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}

},{"buffer":117}],86:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./nil.js":89,"./parse.js":90,"./stringify.js":94,"./v1.js":95,"./v3.js":96,"./v4.js":98,"./v5.js":99,"./validate.js":100,"./version.js":101}],88:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
},{}],89:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
},{}],90:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
},{"./validate.js":100}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
},{}],92:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
},{}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
},{}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
},{"./validate.js":100}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;
},{"./rng.js":92,"./stringify.js":94}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
},{"./md5.js":88,"./v35.js":97}],97:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
},{"./parse.js":90,"./stringify.js":94}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;
},{"./rng.js":92,"./stringify.js":94}],99:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
},{"./sha1.js":93,"./v35.js":97}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
},{"./regex.js":91}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
},{"./validate.js":100}],102:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

// Shimming starts here.
(function() {
  // Utils.
  var logging = require('./utils').log;
  var browserDetails = require('./utils').browserDetails;
  // Export to the adapter global object visible in the browser.
  module.exports.browserDetails = browserDetails;
  module.exports.extractVersion = require('./utils').extractVersion;
  module.exports.disableLog = require('./utils').disableLog;

  // Uncomment the line below if you want logging to occur, including logging
  // for the switch statement below. Can also be turned on in the browser via
  // adapter.disableLog(false), but then logging from the switch statement below
  // will not appear.
  // require('./utils').disableLog(false);

  // Browser shims.
  var chromeShim = require('./chrome/chrome_shim') || null;
  var edgeShim = require('./edge/edge_shim') || null;
  var firefoxShim = require('./firefox/firefox_shim') || null;
  var safariShim = require('./safari/safari_shim') || null;

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'opera': // fallthrough as it uses chrome shims
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection) {
        logging('Chrome shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = chromeShim;

      chromeShim.shimGetUserMedia();
      chromeShim.shimMediaStream();
      chromeShim.shimSourceObject();
      chromeShim.shimPeerConnection();
      chromeShim.shimOnTrack();
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection) {
        logging('Firefox shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = firefoxShim;

      firefoxShim.shimGetUserMedia();
      firefoxShim.shimSourceObject();
      firefoxShim.shimPeerConnection();
      firefoxShim.shimOnTrack();
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection) {
        logging('MS edge shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = edgeShim;

      edgeShim.shimGetUserMedia();
      edgeShim.shimPeerConnection();
      break;
    case 'safari':
      if (!safariShim) {
        logging('Safari shim is not included in this adapter release.');
        return;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      module.exports.browserShim = safariShim;

      safariShim.shimGetUserMedia();
      break;
    default:
      logging('Unsupported browser!');
  }
})();

},{"./chrome/chrome_shim":103,"./edge/edge_shim":105,"./firefox/firefox_shim":107,"./safari/safari_shim":109,"./utils":110}],103:[function(require,module,exports){

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var logging = require('../utils.js').log;
var browserDetails = require('../utils.js').browserDetails;

var chromeShim = {
  shimMediaStream: function() {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  },

  shimOnTrack: function() {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          var self = this;
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function(te) {
              var event = new Event('track');
              event.track = te.track;
              event.receiver = {track: te.track};
              event.streams = [e.stream];
              self.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        }
      });
    }
  },

  shimSourceObject: function() {
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this._srcObject;
          },
          set: function(stream) {
            var self = this;
            // Use _srcObject as a private property for this shim
            this._srcObject = stream;
            if (this.src) {
              URL.revokeObjectURL(this.src);
            }

            if (!stream) {
              this.src = '';
              return;
            }
            this.src = URL.createObjectURL(stream);
            // We need to recreate the blob url when a track is added or
            // removed. Doing it manually since we want to avoid a recursion.
            stream.addEventListener('addtrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
            stream.addEventListener('removetrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
          }
        });
      }
    }
  },

  shimPeerConnection: function() {
    // The RTCPeerConnection object.
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      // Translate iceTransportPolicy to iceTransports,
      // see https://code.google.com/p/webrtc/issues/detail?id=4869
      logging('PeerConnection');
      if (pcConfig && pcConfig.iceTransportPolicy) {
        pcConfig.iceTransports = pcConfig.iceTransportPolicy;
      }

      var pc = new webkitRTCPeerConnection(pcConfig, pcConstraints);
      var origGetStats = pc.getStats.bind(pc);
      pc.getStats = function(selector, successCallback, errorCallback) {
        var self = this;
        var args = arguments;

        // If selector is a function then we are in the old style stats so just
        // pass back the original getStats format to avoid breaking old users.
        if (arguments.length > 0 && typeof selector === 'function') {
          return origGetStats(selector, successCallback);
        }

        var fixChromeStats_ = function(response) {
          var standardReport = {};
          var reports = response.result();
          reports.forEach(function(report) {
            var standardStats = {
              id: report.id,
              timestamp: report.timestamp,
              type: report.type
            };
            report.names().forEach(function(name) {
              standardStats[name] = report.stat(name);
            });
            standardReport[standardStats.id] = standardStats;
          });

          return standardReport;
        };

        // shim getStats with maplike support
        var makeMapStats = function(stats, legacyStats) {
          var map = new Map(Object.keys(stats).map(function(key) {
            return[key, stats[key]];
          }));
          legacyStats = legacyStats || stats;
          Object.keys(legacyStats).forEach(function(key) {
            map[key] = legacyStats[key];
          });
          return map;
        };

        if (arguments.length >= 2) {
          var successCallbackWrapper_ = function(response) {
            args[1](makeMapStats(fixChromeStats_(response)));
          };

          return origGetStats.apply(this, [successCallbackWrapper_,
              arguments[0]]);
        }

        // promise-support
        return new Promise(function(resolve, reject) {
          if (args.length === 1 && typeof selector === 'object') {
            origGetStats.apply(self, [
              function(response) {
                resolve(makeMapStats(fixChromeStats_(response)));
              }, reject]);
          } else {
            // Preserve legacy chrome stats only on legacy access of stats obj
            origGetStats.apply(self, [
              function(response) {
                resolve(makeMapStats(fixChromeStats_(response),
                    response.result()));
              }, reject]);
          }
        }).then(successCallback, errorCallback);
      };

      return pc;
    };
    window.RTCPeerConnection.prototype = webkitRTCPeerConnection.prototype;

    // wrap static methods. Currently just generateCertificate.
    if (webkitRTCPeerConnection.generateCertificate) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return webkitRTCPeerConnection.generateCertificate;
        }
      });
    }

    ['createOffer', 'createAnswer'].forEach(function(method) {
      var nativeMethod = webkitRTCPeerConnection.prototype[method];
      webkitRTCPeerConnection.prototype[method] = function() {
        var self = this;
        if (arguments.length < 1 || (arguments.length === 1 &&
            typeof arguments[0] === 'object')) {
          var opts = arguments.length === 1 ? arguments[0] : undefined;
          return new Promise(function(resolve, reject) {
            nativeMethod.apply(self, [resolve, reject, opts]);
          });
        }
        return nativeMethod.apply(this, arguments);
      };
    });

    // add promise support -- natively available in Chrome 51
    if (browserDetails.version < 51) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
          .forEach(function(method) {
            var nativeMethod = webkitRTCPeerConnection.prototype[method];
            webkitRTCPeerConnection.prototype[method] = function() {
              var args = arguments;
              var self = this;
              var promise = new Promise(function(resolve, reject) {
                nativeMethod.apply(self, [args[0], resolve, reject]);
              });
              if (args.length < 2) {
                return promise;
              }
              return promise.then(function() {
                args[1].apply(null, []);
              },
              function(err) {
                if (args.length >= 3) {
                  args[2].apply(null, [err]);
                }
              });
            };
          });
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = webkitRTCPeerConnection.prototype[method];
          webkitRTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                RTCIceCandidate : RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        RTCPeerConnection.prototype.addIceCandidate;
    RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }
};


// Expose public methods.
module.exports = {
  shimMediaStream: chromeShim.shimMediaStream,
  shimOnTrack: chromeShim.shimOnTrack,
  shimSourceObject: chromeShim.shimSourceObject,
  shimPeerConnection: chromeShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils.js":110,"./getusermedia":104}],104:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var logging = require('../utils.js').log;

// Expose public methods.
module.exports = function() {
  var constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function(mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function(constraints, func) {
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && constraints.audio) {
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile, where it defaults to "user".
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode)) {
        delete constraints.video.facingMode;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          // Look for "back" in label, or use last cam (typically back cam).
          return navigator.mediaDevices.enumerateDevices()
          .then(function(devices) {
            devices = devices.filter(function(d) {
              return d.kind === 'videoinput';
            });
            var back = devices.find(function(d) {
              return d.label.toLowerCase().indexOf('back') !== -1;
            }) || (devices.length && devices[devices.length - 1]);
            if (back) {
              constraints.video.deviceId = face.exact ? {exact: back.deviceId} :
                                                        {ideal: back.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function(e) {
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        ConstraintNotSatisfiedError: 'OverconstrainedError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraintName,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function(c) {
      navigator.webkitGetUserMedia(c, onSuccess, function(e) {
        onError(shimError_(e));
      });
    });
  };

  navigator.getUserMedia = getUserMedia_;

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      navigator.getUserMedia(constraints, resolve, reject);
    });
  };

  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {
      getUserMedia: getUserMediaPromise_,
      enumerateDevices: function() {
        return new Promise(function(resolve) {
          var kinds = {audio: 'audioinput', video: 'videoinput'};
          return MediaStreamTrack.getSources(function(devices) {
            resolve(devices.map(function(device) {
              return {label: device.label,
                      kind: kinds[device.kind],
                      deviceId: device.id,
                      groupId: ''};
            }));
          });
        });
      }
    };
  }

  // A shim for getUserMedia method on the mediaDevices object.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (!navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      return getUserMediaPromise_(constraints);
    };
  } else {
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, function(c) {
        return origGetUserMedia(c).then(function(stream) {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function(e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }

  // Dummy devicechange event methods.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
    navigator.mediaDevices.addEventListener = function() {
      logging('Dummy mediaDevices.addEventListener called.');
    };
  }
  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
    navigator.mediaDevices.removeEventListener = function() {
      logging('Dummy mediaDevices.removeEventListener called.');
    };
  }
};

},{"../utils.js":110}],105:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');
var browserDetails = require('../utils').browserDetails;

var edgeShim = {
  shimPeerConnection: function() {
    if (window.RTCIceGatherer) {
      // ORTC defines an RTCIceCandidate object but no constructor.
      // Not implemented in Edge.
      if (!window.RTCIceCandidate) {
        window.RTCIceCandidate = function(args) {
          return args;
        };
      }
      // ORTC does not have a session description object but
      // other browsers (i.e. Chrome) that will support both PC and ORTC
      // in the future might have this defined already.
      if (!window.RTCSessionDescription) {
        window.RTCSessionDescription = function(args) {
          return args;
        };
      }
      // this adds an additional event listener to MediaStrackTrack that signals
      // when a tracks enabled property was changed.
      var origMSTEnabled = Object.getOwnPropertyDescriptor(
          MediaStreamTrack.prototype, 'enabled');
      Object.defineProperty(MediaStreamTrack.prototype, 'enabled', {
        set: function(value) {
          origMSTEnabled.set.call(this, value);
          var ev = new Event('enabled');
          ev.enabled = value;
          this.dispatchEvent(ev);
        }
      });
    }

    window.RTCPeerConnection = function(config) {
      var self = this;

      var _eventTarget = document.createDocumentFragment();
      ['addEventListener', 'removeEventListener', 'dispatchEvent']
          .forEach(function(method) {
            self[method] = _eventTarget[method].bind(_eventTarget);
          });

      this.onicecandidate = null;
      this.onaddstream = null;
      this.ontrack = null;
      this.onremovestream = null;
      this.onsignalingstatechange = null;
      this.oniceconnectionstatechange = null;
      this.onnegotiationneeded = null;
      this.ondatachannel = null;

      this.localStreams = [];
      this.remoteStreams = [];
      this.getLocalStreams = function() {
        return self.localStreams;
      };
      this.getRemoteStreams = function() {
        return self.remoteStreams;
      };

      this.localDescription = new RTCSessionDescription({
        type: '',
        sdp: ''
      });
      this.remoteDescription = new RTCSessionDescription({
        type: '',
        sdp: ''
      });
      this.signalingState = 'stable';
      this.iceConnectionState = 'new';
      this.iceGatheringState = 'new';

      this.iceOptions = {
        gatherPolicy: 'all',
        iceServers: []
      };
      if (config && config.iceTransportPolicy) {
        switch (config.iceTransportPolicy) {
          case 'all':
          case 'relay':
            this.iceOptions.gatherPolicy = config.iceTransportPolicy;
            break;
          case 'none':
            // FIXME: remove once implementation and spec have added this.
            throw new TypeError('iceTransportPolicy "none" not supported');
          default:
            // don't set iceTransportPolicy.
            break;
        }
      }
      this.usingBundle = config && config.bundlePolicy === 'max-bundle';

      if (config && config.iceServers) {
        // Edge does not like
        // 1) stun:
        // 2) turn: that does not have all of turn:host:port?transport=udp
        // 3) turn: with ipv6 addresses
        var iceServers = JSON.parse(JSON.stringify(config.iceServers));
        this.iceOptions.iceServers = iceServers.filter(function(server) {
          if (server && server.urls) {
            var urls = server.urls;
            if (typeof urls === 'string') {
              urls = [urls];
            }
            urls = urls.filter(function(url) {
              return (url.indexOf('turn:') === 0 &&
                  url.indexOf('transport=udp') !== -1 &&
                  url.indexOf('turn:[') === -1) ||
                  (url.indexOf('stun:') === 0 &&
                    browserDetails.version >= 14393);
            })[0];
            return !!urls;
          }
          return false;
        });
      }
      this._config = config;

      // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
      // everything that is needed to describe a SDP m-line.
      this.transceivers = [];

      // since the iceGatherer is currently created in createOffer but we
      // must not emit candidates until after setLocalDescription we buffer
      // them in this array.
      this._localIceCandidatesBuffer = [];
    };

    window.RTCPeerConnection.prototype._emitBufferedCandidates = function() {
      var self = this;
      var sections = SDPUtils.splitSections(self.localDescription.sdp);
      // FIXME: need to apply ice candidates in a way which is async but
      // in-order
      this._localIceCandidatesBuffer.forEach(function(event) {
        var end = !event.candidate || Object.keys(event.candidate).length === 0;
        if (end) {
          for (var j = 1; j < sections.length; j++) {
            if (sections[j].indexOf('\r\na=end-of-candidates\r\n') === -1) {
              sections[j] += 'a=end-of-candidates\r\n';
            }
          }
        } else if (event.candidate.candidate.indexOf('typ endOfCandidates')
            === -1) {
          sections[event.candidate.sdpMLineIndex + 1] +=
              'a=' + event.candidate.candidate + '\r\n';
        }
        self.localDescription.sdp = sections.join('');
        self.dispatchEvent(event);
        if (self.onicecandidate !== null) {
          self.onicecandidate(event);
        }
        if (!event.candidate && self.iceGatheringState !== 'complete') {
          var complete = self.transceivers.every(function(transceiver) {
            return transceiver.iceGatherer &&
                transceiver.iceGatherer.state === 'completed';
          });
          if (complete) {
            self.iceGatheringState = 'complete';
          }
        }
      });
      this._localIceCandidatesBuffer = [];
    };

    window.RTCPeerConnection.prototype.getConfiguration = function() {
      return this._config;
    };

    window.RTCPeerConnection.prototype.addStream = function(stream) {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      this.localStreams.push(clonedStream);
      this._maybeFireNegotiationNeeded();
    };

    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var idx = this.localStreams.indexOf(stream);
      if (idx > -1) {
        this.localStreams.splice(idx, 1);
        this._maybeFireNegotiationNeeded();
      }
    };

    window.RTCPeerConnection.prototype.getSenders = function() {
      return this.transceivers.filter(function(transceiver) {
        return !!transceiver.rtpSender;
      })
      .map(function(transceiver) {
        return transceiver.rtpSender;
      });
    };

    window.RTCPeerConnection.prototype.getReceivers = function() {
      return this.transceivers.filter(function(transceiver) {
        return !!transceiver.rtpReceiver;
      })
      .map(function(transceiver) {
        return transceiver.rtpReceiver;
      });
    };

    // Determines the intersection of local and remote capabilities.
    window.RTCPeerConnection.prototype._getCommonCapabilities =
        function(localCapabilities, remoteCapabilities) {
          var commonCapabilities = {
            codecs: [],
            headerExtensions: [],
            fecMechanisms: []
          };
          localCapabilities.codecs.forEach(function(lCodec) {
            for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
              var rCodec = remoteCapabilities.codecs[i];
              if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
                  lCodec.clockRate === rCodec.clockRate) {
                // number of channels is the highest common number of channels
                rCodec.numChannels = Math.min(lCodec.numChannels,
                    rCodec.numChannels);
                // push rCodec so we reply with offerer payload type
                commonCapabilities.codecs.push(rCodec);

                // determine common feedback mechanisms
                rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
                  for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
                    if (lCodec.rtcpFeedback[j].type === fb.type &&
                        lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                      return true;
                    }
                  }
                  return false;
                });
                // FIXME: also need to determine .parameters
                //  see https://github.com/openpeer/ortc/issues/569
                break;
              }
            }
          });

          localCapabilities.headerExtensions
              .forEach(function(lHeaderExtension) {
                for (var i = 0; i < remoteCapabilities.headerExtensions.length;
                     i++) {
                  var rHeaderExtension = remoteCapabilities.headerExtensions[i];
                  if (lHeaderExtension.uri === rHeaderExtension.uri) {
                    commonCapabilities.headerExtensions.push(rHeaderExtension);
                    break;
                  }
                }
              });

          // FIXME: fecMechanisms
          return commonCapabilities;
        };

    // Create ICE gatherer, ICE transport and DTLS transport.
    window.RTCPeerConnection.prototype._createIceAndDtlsTransports =
        function(mid, sdpMLineIndex) {
          var self = this;
          var iceGatherer = new RTCIceGatherer(self.iceOptions);
          var iceTransport = new RTCIceTransport(iceGatherer);
          iceGatherer.onlocalcandidate = function(evt) {
            var event = new Event('icecandidate');
            event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

            var cand = evt.candidate;
            var end = !cand || Object.keys(cand).length === 0;
            // Edge emits an empty object for RTCIceCandidateComplete
            if (end) {
              // polyfill since RTCIceGatherer.state is not implemented in
              // Edge 10547 yet.
              if (iceGatherer.state === undefined) {
                iceGatherer.state = 'completed';
              }

              // Emit a candidate with type endOfCandidates to make the samples
              // work. Edge requires addIceCandidate with this empty candidate
              // to start checking. The real solution is to signal
              // end-of-candidates to the other side when getting the null
              // candidate but some apps (like the samples) don't do that.
              event.candidate.candidate =
                  'candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates';
            } else {
              // RTCIceCandidate doesn't have a component, needs to be added
              cand.component = iceTransport.component === 'RTCP' ? 2 : 1;
              event.candidate.candidate = SDPUtils.writeCandidate(cand);
            }

            // update local description.
            var sections = SDPUtils.splitSections(self.localDescription.sdp);
            if (event.candidate.candidate.indexOf('typ endOfCandidates')
                === -1) {
              sections[event.candidate.sdpMLineIndex + 1] +=
                  'a=' + event.candidate.candidate + '\r\n';
            } else {
              sections[event.candidate.sdpMLineIndex + 1] +=
                  'a=end-of-candidates\r\n';
            }
            self.localDescription.sdp = sections.join('');

            var complete = self.transceivers.every(function(transceiver) {
              return transceiver.iceGatherer &&
                  transceiver.iceGatherer.state === 'completed';
            });

            // Emit candidate if localDescription is set.
            // Also emits null candidate when all gatherers are complete.
            switch (self.iceGatheringState) {
              case 'new':
                self._localIceCandidatesBuffer.push(event);
                if (end && complete) {
                  self._localIceCandidatesBuffer.push(
                      new Event('icecandidate'));
                }
                break;
              case 'gathering':
                self._emitBufferedCandidates();
                self.dispatchEvent(event);
                if (self.onicecandidate !== null) {
                  self.onicecandidate(event);
                }
                if (complete) {
                  self.dispatchEvent(new Event('icecandidate'));
                  if (self.onicecandidate !== null) {
                    self.onicecandidate(new Event('icecandidate'));
                  }
                  self.iceGatheringState = 'complete';
                }
                break;
              case 'complete':
                // should not happen... currently!
                break;
              default: // no-op.
                break;
            }
          };
          iceTransport.onicestatechange = function() {
            self._updateConnectionState();
          };

          var dtlsTransport = new RTCDtlsTransport(iceTransport);
          dtlsTransport.ondtlsstatechange = function() {
            self._updateConnectionState();
          };
          dtlsTransport.onerror = function() {
            // onerror does not set state to failed by itself.
            dtlsTransport.state = 'failed';
            self._updateConnectionState();
          };

          return {
            iceGatherer: iceGatherer,
            iceTransport: iceTransport,
            dtlsTransport: dtlsTransport
          };
        };

    // Start the RTP Sender and Receiver for a transceiver.
    window.RTCPeerConnection.prototype._transceive = function(transceiver,
        send, recv) {
      var params = this._getCommonCapabilities(transceiver.localCapabilities,
          transceiver.remoteCapabilities);
      if (send && transceiver.rtpSender) {
        params.encodings = transceiver.sendEncodingParameters;
        params.rtcp = {
          cname: SDPUtils.localCName
        };
        if (transceiver.recvEncodingParameters.length) {
          params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
        }
        transceiver.rtpSender.send(params);
      }
      if (recv && transceiver.rtpReceiver) {
        // remove RTX field in Edge 14942
        if (transceiver.kind === 'video'
            && transceiver.recvEncodingParameters) {
          transceiver.recvEncodingParameters.forEach(function(p) {
            delete p.rtx;
          });
        }
        params.encodings = transceiver.recvEncodingParameters;
        params.rtcp = {
          cname: transceiver.cname
        };
        if (transceiver.sendEncodingParameters.length) {
          params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
        }
        transceiver.rtpReceiver.receive(params);
      }
    };

    window.RTCPeerConnection.prototype.setLocalDescription =
        function(description) {
          var self = this;
          var sections;
          var sessionpart;
          if (description.type === 'offer') {
            // FIXME: What was the purpose of this empty if statement?
            // if (!this._pendingOffer) {
            // } else {
            if (this._pendingOffer) {
              // VERY limited support for SDP munging. Limited to:
              // * changing the order of codecs
              sections = SDPUtils.splitSections(description.sdp);
              sessionpart = sections.shift();
              sections.forEach(function(mediaSection, sdpMLineIndex) {
                var caps = SDPUtils.parseRtpParameters(mediaSection);
                self._pendingOffer[sdpMLineIndex].localCapabilities = caps;
              });
              this.transceivers = this._pendingOffer;
              delete this._pendingOffer;
            }
          } else if (description.type === 'answer') {
            sections = SDPUtils.splitSections(self.remoteDescription.sdp);
            sessionpart = sections.shift();
            var isIceLite = SDPUtils.matchPrefix(sessionpart,
                'a=ice-lite').length > 0;
            sections.forEach(function(mediaSection, sdpMLineIndex) {
              var transceiver = self.transceivers[sdpMLineIndex];
              var iceGatherer = transceiver.iceGatherer;
              var iceTransport = transceiver.iceTransport;
              var dtlsTransport = transceiver.dtlsTransport;
              var localCapabilities = transceiver.localCapabilities;
              var remoteCapabilities = transceiver.remoteCapabilities;

              var rejected = mediaSection.split('\n', 1)[0]
                  .split(' ', 2)[1] === '0';

              if (!rejected && !transceiver.isDatachannel) {
                var remoteIceParameters = SDPUtils.getIceParameters(
                    mediaSection, sessionpart);
                if (isIceLite) {
                  var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
                  .map(function(cand) {
                    return SDPUtils.parseCandidate(cand);
                  })
                  .filter(function(cand) {
                    return cand.component === '1';
                  });
                  // ice-lite only includes host candidates in the SDP so we can
                  // use setRemoteCandidates (which implies an
                  // RTCIceCandidateComplete)
                  if (cands.length) {
                    iceTransport.setRemoteCandidates(cands);
                  }
                }
                var remoteDtlsParameters = SDPUtils.getDtlsParameters(
                    mediaSection, sessionpart);
                if (isIceLite) {
                  remoteDtlsParameters.role = 'server';
                }

                if (!self.usingBundle || sdpMLineIndex === 0) {
                  iceTransport.start(iceGatherer, remoteIceParameters,
                      isIceLite ? 'controlling' : 'controlled');
                  dtlsTransport.start(remoteDtlsParameters);
                }

                // Calculate intersection of capabilities.
                var params = self._getCommonCapabilities(localCapabilities,
                    remoteCapabilities);

                // Start the RTCRtpSender. The RTCRtpReceiver for this
                // transceiver has already been started in setRemoteDescription.
                self._transceive(transceiver,
                    params.codecs.length > 0,
                    false);
              }
            });
          }

          this.localDescription = {
            type: description.type,
            sdp: description.sdp
          };
          switch (description.type) {
            case 'offer':
              this._updateSignalingState('have-local-offer');
              break;
            case 'answer':
              this._updateSignalingState('stable');
              break;
            default:
              throw new TypeError('unsupported type "' + description.type +
                  '"');
          }

          // If a success callback was provided, emit ICE candidates after it
          // has been executed. Otherwise, emit callback after the Promise is
          // resolved.
          var hasCallback = arguments.length > 1 &&
            typeof arguments[1] === 'function';
          if (hasCallback) {
            var cb = arguments[1];
            window.setTimeout(function() {
              cb();
              if (self.iceGatheringState === 'new') {
                self.iceGatheringState = 'gathering';
              }
              self._emitBufferedCandidates();
            }, 0);
          }
          var p = Promise.resolve();
          p.then(function() {
            if (!hasCallback) {
              if (self.iceGatheringState === 'new') {
                self.iceGatheringState = 'gathering';
              }
              // Usually candidates will be emitted earlier.
              window.setTimeout(self._emitBufferedCandidates.bind(self), 500);
            }
          });
          return p;
        };

    window.RTCPeerConnection.prototype.setRemoteDescription =
        function(description) {
          var self = this;
          var stream = new MediaStream();
          var receiverList = [];
          var sections = SDPUtils.splitSections(description.sdp);
          var sessionpart = sections.shift();
          var isIceLite = SDPUtils.matchPrefix(sessionpart,
              'a=ice-lite').length > 0;
          this.usingBundle = SDPUtils.matchPrefix(sessionpart,
              'a=group:BUNDLE ').length > 0;
          sections.forEach(function(mediaSection, sdpMLineIndex) {
            var lines = SDPUtils.splitLines(mediaSection);
            var mline = lines[0].substr(2).split(' ');
            var kind = mline[0];
            var rejected = mline[1] === '0';
            var direction = SDPUtils.getDirection(mediaSection, sessionpart);

            var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:');
            if (mid.length) {
              mid = mid[0].substr(6);
            } else {
              mid = SDPUtils.generateIdentifier();
            }

            // Reject datachannels which are not implemented yet.
            if (kind === 'application' && mline[2] === 'DTLS/SCTP') {
              self.transceivers[sdpMLineIndex] = {
                mid: mid,
                isDatachannel: true
              };
              return;
            }

            var transceiver;
            var iceGatherer;
            var iceTransport;
            var dtlsTransport;
            var rtpSender;
            var rtpReceiver;
            var sendEncodingParameters;
            var recvEncodingParameters;
            var localCapabilities;

            var track;
            // FIXME: ensure the mediaSection has rtcp-mux set.
            var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
            var remoteIceParameters;
            var remoteDtlsParameters;
            if (!rejected) {
              remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
                  sessionpart);
              remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
                  sessionpart);
              remoteDtlsParameters.role = 'client';
            }
            recvEncodingParameters =
                SDPUtils.parseRtpEncodingParameters(mediaSection);

            var cname;
            // Gets the first SSRC. Note that with RTX there might be multiple
            // SSRCs.
            var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
                .map(function(line) {
                  return SDPUtils.parseSsrcMedia(line);
                })
                .filter(function(obj) {
                  return obj.attribute === 'cname';
                })[0];
            if (remoteSsrc) {
              cname = remoteSsrc.value;
            }

            var isComplete = SDPUtils.matchPrefix(mediaSection,
                'a=end-of-candidates', sessionpart).length > 0;
            var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
                .map(function(cand) {
                  return SDPUtils.parseCandidate(cand);
                })
                .filter(function(cand) {
                  return cand.component === '1';
                });
            if (description.type === 'offer' && !rejected) {
              var transports = self.usingBundle && sdpMLineIndex > 0 ? {
                iceGatherer: self.transceivers[0].iceGatherer,
                iceTransport: self.transceivers[0].iceTransport,
                dtlsTransport: self.transceivers[0].dtlsTransport
              } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);

              if (isComplete) {
                transports.iceTransport.setRemoteCandidates(cands);
              }

              localCapabilities = RTCRtpReceiver.getCapabilities(kind);

              // filter RTX until additional stuff needed for RTX is implemented
              // in adapter.js
              localCapabilities.codecs = localCapabilities.codecs.filter(
                  function(codec) {
                    return codec.name !== 'rtx';
                  });

              sendEncodingParameters = [{
                ssrc: (2 * sdpMLineIndex + 2) * 1001
              }];

              rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);

              track = rtpReceiver.track;
              receiverList.push([track, rtpReceiver]);
              // FIXME: not correct when there are multiple streams but that is
              // not currently supported in this shim.
              stream.addTrack(track);

              // FIXME: look at direction.
              if (self.localStreams.length > 0 &&
                  self.localStreams[0].getTracks().length >= sdpMLineIndex) {
                var localTrack;
                if (kind === 'audio') {
                  localTrack = self.localStreams[0].getAudioTracks()[0];
                } else if (kind === 'video') {
                  localTrack = self.localStreams[0].getVideoTracks()[0];
                }
                if (localTrack) {
                  rtpSender = new RTCRtpSender(localTrack,
                      transports.dtlsTransport);
                }
              }

              self.transceivers[sdpMLineIndex] = {
                iceGatherer: transports.iceGatherer,
                iceTransport: transports.iceTransport,
                dtlsTransport: transports.dtlsTransport,
                localCapabilities: localCapabilities,
                remoteCapabilities: remoteCapabilities,
                rtpSender: rtpSender,
                rtpReceiver: rtpReceiver,
                kind: kind,
                mid: mid,
                cname: cname,
                sendEncodingParameters: sendEncodingParameters,
                recvEncodingParameters: recvEncodingParameters
              };
              // Start the RTCRtpReceiver now. The RTPSender is started in
              // setLocalDescription.
              self._transceive(self.transceivers[sdpMLineIndex],
                  false,
                  direction === 'sendrecv' || direction === 'sendonly');
            } else if (description.type === 'answer' && !rejected) {
              transceiver = self.transceivers[sdpMLineIndex];
              iceGatherer = transceiver.iceGatherer;
              iceTransport = transceiver.iceTransport;
              dtlsTransport = transceiver.dtlsTransport;
              rtpSender = transceiver.rtpSender;
              rtpReceiver = transceiver.rtpReceiver;
              sendEncodingParameters = transceiver.sendEncodingParameters;
              localCapabilities = transceiver.localCapabilities;

              self.transceivers[sdpMLineIndex].recvEncodingParameters =
                  recvEncodingParameters;
              self.transceivers[sdpMLineIndex].remoteCapabilities =
                  remoteCapabilities;
              self.transceivers[sdpMLineIndex].cname = cname;

              if ((isIceLite || isComplete) && cands.length) {
                iceTransport.setRemoteCandidates(cands);
              }
              if (!self.usingBundle || sdpMLineIndex === 0) {
                iceTransport.start(iceGatherer, remoteIceParameters,
                    'controlling');
                dtlsTransport.start(remoteDtlsParameters);
              }

              self._transceive(transceiver,
                  direction === 'sendrecv' || direction === 'recvonly',
                  direction === 'sendrecv' || direction === 'sendonly');

              if (rtpReceiver &&
                  (direction === 'sendrecv' || direction === 'sendonly')) {
                track = rtpReceiver.track;
                receiverList.push([track, rtpReceiver]);
                stream.addTrack(track);
              } else {
                // FIXME: actually the receiver should be created later.
                delete transceiver.rtpReceiver;
              }
            }
          });

          this.remoteDescription = {
            type: description.type,
            sdp: description.sdp
          };
          switch (description.type) {
            case 'offer':
              this._updateSignalingState('have-remote-offer');
              break;
            case 'answer':
              this._updateSignalingState('stable');
              break;
            default:
              throw new TypeError('unsupported type "' + description.type +
                  '"');
          }
          if (stream.getTracks().length) {
            self.remoteStreams.push(stream);
            window.setTimeout(function() {
              var event = new Event('addstream');
              event.stream = stream;
              self.dispatchEvent(event);
              if (self.onaddstream !== null) {
                window.setTimeout(function() {
                  self.onaddstream(event);
                }, 0);
              }

              receiverList.forEach(function(item) {
                var track = item[0];
                var receiver = item[1];
                var trackEvent = new Event('track');
                trackEvent.track = track;
                trackEvent.receiver = receiver;
                trackEvent.streams = [stream];
                self.dispatchEvent(event);
                if (self.ontrack !== null) {
                  window.setTimeout(function() {
                    self.ontrack(trackEvent);
                  }, 0);
                }
              });
            }, 0);
          }
          if (arguments.length > 1 && typeof arguments[1] === 'function') {
            window.setTimeout(arguments[1], 0);
          }
          return Promise.resolve();
        };

    window.RTCPeerConnection.prototype.close = function() {
      this.transceivers.forEach(function(transceiver) {
        /* not yet
        if (transceiver.iceGatherer) {
          transceiver.iceGatherer.close();
        }
        */
        if (transceiver.iceTransport) {
          transceiver.iceTransport.stop();
        }
        if (transceiver.dtlsTransport) {
          transceiver.dtlsTransport.stop();
        }
        if (transceiver.rtpSender) {
          transceiver.rtpSender.stop();
        }
        if (transceiver.rtpReceiver) {
          transceiver.rtpReceiver.stop();
        }
      });
      // FIXME: clean up tracks, local streams, remote streams, etc
      this._updateSignalingState('closed');
    };

    // Update the signaling state.
    window.RTCPeerConnection.prototype._updateSignalingState =
        function(newState) {
          this.signalingState = newState;
          var event = new Event('signalingstatechange');
          this.dispatchEvent(event);
          if (this.onsignalingstatechange !== null) {
            this.onsignalingstatechange(event);
          }
        };

    // Determine whether to fire the negotiationneeded event.
    window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded =
        function() {
          // Fire away (for now).
          var event = new Event('negotiationneeded');
          this.dispatchEvent(event);
          if (this.onnegotiationneeded !== null) {
            this.onnegotiationneeded(event);
          }
        };

    // Update the connection state.
    window.RTCPeerConnection.prototype._updateConnectionState = function() {
      var self = this;
      var newState;
      var states = {
        'new': 0,
        closed: 0,
        connecting: 0,
        checking: 0,
        connected: 0,
        completed: 0,
        failed: 0
      };
      this.transceivers.forEach(function(transceiver) {
        states[transceiver.iceTransport.state]++;
        states[transceiver.dtlsTransport.state]++;
      });
      // ICETransport.completed and connected are the same for this purpose.
      states.connected += states.completed;

      newState = 'new';
      if (states.failed > 0) {
        newState = 'failed';
      } else if (states.connecting > 0 || states.checking > 0) {
        newState = 'connecting';
      } else if (states.disconnected > 0) {
        newState = 'disconnected';
      } else if (states.new > 0) {
        newState = 'new';
      } else if (states.connected > 0 || states.completed > 0) {
        newState = 'connected';
      }

      if (newState !== self.iceConnectionState) {
        self.iceConnectionState = newState;
        var event = new Event('iceconnectionstatechange');
        this.dispatchEvent(event);
        if (this.oniceconnectionstatechange !== null) {
          this.oniceconnectionstatechange(event);
        }
      }
    };

    window.RTCPeerConnection.prototype.createOffer = function() {
      var self = this;
      if (this._pendingOffer) {
        throw new Error('createOffer called while there is a pending offer.');
      }
      var offerOptions;
      if (arguments.length === 1 && typeof arguments[0] !== 'function') {
        offerOptions = arguments[0];
      } else if (arguments.length === 3) {
        offerOptions = arguments[2];
      }

      var tracks = [];
      var numAudioTracks = 0;
      var numVideoTracks = 0;
      // Default to sendrecv.
      if (this.localStreams.length) {
        numAudioTracks = this.localStreams[0].getAudioTracks().length;
        numVideoTracks = this.localStreams[0].getVideoTracks().length;
      }
      // Determine number of audio and video tracks we need to send/recv.
      if (offerOptions) {
        // Reject Chrome legacy constraints.
        if (offerOptions.mandatory || offerOptions.optional) {
          throw new TypeError(
              'Legacy mandatory/optional constraints not supported.');
        }
        if (offerOptions.offerToReceiveAudio !== undefined) {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
        if (offerOptions.offerToReceiveVideo !== undefined) {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
      if (this.localStreams.length) {
        // Push local streams.
        this.localStreams[0].getTracks().forEach(function(track) {
          tracks.push({
            kind: track.kind,
            track: track,
            wantReceive: track.kind === 'audio' ?
                numAudioTracks > 0 : numVideoTracks > 0
          });
          if (track.kind === 'audio') {
            numAudioTracks--;
          } else if (track.kind === 'video') {
            numVideoTracks--;
          }
        });
      }
      // Create M-lines for recvonly streams.
      while (numAudioTracks > 0 || numVideoTracks > 0) {
        if (numAudioTracks > 0) {
          tracks.push({
            kind: 'audio',
            wantReceive: true
          });
          numAudioTracks--;
        }
        if (numVideoTracks > 0) {
          tracks.push({
            kind: 'video',
            wantReceive: true
          });
          numVideoTracks--;
        }
      }

      var sdp = SDPUtils.writeSessionBoilerplate();
      var transceivers = [];
      tracks.forEach(function(mline, sdpMLineIndex) {
        // For each track, create an ice gatherer, ice transport,
        // dtls transport, potentially rtpsender and rtpreceiver.
        var track = mline.track;
        var kind = mline.kind;
        var mid = SDPUtils.generateIdentifier();

        var transports = self.usingBundle && sdpMLineIndex > 0 ? {
          iceGatherer: transceivers[0].iceGatherer,
          iceTransport: transceivers[0].iceTransport,
          dtlsTransport: transceivers[0].dtlsTransport
        } : self._createIceAndDtlsTransports(mid, sdpMLineIndex);

        var localCapabilities = RTCRtpSender.getCapabilities(kind);
        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
        localCapabilities.codecs.forEach(function(codec) {
          // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
          // by adding level-asymmetry-allowed=1
          if (codec.name === 'H264' &&
              codec.parameters['level-asymmetry-allowed'] === undefined) {
            codec.parameters['level-asymmetry-allowed'] = '1';
          }
        });

        var rtpSender;
        var rtpReceiver;

        // generate an ssrc now, to be used later in rtpSender.send
        var sendEncodingParameters = [{
          ssrc: (2 * sdpMLineIndex + 1) * 1001
        }];
        if (track) {
          rtpSender = new RTCRtpSender(track, transports.dtlsTransport);
        }

        if (mline.wantReceive) {
          rtpReceiver = new RTCRtpReceiver(transports.dtlsTransport, kind);
        }

        transceivers[sdpMLineIndex] = {
          iceGatherer: transports.iceGatherer,
          iceTransport: transports.iceTransport,
          dtlsTransport: transports.dtlsTransport,
          localCapabilities: localCapabilities,
          remoteCapabilities: null,
          rtpSender: rtpSender,
          rtpReceiver: rtpReceiver,
          kind: kind,
          mid: mid,
          sendEncodingParameters: sendEncodingParameters,
          recvEncodingParameters: null
        };
      });
      if (this.usingBundle) {
        sdp += 'a=group:BUNDLE ' + transceivers.map(function(t) {
          return t.mid;
        }).join(' ') + '\r\n';
      }
      tracks.forEach(function(mline, sdpMLineIndex) {
        var transceiver = transceivers[sdpMLineIndex];
        sdp += SDPUtils.writeMediaSection(transceiver,
            transceiver.localCapabilities, 'offer', self.localStreams[0]);
      });

      this._pendingOffer = transceivers;
      var desc = new RTCSessionDescription({
        type: 'offer',
        sdp: sdp
      });
      if (arguments.length && typeof arguments[0] === 'function') {
        window.setTimeout(arguments[0], 0, desc);
      }
      return Promise.resolve(desc);
    };

    window.RTCPeerConnection.prototype.createAnswer = function() {
      var self = this;

      var sdp = SDPUtils.writeSessionBoilerplate();
      if (this.usingBundle) {
        sdp += 'a=group:BUNDLE ' + this.transceivers.map(function(t) {
          return t.mid;
        }).join(' ') + '\r\n';
      }
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.isDatachannel) {
          sdp += 'm=application 0 DTLS/SCTP 5000\r\n' +
              'c=IN IP4 0.0.0.0\r\n' +
              'a=mid:' + transceiver.mid + '\r\n';
          return;
        }
        // Calculate intersection of capabilities.
        var commonCapabilities = self._getCommonCapabilities(
            transceiver.localCapabilities,
            transceiver.remoteCapabilities);

        sdp += SDPUtils.writeMediaSection(transceiver, commonCapabilities,
            'answer', self.localStreams[0]);
      });

      var desc = new RTCSessionDescription({
        type: 'answer',
        sdp: sdp
      });
      if (arguments.length && typeof arguments[0] === 'function') {
        window.setTimeout(arguments[0], 0, desc);
      }
      return Promise.resolve(desc);
    };

    window.RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
      if (!candidate) {
        this.transceivers.forEach(function(transceiver) {
          transceiver.iceTransport.addRemoteCandidate({});
        });
      } else {
        var mLineIndex = candidate.sdpMLineIndex;
        if (candidate.sdpMid) {
          for (var i = 0; i < this.transceivers.length; i++) {
            if (this.transceivers[i].mid === candidate.sdpMid) {
              mLineIndex = i;
              break;
            }
          }
        }
        var transceiver = this.transceivers[mLineIndex];
        if (transceiver) {
          var cand = Object.keys(candidate.candidate).length > 0 ?
              SDPUtils.parseCandidate(candidate.candidate) : {};
          // Ignore Chrome's invalid candidates since Edge does not like them.
          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
            return;
          }
          // Ignore RTCP candidates, we assume RTCP-MUX.
          if (cand.component !== '1') {
            return;
          }
          // A dirty hack to make samples work.
          if (cand.type === 'endOfCandidates') {
            cand = {};
          }
          transceiver.iceTransport.addRemoteCandidate(cand);

          // update the remoteDescription.
          var sections = SDPUtils.splitSections(this.remoteDescription.sdp);
          sections[mLineIndex + 1] += (cand.type ? candidate.candidate.trim()
              : 'a=end-of-candidates') + '\r\n';
          this.remoteDescription.sdp = sections.join('');
        }
      }
      if (arguments.length > 1 && typeof arguments[1] === 'function') {
        window.setTimeout(arguments[1], 0);
      }
      return Promise.resolve();
    };

    window.RTCPeerConnection.prototype.getStats = function() {
      var promises = [];
      this.transceivers.forEach(function(transceiver) {
        ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
            'dtlsTransport'].forEach(function(method) {
              if (transceiver[method]) {
                promises.push(transceiver[method].getStats());
              }
            });
      });
      var cb = arguments.length > 1 && typeof arguments[1] === 'function' &&
          arguments[1];
      return new Promise(function(resolve) {
        // shim getStats with maplike support
        var results = new Map();
        Promise.all(promises).then(function(res) {
          res.forEach(function(result) {
            Object.keys(result).forEach(function(id) {
              results.set(id, result[id]);
              results[id] = result[id];
            });
          });
          if (cb) {
            window.setTimeout(cb, 0, results);
          }
          resolve(results);
        });
      });
    };
  }
};

// Expose public methods.
module.exports = {
  shimPeerConnection: edgeShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils":110,"./getusermedia":106,"sdp":51}],106:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

// Expose public methods.
module.exports = function() {
  var shimError_ = function(e) {
    return {
      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.
      bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function(c) {
    return origGetUserMedia(c).catch(function(e) {
      return Promise.reject(shimError_(e));
    });
  };
};

},{}],107:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var browserDetails = require('../utils').browserDetails;

var firefoxShim = {
  shimOnTrack: function() {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        }
      });
    }
  },

  shimSourceObject: function() {
    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this.mozSrcObject;
          },
          set: function(stream) {
            this.mozSrcObject = stream;
          }
        });
      }
    }
  },

  shimPeerConnection: function() {
    if (typeof window !== 'object' || !(window.RTCPeerConnection ||
        window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (browserDetails.version < 38) {
          // .urls is not supported in FF < 38.
          // create RTCIceServers with a single url.
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (server.hasOwnProperty('urls')) {
                for (var j = 0; j < server.urls.length; j++) {
                  var newServer = {
                    url: server.urls[j]
                  };
                  if (server.urls[j].indexOf('turn') === 0) {
                    newServer.username = server.username;
                    newServer.credential = server.credential;
                  }
                  newIceServers.push(newServer);
                }
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
        }
        return new mozRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype = mozRTCPeerConnection.prototype;

      // wrap static methods. Currently just generateCertificate.
      if (mozRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return mozRTCPeerConnection.generateCertificate;
          }
        });
      }

      window.RTCSessionDescription = mozRTCSessionDescription;
      window.RTCIceCandidate = mozRTCIceCandidate;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = RTCPeerConnection.prototype[method];
          RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                RTCIceCandidate : RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        RTCPeerConnection.prototype.addIceCandidate;
    RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    if (browserDetails.version < 48) {
      // shim getStats with maplike support
      var makeMapStats = function(stats) {
        var map = new Map();
        Object.keys(stats).forEach(function(key) {
          map.set(key, stats[key]);
          map[key] = stats[key];
        });
        return map;
      };

      var nativeGetStats = RTCPeerConnection.prototype.getStats;
      RTCPeerConnection.prototype.getStats = function(selector, onSucc, onErr) {
        return nativeGetStats.apply(this, [selector || null])
          .then(function(stats) {
            return makeMapStats(stats);
          })
          .then(onSucc, onErr);
      };
    }
  }
};

// Expose public methods.
module.exports = {
  shimOnTrack: firefoxShim.shimOnTrack,
  shimSourceObject: firefoxShim.shimSourceObject,
  shimPeerConnection: firefoxShim.shimPeerConnection,
  shimGetUserMedia: require('./getusermedia')
};

},{"../utils":110,"./getusermedia":108}],108:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logging = require('../utils').log;
var browserDetails = require('../utils').browserDetails;

// Expose public methods.
module.exports = function() {
  var shimError_ = function(e) {
    return {
      name: {
        SecurityError: 'NotAllowedError',
        PermissionDeniedError: 'NotAllowedError'
      }[e.name] || e.name,
      message: {
        'The operation is insecure.': 'The request is not allowed by the ' +
        'user agent or the platform in the current context.'
      }[e.message] || e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  // getUserMedia constraints shim.
  var getUserMedia_ = function(constraints, onSuccess, onError) {
    var constraintsToFF37_ = function(c) {
      if (typeof c !== 'object' || c.require) {
        return c;
      }
      var require = [];
      Object.keys(c).forEach(function(key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = c[key] = (typeof c[key] === 'object') ?
            c[key] : {ideal: c[key]};
        if (r.min !== undefined ||
            r.max !== undefined || r.exact !== undefined) {
          require.push(key);
        }
        if (r.exact !== undefined) {
          if (typeof r.exact === 'number') {
            r. min = r.max = r.exact;
          } else {
            c[key] = r.exact;
          }
          delete r.exact;
        }
        if (r.ideal !== undefined) {
          c.advanced = c.advanced || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[key] = {min: r.ideal, max: r.ideal};
          } else {
            oc[key] = r.ideal;
          }
          c.advanced.push(oc);
          delete r.ideal;
          if (!Object.keys(r).length) {
            delete c[key];
          }
        }
      });
      if (require.length) {
        c.require = require;
      }
      return c;
    };
    constraints = JSON.parse(JSON.stringify(constraints));
    if (browserDetails.version < 38) {
      logging('spec: ' + JSON.stringify(constraints));
      if (constraints.audio) {
        constraints.audio = constraintsToFF37_(constraints.audio);
      }
      if (constraints.video) {
        constraints.video = constraintsToFF37_(constraints.video);
      }
      logging('ff37: ' + JSON.stringify(constraints));
    }
    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {
      onError(shimError_(e));
    });
  };

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      getUserMedia_(constraints, resolve, reject);
    });
  };

  // Shim for mediaDevices on older versions.
  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
      addEventListener: function() { },
      removeEventListener: function() { }
    };
  }
  navigator.mediaDevices.enumerateDevices =
      navigator.mediaDevices.enumerateDevices || function() {
        return new Promise(function(resolve) {
          var infos = [
            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
          ];
          resolve(infos);
        });
      };

  if (browserDetails.version < 41) {
    // Work around http://bugzil.la/1169665
    var orgEnumerateDevices =
        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
    navigator.mediaDevices.enumerateDevices = function() {
      return orgEnumerateDevices().then(undefined, function(e) {
        if (e.name === 'NotFoundError') {
          return [];
        }
        throw e;
      });
    };
  }
  if (browserDetails.version < 49) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      return origGetUserMedia(c).then(function(stream) {
        // Work around https://bugzil.la/802326
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(function(track) {
            track.stop();
          });
          throw new DOMException('The object can not be found here.',
                                 'NotFoundError');
        }
        return stream;
      }, function(e) {
        return Promise.reject(shimError_(e));
      });
    };
  }
  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    if (browserDetails.version < 44) {
      return getUserMedia_(constraints, onSuccess, onError);
    }
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    console.warn('navigator.getUserMedia has been replaced by ' +
                 'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
};

},{"../utils":110}],109:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';
var safariShim = {
  // TODO: DrAlex, should be here, double check against LayoutTests
  // shimOnTrack: function() { },

  // TODO: once the back-end for the mac port is done, add.
  // TODO: check for webkitGTK+
  // shimPeerConnection: function() { },

  shimGetUserMedia: function() {
    navigator.getUserMedia = navigator.webkitGetUserMedia;
  }
};

// Expose public methods.
module.exports = {
  shimGetUserMedia: safariShim.shimGetUserMedia
  // TODO
  // shimOnTrack: safariShim.shimOnTrack,
  // shimPeerConnection: safariShim.shimPeerConnection
};

},{}],110:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logDisabled_ = true;

// Utility methods.
var utils = {
  disableLog: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
        'adapter.js logging enabled';
  },

  log: function() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  },

  /**
   * Extract browser version out of the provided user agent string.
   *
   * @param {!string} uastring userAgent string.
   * @param {!string} expr Regular expression used as match criteria.
   * @param {!number} pos position in the version string to be returned.
   * @return {!number} browser version.
   */
  extractVersion: function(uastring, expr, pos) {
    var match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  },

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  detectBrowser: function() {
    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    // Firefox.
    if (navigator.mozGetUserMedia) {
      result.browser = 'firefox';
      result.version = this.extractVersion(navigator.userAgent,
          /Firefox\/([0-9]+)\./, 1);

    // all webkit-based browsers
    } else if (navigator.webkitGetUserMedia) {
      // Chrome, Chromium, Webview, Opera, all use the chrome shim for now
      if (window.webkitRTCPeerConnection) {
        result.browser = 'chrome';
        result.version = this.extractVersion(navigator.userAgent,
          /Chrom(e|ium)\/([0-9]+)\./, 2);

      // Safari or unknown webkit-based
      // for the time being Safari has support for MediaStreams but not webRTC
      } else {
        // Safari UA substrings of interest for reference:
        // - webkit version:           AppleWebKit/602.1.25 (also used in Op,Cr)
        // - safari UI version:        Version/9.0.3 (unique to Safari)
        // - safari UI webkit version: Safari/601.4.4 (also used in Op,Cr)
        //
        // if the webkit version and safari UI webkit versions are equals,
        // ... this is a stable version.
        //
        // only the internal webkit version is important today to know if
        // media streams are supported
        //
        if (navigator.userAgent.match(/Version\/(\d+).(\d+)/)) {
          result.browser = 'safari';
          result.version = this.extractVersion(navigator.userAgent,
            /AppleWebKit\/([0-9]+)\./, 1);

        // unknown webkit-based browser
        } else {
          result.browser = 'Unsupported webkit-based browser ' +
              'with GUM support but no WebRTC support.';
          return result;
        }
      }

    // Edge.
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
      result.browser = 'edge';
      result.version = this.extractVersion(navigator.userAgent,
          /Edge\/(\d+).(\d+)$/, 2);

    // Default fallthrough: not supported.
    } else {
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  }
};

// Export.
module.exports = {
  log: utils.log,
  disableLog: utils.disableLog,
  browserDetails: utils.detectBrowser(),
  extractVersion: utils.extractVersion
};

},{}],111:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],112:[function(require,module,exports){
var bus = require('page-bus')
var short = require('short-uuid')
var id = short().generate()
var emitters = {}
var names = []
var meta = bus({key: '_meta_'})
var join = bus({key: '_join_'})
var self = bus({key: id})
var swarm = {} // ids
var count = 0

join.emit('data', {id: id})

join.on('data', e => {
  if(e.id == id) return
  let em = swarm[e.id] = bus({key: e.id})
  count++
  if(Math.random() <= 1 / Math.pow(count, 2)) return
  else em.emit('data', {events: names, swamrm: Object.keys(swarm)})
})

self.on('data', e => {
  e.events.forEach(ev => {
    if(!emitters[e.name]) {
      var emitter = emitters[e.name] = bus({key:e.name})
    }
  })
  e.swarm.forEach(s => {
    if(!swarm[s]) swarm[s] = bus({key: s})
  })
 count = swarm.length
})

meta.on('data', e => {
  if(!emitters[e.name]) emitters[e.name] = bus({key:e.name})
})

module.exports = {on, once, emit}

function on(name, fn){
  if(!emitters[name]) {
    names.push(name)
    meta.emit('data', {name: name})
    setTimeout(e => on(name, fn), 0)
  }  
  else {
    emitters[name].on(name, fn)
  }
}

function once(name, fn){
  if(!emitters[name]) {
    meta.emit('data', {name: name})
    setTimeout(e => on(name, fn), 0)
  }  
  else emitters[name].once(name, fn)
}

function emit(name, data){
  if(!emitters[name]) {
    meta.emit('data', {name: name})
    setTimeout(e => emit(name, data, 0))
  }  
  else emitters[name].emit(name, data)
}

},{"page-bus":31,"short-uuid":52}],113:[function(require,module,exports){
(function (process,setImmediate){(function (){
var ms2s = 1.0 / 1000.0;
var ns2ms = 1.0 / 1000000.0
var ns2s = 1e-9

module.exports = T

function T(){
	if(!process.hrtime){ // browser fill

		process.hrtime = function(){

			if(arguments.length){
				arguments[1] = new Date().getTime();
				arguments[0] =  arguments[1] - millies(arguments[0])
			}

			else {
				arguments[0] = new Date().getTime();
			}
			
			return [parseInt(arguments[0] * ms2s), parseInt(((arguments[0] * ms2s) % 1) / ns2s)];
			
		}
	}
  if(!(this instanceof T)) return new T();
  var self = this;
  self.start = self.last = self.beat = process.hrtime();
  self.x = []
  self.end = []
  self.beats =  []
  self.averageSetSize = 333
  self.threshold = 1e6 // 10,000,000 ns ( 10 ms )
  self.skip = false
};

T.prototype.sinceBegin = function(){
  return process.hrtime(this.start)
};

T.prototype.sinceLast = function(){
  this.x = process.hrtime(this.last)
  this.last = process.hrtime()
  return this.x
}

T.prototype.sinceLastNS = function(){
  return nanos(this.sinceLast())
};

T.prototype.sinceBeginNS = function(){
  return nanos(this.sinceBegin())
};

T.prototype.avg = function(){
  var ns = nanos(this.sinceLast())
  this.beats.push(ns);
  this.beats = this.beats.splice(-this.averageSetSize)
  return avg(this.beats);
};

T.prototype.everyS = function(s, fn, go){
	this.every(s * 1e9, fn, go)
}

T.prototype.every = function(ns, fn, go){

  var self = new T();
  var timer = new T();

  var inter = ns || 0
    , fn = fn || function(t,c){c()}
    ;   
      
  function tick(){

    var ns = nanos(self.sinceLast());
//  unnecessary cuz no longer trying to optimize in loop()
//    self.beats.push(ns);
    loop()

  };

  function loop(){
    var d = inter - (nanos(process.hrtime()) - nanos(self.beat));

    if(d < 10000) {
      tock()
    }

    else if(self.skip) {
     setImmediate(loop)
    }

    else if(d < self.threshold) {
      // under the threshold, its nextTicks until the interval is up
      self.skip = true; setImmediate(loop) 
    }

    else {
      if(false && self.beats.length > 9) {
        var r = self.beats.length / self.averageSetSize;
        self.threshold = avg(self.beats) * .45 * r * 2
      }

      // for future reference:
      // console.log(avg(self.beats), self.beats.length, 'threshold = ' + self.threshold)

      self.skip = false; 
      setTimeout(loop, self.threshold / 1e6)
    }
  };

  function tock(){
    self.beat = process.hrtime();
    self.skip = false;
    fn(tick, nanos(timer.sinceLast()))
  };
  
  if(go) tock()

  else loop()

}

function millies(arr){
	return (arr[0] * 1e3) + (arr[1] * ns2ms)
}

function nanos(arr){
  return arr[0] * 1e9 + arr[1]
}

function add(a, b){
  var ns = a[1] + b[1];
  b[0] += a[0];
  b[1] = ns % 1e9;
  if(ns !== b[1]) b[0]++;
  return b
};

function avg(){

  return Array.prototype.slice.call(arguments[0]).reduce(function(a,i){return a += i },0) / arguments[0].length

}

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":136,"timers":157}],114:[function(require,module,exports){
(function (global){(function (){
'use strict';

var possibleNames = [
	'BigInt64Array',
	'BigUint64Array',
	'Float32Array',
	'Float64Array',
	'Int16Array',
	'Int32Array',
	'Int8Array',
	'Uint16Array',
	'Uint32Array',
	'Uint8Array',
	'Uint8ClampedArray'
];

var g = typeof globalThis === 'undefined' ? global : globalThis;

module.exports = function availableTypedArrays() {
	var out = [];
	for (var i = 0; i < possibleNames.length; i++) {
		if (typeof g[possibleNames[i]] === 'function') {
			out[out.length] = possibleNames[i];
		}
	}
	return out;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],115:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],116:[function(require,module,exports){

},{}],117:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":115,"buffer":117,"ieee754":130}],118:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"./":119,"get-intrinsic":125}],119:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"function-bind":124,"get-intrinsic":125}],120:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"get-intrinsic":125}],121:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],122:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],123:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],124:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":123}],125:[function(require,module,exports){
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"function-bind":124,"has":129,"has-symbols":126}],126:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":127}],127:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],128:[function(require,module,exports){
'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

},{"has-symbols/shams":127}],129:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":124}],130:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],131:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],132:[function(require,module,exports){
'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{"call-bind/callBound":118,"has-tostringtag/shams":128}],133:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],134:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = require('has-tostringtag/shams')();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () { // eslint-disable-line consistent-return
	if (!hasToStringTag) {
		return false;
	}
	try {
		return Function('return function*() {}')();
	} catch (e) {
	}
};
var GeneratorFunction;

module.exports = function isGeneratorFunction(fn) {
	if (typeof fn !== 'function') {
		return false;
	}
	if (isFnRegex.test(fnToStr.call(fn))) {
		return true;
	}
	if (!hasToStringTag) {
		var str = toStr.call(fn);
		return str === '[object GeneratorFunction]';
	}
	if (!getProto) {
		return false;
	}
	if (typeof GeneratorFunction === 'undefined') {
		var generatorFunc = getGeneratorFunc();
		GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
	}
	return getProto(fn) === GeneratorFunction;
};

},{"has-tostringtag/shams":128}],135:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		}
	}
	return -1;
};
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr) {
			var proto = getPrototypeOf(arr);
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor) {
				var superProto = getPrototypeOf(proto);
				descriptor = gOPD(superProto, Symbol.toStringTag);
			}
			toStrTags[typedArray] = descriptor.get;
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var anyTrue = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!anyTrue) {
			try {
				anyTrue = getter.call(value) === typedArray;
			} catch (e) { /**/ }
		}
	});
	return anyTrue;
};

module.exports = function isTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) {
		var tag = $slice($toString(value), 8, -1);
		return $indexOf(typedArrays, tag) > -1;
	}
	if (!gOPD) { return false; }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"available-typed-arrays":114,"call-bind/callBound":118,"es-abstract/helpers/getOwnPropertyDescriptor":120,"foreach":122,"has-tostringtag/shams":128}],136:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],137:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],138:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],139:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":137,"./encode":138}],140:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"buffer":117,"dup":50}],141:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":121,"inherits":131,"readable-stream/lib/_stream_duplex.js":143,"readable-stream/lib/_stream_passthrough.js":144,"readable-stream/lib/_stream_readable.js":145,"readable-stream/lib/_stream_transform.js":146,"readable-stream/lib/_stream_writable.js":147,"readable-stream/lib/internal/streams/end-of-stream.js":151,"readable-stream/lib/internal/streams/pipeline.js":153}],142:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"dup":34}],143:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":145,"./_stream_writable":147,"_process":136,"inherits":131}],144:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./_stream_transform":146,"dup":36,"inherits":131}],145:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":142,"./_stream_duplex":143,"./internal/streams/async_iterator":148,"./internal/streams/buffer_list":149,"./internal/streams/destroy":150,"./internal/streams/from":152,"./internal/streams/state":154,"./internal/streams/stream":155,"_process":136,"buffer":117,"events":121,"inherits":131,"string_decoder/":156,"util":116}],146:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"../errors":142,"./_stream_duplex":143,"dup":38,"inherits":131}],147:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":142,"./_stream_duplex":143,"./internal/streams/destroy":150,"./internal/streams/state":154,"./internal/streams/stream":155,"_process":136,"buffer":117,"inherits":131,"util-deprecate":158}],148:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

},{"./end-of-stream":151,"_process":136}],149:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"buffer":117,"dup":41,"util":116}],150:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

},{"_process":136}],151:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"../../../errors":142,"dup":43}],152:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"dup":44}],153:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"../../../errors":142,"./end-of-stream":151,"dup":45}],154:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"../../../errors":142,"dup":46}],155:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"dup":47,"events":121}],156:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76,"safe-buffer":140}],157:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":136,"timers":157}],158:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],159:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],160:[function(require,module,exports){
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

'use strict';

var isArgumentsObject = require('is-arguments');
var isGeneratorFunction = require('is-generator-function');
var whichTypedArray = require('which-typed-array');
var isTypedArray = require('is-typed-array');

function uncurryThis(f) {
  return f.call.bind(f);
}

var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';

var ObjectToString = uncurryThis(Object.prototype.toString);

var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);

if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}

if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
	return (
		(
			typeof Promise !== 'undefined' &&
			input instanceof Promise
		) ||
		(
			input !== null &&
			typeof input === 'object' &&
			typeof input.then === 'function' &&
			typeof input.catch === 'function'
		)
	);
}
exports.isPromise = isPromise;

function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }

  return (
    isTypedArray(value) ||
    isDataView(value)
  );
}
exports.isArrayBufferView = isArrayBufferView;


function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;

function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;

function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;

function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;

function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;

function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;

function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;

function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;

function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;

function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;

function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;

function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = (
  typeof Map !== 'undefined' &&
  isMapToString(new Map())
);

function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }

  return isMapToString.working
    ? isMapToString(value)
    : value instanceof Map;
}
exports.isMap = isMap;

function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = (
  typeof Set !== 'undefined' &&
  isSetToString(new Set())
);
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }

  return isSetToString.working
    ? isSetToString(value)
    : value instanceof Set;
}
exports.isSet = isSet;

function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = (
  typeof WeakMap !== 'undefined' &&
  isWeakMapToString(new WeakMap())
);
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }

  return isWeakMapToString.working
    ? isWeakMapToString(value)
    : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;

function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = (
  typeof WeakSet !== 'undefined' &&
  isWeakSetToString(new WeakSet())
);
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;

function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  isArrayBufferToString(new ArrayBuffer())
);
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }

  return isArrayBufferToString.working
    ? isArrayBufferToString(value)
    : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;

function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = (
  typeof ArrayBuffer !== 'undefined' &&
  typeof DataView !== 'undefined' &&
  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
);
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }

  return isDataViewToString.working
    ? isDataViewToString(value)
    : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }

  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }

  return isSharedArrayBufferToString.working
    ? isSharedArrayBufferToString(value)
    : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;

function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;

function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;

function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;

function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;

function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;

function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;

function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;

function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;

function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;

function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}
exports.isBoxedPrimitive = isBoxedPrimitive;

function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (
    isArrayBuffer(value) ||
    isSharedArrayBuffer(value)
  );
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;

['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function() {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

},{"is-arguments":132,"is-generator-function":134,"is-typed-array":135,"which-typed-array":162}],161:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  var debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = require('./support/types');

function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

}).call(this)}).call(this,require('_process'))

},{"./support/isBuffer":159,"./support/types":160,"_process":136,"inherits":131}],162:[function(require,module,exports){
(function (global){(function (){
'use strict';

var forEach = require('foreach');
var availableTypedArrays = require('available-typed-arrays');
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
if (hasToStringTag && gOPD && getPrototypeOf) {
	forEach(typedArrays, function (typedArray) {
		if (typeof g[typedArray] === 'function') {
			var arr = new g[typedArray]();
			if (Symbol.toStringTag in arr) {
				var proto = getPrototypeOf(arr);
				var descriptor = gOPD(proto, Symbol.toStringTag);
				if (!descriptor) {
					var superProto = getPrototypeOf(proto);
					descriptor = gOPD(superProto, Symbol.toStringTag);
				}
				toStrTags[typedArray] = descriptor.get;
			}
		}
	});
}

var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundName = false;
	forEach(toStrTags, function (getter, typedArray) {
		if (!foundName) {
			try {
				var name = getter.call(value);
				if (name === typedArray) {
					foundName = name;
				}
			} catch (e) {}
		}
	});
	return foundName;
};

var isTypedArray = require('is-typed-array');

module.exports = function whichTypedArray(value) {
	if (!isTypedArray(value)) { return false; }
	if (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }
	return tryTypedArrays(value);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"available-typed-arrays":114,"call-bind/callBound":118,"es-abstract/helpers/getOwnPropertyDescriptor":120,"foreach":122,"has-tostringtag/shams":128,"is-typed-array":135}]},{},[3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uL2pzeW50aC1maWxlLXNhbXBsZS9pbmRleC5qcyIsIi4uL2pzeW50aC1taWMvc3RyZWFtLmpzIiwiL2hvbWUvam9obm55L3Byb2plY3RzL3AycGNvbnNlbnQvaG9zdC5qcyIsIm5vZGVfbW9kdWxlcy9hbnktYmFzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hbnktYmFzZS9zcmMvY29udmVydGVyLmpzIiwibm9kZV9tb2R1bGVzL2Jsb2ItdG8tYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItc3BsaXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2xhc3MtbGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9kZXRlY3QtYnJvd3Nlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kb21yZWFkeS9yZWFkeS5qcyIsIm5vZGVfbW9kdWxlcy9lcnItY29kZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudC10YXJnZXQtc2hpbS9kaXN0L2V2ZW50LXRhcmdldC1zaGltLmpzIiwibm9kZV9tb2R1bGVzL2dldC1icm93c2VyLXJ0Yy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZXRpZHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2V0dXNlcm1lZGlhL2dldHVzZXJtZWRpYS5qcyIsIm5vZGVfbW9kdWxlcy9oeXBlcnNjcmlwdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmRleG9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbWluaW1pc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9ieC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vYngvZGlzdC9tb2J4LmNqcy5kZXZlbG9wbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9tb2J4L2Rpc3QvbW9ieC5janMucHJvZHVjdGlvbi5taW4uanMiLCJub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbmFub2Fzc2VydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vaHJlZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vZ2ctb3B1cy1kZWNvZGVyL2Rpc3Qvb2dnLW9wdXMtZGVjb2Rlci5taW4uanMiLCJub2RlX21vZHVsZXMvb3B1cy1tZWRpYS1yZWNvcmRlci9PcHVzTWVkaWFSZWNvcmRlci5qcyIsIm5vZGVfbW9kdWxlcy9wYWdlLWJ1cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9xdWV1ZS1taWNyb3Rhc2svaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFuZG9tYnl0ZXMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZXJyb3JzLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9ydW4td2F0ZXJmYWxsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NkcC9zZHAuanMiLCJub2RlX21vZHVsZXMvc2hvcnQtdXVpZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaWduYWxodWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9ldmVudC1zb3VyY2Utc3RyZWFtL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9uZXRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL2Zvci1lYWNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpZ25hbGh1Yi9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy9mb3ItZWFjaC9ub2RlX21vZHVsZXMvaXMtZnVuY3Rpb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL3RyaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2lnbmFsaHViL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGUtcGVlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9kaXN0L3N0b3JlLmxlZ2FjeS5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9wbHVnaW5zL2pzb24yLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3BsdWdpbnMvbGliL2pzb24yLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3NyYy9zdG9yZS1lbmdpbmUuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvYWxsLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL2Nvb2tpZVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvbG9jYWxTdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL3N0b3JlL3N0b3JhZ2VzL21lbW9yeVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvb2xkRkYtZ2xvYmFsU3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9zdG9yZS9zdG9yYWdlcy9vbGRJRS11c2VyRGF0YVN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RvcmUvc3RvcmFnZXMvc2Vzc2lvblN0b3JhZ2UuanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvdGhyb3VnaDIvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJvdWdoMi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gyL3Rocm91Z2gyLmpzIiwibm9kZV9tb2R1bGVzL3RvLWFycmF5YnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9tZDUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvbmlsLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvcmVnZXguanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3JuZy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9zaGExLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjEuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3YzLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92MzUuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3Y0LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92NS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdmFsaWRhdGUuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2FkYXB0ZXJfY29yZS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvY2hyb21lL2Nocm9tZV9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9jaHJvbWUvZ2V0dXNlcm1lZGlhLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9lZGdlL2VkZ2Vfc2hpbS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZWRnZS9nZXR1c2VybWVkaWEuanMiLCJub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2ZpcmVmb3gvZmlyZWZveF9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9maXJlZm94L2dldHVzZXJtZWRpYS5qcyIsIm5vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvc2FmYXJpL3NhZmFyaV9zaGltLmpzIiwibm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJzaGFyZWRFbWl0dGVyLmpzIiwiLi4vc2luY2Utd2hlbi9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2F2YWlsYWJsZS10eXBlZC1hcnJheXMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9oYXMtdG9zdHJpbmd0YWcvc2hhbXMuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWFyZ3VtZW50cy9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWdlbmVyYXRvci1mdW5jdGlvbi9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLXR5cGVkLWFycmF5L2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIi4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCIuLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxNQUFNO0VBQ3hCLE1BQU0sa0JBQWtCLE1BQU0sYUFBYSxJQUFJLE1BQU0sbUJBQW1CO0VBQ3hFLElBQUksTUFBTTtFQUNWLElBQUksSUFBSSxPQUFPLENBQUMsYUFBYSxDQUFDO0VBQzlCLElBQUksS0FBSyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7RUFDNUIsSUFBSSxNQUFNLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztFQUNwQyxHQUFHLEtBQUssQ0FBQyxjQUFjLEVBQUUsS0FBSztJQUM1QixPQUFPLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDZCxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUs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LElBQUksRUFBRSxNQUFNLEtBQUssQ0FBQztJQUM1QyxJQUFJLE1BQU0sT0FBTyxDQUFDLGNBQWMsQ0FBQzs7SUFFakMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLHFCQUFxQjs7OztNQUl2QyxFQUFFLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQztLQUNoQixDQUFDO0lBQ0Y7Q0FDSCxDQUFDOzs7Ozs7QUMzcEJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDclFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDenNMQTtBQUNBO0FBQ0E7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0NBO0FBQ0E7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25tQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdDlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xZQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25tQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM3NCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLy8gaGFuZGxlcyBhdWRpbyBmaWxlcyBhbmQgcmF3LCBtb25vLCBhdWRpbyBidWZmZXJzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29udGV4dCwgYnVmZiwgY2Ipe1xuICBcbiAgdmFyIG5hbWUgPSBidWZmLmNvbnN0cnVjdG9yLm5hbWVcbiAgLy9pZihNYXRoLnJhbmRvbSgpIDwgLjA1KSBjb25zb2xlLmxvZyhidWZmKVxuICBpZihuYW1lID09ICdBcnJheUJ1ZmZlcicpe1xuICAgIGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKGJ1ZmYpLnRoZW4oZnVuY3Rpb24oZGF0YSl7XG4gICAgICB2YXIgc291cmNlID0gY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKVxuICAgICAgc291cmNlLmJ1ZmZlciA9IGRhdGFcbi8qICAgICAgdmFyIGdhaW4gPSBjb250ZXh0LmNyZWF0ZUdhaW4oKVxuICAgICAgZ2Fpbi5jaGFubmVsQ291bnQgPSAxXG4gICAgICBnYWluLmNoYW5uZWxDb3VudE1vZGUgPSAnZXhwbGljaXQnXG4gICAgICBnYWluLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9ICdzcGVha2VycydcbiAgICAgIHNvdXJjZS5jb25uZWN0KGdhaW4pXG4gICAgICBzb3VyY2UuX2Nvbm5lY3QgPSBzb3VyY2UuY29ubmVjdFxuICAgICAgc291cmNlLmNvbm5lY3QgPSBnYWluLmNvbm5lY3RcbiAqLyAgICAgY2IobnVsbCwgc291cmNlKSBcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpe2NiKGVyciwgbnVsbCl9KVxuXHRcbiAgfWVsc2UgaWYobmFtZSA9PSAnQXJyYXknKXtcbiAgXG4gICAgdmFyIHNvdXJjZSA9IGNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICBcbiAgICB2YXIgYnVmZmVyID0gY29udGV4dC5jcmVhdGVCdWZmZXIoMiwgYnVmZlswXS5sZW5ndGgsIGNvbnRleHQuc2FtcGxlUmF0ZSlcblxuICAgIHRyeXsgLy8gbmV3XG4gICAgICBidWZmZXIuY29weVRvQ2hhbm5lbChidWZmWzBdLCAwLCAwKVxuICAgICAgYnVmZmVyLmNvcHlUb0NoYW5uZWwoYnVmZlsxXSwgMSwgMClcblxuICAgIH1jYXRjaChlcnIpeyAvLyBvbGRcbiAgICAgIC8vYnVmZmVyLmdldENoYW5uZWxEYXRhKDApLnNldChidWZmKVxuICAgIH1cbiAgICBcbiAgICBzb3VyY2UuYnVmZmVyID0gYnVmZmVyO1xuICAgIFxuICAgIC8qXG4gICAgdmFyIGdhaW4gPSBjb250ZXh0LmNyZWF0ZUdhaW4oKVxuICAgIGdhaW4uY2hhbm5lbENvdW50ID0gMlxuICAgIGdhaW4uY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCdcbiAgICBnYWluLmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9ICdzcGVha2VycydcbiAgICBzb3VyY2UuZ2FpbiA9IGdhaW5cbiAgICBzb3VyY2UuY29ubmVjdChnYWluKVxuICAgIHNvdXJjZS5fY29ubmVjdCA9IHNvdXJjZS5jb25uZWN0XG4gICAgc291cmNlLmNvbm5lY3QgPSBnYWluLmNvbm5lY3RcbiAgICBpZihjYikgY2IobnVsbCwgc291cmNlKVxuICAgICovXG4gICAgcmV0dXJuIHNvdXJjZVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1hc3Rlciwgc3RyZWFtKXtcbiAgICB2YXIgbm9kZSA9IG1hc3Rlci5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pXG4gICAgdmFyIGdhaW4gPSBtYXN0ZXIuY3JlYXRlR2FpbigpXG4gICAgZ2Fpbi5jaGFubmVsQ291bnQgPSAxXG4gICAgZ2Fpbi5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0J1xuICAgIGdhaW4uIGNoYW5uZWxJbnRlcnByZXRhdGlvbiA9ICdzcGVha2VycydcbiAgICBub2RlLmNvbm5lY3QoZ2FpbilcbiAgICByZXR1cm4gZ2FpblxufVxuIiwiXG5yZXF1aXJlKCdkb21yZWFkeScpKHJlID0+IHtcbiAgY29uc3QgV2ViQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0XG4gIHZhciBtYXN0ZXIgXG4gIHZhciBoID0gcmVxdWlyZSgnaHlwZXJzY3JpcHQnKVxuICB2YXIgdWkgPSByZXF1aXJlKCdnZXRpZHMnKSgpXG4gIHZhciBidXMgPSByZXF1aXJlKCcuL3NoYXJlZEVtaXR0ZXInKVxuICBidXMub25jZSgnaWZyYW1lTG9hZGVkJywgZSA9PiB7XG4gICAgY29uc29sZS5sb2coZSlcbiAgICBidXMuZW1pdCgncG9uZycsIHtnb2F0OiAxfSlcbiAgICBidXMub24oJ2Nsb2NrJywgZSA9PiBjb25zb2xlLmxvZyhlKSlcbiAgfSlcbiAgLy92YXIgaWZyYW1lID0gcmVxdWlyZSgnLi4vaWZyYW1hcmZpJylcbiAgLy92YXIgcGVlcmluZyA9IGlmcmFtZShyZXF1aXJlKCcuL3BlZXJpbmcuanMnKSlcbiAgLy91aS5wZWVyaW5nLmFwcGVuZENoaWxkKHBlZXJpbmcpXG4gIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbiAgdmFyIFBlZXIgPSByZXF1aXJlKCdzaW1wbGUtcGVlcicpXG4gIHZhciBzaWduYWxodWIgPSByZXF1aXJlKCdzaWduYWxodWInKVxuICBjb25zdCB7bWFrZUF1dG9PYnNlcnZhYmxlLCAgYXV0b3J1bn0gPSByZXF1aXJlKCdtb2J4JylcbiAgY29uc3Qgc2hvcnQgPSByZXF1aXJlKCdzaG9ydC11dWlkJyk7XG4gIGNvbnN0IHRvYSA9IHJlcXVpcmUoJ3RvLWFycmF5YnVmZmVyJylcbiAgY29uc3QgYnRvYiA9IHJlcXVpcmUoJ2Jsb2ItdG8tYnVmZmVyJylcbiAgY29uc3QgdGhydSA9IHJlcXVpcmUoJ3Rocm91Z2gyJylcbiAgdmFyIHN0b3JlID0gcmVxdWlyZSgnc3RvcmUnKVxuICBjb25zdCBUaW1lID0gcmVxdWlyZSgnLi4vc2luY2Utd2hlbicpXG4gIHZhciBqbWljID0gcmVxdWlyZSgnLi4vanN5bnRoLW1pYy9zdHJlYW0nKVxuICB2YXIgc2FtcGxlciA9IHJlcXVpcmUoJy4uL2pzeW50aC1maWxlLXNhbXBsZScpXG4gIHZhciBtZWRpYSBcbiAgdmFyIHJ1bnAgPXJlcXVpcmUoJ3J1bi13YXRlcmZhbGwnKVxuICB2YXIgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpXG4gIHZhciBuYW5hID0gcmVxdWlyZSgnbmFub2hyZWYnKVxuICB2YXIgbWluaW1pc3QgPSByZXF1aXJlKCdtaW5pbWlzdCcpXG4gIHZhciBhcmd2ID0gbWluaW1pc3QocHJvY2Vzcy5hcmd2LCB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgaG9zdDogJ2ZvbGtzdGFjay5jb20nLFxuICAgICAgcG9ydDogODAsXG4gICAgICBwcm90b2NvbDogJ2h0dHBzJ1xuICAgIH1cbiAgfSlcbiAgdmFyIGRlYnViID0gc2lnbmFsaHViKCdodHRwczovL2ZvbGtzdGFjay5jb206ODAnLCAnZGVidWcnKVxuICAvL3ZhciByZXQ9ZGVidWIuc3Vic2NyaWJlKCdyZXR1cm4nKVxuXG4gIHZhciBhcHAgXG5cbiAgd2luZG93LnN0b3JlID0gc3RvcmVcbiAgc3RvcmUuY2xlYXJBbGwoKTtcbiAgcnVucChbaW5pdFN0YXRlLCBpbml0VUldLCAoZXJyLCBhcHApPT57XG4gICAgYXBwID0gYXBwXG5cbiAgICB1aS5pbml0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGUgPT4ge1xuICAgICAgYXBwLl9sb2coJ2luaXQnKVxuXG4gICAgICB0cnl7XG4gICAgICAgIHJ1bnAoW2NhcHR1cmVTb3VyY2UsIGNhcHR1cmVTaW5rLCBjYXB0dXJlTmV0d29yaywgaW5pdEF1ZGlvLCBpbml0Q2FzdChhcHApXS5yZXZlcnNlKCksIChlcnIsIGFwcCk9PntcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnIsIGFwcClcbiAgICAgICAgICAvL2FwcC5hdWRpby5zb3VyY2VTdHJlYW0ucGlwZShhcHAuYXVkaW8uc2lua1N0cmVhbSkgLy8gaGVoXG4gICAgICAgICAgaWYoYXBwLnNlc3Npb24uYnJvYWRjYXN0aW5nKSB7XG4gICAgICAgICAgICBhcHAubmV0d29yay5kaXN0YW5jZSA9IDFcbi8vICAgICAgICAgICAgYXBwLm5ldHdvcmsuc291cmNlU3RyZWFtID0gYXBwLmF1ZGlvLnNvdXJjZVN0cmVhbVxuICAgICAgICAgICAgYXBwLm5ldHdvcmsuaXNTZWVrV29ydGh5KClcbiAgICAgICAgICAgIGFwcC5uZXR3b3JrLmFsbG93Q2FsbHMoYXBwLnNlc3Npb24uc3RyZWFtKVxuICAgICAgICAgIFxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGFwcC5uZXR3b3JrLnNvdXJjZVNlZWsoKVxuICAgICAgfSl9IGNhdGNoIChlcnIpe1xuICAgICAgICBhcHAuX2xvZyhlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgfSlcblxuICB2YXIgYWVsID0gdWkucGxheWVyXG4gIHZhciBtaW1lID0gJ2F1ZGlvL29nZztjb2RlY3M9b3B1cydcblxuXG4gIGZ1bmN0aW9uIGluaXRTdGF0ZShjYil7XG5cbiAgICBjbGFzcyBBcHAge1xuICAgIFxuICAgICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5taWMgPSAxLzJcbiAgICAgICAgdGhpcy5tb25pdG9yID0gMFxuICAgICAgICB0aGlzLmNhbGwgPSAxLzJcbiAgICAgICAgdGhpcy50cmFjayA9IDEvMlxuICAgICAgICB0aGlzLnF1YWxpdHkgPSA2NDAwMFxuICAgICAgICB0aGlzLnVwZGF0ZSA9IG51bGxcbiAgICAgICAgbWFrZUF1dG9PYnNlcnZhYmxlKHRoaXMpXG4gICAgICB9XG5cbiAgICAgIHNldEdhaW4oZGlhbCwgdmFsdWUpe1xuICAgICAgICB0aGlzW2RpYWxdID0gdmFsdWVcbiAgICAgICAgdGhpcy51cGRhdGUgPSBbZGlhbCwgdmFsdWVdXG4gICAgICB9XG4gICAgXG4gICAgfVxuXG4gICAgY29uc3QgYXBwID0gbmV3IEFwcFxuICAgIGJ1cy5vbignYXBwU3RhdGVDaGFuZ2UnLCBlID0+e1xuICAgICAgYXBwLnNldEdhaW4oZVswXSwgZVsxXSlcbiAgICB9KVxuICAgIHZhciBzZXNzaW9uID0gc3RvcmUuZ2V0KCdzZXNzaW9uJylcbiAgICBpZighc2Vzc2lvbikgc2Vzc2lvbiA9IHtpZDogc2hvcnQoKS5nZW5lcmF0ZSgpLnNwbGl0KCkucmV2ZXJzZSgpLmpvaW4oKS5zbGljZSgwLDExKX1cbiAgICBzZXNzaW9uLmJyb2FkY2FzdGluZyA9IHRydWVcbiAgICB2YXIgcSA9IHFzLnBhcnNlKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc2xpY2UoMSkpXG4gICAgaWYocS5zdHJlYW0pIHtcbiAgICAgIHNlc3Npb24uc3RyZWFtID0gcS5zdHJlYW1cbiAgICAgIHNlc3Npb24uYnJvYWRjYXN0aW5nID0gZmFsc2UgXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2Vzc2lvbi5zdHJlYW0gPSBzZXNzaW9uLnN0cmVhbSB8fCBzaG9ydCgpLmdlbmVyYXRlKCkuc3BsaXQoKS5yZXZlcnNlKCkuam9pbigpLnNsaWNlKDAsMTEpXG4gICAgfVxuXG4gICAgYXBwLnNlc3Npb24gPSBzZXNzaW9uXG4gIGFwcC5fbG9nID0gZnVuY3Rpb24oX2lkKSB7IHJldHVybiBlID0+IHtcbiAgICAgIC8vdWkuZGVidWcuYXBwZW5kQ2hpbGQoaCgncCcsIGUudG9TdHJpbmcoKSkpICAgIFxuICAgICAgZGVidWIuYnJvYWRjYXN0KCdkZWJ1ZycsIEpTT04uc3RyaW5naWZ5KHtpZDogX2lkLCBsb2c6IGV9KSlcbiAgfSB9KHNlc3Npb24uaWQpXG4gICAgc3RvcmUuc2V0KCdzZXNzaW9uJywgc2Vzc2lvbilcbiAgICBjb25zb2xlLmxvZyhhcHApXG4gICAgY2IobnVsbCwgYXBwKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEF1ZGlvKGFwcCwgY2Ipe1xuICAgIGNvbnN0IGF1ZGlvID0ge31cbiAgICB2YXIgT3B1c01lZGlhUmVjb3JkZXIgPSByZXF1aXJlKCdvcHVzLW1lZGlhLXJlY29yZGVyJykgXG4gICAgd2luZG93Lk1lZGlhUmVjb3JkZXIgPSBPcHVzTWVkaWFSZWNvcmRlcjtcbiAgICBtYXN0ZXIgPSBuZXcgV2ViQXVkaW9Db250ZXh0KHtzYW1wbGVSYXRlOiA0ODAwMH0pXG4gICAgYXVkaW8ubWFzdGVyID0gbWFzdGVyXG4gICAgYXVkaW8uYnJvYWRjYXN0bWl4ZXIgPSBtYXN0ZXIuY3JlYXRlQ2hhbm5lbE1lcmdlcigyKVxuICAgIGF1ZGlvLmNhbGxtaXhlciA9IG1hc3Rlci5jcmVhdGVDaGFubmVsTWVyZ2VyKDIpXG4gICAgYXVkaW8uYnJvYWRjYXN0c3RyZWFtID0gbWFzdGVyLmNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24oKVxuICAgIGF1ZGlvLmNhbGxzdHJlYW0gPSBtYXN0ZXIuY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvbigpXG4gICAgYXVkaW8ubW9uaXRvciA9IG1hc3Rlci5jcmVhdGVHYWluKClcbiAgICBhdWRpby5taWMgPSBtYXN0ZXIuY3JlYXRlR2FpbigpXG4gICAgYXVkaW8uY2FsbCA9IG1hc3Rlci5jcmVhdGVHYWluKClcbiAgICBhdWRpby50cmFja21peGVyID0gbWFzdGVyLmNyZWF0ZUNoYW5uZWxNZXJnZXIoMilcbiAgICBhdWRpby50cmFjayA9IG1hc3Rlci5jcmVhdGVHYWluKClcbiAgICBhdWRpby50cmFja21peGVyLmNvbm5lY3QoYXVkaW8udHJhY2spXG5cbiAgICBhdWRpby5icm9hZGNhc3RtaXhlci5jb25uZWN0KGF1ZGlvLmJyb2FkY2FzdHN0cmVhbSlcbiAgICAvL2F1ZGlvLmJyb2FkY2FzdG1peGVyLmNvbm5lY3QoYXVkaW8ubW9uaXRvcilcblxuICAgIGF1ZGlvLmNhbGxtaXhlci5jb25uZWN0KGF1ZGlvLmNhbGxzdHJlYW0pXG4gICAgLy9hdWRpby5jYWxsbWl4ZXIuY29ubmVjdChhdWRpby5tb25pdG9yKVxuXG5cbiAgICBhdWRpby5taWMuY29ubmVjdChhdWRpby5tb25pdG9yKVxuICAgIGF1ZGlvLmNhbGwuY29ubmVjdChhdWRpby5tb25pdG9yKVxuICAgIGF1ZGlvLnRyYWNrLmNvbm5lY3QoYXVkaW8ubW9uaXRvcilcbiAgICBhdWRpby5tb25pdG9yLmNvbm5lY3QobWFzdGVyLmRlc3RpbmF0aW9uKVxuXG4gICAgYXVkaW8ubWljLmNvbm5lY3QoYXVkaW8uYnJvYWRjYXN0bWl4ZXIpXG4gICAgLy9hdWRpby50cmFjay5jb25uZWN0KGF1ZGlvLmJyb2FkY2FzdG1peGVyKVxuICAgIC8vYXVkaW8uY2FsbC5jb25uZWN0KGF1ZGlvLmJyb2FkY2FzdG1peGVyKVxuXG4gICAgLy9hdWRpby5taWMuY29ubmVjdChhdWRpby5jYWxsbWl4ZXIpXG4gICAgLy9hdWRpby50cmFjay5jb25uZWN0KGF1ZGlvLmNhbGxtaXhlcilcblxuICAgIGF1ZGlvLmJyb2FkY2FzdG1peGVyLmNvbm5lY3QoYXVkaW8uYnJvYWRjYXN0c3RyZWFtKVxuICAgIGF1ZGlvLmNhbGxtaXhlci5jb25uZWN0KGF1ZGlvLmNhbGxzdHJlYW0pXG4gICAgXG4gICAgY29uc3Qgd29ya2VyT3B0aW9ucyA9IHtcbiAgICAgIGVuY29kZXJXb3JrZXJGYWN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFVNRCBzaG91bGQgYmUgdXNlZCBpZiB5b3UgZG9uJ3QgdXNlIGEgd2ViIHdvcmtlciBidW5kbGVyIGZvciB0aGlzLlxuICAgICAgICByZXR1cm4gbmV3IFdvcmtlcih0b2IoZnMucmVhZEZpbGVTeW5jKCcuL3B1YmxpYy9zdGF0aWMvZW5jb2Rlcldvcmtlci51bWQuanMnKSkpXG4gICAgICB9LFxuICAgICAgT2dnT3B1c0VuY29kZXJXYXNtUGF0aDogdG9iKGZzLnJlYWRGaWxlU3luYygnLi9wdWJsaWMvc3RhdGljL09nZ09wdXNFbmNvZGVyLndhc20nKSksXG4gICAgICBXZWJNT3B1c0VuY29kZXJXYXNtUGF0aDogdG9iKGZzLnJlYWRGaWxlU3luYygnLi9wdWJsaWMvc3RhdGljL1dlYk1PcHVzRW5jb2Rlci53YXNtJykpXG4gICAgfTtcblxuICAgIGF1ZGlvLmJyb2FkY2FzdGVuY29kZXIgPSBuZXcgTWVkaWFSZWNvcmRlcihhdWRpby5icm9hZGNhc3RzdHJlYW0uc3RyZWFtLCB7YXVkaW9CaXRzUGVyU2Vjb25kOjQwMDAwLCBtaW1lVHlwZTptaW1lfSwgd29ya2VyT3B0aW9ucylcbiAgICBhdWRpby5jYWxsZW5jb2RlciA9IG5ldyBNZWRpYVJlY29yZGVyKGF1ZGlvLmNhbGxzdHJlYW0uc3RyZWFtLCB7YXVkaW9CaXRzUGVyU2Vjb25kOjQwMDAwLCBtaW1lVHlwZTptaW1lfSwgd29ya2VyT3B0aW9ucylcblxuICAgIGF1ZGlvLmJyb2FkY2FzdGVuY29kZXIuYWRkRXZlbnRMaXN0ZW5lcignZGF0YWF2YWlsYWJsZScsIGUgPT4ge1xuICAgICAgYnRvYihlLmRhdGEsIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYoYXBwLnNlc3Npb24uYnJvYWRjYXN0aW5nKSBhcHAuX2xvZyhidWYubGVuZ3RoKVxuICAgICAgICAvL2J1ZnIucHVzaChuZXcgVWludDhBcnJheShidWYpKVxuICAgIC8vICAgIGFwcC5hdWRpby5kZWNvZGVyLmRlY29kZShidWYpICAgICBcbiAgICAgICAgYXBwLm5ldHdvcmsuYnJvYWRjYXN0KGJ1ZilcbiAgICAgICAgLy9zdHJTcmMud3JpdGUoYnVmKVxuICAgICAgfSlcblxuICAgIH0pXG5cbiAgICBhdWRpby5jYWxsZW5jb2Rlci5hZGRFdmVudExpc3RlbmVyKCdkYXRhYXZhaWxhYmxlJywgZSA9PiB7XG4gICAgICBidG9iKGUuZGF0YSwgKGVyciwgYnVmKSA9PiB7XG4gICAgICAgIC8vYnVmci5wdXNoKG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgICAgIGFwcC5hdWRpby5kZWNvZGVyLmRlY29kZShidWYpICAgICBcbiAgICAgICAgLy9hcHAubmV0d29yay5zZW5kKGJ1ZilcbiAgICAgICAgLy9zdHJTcmMud3JpdGUoYnVmKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgXG4gICAgYXVkaW8uYnJvYWRjYXN0ZW5jb2Rlci5zdGFydCgxMDAwKVxuXG4gICAgYXV0b3J1bigoKT0+e1xuICAgICAgaWYoYXBwLnVwZGF0ZSkge1xuICAgICAgICBhdWRpb1thcHAudXBkYXRlWzBdXS5nYWluLnZhbHVlID0gTWF0aC5tYXgoMCwgYXBwLnVwZGF0ZVsxXSkvLy5tb25pdG9yXG4gICAgICB9IFxuICAgIH0pXG5cbiAgICBhcHAuX2xvZyhgbWVkaWFSZWNvcmRlciBhZGRlZD8gJHsoISFhdWRpby5icm9hZGNhc3RlbmNvZGVyKX1gKVxuXG4gICAgYXBwLmF1ZGlvID0gYXVkaW9cbiAgICBtYXN0ZXIucmVzdW1lKClcbiAgICBjYihudWxsLCBhcHApXG4gIH1cblxuICBmdW5jdGlvbiBpbml0VUkoYXBwLCBjYil7XG5cbiAgICB1aS5saXZlbGluay5pbm5lclRleHQgPSAnaHR0cHM6Ly9nYWJyLnZlcmNlbC5hcHA/c3RyZWFtPScrYXBwLnNlc3Npb24uc3RyZWFtXG4gICAgdWkuY29weWJ1dHRvbi5vbmNoYW5nZSA9IGUgPT4ge1xuICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodWkubGluay5pbm5lclRleHQpXG4gICAgfVxuICAgIHVpLnJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICBhcHAubmV0d29yay5pbml0Q2FsbChhcHAuc2Vzc2lvbi5zdHJlYW0pXG4gICAgfSlcbiAgICB1aS5maWxlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGUgPT4ge1xuICAgICAgY29uc29sZS5sb2coZS50YXJnZXQuZmlsZXNbMF0pXG4gICAgICB2YXIgYSA9IGgoJ2F1ZGlvLmludmVydCcsIHtjb250cm9sczogdHJ1ZSwgc3JjIDogVVJMLmNyZWF0ZU9iamVjdFVSTChlLnRhcmdldC5maWxlc1swXSl9KVxuICAgICAgdWkudHJhY2tzLmFwcGVuZENoaWxkKGEpXG4gICAgICB2YXIgYz0gYXBwLmF1ZGlvLm1hc3Rlci5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UoYSlcbiAgICAgIGNvbnNvbGUubG9nKGEpXG4gICAgICBjLmNvbm5lY3QoYXBwLmF1ZGlvLnRyYWNrbWl4ZXIpXG4gICAgICBidG9iKGUudGFyZ2V0LmZpbGVzWzBdLCAoZXJyLCBidWYpID0+IHtcbiAgICAgICAgc2FtcGxlcihhcHAuYXVkaW8ubWFzdGVyLCBidWYuYnVmZmVyLCAoZXJyLCBub2RlKSA9PntcbiAgICAgICAgICAvL25vZGUuY29ubmVjdChhcHAuYXVkaW8ubWFzdGVyLmRlc3RpbmF0aW9uKVxuICAgICAgICAgIC8vbm9kZS5zdGFydCgwKVxuICAgICAgICB9KSAgICAgIFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgO1tdLmZvckVhY2guY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPXJhbmdlXScpLCBlID0+IHtcbiAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBldiA9PiB7XG4gICAgICAgIGJ1cy5lbWl0KCdhcHBTdGF0ZUNoYW5nZScsIFtldi50YXJnZXQubmFtZSwgTnVtYmVyKGV2LnRhcmdldC52YWx1ZSldKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgO1tdLmZvckVhY2guY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1tdXRlXScpLCBlID0+IHtcbiAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZXYgPT4ge1xuICAgICAgICBidXMuZW1pdCgnYXBwU3RhdGVDaGFuZ2UnLCBbZXYudGFyZ2V0LmRhdGFzZXQubXV0ZSwgLSBhcHBbZXYudGFyZ2V0LmRhdGFzZXQubXV0ZV1dKVxuICAgICAgfSlcbiAgICB9KVxuXG5cbiAgICB1aS5tb25pdG9yUmFuZ2UuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhlLnRhcmdldC52YWx1ZSlcbiAgICAgIC8vYnVzLmVtaXQoJ2FwcFN0YXRlQ2hhbmdlJywgWydtb25pdG9yJywgTnVtYmVyKGUudGFyZ2V0LnZhbHVlKV0pXG4gICAgICAvL2FwcC5zZXRHYWluKCdtb25pdG9yJywgTnVtYmVyKGUudGFyZ2V0LnZhbHVlKSlcbiAgICB9KVxuXG4gICAgY2IobnVsbCxhcHApXG5cbiAgfVxuXG5cbiAgZnVuY3Rpb24gaW5pdENhc3QoYXBwKXtcbiAgXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNiKXtcbiAgICAgIGFwcC5fbG9nKCdzdGF0ZUluaXQnKVxuICAgICAgY2IobnVsbCwgYXBwKVxuICAgIFxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjYXB0dXJlTmV0d29yayhhcHAsIGNiKSB7XG4gICAgdmFyIG5ldHdvcmsgPSBuZXcgTmV0d29yayhhcHAsIGFyZ3YucHJvdG9jb2wgKyAnOi8vJyArIGFyZ3YuaG9zdCArICc6JyArIGFyZ3YucG9ydClcbiAgICBhcHAuX2xvZygnbmV0Q2FwJylcbiAgICBhcHAubmV0d29yayA9IG5ldHdvcmtcblxuICAgIGNiKG51bGwsIGFwcClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhcHR1cmVTb3VyY2UgKGFwcCwgY2IpIHtcbiAgICAvLyBUT0RPIHNvdXJjZSBpcyBlaXRoZXIgdGhlIG1lZGlhc3RyZWFtIG9yIGEgcGVlciBjb25uZWN0aW9uXG4gICAgXG4gICAgaWYodHJ1ZSB8fCBhcHAuc2Vzc2lvbi5icm9hZGNhc3Rpbmcpe1xuICAgICAgYWRkTWVkaWEoKGVyciwgc3RyZWFtKSA9PntcbiAgICAgICAgYXBwLl9sb2coYG1lZGlhU3RyZWFtIGFkZGVkPyAkeyghIXN0cmVhbSl9YClcbiAgICAgICAgYXBwLl9sb2coYG1lZGlhU3RyZWFtIGVycm9yPyAkeyhlcnIpfWApXG5cbiAgICAgICAgY29uc29sZS5sb2coZXJyKVxuICAgICAgICBjb25zb2xlLmxvZyhzdHJlYW0pXG5cbiAgICAgICAgY29uc3QgbWljID0gYXBwLmF1ZGlvLm1hc3Rlci5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pIFxuICAgICAgICBtaWMuY29ubmVjdChhcHAuYXVkaW8ubWljKVxuXG4gICAgICAgIGFwcC5hdWRpby5tZWRpYXN0cmVhbSA9IHN0cmVhbVxuICAgICAgICBhcHAuYXVkaW8ubWljbm9kZSA9IG1pY1xuICAgIFxuICAgICAgICAvKlxuICAgICAgICB2YXIgYnVmciA9IFtdXG4gICAgICAgIGFwcC5hdWRpby5idWZmZXIgPSBidWZyXG4gICAgICAgIGNvbnN0IHN0clNyYyA9IHRocnUoKGIsIHIsIGNiKT0+e1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3NvdXJjZScsIGIpXG4gICAgICAgICAgY2IobnVsbCwgYilcbiAgICAgICAgfSxlPT57XG4gICAgICAgICAgY29uc29sZS5sb2coZSlcbiAgICAgICAgfSApXG4gICAgICAgIGFwcC5hdWRpby5zb3VyY2VTdHJlYW0gPSBzdHJTcmNcbiAgICAgICAgKi9cbiAgICAgICAgLy8gZG8gc2FtZSBmb3IgaG9zdCBtb25pdG9yaW5nOlxuICAgICAgICAvL2Zvcih2YXIgc21pdGggaW4gcGhvbmVib29rKSBtZWRpYVN0cmVhbS5waXBlKHBob25lYm9va1tzbWl0aF0pIFxuICAgICAgICAvL3VpLm1vbml0b3Iuc3JjT2JqZWN0ID0gc3RyZWFtLy8gPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSkgICAgICBcbiAgICAgICAgLy8gRGVsZXRlIHRoZSBlbmNvZGVyIHdoZW4gZmluaXNoZWQgd2l0aCBpdCAoRW1zY3JpcHRlbiBkb2VzIG5vdCBhdXRvbWF0aWNhbGx5IGNhbGwgQysrIG9iamVjdCBkZXN0cnVjdG9ycylcbiAgICAgICAgLy9lbmNvZGVyLmRlbGV0ZSgpO1xuICAgICAgIGFwcC5fbG9nKCdzb3VyY2VDYXAnKVxuICAgICAgICBjYihlcnIsIGFwcClcbiAgICAgICAgXG4gICAgICBcbiAgICAgIH0pXG4gICAgfVxuXG5cblxuXG4gIH1cblxuICBmdW5jdGlvbiBjYXB0dXJlU2luayhhcHAsIGNiKXtcbiAgICB2YXIge09nZ09wdXNEZWNvZGVyfSA9IHJlcXVpcmUoJ29nZy1vcHVzLWRlY29kZXInKVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3NtKGxvZyl7XG4gICAgXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IE9nZ09wdXNEZWNvZGVyKHtvbkRlY29kZSwgb25EZWNvZGVBbGx9KVxuXG4gICAgICBmdW5jdGlvbiBvbkRlY29kZSAoKSB7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uRGVjb2RlQWxsICh7Y2hhbm5lbERhdGEsIHNhbXBsZXNEZWNvZGVkLCBzYW1wbGVSYXRlfSkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKGNoYW5uZWxEYXRhKVxuICAgICAgICBsZXQgc2FtID0gc2FtcGxlcihhcHAuYXVkaW8ubWFzdGVyLCBjaGFubmVsRGF0YSlcbiAgICAgICAgc2FtLmNvbm5lY3QoYXBwLmF1ZGlvLm1hc3Rlci5kZXN0aW5hdGlvbilcbiAgICAgICAgc2FtLnN0YXJ0KDApXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGRlY29kZXIucmVhZHlcblxuICAgICAgLypcbiAgICAgIGNvbnN0IHNpbmtTdHJlYW0gPSB0aHJ1KChidWYsIGVuYywgY2IpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ3NpbmsnLCBidWYpXG4gICAgICAgIGRlY29kZXIuZGVjb2RlKGJ1ZilcbiAgICAgICAgY2IoKVxuICAgICAgfSwgZSA9PntcbiAgICAgICAgY29uc29sZS5sb2coZSlcbiAgICAgIFxuICAgICAgfSlcblxuICAgICAgdmFyIHNpbmtTdGF0ZSA9IHtcbiAgICAgICAgc2luazogc2lua1N0cmVhbSxcbiAgICAgIH1cbiAgICAgICovXG4gICAgICBsb2coZGVjb2RlcilcbiAgICAgIC8vYXBwLmF1ZGlvLnNpbmtTdHJlYW0gPSBzaW5rU3RyZWFtXG4gICAgICBcbiAgICB9XG5cbiAgICBidXMub24oXCJzb3VyY2VQZWVyQ2FwdHVyZWRcIiwgaWQgPT4ge1xuICAgICAgICB3c20oZnVuY3Rpb24oZGVjb2Rlcil7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1dBU00nKVxuICAgICAgICAgIGFwcC5fbG9nKCdzaW5rQ2FwJylcbiAgICAgICAgICBhcHAuYXVkaW8uZGVjb2RlciA9IGRlY29kZXJcbiAgICAgICAgICBsZXQgcGVlciA9IGFwcC5uZXR3b3JrLmNvbm5lY3Rpb25zW2lkXVxuICAgICAgICAgIHBlZXIub24oJ2RhdGEnLCBidWYgPT4ge1xuICAgICAgICAgICAgYXBwLl9sb2coYnVmLmxlbmd0aClcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgZGVjb2Rlci5yZWFkeS50aGVuKCgpID0+IGRlY29kZXIuZGVjb2RlKGJ1ZiksIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgYXBwLl9sb2coZXJyLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgZGVjb2Rlci5yZWFkeS50aGVuKCgpPT5kZWNvZGVyLmZyZWUoKSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICAgICAgICAgICBhcHAuX2xvZyhlcnIudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG5cblxuICAgICAgY2IobnVsbCwgYXBwKVxuICAgIFxuXG4gIH1cblxuXG5cbiAgZnVuY3Rpb24gdG9iKGJ1ZiwgdHlwZT1cImFwcGxpY2F0aW9uL3dhc21cIil7XG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW25ldyBCdWZmZXIoYnVmKS5idWZmZXJdLCB7dHlwZX0pKVxuICB9XG4gICBcbiAgdmFyIHBlZXJzID0ge31cblxuICAvL3VpLmFkZE1pYy5vbmNsaWNrID0gZSA9PiBhZGRNZWRpYSgpXG5cbiAgZnVuY3Rpb24gbXV0ZSh0b3JmKXtcbiAgICBtaWNTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXS5lbmFibGVkID0gdG9yZlxuICB9XG5cblxuICB2YXIgY29ubmVjdGluZyA9IHt9XG4gIGZ1bmN0aW9uIGluaXRCcm9hZGNhc3QoKXtcbiAgICAvLyBzb3VyY2UgY2FwIHRoZW4gYnJvYWRjYXN0XG4gICAgc2Vzc2lvbi5icm9hZGNhc3RJZCA9IHNob3J0KCkuZ2VuZXJhdGUoKVxuICAgIHNlc3Npb3MuZGlzdGFuY2UgPSAwXG4gICAgc2Vzc2lvbi5tYXhDb25uZWN0aW9ucyA9IDIwXG4gICAgc2Vzc2lvbi5vZmZlcnNPdXQgPSAwXG4gICAgLy8gYmUgc2Vla2FibGUgd2hlbi4uXG4gICAgc2Vla2FibGUoc2Vzc2lvbilcbiAgICByZXR1cm4gc2Vzc2lvblxuICB9XG5cblxuXG4gIGNsYXNzIE5ldHdvcmsgeyBcblxuICAgIGNvbnN0cnVjdG9yKGFwcCwgYWRkcil7XG4gICAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgICAgLy9jb25zb2xlLmxvZyhzdGF0ZSwgYWRkcilcbiAgICAgIHRoaXMuYXBwID0gYXBwXG4gICAgICB0aGlzLmh1YiA9IHNpZ25hbGh1YihhZGRyLCBhcHAuc2Vzc2lvbi5zdHJlYW0pXG4gICAgICB0aGlzLmNoYW5uZWwgPSBhcHAuc2Vzc2lvbi5zdHJlYW1cbiAgICAgIHRoaXMuaWQgPSBhcHAuc2Vzc2lvbi5pZFxuICAgICAgdGhpcy5zdGF0ZSA9IGFwcC5zdGF0ZVxuICAgICAgdGhpcy5jb25uZWN0aW9ucyA9IHt9XG4gICAgICB0aGlzLmh1YnMgPSB7fSBcbiAgICAgIHRoaXMucGVlcnMgPSB7fVxuICAgICAgdGhpcy5jYWxsZXJzID0ge31cbiAgICAgIHRoaXMuY29ubmVjdGluZyA9IHt9XG4gICAgICB0aGlzLmRpc3RhbmNlID0gMVxuICAgICAgdGhpcy5vZmZlcnNPdXQgPSAwXG4gICAgICB0aGlzLm1heENvbm5lY3Rpb25zID0gNCAvLyBzdGFydCBsb3csIHRlc3QgaGlnaCwgYWxzbyBoZWxwcyBzcHJlYWQgZWFybHkgcGNhc3QgdGVzdGluZ1xuICAgICAgdGhpcy5kdXJhdGlvbiA9IG51bGwgLy8gc2luY2Utd2hlblxuICAgICAgdGhpcy5jaGFubmVscyA9IHt9XG4gICAgICB0aGlzLmR1cmF0aW9uID0gbmV3IFRpbWVcbiAgICAgIHRoaXMuc2lua1N0cmVhbSA9IHRocnUoYnVmID0+IHtcbiAgICAgICAgZm9yKHZhciBuIGluIHRoaXMucGVlcnMpe1xuICAgICAgICAgIGxldCBwID0gdGhpcy5wZWVyc1tuXVxuICAgICAgICAgIGlmKHAud3JpdGFibGUpIHAud3JpdGUoYnVmKVxuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiBjbG9zZSgpe30pXG4gICAgfVxuXG4gICAgYnJvYWRjYXN0KGJ1Zil7XG4gICAgICBmb3IodmFyIG4gaW4gdGhpcy5wZWVycykgdGhpcy5wZWVyc1tuXS53cml0ZShidWYpXG4gICAgfVxuXG4gICAgc2VuZChidWYpe1xuICAgICAgZm9yKHZhciBuIGluIHRoaXMuY2FsbGVycykgdGhpcy5jYWxsZXJzW25dLndyaXRlKGJ1ZilcbiAgICB9XG5cbiAgICBsb2coKXtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICB9XG5cbiAgICBjbG9zZVBlZXJTaWduYWwoYWRkcil7XG4gICAgICB0aGlzLmh1Yi51bnN1YnNjcmliZShhZGRyKVxuICAgICAgLy9kZWxldGUgdGhpcy5jb25uZWN0aW9uc1thZGRyXVxuICAgIH1cblxuICAgIGRpc2FsbG93Q2FsbHMoaWQpe1xuICAgICAgdGhpcy5odWIudW5zdWJzY3JpYmUoJ2NhbGxlcjonK2lkKVxuICAgIH1cblxuICAgIGFsbG93Q2FsbHMoaWQpe1xuICAgICAgbGV0IGNhbGxzID0gdGhpcy5odWIuc3Vic2NyaWJlKCdjYWxsZXI6JytpZClcbiAgICAgIGNhbGxzLm9uKCdkYXRhJywgbXNnPT57XG4gICAgICAgIG1zZz1KU09OLnBhcnNlKG1zZylcbiAgICAgICAgYnVzLmVtaXQoJ2NhbGxlcicsIG1zZylcbiAgICAgIH0pXG4gICAgICBidXMub24oJ2NhbGwnLCBtc2cgPT57XG4gICAgICAgIHRoaXMuY2FsbERpcmVjdChtc2cucGVlcklkKVxuICAgICAgfSlcblxuICAgIH1cblxuICAgIGluaXRDYWxsKGlkKXtcbiAgICAgIFxuICAgICAgdGhpcy5odWIuYnJvYWRjYXN0KCdjYWxsZXI6JytpZCwge3BlZXJJZDogdGhpcy5pZH0pXG4gICAgICBsZXQgcGVlciA9IHRoaXMuaW5pdENvbm5lY3QoaWQsIGZhbHNlLCB0aGlzLmlkKVxuICAgICAgcGVlci5vbmNlKCdjb25uZWN0ZWQnLCBlID0+e1xuICAgICAgICB0aGlzLmNhbGxlcnNbaWRdID0gcGVlclxuICAgICAgICBidXMuZW1pdCgnQ2FsbCBTb3VyY2UgQ2FwdHVyZWQnLCBwZWVyKVxuXG4gICAgICB9KVxuICAgICAgXG4gICAgICBcbiAgICB9XG5cbiAgICBjYWxsRGlyZWN0KGlkKXtcbiAgICAgIGxldCBwZWVyID0gdGhpcy5pbml0Q29ubmVjdChpZCwgdHJ1ZSwgdGhpcy5pZClcbiAgICAgIHBlZXIub25jZSgnY29ubmVjdGVkJywgZSA9PntcbiAgICAgICAgdGhpcy5jYWxsZXJzW2lkXSA9IHBlZXJcbiAgICAgICAgYnVzLmVtaXQoJ0NhbGwgU291cmNlIENhcHR1cmVkJywgcGVlcilcblxuICAgICAgfSlcbiAgICB9XG5cbiAgICBzb3VyY2VTZWVrKCl7IC8vIGlkIGZvciBhIHBlZXIgc3RyZWFtXG4gICAgICB2YXIgc2VsZiA9IHRoaXMgXG4gICAgICBsZXQgbWFzayA9IHNob3J0KCkuZ2VuZXJhdGUoKVxuICAgICAgbGV0IG9mZmVyaW5ncyA9IHRoaXMuaHViLnN1YnNjcmliZShtYXNrKVxuICAgICAgdmFyIGJlc3QgPSAwLy9JbmZpbml0eVxuICAgICAgdmFyIGNob3NlblxuICAgICAgdmFyIHN0YXJ0ID0gbmV3IFRpbWVcbiAgICAgIG9mZmVyaW5ncy5vbignZGF0YScsIG9mZmVyID0+IHtcbiAgICAgICAgb2ZmZXIgPSBKU09OLnBhcnNlKG9mZmVyKVxuICAgICAgICBzZWxmLmFwcC5fbG9nKG9mZmVyKVxuICAgICAgICBsZXQgc2NvcmUgPSAoMSAvIG9mZmVyLmRpc3RhbmNlKSAqIG9mZmVyLmR1cmF0aW9uXG4gICAgICAgIGlmKHNjb3JlID4gYmVzdCkge1xuICAgICAgICAgIGJlc3QgPSBzY29yZSAvL29mZmVyLmRpc3RhbmNlXG4gICAgICAgICAgY2hvc2VuID0gb2ZmZXJcbiAgICAgICAgfVxuICAgICAgY29uc29sZS5sb2coY2hvc2VuKVxuICAgICAgfSlcbiAgICAgIGxldCB0MCA9IHNldFRpbWVvdXQoZSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhjaG9zZW4pXG4gICAgICAgIGlmKGNob3Nlbikge1xuICAgIC8vICAgICAgdGhpcy5odWIudW5zdWJzY3JpYmUobWFzaylcbiAgICAgICAgICAvLyBkbyBjaG9zZW5cbiAgICAgICAgICBidXMuZW1pdCgnc291cmNlUGVlcklkQ2FwdHVyZWQnLCBjaG9zZW4ucGVlcklkKVxuICAgICAgICAgIC8vc2VsZi5zb3VyY2VDYXAoY2hvc2VuKVxuICAgICAgICAgIGxldCBwZWVyID0gdGhpcy5pbml0Q29ubmVjdChjaG9zZW4ucGVlcklkLCB0cnVlLCBtYXNrKVxuICAgICAgICAgIHBlZXIub25jZSgnY29ubmVjdCcsIGUgPT4ge1xuICAgICAgICAgICAgYnVzLmVtaXQoJ3NvdXJjZVBlZXJDYXB0dXJlZCcsIGNob3Nlbi5wZWVySWQpXG4gICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gY2hvc2VuLmRpc3RhbmNlICsgMVxuICAgICAgICAgICAgdGhpcy5zb3VyY2VTdHJlYW0gPSBwZWVyXG4gICAgICAgICAgICBzZWxmLmFwcC5fbG9nKCdTb3VyY2UgUGVlciBDYXB0dXJlZC4nKVxuXG4gICAgICAgICAgfSlcbiAgICAgICAgICBwZWVyLm9uKCdjbG9zZScsIGUgPT4ge1xuICAgICAgICAgICAgc2VsZi5hcHAuX2xvZygnU291cmNlIFBlZXIgQ2xvc2VkJylcblxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5hcHAuX2xvZygnRXJyOiBObyBzb3VyY2UgcGVlciBmb3VuZC4nKSAgICBcbiAgICAgICAgfVxuICAgICAgfSwgMTMwMDApXG4gICAgICBcblxuICAgICAgdGhpcy5odWIuYnJvYWRjYXN0KCdzb3VyY2UnLCBcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHBlZXJJZDogbWFza1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgXG4gICAgfVxuXG4gICAgc2V0IHNvdXJjZVN0cmVhbShzdHJlYW0pe1xuICAgICAgdGhpcy5fc291cmNlU3RyZWFtID0gc3RyZWFtXG4gICAgICB0aGlzLmR1cmF0aW9uID0gbmV3IFRpbWUoKVxuICAgICAgLy9zdHJlYW0ucGlwZSh0aGlzLnNpbmtTdHJlYW0pXG4gICAgICAvL3N0cmVhbS5waXBlKGFwcC5hdWRpby5zaW5rU3RyZWFtKVxuICAgIH1cblxuICAgIGdldCBzb3VyY2VTdHJlYW0oKXtcbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VTdHJlYW1cbiAgICB9XG5cbiAgICB1bnNlZWthYmxlKHNlc3Npb24pe1xuICAgICAgaWYoc2VzaW9uKSB0aGlzLmh1Yi51bnN1YnNjcmliZShzZXNzaW9uKVxuICAgIH1cblxuICAgIGlzU2Vla1dvcnRoeSgpe1xuICAgICAgbGV0IHIgPSB0aGlzLm9mZmVyc091dCA8IHRoaXMubWF4Q29ubmVjdGlvbnNcbiAgICAgIGxldCBzID0gdGhpcy5tYXhDb25uZWN0aW9ucyA+IE9iamVjdC5rZXlzKHRoaXMuY29ubmVjdGlvbnMpLmxlbmd0aCAgXG4gICAgICBsZXQgcSA9IHIgJiYgcyBcbiAgICAgIHRoaXMuX3NlZWthYmxlID0gcVxuICAgICAgaWYocSkge1xuICAgICAgICB0aGlzLnNvdXJjZXIgPSB0aGlzLmh1Yi5zdWJzY3JpYmUoJ3NvdXJjZScpXG4gICAgICAgIHRoaXMuc291cmNlci5vbignZGF0YScsIG1zZyA9PiB0aGlzLnNlZWthYmxlKEpTT04ucGFyc2UobXNnKSkpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYodGhpcy5zb3VyY2VyKSB0aGlzLnNvdXJjZXIuY2xvc2UoKVxuICAgICAgICBcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9zZWVrYWJsZVxuICAgIH1cblxuICAgIHNldHN1YihpZCl7XG4gICAgICBpZih0aGlzLmh1YnNbaWRdKSByZXR1cm4gdGhpcy5odWJzW2lkXVxuICAgICAgZWxzZSB0aGlzLmh1YnNbaWRdID0gdGhpcy5odWIuc3Vic2NyaWJlKGlkKVxuICAgIH1cbiAgICBnZXRzdWIoaWQpe1xuICAgICAgcmV0dXJuIHRoaXMuaHVic1tpZF1cbiAgICB9XG5cbiAgICB1bnN1YihpZCl7XG4gICAgICBpZih0aGlzLmh1YnNbaWRdKSB7XG4gICAgICAgIHRoaXMuaHViLnVuc3Vic2NyaWJlKGlkKSBcbiAgICAgICAgZGVsZXRlIHRoaXMuaHVic1tpZF0gXG4gICAgICB9XG4gICAgfVxuXG4gICAgc2Vla2FibGUobXNnKXsgXG4gICAgdGhpcy5hcHAuX2xvZyhtc2cpXG4gICAgICBsZXQgc2VsZiA9IHRoaXNcbiAgICAgIGlmKGZhbHNlKSByZXR1cm4gLy8gfHwgTWF0aC5yYW5kb20oKSA8IDEgLyBNYXRoLnBvdyhzZWxmLmRpc3RhbmNlLCAyKSkgcmV0dXJuXG4gICAgICBlbHNle1xuICAgICAgICBzZWxmLm9mZmVyc091dCArPSAxXG4gICAgICAgIHNldFRpbWVvdXQoZT0+e1xuICAgICAgICAgIHRoaXMub2ZmZXJzT3V0LS1cbiAgICAgICAgICAvL3RoaXMuZGlzbml0KG1zZy5wZWVySWQsIG1hc2spXG4gICAgICAgIH0sIDExMTEqMylcbiAgICAgICAgbGV0IG1hc2sgPSBzaG9ydCgpLmdlbmVyYXRlKClcbiAgICAgICAgbGV0IHBlZXIgPSB0aGlzLmluaXRDb25uZWN0KG1zZy5wZWVySWQsIGZhbHNlLCBtYXNrKVxuICAgICAgICBwZWVyLm9uY2UoJ2Nvbm5lY3QnLCBlID0+e1xuICAgICAgICAgIHNlbGYucGVlcnNbbXNnLnBlZXJJZF0gPSBwZWVyXG4gICAgICAgIH0pXG4gICAgICAgIHBlZXIub25jZSgnY2xvc2UnLCBlID0+e1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLnBlZXJzW21zZy5wZWVySWRdXG4gICAgICAgICAgc2VsZi5pc1NlZWtXb3J0aHkoKVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLmh1Yi5icm9hZGNhc3QobXNnLnBlZXJJZCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHBlZXJJZDogbWFzayxcbiAgICAgICAgICB0bzogbXNnLnBlZXJJZCxcbiAgICAgICAgICBkaXN0YW5jZTogdGhpcy5kaXN0YW5jZSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbi5zaW5jZUJlZ2luTlMoKVxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNuaXQoaWQsIG1hc2spe1xuICAgICAgLy9kZWxldGUgdGhpcy5jb25uZWN0aW5nW2lkXVxuICAgICAgLy90aGlzLmh1Yi51bnN1YnNjcmliZShtYXNrKVxuICAgIH1cblxuICAgIGluaXRDb25uZWN0KGlkLCBpbml0LCBtYXNrKXtcbiAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgbGV0IHBpcGUgPSB0aGlzLmh1Yi5zdWJzY3JpYmUobWFzaylcbiAgICAgIHZhciBjYWxsZXIgPSBuZXcgUGVlcih7aW5pdGlhdG9yOiBpbml0LCB0cmlja2xlOiBmYWxzZSwgb2JqZWN0TW9kZTogZmFsc2V9KVxuICAgICAgdGhpcy5jb25uZWN0aW5nW2lkXSA9IGNhbGxlclxuICAgICAgcGlwZS5vbignZXJyb3InLCBlID0+IGNvbnNvbGUubG9nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpXG4gICAgICBwaXBlLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgICAgIC8vIGNhbGxlcklEXG4gICAgICAgIHZhciBwZWVyID0gc2VsZi5jb25uZWN0aW5nW2RhdGEucGVlcklkXVxuICAgICAgICBwZWVyLnNpZ25hbChkYXRhLnNpZ25hbClcbiAgICAgICAgcGVlci5vbmNlKCdjb25uZWN0JywgZSA9PiB7XG4gICAgICAgICAgLy8gY2xvc2UgbWFzayBodWJcbiAgICAgICAgfSlcbiAgICAgICAgLy91aS5jYWxsZXJzLmFwcGVuZENoaWxkKGgoJ2Rpdi5jYWxsZXInLCBoKCdidXR0b24uY29ubmVjdCcsIGBDb25uZWN0IHRvICR7ZGF0YS5uYW1lIHx8IGZyb219YCwge29uY2xpY2s6IF9jb25uZWN0fSkpKSAgXG4gICAgICB9KVxuICAgICAgY2FsbGVyLl9kZWJ1ZyA9IGNvbnNvbGUubG9nXG4gICAgICBjYWxsZXIub24oJ3NpZ25hbCcsIHNpZyA9PiB0aGlzLmh1Yi5icm9hZGNhc3QoaWQsIEpTT04uc3RyaW5naWZ5KHtwZWVySWQ6IG1hc2ssIHRvOiBpZCwgc2lnbmFsOiBzaWcgfSkpKVxuICAgICAgY2FsbGVyLm9uY2UoJ2Nvbm5lY3QnLCBlID0+IHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uc1tpZF0gPSBjYWxsZXJcbiAgICAgICAgdGhpcy5jb25uZWN0aW5nW2lkXSA9IG51bGxcbiAgICAgICAgY29uc29sZS5sb2coYGNvbm5lY3RlZCB0byAke09iamVjdC5rZXlzKHRoaXMuY29ubmVjdGlvbnMpLmxlbmd0aH0gcGVlcnNgKVxuICAgICAgfSlcbiAgICAgIGNhbGxlci5vbignY2xvc2UnLCBlID0+IHtcbiAgICAgICAgdGhpcy5kaXNuaXQoaWQsIG1hc2spXG4gICAgICB9KVxuICAgICAgY2FsbGVyLm9uKCdlcnJvcicsIGUgPT4gY29uc29sZS5sb2coZSkpXG4gICAgICByZXR1cm4gY2FsbGVyXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBhZGRNZWRpYShjYiwgYXVkaW89dHJ1ZSwgdmlkZW89ZmFsc2Upe1xuICAgIHZhciBnYW0gPSByZXF1aXJlKCdnZXR1c2VybWVkaWEnKVxuICAgIC8vIFdlYiB3b3JrZXIgYW5kIC53YXNtIGNvbmZpZ3VyYXRpb24uIE5vdGU6IFRoaXMgaXMgTk9UIGEgcGFydCBvZiBXM0Mgc3RhbmRhcmQuXG4gICAgZ2FtKHt2aWRlbywgYXVkaW99LCBmdW5jdGlvbihlcnIsIHN0cmVhbSl7XG4gICAgICAvL2NvbnNvbGUubG9nKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpKVxuXG5cbiAgICAgIGNiKGVyciwgc3RyZWFtKVxuICAgIH0pXG4gICB9ICAgIFxufSlcbiIsInZhciBDb252ZXJ0ZXIgPSByZXF1aXJlKCcuL3NyYy9jb252ZXJ0ZXInKTtcblxuLyoqXG4gKiBGdW5jdGlvbiBnZXQgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBhbHBoYWJldCBhbmQgcmV0dXJuIGNvbnZlcnQgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gc3JjQWxwaGFiZXRcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBkc3RBbHBoYWJldFxuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihudW1iZXJ8QXJyYXkpfVxuICovXG5mdW5jdGlvbiBhbnlCYXNlKHNyY0FscGhhYmV0LCBkc3RBbHBoYWJldCkge1xuICAgIHZhciBjb252ZXJ0ZXIgPSBuZXcgQ29udmVydGVyKHNyY0FscGhhYmV0LCBkc3RBbHBoYWJldCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydCBmdW5jdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IG51bWJlclxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfEFycmF5fSBudW1iZXJcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICByZXR1cm4gY29udmVydGVyLmNvbnZlcnQobnVtYmVyKTtcbiAgICB9XG59O1xuXG5hbnlCYXNlLkJJTiA9ICcwMSc7XG5hbnlCYXNlLk9DVCA9ICcwMTIzNDU2Nyc7XG5hbnlCYXNlLkRFQyA9ICcwMTIzNDU2Nzg5JztcbmFueUJhc2UuSEVYID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFueUJhc2U7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbnZlcnRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBzcmNBbHBoYWJldFxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IGRzdEFscGhhYmV0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ29udmVydGVyKHNyY0FscGhhYmV0LCBkc3RBbHBoYWJldCkge1xuICAgIGlmICghc3JjQWxwaGFiZXQgfHwgIWRzdEFscGhhYmV0IHx8ICFzcmNBbHBoYWJldC5sZW5ndGggfHwgIWRzdEFscGhhYmV0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBhbHBoYWJldCcpO1xuICAgIH1cbiAgICB0aGlzLnNyY0FscGhhYmV0ID0gc3JjQWxwaGFiZXQ7XG4gICAgdGhpcy5kc3RBbHBoYWJldCA9IGRzdEFscGhhYmV0O1xufVxuXG4vKipcbiAqIENvbnZlcnQgbnVtYmVyIGZyb20gc291cmNlIGFscGhhYmV0IHRvIGRlc3RpbmF0aW9uIGFscGhhYmV0XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IG51bWJlciAtIG51bWJlciByZXByZXNlbnRlZCBhcyBhIHN0cmluZyBvciBhcnJheSBvZiBwb2ludHNcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfEFycmF5fVxuICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbihudW1iZXIpIHtcbiAgICB2YXIgaSwgZGl2aWRlLCBuZXdsZW4sXG4gICAgbnVtYmVyTWFwID0ge30sXG4gICAgZnJvbUJhc2UgPSB0aGlzLnNyY0FscGhhYmV0Lmxlbmd0aCxcbiAgICB0b0Jhc2UgPSB0aGlzLmRzdEFscGhhYmV0Lmxlbmd0aCxcbiAgICBsZW5ndGggPSBudW1iZXIubGVuZ3RoLFxuICAgIHJlc3VsdCA9IHR5cGVvZiBudW1iZXIgPT09ICdzdHJpbmcnID8gJycgOiBbXTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkKG51bWJlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgXCInICsgbnVtYmVyICsgJ1wiIGNvbnRhaW5zIG9mIG5vbi1hbHBoYWJldGljIGRpZ2l0cyAoJyArIHRoaXMuc3JjQWxwaGFiZXQgKyAnKScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNyY0FscGhhYmV0ID09PSB0aGlzLmRzdEFscGhhYmV0KSB7XG4gICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG51bWJlck1hcFtpXSA9IHRoaXMuc3JjQWxwaGFiZXQuaW5kZXhPZihudW1iZXJbaV0pO1xuICAgIH1cbiAgICBkbyB7XG4gICAgICAgIGRpdmlkZSA9IDA7XG4gICAgICAgIG5ld2xlbiA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGl2aWRlID0gZGl2aWRlICogZnJvbUJhc2UgKyBudW1iZXJNYXBbaV07XG4gICAgICAgICAgICBpZiAoZGl2aWRlID49IHRvQmFzZSkge1xuICAgICAgICAgICAgICAgIG51bWJlck1hcFtuZXdsZW4rK10gPSBwYXJzZUludChkaXZpZGUgLyB0b0Jhc2UsIDEwKTtcbiAgICAgICAgICAgICAgICBkaXZpZGUgPSBkaXZpZGUgJSB0b0Jhc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ld2xlbiA+IDApIHtcbiAgICAgICAgICAgICAgICBudW1iZXJNYXBbbmV3bGVuKytdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSBuZXdsZW47XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZHN0QWxwaGFiZXQuc2xpY2UoZGl2aWRlLCBkaXZpZGUgKyAxKS5jb25jYXQocmVzdWx0KTtcbiAgICB9IHdoaWxlIChuZXdsZW4gIT09IDApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWQgbnVtYmVyIHdpdGggc291cmNlIGFscGhhYmV0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbihudW1iZXIpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBudW1iZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHRoaXMuc3JjQWxwaGFiZXQuaW5kZXhPZihudW1iZXJbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb252ZXJ0ZXI7IiwiLyohIGJsb2ItdG8tYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBnbG9iYWwgQmxvYiwgRmlsZVJlYWRlciAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2JUb0J1ZmZlciAoYmxvYiwgY2IpIHtcbiAgaWYgKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJyB8fCAhKGJsb2IgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIEJsb2InKVxuICB9XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICB9XG5cbiAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuXG4gIGZ1bmN0aW9uIG9uTG9hZEVuZCAoZSkge1xuICAgIHJlYWRlci5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgb25Mb2FkRW5kLCBmYWxzZSlcbiAgICBpZiAoZS5lcnJvcikgY2IoZS5lcnJvcilcbiAgICBlbHNlIGNiKG51bGwsIEJ1ZmZlci5mcm9tKHJlYWRlci5yZXN1bHQpKVxuICB9XG5cbiAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBvbkxvYWRFbmQsIGZhbHNlKVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbn1cbiIsIi8qIVxuICogQ3Jvc3MtQnJvd3NlciBTcGxpdCAxLjEuMVxuICogQ29weXJpZ2h0IDIwMDctMjAxMiBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT5cbiAqIEF2YWlsYWJsZSB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIEVDTUFTY3JpcHQgY29tcGxpYW50LCB1bmlmb3JtIGNyb3NzLWJyb3dzZXIgc3BsaXQgbWV0aG9kXG4gKi9cblxuLyoqXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGEgcmVnZXggb3Igc3RyaW5nIHNlcGFyYXRvci4gTWF0Y2hlcyBvZiB0aGVcbiAqIHNlcGFyYXRvciBhcmUgbm90IGluY2x1ZGVkIGluIHRoZSByZXN1bHQgYXJyYXkuIEhvd2V2ZXIsIGlmIGBzZXBhcmF0b3JgIGlzIGEgcmVnZXggdGhhdCBjb250YWluc1xuICogY2FwdHVyaW5nIGdyb3VwcywgYmFja3JlZmVyZW5jZXMgYXJlIHNwbGljZWQgaW50byB0aGUgcmVzdWx0IGVhY2ggdGltZSBgc2VwYXJhdG9yYCBpcyBtYXRjaGVkLlxuICogRml4ZXMgYnJvd3NlciBidWdzIGNvbXBhcmVkIHRvIHRoZSBuYXRpdmUgYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgIGFuZCBjYW4gYmUgdXNlZCByZWxpYWJseVxuICogY3Jvc3MtYnJvd3Nlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNwbGl0LlxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSBzZXBhcmF0b3IgUmVnZXggb3Igc3RyaW5nIHRvIHVzZSBmb3Igc2VwYXJhdGluZyB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtsaW1pdF0gTWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzdWx0IGFycmF5LlxuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBzdWJzdHJpbmdzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBCYXNpYyB1c2VcbiAqIHNwbGl0KCdhIGIgYyBkJywgJyAnKTtcbiAqIC8vIC0+IFsnYScsICdiJywgJ2MnLCAnZCddXG4gKlxuICogLy8gV2l0aCBsaW1pdFxuICogc3BsaXQoJ2EgYiBjIGQnLCAnICcsIDIpO1xuICogLy8gLT4gWydhJywgJ2InXVxuICpcbiAqIC8vIEJhY2tyZWZlcmVuY2VzIGluIHJlc3VsdCBhcnJheVxuICogc3BsaXQoJy4ud29yZDEgd29yZDIuLicsIC8oW2Etel0rKShcXGQrKS9pKTtcbiAqIC8vIC0+IFsnLi4nLCAnd29yZCcsICcxJywgJyAnLCAnd29yZCcsICcyJywgJy4uJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gc3BsaXQodW5kZWYpIHtcblxuICB2YXIgbmF0aXZlU3BsaXQgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0LFxuICAgIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoXCJcIilbMV0gPT09IHVuZGVmLFxuICAgIC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG4gICAgc2VsZjtcblxuICBzZWxmID0gZnVuY3Rpb24oc3RyLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBgbmF0aXZlU3BsaXRgXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzZXBhcmF0b3IpICE9PSBcIltvYmplY3QgUmVnRXhwXVwiKSB7XG4gICAgICByZXR1cm4gbmF0aXZlU3BsaXQuY2FsbChzdHIsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAoc2VwYXJhdG9yLm11bHRpbGluZSA/IFwibVwiIDogXCJcIikgKyAoc2VwYXJhdG9yLmV4dGVuZGVkID8gXCJ4XCIgOiBcIlwiKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcbiAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gXCJ5XCIgOiBcIlwiKSxcbiAgICAgIC8vIEZpcmVmb3ggMytcbiAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyBcImdcIiksXG4gICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgIHN0ciArPSBcIlwiOyAvLyBUeXBlLWNvbnZlcnRcbiAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKFwiXlwiICsgc2VwYXJhdG9yLnNvdXJjZSArIFwiJCg/IVxcXFxzKVwiLCBmbGFncyk7XG4gICAgfVxuICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgKi9cbiAgICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZiA/IC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgIGxpbWl0ID4+PiAwOyAvLyBUb1VpbnQzMihsaW1pdClcbiAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdHIpKSB7XG4gICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZikge1xuICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdW5kZWY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoXCJcIikpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goXCJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufSkoKTtcbiIsIi8vIGNvbnRhaW5zLCBhZGQsIHJlbW92ZSwgdG9nZ2xlXG52YXIgaW5kZXhvZiA9IHJlcXVpcmUoJ2luZGV4b2YnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsYXNzTGlzdFxuXG5mdW5jdGlvbiBDbGFzc0xpc3QoZWxlbSkge1xuICAgIHZhciBjbCA9IGVsZW0uY2xhc3NMaXN0XG5cbiAgICBpZiAoY2wpIHtcbiAgICAgICAgcmV0dXJuIGNsXG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTGlzdCA9IHtcbiAgICAgICAgYWRkOiBhZGRcbiAgICAgICAgLCByZW1vdmU6IHJlbW92ZVxuICAgICAgICAsIGNvbnRhaW5zOiBjb250YWluc1xuICAgICAgICAsIHRvZ2dsZTogdG9nZ2xlXG4gICAgICAgICwgdG9TdHJpbmc6ICR0b1N0cmluZ1xuICAgICAgICAsIGxlbmd0aDogMFxuICAgICAgICAsIGl0ZW06IGl0ZW1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3NMaXN0XG5cbiAgICBmdW5jdGlvbiBhZGQodG9rZW4pIHtcbiAgICAgICAgdmFyIGxpc3QgPSBnZXRUb2tlbnMoKVxuICAgICAgICBpZiAoaW5kZXhvZihsaXN0LCB0b2tlbikgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5wdXNoKHRva2VuKVxuICAgICAgICBzZXRUb2tlbnMobGlzdClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmUodG9rZW4pIHtcbiAgICAgICAgdmFyIGxpc3QgPSBnZXRUb2tlbnMoKVxuICAgICAgICAgICAgLCBpbmRleCA9IGluZGV4b2YobGlzdCwgdG9rZW4pXG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgc2V0VG9rZW5zKGxpc3QpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGFpbnModG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGluZGV4b2YoZ2V0VG9rZW5zKCksIHRva2VuKSA+IC0xXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9nZ2xlKHRva2VuKSB7XG4gICAgICAgIGlmIChjb250YWlucyh0b2tlbikpIHtcbiAgICAgICAgICAgIHJlbW92ZSh0b2tlbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkKHRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICR0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NOYW1lXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlbShpbmRleCkge1xuICAgICAgICB2YXIgdG9rZW5zID0gZ2V0VG9rZW5zKClcbiAgICAgICAgcmV0dXJuIHRva2Vuc1tpbmRleF0gfHwgbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRva2VucygpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGVsZW0uY2xhc3NOYW1lXG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcihjbGFzc05hbWUuc3BsaXQoXCIgXCIpLCBpc1RydXRoeSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUb2tlbnMobGlzdCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGhcblxuICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGxpc3Quam9pbihcIiBcIilcbiAgICAgICAgY2xhc3NMaXN0Lmxlbmd0aCA9IGxlbmd0aFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2xhc3NMaXN0W2ldID0gbGlzdFtpXVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGxpc3RbbGVuZ3RoXVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyIChhcnIsIGZuKSB7XG4gICAgdmFyIHJldCA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZuKGFycltpXSkpIHJldC5wdXNoKGFycltpXSlcbiAgICB9XG4gICAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBpc1RydXRoeSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiBlbmFibGVPdmVycmlkZSA9PT0gbnVsbCA/IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKSA6IGVuYWJsZU92ZXJyaWRlLFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJyb3dzZXJJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJJbmZvKG5hbWUsIHZlcnNpb24sIG9zKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMub3MgPSBvcztcbiAgICB9XG4gICAgcmV0dXJuIEJyb3dzZXJJbmZvO1xufSgpKTtcbmV4cG9ydHMuQnJvd3NlckluZm8gPSBCcm93c2VySW5mbztcbnZhciBOb2RlSW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlSW5mbyh2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMubmFtZSA9ICdub2RlJztcbiAgICAgICAgdGhpcy5vcyA9IHByb2Nlc3MucGxhdGZvcm07XG4gICAgfVxuICAgIHJldHVybiBOb2RlSW5mbztcbn0oKSk7XG5leHBvcnRzLk5vZGVJbmZvID0gTm9kZUluZm87XG52YXIgQm90SW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb3RJbmZvKCkge1xuICAgICAgICB0aGlzLmJvdCA9IHRydWU7IC8vIE5PVEU6IGRlcHJlY2F0ZWQgdGVzdCBuYW1lIGluc3RlYWRcbiAgICAgICAgdGhpcy5uYW1lID0gJ2JvdCc7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMub3MgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQm90SW5mbztcbn0oKSk7XG5leHBvcnRzLkJvdEluZm8gPSBCb3RJbmZvO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxudmFyIFNFQVJDSEJPWF9VQV9SRUdFWCA9IC9hbGV4YXxib3R8Y3Jhd2woZXJ8aW5nKXxmYWNlYm9va2V4dGVybmFsaGl0fGZlZWRidXJuZXJ8Z29vZ2xlIHdlYiBwcmV2aWV3fG5hZ2lvc3xwb3N0cmFua3xwaW5nZG9tfHNsdXJwfHNwaWRlcnx5YWhvbyF8eWFuZGV4LztcbnZhciBTRUFSQ0hCT1RfT1NfUkVHRVggPSAvKG51aGspfChHb29nbGVib3QpfChZYW1teWJvdCl8KE9wZW5ib3QpfChTbHVycCl8KE1TTkJvdCl8KEFzayBKZWV2ZXNcXC9UZW9tYSl8KGlhX2FyY2hpdmVyKS87XG52YXIgUkVRVUlSRURfVkVSU0lPTl9QQVJUUyA9IDM7XG52YXIgdXNlckFnZW50UnVsZXMgPSBbXG4gICAgWydhb2wnLCAvQU9MU2hpZWxkXFwvKFswLTlcXC5fXSspL10sXG4gICAgWydlZGdlJywgL0VkZ2VcXC8oWzAtOVxcLl9dKykvXSxcbiAgICBbJ2VkZ2UtaW9zJywgL0VkZ2lPU1xcLyhbMC05XFwuX10rKS9dLFxuICAgIFsneWFuZGV4YnJvd3NlcicsIC9ZYUJyb3dzZXJcXC8oWzAtOVxcLl9dKykvXSxcbiAgICBbJ3ZpdmFsZGknLCAvVml2YWxkaVxcLyhbMC05XFwuXSspL10sXG4gICAgWydrYWthb3RhbGsnLCAvS0FLQU9UQUxLXFxzKFswLTlcXC5dKykvXSxcbiAgICBbJ3NhbXN1bmcnLCAvU2Ftc3VuZ0Jyb3dzZXJcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnc2lsaycsIC9cXGJTaWxrXFwvKFswLTkuXy1dKylcXGIvXSxcbiAgICBbJ21pdWknLCAvTWl1aUJyb3dzZXJcXC8oWzAtOVxcLl0rKSQvXSxcbiAgICBbJ2JlYWtlcicsIC9CZWFrZXJCcm93c2VyXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2VkZ2UtY2hyb21pdW0nLCAvRWRnXFwvKFswLTlcXC5dKykvXSxcbiAgICBbXG4gICAgICAgICdjaHJvbWl1bS13ZWJ2aWV3JyxcbiAgICAgICAgLyg/IUNocm9tLipPUFIpd3ZcXCkuKkNocm9tKD86ZXxpdW0pXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvLFxuICAgIF0sXG4gICAgWydjaHJvbWUnLCAvKD8hQ2hyb20uKk9QUilDaHJvbSg/OmV8aXVtKVxcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sXG4gICAgWydwaGFudG9tanMnLCAvUGhhbnRvbUpTXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgICBbJ2NyaW9zJywgL0NyaU9TXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgICBbJ2ZpcmVmb3gnLCAvRmlyZWZveFxcLyhbMC05XFwuXSspKD86XFxzfCQpL10sXG4gICAgWydmeGlvcycsIC9GeGlPU1xcLyhbMC05XFwuXSspL10sXG4gICAgWydvcGVyYS1taW5pJywgL09wZXJhIE1pbmkuKlZlcnNpb25cXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnb3BlcmEnLCAvT3BlcmFcXC8oWzAtOVxcLl0rKSg/Olxcc3wkKS9dLFxuICAgIFsnb3BlcmEnLCAvT1BSXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgICBbJ2llJywgL1RyaWRlbnRcXC83XFwuMC4qcnZcXDooWzAtOVxcLl0rKS4qXFwpLipHZWNrbyQvXSxcbiAgICBbJ2llJywgL01TSUVcXHMoWzAtOVxcLl0rKTsuKlRyaWRlbnRcXC9bNC03XS4wL10sXG4gICAgWydpZScsIC9NU0lFXFxzKDdcXC4wKS9dLFxuICAgIFsnYmIxMCcsIC9CQjEwO1xcc1RvdWNoLipWZXJzaW9uXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2FuZHJvaWQnLCAvQW5kcm9pZFxccyhbMC05XFwuXSspL10sXG4gICAgWydpb3MnLCAvVmVyc2lvblxcLyhbMC05XFwuX10rKS4qTW9iaWxlLipTYWZhcmkuKi9dLFxuICAgIFsnc2FmYXJpJywgL1ZlcnNpb25cXC8oWzAtOVxcLl9dKykuKlNhZmFyaS9dLFxuICAgIFsnZmFjZWJvb2snLCAvRkJBVlxcLyhbMC05XFwuXSspL10sXG4gICAgWydpbnN0YWdyYW0nLCAvSW5zdGFncmFtXFxzKFswLTlcXC5dKykvXSxcbiAgICBbJ2lvcy13ZWJ2aWV3JywgL0FwcGxlV2ViS2l0XFwvKFswLTlcXC5dKykuKk1vYmlsZS9dLFxuICAgIFsnaW9zLXdlYnZpZXcnLCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS4qR2Vja29cXCkkL10sXG4gICAgWydzZWFyY2hib3QnLCBTRUFSQ0hCT1hfVUFfUkVHRVhdLFxuXTtcbnZhciBvcGVyYXRpbmdTeXN0ZW1SdWxlcyA9IFtcbiAgICBbJ2lPUycsIC9pUChob25lfG9kfGFkKS9dLFxuICAgIFsnQW5kcm9pZCBPUycsIC9BbmRyb2lkL10sXG4gICAgWydCbGFja0JlcnJ5IE9TJywgL0JsYWNrQmVycnl8QkIxMC9dLFxuICAgIFsnV2luZG93cyBNb2JpbGUnLCAvSUVNb2JpbGUvXSxcbiAgICBbJ0FtYXpvbiBPUycsIC9LaW5kbGUvXSxcbiAgICBbJ1dpbmRvd3MgMy4xMScsIC9XaW4xNi9dLFxuICAgIFsnV2luZG93cyA5NScsIC8oV2luZG93cyA5NSl8KFdpbjk1KXwoV2luZG93c185NSkvXSxcbiAgICBbJ1dpbmRvd3MgOTgnLCAvKFdpbmRvd3MgOTgpfChXaW45OCkvXSxcbiAgICBbJ1dpbmRvd3MgMjAwMCcsIC8oV2luZG93cyBOVCA1LjApfChXaW5kb3dzIDIwMDApL10sXG4gICAgWydXaW5kb3dzIFhQJywgLyhXaW5kb3dzIE5UIDUuMSl8KFdpbmRvd3MgWFApL10sXG4gICAgWydXaW5kb3dzIFNlcnZlciAyMDAzJywgLyhXaW5kb3dzIE5UIDUuMikvXSxcbiAgICBbJ1dpbmRvd3MgVmlzdGEnLCAvKFdpbmRvd3MgTlQgNi4wKS9dLFxuICAgIFsnV2luZG93cyA3JywgLyhXaW5kb3dzIE5UIDYuMSkvXSxcbiAgICBbJ1dpbmRvd3MgOCcsIC8oV2luZG93cyBOVCA2LjIpL10sXG4gICAgWydXaW5kb3dzIDguMScsIC8oV2luZG93cyBOVCA2LjMpL10sXG4gICAgWydXaW5kb3dzIDEwJywgLyhXaW5kb3dzIE5UIDEwLjApL10sXG4gICAgWydXaW5kb3dzIE1FJywgL1dpbmRvd3MgTUUvXSxcbiAgICBbJ09wZW4gQlNEJywgL09wZW5CU0QvXSxcbiAgICBbJ1N1biBPUycsIC9TdW5PUy9dLFxuICAgIFsnQ2hyb21lIE9TJywgL0NyT1MvXSxcbiAgICBbJ0xpbnV4JywgLyhMaW51eCl8KFgxMSkvXSxcbiAgICBbJ01hYyBPUycsIC8oTWFjX1Bvd2VyUEMpfChNYWNpbnRvc2gpL10sXG4gICAgWydRTlgnLCAvUU5YL10sXG4gICAgWydCZU9TJywgL0JlT1MvXSxcbiAgICBbJ09TLzInLCAvT1NcXC8yL10sXG4gICAgWydTZWFyY2ggQm90JywgU0VBUkNIQk9UX09TX1JFR0VYXSxcbl07XG5mdW5jdGlvbiBkZXRlY3QodXNlckFnZW50KSB7XG4gICAgaWYgKCEhdXNlckFnZW50KSB7XG4gICAgICAgIHJldHVybiBwYXJzZVVzZXJBZ2VudCh1c2VyQWdlbnQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVXNlckFnZW50KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Tm9kZVZlcnNpb24oKTtcbn1cbmV4cG9ydHMuZGV0ZWN0ID0gZGV0ZWN0O1xuZnVuY3Rpb24gcGFyc2VVc2VyQWdlbnQodWEpIHtcbiAgICAvLyBvcHRlZCBmb3IgdXNpbmcgcmVkdWNlIGhlcmUgcmF0aGVyIHRoYW4gQXJyYXkjZmlyc3Qgd2l0aCBhIHJlZ2V4LnRlc3QgY2FsbFxuICAgIC8vIHRoaXMgaXMgcHJpbWFyaWx5IGJlY2F1c2UgdXNpbmcgdGhlIHJlZHVjZSB3ZSBvbmx5IHBlcmZvcm0gdGhlIHJlZ2V4XG4gICAgLy8gZXhlY3V0aW9uIG9uY2UgcmF0aGVyIHRoYW4gb25jZSBmb3IgdGhlIHRlc3QgYW5kIGZvciB0aGUgZXhlYyBhZ2FpbiBiZWxvd1xuICAgIC8vIHByb2JhYmx5IHNvbWV0aGluZyB0aGF0IG5lZWRzIHRvIGJlIGJlbmNobWFya2VkIHRob3VnaFxuICAgIHZhciBtYXRjaGVkUnVsZSA9IHVhICE9PSAnJyAmJlxuICAgICAgICB1c2VyQWdlbnRSdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKG1hdGNoZWQsIF9hKSB7XG4gICAgICAgICAgICB2YXIgYnJvd3NlciA9IF9hWzBdLCByZWdleCA9IF9hWzFdO1xuICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1YU1hdGNoID0gcmVnZXguZXhlYyh1YSk7XG4gICAgICAgICAgICByZXR1cm4gISF1YU1hdGNoICYmIFticm93c2VyLCB1YU1hdGNoXTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIGlmICghbWF0Y2hlZFJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBuYW1lID0gbWF0Y2hlZFJ1bGVbMF0sIG1hdGNoID0gbWF0Y2hlZFJ1bGVbMV07XG4gICAgaWYgKG5hbWUgPT09ICdzZWFyY2hib3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQm90SW5mbygpO1xuICAgIH1cbiAgICB2YXIgdmVyc2lvblBhcnRzID0gbWF0Y2hbMV0gJiYgbWF0Y2hbMV0uc3BsaXQoL1suX10vKS5zbGljZSgwLCAzKTtcbiAgICBpZiAodmVyc2lvblBhcnRzKSB7XG4gICAgICAgIGlmICh2ZXJzaW9uUGFydHMubGVuZ3RoIDwgUkVRVUlSRURfVkVSU0lPTl9QQVJUUykge1xuICAgICAgICAgICAgdmVyc2lvblBhcnRzID0gX19zcHJlYWRBcnJheXModmVyc2lvblBhcnRzLCBjcmVhdGVWZXJzaW9uUGFydHMoUkVRVUlSRURfVkVSU0lPTl9QQVJUUyAtIHZlcnNpb25QYXJ0cy5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmVyc2lvblBhcnRzID0gW107XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnJvd3NlckluZm8obmFtZSwgdmVyc2lvblBhcnRzLmpvaW4oJy4nKSwgZGV0ZWN0T1ModWEpKTtcbn1cbmV4cG9ydHMucGFyc2VVc2VyQWdlbnQgPSBwYXJzZVVzZXJBZ2VudDtcbmZ1bmN0aW9uIGRldGVjdE9TKHVhKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBjb3VudCA9IG9wZXJhdGluZ1N5c3RlbVJ1bGVzLmxlbmd0aDsgaWkgPCBjb3VudDsgaWkrKykge1xuICAgICAgICB2YXIgX2EgPSBvcGVyYXRpbmdTeXN0ZW1SdWxlc1tpaV0sIG9zID0gX2FbMF0sIHJlZ2V4ID0gX2FbMV07XG4gICAgICAgIHZhciBtYXRjaCA9IHJlZ2V4LnRlc3QodWEpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBvcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZGV0ZWN0T1MgPSBkZXRlY3RPUztcbmZ1bmN0aW9uIGdldE5vZGVWZXJzaW9uKCkge1xuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9uO1xuICAgIHJldHVybiBpc05vZGUgPyBuZXcgTm9kZUluZm8ocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDEpKSA6IG51bGw7XG59XG5leHBvcnRzLmdldE5vZGVWZXJzaW9uID0gZ2V0Tm9kZVZlcnNpb247XG5mdW5jdGlvbiBjcmVhdGVWZXJzaW9uUGFydHMoY291bnQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGNvdW50OyBpaSsrKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKCcwJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4iLCIvKiFcbiAgKiBkb21yZWFkeSAoYykgRHVzdGluIERpYXogMjAxNCAtIExpY2Vuc2UgTUlUXG4gICovXG4hZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnKSBkZWZpbmUoZGVmaW5pdGlvbilcbiAgZWxzZSB0aGlzW25hbWVdID0gZGVmaW5pdGlvbigpXG5cbn0oJ2RvbXJlYWR5JywgZnVuY3Rpb24gKCkge1xuXG4gIHZhciBmbnMgPSBbXSwgbGlzdGVuZXJcbiAgICAsIGRvYyA9IGRvY3VtZW50XG4gICAgLCBoYWNrID0gZG9jLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbFxuICAgICwgZG9tQ29udGVudExvYWRlZCA9ICdET01Db250ZW50TG9hZGVkJ1xuICAgICwgbG9hZGVkID0gKGhhY2sgPyAvXmxvYWRlZHxeYy8gOiAvXmxvYWRlZHxeaXxeYy8pLnRlc3QoZG9jLnJlYWR5U3RhdGUpXG5cblxuICBpZiAoIWxvYWRlZClcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoZG9tQ29udGVudExvYWRlZCwgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9tQ29udGVudExvYWRlZCwgbGlzdGVuZXIpXG4gICAgbG9hZGVkID0gMVxuICAgIHdoaWxlIChsaXN0ZW5lciA9IGZucy5zaGlmdCgpKSBsaXN0ZW5lcigpXG4gIH0pXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIGxvYWRlZCA/IHNldFRpbWVvdXQoZm4sIDApIDogZm5zLnB1c2goZm4pXG4gIH1cblxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHR5cGVkZWYge3sgW2tleTogc3RyaW5nXTogYW55IH19IEV4dGVuc2lvbnNcbiAqIEB0eXBlZGVmIHtFcnJvcn0gRXJyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZVxuICovXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IG9ialxuICogQHBhcmFtIHtFeHRlbnNpb25zfSBwcm9wc1xuICogQHJldHVybnMge0Vycm9yICYgRXh0ZW5zaW9uc31cbiAqL1xuZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiBwcm9wc1trZXldLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHthbnl9IGVyciAtIEFuIEVycm9yXG4gKiBAcGFyYW0ge3N0cmluZ3xFeHRlbnNpb25zfSBjb2RlIC0gQSBzdHJpbmcgY29kZSBvciBwcm9wcyB0byBzZXQgb24gdGhlIGVycm9yXG4gKiBAcGFyYW0ge0V4dGVuc2lvbnN9IFtwcm9wc10gLSBQcm9wcyB0byBzZXQgb24gdGhlIGVycm9yXG4gKiBAcmV0dXJucyB7RXJyb3IgJiBFeHRlbnNpb25zfVxuICovXG5mdW5jdGlvbiBjcmVhdGVFcnJvcihlcnIsIGNvZGUsIHByb3BzKSB7XG4gICAgaWYgKCFlcnIgfHwgdHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHBhc3MgYW4gRXJyb3IgdG8gZXJyLWNvZGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb2RlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBwcm9wcyA9IGNvZGU7XG4gICAgICAgIGNvZGUgPSAnJztcbiAgICB9XG5cbiAgICBpZiAoY29kZSkge1xuICAgICAgICBwcm9wcy5jb2RlID0gY29kZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXNzaWduKGVyciwgcHJvcHMpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgcHJvcHMubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgICBwcm9wcy5zdGFjayA9IGVyci5zdGFjaztcblxuICAgICAgICBjb25zdCBFcnJDbGFzcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgIEVyckNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGVycikpO1xuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXNzaWduKG5ldyBFcnJDbGFzcygpLCBwcm9wcyk7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRXJyb3I7XG4iLCIvKipcbiAqIEBhdXRob3IgVG9ydSBOYWdhc2hpbWEgPGh0dHBzOi8vZ2l0aHViLmNvbS9teXN0aWNhdGVhPlxuICogQGNvcHlyaWdodCAyMDE1IFRvcnUgTmFnYXNoaW1hLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU2VlIExJQ0VOU0UgZmlsZSBpbiByb290IGRpcmVjdG9yeSBmb3IgZnVsbCBsaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gUHJpdmF0ZURhdGFcbiAqIEBwcm9wZXJ0eSB7RXZlbnRUYXJnZXR9IGV2ZW50VGFyZ2V0IFRoZSBldmVudCB0YXJnZXQuXG4gKiBAcHJvcGVydHkge3t0eXBlOnN0cmluZ319IGV2ZW50IFRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZXZlbnRQaGFzZSBUaGUgY3VycmVudCBldmVudCBwaGFzZS5cbiAqIEBwcm9wZXJ0eSB7RXZlbnRUYXJnZXR8bnVsbH0gY3VycmVudFRhcmdldCBUaGUgY3VycmVudCBldmVudCB0YXJnZXQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhbmNlbGVkIFRoZSBmbGFnIHRvIHByZXZlbnQgZGVmYXVsdC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc3RvcHBlZCBUaGUgZmxhZyB0byBzdG9wIHByb3BhZ2F0aW9uIGltbWVkaWF0ZWx5LlxuICogQHByb3BlcnR5IHtGdW5jdGlvbnxudWxsfSBwYXNzaXZlTGlzdGVuZXIgVGhlIGxpc3RlbmVyIGlmIHRoZSBjdXJyZW50IGxpc3RlbmVyIGlzIHBhc3NpdmUuIE90aGVyd2lzZSB0aGlzIGlzIG51bGwuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZVN0YW1wIFRoZSB1bml4IHRpbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogUHJpdmF0ZSBkYXRhIGZvciBldmVudCB3cmFwcGVycy5cbiAqIEB0eXBlIHtXZWFrTWFwPEV2ZW50LCBQcml2YXRlRGF0YT59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBwcml2YXRlRGF0YSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQ2FjaGUgZm9yIHdyYXBwZXIgY2xhc3Nlcy5cbiAqIEB0eXBlIHtXZWFrTWFwPE9iamVjdCwgRnVuY3Rpb24+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgd3JhcHBlcnMgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIEdldCBwcml2YXRlIGRhdGEuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IHRvIGdldCBwcml2YXRlIGRhdGEuXG4gKiBAcmV0dXJucyB7UHJpdmF0ZURhdGF9IFRoZSBwcml2YXRlIGRhdGEgb2YgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGQoZXZlbnQpIHtcbiAgICBjb25zdCByZXR2ID0gcHJpdmF0ZURhdGEuZ2V0KGV2ZW50KTtcbiAgICBjb25zb2xlLmFzc2VydChyZXR2ICE9IG51bGwsIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50IG9iamVjdCwgYnV0IGdvdFwiLCBldmVudCk7XG4gICAgcmV0dXJuIHJldHZcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLWV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG4vKipcbiAqIFRoZSBldmVudCB3cmFwcGVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IG9mIHRoaXMgZGlzcGF0Y2hpbmcuXG4gKiBAcGFyYW0ge0V2ZW50fHt0eXBlOnN0cmluZ319IGV2ZW50IFRoZSBvcmlnaW5hbCBldmVudCB0byB3cmFwLlxuICovXG5mdW5jdGlvbiBFdmVudChldmVudFRhcmdldCwgZXZlbnQpIHtcbiAgICBwcml2YXRlRGF0YS5zZXQodGhpcywge1xuICAgICAgICBldmVudFRhcmdldCxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGV2ZW50UGhhc2U6IDIsXG4gICAgICAgIGN1cnJlbnRUYXJnZXQ6IGV2ZW50VGFyZ2V0LFxuICAgICAgICBjYW5jZWxlZDogZmFsc2UsXG4gICAgICAgIHN0b3BwZWQ6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlTGlzdGVuZXI6IG51bGwsXG4gICAgICAgIHRpbWVTdGFtcDogZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCksXG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNVbmZvcmdlYWJsZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzVHJ1c3RlZFwiLCB7IHZhbHVlOiBmYWxzZSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuICAgIC8vIERlZmluZSBhY2Nlc3NvcnNcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIShrZXkgaW4gdGhpcykpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gU2hvdWxkIGJlIGVudW1lcmFibGUsIGJ1dCBjbGFzcyBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZS5cbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudC50eXBlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAgZ2V0IHRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLmV2ZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0YXJnZXQgb2YgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5jdXJyZW50VGFyZ2V0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtFdmVudFRhcmdldFtdfSBUaGUgY29tcG9zZWQgcGF0aCBvZiB0aGlzIGV2ZW50LlxuICAgICAqL1xuICAgIGNvbXBvc2VkUGF0aCgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRhcmdldCA9IHBkKHRoaXMpLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3VycmVudFRhcmdldF1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgb2YgTk9ORS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBOT05FKCkge1xuICAgICAgICByZXR1cm4gMFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBDQVBUVVJJTkdfUEhBU0UuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQ0FQVFVSSU5HX1BIQVNFKCkge1xuICAgICAgICByZXR1cm4gMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBBVF9UQVJHRVQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgQVRfVEFSR0VUKCkge1xuICAgICAgICByZXR1cm4gMlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdGFudCBvZiBCVUJCTElOR19QSEFTRS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBCVUJCTElOR19QSEFTRSgpIHtcbiAgICAgICAgcmV0dXJuIDNcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRhcmdldCBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGV2ZW50UGhhc2UoKSB7XG4gICAgICAgIHJldHVybiBwZCh0aGlzKS5ldmVudFBoYXNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gcGQodGhpcyk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5zdG9wUHJvcGFnYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZGF0YS5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGV2ZW50IGJ1YmJsaW5nLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHBkKHRoaXMpO1xuXG4gICAgICAgIGRhdGEuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZGF0YS5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmxhZyB0byBiZSBidWJibGluZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgYnViYmxlcygpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuYnViYmxlcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gYmUgY2FuY2VsYWJsZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY2FuY2VsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGQodGhpcykuZXZlbnQuY2FuY2VsYWJsZSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoaXMgZXZlbnQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwZCh0aGlzKTtcbiAgICAgICAgaWYgKGRhdGEucGFzc2l2ZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkV2ZW50I3ByZXZlbnREZWZhdWx0KCkgd2FzIGNhbGxlZCBmcm9tIGEgcGFzc2l2ZSBsaXN0ZW5lcjpcIiwgZGF0YS5wYXNzaXZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhLmV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5jYW5jZWxlZCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5ldmVudC5wcmV2ZW50RGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkYXRhLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gaW5kaWNhdGUgY2FuY2VsbGF0aW9uIHN0YXRlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBkZWZhdWx0UHJldmVudGVkKCkge1xuICAgICAgICByZXR1cm4gcGQodGhpcykuY2FuY2VsZWRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGZsYWcgdG8gYmUgY29tcG9zZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGNvbXBvc2VkKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwZCh0aGlzKS5ldmVudC5jb21wb3NlZClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHVuaXggdGltZSBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHRpbWVTdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHBkKHRoaXMpLnRpbWVTdGFtcFxuICAgIH0sXG59O1xuXG4vLyBgY29uc3RydWN0b3JgIGlzIG5vdCBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBFdmVudCwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcblxuLy8gRW5zdXJlIGBldmVudCBpbnN0YW5jZW9mIHdpbmRvdy5FdmVudGAgaXMgYHRydWVgLlxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5FdmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFdmVudC5wcm90b3R5cGUsIHdpbmRvdy5FdmVudC5wcm90b3R5cGUpO1xuXG4gICAgLy8gTWFrZSBhc3NvY2lhdGlvbiBmb3Igd3JhcHBlcnMuXG4gICAgd3JhcHBlcnMuc2V0KHdpbmRvdy5FdmVudC5wcm90b3R5cGUsIEV2ZW50KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcmVkaXJlY3QgYSBnaXZlbiBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgUHJvcGVydHkgbmFtZSB0byBkZWZpbmUgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIHJlZGlyZWN0IHRoZSBwcm9wZXJ0eS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlZGlyZWN0RGVzY3JpcHRvcihrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGQodGhpcykuZXZlbnRba2V5XVxuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIHBkKHRoaXMpLmV2ZW50W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gY2FsbCBhIGdpdmVuIG1ldGhvZCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgUHJvcGVydHkgbmFtZSB0byBkZWZpbmUgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtQcm9wZXJ0eURlc2NyaXB0b3J9IFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIGNhbGwgdGhlIG1ldGhvZCBwcm9wZXJ0eS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUNhbGxEZXNjcmlwdG9yKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlKCkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBwZCh0aGlzKS5ldmVudDtcbiAgICAgICAgICAgIHJldHVybiBldmVudFtrZXldLmFwcGx5KGV2ZW50LCBhcmd1bWVudHMpXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogRGVmaW5lIG5ldyB3cmFwcGVyIGNsYXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQmFzZUV2ZW50IFRoZSBiYXNlIHdyYXBwZXIgY2xhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIHByb3RvdHlwZSBvZiB0aGUgb3JpZ2luYWwgZXZlbnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBkZWZpbmVkIHdyYXBwZXIgY2xhc3MuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZpbmVXcmFwcGVyKEJhc2VFdmVudCwgcHJvdG8pIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvdG8pO1xuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQmFzZUV2ZW50XG4gICAgfVxuXG4gICAgLyoqIEN1c3RvbUV2ZW50ICovXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnRUYXJnZXQsIGV2ZW50KSB7XG4gICAgICAgIEJhc2VFdmVudC5jYWxsKHRoaXMsIGV2ZW50VGFyZ2V0LCBldmVudCk7XG4gICAgfVxuXG4gICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlRXZlbnQucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBDdXN0b21FdmVudCwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgIH0pO1xuXG4gICAgLy8gRGVmaW5lIGFjY2Vzc29ycy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCEoa2V5IGluIEJhc2VFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywga2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGlzRnVuYyA9ICh0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICBDdXN0b21FdmVudC5wcm90b3R5cGUsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGlzRnVuYyA/IGRlZmluZUNhbGxEZXNjcmlwdG9yKGtleSkgOiBkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3Ioa2V5KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDdXN0b21FdmVudFxufVxuXG4vKipcbiAqIEdldCB0aGUgd3JhcHBlciBjbGFzcyBvZiBhIGdpdmVuIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgcHJvdG90eXBlIG9mIHRoZSBvcmlnaW5hbCBldmVudCB0byBnZXQgaXRzIHdyYXBwZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSB3cmFwcGVyIGNsYXNzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0V3JhcHBlcihwcm90bykge1xuICAgIGlmIChwcm90byA9PSBudWxsIHx8IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybiBFdmVudFxuICAgIH1cblxuICAgIGxldCB3cmFwcGVyID0gd3JhcHBlcnMuZ2V0KHByb3RvKTtcbiAgICBpZiAod3JhcHBlciA9PSBudWxsKSB7XG4gICAgICAgIHdyYXBwZXIgPSBkZWZpbmVXcmFwcGVyKGdldFdyYXBwZXIoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSksIHByb3RvKTtcbiAgICAgICAgd3JhcHBlcnMuc2V0KHByb3RvLCB3cmFwcGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXBwZXJcbn1cblxuLyoqXG4gKiBXcmFwIGEgZ2l2ZW4gZXZlbnQgdG8gbWFuYWdlbWVudCBhIGRpc3BhdGNoaW5nLlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZXZlbnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldCBvZiB0aGlzIGRpc3BhdGNoaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBldmVudCB0byB3cmFwLlxuICogQHJldHVybnMge0V2ZW50fSBUaGUgd3JhcHBlciBpbnN0YW5jZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHdyYXBFdmVudChldmVudFRhcmdldCwgZXZlbnQpIHtcbiAgICBjb25zdCBXcmFwcGVyID0gZ2V0V3JhcHBlcihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXZlbnQpKTtcbiAgICByZXR1cm4gbmV3IFdyYXBwZXIoZXZlbnRUYXJnZXQsIGV2ZW50KVxufVxuXG4vKipcbiAqIEdldCB0aGUgc3RvcHBlZCBmbGFnIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gZ2V0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBmbGFnIHRvIHN0b3AgcHJvcGFnYXRpb24gaW1tZWRpYXRlbHkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1N0b3BwZWQoZXZlbnQpIHtcbiAgICByZXR1cm4gcGQoZXZlbnQpLnN0b3BwZWRcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgZXZlbnQgcGhhc2Ugb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBzZXQgY3VycmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZXZlbnRQaGFzZSBOZXcgZXZlbnQgcGhhc2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldEV2ZW50UGhhc2UoZXZlbnQsIGV2ZW50UGhhc2UpIHtcbiAgICBwZChldmVudCkuZXZlbnRQaGFzZSA9IGV2ZW50UGhhc2U7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IHRhcmdldCBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHNldCBjdXJyZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8bnVsbH0gY3VycmVudFRhcmdldCBOZXcgY3VycmVudCB0YXJnZXQuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldEN1cnJlbnRUYXJnZXQoZXZlbnQsIGN1cnJlbnRUYXJnZXQpIHtcbiAgICBwZChldmVudCkuY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG59XG5cbi8qKlxuICogU2V0IGEgcGFzc2l2ZSBsaXN0ZW5lciBvZiBhIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIHNldCBjdXJyZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb258bnVsbH0gcGFzc2l2ZUxpc3RlbmVyIE5ldyBwYXNzaXZlIGxpc3RlbmVyLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRQYXNzaXZlTGlzdGVuZXIoZXZlbnQsIHBhc3NpdmVMaXN0ZW5lcikge1xuICAgIHBkKGV2ZW50KS5wYXNzaXZlTGlzdGVuZXIgPSBwYXNzaXZlTGlzdGVuZXI7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gTGlzdGVuZXJOb2RlXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICogQHByb3BlcnR5IHsxfDJ8M30gbGlzdGVuZXJUeXBlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhc3NpdmVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb25jZVxuICogQHByb3BlcnR5IHtMaXN0ZW5lck5vZGV8bnVsbH0gbmV4dFxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtXZWFrTWFwPG9iamVjdCwgTWFwPHN0cmluZywgTGlzdGVuZXJOb2RlPj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBsaXN0ZW5lcnNNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4vLyBMaXN0ZW5lciB0eXBlc1xuY29uc3QgQ0FQVFVSRSA9IDE7XG5jb25zdCBCVUJCTEUgPSAyO1xuY29uc3QgQVRUUklCVVRFID0gMztcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0IG9yIG5vdC5cbiAqIEBwYXJhbSB7YW55fSB4IFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB4ICE9PSBudWxsICYmIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiIC8vZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxufVxuXG4vKipcbiAqIEdldCBsaXN0ZW5lcnMuXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldmVudFRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IHRvIGdldC5cbiAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBMaXN0ZW5lck5vZGU+fSBUaGUgbGlzdGVuZXJzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2ZW50VGFyZ2V0KSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbGlzdGVuZXJzTWFwLmdldChldmVudFRhcmdldCk7XG4gICAgaWYgKGxpc3RlbmVycyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCIndGhpcycgaXMgZXhwZWN0ZWQgYW4gRXZlbnRUYXJnZXQgb2JqZWN0LCBidXQgZ290IGFub3RoZXIgdmFsdWUuXCIpXG4gICAgfVxuICAgIHJldHVybiBsaXN0ZW5lcnNcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIHRoZSBldmVudCBhdHRyaWJ1dGUgb2YgYSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gZ2V0IHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7UHJvcGVydHlEZXNjcmlwdG9yfSBUaGUgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUV2ZW50QXR0cmlidXRlRGVzY3JpcHRvcihldmVudE5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGxpc3RlbmVycy5nZXQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5saXN0ZW5lclR5cGUgPT09IEFUVFJJQlVURSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5saXN0ZW5lclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIiAmJiAhaXNPYmplY3QobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XG5cbiAgICAgICAgICAgIC8vIFRyYXZlcnNlIHRvIHRoZSB0YWlsIHdoaWxlIHJlbW92aW5nIG9sZCB2YWx1ZS5cbiAgICAgICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmxpc3RlbmVyVHlwZSA9PT0gQVRUUklCVVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Lm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbm9kZS5uZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIG5ldyB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChsaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lclR5cGU6IEFUVFJJQlVURSxcbiAgICAgICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNldChldmVudE5hbWUsIG5ld05vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB9XG59XG5cbi8qKlxuICogRGVmaW5lIGFuIGV2ZW50IGF0dHJpYnV0ZSAoZS5nLiBgZXZlbnRUYXJnZXQub25jbGlja2ApLlxuICogQHBhcmFtIHtPYmplY3R9IGV2ZW50VGFyZ2V0UHJvdG90eXBlIFRoZSBldmVudCB0YXJnZXQgcHJvdG90eXBlIHRvIGRlZmluZSBhbiBldmVudCBhdHRyYml0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgdG8gZGVmaW5lLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRlZmluZUV2ZW50QXR0cmlidXRlKGV2ZW50VGFyZ2V0UHJvdG90eXBlLCBldmVudE5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnRUYXJnZXRQcm90b3R5cGUsIGBvbiR7ZXZlbnROYW1lfWAsIGRlZmluZUV2ZW50QXR0cmlidXRlRGVzY3JpcHRvcihldmVudE5hbWUpKTtcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBjdXN0b20gRXZlbnRUYXJnZXQgd2l0aCBldmVudCBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZXZlbnROYW1lcyBFdmVudCBuYW1lcyBmb3IgZXZlbnQgYXR0cmlidXRlcy5cbiAqIEByZXR1cm5zIHtFdmVudFRhcmdldH0gVGhlIGN1c3RvbSBFdmVudFRhcmdldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUV2ZW50VGFyZ2V0KGV2ZW50TmFtZXMpIHtcbiAgICAvKiogQ3VzdG9tRXZlbnRUYXJnZXQgKi9cbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudFRhcmdldCgpIHtcbiAgICAgICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBDdXN0b21FdmVudFRhcmdldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogQ3VzdG9tRXZlbnRUYXJnZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcbiAgICB9KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBkZWZpbmVFdmVudEF0dHJpYnV0ZShDdXN0b21FdmVudFRhcmdldC5wcm90b3R5cGUsIGV2ZW50TmFtZXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBDdXN0b21FdmVudFRhcmdldFxufVxuXG4vKipcbiAqIEV2ZW50VGFyZ2V0LlxuICpcbiAqIC0gVGhpcyBpcyBjb25zdHJ1Y3RvciBpZiBubyBhcmd1bWVudHMuXG4gKiAtIFRoaXMgaXMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgQ3VzdG9tRXZlbnRUYXJnZXQgY29uc3RydWN0b3IgaWYgdGhlcmUgYXJlIGFyZ3VtZW50cy5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgY2xhc3MgQSBleHRlbmRzIEV2ZW50VGFyZ2V0IHt9XG4gKiAgICAgY2xhc3MgQiBleHRlbmRzIEV2ZW50VGFyZ2V0KFwibWVzc2FnZVwiKSB7fVxuICogICAgIGNsYXNzIEMgZXh0ZW5kcyBFdmVudFRhcmdldChcIm1lc3NhZ2VcIiwgXCJlcnJvclwiKSB7fVxuICogICAgIGNsYXNzIEQgZXh0ZW5kcyBFdmVudFRhcmdldChbXCJtZXNzYWdlXCIsIFwiZXJyb3JcIl0pIHt9XG4gKi9cbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIGxpc3RlbmVyc01hcC5zZXQodGhpcywgbmV3IE1hcCgpKTtcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQoYXJndW1lbnRzWzBdKVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0eXBlc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQodHlwZXMpXG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIilcbiAgICAvKmVzbGludC1lbmFibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbn1cblxuLy8gU2hvdWxkIGJlIGVudW1lcmFibGUsIGJ1dCBjbGFzcyBtZXRob2RzIGFyZSBub3QgZW51bWVyYWJsZS5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBBZGQgYSBnaXZlbiBsaXN0ZW5lciB0byB0aGlzIGV2ZW50IHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnx7Y2FwdHVyZT86Ym9vbGVhbixwYXNzaXZlPzpib29sZWFuLG9uY2U/OmJvb2xlYW59fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoaXMgbGlzdGVuZXIuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgbGlzdGVuZXIgd2FzIGFkZGVkIGFjdHVhbGx5LlxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiICYmICFpc09iamVjdChsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInbGlzdGVuZXInIHNob3VsZCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdC5cIilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uc0lzT2JqID0gaXNPYmplY3Qob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhcHR1cmUgPSBvcHRpb25zSXNPYmogPyBCb29sZWFuKG9wdGlvbnMuY2FwdHVyZSkgOiBCb29sZWFuKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsaXN0ZW5lclR5cGUgPSAoY2FwdHVyZSA/IENBUFRVUkUgOiBCVUJCTEUpO1xuICAgICAgICBjb25zdCBuZXdOb2RlID0ge1xuICAgICAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgICAgICBsaXN0ZW5lclR5cGUsXG4gICAgICAgICAgICBwYXNzaXZlOiBvcHRpb25zSXNPYmogJiYgQm9vbGVhbihvcHRpb25zLnBhc3NpdmUpLFxuICAgICAgICAgICAgb25jZTogb3B0aW9uc0lzT2JqICYmIEJvb2xlYW4ob3B0aW9ucy5vbmNlKSxcbiAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2V0IGl0IGFzIHRoZSBmaXJzdCBub2RlIGlmIHRoZSBmaXJzdCBub2RlIGlzIG51bGwuXG4gICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuc2V0KGV2ZW50TmFtZSwgbmV3Tm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhdmVyc2UgdG8gdGhlIHRhaWwgd2hpbGUgY2hlY2tpbmcgZHVwbGljYXRpb24uLlxuICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJiBub2RlLmxpc3RlbmVyVHlwZSA9PT0gbGlzdGVuZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIGlnbm9yZSBkdXBsaWNhdGlvbi5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBpdC5cbiAgICAgICAgcHJldi5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgZ2l2ZW4gbGlzdGVuZXIgZnJvbSB0aGlzIGV2ZW50IHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnx7Y2FwdHVyZT86Ym9vbGVhbixwYXNzaXZlPzpib29sZWFuLG9uY2U/OmJvb2xlYW59fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoaXMgbGlzdGVuZXIuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQgYWN0dWFsbHkuXG4gICAgICovXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IGlzT2JqZWN0KG9wdGlvbnMpID8gQm9vbGVhbihvcHRpb25zLmNhcHR1cmUpIDogQm9vbGVhbihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJUeXBlID0gKGNhcHR1cmUgPyBDQVBUVVJFIDogQlVCQkxFKTtcblxuICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiYgbm9kZS5saXN0ZW5lclR5cGUgPT09IGxpc3RlbmVyVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggYSBnaXZlbiBldmVudC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fHt0eXBlOnN0cmluZ319IGV2ZW50IFRoZSBldmVudCB0byBkaXNwYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYGZhbHNlYCBpZiBjYW5jZWxlZC5cbiAgICAgKi9cbiAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7IC8vZXNsaW50LWRpc2FibGUtbGluZSBjb21wbGV4aXR5XG4gICAgICAgIGlmIChldmVudCA9PSBudWxsIHx8IHR5cGVvZiBldmVudC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiXFxcImV2ZW50LnR5cGVcXFwiIHNob3VsZCBiZSBhIHN0cmluZy5cIilcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGxpc3RlbmVycyBhcmVuJ3QgcmVnaXN0ZXJlZCwgdGVybWluYXRlLlxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IGV2ZW50LnR5cGU7XG4gICAgICAgIGxldCBub2RlID0gbGlzdGVuZXJzLmdldChldmVudE5hbWUpO1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luY2Ugd2UgY2Fubm90IHJld3JpdGUgc2V2ZXJhbCBwcm9wZXJ0aWVzLCBzbyB3cmFwIG9iamVjdC5cbiAgICAgICAgY29uc3Qgd3JhcHBlZEV2ZW50ID0gd3JhcEV2ZW50KHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAvLyBUaGlzIGRvZXNuJ3QgcHJvY2VzcyBjYXB0dXJpbmcgcGhhc2UgYW5kIGJ1YmJsaW5nIHBoYXNlLlxuICAgICAgICAvLyBUaGlzIGlzbid0IHBhcnRpY2lwYXRpbmcgaW4gYSB0cmVlLlxuICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGxpc3RlbmVyIGlmIGl0J3Mgb25jZVxuICAgICAgICAgICAgaWYgKG5vZGUub25jZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zZXQoZXZlbnROYW1lLCBub2RlLm5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxsIHRoaXMgbGlzdGVuZXJcbiAgICAgICAgICAgIHNldFBhc3NpdmVMaXN0ZW5lcih3cmFwcGVkRXZlbnQsIChub2RlLnBhc3NpdmUgPyBub2RlLmxpc3RlbmVyIDogbnVsbCkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLmxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmxpc3RlbmVyLmNhbGwodGhpcywgd3JhcHBlZEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvKmVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKmVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubGlzdGVuZXJUeXBlICE9PSBBVFRSSUJVVEUgJiYgdHlwZW9mIG5vZGUubGlzdGVuZXIuaGFuZGxlRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG5vZGUubGlzdGVuZXIuaGFuZGxlRXZlbnQod3JhcHBlZEV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQnJlYWsgaWYgYGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbmAgd2FzIGNhbGxlZC5cbiAgICAgICAgICAgIGlmIChpc1N0b3BwZWQod3JhcHBlZEV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UGFzc2l2ZUxpc3RlbmVyKHdyYXBwZWRFdmVudCwgbnVsbCk7XG4gICAgICAgIHNldEV2ZW50UGhhc2Uod3JhcHBlZEV2ZW50LCAwKTtcbiAgICAgICAgc2V0Q3VycmVudFRhcmdldCh3cmFwcGVkRXZlbnQsIG51bGwpO1xuXG4gICAgICAgIHJldHVybiAhd3JhcHBlZEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWRcbiAgICB9LFxufTtcblxuLy8gYGNvbnN0cnVjdG9yYCBpcyBub3QgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFRhcmdldC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogRXZlbnRUYXJnZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG5cbi8vIEVuc3VyZSBgZXZlbnRUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnRUYXJnZXRgIGlzIGB0cnVlYC5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuRXZlbnRUYXJnZXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnRUYXJnZXQucHJvdG90eXBlLCB3aW5kb3cuRXZlbnRUYXJnZXQucHJvdG90eXBlKTtcbn1cblxuZXhwb3J0cy5kZWZpbmVFdmVudEF0dHJpYnV0ZSA9IGRlZmluZUV2ZW50QXR0cmlidXRlO1xuZXhwb3J0cy5FdmVudFRhcmdldCA9IEV2ZW50VGFyZ2V0O1xuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRUYXJnZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXRcbm1vZHVsZS5leHBvcnRzLkV2ZW50VGFyZ2V0ID0gbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRXZlbnRUYXJnZXRcbm1vZHVsZS5leHBvcnRzLmRlZmluZUV2ZW50QXR0cmlidXRlID0gZGVmaW5lRXZlbnRBdHRyaWJ1dGVcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50LXRhcmdldC1zaGltLmpzLm1hcFxuIiwiLy8gb3JpZ2luYWxseSBwdWxsZWQgb3V0IG9mIHNpbXBsZS1wZWVyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0QnJvd3NlclJUQyAoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsXG4gIHZhciB3cnRjID0ge1xuICAgIFJUQ1BlZXJDb25uZWN0aW9uOiBnbG9iYWxUaGlzLlJUQ1BlZXJDb25uZWN0aW9uIHx8IGdsb2JhbFRoaXMubW96UlRDUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgIGdsb2JhbFRoaXMud2Via2l0UlRDUGVlckNvbm5lY3Rpb24sXG4gICAgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uOiBnbG9iYWxUaGlzLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiB8fFxuICAgICAgZ2xvYmFsVGhpcy5tb3pSVENTZXNzaW9uRGVzY3JpcHRpb24gfHwgZ2xvYmFsVGhpcy53ZWJraXRSVENTZXNzaW9uRGVzY3JpcHRpb24sXG4gICAgUlRDSWNlQ2FuZGlkYXRlOiBnbG9iYWxUaGlzLlJUQ0ljZUNhbmRpZGF0ZSB8fCBnbG9iYWxUaGlzLm1velJUQ0ljZUNhbmRpZGF0ZSB8fFxuICAgICAgZ2xvYmFsVGhpcy53ZWJraXRSVENJY2VDYW5kaWRhdGVcbiAgfVxuICBpZiAoIXdydGMuUlRDUGVlckNvbm5lY3Rpb24pIHJldHVybiBudWxsXG4gIHJldHVybiB3cnRjXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVsKXtcblxuICAgIHZhciBpZHMgPSB7fTtcblxuICAgIGlmKCdzdHJpbmcnID09IHR5cGVvZiBlbCkgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbCk7XG5cbiAgICBpZighZWwpIGVsID0gZG9jdW1lbnQ7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSBlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpO1xuXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChjaGlsZHJlbiwgZnVuY3Rpb24oZSl7XG5cblx0aWYoZS5pZC5sZW5ndGggPiAwKXtcblxuXHQgICAgaWRzW2UuaWRdID0gZVxuXG5cdH1cblxuICAgIH0pXG5cbiAgICByZXR1cm4gaWRzXG5cbn1cbiIsIi8vIGdldFVzZXJNZWRpYSBoZWxwZXIgYnkgQEhlbnJpa0pvcmV0ZWcgdXNlZCBmb3IgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSBzaGltXG52YXIgYWRhcHRlciA9IHJlcXVpcmUoJ3dlYnJ0Yy1hZGFwdGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzLCBjYikge1xuICAgIHZhciBlcnJvcjtcbiAgICB2YXIgaGF2ZU9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAyO1xuICAgIHZhciBkZWZhdWx0T3B0cyA9IHt2aWRlbzogdHJ1ZSwgYXVkaW86IHRydWV9O1xuXG4gICAgdmFyIGRlbmllZCA9ICdQZXJtaXNzaW9uRGVuaWVkRXJyb3InO1xuICAgIHZhciBhbHREZW5pZWQgPSAnUEVSTUlTU0lPTl9ERU5JRUQnO1xuICAgIHZhciBub3RTYXRpc2ZpZWQgPSAnQ29uc3RyYWludE5vdFNhdGlzZmllZEVycm9yJztcblxuICAgIC8vIG1ha2UgY29uc3RyYWludHMgb3B0aW9uYWxcbiAgICBpZiAoIWhhdmVPcHRzKSB7XG4gICAgICAgIGNiID0gY29uc3RyYWludHM7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gZGVmYXVsdE9wdHM7XG4gICAgfVxuXG4gICAgLy8gdHJlYXQgbGFjayBvZiBicm93c2VyIHN1cHBvcnQgbGlrZSBhbiBlcnJvclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyl7IC8vZ2V0VXNlck1lZGlhKSB7XG4gICAgICAgIC8vIHRocm93IHByb3BlciBlcnJvciBwZXIgc3BlY1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTWVkaWFTdHJlYW1FcnJvcicpO1xuICAgICAgICBlcnJvci5uYW1lID0gJ05vdFN1cHBvcnRlZEVycm9yJztcblxuICAgICAgICAvLyBrZWVwIGFsbCBjYWxsYmFja3MgYXN5bmNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgZXJyb3IgaGFuZGxpbmcgd2hlbiBubyBtZWRpYSB0eXBlcyBhcmUgcmVxdWVzdGVkXG4gICAgaWYgKCFjb25zdHJhaW50cy5hdWRpbyAmJiAhY29uc3RyYWludHMudmlkZW8pIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01lZGlhU3RyZWFtRXJyb3InKTtcbiAgICAgICAgZXJyb3IubmFtZSA9ICdOb01lZGlhUmVxdWVzdGVkRXJyb3InO1xuXG4gICAgICAgIC8vIGtlZXAgYWxsIGNhbGxiYWNrcyBhc3luY1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuICAgIC50aGVuKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgY2IobnVsbCwgc3RyZWFtKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gY29lcmNlIGludG8gYW4gZXJyb3Igb2JqZWN0IHNpbmNlIEZGIGdpdmVzIHVzIGEgc3RyaW5nXG4gICAgICAgIC8vIHRoZXJlIGFyZSBvbmx5IHR3byB2YWxpZCBuYW1lcyBhY2NvcmRpbmcgdG8gdGhlIHNwZWNcbiAgICAgICAgLy8gd2UgY29lcmNlIGFsbCBub24tZGVuaWVkIHRvIFwiY29uc3RyYWludCBub3Qgc2F0aXNmaWVkXCIuXG4gICAgICAgIGlmICh0eXBlb2YgZXJyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01lZGlhU3RyZWFtRXJyb3InKTtcbiAgICAgICAgICAgIGlmIChlcnIgPT09IGRlbmllZCB8fCBlcnIgPT09IGFsdERlbmllZCkge1xuICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBkZW5pZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBub3RTYXRpc2ZpZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBnZXQgYW4gZXJyb3Igb2JqZWN0IG1ha2Ugc3VyZSAnLm5hbWUnIHByb3BlcnR5IGlzIHNldFxuICAgICAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHNwZWM6IGh0dHA6Ly9kZXYudzMub3JnLzIwMTEvd2VicnRjL2VkaXRvci9nZXR1c2VybWVkaWEuaHRtbCNuYXZpZ2F0b3J1c2VybWVkaWFlcnJvci1hbmQtbmF2aWdhdG9ydXNlcm1lZGlhZXJyb3JjYWxsYmFja1xuICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICBpZiAoIWVycm9yLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGxpa2VseSBjaHJvbWUgd2hpY2hcbiAgICAgICAgICAgICAgICAvLyBzZXRzIGEgcHJvcGVydHkgY2FsbGVkIFwiRVJST1JfREVOSUVEXCIgb24gdGhlIGVycm9yIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGlmIHNvIHdlIG1ha2Ugc3VyZSB0byBzZXQgYSBuYW1lXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yW2RlbmllZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLm5hbWUgPSBkZW5pZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyLm5hbWUgPSBub3RTYXRpc2ZpZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgIH0pO1xufTtcbiIsInZhciBzcGxpdCA9IHJlcXVpcmUoJ2Jyb3dzZXItc3BsaXQnKVxudmFyIENsYXNzTGlzdCA9IHJlcXVpcmUoJ2NsYXNzLWxpc3QnKVxuXG52YXIgdyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gcmVxdWlyZSgnaHRtbC1lbGVtZW50JykgOiB3aW5kb3dcbnZhciBkb2N1bWVudCA9IHcuZG9jdW1lbnRcbnZhciBUZXh0ID0gdy5UZXh0XG5cbmZ1bmN0aW9uIGNvbnRleHQgKCkge1xuXG4gIHZhciBjbGVhbnVwRnVuY3MgPSBbXVxuXG4gIGZ1bmN0aW9uIGgoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGUgPSBudWxsXG4gICAgZnVuY3Rpb24gaXRlbSAobCkge1xuICAgICAgdmFyIHJcbiAgICAgIGZ1bmN0aW9uIHBhcnNlQ2xhc3MgKHN0cmluZykge1xuICAgICAgICAvLyBPdXIgbWluaW1hbCBwYXJzZXIgZG9lc27igJl0IHVuZGVyc3RhbmQgZXNjYXBpbmcgQ1NTIHNwZWNpYWxcbiAgICAgICAgLy8gY2hhcmFjdGVycyBsaWtlIGAjYC4gRG9u4oCZdCB1c2UgdGhlbS4gTW9yZSByZWFkaW5nOlxuICAgICAgICAvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvY3NzLWVzY2FwZXMgLlxuXG4gICAgICAgIHZhciBtID0gc3BsaXQoc3RyaW5nLCAvKFtcXC4jXT9bXlxccyMuXSspLylcbiAgICAgICAgaWYoL15cXC58Iy8udGVzdChtWzFdKSlcbiAgICAgICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgZm9yRWFjaChtLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgIHZhciBzID0gdi5zdWJzdHJpbmcoMSx2Lmxlbmd0aClcbiAgICAgICAgICBpZighdikgcmV0dXJuXG4gICAgICAgICAgaWYoIWUpXG4gICAgICAgICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh2KVxuICAgICAgICAgIGVsc2UgaWYgKHZbMF0gPT09ICcuJylcbiAgICAgICAgICAgIENsYXNzTGlzdChlKS5hZGQocylcbiAgICAgICAgICBlbHNlIGlmICh2WzBdID09PSAnIycpXG4gICAgICAgICAgICBlLnNldEF0dHJpYnV0ZSgnaWQnLCBzKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZihsID09IG51bGwpXG4gICAgICAgIDtcbiAgICAgIGVsc2UgaWYoJ3N0cmluZycgPT09IHR5cGVvZiBsKSB7XG4gICAgICAgIGlmKCFlKVxuICAgICAgICAgIHBhcnNlQ2xhc3MobClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGwpKVxuICAgICAgfVxuICAgICAgZWxzZSBpZignbnVtYmVyJyA9PT0gdHlwZW9mIGxcbiAgICAgICAgfHwgJ2Jvb2xlYW4nID09PSB0eXBlb2YgbFxuICAgICAgICB8fCBsIGluc3RhbmNlb2YgRGF0ZVxuICAgICAgICB8fCBsIGluc3RhbmNlb2YgUmVnRXhwICkge1xuICAgICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGwudG9TdHJpbmcoKSkpXG4gICAgICB9XG4gICAgICAvL3RoZXJlIG1pZ2h0IGJlIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuICAgICAgZWxzZSBpZiAoaXNBcnJheShsKSlcbiAgICAgICAgZm9yRWFjaChsLCBpdGVtKVxuICAgICAgZWxzZSBpZihpc05vZGUobCkpXG4gICAgICAgIGUuYXBwZW5kQ2hpbGQociA9IGwpXG4gICAgICBlbHNlIGlmKGwgaW5zdGFuY2VvZiBUZXh0KVxuICAgICAgICBlLmFwcGVuZENoaWxkKHIgPSBsKVxuICAgICAgZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGVvZiBsKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gbCkge1xuICAgICAgICAgIGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiBsW2tdKSB7XG4gICAgICAgICAgICBpZigvXm9uXFx3Ky8udGVzdChrKSkge1xuICAgICAgICAgICAgICAoZnVuY3Rpb24gKGssIGwpIHsgLy8gY2FwdHVyZSBrLCBsIGluIHRoZSBjbG9zdXJlXG4gICAgICAgICAgICAgICAgaWYgKGUuYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgICAgICAgICAgICAgICBlLmFkZEV2ZW50TGlzdGVuZXIoay5zdWJzdHJpbmcoMiksIGxba10sIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgY2xlYW51cEZ1bmNzLnB1c2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgZS5yZW1vdmVFdmVudExpc3RlbmVyKGsuc3Vic3RyaW5nKDIpLCBsW2tdLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICBlLmF0dGFjaEV2ZW50KGssIGxba10pXG4gICAgICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBlLmRldGFjaEV2ZW50KGssIGxba10pXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkoaywgbClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG9ic2VydmFibGVcbiAgICAgICAgICAgICAgZVtrXSA9IGxba10oKVxuICAgICAgICAgICAgICBjbGVhbnVwRnVuY3MucHVzaChsW2tdKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgZVtrXSA9IHZcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYoayA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgaWYoJ3N0cmluZycgPT09IHR5cGVvZiBsW2tdKSB7XG4gICAgICAgICAgICAgIGUuc3R5bGUuY3NzVGV4dCA9IGxba11cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBmb3IgKHZhciBzIGluIGxba10pIChmdW5jdGlvbihzLCB2KSB7XG4gICAgICAgICAgICAgICAgaWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIG9ic2VydmFibGVcbiAgICAgICAgICAgICAgICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocywgdigpKVxuICAgICAgICAgICAgICAgICAgY2xlYW51cEZ1bmNzLnB1c2godihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocywgdmFsKVxuICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsW2tdW3NdLm1hdGNoKC8oLiopXFxXKyFpbXBvcnRhbnRcXFcqJC8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuc3R5bGUuc2V0UHJvcGVydHkocywgbWF0Y2hbMV0sICdpbXBvcnRhbnQnKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eShzLCBsW2tdW3NdKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KShzLCBsW2tdW3NdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZihrID09PSAnYXR0cnMnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2IGluIGxba10pIHtcbiAgICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUodiwgbFtrXVt2XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoay5zdWJzdHIoMCwgNSkgPT09IFwiZGF0YS1cIikge1xuICAgICAgICAgICAgZS5zZXRBdHRyaWJ1dGUoaywgbFtrXSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZVtrXSA9IGxba11cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGwpIHtcbiAgICAgICAgLy9hc3N1bWUgaXQncyBhbiBvYnNlcnZhYmxlIVxuICAgICAgICB2YXIgdiA9IGwoKVxuICAgICAgICBlLmFwcGVuZENoaWxkKHIgPSBpc05vZGUodikgPyB2IDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodikpXG5cbiAgICAgICAgY2xlYW51cEZ1bmNzLnB1c2gobChmdW5jdGlvbiAodikge1xuICAgICAgICAgIGlmKGlzTm9kZSh2KSAmJiByLnBhcmVudEVsZW1lbnQpXG4gICAgICAgICAgICByLnBhcmVudEVsZW1lbnQucmVwbGFjZUNoaWxkKHYsIHIpLCByID0gdlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHIudGV4dENvbnRlbnQgPSB2XG4gICAgICAgIH0pKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gclxuICAgIH1cbiAgICB3aGlsZShhcmdzLmxlbmd0aClcbiAgICAgIGl0ZW0oYXJncy5zaGlmdCgpKVxuXG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIGguY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsZWFudXBGdW5jcy5sZW5ndGg7IGkrKyl7XG4gICAgICBjbGVhbnVwRnVuY3NbaV0oKVxuICAgIH1cbiAgICBjbGVhbnVwRnVuY3MubGVuZ3RoID0gMFxuICB9XG5cbiAgcmV0dXJuIGhcbn1cblxudmFyIGggPSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRleHQoKVxuaC5jb250ZXh0ID0gY29udGV4dFxuXG5mdW5jdGlvbiBpc05vZGUgKGVsKSB7XG4gIHJldHVybiBlbCAmJiBlbC5ub2RlTmFtZSAmJiBlbC5ub2RlVHlwZVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoIChhcnIsIGZuKSB7XG4gIGlmIChhcnIuZm9yRWFjaCkgcmV0dXJuIGFyci5mb3JFYWNoKGZuKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgZm4oYXJyW2ldLCBpKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSdcbn1cblxuXG4iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07IiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJncywgb3B0cykge1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgIFxuICAgIHZhciBmbGFncyA9IHsgYm9vbHMgOiB7fSwgc3RyaW5ncyA6IHt9LCB1bmtub3duRm46IG51bGwgfTtcblxuICAgIGlmICh0eXBlb2Ygb3B0c1sndW5rbm93biddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZsYWdzLnVua25vd25GbiA9IG9wdHNbJ3Vua25vd24nXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHNbJ2Jvb2xlYW4nXSA9PT0gJ2Jvb2xlYW4nICYmIG9wdHNbJ2Jvb2xlYW4nXSkge1xuICAgICAgZmxhZ3MuYWxsQm9vbHMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBbXS5jb25jYXQob3B0c1snYm9vbGVhbiddKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgZmxhZ3MuYm9vbHNba2V5XSA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhvcHRzLmFsaWFzIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgYWxpYXNlc1trZXldID0gW10uY29uY2F0KG9wdHMuYWxpYXNba2V5XSk7XG4gICAgICAgIGFsaWFzZXNba2V5XS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBhbGlhc2VzW3hdID0gW2tleV0uY29uY2F0KGFsaWFzZXNba2V5XS5maWx0ZXIoZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geCAhPT0geTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBbXS5jb25jYXQob3B0cy5zdHJpbmcpLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZmxhZ3Muc3RyaW5nc1trZXldID0gdHJ1ZTtcbiAgICAgICAgaWYgKGFsaWFzZXNba2V5XSkge1xuICAgICAgICAgICAgZmxhZ3Muc3RyaW5nc1thbGlhc2VzW2tleV1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICB9KTtcblxuICAgIHZhciBkZWZhdWx0cyA9IG9wdHNbJ2RlZmF1bHQnXSB8fCB7fTtcbiAgICBcbiAgICB2YXIgYXJndiA9IHsgXyA6IFtdIH07XG4gICAgT2JqZWN0LmtleXMoZmxhZ3MuYm9vbHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBzZXRBcmcoa2V5LCBkZWZhdWx0c1trZXldID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGRlZmF1bHRzW2tleV0pO1xuICAgIH0pO1xuICAgIFxuICAgIHZhciBub3RGbGFncyA9IFtdO1xuXG4gICAgaWYgKGFyZ3MuaW5kZXhPZignLS0nKSAhPT0gLTEpIHtcbiAgICAgICAgbm90RmxhZ3MgPSBhcmdzLnNsaWNlKGFyZ3MuaW5kZXhPZignLS0nKSsxKTtcbiAgICAgICAgYXJncyA9IGFyZ3Muc2xpY2UoMCwgYXJncy5pbmRleE9mKCctLScpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcmdEZWZpbmVkKGtleSwgYXJnKSB7XG4gICAgICAgIHJldHVybiAoZmxhZ3MuYWxsQm9vbHMgJiYgL14tLVtePV0rJC8udGVzdChhcmcpKSB8fFxuICAgICAgICAgICAgZmxhZ3Muc3RyaW5nc1trZXldIHx8IGZsYWdzLmJvb2xzW2tleV0gfHwgYWxpYXNlc1trZXldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEFyZyAoa2V5LCB2YWwsIGFyZykge1xuICAgICAgICBpZiAoYXJnICYmIGZsYWdzLnVua25vd25GbiAmJiAhYXJnRGVmaW5lZChrZXksIGFyZykpIHtcbiAgICAgICAgICAgIGlmIChmbGFncy51bmtub3duRm4oYXJnKSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9ICFmbGFncy5zdHJpbmdzW2tleV0gJiYgaXNOdW1iZXIodmFsKVxuICAgICAgICAgICAgPyBOdW1iZXIodmFsKSA6IHZhbFxuICAgICAgICA7XG4gICAgICAgIHNldEtleShhcmd2LCBrZXkuc3BsaXQoJy4nKSwgdmFsdWUpO1xuICAgICAgICBcbiAgICAgICAgKGFsaWFzZXNba2V5XSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgc2V0S2V5KGFyZ3YsIHguc3BsaXQoJy4nKSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRLZXkgKG9iaiwga2V5cywgdmFsdWUpIHtcbiAgICAgICAgdmFyIG8gPSBvYmo7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSByZXR1cm47XG4gICAgICAgICAgICBpZiAob1trZXldID09PSB1bmRlZmluZWQpIG9ba2V5XSA9IHt9O1xuICAgICAgICAgICAgaWYgKG9ba2V5XSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBvW2tleV0gPT09IE51bWJlci5wcm90b3R5cGVcbiAgICAgICAgICAgICAgICB8fCBvW2tleV0gPT09IFN0cmluZy5wcm90b3R5cGUpIG9ba2V5XSA9IHt9O1xuICAgICAgICAgICAgaWYgKG9ba2V5XSA9PT0gQXJyYXkucHJvdG90eXBlKSBvW2tleV0gPSBbXTtcbiAgICAgICAgICAgIG8gPSBvW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5ID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykgcmV0dXJuO1xuICAgICAgICBpZiAobyA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBvID09PSBOdW1iZXIucHJvdG90eXBlXG4gICAgICAgICAgICB8fCBvID09PSBTdHJpbmcucHJvdG90eXBlKSBvID0ge307XG4gICAgICAgIGlmIChvID09PSBBcnJheS5wcm90b3R5cGUpIG8gPSBbXTtcbiAgICAgICAgaWYgKG9ba2V5XSA9PT0gdW5kZWZpbmVkIHx8IGZsYWdzLmJvb2xzW2tleV0gfHwgdHlwZW9mIG9ba2V5XSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ba2V5XSkpIHtcbiAgICAgICAgICAgIG9ba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ba2V5XSA9IFsgb1trZXldLCB2YWx1ZSBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGFsaWFzSXNCb29sZWFuKGtleSkge1xuICAgICAgcmV0dXJuIGFsaWFzZXNba2V5XS5zb21lKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIGZsYWdzLmJvb2xzW3hdO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhcmcgPSBhcmdzW2ldO1xuICAgICAgICBcbiAgICAgICAgaWYgKC9eLS0uKz0vLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgLy8gVXNpbmcgW1xcc1xcU10gaW5zdGVhZCBvZiAuIGJlY2F1c2UganMgZG9lc24ndCBzdXBwb3J0IHRoZVxuICAgICAgICAgICAgLy8gJ2RvdGFsbCcgcmVnZXggbW9kaWZpZXIuIFNlZTpcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwNjgzMDgvMTMyMTZcbiAgICAgICAgICAgIHZhciBtID0gYXJnLm1hdGNoKC9eLS0oW149XSspPShbXFxzXFxTXSopJC8pO1xuICAgICAgICAgICAgdmFyIGtleSA9IG1bMV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBtWzJdO1xuICAgICAgICAgICAgaWYgKGZsYWdzLmJvb2xzW2tleV0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICE9PSAnZmFsc2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0QXJnKGtleSwgdmFsdWUsIGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14tLW5vLS4rLy50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBhcmcubWF0Y2goL14tLW5vLSguKykvKVsxXTtcbiAgICAgICAgICAgIHNldEFyZyhrZXksIGZhbHNlLCBhcmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eLS0uKy8udGVzdChhcmcpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gYXJnLm1hdGNoKC9eLS0oLispLylbMV07XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGFyZ3NbaSArIDFdO1xuICAgICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCAmJiAhL14tLy50ZXN0KG5leHQpXG4gICAgICAgICAgICAmJiAhZmxhZ3MuYm9vbHNba2V5XVxuICAgICAgICAgICAgJiYgIWZsYWdzLmFsbEJvb2xzXG4gICAgICAgICAgICAmJiAoYWxpYXNlc1trZXldID8gIWFsaWFzSXNCb29sZWFuKGtleSkgOiB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIG5leHQsIGFyZyk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoL14odHJ1ZXxmYWxzZSkkLy50ZXN0KG5leHQpKSB7XG4gICAgICAgICAgICAgICAgc2V0QXJnKGtleSwgbmV4dCA9PT0gJ3RydWUnLCBhcmcpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIGZsYWdzLnN0cmluZ3Nba2V5XSA/ICcnIDogdHJ1ZSwgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXi1bXi1dKy8udGVzdChhcmcpKSB7XG4gICAgICAgICAgICB2YXIgbGV0dGVycyA9IGFyZy5zbGljZSgxLC0xKS5zcGxpdCgnJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBicm9rZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGV0dGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gYXJnLnNsaWNlKGorMik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgbmV4dCwgYXJnKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKC9bQS1aYS16XS8udGVzdChsZXR0ZXJzW2pdKSAmJiAvPS8udGVzdChuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcobGV0dGVyc1tqXSwgbmV4dC5zcGxpdCgnPScpWzFdLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICBicm9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKC9bQS1aYS16XS8udGVzdChsZXR0ZXJzW2pdKVxuICAgICAgICAgICAgICAgICYmIC8tP1xcZCsoXFwuXFxkKik/KGUtP1xcZCspPyQvLnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIG5leHQsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobGV0dGVyc1tqKzFdICYmIGxldHRlcnNbaisxXS5tYXRjaCgvXFxXLykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIGFyZy5zbGljZShqKzIpLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICBicm9rZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBmbGFncy5zdHJpbmdzW2xldHRlcnNbal1dID8gJycgOiB0cnVlLCBhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGtleSA9IGFyZy5zbGljZSgtMSlbMF07XG4gICAgICAgICAgICBpZiAoIWJyb2tlbiAmJiBrZXkgIT09ICctJykge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzW2krMV0gJiYgIS9eKC18LS0pW14tXS8udGVzdChhcmdzW2krMV0pXG4gICAgICAgICAgICAgICAgJiYgIWZsYWdzLmJvb2xzW2tleV1cbiAgICAgICAgICAgICAgICAmJiAoYWxpYXNlc1trZXldID8gIWFsaWFzSXNCb29sZWFuKGtleSkgOiB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBhcmdzW2krMV0sIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnc1tpKzFdICYmIC9eKHRydWV8ZmFsc2UpJC8udGVzdChhcmdzW2krMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFyZyhrZXksIGFyZ3NbaSsxXSA9PT0gJ3RydWUnLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRBcmcoa2V5LCBmbGFncy5zdHJpbmdzW2tleV0gPyAnJyA6IHRydWUsIGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFmbGFncy51bmtub3duRm4gfHwgZmxhZ3MudW5rbm93bkZuKGFyZykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYXJndi5fLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnN0cmluZ3NbJ18nXSB8fCAhaXNOdW1iZXIoYXJnKSA/IGFyZyA6IE51bWJlcihhcmcpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLnN0b3BFYXJseSkge1xuICAgICAgICAgICAgICAgIGFyZ3YuXy5wdXNoLmFwcGx5KGFyZ3YuXywgYXJncy5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIE9iamVjdC5rZXlzKGRlZmF1bHRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFoYXNLZXkoYXJndiwga2V5LnNwbGl0KCcuJykpKSB7XG4gICAgICAgICAgICBzZXRLZXkoYXJndiwga2V5LnNwbGl0KCcuJyksIGRlZmF1bHRzW2tleV0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAoYWxpYXNlc1trZXldIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgc2V0S2V5KGFyZ3YsIHguc3BsaXQoJy4nKSwgZGVmYXVsdHNba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGlmIChvcHRzWyctLSddKSB7XG4gICAgICAgIGFyZ3ZbJy0tJ10gPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgbm90RmxhZ3MuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGFyZ3ZbJy0tJ10ucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vdEZsYWdzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBhcmd2Ll8ucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJndjtcbn07XG5cbmZ1bmN0aW9uIGhhc0tleSAob2JqLCBrZXlzKSB7XG4gICAgdmFyIG8gPSBvYmo7XG4gICAga2V5cy5zbGljZSgwLC0xKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgbyA9IChvW2tleV0gfHwge30pO1xuICAgIH0pO1xuXG4gICAgdmFyIGtleSA9IGtleXNba2V5cy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4ga2V5IGluIG87XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyICh4KSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykgcmV0dXJuIHRydWU7XG4gICAgaWYgKC9eMHhbMC05YS1mXSskL2kudGVzdCh4KSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIC9eWy0rXT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKGVbLStdP1xcZCspPyQvLnRlc3QoeCk7XG59XG5cbiIsIlxuJ3VzZSBzdHJpY3QnXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2J4LmNqcy5wcm9kdWN0aW9uLm1pbi5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbW9ieC5janMuZGV2ZWxvcG1lbnQuanMnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbmljZUVycm9ycyA9IHtcbiAgMDogXCJJbnZhbGlkIHZhbHVlIGZvciBjb25maWd1cmF0aW9uICdlbmZvcmNlQWN0aW9ucycsIGV4cGVjdGVkICduZXZlcicsICdhbHdheXMnIG9yICdvYnNlcnZlZCdcIixcbiAgMTogZnVuY3Rpb24gXyhhbm5vdGF0aW9uVHlwZSwga2V5KSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IGFwcGx5ICdcIiArIGFubm90YXRpb25UeXBlICsgXCInIHRvICdcIiArIGtleS50b1N0cmluZygpICsgXCInOiBGaWVsZCBub3QgZm91bmQuXCI7XG4gIH0sXG5cbiAgLypcclxuICAyKHByb3ApIHtcclxuICAgICAgcmV0dXJuIGBpbnZhbGlkIGRlY29yYXRvciBmb3IgJyR7cHJvcC50b1N0cmluZygpfSdgXHJcbiAgfSxcclxuICAzKHByb3ApIHtcclxuICAgICAgcmV0dXJuIGBDYW5ub3QgZGVjb3JhdGUgJyR7cHJvcC50b1N0cmluZygpfSc6IGFjdGlvbiBjYW4gb25seSBiZSB1c2VkIG9uIHByb3BlcnRpZXMgd2l0aCBhIGZ1bmN0aW9uIHZhbHVlLmBcclxuICB9LFxyXG4gIDQocHJvcCkge1xyXG4gICAgICByZXR1cm4gYENhbm5vdCBkZWNvcmF0ZSAnJHtwcm9wLnRvU3RyaW5nKCl9JzogY29tcHV0ZWQgY2FuIG9ubHkgYmUgdXNlZCBvbiBnZXR0ZXIgcHJvcGVydGllcy5gXHJcbiAgfSxcclxuICAqL1xuICA1OiBcIidrZXlzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMsIHNldHMgYW5kIG1hcHNcIixcbiAgNjogXCIndmFsdWVzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMsIHNldHMgYW5kIG1hcHNcIixcbiAgNzogXCInZW50cmllcygpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDg6IFwiJ3NldCgpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDk6IFwiJ3JlbW92ZSgpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0cywgYXJyYXlzIGFuZCBtYXBzXCIsXG4gIDEwOiBcIidoYXMoKScgY2FuIG9ubHkgYmUgdXNlZCBvbiBvYnNlcnZhYmxlIG9iamVjdHMsIGFycmF5cyBhbmQgbWFwc1wiLFxuICAxMTogXCInZ2V0KCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIG1hcHNcIixcbiAgMTI6IFwiSW52YWxpZCBhbm5vdGF0aW9uXCIsXG4gIDEzOiBcIkR5bmFtaWMgb2JzZXJ2YWJsZSBvYmplY3RzIGNhbm5vdCBiZSBmcm96ZW5cIixcbiAgMTQ6IFwiSW50ZXJjZXB0IGhhbmRsZXJzIHNob3VsZCByZXR1cm4gbm90aGluZyBvciBhIGNoYW5nZSBvYmplY3RcIixcbiAgMTU6IFwiT2JzZXJ2YWJsZSBhcnJheXMgY2Fubm90IGJlIGZyb3plblwiLFxuICAxNjogXCJNb2RpZmljYXRpb24gZXhjZXB0aW9uOiB0aGUgaW50ZXJuYWwgc3RydWN0dXJlIG9mIGFuIG9ic2VydmFibGUgYXJyYXkgd2FzIGNoYW5nZWQuXCIsXG4gIDE3OiBmdW5jdGlvbiBfKGluZGV4LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gXCJbbW9ieC5hcnJheV0gSW5kZXggb3V0IG9mIGJvdW5kcywgXCIgKyBpbmRleCArIFwiIGlzIGxhcmdlciB0aGFuIFwiICsgbGVuZ3RoO1xuICB9LFxuICAxODogXCJtb2J4Lm1hcCByZXF1aXJlcyBNYXAgcG9seWZpbGwgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuIENoZWNrIGJhYmVsLXBvbHlmaWxsIG9yIGNvcmUtanMvZXM2L21hcC5qc1wiLFxuICAxOTogZnVuY3Rpb24gXyhvdGhlcikge1xuICAgIHJldHVybiBcIkNhbm5vdCBpbml0aWFsaXplIGZyb20gY2xhc3NlcyB0aGF0IGluaGVyaXQgZnJvbSBNYXA6IFwiICsgb3RoZXIuY29uc3RydWN0b3IubmFtZTtcbiAgfSxcbiAgMjA6IGZ1bmN0aW9uIF8ob3RoZXIpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgaW5pdGlhbGl6ZSBtYXAgZnJvbSBcIiArIG90aGVyO1xuICB9LFxuICAyMTogZnVuY3Rpb24gXyhkYXRhU3RydWN0dXJlKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IGNvbnZlcnQgdG8gbWFwIGZyb20gJ1wiICsgZGF0YVN0cnVjdHVyZSArIFwiJ1wiO1xuICB9LFxuICAyMjogXCJtb2J4LnNldCByZXF1aXJlcyBTZXQgcG9seWZpbGwgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuIENoZWNrIGJhYmVsLXBvbHlmaWxsIG9yIGNvcmUtanMvZXM2L3NldC5qc1wiLFxuICAyMzogXCJJdCBpcyBub3QgcG9zc2libGUgdG8gZ2V0IGluZGV4IGF0b21zIGZyb20gYXJyYXlzXCIsXG4gIDI0OiBmdW5jdGlvbiBfKHRoaW5nKSB7XG4gICAgcmV0dXJuIFwiQ2Fubm90IG9idGFpbiBhZG1pbmlzdHJhdGlvbiBmcm9tIFwiICsgdGhpbmc7XG4gIH0sXG4gIDI1OiBmdW5jdGlvbiBfKHByb3BlcnR5LCBuYW1lKSB7XG4gICAgcmV0dXJuIFwidGhlIGVudHJ5ICdcIiArIHByb3BlcnR5ICsgXCInIGRvZXMgbm90IGV4aXN0IGluIHRoZSBvYnNlcnZhYmxlIG1hcCAnXCIgKyBuYW1lICsgXCInXCI7XG4gIH0sXG4gIDI2OiBcInBsZWFzZSBzcGVjaWZ5IGEgcHJvcGVydHlcIixcbiAgMjc6IGZ1bmN0aW9uIF8ocHJvcGVydHksIG5hbWUpIHtcbiAgICByZXR1cm4gXCJubyBvYnNlcnZhYmxlIHByb3BlcnR5ICdcIiArIHByb3BlcnR5LnRvU3RyaW5nKCkgKyBcIicgZm91bmQgb24gdGhlIG9ic2VydmFibGUgb2JqZWN0ICdcIiArIG5hbWUgKyBcIidcIjtcbiAgfSxcbiAgMjg6IGZ1bmN0aW9uIF8odGhpbmcpIHtcbiAgICByZXR1cm4gXCJDYW5ub3Qgb2J0YWluIGF0b20gZnJvbSBcIiArIHRoaW5nO1xuICB9LFxuICAyOTogXCJFeHBlY3Rpbmcgc29tZSBvYmplY3RcIixcbiAgMzA6IFwiaW52YWxpZCBhY3Rpb24gc3RhY2suIGRpZCB5b3UgZm9yZ2V0IHRvIGZpbmlzaCBhbiBhY3Rpb24/XCIsXG4gIDMxOiBcIm1pc3Npbmcgb3B0aW9uIGZvciBjb21wdXRlZDogZ2V0XCIsXG4gIDMyOiBmdW5jdGlvbiBfKG5hbWUsIGRlcml2YXRpb24pIHtcbiAgICByZXR1cm4gXCJDeWNsZSBkZXRlY3RlZCBpbiBjb21wdXRhdGlvbiBcIiArIG5hbWUgKyBcIjogXCIgKyBkZXJpdmF0aW9uO1xuICB9LFxuICAzMzogZnVuY3Rpb24gXyhuYW1lKSB7XG4gICAgcmV0dXJuIFwiVGhlIHNldHRlciBvZiBjb21wdXRlZCB2YWx1ZSAnXCIgKyBuYW1lICsgXCInIGlzIHRyeWluZyB0byB1cGRhdGUgaXRzZWxmLiBEaWQgeW91IGludGVuZCB0byB1cGRhdGUgYW4gX29ic2VydmFibGVfIHZhbHVlLCBpbnN0ZWFkIG9mIHRoZSBjb21wdXRlZCBwcm9wZXJ0eT9cIjtcbiAgfSxcbiAgMzQ6IGZ1bmN0aW9uIF8obmFtZSkge1xuICAgIHJldHVybiBcIltDb21wdXRlZFZhbHVlICdcIiArIG5hbWUgKyBcIiddIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBhc3NpZ24gYSBuZXcgdmFsdWUgdG8gYSBjb21wdXRlZCB2YWx1ZS5cIjtcbiAgfSxcbiAgMzU6IFwiVGhlcmUgYXJlIG11bHRpcGxlLCBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgTW9iWCBhY3RpdmUuIE1ha2Ugc3VyZSBNb2JYIGlzIGxvYWRlZCBvbmx5IG9uY2Ugb3IgdXNlIGBjb25maWd1cmUoeyBpc29sYXRlR2xvYmFsU3RhdGU6IHRydWUgfSlgXCIsXG4gIDM2OiBcImlzb2xhdGVHbG9iYWxTdGF0ZSBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBNb2JYIGlzIHJ1bm5pbmcgYW55IHJlYWN0aW9uc1wiLFxuICAzNzogZnVuY3Rpb24gXyhtZXRob2QpIHtcbiAgICByZXR1cm4gXCJbbW9ieF0gYG9ic2VydmFibGVBcnJheS5cIiArIG1ldGhvZCArIFwiKClgIG11dGF0ZXMgdGhlIGFycmF5IGluLXBsYWNlLCB3aGljaCBpcyBub3QgYWxsb3dlZCBpbnNpZGUgYSBkZXJpdmF0aW9uLiBVc2UgYGFycmF5LnNsaWNlKCkuXCIgKyBtZXRob2QgKyBcIigpYCBpbnN0ZWFkXCI7XG4gIH0sXG4gIDM4OiBcIidvd25LZXlzKCknIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JzZXJ2YWJsZSBvYmplY3RzXCIsXG4gIDM5OiBcIidkZWZpbmVQcm9wZXJ0eSgpJyBjYW4gb25seSBiZSB1c2VkIG9uIG9ic2VydmFibGUgb2JqZWN0c1wiXG59O1xudmFyIGVycm9ycyA9ICBuaWNlRXJyb3JzIDtcbmZ1bmN0aW9uIGRpZShlcnJvcikge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB7XG4gICAgdmFyIGUgPSB0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIgPyBlcnJvciA6IGVycm9yc1tlcnJvcl07XG4gICAgaWYgKHR5cGVvZiBlID09PSBcImZ1bmN0aW9uXCIpIGUgPSBlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIltNb2JYXSBcIiArIGUpO1xuICB9XG59XG5cbnZhciBtb2NrR2xvYmFsID0ge307XG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICByZXR1cm4gbW9ja0dsb2JhbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG52YXIgZ2V0RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBFTVBUWV9BUlJBWSA9IFtdO1xuT2JqZWN0LmZyZWV6ZShFTVBUWV9BUlJBWSk7XG52YXIgRU1QVFlfT0JKRUNUID0ge307XG5PYmplY3QuZnJlZXplKEVNUFRZX09CSkVDVCk7XG52YXIgaGFzUHJveHkgPSB0eXBlb2YgUHJveHkgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgcGxhaW5PYmplY3RTdHJpbmcgPSAvKiNfX1BVUkVfXyovT2JqZWN0LnRvU3RyaW5nKCk7XG5mdW5jdGlvbiBhc3NlcnRQcm94aWVzKCkge1xuICBpZiAoIWhhc1Byb3h5KSB7XG4gICAgZGllKCBcImBQcm94eWAgb2JqZWN0cyBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gUGxlYXNlIGNvbmZpZ3VyZSBNb2JYIHRvIGVuYWJsZSBhIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uLmBcIiApO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KG1zZykge1xuICBpZiAoIGdsb2JhbFN0YXRlLnZlcmlmeVByb3hpZXMpIHtcbiAgICBkaWUoXCJNb2JYIGlzIGN1cnJlbnRseSBjb25maWd1cmVkIHRvIGJlIGFibGUgdG8gcnVuIGluIEVTNSBtb2RlLCBidXQgaW4gRVM1IE1vYlggd29uJ3QgYmUgYWJsZSB0byBcIiArIG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE5leHRJZCgpIHtcbiAgcmV0dXJuICsrZ2xvYmFsU3RhdGUubW9ieEd1aWQ7XG59XG4vKipcclxuICogTWFrZXMgc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpcyBpbnZva2VkIGF0IG1vc3Qgb25jZS5cclxuICovXG5cbmZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICB2YXIgaW52b2tlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpbnZva2VkKSByZXR1cm47XG4gICAgaW52b2tlZCA9IHRydWU7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmbikge1xuICByZXR1cm4gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBpc1N0cmluZ2lzaCh2YWx1ZSkge1xuICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcblxuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcInN5bWJvbFwiOlxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgdmFyIF9wcm90byRjb25zdHJ1Y3RvcjtcblxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiAoKF9wcm90byRjb25zdHJ1Y3RvciA9IHByb3RvLmNvbnN0cnVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX3Byb3RvJGNvbnN0cnVjdG9yLnRvU3RyaW5nKCkpID09PSBwbGFpbk9iamVjdFN0cmluZztcbn0gLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM3ODY1MTcwXG5cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yKG9iaikge1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9iai5jb25zdHJ1Y3RvcjtcbiAgaWYgKCFjb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuICBpZiAoXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSBjb25zdHJ1Y3Rvci5uYW1lIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gY29uc3RydWN0b3IuZGlzcGxheU5hbWUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhZGRIaWRkZW5Qcm9wKG9iamVjdCwgcHJvcE5hbWUsIHZhbHVlKSB7XG4gIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcE5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkSGlkZGVuRmluYWxQcm9wKG9iamVjdCwgcHJvcE5hbWUsIHZhbHVlKSB7XG4gIGRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcE5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUobmFtZSwgdGhlQ2xhc3MpIHtcbiAgdmFyIHByb3BOYW1lID0gXCJpc01vYlhcIiArIG5hbWU7XG4gIHRoZUNsYXNzLnByb3RvdHlwZVtwcm9wTmFtZV0gPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoeCkgJiYgeFtwcm9wTmFtZV0gPT09IHRydWU7XG4gIH07XG59XG5mdW5jdGlvbiBpc0VTNk1hcCh0aGluZykge1xuICByZXR1cm4gdGhpbmcgaW5zdGFuY2VvZiBNYXA7XG59XG5mdW5jdGlvbiBpc0VTNlNldCh0aGluZykge1xuICByZXR1cm4gdGhpbmcgaW5zdGFuY2VvZiBTZXQ7XG59XG52YXIgaGFzR2V0T3duUHJvcGVydHlTeW1ib2xzID0gdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09IFwidW5kZWZpbmVkXCI7XG4vKipcclxuICogUmV0dXJucyB0aGUgZm9sbG93aW5nOiBvd24gZW51bWVyYWJsZSBrZXlzIGFuZCBzeW1ib2xzLlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0UGxhaW5PYmplY3RLZXlzKG9iamVjdCkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IC8vIE5vdCBzdXBwb3J0ZWQgaW4gSUUsIHNvIHRoZXJlIGFyZSBub3QgZ29pbmcgdG8gYmUgc3ltYm9sIHByb3BzIGFueXdheS4uLlxuXG4gIGlmICghaGFzR2V0T3duUHJvcGVydHlTeW1ib2xzKSByZXR1cm4ga2V5cztcbiAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gIGlmICghc3ltYm9scy5sZW5ndGgpIHJldHVybiBrZXlzO1xuICByZXR1cm4gW10uY29uY2F0KGtleXMsIHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIG9iamVjdFByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgcyk7XG4gIH0pKTtcbn0gLy8gRnJvbSBJbW1lciB1dGlsc1xuLy8gUmV0dXJucyBhbGwgb3duIGtleXMsIGluY2x1ZGluZyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9saWNcblxudmFyIG93bktleXMgPSB0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0Lm93bktleXMgPyBSZWZsZWN0Lm93bktleXMgOiBoYXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikpO1xufSA6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG5mdW5jdGlvbiBzdHJpbmdpZnlLZXkoa2V5KSB7XG4gIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSByZXR1cm4ga2V5O1xuICBpZiAodHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIikgcmV0dXJuIGtleS50b1N0cmluZygpO1xuICByZXR1cm4gbmV3IFN0cmluZyhrZXkpLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBudWxsIDogdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiID8gXCJcIiArIHZhbHVlIDogdmFsdWU7XG59XG5mdW5jdGlvbiBoYXNQcm9wKHRhcmdldCwgcHJvcCkge1xuICByZXR1cm4gb2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKTtcbn0gLy8gRnJvbSBJbW1lciB1dGlsc1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnModGFyZ2V0KSB7XG4gIC8vIFBvbHlmaWxsIG5lZWRlZCBmb3IgSGVybWVzIGFuZCBJRSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9oZXJtZXMvaXNzdWVzLzI3NFxuICB2YXIgcmVzID0ge307IC8vIE5vdGU6IHdpdGhvdXQgcG9seWZpbGwgZm9yIG93bktleXMsIHN5bWJvbHMgd29uJ3QgYmUgcGlja2VkIHVwXG5cbiAgb3duS2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHJlc1trZXldID0gZ2V0RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gIH0pO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdDtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgcmV0dXJuIGl0Lm5leHQuYmluZChpdCk7XG59XG5cbnZhciBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCA9IC8qI19fUFVSRV9fKi9TeW1ib2woXCJtb2J4LXN0b3JlZC1hbm5vdGF0aW9uc1wiKTtcbi8qKlxyXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY3RzIGFzXHJcbiAqIC0gZGVjb3JhdG9yXHJcbiAqIC0gYW5ub3RhdGlvbiBvYmplY3RcclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlY29yYXRvckFubm90YXRpb24oYW5ub3RhdGlvbikge1xuICBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgIHN0b3JlQW5ub3RhdGlvbih0YXJnZXQsIHByb3BlcnR5LCBhbm5vdGF0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKGRlY29yYXRvciwgYW5ub3RhdGlvbik7XG59XG4vKipcclxuICogU3RvcmVzIGFubm90YXRpb24gdG8gcHJvdG90eXBlLFxyXG4gKiBzbyBpdCBjYW4gYmUgaW5zcGVjdGVkIGxhdGVyIGJ5IGBtYWtlT2JzZXJ2YWJsZWAgY2FsbGVkIGZyb20gY29uc3RydWN0b3JcclxuICovXG5cbmZ1bmN0aW9uIHN0b3JlQW5ub3RhdGlvbihwcm90b3R5cGUsIGtleSwgYW5ub3RhdGlvbikge1xuICBpZiAoIWhhc1Byb3AocHJvdG90eXBlLCBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCkpIHtcbiAgICBhZGRIaWRkZW5Qcm9wKHByb3RvdHlwZSwgc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2wsIF9leHRlbmRzKHt9LCBwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSk7XG4gIH0gLy8gQG92ZXJyaWRlIG11c3Qgb3ZlcnJpZGUgc29tZXRoaW5nXG5cblxuICBpZiAoIGlzT3ZlcnJpZGUoYW5ub3RhdGlvbikgJiYgIWhhc1Byb3AocHJvdG90eXBlW3N0b3JlZEFubm90YXRpb25zU3ltYm9sXSwga2V5KSkge1xuICAgIHZhciBmaWVsZE5hbWUgPSBwcm90b3R5cGUuY29uc3RydWN0b3IubmFtZSArIFwiLnByb3RvdHlwZS5cIiArIGtleS50b1N0cmluZygpO1xuICAgIGRpZShcIidcIiArIGZpZWxkTmFtZSArIFwiJyBpcyBkZWNvcmF0ZWQgd2l0aCAnb3ZlcnJpZGUnLCBcIiArIFwiYnV0IG5vIHN1Y2ggZGVjb3JhdGVkIG1lbWJlciB3YXMgZm91bmQgb24gcHJvdG90eXBlLlwiKTtcbiAgfSAvLyBDYW5ub3QgcmUtZGVjb3JhdGVcblxuXG4gIGFzc2VydE5vdERlY29yYXRlZChwcm90b3R5cGUsIGFubm90YXRpb24sIGtleSk7IC8vIElnbm9yZSBvdmVycmlkZVxuXG4gIGlmICghaXNPdmVycmlkZShhbm5vdGF0aW9uKSkge1xuICAgIHByb3RvdHlwZVtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF1ba2V5XSA9IGFubm90YXRpb247XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0Tm90RGVjb3JhdGVkKHByb3RvdHlwZSwgYW5ub3RhdGlvbiwga2V5KSB7XG4gIGlmICggIWlzT3ZlcnJpZGUoYW5ub3RhdGlvbikgJiYgaGFzUHJvcChwcm90b3R5cGVbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdLCBrZXkpKSB7XG4gICAgdmFyIGZpZWxkTmFtZSA9IHByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lICsgXCIucHJvdG90eXBlLlwiICsga2V5LnRvU3RyaW5nKCk7XG4gICAgdmFyIGN1cnJlbnRBbm5vdGF0aW9uVHlwZSA9IHByb3RvdHlwZVtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF1ba2V5XS5hbm5vdGF0aW9uVHlwZV87XG4gICAgdmFyIHJlcXVlc3RlZEFubm90YXRpb25UeXBlID0gYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV87XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdAXCIgKyByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSArIFwiJyB0byAnXCIgKyBmaWVsZE5hbWUgKyBcIic6XCIgKyAoXCJcXG5UaGUgZmllbGQgaXMgYWxyZWFkeSBkZWNvcmF0ZWQgd2l0aCAnQFwiICsgY3VycmVudEFubm90YXRpb25UeXBlICsgXCInLlwiKSArIFwiXFxuUmUtZGVjb3JhdGluZyBmaWVsZHMgaXMgbm90IGFsbG93ZWQuXCIgKyBcIlxcblVzZSAnQG92ZXJyaWRlJyBkZWNvcmF0b3IgZm9yIG1ldGhvZHMgb3ZlcnJpZGVuIGJ5IHN1YmNsYXNzLlwiKTtcbiAgfVxufVxuLyoqXHJcbiAqIENvbGxlY3RzIGFubm90YXRpb25zIGZyb20gcHJvdG90eXBlcyBhbmQgc3RvcmVzIHRoZW0gb24gdGFyZ2V0IChpbnN0YW5jZSlcclxuICovXG5cblxuZnVuY3Rpb24gY29sbGVjdFN0b3JlZEFubm90YXRpb25zKHRhcmdldCkge1xuICBpZiAoIWhhc1Byb3AodGFyZ2V0LCBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCkpIHtcbiAgICBpZiAoICF0YXJnZXRbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSB7XG4gICAgICBkaWUoXCJObyBhbm5vdGF0aW9ucyB3ZXJlIHBhc3NlZCB0byBtYWtlT2JzZXJ2YWJsZSwgYnV0IG5vIGRlY29yYXRlZCBtZW1iZXJzIGhhdmUgYmVlbiBmb3VuZCBlaXRoZXJcIik7XG4gICAgfSAvLyBXZSBuZWVkIGEgY29weSBhcyB3ZSB3aWxsIHJlbW92ZSBhbm5vdGF0aW9uIGZyb20gdGhlIGxpc3Qgb25jZSBpdCdzIGFwcGxpZWQuXG5cblxuICAgIGFkZEhpZGRlblByb3AodGFyZ2V0LCBzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbCwgX2V4dGVuZHMoe30sIHRhcmdldFtzdG9yZWRBbm5vdGF0aW9uc1N5bWJvbF0pKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRbc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdO1xufVxuXG52YXIgJG1vYnggPSAvKiNfX1BVUkVfXyovU3ltYm9sKFwibW9ieCBhZG1pbmlzdHJhdGlvblwiKTtcbnZhciBBdG9tID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gZm9yIGVmZmVjdGl2ZSB1bm9ic2VydmluZy4gQmFzZUF0b20gaGFzIHRydWUsIGZvciBleHRyYSBvcHRpbWl6YXRpb24sIHNvIGl0cyBvbkJlY29tZVVub2JzZXJ2ZWQgbmV2ZXIgZ2V0cyBjYWxsZWQsIGJlY2F1c2UgaXQncyBub3QgbmVlZGVkXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGF0b20uIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgaXQgaXMgcmVjb21tZW5kZWQgdG8gZ2l2ZSBpdCBhIG5hbWUuXHJcbiAgICogVGhlIG9uQmVjb21lT2JzZXJ2ZWQgYW5kIG9uQmVjb21lVW5vYnNlcnZlZCBjYWxsYmFja3MgY2FuIGJlIHVzZWQgZm9yIHJlc291cmNlIG1hbmFnZW1lbnQuXHJcbiAgICovXG4gIGZ1bmN0aW9uIEF0b20obmFtZV8pIHtcbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSAgXCJBdG9tQFwiICsgZ2V0TmV4dElkKCkgO1xuICAgIH1cblxuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc1BlbmRpbmdVbm9ic2VydmF0aW9uXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNCZWluZ09ic2VydmVkXyA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXJzXyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmRpZmZWYWx1ZV8gPSAwO1xuICAgIHRoaXMubGFzdEFjY2Vzc2VkQnlfID0gMDtcbiAgICB0aGlzLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uTk9UX1RSQUNLSU5HXztcbiAgICB0aGlzLm9uQk9MID0gdm9pZCAwO1xuICAgIHRoaXMub25CVU9MID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgfSAvLyBvbkJlY29tZU9ic2VydmVkTGlzdGVuZXJzXG5cblxuICB2YXIgX3Byb3RvID0gQXRvbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9uQk8gPSBmdW5jdGlvbiBvbkJPKCkge1xuICAgIGlmICh0aGlzLm9uQk9MKSB7XG4gICAgICB0aGlzLm9uQk9MLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkJVTyA9IGZ1bmN0aW9uIG9uQlVPKCkge1xuICAgIGlmICh0aGlzLm9uQlVPTCkge1xuICAgICAgdGhpcy5vbkJVT0wuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogSW52b2tlIHRoaXMgbWV0aG9kIHRvIG5vdGlmeSBtb2J4IHRoYXQgeW91ciBhdG9tIGhhcyBiZWVuIHVzZWQgc29tZWhvdy5cclxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgY3VycmVudGx5IGEgcmVhY3RpdmUgY29udGV4dC5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBvcnRPYnNlcnZlZCA9IGZ1bmN0aW9uIHJlcG9ydE9ic2VydmVkJDEoKSB7XG4gICAgcmV0dXJuIHJlcG9ydE9ic2VydmVkKHRoaXMpO1xuICB9XG4gIC8qKlxyXG4gICAqIEludm9rZSB0aGlzIG1ldGhvZCBfYWZ0ZXJfIHRoaXMgbWV0aG9kIGhhcyBjaGFuZ2VkIHRvIHNpZ25hbCBtb2J4IHRoYXQgYWxsIGl0cyBvYnNlcnZlcnMgc2hvdWxkIGludmFsaWRhdGUuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVwb3J0Q2hhbmdlZCA9IGZ1bmN0aW9uIHJlcG9ydENoYW5nZWQoKSB7XG4gICAgc3RhcnRCYXRjaCgpO1xuICAgIHByb3BhZ2F0ZUNoYW5nZWQodGhpcyk7XG4gICAgZW5kQmF0Y2goKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lXztcbiAgfTtcblxuICByZXR1cm4gQXRvbTtcbn0oKTtcbnZhciBpc0F0b20gPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIkF0b21cIiwgQXRvbSk7XG5mdW5jdGlvbiBjcmVhdGVBdG9tKG5hbWUsIG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyLCBvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyKSB7XG4gIGlmIChvbkJlY29tZU9ic2VydmVkSGFuZGxlciA9PT0gdm9pZCAwKSB7XG4gICAgb25CZWNvbWVPYnNlcnZlZEhhbmRsZXIgPSBub29wO1xuICB9XG5cbiAgaWYgKG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIgPT09IHZvaWQgMCkge1xuICAgIG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIgPSBub29wO1xuICB9XG5cbiAgdmFyIGF0b20gPSBuZXcgQXRvbShuYW1lKTsgLy8gZGVmYXVsdCBgbm9vcGAgbGlzdGVuZXIgd2lsbCBub3QgaW5pdGlhbGl6ZSB0aGUgaG9vayBTZXRcblxuICBpZiAob25CZWNvbWVPYnNlcnZlZEhhbmRsZXIgIT09IG5vb3ApIHtcbiAgICBvbkJlY29tZU9ic2VydmVkKGF0b20sIG9uQmVjb21lT2JzZXJ2ZWRIYW5kbGVyKTtcbiAgfVxuXG4gIGlmIChvbkJlY29tZVVub2JzZXJ2ZWRIYW5kbGVyICE9PSBub29wKSB7XG4gICAgb25CZWNvbWVVbm9ic2VydmVkKGF0b20sIG9uQmVjb21lVW5vYnNlcnZlZEhhbmRsZXIpO1xuICB9XG5cbiAgcmV0dXJuIGF0b207XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5Q29tcGFyZXIoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cblxuZnVuY3Rpb24gc3RydWN0dXJhbENvbXBhcmVyKGEsIGIpIHtcbiAgcmV0dXJuIGRlZXBFcXVhbChhLCBiKTtcbn1cblxuZnVuY3Rpb24gc2hhbGxvd0NvbXBhcmVyKGEsIGIpIHtcbiAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCAxKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmVyKGEsIGIpIHtcbiAgaWYgKE9iamVjdC5pcykgcmV0dXJuIE9iamVjdC5pcyhhLCBiKTtcbiAgcmV0dXJuIGEgPT09IGIgPyBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYiA6IGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cblxudmFyIGNvbXBhcmVyID0ge1xuICBpZGVudGl0eTogaWRlbnRpdHlDb21wYXJlcixcbiAgc3RydWN0dXJhbDogc3RydWN0dXJhbENvbXBhcmVyLFxuICBcImRlZmF1bHRcIjogZGVmYXVsdENvbXBhcmVyLFxuICBzaGFsbG93OiBzaGFsbG93Q29tcGFyZXJcbn07XG5cbmZ1bmN0aW9uIGRlZXBFbmhhbmNlcih2LCBfLCBuYW1lKSB7XG4gIC8vIGl0IGlzIGFuIG9ic2VydmFibGUgYWxyZWFkeSwgZG9uZVxuICBpZiAoaXNPYnNlcnZhYmxlKHYpKSByZXR1cm4gdjsgLy8gc29tZXRoaW5nIHRoYXQgY2FuIGJlIGNvbnZlcnRlZCBhbmQgbXV0YXRlZD9cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkgcmV0dXJuIG9ic2VydmFibGUuYXJyYXkodiwge1xuICAgIG5hbWU6IG5hbWVcbiAgfSk7XG4gIGlmIChpc1BsYWluT2JqZWN0KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5vYmplY3QodiwgdW5kZWZpbmVkLCB7XG4gICAgbmFtZTogbmFtZVxuICB9KTtcbiAgaWYgKGlzRVM2TWFwKHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5tYXAodiwge1xuICAgIG5hbWU6IG5hbWVcbiAgfSk7XG4gIGlmIChpc0VTNlNldCh2KSkgcmV0dXJuIG9ic2VydmFibGUuc2V0KHYsIHtcbiAgICBuYW1lOiBuYW1lXG4gIH0pO1xuXG4gIGlmICh0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiICYmICFpc0FjdGlvbih2KSAmJiAhaXNGbG93KHYpKSB7XG4gICAgaWYgKGlzR2VuZXJhdG9yKHYpKSB7XG4gICAgICByZXR1cm4gZmxvdyh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF1dG9BY3Rpb24obmFtZSwgdik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBzaGFsbG93RW5oYW5jZXIodiwgXywgbmFtZSkge1xuICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGwpIHJldHVybiB2O1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHYpIHx8IGlzT2JzZXJ2YWJsZUFycmF5KHYpIHx8IGlzT2JzZXJ2YWJsZU1hcCh2KSB8fCBpc09ic2VydmFibGVTZXQodikpIHJldHVybiB2O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2KSkgcmV0dXJuIG9ic2VydmFibGUuYXJyYXkodiwge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgZGVlcDogZmFsc2VcbiAgfSk7XG4gIGlmIChpc1BsYWluT2JqZWN0KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5vYmplY3QodiwgdW5kZWZpbmVkLCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBkZWVwOiBmYWxzZVxuICB9KTtcbiAgaWYgKGlzRVM2TWFwKHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5tYXAodiwge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgZGVlcDogZmFsc2VcbiAgfSk7XG4gIGlmIChpc0VTNlNldCh2KSkgcmV0dXJuIG9ic2VydmFibGUuc2V0KHYsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGRlZXA6IGZhbHNlXG4gIH0pO1xuICBkaWUoXCJUaGUgc2hhbGxvdyBtb2RpZmllciAvIGRlY29yYXRvciBjYW4gb25seSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYXJyYXlzLCBvYmplY3RzLCBtYXBzIGFuZCBzZXRzXCIpO1xufVxuZnVuY3Rpb24gcmVmZXJlbmNlRW5oYW5jZXIobmV3VmFsdWUpIHtcbiAgLy8gbmV2ZXIgdHVybiBpbnRvIGFuIG9ic2VydmFibGVcbiAgcmV0dXJuIG5ld1ZhbHVlO1xufVxuZnVuY3Rpb24gcmVmU3RydWN0RW5oYW5jZXIodiwgb2xkVmFsdWUpIHtcbiAgaWYgKCBpc09ic2VydmFibGUodikpIGRpZShcIm9ic2VydmFibGUuc3RydWN0IHNob3VsZCBub3QgYmUgdXNlZCB3aXRoIG9ic2VydmFibGUgdmFsdWVzXCIpO1xuICBpZiAoZGVlcEVxdWFsKHYsIG9sZFZhbHVlKSkgcmV0dXJuIG9sZFZhbHVlO1xuICByZXR1cm4gdjtcbn1cblxudmFyIE9WRVJSSURFID0gXCJvdmVycmlkZVwiO1xudmFyIG92ZXJyaWRlID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oe1xuICBhbm5vdGF0aW9uVHlwZV86IE9WRVJSSURFLFxuICBtYWtlXzogbWFrZV8sXG4gIGV4dGVuZF86IGV4dGVuZF9cbn0pO1xuZnVuY3Rpb24gaXNPdmVycmlkZShhbm5vdGF0aW9uKSB7XG4gIHJldHVybiBhbm5vdGF0aW9uLmFubm90YXRpb25UeXBlXyA9PT0gT1ZFUlJJREU7XG59XG5cbmZ1bmN0aW9uIG1ha2VfKGFkbSwga2V5KSB7XG4gIC8vIE11c3Qgbm90IGJlIHBsYWluIG9iamVjdFxuICBpZiAoIGFkbS5pc1BsYWluT2JqZWN0Xykge1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyB0aGlzLmFubm90YXRpb25UeXBlXyArIFwiJyB0byAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOlwiICsgKFwiXFxuJ1wiICsgdGhpcy5hbm5vdGF0aW9uVHlwZV8gKyBcIicgY2Fubm90IGJlIHVzZWQgb24gcGxhaW4gb2JqZWN0cy5cIikpO1xuICB9IC8vIE11c3Qgb3ZlcnJpZGUgc29tZXRoaW5nXG5cblxuICBpZiAoICFoYXNQcm9wKGFkbS5hcHBsaWVkQW5ub3RhdGlvbnNfLCBrZXkpKSB7XG4gICAgZGllKFwiJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJyBpcyBhbm5vdGF0ZWQgd2l0aCAnXCIgKyB0aGlzLmFubm90YXRpb25UeXBlXyArIFwiJywgXCIgKyBcImJ1dCBubyBzdWNoIGFubm90YXRlZCBtZW1iZXIgd2FzIGZvdW5kIG9uIHByb3RvdHlwZS5cIik7XG4gIH1cblxuICByZXR1cm4gMFxuICAvKiBDYW5jZWwgKi9cbiAgO1xufVxuXG5mdW5jdGlvbiBleHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgZGllKFwiJ1wiICsgdGhpcy5hbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCB3aXRoICdtYWtlT2JzZXJ2YWJsZSdcIik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkFubm90YXRpb24obmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGFubm90YXRpb25UeXBlXzogbmFtZSxcbiAgICBvcHRpb25zXzogb3B0aW9ucyxcbiAgICBtYWtlXzogbWFrZV8kMSxcbiAgICBleHRlbmRfOiBleHRlbmRfJDFcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZV8kMShhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXztcblxuICAvLyBib3VuZFxuICBpZiAoKF90aGlzJG9wdGlvbnNfID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfLmJvdW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgZmFsc2UpID09PSBudWxsID8gMFxuICAgIC8qIENhbmNlbCAqL1xuICAgIDogMVxuICAgIC8qIEJyZWFrICovXG4gICAgO1xuICB9IC8vIG93blxuXG5cbiAgaWYgKHNvdXJjZSA9PT0gYWRtLnRhcmdldF8pIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwgPyAwXG4gICAgLyogQ2FuY2VsICovXG4gICAgOiAyXG4gICAgLyogQ29udGludWUgKi9cbiAgICA7XG4gIH0gLy8gcHJvdG90eXBlXG5cblxuICBpZiAoaXNBY3Rpb24oZGVzY3JpcHRvci52YWx1ZSkpIHtcbiAgICAvLyBBIHByb3RvdHlwZSBjb3VsZCBoYXZlIGJlZW4gYW5ub3RhdGVkIGFscmVhZHkgYnkgb3RoZXIgY29uc3RydWN0b3IsXG4gICAgLy8gcmVzdCBvZiB0aGUgcHJvdG8gY2hhaW4gbXVzdCBiZSBhbm5vdGF0ZWQgYWxyZWFkeVxuICAgIHJldHVybiAxXG4gICAgLyogQnJlYWsgKi9cbiAgICA7XG4gIH1cblxuICB2YXIgYWN0aW9uRGVzY3JpcHRvciA9IGNyZWF0ZUFjdGlvbkRlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKTtcbiAgZGVmaW5lUHJvcGVydHkoc291cmNlLCBrZXksIGFjdGlvbkRlc2NyaXB0b3IpO1xuICByZXR1cm4gMlxuICAvKiBDb250aW51ZSAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZF8kMShhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIHZhciBhY3Rpb25EZXNjcmlwdG9yID0gY3JlYXRlQWN0aW9uRGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvcik7XG4gIHJldHVybiBhZG0uZGVmaW5lUHJvcGVydHlfKGtleSwgYWN0aW9uRGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QWN0aW9uRGVzY3JpcHRvcihhZG0sIF9yZWYsIGtleSwgX3JlZjIpIHtcbiAgdmFyIGFubm90YXRpb25UeXBlXyA9IF9yZWYuYW5ub3RhdGlvblR5cGVfO1xuICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZTtcblxuICBpZiAoICFpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgdG8gJ1wiICsgYWRtLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSArIFwiJzpcIiArIChcIlxcbidcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyBjYW4gb25seSBiZSB1c2VkIG9uIHByb3BlcnRpZXMgd2l0aCBhIGZ1bmN0aW9uIHZhbHVlLlwiKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQWN0aW9uRGVzY3JpcHRvcihhZG0sIGFubm90YXRpb24sIGtleSwgZGVzY3JpcHRvciwgLy8gcHJvdmlkZXMgYWJpbGl0eSB0byBkaXNhYmxlIHNhZmVEZXNjcmlwdG9ycyBmb3IgcHJvdG90eXBlc1xuc2FmZURlc2NyaXB0b3JzKSB7XG4gIHZhciBfYW5ub3RhdGlvbiRvcHRpb25zXywgX2Fubm90YXRpb24kb3B0aW9uc18kLCBfYW5ub3RhdGlvbiRvcHRpb25zXzIsIF9hbm5vdGF0aW9uJG9wdGlvbnNfJDIsIF9hbm5vdGF0aW9uJG9wdGlvbnNfMztcblxuICBpZiAoc2FmZURlc2NyaXB0b3JzID09PSB2b2lkIDApIHtcbiAgICBzYWZlRGVzY3JpcHRvcnMgPSBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnM7XG4gIH1cblxuICBhc3NlcnRBY3Rpb25EZXNjcmlwdG9yKGFkbSwgYW5ub3RhdGlvbiwga2V5LCBkZXNjcmlwdG9yKTtcbiAgdmFyIHZhbHVlID0gZGVzY3JpcHRvci52YWx1ZTtcblxuICBpZiAoKF9hbm5vdGF0aW9uJG9wdGlvbnNfID0gYW5ub3RhdGlvbi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9uJG9wdGlvbnNfLmJvdW5kKSB7XG4gICAgdmFyIF9hZG0kcHJveHlfO1xuXG4gICAgdmFsdWUgPSB2YWx1ZS5iaW5kKChfYWRtJHByb3h5XyA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XyA6IGFkbS50YXJnZXRfKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGNyZWF0ZUFjdGlvbigoX2Fubm90YXRpb24kb3B0aW9uc18kID0gKF9hbm5vdGF0aW9uJG9wdGlvbnNfMiA9IGFubm90YXRpb24ub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfYW5ub3RhdGlvbiRvcHRpb25zXzIubmFtZSkgIT0gbnVsbCA/IF9hbm5vdGF0aW9uJG9wdGlvbnNfJCA6IGtleS50b1N0cmluZygpLCB2YWx1ZSwgKF9hbm5vdGF0aW9uJG9wdGlvbnNfJDIgPSAoX2Fubm90YXRpb24kb3B0aW9uc18zID0gYW5ub3RhdGlvbi5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9uJG9wdGlvbnNfMy5hdXRvQWN0aW9uKSAhPSBudWxsID8gX2Fubm90YXRpb24kb3B0aW9uc18kMiA6IGZhbHNlKSxcbiAgICAvLyBOb24tY29uZmlndXJhYmxlIGZvciBjbGFzc2VzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbCBmaWVsZCByZWRlZmluaXRpb24gaW4gc3ViY2xhc3NcbiAgICBjb25maWd1cmFibGU6IHNhZmVEZXNjcmlwdG9ycyA/IGFkbS5pc1BsYWluT2JqZWN0XyA6IHRydWUsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L3B1bGwvMjY0MSNpc3N1ZWNvbW1lbnQtNzM3MjkyMDU4XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgLy8gTm9uLW9ic2V2YWJsZSwgdGhlcmVmb3JlIG5vbi13cml0YWJsZVxuICAgIC8vIEFsc28gcHJldmVudHMgcmV3cml0aW5nIGluIHN1YmNsYXNzIGNvbnN0cnVjdG9yXG4gICAgd3JpdGFibGU6IHNhZmVEZXNjcmlwdG9ycyA/IGZhbHNlIDogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGbG93QW5ub3RhdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGlvblR5cGVfOiBuYW1lLFxuICAgIG9wdGlvbnNfOiBvcHRpb25zLFxuICAgIG1ha2VfOiBtYWtlXyQyLFxuICAgIGV4dGVuZF86IGV4dGVuZF8kMlxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlXyQyKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfO1xuXG4gIC8vIG93blxuICBpZiAoc291cmNlID09PSBhZG0udGFyZ2V0Xykge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCA/IDBcbiAgICAvKiBDYW5jZWwgKi9cbiAgICA6IDJcbiAgICAvKiBDb250aW51ZSAqL1xuICAgIDtcbiAgfSAvLyBwcm90b3R5cGVcbiAgLy8gYm91bmQgLSBtdXN0IGFubm90YXRlIHByb3RvcyB0byBzdXBwb3J0IHN1cGVyLmZsb3coKVxuXG5cbiAgaWYgKCgoX3RoaXMkb3B0aW9uc18gPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc18uYm91bmQpICYmICFpc0Zsb3coYWRtLnRhcmdldF9ba2V5XSkpIHtcbiAgICBpZiAodGhpcy5leHRlbmRfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSkgPT09IG51bGwpIHJldHVybiAwXG4gICAgLyogQ2FuY2VsICovXG4gICAgO1xuICB9XG5cbiAgaWYgKGlzRmxvdyhkZXNjcmlwdG9yLnZhbHVlKSkge1xuICAgIC8vIEEgcHJvdG90eXBlIGNvdWxkIGhhdmUgYmVlbiBhbm5vdGF0ZWQgYWxyZWFkeSBieSBvdGhlciBjb25zdHJ1Y3RvcixcbiAgICAvLyByZXN0IG9mIHRoZSBwcm90byBjaGFpbiBtdXN0IGJlIGFubm90YXRlZCBhbHJlYWR5XG4gICAgcmV0dXJuIDFcbiAgICAvKiBCcmVhayAqL1xuICAgIDtcbiAgfVxuXG4gIHZhciBmbG93RGVzY3JpcHRvciA9IGNyZWF0ZUZsb3dEZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yLCBmYWxzZSwgZmFsc2UpO1xuICBkZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwgZmxvd0Rlc2NyaXB0b3IpO1xuICByZXR1cm4gMlxuICAvKiBDb250aW51ZSAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZF8kMihhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXzI7XG5cbiAgdmFyIGZsb3dEZXNjcmlwdG9yID0gY3JlYXRlRmxvd0Rlc2NyaXB0b3IoYWRtLCB0aGlzLCBrZXksIGRlc2NyaXB0b3IsIChfdGhpcyRvcHRpb25zXzIgPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc18yLmJvdW5kKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVQcm9wZXJ0eV8oa2V5LCBmbG93RGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Rmxvd0Rlc2NyaXB0b3IoYWRtLCBfcmVmLCBrZXksIF9yZWYyKSB7XG4gIHZhciBhbm5vdGF0aW9uVHlwZV8gPSBfcmVmLmFubm90YXRpb25UeXBlXztcbiAgdmFyIHZhbHVlID0gX3JlZjIudmFsdWU7XG5cbiAgaWYgKCAhaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2FuIG9ubHkgYmUgdXNlZCBvbiBwcm9wZXJ0aWVzIHdpdGggYSBnZW5lcmF0b3IgZnVuY3Rpb24gdmFsdWUuXCIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGbG93RGVzY3JpcHRvcihhZG0sIGFubm90YXRpb24sIGtleSwgZGVzY3JpcHRvciwgYm91bmQsIC8vIHByb3ZpZGVzIGFiaWxpdHkgdG8gZGlzYWJsZSBzYWZlRGVzY3JpcHRvcnMgZm9yIHByb3RvdHlwZXNcbnNhZmVEZXNjcmlwdG9ycykge1xuICBpZiAoc2FmZURlc2NyaXB0b3JzID09PSB2b2lkIDApIHtcbiAgICBzYWZlRGVzY3JpcHRvcnMgPSBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnM7XG4gIH1cblxuICBhc3NlcnRGbG93RGVzY3JpcHRvcihhZG0sIGFubm90YXRpb24sIGtleSwgZGVzY3JpcHRvcik7XG4gIHZhciB2YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWU7XG5cbiAgaWYgKGJvdW5kKSB7XG4gICAgdmFyIF9hZG0kcHJveHlfO1xuXG4gICAgdmFsdWUgPSB2YWx1ZS5iaW5kKChfYWRtJHByb3h5XyA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XyA6IGFkbS50YXJnZXRfKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGZsb3codmFsdWUpLFxuICAgIC8vIE5vbi1jb25maWd1cmFibGUgZm9yIGNsYXNzZXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsIGZpZWxkIHJlZGVmaW5pdGlvbiBpbiBzdWJjbGFzc1xuICAgIGNvbmZpZ3VyYWJsZTogc2FmZURlc2NyaXB0b3JzID8gYWRtLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvcHVsbC8yNjQxI2lzc3VlY29tbWVudC03MzcyOTIwNThcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAvLyBOb24tb2JzZXZhYmxlLCB0aGVyZWZvcmUgbm9uLXdyaXRhYmxlXG4gICAgLy8gQWxzbyBwcmV2ZW50cyByZXdyaXRpbmcgaW4gc3ViY2xhc3MgY29uc3RydWN0b3JcbiAgICB3cml0YWJsZTogc2FmZURlc2NyaXB0b3JzID8gZmFsc2UgOiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkQW5ub3RhdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGlvblR5cGVfOiBuYW1lLFxuICAgIG9wdGlvbnNfOiBvcHRpb25zLFxuICAgIG1ha2VfOiBtYWtlXyQzLFxuICAgIGV4dGVuZF86IGV4dGVuZF8kM1xuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlXyQzKGFkbSwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIHJldHVybiB0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCA/IDBcbiAgLyogQ2FuY2VsICovXG4gIDogMVxuICAvKiBCcmVhayAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZF8kMyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIGFzc2VydENvbXB1dGVkRGVzY3JpcHRvcihhZG0sIHRoaXMsIGtleSwgZGVzY3JpcHRvcik7XG4gIHJldHVybiBhZG0uZGVmaW5lQ29tcHV0ZWRQcm9wZXJ0eV8oa2V5LCBfZXh0ZW5kcyh7fSwgdGhpcy5vcHRpb25zXywge1xuICAgIGdldDogZGVzY3JpcHRvci5nZXQsXG4gICAgc2V0OiBkZXNjcmlwdG9yLnNldFxuICB9KSwgcHJveHlUcmFwKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q29tcHV0ZWREZXNjcmlwdG9yKGFkbSwgX3JlZiwga2V5LCBfcmVmMikge1xuICB2YXIgYW5ub3RhdGlvblR5cGVfID0gX3JlZi5hbm5vdGF0aW9uVHlwZV87XG4gIHZhciBnZXQgPSBfcmVmMi5nZXQ7XG5cbiAgaWYgKCAhZ2V0KSB7XG4gICAgZGllKFwiQ2Fubm90IGFwcGx5ICdcIiArIGFubm90YXRpb25UeXBlXyArIFwiJyB0byAnXCIgKyBhZG0ubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpICsgXCInOlwiICsgKFwiXFxuJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIGNhbiBvbmx5IGJlIHVzZWQgb24gZ2V0dGVyKCtzZXR0ZXIpIHByb3BlcnRpZXMuXCIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlQW5ub3RhdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGlvblR5cGVfOiBuYW1lLFxuICAgIG9wdGlvbnNfOiBvcHRpb25zLFxuICAgIG1ha2VfOiBtYWtlXyQ0LFxuICAgIGV4dGVuZF86IGV4dGVuZF8kNFxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlXyQ0KGFkbSwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIHJldHVybiB0aGlzLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIGZhbHNlKSA9PT0gbnVsbCA/IDBcbiAgLyogQ2FuY2VsICovXG4gIDogMVxuICAvKiBCcmVhayAqL1xuICA7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZF8kNChhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKSB7XG4gIHZhciBfdGhpcyRvcHRpb25zXyRlbmhhbmMsIF90aGlzJG9wdGlvbnNfO1xuXG4gIGFzc2VydE9ic2VydmFibGVEZXNjcmlwdG9yKGFkbSwgdGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgcmV0dXJuIGFkbS5kZWZpbmVPYnNlcnZhYmxlUHJvcGVydHlfKGtleSwgZGVzY3JpcHRvci52YWx1ZSwgKF90aGlzJG9wdGlvbnNfJGVuaGFuYyA9IChfdGhpcyRvcHRpb25zXyA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXy5lbmhhbmNlcikgIT0gbnVsbCA/IF90aGlzJG9wdGlvbnNfJGVuaGFuYyA6IGRlZXBFbmhhbmNlciwgcHJveHlUcmFwKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JzZXJ2YWJsZURlc2NyaXB0b3IoYWRtLCBfcmVmLCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgdmFyIGFubm90YXRpb25UeXBlXyA9IF9yZWYuYW5ub3RhdGlvblR5cGVfO1xuXG4gIGlmICggIShcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikpIHtcbiAgICBkaWUoXCJDYW5ub3QgYXBwbHkgJ1wiICsgYW5ub3RhdGlvblR5cGVfICsgXCInIHRvICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6XCIgKyAoXCJcXG4nXCIgKyBhbm5vdGF0aW9uVHlwZV8gKyBcIicgY2Fubm90IGJlIHVzZWQgb24gZ2V0dGVyL3NldHRlciBwcm9wZXJ0aWVzXCIpKTtcbiAgfVxufVxuXG52YXIgQVVUTyA9IFwidHJ1ZVwiO1xudmFyIGF1dG9Bbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUF1dG9Bbm5vdGF0aW9uKCk7XG5mdW5jdGlvbiBjcmVhdGVBdXRvQW5ub3RhdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYW5ub3RhdGlvblR5cGVfOiBBVVRPLFxuICAgIG9wdGlvbnNfOiBvcHRpb25zLFxuICAgIG1ha2VfOiBtYWtlXyQ1LFxuICAgIGV4dGVuZF86IGV4dGVuZF8kNVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlXyQ1KGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfMywgX3RoaXMkb3B0aW9uc180O1xuXG4gIC8vIGdldHRlciAtPiBjb21wdXRlZFxuICBpZiAoZGVzY3JpcHRvci5nZXQpIHtcbiAgICByZXR1cm4gY29tcHV0ZWQubWFrZV8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG4gIH0gLy8gbG9uZSBzZXR0ZXIgLT4gYWN0aW9uIHNldHRlclxuXG5cbiAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgLy8gVE9ETyBtYWtlIGFjdGlvbiBhcHBsaWNhYmxlIHRvIHNldHRlciBhbmQgZGVsZWdhdGUgdG8gYWN0aW9uLm1ha2VfXG4gICAgdmFyIHNldCA9IGNyZWF0ZUFjdGlvbihrZXkudG9TdHJpbmcoKSwgZGVzY3JpcHRvci5zZXQpOyAvLyBvd25cblxuICAgIGlmIChzb3VyY2UgPT09IGFkbS50YXJnZXRfKSB7XG4gICAgICByZXR1cm4gYWRtLmRlZmluZVByb3BlcnR5XyhrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnMgPyBhZG0uaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgICAgICBzZXQ6IHNldFxuICAgICAgfSkgPT09IG51bGwgPyAwXG4gICAgICAvKiBDYW5jZWwgKi9cbiAgICAgIDogMlxuICAgICAgLyogQ29udGludWUgKi9cbiAgICAgIDtcbiAgICB9IC8vIHByb3RvXG5cblxuICAgIGRlZmluZVByb3BlcnR5KHNvdXJjZSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBzZXQ6IHNldFxuICAgIH0pO1xuICAgIHJldHVybiAyXG4gICAgLyogQ29udGludWUgKi9cbiAgICA7XG4gIH0gLy8gZnVuY3Rpb24gb24gcHJvdG8gLT4gYXV0b0FjdGlvbi9mbG93XG5cblxuICBpZiAoc291cmNlICE9PSBhZG0udGFyZ2V0XyAmJiB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnNfMjtcblxuICAgIGlmIChpc0dlbmVyYXRvcihkZXNjcmlwdG9yLnZhbHVlKSkge1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnNfO1xuXG4gICAgICB2YXIgZmxvd0Fubm90YXRpb24gPSAoKF90aGlzJG9wdGlvbnNfID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfLmF1dG9CaW5kKSA/IGZsb3cuYm91bmQgOiBmbG93O1xuICAgICAgcmV0dXJuIGZsb3dBbm5vdGF0aW9uLm1ha2VfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciBhY3Rpb25Bbm5vdGF0aW9uID0gKChfdGhpcyRvcHRpb25zXzIgPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc18yLmF1dG9CaW5kKSA/IGF1dG9BY3Rpb24uYm91bmQgOiBhdXRvQWN0aW9uO1xuICAgIHJldHVybiBhY3Rpb25Bbm5vdGF0aW9uLm1ha2VfKGFkbSwga2V5LCBkZXNjcmlwdG9yLCBzb3VyY2UpO1xuICB9IC8vIG90aGVyIC0+IG9ic2VydmFibGVcbiAgLy8gQ29weSBwcm9wcyBmcm9tIHByb3RvIGFzIHdlbGwsIHNlZSB0ZXN0OlxuICAvLyBcImRlY29yYXRlIHNob3VsZCB3b3JrIHdpdGggT2JqZWN0LmNyZWF0ZVwiXG5cblxuICB2YXIgb2JzZXJ2YWJsZUFubm90YXRpb24gPSAoKF90aGlzJG9wdGlvbnNfMyA9IHRoaXMub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zXzMuZGVlcCkgPT09IGZhbHNlID8gb2JzZXJ2YWJsZS5yZWYgOiBvYnNlcnZhYmxlOyAvLyBpZiBmdW5jdGlvbiByZXNwZWN0IGF1dG9CaW5kIG9wdGlvblxuXG4gIGlmICh0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmICgoX3RoaXMkb3B0aW9uc180ID0gdGhpcy5vcHRpb25zXykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnNfNC5hdXRvQmluZCkpIHtcbiAgICB2YXIgX2FkbSRwcm94eV87XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZGVzY3JpcHRvci52YWx1ZS5iaW5kKChfYWRtJHByb3h5XyA9IGFkbS5wcm94eV8pICE9IG51bGwgPyBfYWRtJHByb3h5XyA6IGFkbS50YXJnZXRfKTtcbiAgfVxuXG4gIHJldHVybiBvYnNlcnZhYmxlQW5ub3RhdGlvbi5tYWtlXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgc291cmNlKTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kXyQ1KGFkbSwga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgdmFyIF90aGlzJG9wdGlvbnNfNSwgX3RoaXMkb3B0aW9uc182O1xuXG4gIC8vIGdldHRlciAtPiBjb21wdXRlZFxuICBpZiAoZGVzY3JpcHRvci5nZXQpIHtcbiAgICByZXR1cm4gY29tcHV0ZWQuZXh0ZW5kXyhhZG0sIGtleSwgZGVzY3JpcHRvciwgcHJveHlUcmFwKTtcbiAgfSAvLyBsb25lIHNldHRlciAtPiBhY3Rpb24gc2V0dGVyXG5cblxuICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcbiAgICAvLyBUT0RPIG1ha2UgYWN0aW9uIGFwcGxpY2FibGUgdG8gc2V0dGVyIGFuZCBkZWxlZ2F0ZSB0byBhY3Rpb24uZXh0ZW5kX1xuICAgIHJldHVybiBhZG0uZGVmaW5lUHJvcGVydHlfKGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnMgPyBhZG0uaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgICAgc2V0OiBjcmVhdGVBY3Rpb24oa2V5LnRvU3RyaW5nKCksIGRlc2NyaXB0b3Iuc2V0KVxuICAgIH0sIHByb3h5VHJhcCk7XG4gIH0gLy8gb3RoZXIgLT4gb2JzZXJ2YWJsZVxuICAvLyBpZiBmdW5jdGlvbiByZXNwZWN0IGF1dG9CaW5kIG9wdGlvblxuXG5cbiAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgKChfdGhpcyRvcHRpb25zXzUgPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc181LmF1dG9CaW5kKSkge1xuICAgIHZhciBfYWRtJHByb3h5XzI7XG5cbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZGVzY3JpcHRvci52YWx1ZS5iaW5kKChfYWRtJHByb3h5XzIgPSBhZG0ucHJveHlfKSAhPSBudWxsID8gX2FkbSRwcm94eV8yIDogYWRtLnRhcmdldF8pO1xuICB9XG5cbiAgdmFyIG9ic2VydmFibGVBbm5vdGF0aW9uID0gKChfdGhpcyRvcHRpb25zXzYgPSB0aGlzLm9wdGlvbnNfKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uc182LmRlZXApID09PSBmYWxzZSA/IG9ic2VydmFibGUucmVmIDogb2JzZXJ2YWJsZTtcbiAgcmV0dXJuIG9ic2VydmFibGVBbm5vdGF0aW9uLmV4dGVuZF8oYWRtLCBrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG59XG5cbnZhciBPQlNFUlZBQkxFID0gXCJvYnNlcnZhYmxlXCI7XG52YXIgT0JTRVJWQUJMRV9SRUYgPSBcIm9ic2VydmFibGUucmVmXCI7XG52YXIgT0JTRVJWQUJMRV9TSEFMTE9XID0gXCJvYnNlcnZhYmxlLnNoYWxsb3dcIjtcbnZhciBPQlNFUlZBQkxFX1NUUlVDVCA9IFwib2JzZXJ2YWJsZS5zdHJ1Y3RcIjsgLy8gUHJlZGVmaW5lZCBiYWdzIG9mIGNyZWF0ZSBvYnNlcnZhYmxlIG9wdGlvbnMsIHRvIGF2b2lkIGFsbG9jYXRpbmcgdGVtcG9yYXJpbHkgb3B0aW9uIG9iamVjdHNcbi8vIGluIHRoZSBtYWpvcml0eSBvZiBjYXNlc1xuXG52YXIgZGVmYXVsdENyZWF0ZU9ic2VydmFibGVPcHRpb25zID0ge1xuICBkZWVwOiB0cnVlLFxuICBuYW1lOiB1bmRlZmluZWQsXG4gIGRlZmF1bHREZWNvcmF0b3I6IHVuZGVmaW5lZCxcbiAgcHJveHk6IHRydWVcbn07XG5PYmplY3QuZnJlZXplKGRlZmF1bHRDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyk7XG5mdW5jdGlvbiBhc0NyZWF0ZU9ic2VydmFibGVPcHRpb25zKHRoaW5nKSB7XG4gIHJldHVybiB0aGluZyB8fCBkZWZhdWx0Q3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnM7XG59XG52YXIgb2JzZXJ2YWJsZUFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oT0JTRVJWQUJMRSk7XG52YXIgb2JzZXJ2YWJsZVJlZkFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oT0JTRVJWQUJMRV9SRUYsIHtcbiAgZW5oYW5jZXI6IHJlZmVyZW5jZUVuaGFuY2VyXG59KTtcbnZhciBvYnNlcnZhYmxlU2hhbGxvd0Fubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlT2JzZXJ2YWJsZUFubm90YXRpb24oT0JTRVJWQUJMRV9TSEFMTE9XLCB7XG4gIGVuaGFuY2VyOiBzaGFsbG93RW5oYW5jZXJcbn0pO1xudmFyIG9ic2VydmFibGVTdHJ1Y3RBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZU9ic2VydmFibGVBbm5vdGF0aW9uKE9CU0VSVkFCTEVfU1RSVUNULCB7XG4gIGVuaGFuY2VyOiByZWZTdHJ1Y3RFbmhhbmNlclxufSk7XG52YXIgb2JzZXJ2YWJsZURlY29yYXRvckFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihvYnNlcnZhYmxlQW5ub3RhdGlvbik7XG5mdW5jdGlvbiBnZXRFbmhhbmNlckZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZGVlcCA9PT0gdHJ1ZSA/IGRlZXBFbmhhbmNlciA6IG9wdGlvbnMuZGVlcCA9PT0gZmFsc2UgPyByZWZlcmVuY2VFbmhhbmNlciA6IGdldEVuaGFuY2VyRnJvbUFubm90YXRpb24ob3B0aW9ucy5kZWZhdWx0RGVjb3JhdG9yKTtcbn1cbmZ1bmN0aW9uIGdldEFubm90YXRpb25Gcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRkZWZhdWx0RGVjb3I7XG5cbiAgcmV0dXJuIG9wdGlvbnMgPyAoX29wdGlvbnMkZGVmYXVsdERlY29yID0gb3B0aW9ucy5kZWZhdWx0RGVjb3JhdG9yKSAhPSBudWxsID8gX29wdGlvbnMkZGVmYXVsdERlY29yIDogY3JlYXRlQXV0b0Fubm90YXRpb24ob3B0aW9ucykgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRFbmhhbmNlckZyb21Bbm5vdGF0aW9uKGFubm90YXRpb24pIHtcbiAgdmFyIF9hbm5vdGF0aW9uJG9wdGlvbnNfJCwgX2Fubm90YXRpb24kb3B0aW9uc187XG5cbiAgcmV0dXJuICFhbm5vdGF0aW9uID8gZGVlcEVuaGFuY2VyIDogKF9hbm5vdGF0aW9uJG9wdGlvbnNfJCA9IChfYW5ub3RhdGlvbiRvcHRpb25zXyA9IGFubm90YXRpb24ub3B0aW9uc18pID09IG51bGwgPyB2b2lkIDAgOiBfYW5ub3RhdGlvbiRvcHRpb25zXy5lbmhhbmNlcikgIT0gbnVsbCA/IF9hbm5vdGF0aW9uJG9wdGlvbnNfJCA6IGRlZXBFbmhhbmNlcjtcbn1cbi8qKlxyXG4gKiBUdXJucyBhbiBvYmplY3QsIGFycmF5IG9yIGZ1bmN0aW9uIGludG8gYSByZWFjdGl2ZSBzdHJ1Y3R1cmUuXHJcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB3aGljaCBzaG91bGQgYmVjb21lIG9ic2VydmFibGUuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlKHYsIGFyZzIsIGFyZzMpIHtcbiAgLy8gQG9ic2VydmFibGUgc29tZVByb3A7XG4gIGlmIChpc1N0cmluZ2lzaChhcmcyKSkge1xuICAgIHN0b3JlQW5ub3RhdGlvbih2LCBhcmcyLCBvYnNlcnZhYmxlQW5ub3RhdGlvbik7XG4gICAgcmV0dXJuO1xuICB9IC8vIGFscmVhZHkgb2JzZXJ2YWJsZSAtIGlnbm9yZVxuXG5cbiAgaWYgKGlzT2JzZXJ2YWJsZSh2KSkgcmV0dXJuIHY7IC8vIHBsYWluIG9iamVjdFxuXG4gIGlmIChpc1BsYWluT2JqZWN0KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5vYmplY3QodiwgYXJnMiwgYXJnMyk7IC8vIEFycmF5XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHJldHVybiBvYnNlcnZhYmxlLmFycmF5KHYsIGFyZzIpOyAvLyBNYXBcblxuICBpZiAoaXNFUzZNYXAodikpIHJldHVybiBvYnNlcnZhYmxlLm1hcCh2LCBhcmcyKTsgLy8gU2V0XG5cbiAgaWYgKGlzRVM2U2V0KHYpKSByZXR1cm4gb2JzZXJ2YWJsZS5zZXQodiwgYXJnMik7IC8vIG90aGVyIG9iamVjdCAtIGlnbm9yZVxuXG4gIGlmICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsKSByZXR1cm4gdjsgLy8gYW55dGhpbmcgZWxzZVxuXG4gIHJldHVybiBvYnNlcnZhYmxlLmJveCh2LCBhcmcyKTtcbn1cblxuT2JqZWN0LmFzc2lnbihjcmVhdGVPYnNlcnZhYmxlLCBvYnNlcnZhYmxlRGVjb3JhdG9yQW5ub3RhdGlvbik7XG52YXIgb2JzZXJ2YWJsZUZhY3RvcmllcyA9IHtcbiAgYm94OiBmdW5jdGlvbiBib3godmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgbyA9IGFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlVmFsdWUodmFsdWUsIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMobyksIG8ubmFtZSwgdHJ1ZSwgby5lcXVhbHMpO1xuICB9LFxuICBhcnJheTogZnVuY3Rpb24gYXJyYXkoaW5pdGlhbFZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBvID0gYXNDcmVhdGVPYnNlcnZhYmxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gKGdsb2JhbFN0YXRlLnVzZVByb3hpZXMgPT09IGZhbHNlIHx8IG8ucHJveHkgPT09IGZhbHNlID8gY3JlYXRlTGVnYWN5QXJyYXkgOiBjcmVhdGVPYnNlcnZhYmxlQXJyYXkpKGluaXRpYWxWYWx1ZXMsIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMobyksIG8ubmFtZSk7XG4gIH0sXG4gIG1hcDogZnVuY3Rpb24gbWFwKGluaXRpYWxWYWx1ZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgbyA9IGFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlTWFwKGluaXRpYWxWYWx1ZXMsIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMobyksIG8ubmFtZSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KGluaXRpYWxWYWx1ZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgbyA9IGFzQ3JlYXRlT2JzZXJ2YWJsZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlU2V0KGluaXRpYWxWYWx1ZXMsIGdldEVuaGFuY2VyRnJvbU9wdGlvbnMobyksIG8ubmFtZSk7XG4gIH0sXG4gIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0KHByb3BzLCBkZWNvcmF0b3JzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGV4dGVuZE9ic2VydmFibGUoZ2xvYmFsU3RhdGUudXNlUHJveGllcyA9PT0gZmFsc2UgfHwgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucHJveHkpID09PSBmYWxzZSA/IGFzT2JzZXJ2YWJsZU9iamVjdCh7fSwgb3B0aW9ucykgOiBhc0R5bmFtaWNPYnNlcnZhYmxlT2JqZWN0KHt9LCBvcHRpb25zKSwgcHJvcHMsIGRlY29yYXRvcnMpO1xuICB9LFxuICByZWY6IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKG9ic2VydmFibGVSZWZBbm5vdGF0aW9uKSxcbiAgc2hhbGxvdzogLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24ob2JzZXJ2YWJsZVNoYWxsb3dBbm5vdGF0aW9uKSxcbiAgZGVlcDogb2JzZXJ2YWJsZURlY29yYXRvckFubm90YXRpb24sXG4gIHN0cnVjdDogLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24ob2JzZXJ2YWJsZVN0cnVjdEFubm90YXRpb24pXG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxudmFyIG9ic2VydmFibGUgPSAvKiNfX1BVUkVfXyovYXNzaWduKGNyZWF0ZU9ic2VydmFibGUsIG9ic2VydmFibGVGYWN0b3JpZXMpO1xuXG52YXIgQ09NUFVURUQgPSBcImNvbXB1dGVkXCI7XG52YXIgQ09NUFVURURfU1RSVUNUID0gXCJjb21wdXRlZC5zdHJ1Y3RcIjtcbnZhciBjb21wdXRlZEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKENPTVBVVEVEKTtcbnZhciBjb21wdXRlZFN0cnVjdEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKENPTVBVVEVEX1NUUlVDVCwge1xuICBlcXVhbHM6IGNvbXBhcmVyLnN0cnVjdHVyYWxcbn0pO1xuLyoqXHJcbiAqIERlY29yYXRvciBmb3IgY2xhc3MgcHJvcGVydGllczogQGNvbXB1dGVkIGdldCB2YWx1ZSgpIHsgcmV0dXJuIGV4cHI7IH0uXHJcbiAqIEZvciBsZWdhY3kgcHVycG9zZXMgYWxzbyBpbnZva2FibGUgYXMgRVM1IG9ic2VydmFibGUgY3JlYXRlZDogYGNvbXB1dGVkKCgpID0+IGV4cHIpYDtcclxuICovXG5cbnZhciBjb21wdXRlZCA9IGZ1bmN0aW9uIGNvbXB1dGVkKGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzU3RyaW5naXNoKGFyZzIpKSB7XG4gICAgLy8gQGNvbXB1dGVkXG4gICAgcmV0dXJuIHN0b3JlQW5ub3RhdGlvbihhcmcxLCBhcmcyLCBjb21wdXRlZEFubm90YXRpb24pO1xuICB9XG5cbiAgaWYgKGlzUGxhaW5PYmplY3QoYXJnMSkpIHtcbiAgICAvLyBAY29tcHV0ZWQoeyBvcHRpb25zIH0pXG4gICAgcmV0dXJuIGNyZWF0ZURlY29yYXRvckFubm90YXRpb24oY3JlYXRlQ29tcHV0ZWRBbm5vdGF0aW9uKENPTVBVVEVELCBhcmcxKSk7XG4gIH0gLy8gY29tcHV0ZWQoZXhwciwgb3B0aW9ucz8pXG5cblxuICB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGFyZzEpKSBkaWUoXCJGaXJzdCBhcmd1bWVudCB0byBgY29tcHV0ZWRgIHNob3VsZCBiZSBhbiBleHByZXNzaW9uLlwiKTtcbiAgICBpZiAoaXNGdW5jdGlvbihhcmcyKSkgZGllKFwiQSBzZXR0ZXIgYXMgc2Vjb25kIGFyZ3VtZW50IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHVzZSBgeyBzZXQ6IGZuIH1gIG9wdGlvbiBpbnN0ZWFkXCIpO1xuICB9XG5cbiAgdmFyIG9wdHMgPSBpc1BsYWluT2JqZWN0KGFyZzIpID8gYXJnMiA6IHt9O1xuICBvcHRzLmdldCA9IGFyZzE7XG4gIG9wdHMubmFtZSB8fCAob3B0cy5uYW1lID0gYXJnMS5uYW1lIHx8IFwiXCIpO1xuICAvKiBmb3IgZ2VuZXJhdGVkIG5hbWUgKi9cblxuICByZXR1cm4gbmV3IENvbXB1dGVkVmFsdWUob3B0cyk7XG59O1xuT2JqZWN0LmFzc2lnbihjb21wdXRlZCwgY29tcHV0ZWRBbm5vdGF0aW9uKTtcbmNvbXB1dGVkLnN0cnVjdCA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGNvbXB1dGVkU3RydWN0QW5ub3RhdGlvbik7XG5cbnZhciBfZ2V0RGVzY3JpcHRvciRjb25maWcsIF9nZXREZXNjcmlwdG9yO1xuLy8gbW9ieCB2ZXJzaW9uc1xuXG52YXIgY3VycmVudEFjdGlvbklkID0gMDtcbnZhciBuZXh0QWN0aW9uSWQgPSAxO1xudmFyIGlzRnVuY3Rpb25OYW1lQ29uZmlndXJhYmxlID0gKF9nZXREZXNjcmlwdG9yJGNvbmZpZyA9IChfZ2V0RGVzY3JpcHRvciA9IC8qI19fUFVSRV9fKi9nZXREZXNjcmlwdG9yKGZ1bmN0aW9uICgpIHt9LCBcIm5hbWVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0RGVzY3JpcHRvci5jb25maWd1cmFibGUpICE9IG51bGwgPyBfZ2V0RGVzY3JpcHRvciRjb25maWcgOiBmYWxzZTsgLy8gd2UgY2FuIHNhZmVseSByZWN5Y2xlIHRoaXMgb2JqZWN0XG5cbnZhciB0bXBOYW1lRGVzY3JpcHRvciA9IHtcbiAgdmFsdWU6IFwiYWN0aW9uXCIsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbihhY3Rpb25OYW1lLCBmbiwgYXV0b0FjdGlvbiwgcmVmKSB7XG4gIGlmIChhdXRvQWN0aW9uID09PSB2b2lkIDApIHtcbiAgICBhdXRvQWN0aW9uID0gZmFsc2U7XG4gIH1cblxuICB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGZuKSkgZGllKFwiYGFjdGlvbmAgY2FuIG9ubHkgYmUgaW52b2tlZCBvbiBmdW5jdGlvbnNcIik7XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25OYW1lICE9PSBcInN0cmluZ1wiIHx8ICFhY3Rpb25OYW1lKSBkaWUoXCJhY3Rpb25zIHNob3VsZCBoYXZlIHZhbGlkIG5hbWVzLCBnb3Q6ICdcIiArIGFjdGlvbk5hbWUgKyBcIidcIik7XG4gIH1cblxuICBmdW5jdGlvbiByZXMoKSB7XG4gICAgcmV0dXJuIGV4ZWN1dGVBY3Rpb24oYWN0aW9uTmFtZSwgYXV0b0FjdGlvbiwgZm4sIHJlZiB8fCB0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmVzLmlzTW9ieEFjdGlvbiA9IHRydWU7XG5cbiAgaWYgKGlzRnVuY3Rpb25OYW1lQ29uZmlndXJhYmxlKSB7XG4gICAgdG1wTmFtZURlc2NyaXB0b3IudmFsdWUgPSBhY3Rpb25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXMsIFwibmFtZVwiLCB0bXBOYW1lRGVzY3JpcHRvcik7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZXhlY3V0ZUFjdGlvbihhY3Rpb25OYW1lLCBjYW5SdW5Bc0Rlcml2YXRpb24sIGZuLCBzY29wZSwgYXJncykge1xuICB2YXIgcnVuSW5mbyA9IF9zdGFydEFjdGlvbihhY3Rpb25OYW1lLCBjYW5SdW5Bc0Rlcml2YXRpb24sIHNjb3BlLCBhcmdzKTtcblxuICB0cnkge1xuICAgIHJldHVybiBmbi5hcHBseShzY29wZSwgYXJncyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJ1bkluZm8uZXJyb3JfID0gZXJyO1xuICAgIHRocm93IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICBfZW5kQWN0aW9uKHJ1bkluZm8pO1xuICB9XG59XG5mdW5jdGlvbiBfc3RhcnRBY3Rpb24oYWN0aW9uTmFtZSwgY2FuUnVuQXNEZXJpdmF0aW9uLCAvLyB0cnVlIGZvciBhdXRvQWN0aW9uXG5zY29wZSwgYXJncykge1xuICB2YXIgbm90aWZ5U3B5XyA9ICBpc1NweUVuYWJsZWQoKSAmJiAhIWFjdGlvbk5hbWU7XG4gIHZhciBzdGFydFRpbWVfID0gMDtcblxuICBpZiAoIG5vdGlmeVNweV8pIHtcbiAgICBzdGFydFRpbWVfID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgZmxhdHRlbmVkQXJncyA9IGFyZ3MgPyBBcnJheS5mcm9tKGFyZ3MpIDogRU1QVFlfQVJSQVk7XG4gICAgc3B5UmVwb3J0U3RhcnQoe1xuICAgICAgdHlwZTogQUNUSU9OLFxuICAgICAgbmFtZTogYWN0aW9uTmFtZSxcbiAgICAgIG9iamVjdDogc2NvcGUsXG4gICAgICBhcmd1bWVudHM6IGZsYXR0ZW5lZEFyZ3NcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwcmV2RGVyaXZhdGlvbl8gPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG4gIHZhciBydW5Bc0FjdGlvbiA9ICFjYW5SdW5Bc0Rlcml2YXRpb24gfHwgIXByZXZEZXJpdmF0aW9uXztcbiAgc3RhcnRCYXRjaCgpO1xuICB2YXIgcHJldkFsbG93U3RhdGVDaGFuZ2VzXyA9IGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzOyAvLyBieSBkZWZhdWx0IHByZXNlcnZlIHByZXZpb3VzIGFsbG93XG5cbiAgaWYgKHJ1bkFzQWN0aW9uKSB7XG4gICAgdW50cmFja2VkU3RhcnQoKTtcbiAgICBwcmV2QWxsb3dTdGF0ZUNoYW5nZXNfID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydCh0cnVlKTtcbiAgfVxuXG4gIHZhciBwcmV2QWxsb3dTdGF0ZVJlYWRzXyA9IGFsbG93U3RhdGVSZWFkc1N0YXJ0KHRydWUpO1xuICB2YXIgcnVuSW5mbyA9IHtcbiAgICBydW5Bc0FjdGlvbl86IHJ1bkFzQWN0aW9uLFxuICAgIHByZXZEZXJpdmF0aW9uXzogcHJldkRlcml2YXRpb25fLFxuICAgIHByZXZBbGxvd1N0YXRlQ2hhbmdlc186IHByZXZBbGxvd1N0YXRlQ2hhbmdlc18sXG4gICAgcHJldkFsbG93U3RhdGVSZWFkc186IHByZXZBbGxvd1N0YXRlUmVhZHNfLFxuICAgIG5vdGlmeVNweV86IG5vdGlmeVNweV8sXG4gICAgc3RhcnRUaW1lXzogc3RhcnRUaW1lXyxcbiAgICBhY3Rpb25JZF86IG5leHRBY3Rpb25JZCsrLFxuICAgIHBhcmVudEFjdGlvbklkXzogY3VycmVudEFjdGlvbklkXG4gIH07XG4gIGN1cnJlbnRBY3Rpb25JZCA9IHJ1bkluZm8uYWN0aW9uSWRfO1xuICByZXR1cm4gcnVuSW5mbztcbn1cbmZ1bmN0aW9uIF9lbmRBY3Rpb24ocnVuSW5mbykge1xuICBpZiAoY3VycmVudEFjdGlvbklkICE9PSBydW5JbmZvLmFjdGlvbklkXykge1xuICAgIGRpZSgzMCk7XG4gIH1cblxuICBjdXJyZW50QWN0aW9uSWQgPSBydW5JbmZvLnBhcmVudEFjdGlvbklkXztcblxuICBpZiAocnVuSW5mby5lcnJvcl8gIT09IHVuZGVmaW5lZCkge1xuICAgIGdsb2JhbFN0YXRlLnN1cHByZXNzUmVhY3Rpb25FcnJvcnMgPSB0cnVlO1xuICB9XG5cbiAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocnVuSW5mby5wcmV2QWxsb3dTdGF0ZUNoYW5nZXNfKTtcbiAgYWxsb3dTdGF0ZVJlYWRzRW5kKHJ1bkluZm8ucHJldkFsbG93U3RhdGVSZWFkc18pO1xuICBlbmRCYXRjaCgpO1xuICBpZiAocnVuSW5mby5ydW5Bc0FjdGlvbl8pIHVudHJhY2tlZEVuZChydW5JbmZvLnByZXZEZXJpdmF0aW9uXyk7XG5cbiAgaWYgKCBydW5JbmZvLm5vdGlmeVNweV8pIHtcbiAgICBzcHlSZXBvcnRFbmQoe1xuICAgICAgdGltZTogRGF0ZS5ub3coKSAtIHJ1bkluZm8uc3RhcnRUaW1lX1xuICAgIH0pO1xuICB9XG5cbiAgZ2xvYmFsU3RhdGUuc3VwcHJlc3NSZWFjdGlvbkVycm9ycyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZUNoYW5nZXMoYWxsb3dTdGF0ZUNoYW5nZXMsIGZ1bmMpIHtcbiAgdmFyIHByZXYgPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KGFsbG93U3RhdGVDaGFuZ2VzKTtcblxuICB0cnkge1xuICAgIHJldHVybiBmdW5jKCk7XG4gIH0gZmluYWxseSB7XG4gICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XG4gIH1cbn1cbmZ1bmN0aW9uIGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQoYWxsb3dTdGF0ZUNoYW5nZXMpIHtcbiAgdmFyIHByZXYgPSBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcztcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSBhbGxvd1N0YXRlQ2hhbmdlcztcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBhbGxvd1N0YXRlQ2hhbmdlc0VuZChwcmV2KSB7XG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gcHJldjtcbn1cblxudmFyIF9TeW1ib2wkdG9QcmltaXRpdmU7XG52YXIgQ1JFQVRFID0gXCJjcmVhdGVcIjtcbl9TeW1ib2wkdG9QcmltaXRpdmUgPSBTeW1ib2wudG9QcmltaXRpdmU7XG52YXIgT2JzZXJ2YWJsZVZhbHVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQXRvbSkge1xuICBfaW5oZXJpdHNMb29zZShPYnNlcnZhYmxlVmFsdWUsIF9BdG9tKTtcblxuICBmdW5jdGlvbiBPYnNlcnZhYmxlVmFsdWUodmFsdWUsIGVuaGFuY2VyLCBuYW1lXywgbm90aWZ5U3B5LCBlcXVhbHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSAgXCJPYnNlcnZhYmxlVmFsdWVAXCIgKyBnZXROZXh0SWQoKSA7XG4gICAgfVxuXG4gICAgaWYgKG5vdGlmeVNweSA9PT0gdm9pZCAwKSB7XG4gICAgICBub3RpZnlTcHkgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChlcXVhbHMgPT09IHZvaWQgMCkge1xuICAgICAgZXF1YWxzID0gY29tcGFyZXJbXCJkZWZhdWx0XCJdO1xuICAgIH1cblxuICAgIF90aGlzID0gX0F0b20uY2FsbCh0aGlzLCBuYW1lXykgfHwgdGhpcztcbiAgICBfdGhpcy5lbmhhbmNlciA9IHZvaWQgMDtcbiAgICBfdGhpcy5uYW1lXyA9IHZvaWQgMDtcbiAgICBfdGhpcy5lcXVhbHMgPSB2b2lkIDA7XG4gICAgX3RoaXMuaGFzVW5yZXBvcnRlZENoYW5nZV8gPSBmYWxzZTtcbiAgICBfdGhpcy5pbnRlcmNlcHRvcnNfID0gdm9pZCAwO1xuICAgIF90aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgX3RoaXMudmFsdWVfID0gdm9pZCAwO1xuICAgIF90aGlzLmRlaGFuY2VyID0gdm9pZCAwO1xuICAgIF90aGlzLmVuaGFuY2VyID0gZW5oYW5jZXI7XG4gICAgX3RoaXMubmFtZV8gPSBuYW1lXztcbiAgICBfdGhpcy5lcXVhbHMgPSBlcXVhbHM7XG4gICAgX3RoaXMudmFsdWVfID0gZW5oYW5jZXIodmFsdWUsIHVuZGVmaW5lZCwgbmFtZV8pO1xuXG4gICAgaWYgKCBub3RpZnlTcHkgJiYgaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgIC8vIG9ubHkgbm90aWZ5IHNweSBpZiB0aGlzIGlzIGEgc3RhbmQtYWxvbmUgb2JzZXJ2YWJsZVxuICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgdHlwZTogQ1JFQVRFLFxuICAgICAgICBvYmplY3Q6IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLFxuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJ2YWx1ZVwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IF90aGlzLm5hbWVfLFxuICAgICAgICBuZXdWYWx1ZTogXCJcIiArIF90aGlzLnZhbHVlX1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVWYWx1ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRlaGFuY2VWYWx1ZSA9IGZ1bmN0aW9uIGRlaGFuY2VWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgIG5ld1ZhbHVlID0gdGhpcy5wcmVwYXJlTmV3VmFsdWVfKG5ld1ZhbHVlKTtcblxuICAgIGlmIChuZXdWYWx1ZSAhPT0gZ2xvYmFsU3RhdGUuVU5DSEFOR0VEKSB7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gaXNTcHlFbmFibGVkKCk7XG5cbiAgICAgIGlmICggbm90aWZ5U3B5KSB7XG4gICAgICAgIHNweVJlcG9ydFN0YXJ0KHtcbiAgICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICAgIG9ic2VydmFibGVLaW5kOiBcInZhbHVlXCIsXG4gICAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0TmV3VmFsdWVfKG5ld1ZhbHVlKTtcbiAgICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRFbmQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnByZXBhcmVOZXdWYWx1ZV8gPSBmdW5jdGlvbiBwcmVwYXJlTmV3VmFsdWVfKG5ld1ZhbHVlKSB7XG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcyk7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIGdsb2JhbFN0YXRlLlVOQ0hBTkdFRDtcbiAgICAgIG5ld1ZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgIH0gLy8gYXBwbHkgbW9kaWZpZXJcblxuXG4gICAgbmV3VmFsdWUgPSB0aGlzLmVuaGFuY2VyKG5ld1ZhbHVlLCB0aGlzLnZhbHVlXywgdGhpcy5uYW1lXyk7XG4gICAgcmV0dXJuIHRoaXMuZXF1YWxzKHRoaXMudmFsdWVfLCBuZXdWYWx1ZSkgPyBnbG9iYWxTdGF0ZS5VTkNIQU5HRUQgOiBuZXdWYWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uc2V0TmV3VmFsdWVfID0gZnVuY3Rpb24gc2V0TmV3VmFsdWVfKG5ld1ZhbHVlKSB7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZV87XG4gICAgdGhpcy52YWx1ZV8gPSBuZXdWYWx1ZTtcbiAgICB0aGlzLnJlcG9ydENoYW5nZWQoKTtcblxuICAgIGlmIChoYXNMaXN0ZW5lcnModGhpcykpIHtcbiAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCB7XG4gICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdGhpcy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZSh0aGlzLnZhbHVlXyk7XG4gIH07XG5cbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcblxuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgaWYgKGZpcmVJbW1lZGlhdGVseSkgbGlzdGVuZXIoe1xuICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwidmFsdWVcIixcbiAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgIG5ld1ZhbHVlOiB0aGlzLnZhbHVlXyxcbiAgICAgIG9sZFZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgICByZXR1cm4gcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBsaXN0ZW5lcik7XG4gIH07XG5cbiAgX3Byb3RvLnJhdyA9IGZ1bmN0aW9uIHJhdygpIHtcbiAgICAvLyB1c2VkIGJ5IE1TVCBvdCBnZXQgdW5kZWhhbmNlZCB2YWx1ZVxuICAgIHJldHVybiB0aGlzLnZhbHVlXztcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVfICsgXCJbXCIgKyB0aGlzLnZhbHVlXyArIFwiXVwiO1xuICB9O1xuXG4gIF9wcm90by52YWx1ZU9mID0gZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICByZXR1cm4gdG9QcmltaXRpdmUodGhpcy5nZXQoKSk7XG4gIH07XG5cbiAgX3Byb3RvW19TeW1ib2wkdG9QcmltaXRpdmVdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcbiAgfTtcblxuICByZXR1cm4gT2JzZXJ2YWJsZVZhbHVlO1xufShBdG9tKTtcbnZhciBpc09ic2VydmFibGVWYWx1ZSA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZVZhbHVlXCIsIE9ic2VydmFibGVWYWx1ZSk7XG5cbnZhciBfU3ltYm9sJHRvUHJpbWl0aXZlJDE7XG4vKipcclxuICogQSBub2RlIGluIHRoZSBzdGF0ZSBkZXBlbmRlbmN5IHJvb3QgdGhhdCBvYnNlcnZlcyBvdGhlciBub2RlcywgYW5kIGNhbiBiZSBvYnNlcnZlZCBpdHNlbGYuXHJcbiAqXHJcbiAqIENvbXB1dGVkVmFsdWUgd2lsbCByZW1lbWJlciB0aGUgcmVzdWx0IG9mIHRoZSBjb21wdXRhdGlvbiBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBiYXRjaCwgb3JcclxuICogd2hpbGUgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAqXHJcbiAqIER1cmluZyB0aGlzIHRpbWUgaXQgd2lsbCByZWNvbXB1dGUgb25seSB3aGVuIG9uZSBvZiBpdHMgZGlyZWN0IGRlcGVuZGVuY2llcyBjaGFuZ2VkLFxyXG4gKiBidXQgb25seSB3aGVuIGl0IGlzIGJlaW5nIGFjY2Vzc2VkIHdpdGggYENvbXB1dGVkVmFsdWUuZ2V0KClgLlxyXG4gKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBkZXNjcmlwdGlvbjpcclxuICogMS4gRmlyc3QgdGltZSBpdCdzIGJlaW5nIGFjY2Vzc2VkIGl0IHdpbGwgY29tcHV0ZSBhbmQgcmVtZW1iZXIgcmVzdWx0XHJcbiAqICAgIGdpdmUgYmFjayByZW1lbWJlcmVkIHJlc3VsdCB1bnRpbCAyLiBoYXBwZW5zXHJcbiAqIDIuIEZpcnN0IHRpbWUgYW55IGRlZXAgZGVwZW5kZW5jeSBjaGFuZ2UsIHByb3BhZ2F0ZSBQT1NTSUJMWV9TVEFMRSB0byBhbGwgb2JzZXJ2ZXJzLCB3YWl0IGZvciAzLlxyXG4gKiAzLiBXaGVuIGl0J3MgYmVpbmcgYWNjZXNzZWQsIHJlY29tcHV0ZSBpZiBhbnkgc2hhbGxvdyBkZXBlbmRlbmN5IGNoYW5nZWQuXHJcbiAqICAgIGlmIHJlc3VsdCBjaGFuZ2VkOiBwcm9wYWdhdGUgU1RBTEUgdG8gYWxsIG9ic2VydmVycywgdGhhdCB3ZXJlIFBPU1NJQkxZX1NUQUxFIGZyb20gdGhlIGxhc3Qgc3RlcC5cclxuICogICAgZ28gdG8gc3RlcCAyLiBlaXRoZXIgd2F5XHJcbiAqXHJcbiAqIElmIGF0IGFueSBwb2ludCBpdCdzIG91dHNpZGUgYmF0Y2ggYW5kIGl0IGlzbid0IG9ic2VydmVkOiByZXNldCBldmVyeXRoaW5nIGFuZCBnbyB0byAxLlxyXG4gKi9cblxuX1N5bWJvbCR0b1ByaW1pdGl2ZSQxID0gU3ltYm9sLnRvUHJpbWl0aXZlO1xudmFyIENvbXB1dGVkVmFsdWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvLyBub2RlcyB3ZSBhcmUgbG9va2luZyBhdC4gT3VyIHZhbHVlIGRlcGVuZHMgb24gdGhlc2Ugbm9kZXNcbiAgLy8gZHVyaW5nIHRyYWNraW5nIGl0J3MgYW4gYXJyYXkgd2l0aCBuZXcgb2JzZXJ2ZWQgb2JzZXJ2ZXJzXG4gIC8vIHRvIGNoZWNrIGZvciBjeWNsZXNcbiAgLy8gTi5COiB1bm1pbmlmaWVkIGFzIGl0IGlzIHVzZWQgYnkgTVNUXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGNvbXB1dGVkIHZhbHVlIGJhc2VkIG9uIGEgZnVuY3Rpb24gZXhwcmVzc2lvbi5cclxuICAgKlxyXG4gICAqIFRoZSBgbmFtZWAgcHJvcGVydHkgaXMgZm9yIGRlYnVnIHB1cnBvc2VzIG9ubHkuXHJcbiAgICpcclxuICAgKiBUaGUgYGVxdWFsc2AgcHJvcGVydHkgc3BlY2lmaWVzIHRoZSBjb21wYXJlciBmdW5jdGlvbiB0byB1c2UgdG8gZGV0ZXJtaW5lIGlmIGEgbmV3bHkgcHJvZHVjZWRcclxuICAgKiB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHByZXZpb3VzIHZhbHVlLiBUd28gY29tcGFyZXJzIGFyZSBwcm92aWRlZCBpbiB0aGUgbGlicmFyeTsgYGRlZmF1bHRDb21wYXJlcmBcclxuICAgKiBjb21wYXJlcyBiYXNlZCBvbiBpZGVudGl0eSBjb21wYXJpc29uICg9PT0pLCBhbmQgYHN0cnVjdHVyYWxDb21wYXJlcmAgZGVlcGx5IGNvbXBhcmVzIHRoZSBzdHJ1Y3R1cmUuXHJcbiAgICogU3RydWN0dXJhbCBjb21wYXJpc29uIGNhbiBiZSBjb252ZW5pZW50IGlmIHlvdSBhbHdheXMgcHJvZHVjZSBhIG5ldyBhZ2dyZWdhdGVkIG9iamVjdCBhbmRcclxuICAgKiBkb24ndCB3YW50IHRvIG5vdGlmeSBvYnNlcnZlcnMgaWYgaXQgaXMgc3RydWN0dXJhbGx5IHRoZSBzYW1lLlxyXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciB3b3JraW5nIHdpdGggdmVjdG9ycywgbW91c2UgY29vcmRpbmF0ZXMgZXRjLlxyXG4gICAqL1xuICBmdW5jdGlvbiBDb21wdXRlZFZhbHVlKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG4gICAgdGhpcy5vYnNlcnZpbmdfID0gW107XG4gICAgdGhpcy5uZXdPYnNlcnZpbmdfID0gbnVsbDtcbiAgICB0aGlzLmlzQmVpbmdPYnNlcnZlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmlzUGVuZGluZ1Vub2JzZXJ2YXRpb25fID0gZmFsc2U7XG4gICAgdGhpcy5vYnNlcnZlcnNfID0gbmV3IFNldCgpO1xuICAgIHRoaXMuZGlmZlZhbHVlXyA9IDA7XG4gICAgdGhpcy5ydW5JZF8gPSAwO1xuICAgIHRoaXMubGFzdEFjY2Vzc2VkQnlfID0gMDtcbiAgICB0aGlzLmxvd2VzdE9ic2VydmVyU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV87XG4gICAgdGhpcy51bmJvdW5kRGVwc0NvdW50XyA9IDA7XG4gICAgdGhpcy52YWx1ZV8gPSBuZXcgQ2F1Z2h0RXhjZXB0aW9uKG51bGwpO1xuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy50cmlnZ2VyZWRCeV8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc0NvbXB1dGluZ18gPSBmYWxzZTtcbiAgICB0aGlzLmlzUnVubmluZ1NldHRlcl8gPSBmYWxzZTtcbiAgICB0aGlzLmRlcml2YXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5zZXR0ZXJfID0gdm9pZCAwO1xuICAgIHRoaXMuaXNUcmFjaW5nXyA9IFRyYWNlTW9kZS5OT05FO1xuICAgIHRoaXMuc2NvcGVfID0gdm9pZCAwO1xuICAgIHRoaXMuZXF1YWxzXyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlcXVpcmVzUmVhY3Rpb25fID0gdm9pZCAwO1xuICAgIHRoaXMua2VlcEFsaXZlXyA9IHZvaWQgMDtcbiAgICB0aGlzLm9uQk9MID0gdm9pZCAwO1xuICAgIHRoaXMub25CVU9MID0gdm9pZCAwO1xuICAgIGlmICghb3B0aW9ucy5nZXQpIGRpZSgzMSk7XG4gICAgdGhpcy5kZXJpdmF0aW9uID0gb3B0aW9ucy5nZXQ7XG4gICAgdGhpcy5uYW1lXyA9IG9wdGlvbnMubmFtZSB8fCAoIFwiQ29tcHV0ZWRWYWx1ZUBcIiArIGdldE5leHRJZCgpICk7XG5cbiAgICBpZiAob3B0aW9ucy5zZXQpIHtcbiAgICAgIHRoaXMuc2V0dGVyXyA9IGNyZWF0ZUFjdGlvbiggdGhpcy5uYW1lXyArIFwiLXNldHRlclwiICwgb3B0aW9ucy5zZXQpO1xuICAgIH1cblxuICAgIHRoaXMuZXF1YWxzXyA9IG9wdGlvbnMuZXF1YWxzIHx8IChvcHRpb25zLmNvbXBhcmVTdHJ1Y3R1cmFsIHx8IG9wdGlvbnMuc3RydWN0ID8gY29tcGFyZXIuc3RydWN0dXJhbCA6IGNvbXBhcmVyW1wiZGVmYXVsdFwiXSk7XG4gICAgdGhpcy5zY29wZV8gPSBvcHRpb25zLmNvbnRleHQ7XG4gICAgdGhpcy5yZXF1aXJlc1JlYWN0aW9uXyA9ICEhb3B0aW9ucy5yZXF1aXJlc1JlYWN0aW9uO1xuICAgIHRoaXMua2VlcEFsaXZlXyA9ICEhb3B0aW9ucy5rZWVwQWxpdmU7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ29tcHV0ZWRWYWx1ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9uQmVjb21lU3RhbGVfID0gZnVuY3Rpb24gb25CZWNvbWVTdGFsZV8oKSB7XG4gICAgcHJvcGFnYXRlTWF5YmVDaGFuZ2VkKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vbkJPID0gZnVuY3Rpb24gb25CTygpIHtcbiAgICBpZiAodGhpcy5vbkJPTCkge1xuICAgICAgdGhpcy5vbkJPTC5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25CVU8gPSBmdW5jdGlvbiBvbkJVTygpIHtcbiAgICBpZiAodGhpcy5vbkJVT0wpIHtcbiAgICAgIHRoaXMub25CVU9MLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcyBjb21wdXRlZCB2YWx1ZS5cclxuICAgKiBXaWxsIGV2YWx1YXRlIGl0cyBjb21wdXRhdGlvbiBmaXJzdCBpZiBuZWVkZWQuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLmlzQ29tcHV0aW5nXykgZGllKDMyLCB0aGlzLm5hbWVfLCB0aGlzLmRlcml2YXRpb24pO1xuXG4gICAgaWYgKGdsb2JhbFN0YXRlLmluQmF0Y2ggPT09IDAgJiYgLy8gIWdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdHBpb24gJiZcbiAgICB0aGlzLm9ic2VydmVyc18uc2l6ZSA9PT0gMCAmJiAhdGhpcy5rZWVwQWxpdmVfKSB7XG4gICAgICBpZiAoc2hvdWxkQ29tcHV0ZSh0aGlzKSkge1xuICAgICAgICB0aGlzLndhcm5BYm91dFVudHJhY2tlZFJlYWRfKCk7XG4gICAgICAgIHN0YXJ0QmF0Y2goKTsgLy8gU2VlIHBlcmYgdGVzdCAnY29tcHV0ZWQgbWVtb2l6YXRpb24nXG5cbiAgICAgICAgdGhpcy52YWx1ZV8gPSB0aGlzLmNvbXB1dGVWYWx1ZV8oZmFsc2UpO1xuICAgICAgICBlbmRCYXRjaCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXBvcnRPYnNlcnZlZCh0aGlzKTtcblxuICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpIHtcbiAgICAgICAgdmFyIHByZXZUcmFja2luZ0NvbnRleHQgPSBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQ7XG4gICAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZV8gJiYgIXByZXZUcmFja2luZ0NvbnRleHQpIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrQW5kQ29tcHV0ZSgpKSBwcm9wYWdhdGVDaGFuZ2VDb25maXJtZWQodGhpcyk7XG4gICAgICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHByZXZUcmFja2luZ0NvbnRleHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMudmFsdWVfO1xuICAgIGlmIChpc0NhdWdodEV4Y2VwdGlvbihyZXN1bHQpKSB0aHJvdyByZXN1bHQuY2F1c2U7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc2V0dGVyXykge1xuICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nU2V0dGVyXykgZGllKDMzLCB0aGlzLm5hbWVfKTtcbiAgICAgIHRoaXMuaXNSdW5uaW5nU2V0dGVyXyA9IHRydWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2V0dGVyXy5jYWxsKHRoaXMuc2NvcGVfLCB2YWx1ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmlzUnVubmluZ1NldHRlcl8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgZGllKDM0LCB0aGlzLm5hbWVfKTtcbiAgfTtcblxuICBfcHJvdG8udHJhY2tBbmRDb21wdXRlID0gZnVuY3Rpb24gdHJhY2tBbmRDb21wdXRlKCkge1xuICAgIC8vIE4uQjogdW5taW5pZmllZCBhcyBpdCBpcyB1c2VkIGJ5IE1TVFxuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgIHZhciB3YXNTdXNwZW5kZWQgPVxuICAgIC8qIHNlZSAjMTIwOCAqL1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfO1xuICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuY29tcHV0ZVZhbHVlXyh0cnVlKTtcblxuICAgIGlmICggaXNTcHlFbmFibGVkKCkpIHtcbiAgICAgIHNweVJlcG9ydCh7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcImNvbXB1dGVkXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgb2JqZWN0OiB0aGlzLnNjb3BlXyxcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgb2xkVmFsdWU6IHRoaXMudmFsdWVfLFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBjaGFuZ2VkID0gd2FzU3VzcGVuZGVkIHx8IGlzQ2F1Z2h0RXhjZXB0aW9uKG9sZFZhbHVlKSB8fCBpc0NhdWdodEV4Y2VwdGlvbihuZXdWYWx1ZSkgfHwgIXRoaXMuZXF1YWxzXyhvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMudmFsdWVfID0gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXB1dGVWYWx1ZV8gPSBmdW5jdGlvbiBjb21wdXRlVmFsdWVfKHRyYWNrKSB7XG4gICAgdGhpcy5pc0NvbXB1dGluZ18gPSB0cnVlOyAvLyBkb24ndCBhbGxvdyBzdGF0ZSBjaGFuZ2VzIGR1cmluZyBjb21wdXRhdGlvblxuXG4gICAgdmFyIHByZXYgPSBhbGxvd1N0YXRlQ2hhbmdlc1N0YXJ0KGZhbHNlKTtcbiAgICB2YXIgcmVzO1xuXG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXMgPSB0cmFja0Rlcml2ZWRGdW5jdGlvbih0aGlzLCB0aGlzLmRlcml2YXRpb24sIHRoaXMuc2NvcGVfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMgPT09IHRydWUpIHtcbiAgICAgICAgcmVzID0gdGhpcy5kZXJpdmF0aW9uLmNhbGwodGhpcy5zY29wZV8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSB0aGlzLmRlcml2YXRpb24uY2FsbCh0aGlzLnNjb3BlXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXMgPSBuZXcgQ2F1Z2h0RXhjZXB0aW9uKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XG4gICAgdGhpcy5pc0NvbXB1dGluZ18gPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIF9wcm90by5zdXNwZW5kXyA9IGZ1bmN0aW9uIHN1c3BlbmRfKCkge1xuICAgIGlmICghdGhpcy5rZWVwQWxpdmVfKSB7XG4gICAgICBjbGVhck9ic2VydmluZyh0aGlzKTtcbiAgICAgIHRoaXMudmFsdWVfID0gdW5kZWZpbmVkOyAvLyBkb24ndCBob2xkIG9uIHRvIGNvbXB1dGVkIHZhbHVlIVxuXG4gICAgICBpZiAoIHRoaXMuaXNUcmFjaW5nXyAhPT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbbW9ieC50cmFjZV0gQ29tcHV0ZWQgdmFsdWUgJ1wiICsgdGhpcy5uYW1lXyArIFwiJyB3YXMgc3VzcGVuZGVkIGFuZCBpdCB3aWxsIHJlY29tcHV0ZSBvbiB0aGUgbmV4dCBhY2Nlc3MuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuICAgIHZhciBwcmV2VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGF1dG9ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogd2h5IGlzIHRoaXMgaW4gYSBkaWZmZXJlbnQgcGxhY2UgdGhhbiB0aGUgc3B5UmVwb3J0KCkgZnVuY3Rpb24/IGluIGFsbCBvdGhlciBvYnNlcnZhYmxlcyBpdCdzIGNhbGxlZCBpbiB0aGUgc2FtZSBwbGFjZVxuICAgICAgdmFyIG5ld1ZhbHVlID0gX3RoaXMuZ2V0KCk7XG5cbiAgICAgIGlmICghZmlyc3RUaW1lIHx8IGZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgICB2YXIgcHJldlUgPSB1bnRyYWNrZWRTdGFydCgpO1xuICAgICAgICBsaXN0ZW5lcih7XG4gICAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwiY29tcHV0ZWRcIixcbiAgICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IF90aGlzLm5hbWVfLFxuICAgICAgICAgIHR5cGU6IFVQREFURSxcbiAgICAgICAgICBvYmplY3Q6IF90aGlzLFxuICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICBvbGRWYWx1ZTogcHJldlZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB1bnRyYWNrZWRFbmQocHJldlUpO1xuICAgICAgfVxuXG4gICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgIHByZXZWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by53YXJuQWJvdXRVbnRyYWNrZWRSZWFkXyA9IGZ1bmN0aW9uIHdhcm5BYm91dFVudHJhY2tlZFJlYWRfKCkge1xuXG4gICAgaWYgKHRoaXMuaXNUcmFjaW5nXyAhPT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdIENvbXB1dGVkIHZhbHVlICdcIiArIHRoaXMubmFtZV8gKyBcIicgaXMgYmVpbmcgcmVhZCBvdXRzaWRlIGEgcmVhY3RpdmUgY29udGV4dC4gRG9pbmcgYSBmdWxsIHJlY29tcHV0ZS5cIik7XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbFN0YXRlLmNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvbiB8fCB0aGlzLnJlcXVpcmVzUmVhY3Rpb25fKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbbW9ieF0gQ29tcHV0ZWQgdmFsdWUgJ1wiICsgdGhpcy5uYW1lXyArIFwiJyBpcyBiZWluZyByZWFkIG91dHNpZGUgYSByZWFjdGl2ZSBjb250ZXh0LiBEb2luZyBhIGZ1bGwgcmVjb21wdXRlLlwiKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZV8gKyBcIltcIiArIHRoaXMuZGVyaXZhdGlvbi50b1N0cmluZygpICsgXCJdXCI7XG4gIH07XG5cbiAgX3Byb3RvLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0b1ByaW1pdGl2ZSh0aGlzLmdldCgpKTtcbiAgfTtcblxuICBfcHJvdG9bX1N5bWJvbCR0b1ByaW1pdGl2ZSQxXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG4gIH07XG5cbiAgcmV0dXJuIENvbXB1dGVkVmFsdWU7XG59KCk7XG52YXIgaXNDb21wdXRlZFZhbHVlID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJDb21wdXRlZFZhbHVlXCIsIENvbXB1dGVkVmFsdWUpO1xuXG52YXIgSURlcml2YXRpb25TdGF0ZV87XG5cbihmdW5jdGlvbiAoSURlcml2YXRpb25TdGF0ZV8pIHtcbiAgLy8gYmVmb3JlIGJlaW5nIHJ1biBvciAob3V0c2lkZSBiYXRjaCBhbmQgbm90IGJlaW5nIG9ic2VydmVkKVxuICAvLyBhdCB0aGlzIHBvaW50IGRlcml2YXRpb24gaXMgbm90IGhvbGRpbmcgYW55IGRhdGEgYWJvdXQgZGVwZW5kZW5jeSB0cmVlXG4gIElEZXJpdmF0aW9uU3RhdGVfW0lEZXJpdmF0aW9uU3RhdGVfW1wiTk9UX1RSQUNLSU5HX1wiXSA9IC0xXSA9IFwiTk9UX1RSQUNLSU5HX1wiOyAvLyBubyBzaGFsbG93IGRlcGVuZGVuY3kgY2hhbmdlZCBzaW5jZSBsYXN0IGNvbXB1dGF0aW9uXG4gIC8vIHdvbid0IHJlY2FsY3VsYXRlIGRlcml2YXRpb25cbiAgLy8gdGhpcyBpcyB3aGF0IG1ha2VzIG1vYnggZmFzdFxuXG4gIElEZXJpdmF0aW9uU3RhdGVfW0lEZXJpdmF0aW9uU3RhdGVfW1wiVVBfVE9fREFURV9cIl0gPSAwXSA9IFwiVVBfVE9fREFURV9cIjsgLy8gc29tZSBkZWVwIGRlcGVuZGVuY3kgY2hhbmdlZCwgYnV0IGRvbid0IGtub3cgaWYgc2hhbGxvdyBkZXBlbmRlbmN5IGNoYW5nZWRcbiAgLy8gd2lsbCByZXF1aXJlIHRvIGNoZWNrIGZpcnN0IGlmIFVQX1RPX0RBVEUgb3IgUE9TU0lCTFlfU1RBTEVcbiAgLy8gY3VycmVudGx5IG9ubHkgQ29tcHV0ZWRWYWx1ZSB3aWxsIHByb3BhZ2F0ZSBQT1NTSUJMWV9TVEFMRVxuICAvL1xuICAvLyBoYXZpbmcgdGhpcyBzdGF0ZSBpcyBzZWNvbmQgYmlnIG9wdGltaXphdGlvbjpcbiAgLy8gZG9uJ3QgaGF2ZSB0byByZWNvbXB1dGUgb24gZXZlcnkgZGVwZW5kZW5jeSBjaGFuZ2UsIGJ1dCBvbmx5IHdoZW4gaXQncyBuZWVkZWRcblxuICBJRGVyaXZhdGlvblN0YXRlX1tJRGVyaXZhdGlvblN0YXRlX1tcIlBPU1NJQkxZX1NUQUxFX1wiXSA9IDFdID0gXCJQT1NTSUJMWV9TVEFMRV9cIjsgLy8gQSBzaGFsbG93IGRlcGVuZGVuY3kgaGFzIGNoYW5nZWQgc2luY2UgbGFzdCBjb21wdXRhdGlvbiBhbmQgdGhlIGRlcml2YXRpb25cbiAgLy8gd2lsbCBuZWVkIHRvIHJlY29tcHV0ZSB3aGVuIGl0J3MgbmVlZGVkIG5leHQuXG5cbiAgSURlcml2YXRpb25TdGF0ZV9bSURlcml2YXRpb25TdGF0ZV9bXCJTVEFMRV9cIl0gPSAyXSA9IFwiU1RBTEVfXCI7XG59KShJRGVyaXZhdGlvblN0YXRlXyB8fCAoSURlcml2YXRpb25TdGF0ZV8gPSB7fSkpO1xuXG52YXIgVHJhY2VNb2RlO1xuXG4oZnVuY3Rpb24gKFRyYWNlTW9kZSkge1xuICBUcmFjZU1vZGVbVHJhY2VNb2RlW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gIFRyYWNlTW9kZVtUcmFjZU1vZGVbXCJMT0dcIl0gPSAxXSA9IFwiTE9HXCI7XG4gIFRyYWNlTW9kZVtUcmFjZU1vZGVbXCJCUkVBS1wiXSA9IDJdID0gXCJCUkVBS1wiO1xufSkoVHJhY2VNb2RlIHx8IChUcmFjZU1vZGUgPSB7fSkpO1xuXG52YXIgQ2F1Z2h0RXhjZXB0aW9uID0gZnVuY3Rpb24gQ2F1Z2h0RXhjZXB0aW9uKGNhdXNlKSB7XG4gIHRoaXMuY2F1c2UgPSB2b2lkIDA7XG4gIHRoaXMuY2F1c2UgPSBjYXVzZTsgLy8gRW1wdHlcbn07XG5mdW5jdGlvbiBpc0NhdWdodEV4Y2VwdGlvbihlKSB7XG4gIHJldHVybiBlIGluc3RhbmNlb2YgQ2F1Z2h0RXhjZXB0aW9uO1xufVxuLyoqXHJcbiAqIEZpbmRzIG91dCB3aGV0aGVyIGFueSBkZXBlbmRlbmN5IG9mIHRoZSBkZXJpdmF0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxyXG4gKiBJZiBkZXBlbmRlbmNpZXNTdGF0ZSBpcyAxIHRoZW4gaXQgd2lsbCByZWNhbGN1bGF0ZSBkZXBlbmRlbmNpZXMsXHJcbiAqIGlmIGFueSBkZXBlbmRlbmN5IGNoYW5nZWQgaXQgd2lsbCBwcm9wYWdhdGUgaXQgYnkgY2hhbmdpbmcgZGVwZW5kZW5jaWVzU3RhdGUgdG8gMi5cclxuICpcclxuICogQnkgaXRlcmF0aW5nIG92ZXIgdGhlIGRlcGVuZGVuY2llcyBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgd2VyZSByZXBvcnRlZCBhbmRcclxuICogc3RvcHBpbmcgb24gdGhlIGZpcnN0IGNoYW5nZSwgYWxsIHRoZSByZWNhbGN1bGF0aW9ucyBhcmUgb25seSBjYWxsZWQgZm9yIENvbXB1dGVkVmFsdWVzXHJcbiAqIHRoYXQgd2lsbCBiZSB0cmFja2VkIGJ5IGRlcml2YXRpb24uIFRoYXQgaXMgYmVjYXVzZSB3ZSBhc3N1bWUgdGhhdCBpZiB0aGUgZmlyc3QgeFxyXG4gKiBkZXBlbmRlbmNpZXMgb2YgdGhlIGRlcml2YXRpb24gZG9lc24ndCBjaGFuZ2UgdGhlbiB0aGUgZGVyaXZhdGlvbiBzaG91bGQgcnVuIHRoZSBzYW1lIHdheVxyXG4gKiB1cCB1bnRpbCBhY2Nlc3NpbmcgeC10aCBkZXBlbmRlbmN5LlxyXG4gKi9cblxuZnVuY3Rpb24gc2hvdWxkQ29tcHV0ZShkZXJpdmF0aW9uKSB7XG4gIHN3aXRjaCAoZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8pIHtcbiAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfOlxuICAgIGNhc2UgSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfOlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXzpcbiAgICAgIHtcbiAgICAgICAgLy8gc3RhdGUgcHJvcGFnYXRpb24gY2FuIG9jY3VyIG91dHNpZGUgb2YgYWN0aW9uL3JlYWN0aXZlIGNvbnRleHQgIzIxOTVcbiAgICAgICAgdmFyIHByZXZBbGxvd1N0YXRlUmVhZHMgPSBhbGxvd1N0YXRlUmVhZHNTdGFydCh0cnVlKTtcbiAgICAgICAgdmFyIHByZXZVbnRyYWNrZWQgPSB1bnRyYWNrZWRTdGFydCgpOyAvLyBubyBuZWVkIGZvciB0aG9zZSBjb21wdXRlZHMgdG8gYmUgcmVwb3J0ZWQsIHRoZXkgd2lsbCBiZSBwaWNrZWQgdXAgaW4gdHJhY2tEZXJpdmVkRnVuY3Rpb24uXG5cbiAgICAgICAgdmFyIG9icyA9IGRlcml2YXRpb24ub2JzZXJ2aW5nXyxcbiAgICAgICAgICAgIGwgPSBvYnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IG9ic1tpXTtcblxuICAgICAgICAgIGlmIChpc0NvbXB1dGVkVmFsdWUob2JqKSkge1xuICAgICAgICAgICAgaWYgKGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMpIHtcbiAgICAgICAgICAgICAgb2JqLmdldCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvYmouZ2V0KCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgbm90IGludGVyZXN0ZWQgaW4gdGhlIHZhbHVlICpvciogZXhjZXB0aW9uIGF0IHRoaXMgbW9tZW50LCBidXQgaWYgdGhlcmUgaXMgb25lLCBub3RpZnkgYWxsXG4gICAgICAgICAgICAgICAgdW50cmFja2VkRW5kKHByZXZVbnRyYWNrZWQpO1xuICAgICAgICAgICAgICAgIGFsbG93U3RhdGVSZWFkc0VuZChwcmV2QWxsb3dTdGF0ZVJlYWRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBpZiBDb21wdXRlZFZhbHVlIGBvYmpgIGFjdHVhbGx5IGNoYW5nZWQgaXQgd2lsbCBiZSBjb21wdXRlZCBhbmQgcHJvcGFnYXRlZCB0byBpdHMgb2JzZXJ2ZXJzLlxuICAgICAgICAgICAgLy8gYW5kIGBkZXJpdmF0aW9uYCBpcyBhbiBvYnNlcnZlciBvZiBgb2JqYFxuICAgICAgICAgICAgLy8gaW52YXJpYW50U2hvdWxkQ29tcHV0ZShkZXJpdmF0aW9uKVxuXG5cbiAgICAgICAgICAgIGlmIChkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfKSB7XG4gICAgICAgICAgICAgIHVudHJhY2tlZEVuZChwcmV2VW50cmFja2VkKTtcbiAgICAgICAgICAgICAgYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXZBbGxvd1N0YXRlUmVhZHMpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VEZXBlbmRlbmNpZXNTdGF0ZVRvMChkZXJpdmF0aW9uKTtcbiAgICAgICAgdW50cmFja2VkRW5kKHByZXZVbnRyYWNrZWQpO1xuICAgICAgICBhbGxvd1N0YXRlUmVhZHNFbmQocHJldkFsbG93U3RhdGVSZWFkcyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNDb21wdXRpbmdEZXJpdmF0aW9uKCkge1xuICByZXR1cm4gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uICE9PSBudWxsOyAvLyBmaWx0ZXIgb3V0IGFjdGlvbnMgaW5zaWRlIGNvbXB1dGF0aW9uc1xufVxuZnVuY3Rpb24gY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQoYXRvbSkge1xuXG4gIHZhciBoYXNPYnNlcnZlcnMgPSBhdG9tLm9ic2VydmVyc18uc2l6ZSA+IDA7IC8vIFNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gY2hhbmdlIG9ic2VydmVkIHN0YXRlIG91dHNpZGUgc3RyaWN0IG1vZGUsIGV4Y2VwdCBkdXJpbmcgaW5pdGlhbGl6YXRpb24sIHNlZSAjNTYzXG5cbiAgaWYgKCFnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlQ2hhbmdlcyAmJiAoaGFzT2JzZXJ2ZXJzIHx8IGdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zID09PSBcImFsd2F5c1wiKSkgY29uc29sZS53YXJuKFwiW01vYlhdIFwiICsgKGdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zID8gXCJTaW5jZSBzdHJpY3QtbW9kZSBpcyBlbmFibGVkLCBjaGFuZ2luZyAob2JzZXJ2ZWQpIG9ic2VydmFibGUgdmFsdWVzIHdpdGhvdXQgdXNpbmcgYW4gYWN0aW9uIGlzIG5vdCBhbGxvd2VkLiBUcmllZCB0byBtb2RpZnk6IFwiIDogXCJTaWRlIGVmZmVjdHMgbGlrZSBjaGFuZ2luZyBzdGF0ZSBhcmUgbm90IGFsbG93ZWQgYXQgdGhpcyBwb2ludC4gQXJlIHlvdSB0cnlpbmcgdG8gbW9kaWZ5IHN0YXRlIGZyb20sIGZvciBleGFtcGxlLCBhIGNvbXB1dGVkIHZhbHVlIG9yIHRoZSByZW5kZXIgZnVuY3Rpb24gb2YgYSBSZWFjdCBjb21wb25lbnQ/IFlvdSBjYW4gd3JhcCBzaWRlIGVmZmVjdHMgaW4gJ3J1bkluQWN0aW9uJyAob3IgZGVjb3JhdGUgZnVuY3Rpb25zIHdpdGggJ2FjdGlvbicpIGlmIG5lZWRlZC4gVHJpZWQgdG8gbW9kaWZ5OiBcIikgKyBhdG9tLm5hbWVfKTtcbn1cbmZ1bmN0aW9uIGNoZWNrSWZTdGF0ZVJlYWRzQXJlQWxsb3dlZChvYnNlcnZhYmxlKSB7XG4gIGlmICggIWdsb2JhbFN0YXRlLmFsbG93U3RhdGVSZWFkcyAmJiBnbG9iYWxTdGF0ZS5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbikge1xuICAgIGNvbnNvbGUud2FybihcIlttb2J4XSBPYnNlcnZhYmxlICdcIiArIG9ic2VydmFibGUubmFtZV8gKyBcIicgYmVpbmcgcmVhZCBvdXRzaWRlIGEgcmVhY3RpdmUgY29udGV4dC5cIik7XG4gIH1cbn1cbi8qKlxyXG4gKiBFeGVjdXRlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gYGZgIGFuZCB0cmFja3Mgd2hpY2ggb2JzZXJ2YWJsZXMgYXJlIGJlaW5nIGFjY2Vzc2VkLlxyXG4gKiBUaGUgdHJhY2tpbmcgaW5mb3JtYXRpb24gaXMgc3RvcmVkIG9uIHRoZSBgZGVyaXZhdGlvbmAgb2JqZWN0IGFuZCB0aGUgZGVyaXZhdGlvbiBpcyByZWdpc3RlcmVkXHJcbiAqIGFzIG9ic2VydmVyIG9mIGFueSBvZiB0aGUgYWNjZXNzZWQgb2JzZXJ2YWJsZXMuXHJcbiAqL1xuXG5mdW5jdGlvbiB0cmFja0Rlcml2ZWRGdW5jdGlvbihkZXJpdmF0aW9uLCBmLCBjb250ZXh0KSB7XG4gIHZhciBwcmV2QWxsb3dTdGF0ZVJlYWRzID0gYWxsb3dTdGF0ZVJlYWRzU3RhcnQodHJ1ZSk7IC8vIHByZSBhbGxvY2F0ZSBhcnJheSBhbGxvY2F0aW9uICsgcm9vbSBmb3IgdmFyaWF0aW9uIGluIGRlcHNcbiAgLy8gYXJyYXkgd2lsbCBiZSB0cmltbWVkIGJ5IGJpbmREZXBlbmRlbmNpZXNcblxuICBjaGFuZ2VEZXBlbmRlbmNpZXNTdGF0ZVRvMChkZXJpdmF0aW9uKTtcbiAgZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmdfID0gbmV3IEFycmF5KGRlcml2YXRpb24ub2JzZXJ2aW5nXy5sZW5ndGggKyAxMDApO1xuICBkZXJpdmF0aW9uLnVuYm91bmREZXBzQ291bnRfID0gMDtcbiAgZGVyaXZhdGlvbi5ydW5JZF8gPSArK2dsb2JhbFN0YXRlLnJ1bklkO1xuICB2YXIgcHJldlRyYWNraW5nID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uO1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBkZXJpdmF0aW9uO1xuICBnbG9iYWxTdGF0ZS5pbkJhdGNoKys7XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKGdsb2JhbFN0YXRlLmRpc2FibGVFcnJvckJvdW5kYXJpZXMgPT09IHRydWUpIHtcbiAgICByZXN1bHQgPSBmLmNhbGwoY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGYuY2FsbChjb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXN1bHQgPSBuZXcgQ2F1Z2h0RXhjZXB0aW9uKGUpO1xuICAgIH1cbiAgfVxuXG4gIGdsb2JhbFN0YXRlLmluQmF0Y2gtLTtcbiAgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uID0gcHJldlRyYWNraW5nO1xuICBiaW5kRGVwZW5kZW5jaWVzKGRlcml2YXRpb24pO1xuICB3YXJuQWJvdXREZXJpdmF0aW9uV2l0aG91dERlcGVuZGVuY2llcyhkZXJpdmF0aW9uKTtcbiAgYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXZBbGxvd1N0YXRlUmVhZHMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB3YXJuQWJvdXREZXJpdmF0aW9uV2l0aG91dERlcGVuZGVuY2llcyhkZXJpdmF0aW9uKSB7XG4gIGlmIChkZXJpdmF0aW9uLm9ic2VydmluZ18ubGVuZ3RoICE9PSAwKSByZXR1cm47XG5cbiAgaWYgKGdsb2JhbFN0YXRlLnJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlIHx8IGRlcml2YXRpb24ucmVxdWlyZXNPYnNlcnZhYmxlXykge1xuICAgIGNvbnNvbGUud2FybihcIlttb2J4XSBEZXJpdmF0aW9uICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIicgaXMgY3JlYXRlZC91cGRhdGVkIHdpdGhvdXQgcmVhZGluZyBhbnkgb2JzZXJ2YWJsZSB2YWx1ZS5cIik7XG4gIH1cbn1cbi8qKlxyXG4gKiBkaWZmcyBuZXdPYnNlcnZpbmcgd2l0aCBvYnNlcnZpbmcuXHJcbiAqIHVwZGF0ZSBvYnNlcnZpbmcgdG8gYmUgbmV3T2JzZXJ2aW5nIHdpdGggdW5pcXVlIG9ic2VydmFibGVzXHJcbiAqIG5vdGlmeSBvYnNlcnZlcnMgdGhhdCBiZWNvbWUgb2JzZXJ2ZWQvdW5vYnNlcnZlZFxyXG4gKi9cblxuXG5mdW5jdGlvbiBiaW5kRGVwZW5kZW5jaWVzKGRlcml2YXRpb24pIHtcbiAgLy8gaW52YXJpYW50KGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGUgIT09IElEZXJpdmF0aW9uU3RhdGUuTk9UX1RSQUNLSU5HLCBcIklOVEVSTkFMIEVSUk9SIGJpbmREZXBlbmRlbmNpZXMgZXhwZWN0cyBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlICE9PSAtMVwiKTtcbiAgdmFyIHByZXZPYnNlcnZpbmcgPSBkZXJpdmF0aW9uLm9ic2VydmluZ187XG4gIHZhciBvYnNlcnZpbmcgPSBkZXJpdmF0aW9uLm9ic2VydmluZ18gPSBkZXJpdmF0aW9uLm5ld09ic2VydmluZ187XG4gIHZhciBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUgPSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXzsgLy8gR28gdGhyb3VnaCBhbGwgbmV3IG9ic2VydmFibGVzIGFuZCBjaGVjayBkaWZmVmFsdWU6ICh0aGlzIGxpc3QgY2FuIGNvbnRhaW4gZHVwbGljYXRlcyk6XG4gIC8vICAgMDogZmlyc3Qgb2NjdXJyZW5jZSwgY2hhbmdlIHRvIDEgYW5kIGtlZXAgaXRcbiAgLy8gICAxOiBleHRyYSBvY2N1cnJlbmNlLCBkcm9wIGl0XG5cbiAgdmFyIGkwID0gMCxcbiAgICAgIGwgPSBkZXJpdmF0aW9uLnVuYm91bmREZXBzQ291bnRfO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGRlcCA9IG9ic2VydmluZ1tpXTtcblxuICAgIGlmIChkZXAuZGlmZlZhbHVlXyA9PT0gMCkge1xuICAgICAgZGVwLmRpZmZWYWx1ZV8gPSAxO1xuICAgICAgaWYgKGkwICE9PSBpKSBvYnNlcnZpbmdbaTBdID0gZGVwO1xuICAgICAgaTArKztcbiAgICB9IC8vIFVwY2FzdCBpcyAnc2FmZScgaGVyZSwgYmVjYXVzZSBpZiBkZXAgaXMgSU9ic2VydmFibGUsIGBkZXBlbmRlbmNpZXNTdGF0ZWAgd2lsbCBiZSB1bmRlZmluZWQsXG4gICAgLy8gbm90IGhpdHRpbmcgdGhlIGNvbmRpdGlvblxuXG5cbiAgICBpZiAoZGVwLmRlcGVuZGVuY2llc1N0YXRlXyA+IGxvd2VzdE5ld09ic2VydmluZ0Rlcml2YXRpb25TdGF0ZSkge1xuICAgICAgbG93ZXN0TmV3T2JzZXJ2aW5nRGVyaXZhdGlvblN0YXRlID0gZGVwLmRlcGVuZGVuY2llc1N0YXRlXztcbiAgICB9XG4gIH1cblxuICBvYnNlcnZpbmcubGVuZ3RoID0gaTA7XG4gIGRlcml2YXRpb24ubmV3T2JzZXJ2aW5nXyA9IG51bGw7IC8vIG5ld09ic2VydmluZyBzaG91bGRuJ3QgYmUgbmVlZGVkIG91dHNpZGUgdHJhY2tpbmcgKHN0YXRlbWVudCBtb3ZlZCBkb3duIHRvIHdvcmsgYXJvdW5kIEZGIGJ1Zywgc2VlICM2MTQpXG4gIC8vIEdvIHRocm91Z2ggYWxsIG9sZCBvYnNlcnZhYmxlcyBhbmQgY2hlY2sgZGlmZlZhbHVlOiAoaXQgaXMgdW5pcXVlIGFmdGVyIGxhc3QgYmluZERlcGVuZGVuY2llcylcbiAgLy8gICAwOiBpdCdzIG5vdCBpbiBuZXcgb2JzZXJ2YWJsZXMsIHVub2JzZXJ2ZSBpdFxuICAvLyAgIDE6IGl0IGtlZXBzIGJlaW5nIG9ic2VydmVkLCBkb24ndCB3YW50IHRvIG5vdGlmeSBpdC4gY2hhbmdlIHRvIDBcblxuICBsID0gcHJldk9ic2VydmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKGwtLSkge1xuICAgIHZhciBfZGVwID0gcHJldk9ic2VydmluZ1tsXTtcblxuICAgIGlmIChfZGVwLmRpZmZWYWx1ZV8gPT09IDApIHtcbiAgICAgIHJlbW92ZU9ic2VydmVyKF9kZXAsIGRlcml2YXRpb24pO1xuICAgIH1cblxuICAgIF9kZXAuZGlmZlZhbHVlXyA9IDA7XG4gIH0gLy8gR28gdGhyb3VnaCBhbGwgbmV3IG9ic2VydmFibGVzIGFuZCBjaGVjayBkaWZmVmFsdWU6IChub3cgaXQgc2hvdWxkIGJlIHVuaXF1ZSlcbiAgLy8gICAwOiBpdCB3YXMgc2V0IHRvIDAgaW4gbGFzdCBsb29wLiBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAvLyAgIDE6IGl0IHdhc24ndCBvYnNlcnZlZCwgbGV0J3Mgb2JzZXJ2ZSBpdC4gc2V0IGJhY2sgdG8gMFxuXG5cbiAgd2hpbGUgKGkwLS0pIHtcbiAgICB2YXIgX2RlcDIgPSBvYnNlcnZpbmdbaTBdO1xuXG4gICAgaWYgKF9kZXAyLmRpZmZWYWx1ZV8gPT09IDEpIHtcbiAgICAgIF9kZXAyLmRpZmZWYWx1ZV8gPSAwO1xuICAgICAgYWRkT2JzZXJ2ZXIoX2RlcDIsIGRlcml2YXRpb24pO1xuICAgIH1cbiAgfSAvLyBTb21lIG5ldyBvYnNlcnZlZCBkZXJpdmF0aW9ucyBtYXkgYmVjb21lIHN0YWxlIGR1cmluZyB0aGlzIGRlcml2YXRpb24gY29tcHV0YXRpb25cbiAgLy8gc28gdGhleSBoYXZlIGhhZCBubyBjaGFuY2UgdG8gcHJvcGFnYXRlIHN0YWxlbmVzcyAoIzkxNilcblxuXG4gIGlmIChsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGUgIT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSB7XG4gICAgZGVyaXZhdGlvbi5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBsb3dlc3ROZXdPYnNlcnZpbmdEZXJpdmF0aW9uU3RhdGU7XG4gICAgZGVyaXZhdGlvbi5vbkJlY29tZVN0YWxlXygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFyT2JzZXJ2aW5nKGRlcml2YXRpb24pIHtcbiAgLy8gaW52YXJpYW50KGdsb2JhbFN0YXRlLmluQmF0Y2ggPiAwLCBcIklOVEVSTkFMIEVSUk9SIGNsZWFyT2JzZXJ2aW5nIHNob3VsZCBiZSBjYWxsZWQgb25seSBpbnNpZGUgYmF0Y2hcIik7XG4gIHZhciBvYnMgPSBkZXJpdmF0aW9uLm9ic2VydmluZ187XG4gIGRlcml2YXRpb24ub2JzZXJ2aW5nXyA9IFtdO1xuICB2YXIgaSA9IG9icy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHJlbW92ZU9ic2VydmVyKG9ic1tpXSwgZGVyaXZhdGlvbik7XG4gIH1cblxuICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLk5PVF9UUkFDS0lOR187XG59XG5mdW5jdGlvbiB1bnRyYWNrZWQoYWN0aW9uKSB7XG4gIHZhciBwcmV2ID0gdW50cmFja2VkU3RhcnQoKTtcblxuICB0cnkge1xuICAgIHJldHVybiBhY3Rpb24oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB1bnRyYWNrZWRFbmQocHJldik7XG4gIH1cbn1cbmZ1bmN0aW9uIHVudHJhY2tlZFN0YXJ0KCkge1xuICB2YXIgcHJldiA9IGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcbiAgZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uID0gbnVsbDtcbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiB1bnRyYWNrZWRFbmQocHJldikge1xuICBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24gPSBwcmV2O1xufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZVJlYWRzU3RhcnQoYWxsb3dTdGF0ZVJlYWRzKSB7XG4gIHZhciBwcmV2ID0gZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzO1xuICBnbG9iYWxTdGF0ZS5hbGxvd1N0YXRlUmVhZHMgPSBhbGxvd1N0YXRlUmVhZHM7XG4gIHJldHVybiBwcmV2O1xufVxuZnVuY3Rpb24gYWxsb3dTdGF0ZVJlYWRzRW5kKHByZXYpIHtcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzID0gcHJldjtcbn1cbi8qKlxyXG4gKiBuZWVkZWQgdG8ga2VlcCBgbG93ZXN0T2JzZXJ2ZXJTdGF0ZWAgY29ycmVjdC4gd2hlbiBjaGFuZ2luZyBmcm9tICgyIG9yIDEpIHRvIDBcclxuICpcclxuICovXG5cbmZ1bmN0aW9uIGNoYW5nZURlcGVuZGVuY2llc1N0YXRlVG8wKGRlcml2YXRpb24pIHtcbiAgaWYgKGRlcml2YXRpb24uZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5VUF9UT19EQVRFXykgcmV0dXJuO1xuICBkZXJpdmF0aW9uLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfO1xuICB2YXIgb2JzID0gZGVyaXZhdGlvbi5vYnNlcnZpbmdfO1xuICB2YXIgaSA9IG9icy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIG9ic1tpXS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfO1xuICB9XG59XG5cbi8qKlxyXG4gKiBUaGVzZSB2YWx1ZXMgd2lsbCBwZXJzaXN0IGlmIGdsb2JhbCBzdGF0ZSBpcyByZXNldFxyXG4gKi9cblxudmFyIHBlcnNpc3RlbnRLZXlzID0gW1wibW9ieEd1aWRcIiwgXCJzcHlMaXN0ZW5lcnNcIiwgXCJlbmZvcmNlQWN0aW9uc1wiLCBcImNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvblwiLCBcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsIFwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25cIiwgXCJhbGxvd1N0YXRlUmVhZHNcIiwgXCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzXCIsIFwicnVuSWRcIiwgXCJVTkNIQU5HRURcIiwgXCJ1c2VQcm94aWVzXCJdO1xudmFyIE1vYlhHbG9iYWxzID0gZnVuY3Rpb24gTW9iWEdsb2JhbHMoKSB7XG4gIHRoaXMudmVyc2lvbiA9IDY7XG4gIHRoaXMuVU5DSEFOR0VEID0ge307XG4gIHRoaXMudHJhY2tpbmdEZXJpdmF0aW9uID0gbnVsbDtcbiAgdGhpcy50cmFja2luZ0NvbnRleHQgPSBudWxsO1xuICB0aGlzLnJ1bklkID0gMDtcbiAgdGhpcy5tb2J4R3VpZCA9IDA7XG4gIHRoaXMuaW5CYXRjaCA9IDA7XG4gIHRoaXMucGVuZGluZ1Vub2JzZXJ2YXRpb25zID0gW107XG4gIHRoaXMucGVuZGluZ1JlYWN0aW9ucyA9IFtdO1xuICB0aGlzLmlzUnVubmluZ1JlYWN0aW9ucyA9IGZhbHNlO1xuICB0aGlzLmFsbG93U3RhdGVDaGFuZ2VzID0gZmFsc2U7XG4gIHRoaXMuYWxsb3dTdGF0ZVJlYWRzID0gdHJ1ZTtcbiAgdGhpcy5lbmZvcmNlQWN0aW9ucyA9IHRydWU7XG4gIHRoaXMuc3B5TGlzdGVuZXJzID0gW107XG4gIHRoaXMuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzID0gW107XG4gIHRoaXMuY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uID0gZmFsc2U7XG4gIHRoaXMucmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGUgPSBmYWxzZTtcbiAgdGhpcy5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbiA9IGZhbHNlO1xuICB0aGlzLmRpc2FibGVFcnJvckJvdW5kYXJpZXMgPSBmYWxzZTtcbiAgdGhpcy5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzID0gZmFsc2U7XG4gIHRoaXMudXNlUHJveGllcyA9IHRydWU7XG4gIHRoaXMudmVyaWZ5UHJveGllcyA9IGZhbHNlO1xuICB0aGlzLnNhZmVEZXNjcmlwdG9ycyA9IHRydWU7XG59O1xudmFyIGNhbk1lcmdlR2xvYmFsU3RhdGUgPSB0cnVlO1xudmFyIGlzb2xhdGVDYWxsZWQgPSBmYWxzZTtcbnZhciBnbG9iYWxTdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBnbG9iYWwgPSAvKiNfX1BVUkVfXyovZ2V0R2xvYmFsKCk7XG4gIGlmIChnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCA+IDAgJiYgIWdsb2JhbC5fX21vYnhHbG9iYWxzKSBjYW5NZXJnZUdsb2JhbFN0YXRlID0gZmFsc2U7XG4gIGlmIChnbG9iYWwuX19tb2J4R2xvYmFscyAmJiBnbG9iYWwuX19tb2J4R2xvYmFscy52ZXJzaW9uICE9PSBuZXcgTW9iWEdsb2JhbHMoKS52ZXJzaW9uKSBjYW5NZXJnZUdsb2JhbFN0YXRlID0gZmFsc2U7XG5cbiAgaWYgKCFjYW5NZXJnZUdsb2JhbFN0YXRlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWlzb2xhdGVDYWxsZWQpIHtcbiAgICAgICAgZGllKDM1KTtcbiAgICAgIH1cbiAgICB9LCAxKTtcbiAgICByZXR1cm4gbmV3IE1vYlhHbG9iYWxzKCk7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLl9fbW9ieEdsb2JhbHMpIHtcbiAgICBnbG9iYWwuX19tb2J4SW5zdGFuY2VDb3VudCArPSAxO1xuICAgIGlmICghZ2xvYmFsLl9fbW9ieEdsb2JhbHMuVU5DSEFOR0VEKSBnbG9iYWwuX19tb2J4R2xvYmFscy5VTkNIQU5HRUQgPSB7fTsgLy8gbWFrZSBtZXJnZSBiYWNrd2FyZCBjb21wYXRpYmxlXG5cbiAgICByZXR1cm4gZ2xvYmFsLl9fbW9ieEdsb2JhbHM7XG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsLl9fbW9ieEluc3RhbmNlQ291bnQgPSAxO1xuICAgIHJldHVybiBnbG9iYWwuX19tb2J4R2xvYmFscyA9IC8qI19fUFVSRV9fKi9uZXcgTW9iWEdsb2JhbHMoKTtcbiAgfVxufSgpO1xuZnVuY3Rpb24gaXNvbGF0ZUdsb2JhbFN0YXRlKCkge1xuICBpZiAoZ2xvYmFsU3RhdGUucGVuZGluZ1JlYWN0aW9ucy5sZW5ndGggfHwgZ2xvYmFsU3RhdGUuaW5CYXRjaCB8fCBnbG9iYWxTdGF0ZS5pc1J1bm5pbmdSZWFjdGlvbnMpIGRpZSgzNik7XG4gIGlzb2xhdGVDYWxsZWQgPSB0cnVlO1xuXG4gIGlmIChjYW5NZXJnZUdsb2JhbFN0YXRlKSB7XG4gICAgdmFyIGdsb2JhbCA9IGdldEdsb2JhbCgpO1xuICAgIGlmICgtLWdsb2JhbC5fX21vYnhJbnN0YW5jZUNvdW50ID09PSAwKSBnbG9iYWwuX19tb2J4R2xvYmFscyA9IHVuZGVmaW5lZDtcbiAgICBnbG9iYWxTdGF0ZSA9IG5ldyBNb2JYR2xvYmFscygpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxTdGF0ZSgpIHtcbiAgcmV0dXJuIGdsb2JhbFN0YXRlO1xufVxuLyoqXHJcbiAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHk7IHRoaXMgd2lsbCBicmVhayB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgZXhpc3Rpbmcgb2JzZXJ2YWJsZXMsXHJcbiAqIGJ1dCBjYW4gYmUgdXNlZCB0byBnZXQgYmFjayBhdCBhIHN0YWJsZSBzdGF0ZSBhZnRlciB0aHJvd2luZyBlcnJvcnNcclxuICovXG5cbmZ1bmN0aW9uIHJlc2V0R2xvYmFsU3RhdGUoKSB7XG4gIHZhciBkZWZhdWx0R2xvYmFscyA9IG5ldyBNb2JYR2xvYmFscygpO1xuXG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0R2xvYmFscykge1xuICAgIGlmIChwZXJzaXN0ZW50S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSBnbG9iYWxTdGF0ZVtrZXldID0gZGVmYXVsdEdsb2JhbHNba2V5XTtcbiAgfVxuXG4gIGdsb2JhbFN0YXRlLmFsbG93U3RhdGVDaGFuZ2VzID0gIWdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBoYXNPYnNlcnZlcnMob2JzZXJ2YWJsZSkge1xuICByZXR1cm4gb2JzZXJ2YWJsZS5vYnNlcnZlcnNfICYmIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5zaXplID4gMDtcbn1cbmZ1bmN0aW9uIGdldE9ic2VydmVycyhvYnNlcnZhYmxlKSB7XG4gIHJldHVybiBvYnNlcnZhYmxlLm9ic2VydmVyc187XG59IC8vIGZ1bmN0aW9uIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlOiBJT2JzZXJ2YWJsZSkge1xuLy8gICAgIGNvbnN0IGxpc3QgPSBvYnNlcnZhYmxlLm9ic2VydmVyc1xuLy8gICAgIGNvbnN0IG1hcCA9IG9ic2VydmFibGUub2JzZXJ2ZXJzSW5kZXhlc1xuLy8gICAgIGNvbnN0IGwgPSBsaXN0Lmxlbmd0aFxuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4vLyAgICAgICAgIGNvbnN0IGlkID0gbGlzdFtpXS5fX21hcGlkXG4vLyAgICAgICAgIGlmIChpKSB7XG4vLyAgICAgICAgICAgICBpbnZhcmlhbnQobWFwW2lkXSA9PT0gaSwgXCJJTlRFUk5BTCBFUlJPUiBtYXBzIGRlcml2YXRpb24uX19tYXBpZCB0byBpbmRleCBpbiBsaXN0XCIpIC8vIGZvciBwZXJmb3JtYW5jZVxuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgaW52YXJpYW50KCEoaWQgaW4gbWFwKSwgXCJJTlRFUk5BTCBFUlJPUiBvYnNlcnZlciBvbiBpbmRleCAwIHNob3VsZG4ndCBiZSBoZWxkIGluIG1hcC5cIikgLy8gZm9yIHBlcmZvcm1hbmNlXG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vLyAgICAgaW52YXJpYW50KFxuLy8gICAgICAgICBsaXN0Lmxlbmd0aCA9PT0gMCB8fCBPYmplY3Qua2V5cyhtYXApLmxlbmd0aCA9PT0gbGlzdC5sZW5ndGggLSAxLFxuLy8gICAgICAgICBcIklOVEVSTkFMIEVSUk9SIHRoZXJlIGlzIG5vIGp1bmsgaW4gbWFwXCJcbi8vICAgICApXG4vLyB9XG5cbmZ1bmN0aW9uIGFkZE9ic2VydmVyKG9ic2VydmFibGUsIG5vZGUpIHtcbiAgLy8gaW52YXJpYW50KG5vZGUuZGVwZW5kZW5jaWVzU3RhdGUgIT09IC0xLCBcIklOVEVSTkFMIEVSUk9SLCBjYW4gYWRkIG9ubHkgZGVwZW5kZW5jaWVzU3RhdGUgIT09IC0xXCIpO1xuICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgPT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIGFkZCBhbHJlYWR5IGFkZGVkIG5vZGVcIik7XG4gIC8vIGludmFyaWFudE9ic2VydmVycyhvYnNlcnZhYmxlKTtcbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLmFkZChub2RlKTtcbiAgaWYgKG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPiBub2RlLmRlcGVuZGVuY2llc1N0YXRlXykgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IG5vZGUuZGVwZW5kZW5jaWVzU3RhdGVfOyAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSAhPT0gLTEsIFwiSU5URVJOQUwgRVJST1IgZGlkbid0IGFkZCBub2RlXCIpO1xufVxuZnVuY3Rpb24gcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2YWJsZSwgbm9kZSkge1xuICAvLyBpbnZhcmlhbnQoZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDAsIFwiSU5URVJOQUwgRVJST1IsIHJlbW92ZSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgaW5zaWRlIGJhdGNoXCIpO1xuICAvLyBpbnZhcmlhbnQob2JzZXJ2YWJsZS5fb2JzZXJ2ZXJzLmluZGV4T2Yobm9kZSkgIT09IC0xLCBcIklOVEVSTkFMIEVSUk9SIHJlbW92ZSBhbHJlYWR5IHJlbW92ZWQgbm9kZVwiKTtcbiAgLy8gaW52YXJpYW50T2JzZXJ2ZXJzKG9ic2VydmFibGUpO1xuICBvYnNlcnZhYmxlLm9ic2VydmVyc19bXCJkZWxldGVcIl0obm9kZSk7XG5cbiAgaWYgKG9ic2VydmFibGUub2JzZXJ2ZXJzXy5zaXplID09PSAwKSB7XG4gICAgLy8gZGVsZXRpbmcgbGFzdCBvYnNlcnZlclxuICAgIHF1ZXVlRm9yVW5vYnNlcnZhdGlvbihvYnNlcnZhYmxlKTtcbiAgfSAvLyBpbnZhcmlhbnRPYnNlcnZlcnMob2JzZXJ2YWJsZSk7XG4gIC8vIGludmFyaWFudChvYnNlcnZhYmxlLl9vYnNlcnZlcnMuaW5kZXhPZihub2RlKSA9PT0gLTEsIFwiSU5URVJOQUwgRVJST1IgcmVtb3ZlIGFscmVhZHkgcmVtb3ZlZCBub2RlMlwiKTtcblxufVxuZnVuY3Rpb24gcXVldWVGb3JVbm9ic2VydmF0aW9uKG9ic2VydmFibGUpIHtcbiAgaWYgKG9ic2VydmFibGUuaXNQZW5kaW5nVW5vYnNlcnZhdGlvbl8gPT09IGZhbHNlKSB7XG4gICAgLy8gaW52YXJpYW50KG9ic2VydmFibGUuX29ic2VydmVycy5sZW5ndGggPT09IDAsIFwiSU5URVJOQUwgRVJST1IsIHNob3VsZCBvbmx5IHF1ZXVlIGZvciB1bm9ic2VydmF0aW9uIHVub2JzZXJ2ZWQgb2JzZXJ2YWJsZXNcIik7XG4gICAgb2JzZXJ2YWJsZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uXyA9IHRydWU7XG4gICAgZ2xvYmFsU3RhdGUucGVuZGluZ1Vub2JzZXJ2YXRpb25zLnB1c2gob2JzZXJ2YWJsZSk7XG4gIH1cbn1cbi8qKlxyXG4gKiBCYXRjaCBzdGFydHMgYSB0cmFuc2FjdGlvbiwgYXQgbGVhc3QgZm9yIHB1cnBvc2VzIG9mIG1lbW9pemluZyBDb21wdXRlZFZhbHVlcyB3aGVuIG5vdGhpbmcgZWxzZSBkb2VzLlxyXG4gKiBEdXJpbmcgYSBiYXRjaCBgb25CZWNvbWVVbm9ic2VydmVkYCB3aWxsIGJlIGNhbGxlZCBhdCBtb3N0IG9uY2UgcGVyIG9ic2VydmFibGUuXHJcbiAqIEF2b2lkcyB1bm5lY2Vzc2FyeSByZWNhbGN1bGF0aW9ucy5cclxuICovXG5cbmZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XG4gIGdsb2JhbFN0YXRlLmluQmF0Y2grKztcbn1cbmZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICBpZiAoLS1nbG9iYWxTdGF0ZS5pbkJhdGNoID09PSAwKSB7XG4gICAgcnVuUmVhY3Rpb25zKCk7IC8vIHRoZSBiYXRjaCBpcyBhY3R1YWxseSBhYm91dCB0byBmaW5pc2gsIGFsbCB1bm9ic2VydmluZyBzaG91bGQgaGFwcGVuIGhlcmUuXG5cbiAgICB2YXIgbGlzdCA9IGdsb2JhbFN0YXRlLnBlbmRpbmdVbm9ic2VydmF0aW9ucztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG9ic2VydmFibGUgPSBsaXN0W2ldO1xuICAgICAgb2JzZXJ2YWJsZS5pc1BlbmRpbmdVbm9ic2VydmF0aW9uXyA9IGZhbHNlO1xuXG4gICAgICBpZiAob2JzZXJ2YWJsZS5vYnNlcnZlcnNfLnNpemUgPT09IDApIHtcbiAgICAgICAgaWYgKG9ic2VydmFibGUuaXNCZWluZ09ic2VydmVkXykge1xuICAgICAgICAgIC8vIGlmIHRoaXMgb2JzZXJ2YWJsZSBoYWQgcmVhY3RpdmUgb2JzZXJ2ZXJzLCB0cmlnZ2VyIHRoZSBob29rc1xuICAgICAgICAgIG9ic2VydmFibGUuaXNCZWluZ09ic2VydmVkXyA9IGZhbHNlO1xuICAgICAgICAgIG9ic2VydmFibGUub25CVU8oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYnNlcnZhYmxlIGluc3RhbmNlb2YgQ29tcHV0ZWRWYWx1ZSkge1xuICAgICAgICAgIC8vIGNvbXB1dGVkIHZhbHVlcyBhcmUgYXV0b21hdGljYWxseSB0ZWFyZWQgZG93biB3aGVuIHRoZSBsYXN0IG9ic2VydmVyIGxlYXZlc1xuICAgICAgICAgIC8vIHRoaXMgcHJvY2VzcyBoYXBwZW5zIHJlY3Vyc2l2ZWx5LCB0aGlzIGNvbXB1dGVkIG1pZ2h0IGJlIHRoZSBsYXN0IG9ic2VydmFiZSBvZiBhbm90aGVyLCBldGMuLlxuICAgICAgICAgIG9ic2VydmFibGUuc3VzcGVuZF8oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGdsb2JhbFN0YXRlLnBlbmRpbmdVbm9ic2VydmF0aW9ucyA9IFtdO1xuICB9XG59XG5mdW5jdGlvbiByZXBvcnRPYnNlcnZlZChvYnNlcnZhYmxlKSB7XG4gIGNoZWNrSWZTdGF0ZVJlYWRzQXJlQWxsb3dlZChvYnNlcnZhYmxlKTtcbiAgdmFyIGRlcml2YXRpb24gPSBnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb247XG5cbiAgaWYgKGRlcml2YXRpb24gIT09IG51bGwpIHtcbiAgICAvKipcclxuICAgICAqIFNpbXBsZSBvcHRpbWl6YXRpb24sIGdpdmUgZWFjaCBkZXJpdmF0aW9uIHJ1biBhbiB1bmlxdWUgaWQgKHJ1bklkKVxyXG4gICAgICogQ2hlY2sgaWYgbGFzdCB0aW1lIHRoaXMgb2JzZXJ2YWJsZSB3YXMgYWNjZXNzZWQgdGhlIHNhbWUgcnVuSWQgaXMgdXNlZFxyXG4gICAgICogaWYgdGhpcyBpcyB0aGUgY2FzZSwgdGhlIHJlbGF0aW9uIGlzIGFscmVhZHkga25vd25cclxuICAgICAqL1xuICAgIGlmIChkZXJpdmF0aW9uLnJ1bklkXyAhPT0gb2JzZXJ2YWJsZS5sYXN0QWNjZXNzZWRCeV8pIHtcbiAgICAgIG9ic2VydmFibGUubGFzdEFjY2Vzc2VkQnlfID0gZGVyaXZhdGlvbi5ydW5JZF87IC8vIFRyaWVkIHN0b3JpbmcgbmV3T2JzZXJ2aW5nLCBvciBvYnNlcnZpbmcsIG9yIGJvdGggYXMgU2V0LCBidXQgcGVyZm9ybWFuY2UgZGlkbid0IGNvbWUgY2xvc2UuLi5cblxuICAgICAgZGVyaXZhdGlvbi5uZXdPYnNlcnZpbmdfW2Rlcml2YXRpb24udW5ib3VuZERlcHNDb3VudF8rK10gPSBvYnNlcnZhYmxlO1xuXG4gICAgICBpZiAoIW9ic2VydmFibGUuaXNCZWluZ09ic2VydmVkXyAmJiBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQpIHtcbiAgICAgICAgb2JzZXJ2YWJsZS5pc0JlaW5nT2JzZXJ2ZWRfID0gdHJ1ZTtcbiAgICAgICAgb2JzZXJ2YWJsZS5vbkJPKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAob2JzZXJ2YWJsZS5vYnNlcnZlcnNfLnNpemUgPT09IDAgJiYgZ2xvYmFsU3RhdGUuaW5CYXRjaCA+IDApIHtcbiAgICBxdWV1ZUZvclVub2JzZXJ2YXRpb24ob2JzZXJ2YWJsZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIGZ1bmN0aW9uIGludmFyaWFudExPUyhvYnNlcnZhYmxlOiBJT2JzZXJ2YWJsZSwgbXNnOiBzdHJpbmcpIHtcbi8vICAgICAvLyBpdCdzIGV4cGVuc2l2ZSBzbyBiZXR0ZXIgbm90IHJ1biBpdCBpbiBwcm9kdWNpdG9uLiBidXQgdGVtcG9yYXJpbHkgaGVscGZ1bCBmb3IgdGVzdGluZ1xuLy8gICAgIGNvbnN0IG1pbiA9IGdldE9ic2VydmVycyhvYnNlcnZhYmxlKS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWluKGEsIGIuZGVwZW5kZW5jaWVzU3RhdGUpLCAyKVxuLy8gICAgIGlmIChtaW4gPj0gb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlKSByZXR1cm4gLy8gPC0gdGhlIG9ubHkgYXNzdW1wdGlvbiBhYm91dCBgbG93ZXN0T2JzZXJ2ZXJTdGF0ZWBcbi8vICAgICB0aHJvdyBuZXcgRXJyb3IoXG4vLyAgICAgICAgIFwibG93ZXN0T2JzZXJ2ZXJTdGF0ZSBpcyB3cm9uZyBmb3IgXCIgK1xuLy8gICAgICAgICAgICAgbXNnICtcbi8vICAgICAgICAgICAgIFwiIGJlY2F1c2UgXCIgK1xuLy8gICAgICAgICAgICAgbWluICtcbi8vICAgICAgICAgICAgIFwiIDwgXCIgK1xuLy8gICAgICAgICAgICAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXG4vLyAgICAgKVxuLy8gfVxuXG4vKipcclxuICogTk9URTogY3VycmVudCBwcm9wYWdhdGlvbiBtZWNoYW5pc20gd2lsbCBpbiBjYXNlIG9mIHNlbGYgcmVydW5pbmcgYXV0b3J1bnMgYmVoYXZlIHVuZXhwZWN0ZWRseVxyXG4gKiBJdCB3aWxsIHByb3BhZ2F0ZSBjaGFuZ2VzIHRvIG9ic2VydmVycyBmcm9tIHByZXZpb3VzIHJ1blxyXG4gKiBJdCdzIGhhcmQgb3IgbWF5YmUgaW1wb3NzaWJsZSAod2l0aCByZWFzb25hYmxlIHBlcmYpIHRvIGdldCBpdCByaWdodCB3aXRoIGN1cnJlbnQgYXBwcm9hY2hcclxuICogSG9wZWZ1bGx5IHNlbGYgcmVydW5pbmcgYXV0b3J1bnMgYXJlbid0IGEgZmVhdHVyZSBwZW9wbGUgc2hvdWxkIGRlcGVuZCBvblxyXG4gKiBBbHNvIG1vc3QgYmFzaWMgdXNlIGNhc2VzIHNob3VsZCBiZSBva1xyXG4gKi9cbi8vIENhbGxlZCBieSBBdG9tIHdoZW4gaXRzIHZhbHVlIGNoYW5nZXNcblxuZnVuY3Rpb24gcHJvcGFnYXRlQ2hhbmdlZChvYnNlcnZhYmxlKSB7XG4gIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcImNoYW5nZWQgc3RhcnRcIik7XG4gIGlmIChvYnNlcnZhYmxlLmxvd2VzdE9ic2VydmVyU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV8pIHJldHVybjtcbiAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlNUQUxFXzsgLy8gSWRlYWxseSB3ZSB1c2UgZm9yLi5vZiBoZXJlLCBidXQgdGhlIGRvd25jb21waWxlZCB2ZXJzaW9uIGlzIHJlYWxseSBzbG93Li4uXG5cbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSB7XG4gICAgICBpZiAoIGQuaXNUcmFjaW5nXyAhPT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICAgICAgbG9nVHJhY2VJbmZvKGQsIG9ic2VydmFibGUpO1xuICAgICAgfVxuXG4gICAgICBkLm9uQmVjb21lU3RhbGVfKCk7XG4gICAgfVxuXG4gICAgZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV87XG4gIH0pOyAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJjaGFuZ2VkIGVuZFwiKTtcbn0gLy8gQ2FsbGVkIGJ5IENvbXB1dGVkVmFsdWUgd2hlbiBpdCByZWNhbGN1bGF0ZSBhbmQgaXRzIHZhbHVlIGNoYW5nZWRcblxuZnVuY3Rpb24gcHJvcGFnYXRlQ2hhbmdlQ29uZmlybWVkKG9ic2VydmFibGUpIHtcbiAgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY29uZmlybWVkIHN0YXJ0XCIpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9PT0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfKSByZXR1cm47XG4gIG9ic2VydmFibGUubG93ZXN0T2JzZXJ2ZXJTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5TVEFMRV87XG4gIG9ic2VydmFibGUub2JzZXJ2ZXJzXy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGQuZGVwZW5kZW5jaWVzU3RhdGVfID09PSBJRGVyaXZhdGlvblN0YXRlXy5QT1NTSUJMWV9TVEFMRV8pIHtcbiAgICAgIGQuZGVwZW5kZW5jaWVzU3RhdGVfID0gSURlcml2YXRpb25TdGF0ZV8uU1RBTEVfO1xuXG4gICAgICBpZiAoIGQuaXNUcmFjaW5nXyAhPT0gVHJhY2VNb2RlLk5PTkUpIHtcbiAgICAgICAgbG9nVHJhY2VJbmZvKGQsIG9ic2VydmFibGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfIC8vIHRoaXMgaGFwcGVucyBkdXJpbmcgY29tcHV0aW5nIG9mIGBkYCwganVzdCBrZWVwIGxvd2VzdE9ic2VydmVyU3RhdGUgdXAgdG8gZGF0ZS5cbiAgICApIHtcbiAgICAgICAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfO1xuICAgICAgfVxuICB9KTsgLy8gaW52YXJpYW50TE9TKG9ic2VydmFibGUsIFwiY29uZmlybWVkIGVuZFwiKTtcbn0gLy8gVXNlZCBieSBjb21wdXRlZCB3aGVuIGl0cyBkZXBlbmRlbmN5IGNoYW5nZWQsIGJ1dCB3ZSBkb24ndCB3YW4ndCB0byBpbW1lZGlhdGVseSByZWNvbXB1dGUuXG5cbmZ1bmN0aW9uIHByb3BhZ2F0ZU1heWJlQ2hhbmdlZChvYnNlcnZhYmxlKSB7XG4gIC8vIGludmFyaWFudExPUyhvYnNlcnZhYmxlLCBcIm1heWJlIHN0YXJ0XCIpO1xuICBpZiAob2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyAhPT0gSURlcml2YXRpb25TdGF0ZV8uVVBfVE9fREFURV8pIHJldHVybjtcbiAgb2JzZXJ2YWJsZS5sb3dlc3RPYnNlcnZlclN0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXztcbiAgb2JzZXJ2YWJsZS5vYnNlcnZlcnNfLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAoZC5kZXBlbmRlbmNpZXNTdGF0ZV8gPT09IElEZXJpdmF0aW9uU3RhdGVfLlVQX1RPX0RBVEVfKSB7XG4gICAgICBkLmRlcGVuZGVuY2llc1N0YXRlXyA9IElEZXJpdmF0aW9uU3RhdGVfLlBPU1NJQkxZX1NUQUxFXztcbiAgICAgIGQub25CZWNvbWVTdGFsZV8oKTtcbiAgICB9XG4gIH0pOyAvLyBpbnZhcmlhbnRMT1Mob2JzZXJ2YWJsZSwgXCJtYXliZSBlbmRcIik7XG59XG5cbmZ1bmN0aW9uIGxvZ1RyYWNlSW5mbyhkZXJpdmF0aW9uLCBvYnNlcnZhYmxlKSB7XG4gIGNvbnNvbGUubG9nKFwiW21vYngudHJhY2VdICdcIiArIGRlcml2YXRpb24ubmFtZV8gKyBcIicgaXMgaW52YWxpZGF0ZWQgZHVlIHRvIGEgY2hhbmdlIGluOiAnXCIgKyBvYnNlcnZhYmxlLm5hbWVfICsgXCInXCIpO1xuXG4gIGlmIChkZXJpdmF0aW9uLmlzVHJhY2luZ18gPT09IFRyYWNlTW9kZS5CUkVBSykge1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHByaW50RGVwVHJlZShnZXREZXBlbmRlbmN5VHJlZShkZXJpdmF0aW9uKSwgbGluZXMsIDEpOyAvLyBwcmV0dGllci1pZ25vcmVcblxuICAgIG5ldyBGdW5jdGlvbihcImRlYnVnZ2VyO1xcbi8qXFxuVHJhY2luZyAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInXFxuXFxuWW91IGFyZSBlbnRlcmluZyB0aGlzIGJyZWFrIHBvaW50IGJlY2F1c2UgZGVyaXZhdGlvbiAnXCIgKyBkZXJpdmF0aW9uLm5hbWVfICsgXCInIGlzIGJlaW5nIHRyYWNlZCBhbmQgJ1wiICsgb2JzZXJ2YWJsZS5uYW1lXyArIFwiJyBpcyBub3cgZm9yY2luZyBpdCB0byB1cGRhdGUuXFxuSnVzdCBmb2xsb3cgdGhlIHN0YWNrdHJhY2UgeW91IHNob3VsZCBub3cgc2VlIGluIHRoZSBkZXZ0b29scyB0byBzZWUgcHJlY2lzZWx5IHdoYXQgcGllY2Ugb2YgeW91ciBjb2RlIGlzIGNhdXNpbmcgdGhpcyB1cGRhdGVcXG5UaGUgc3RhY2tmcmFtZSB5b3UgYXJlIGxvb2tpbmcgZm9yIGlzIGF0IGxlYXN0IH42LTggc3RhY2stZnJhbWVzIHVwLlxcblxcblwiICsgKGRlcml2YXRpb24gaW5zdGFuY2VvZiBDb21wdXRlZFZhbHVlID8gZGVyaXZhdGlvbi5kZXJpdmF0aW9uLnRvU3RyaW5nKCkucmVwbGFjZSgvWypdXFwvL2csIFwiL1wiKSA6IFwiXCIpICsgXCJcXG5cXG5UaGUgZGVwZW5kZW5jaWVzIGZvciB0aGlzIGRlcml2YXRpb24gYXJlOlxcblxcblwiICsgbGluZXMuam9pbihcIlxcblwiKSArIFwiXFxuKi9cXG4gICAgXCIpKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnREZXBUcmVlKHRyZWUsIGxpbmVzLCBkZXB0aCkge1xuICBpZiAobGluZXMubGVuZ3RoID49IDEwMDApIHtcbiAgICBsaW5lcy5wdXNoKFwiKGFuZCBtYW55IG1vcmUpXCIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxpbmVzLnB1c2goXCJcIiArIG5ldyBBcnJheShkZXB0aCkuam9pbihcIlxcdFwiKSArIHRyZWUubmFtZSk7IC8vIE1XRTogbm90IHRoZSBmYXN0ZXN0LCBidXQgdGhlIGVhc2llc3Qgd2F5IDopXG5cbiAgaWYgKHRyZWUuZGVwZW5kZW5jaWVzKSB0cmVlLmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBwcmludERlcFRyZWUoY2hpbGQsIGxpbmVzLCBkZXB0aCArIDEpO1xuICB9KTtcbn1cblxudmFyIFJlYWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gbm9kZXMgd2UgYXJlIGxvb2tpbmcgYXQuIE91ciB2YWx1ZSBkZXBlbmRzIG9uIHRoZXNlIG5vZGVzXG4gIGZ1bmN0aW9uIFJlYWN0aW9uKG5hbWVfLCBvbkludmFsaWRhdGVfLCBlcnJvckhhbmRsZXJfLCByZXF1aXJlc09ic2VydmFibGVfKSB7XG4gICAgaWYgKG5hbWVfID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWVfID0gIFwiUmVhY3Rpb25AXCIgKyBnZXROZXh0SWQoKSA7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVpcmVzT2JzZXJ2YWJsZV8gPT09IHZvaWQgMCkge1xuICAgICAgcmVxdWlyZXNPYnNlcnZhYmxlXyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5vbkludmFsaWRhdGVfID0gdm9pZCAwO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyXyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlcXVpcmVzT2JzZXJ2YWJsZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5vYnNlcnZpbmdfID0gW107XG4gICAgdGhpcy5uZXdPYnNlcnZpbmdfID0gW107XG4gICAgdGhpcy5kZXBlbmRlbmNpZXNTdGF0ZV8gPSBJRGVyaXZhdGlvblN0YXRlXy5OT1RfVFJBQ0tJTkdfO1xuICAgIHRoaXMuZGlmZlZhbHVlXyA9IDA7XG4gICAgdGhpcy5ydW5JZF8gPSAwO1xuICAgIHRoaXMudW5ib3VuZERlcHNDb3VudF8gPSAwO1xuICAgIHRoaXMuaXNEaXNwb3NlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmlzU2NoZWR1bGVkXyA9IGZhbHNlO1xuICAgIHRoaXMuaXNUcmFja1BlbmRpbmdfID0gZmFsc2U7XG4gICAgdGhpcy5pc1J1bm5pbmdfID0gZmFsc2U7XG4gICAgdGhpcy5pc1RyYWNpbmdfID0gVHJhY2VNb2RlLk5PTkU7XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuICAgIHRoaXMub25JbnZhbGlkYXRlXyA9IG9uSW52YWxpZGF0ZV87XG4gICAgdGhpcy5lcnJvckhhbmRsZXJfID0gZXJyb3JIYW5kbGVyXztcbiAgICB0aGlzLnJlcXVpcmVzT2JzZXJ2YWJsZV8gPSByZXF1aXJlc09ic2VydmFibGVfO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlYWN0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8ub25CZWNvbWVTdGFsZV8gPSBmdW5jdGlvbiBvbkJlY29tZVN0YWxlXygpIHtcbiAgICB0aGlzLnNjaGVkdWxlXygpO1xuICB9O1xuXG4gIF9wcm90by5zY2hlZHVsZV8gPSBmdW5jdGlvbiBzY2hlZHVsZV8oKSB7XG4gICAgaWYgKCF0aGlzLmlzU2NoZWR1bGVkXykge1xuICAgICAgdGhpcy5pc1NjaGVkdWxlZF8gPSB0cnVlO1xuICAgICAgZ2xvYmFsU3RhdGUucGVuZGluZ1JlYWN0aW9ucy5wdXNoKHRoaXMpO1xuICAgICAgcnVuUmVhY3Rpb25zKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5pc1NjaGVkdWxlZCA9IGZ1bmN0aW9uIGlzU2NoZWR1bGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzU2NoZWR1bGVkXztcbiAgfVxuICAvKipcclxuICAgKiBpbnRlcm5hbCwgdXNlIHNjaGVkdWxlKCkgaWYgeW91IGludGVuZCB0byBraWNrIG9mZiBhIHJlYWN0aW9uXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucnVuUmVhY3Rpb25fID0gZnVuY3Rpb24gcnVuUmVhY3Rpb25fKCkge1xuICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkXykge1xuICAgICAgc3RhcnRCYXRjaCgpO1xuICAgICAgdGhpcy5pc1NjaGVkdWxlZF8gPSBmYWxzZTtcbiAgICAgIHZhciBwcmV2ID0gZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0O1xuICAgICAgZ2xvYmFsU3RhdGUudHJhY2tpbmdDb250ZXh0ID0gdGhpcztcblxuICAgICAgaWYgKHNob3VsZENvbXB1dGUodGhpcykpIHtcbiAgICAgICAgdGhpcy5pc1RyYWNrUGVuZGluZ18gPSB0cnVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5vbkludmFsaWRhdGVfKCk7XG5cbiAgICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmlzVHJhY2tQZW5kaW5nXyAmJiBpc1NweUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgLy8gb25JbnZhbGlkYXRlIGRpZG4ndCB0cmlnZ2VyIHRyYWNrIHJpZ2h0IGF3YXkuLlxuICAgICAgICAgICAgc3B5UmVwb3J0KHtcbiAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgICAgICAgdHlwZTogXCJzY2hlZHVsZWQtcmVhY3Rpb25cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5yZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdsb2JhbFN0YXRlLnRyYWNraW5nQ29udGV4dCA9IHByZXY7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udHJhY2sgPSBmdW5jdGlvbiB0cmFjayhmbikge1xuICAgIGlmICh0aGlzLmlzRGlzcG9zZWRfKSB7XG4gICAgICByZXR1cm47IC8vIGNvbnNvbGUud2FybihcIlJlYWN0aW9uIGFscmVhZHkgZGlzcG9zZWRcIikgLy8gTm90ZTogTm90IGEgd2FybmluZyAvIGVycm9yIGluIG1vYnggNCBlaXRoZXJcbiAgICB9XG5cbiAgICBzdGFydEJhdGNoKCk7XG4gICAgdmFyIG5vdGlmeSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBzdGFydFRpbWU7XG5cbiAgICBpZiAoIG5vdGlmeSkge1xuICAgICAgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIHNweVJlcG9ydFN0YXJ0KHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogXCJyZWFjdGlvblwiXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUnVubmluZ18gPSB0cnVlO1xuICAgIHZhciBwcmV2UmVhY3Rpb24gPSBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQ7IC8vIHJlYWN0aW9ucyBjb3VsZCBjcmVhdGUgcmVhY3Rpb25zLi4uXG5cbiAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSB0cmFja0Rlcml2ZWRGdW5jdGlvbih0aGlzLCBmbiwgdW5kZWZpbmVkKTtcbiAgICBnbG9iYWxTdGF0ZS50cmFja2luZ0NvbnRleHQgPSBwcmV2UmVhY3Rpb247XG4gICAgdGhpcy5pc1J1bm5pbmdfID0gZmFsc2U7XG4gICAgdGhpcy5pc1RyYWNrUGVuZGluZ18gPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmlzRGlzcG9zZWRfKSB7XG4gICAgICAvLyBkaXNwb3NlZCBkdXJpbmcgbGFzdCBydW4uIENsZWFuIHVwIGV2ZXJ5dGhpbmcgdGhhdCB3YXMgYm91bmQgYWZ0ZXIgdGhlIGRpc3Bvc2UgY2FsbC5cbiAgICAgIGNsZWFyT2JzZXJ2aW5nKHRoaXMpO1xuICAgIH1cblxuICAgIGlmIChpc0NhdWdodEV4Y2VwdGlvbihyZXN1bHQpKSB0aGlzLnJlcG9ydEV4Y2VwdGlvbkluRGVyaXZhdGlvbl8ocmVzdWx0LmNhdXNlKTtcblxuICAgIGlmICggbm90aWZ5KSB7XG4gICAgICBzcHlSZXBvcnRFbmQoe1xuICAgICAgICB0aW1lOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBlbmRCYXRjaCgpO1xuICB9O1xuXG4gIF9wcm90by5yZXBvcnRFeGNlcHRpb25JbkRlcml2YXRpb25fID0gZnVuY3Rpb24gcmVwb3J0RXhjZXB0aW9uSW5EZXJpdmF0aW9uXyhlcnJvcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5lcnJvckhhbmRsZXJfKSB7XG4gICAgICB0aGlzLmVycm9ySGFuZGxlcl8oZXJyb3IsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChnbG9iYWxTdGF0ZS5kaXNhYmxlRXJyb3JCb3VuZGFyaWVzKSB0aHJvdyBlcnJvcjtcbiAgICB2YXIgbWVzc2FnZSA9ICBcIlttb2J4XSBFbmNvdW50ZXJlZCBhbiB1bmNhdWdodCBleGNlcHRpb24gdGhhdCB3YXMgdGhyb3duIGJ5IGEgcmVhY3Rpb24gb3Igb2JzZXJ2ZXIgY29tcG9uZW50LCBpbjogJ1wiICsgdGhpcyArIFwiJ1wiIDtcblxuICAgIGlmICghZ2xvYmFsU3RhdGUuc3VwcHJlc3NSZWFjdGlvbkVycm9ycykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBlcnJvcik7XG4gICAgICAvKiogSWYgZGVidWdnaW5nIGJyb3VnaHQgeW91IGhlcmUsIHBsZWFzZSwgcmVhZCB0aGUgYWJvdmUgbWVzc2FnZSA6LSkuIFRueCEgKi9cbiAgICB9IGVsc2UgY29uc29sZS53YXJuKFwiW21vYnhdIChlcnJvciBpbiByZWFjdGlvbiAnXCIgKyB0aGlzLm5hbWVfICsgXCInIHN1cHByZXNzZWQsIGZpeCBlcnJvciBvZiBjYXVzaW5nIGFjdGlvbiBiZWxvdylcIik7IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5cbiAgICBpZiAoIGlzU3B5RW5hYmxlZCgpKSB7XG4gICAgICBzcHlSZXBvcnQoe1xuICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIGVycm9yOiBcIlwiICsgZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGdsb2JhbFN0YXRlLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gZihlcnJvciwgX3RoaXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNEaXNwb3NlZF8pIHtcbiAgICAgIHRoaXMuaXNEaXNwb3NlZF8gPSB0cnVlO1xuXG4gICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nXykge1xuICAgICAgICAvLyBpZiBkaXNwb3NlZCB3aGlsZSBydW5uaW5nLCBjbGVhbiB1cCBsYXRlci4gTWF5YmUgbm90IG9wdGltYWwsIGJ1dCByYXJlIGNhc2VcbiAgICAgICAgc3RhcnRCYXRjaCgpO1xuICAgICAgICBjbGVhck9ic2VydmluZyh0aGlzKTtcbiAgICAgICAgZW5kQmF0Y2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldERpc3Bvc2VyXyA9IGZ1bmN0aW9uIGdldERpc3Bvc2VyXygpIHtcbiAgICB2YXIgciA9IHRoaXMuZGlzcG9zZS5iaW5kKHRoaXMpO1xuICAgIHJbJG1vYnhdID0gdGhpcztcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJSZWFjdGlvbltcIiArIHRoaXMubmFtZV8gKyBcIl1cIjtcbiAgfTtcblxuICBfcHJvdG8udHJhY2UgPSBmdW5jdGlvbiB0cmFjZSQxKGVudGVyQnJlYWtQb2ludCkge1xuICAgIGlmIChlbnRlckJyZWFrUG9pbnQgPT09IHZvaWQgMCkge1xuICAgICAgZW50ZXJCcmVha1BvaW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJhY2UodGhpcywgZW50ZXJCcmVha1BvaW50KTtcbiAgfTtcblxuICByZXR1cm4gUmVhY3Rpb247XG59KCk7XG5mdW5jdGlvbiBvblJlYWN0aW9uRXJyb3IoaGFuZGxlcikge1xuICBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gZ2xvYmFsU3RhdGUuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgaWYgKGlkeCA+PSAwKSBnbG9iYWxTdGF0ZS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gIH07XG59XG4vKipcclxuICogTWFnaWMgbnVtYmVyIGFsZXJ0IVxyXG4gKiBEZWZpbmVzIHdpdGhpbiBob3cgbWFueSB0aW1lcyBhIHJlYWN0aW9uIGlzIGFsbG93ZWQgdG8gcmUtdHJpZ2dlciBpdHNlbGZcclxuICogdW50aWwgaXQgaXMgYXNzdW1lZCB0aGF0IHRoaXMgaXMgZ29ubmEgYmUgYSBuZXZlciBlbmRpbmcgbG9vcC4uLlxyXG4gKi9cblxudmFyIE1BWF9SRUFDVElPTl9JVEVSQVRJT05TID0gMTAwO1xuXG52YXIgcmVhY3Rpb25TY2hlZHVsZXIgPSBmdW5jdGlvbiByZWFjdGlvblNjaGVkdWxlcihmKSB7XG4gIHJldHVybiBmKCk7XG59O1xuXG5mdW5jdGlvbiBydW5SZWFjdGlvbnMoKSB7XG4gIC8vIFRyYW1wb2xpbmluZywgaWYgcnVuUmVhY3Rpb25zIGFyZSBhbHJlYWR5IHJ1bm5pbmcsIG5ldyByZWFjdGlvbnMgd2lsbCBiZSBwaWNrZWQgdXBcbiAgaWYgKGdsb2JhbFN0YXRlLmluQmF0Y2ggPiAwIHx8IGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucykgcmV0dXJuO1xuICByZWFjdGlvblNjaGVkdWxlcihydW5SZWFjdGlvbnNIZWxwZXIpO1xufVxuXG5mdW5jdGlvbiBydW5SZWFjdGlvbnNIZWxwZXIoKSB7XG4gIGdsb2JhbFN0YXRlLmlzUnVubmluZ1JlYWN0aW9ucyA9IHRydWU7XG4gIHZhciBhbGxSZWFjdGlvbnMgPSBnbG9iYWxTdGF0ZS5wZW5kaW5nUmVhY3Rpb25zO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7IC8vIFdoaWxlIHJ1bm5pbmcgcmVhY3Rpb25zLCBuZXcgcmVhY3Rpb25zIG1pZ2h0IGJlIHRyaWdnZXJlZC5cbiAgLy8gSGVuY2Ugd2Ugd29yayB3aXRoIHR3byB2YXJpYWJsZXMgYW5kIGNoZWNrIHdoZXRoZXJcbiAgLy8gd2UgY29udmVyZ2UgdG8gbm8gcmVtYWluaW5nIHJlYWN0aW9ucyBhZnRlciBhIHdoaWxlLlxuXG4gIHdoaWxlIChhbGxSZWFjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIGlmICgrK2l0ZXJhdGlvbnMgPT09IE1BWF9SRUFDVElPTl9JVEVSQVRJT05TKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCBcIlJlYWN0aW9uIGRvZXNuJ3QgY29udmVyZ2UgdG8gYSBzdGFibGUgc3RhdGUgYWZ0ZXIgXCIgKyBNQVhfUkVBQ1RJT05fSVRFUkFUSU9OUyArIFwiIGl0ZXJhdGlvbnMuXCIgKyAoXCIgUHJvYmFibHkgdGhlcmUgaXMgYSBjeWNsZSBpbiB0aGUgcmVhY3RpdmUgZnVuY3Rpb246IFwiICsgYWxsUmVhY3Rpb25zWzBdKSApO1xuICAgICAgYWxsUmVhY3Rpb25zLnNwbGljZSgwKTsgLy8gY2xlYXIgcmVhY3Rpb25zXG4gICAgfVxuXG4gICAgdmFyIHJlbWFpbmluZ1JlYWN0aW9ucyA9IGFsbFJlYWN0aW9ucy5zcGxpY2UoMCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlbWFpbmluZ1JlYWN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlbWFpbmluZ1JlYWN0aW9uc1tpXS5ydW5SZWFjdGlvbl8oKTtcbiAgICB9XG4gIH1cblxuICBnbG9iYWxTdGF0ZS5pc1J1bm5pbmdSZWFjdGlvbnMgPSBmYWxzZTtcbn1cblxudmFyIGlzUmVhY3Rpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIlJlYWN0aW9uXCIsIFJlYWN0aW9uKTtcbmZ1bmN0aW9uIHNldFJlYWN0aW9uU2NoZWR1bGVyKGZuKSB7XG4gIHZhciBiYXNlU2NoZWR1bGVyID0gcmVhY3Rpb25TY2hlZHVsZXI7XG5cbiAgcmVhY3Rpb25TY2hlZHVsZXIgPSBmdW5jdGlvbiByZWFjdGlvblNjaGVkdWxlcihmKSB7XG4gICAgcmV0dXJuIGZuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBiYXNlU2NoZWR1bGVyKGYpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc1NweUVuYWJsZWQoKSB7XG4gIHJldHVybiAgISFnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMubGVuZ3RoO1xufVxuZnVuY3Rpb24gc3B5UmVwb3J0KGV2ZW50KSB7XG5cbiAgaWYgKCFnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBsaXN0ZW5lcnMgPSBnbG9iYWxTdGF0ZS5zcHlMaXN0ZW5lcnM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldKGV2ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gc3B5UmVwb3J0U3RhcnQoZXZlbnQpIHtcblxuICB2YXIgY2hhbmdlID0gX2V4dGVuZHMoe30sIGV2ZW50LCB7XG4gICAgc3B5UmVwb3J0U3RhcnQ6IHRydWVcbiAgfSk7XG5cbiAgc3B5UmVwb3J0KGNoYW5nZSk7XG59XG52YXIgRU5EX0VWRU5UID0ge1xuICB0eXBlOiBcInJlcG9ydC1lbmRcIixcbiAgc3B5UmVwb3J0RW5kOiB0cnVlXG59O1xuZnVuY3Rpb24gc3B5UmVwb3J0RW5kKGNoYW5nZSkge1xuICBpZiAoY2hhbmdlKSBzcHlSZXBvcnQoX2V4dGVuZHMoe30sIGNoYW5nZSwge1xuICAgIHR5cGU6IFwicmVwb3J0LWVuZFwiLFxuICAgIHNweVJlcG9ydEVuZDogdHJ1ZVxuICB9KSk7ZWxzZSBzcHlSZXBvcnQoRU5EX0VWRU5UKTtcbn1cbmZ1bmN0aW9uIHNweShsaXN0ZW5lcikge1xuICB7XG4gICAgZ2xvYmFsU3RhdGUuc3B5TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybiBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycyA9IGdsb2JhbFN0YXRlLnNweUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgcmV0dXJuIGwgIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIEFDVElPTiA9IFwiYWN0aW9uXCI7XG52YXIgQUNUSU9OX0JPVU5EID0gXCJhY3Rpb24uYm91bmRcIjtcbnZhciBBVVRPQUNUSU9OID0gXCJhdXRvQWN0aW9uXCI7XG52YXIgQVVUT0FDVElPTl9CT1VORCA9IFwiYXV0b0FjdGlvbi5ib3VuZFwiO1xudmFyIERFRkFVTFRfQUNUSU9OX05BTUUgPSBcIjx1bm5hbWVkIGFjdGlvbj5cIjtcbnZhciBhY3Rpb25Bbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQUNUSU9OKTtcbnZhciBhY3Rpb25Cb3VuZEFubm90YXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlQWN0aW9uQW5ub3RhdGlvbihBQ1RJT05fQk9VTkQsIHtcbiAgYm91bmQ6IHRydWVcbn0pO1xudmFyIGF1dG9BY3Rpb25Bbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQVVUT0FDVElPTiwge1xuICBhdXRvQWN0aW9uOiB0cnVlXG59KTtcbnZhciBhdXRvQWN0aW9uQm91bmRBbm5vdGF0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkFubm90YXRpb24oQVVUT0FDVElPTl9CT1VORCwge1xuICBhdXRvQWN0aW9uOiB0cnVlLFxuICBib3VuZDogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkZhY3RvcnkoYXV0b0FjdGlvbikge1xuICB2YXIgcmVzID0gZnVuY3Rpb24gYWN0aW9uKGFyZzEsIGFyZzIpIHtcbiAgICAvLyBhY3Rpb24oZm4oKSB7fSlcbiAgICBpZiAoaXNGdW5jdGlvbihhcmcxKSkgcmV0dXJuIGNyZWF0ZUFjdGlvbihhcmcxLm5hbWUgfHwgREVGQVVMVF9BQ1RJT05fTkFNRSwgYXJnMSwgYXV0b0FjdGlvbik7IC8vIGFjdGlvbihcIm5hbWVcIiwgZm4oKSB7fSlcblxuICAgIGlmIChpc0Z1bmN0aW9uKGFyZzIpKSByZXR1cm4gY3JlYXRlQWN0aW9uKGFyZzEsIGFyZzIsIGF1dG9BY3Rpb24pOyAvLyBAYWN0aW9uXG5cbiAgICBpZiAoaXNTdHJpbmdpc2goYXJnMikpIHtcbiAgICAgIHJldHVybiBzdG9yZUFubm90YXRpb24oYXJnMSwgYXJnMiwgYXV0b0FjdGlvbiA/IGF1dG9BY3Rpb25Bbm5vdGF0aW9uIDogYWN0aW9uQW5ub3RhdGlvbik7XG4gICAgfSAvLyBhY3Rpb24oXCJuYW1lXCIpICYgQGFjdGlvbihcIm5hbWVcIilcblxuXG4gICAgaWYgKGlzU3RyaW5naXNoKGFyZzEpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGVjb3JhdG9yQW5ub3RhdGlvbihjcmVhdGVBY3Rpb25Bbm5vdGF0aW9uKGF1dG9BY3Rpb24gPyBBVVRPQUNUSU9OIDogQUNUSU9OLCB7XG4gICAgICAgIG5hbWU6IGFyZzEsXG4gICAgICAgIGF1dG9BY3Rpb246IGF1dG9BY3Rpb25cbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBkaWUoXCJJbnZhbGlkIGFyZ3VtZW50cyBmb3IgYGFjdGlvbmBcIik7XG4gIH07XG5cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIGFjdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVBY3Rpb25GYWN0b3J5KGZhbHNlKTtcbk9iamVjdC5hc3NpZ24oYWN0aW9uLCBhY3Rpb25Bbm5vdGF0aW9uKTtcbnZhciBhdXRvQWN0aW9uID0gLyojX19QVVJFX18qL2NyZWF0ZUFjdGlvbkZhY3RvcnkodHJ1ZSk7XG5PYmplY3QuYXNzaWduKGF1dG9BY3Rpb24sIGF1dG9BY3Rpb25Bbm5vdGF0aW9uKTtcbmFjdGlvbi5ib3VuZCA9IC8qI19fUFVSRV9fKi9jcmVhdGVEZWNvcmF0b3JBbm5vdGF0aW9uKGFjdGlvbkJvdW5kQW5ub3RhdGlvbik7XG5hdXRvQWN0aW9uLmJvdW5kID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oYXV0b0FjdGlvbkJvdW5kQW5ub3RhdGlvbik7XG5mdW5jdGlvbiBydW5JbkFjdGlvbihmbikge1xuICByZXR1cm4gZXhlY3V0ZUFjdGlvbihmbi5uYW1lIHx8IERFRkFVTFRfQUNUSU9OX05BTUUsIGZhbHNlLCBmbiwgdGhpcywgdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGlzQWN0aW9uKHRoaW5nKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHRoaW5nKSAmJiB0aGluZy5pc01vYnhBY3Rpb24gPT09IHRydWU7XG59XG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmFtZWQgcmVhY3RpdmUgdmlldyBhbmQga2VlcHMgaXQgYWxpdmUsIHNvIHRoYXQgdGhlIHZpZXcgaXMgYWx3YXlzXHJcbiAqIHVwZGF0ZWQgaWYgb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcywgZXZlbiB3aGVuIHRoZSB2aWV3IGlzIG5vdCBmdXJ0aGVyIHVzZWQgYnkgc29tZXRoaW5nIGVsc2UuXHJcbiAqIEBwYXJhbSB2aWV3IFRoZSByZWFjdGl2ZSB2aWV3XHJcbiAqIEByZXR1cm5zIGRpc3Bvc2VyIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCB0byBzdG9wIHRoZSB2aWV3IGZyb20gYmVpbmcgdXBkYXRlZCBpbiB0aGUgZnV0dXJlLlxyXG4gKi9cblxuZnVuY3Rpb24gYXV0b3J1bih2aWV3LCBvcHRzKSB7XG4gIHZhciBfb3B0cyRuYW1lLCBfb3B0cztcblxuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IEVNUFRZX09CSkVDVDtcbiAgfVxuXG4gIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24odmlldykpIGRpZShcIkF1dG9ydW4gZXhwZWN0cyBhIGZ1bmN0aW9uIGFzIGZpcnN0IGFyZ3VtZW50XCIpO1xuICAgIGlmIChpc0FjdGlvbih2aWV3KSkgZGllKFwiQXV0b3J1biBkb2VzIG5vdCBhY2NlcHQgYWN0aW9ucyBzaW5jZSBhY3Rpb25zIGFyZSB1bnRyYWNrYWJsZVwiKTtcbiAgfVxuXG4gIHZhciBuYW1lID0gKF9vcHRzJG5hbWUgPSAoX29wdHMgPSBvcHRzKSA9PSBudWxsID8gdm9pZCAwIDogX29wdHMubmFtZSkgIT0gbnVsbCA/IF9vcHRzJG5hbWUgOiAgdmlldy5uYW1lIHx8IFwiQXV0b3J1bkBcIiArIGdldE5leHRJZCgpIDtcbiAgdmFyIHJ1blN5bmMgPSAhb3B0cy5zY2hlZHVsZXIgJiYgIW9wdHMuZGVsYXk7XG4gIHZhciByZWFjdGlvbjtcblxuICBpZiAocnVuU3luYykge1xuICAgIC8vIG5vcm1hbCBhdXRvcnVuXG4gICAgcmVhY3Rpb24gPSBuZXcgUmVhY3Rpb24obmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmFjayhyZWFjdGlvblJ1bm5lcik7XG4gICAgfSwgb3B0cy5vbkVycm9yLCBvcHRzLnJlcXVpcmVzT2JzZXJ2YWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNjaGVkdWxlciA9IGNyZWF0ZVNjaGVkdWxlckZyb21PcHRpb25zKG9wdHMpOyAvLyBkZWJvdW5jZWQgYXV0b3J1blxuXG4gICAgdmFyIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgcmVhY3Rpb24gPSBuZXcgUmVhY3Rpb24obmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHNjaGVkdWxlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIXJlYWN0aW9uLmlzRGlzcG9zZWRfKSByZWFjdGlvbi50cmFjayhyZWFjdGlvblJ1bm5lcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIG9wdHMub25FcnJvciwgb3B0cy5yZXF1aXJlc09ic2VydmFibGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3Rpb25SdW5uZXIoKSB7XG4gICAgdmlldyhyZWFjdGlvbik7XG4gIH1cblxuICByZWFjdGlvbi5zY2hlZHVsZV8oKTtcbiAgcmV0dXJuIHJlYWN0aW9uLmdldERpc3Bvc2VyXygpO1xufVxuXG52YXIgcnVuID0gZnVuY3Rpb24gcnVuKGYpIHtcbiAgcmV0dXJuIGYoKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjaGVkdWxlckZyb21PcHRpb25zKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMuc2NoZWR1bGVyID8gb3B0cy5zY2hlZHVsZXIgOiBvcHRzLmRlbGF5ID8gZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmLCBvcHRzLmRlbGF5KTtcbiAgfSA6IHJ1bjtcbn1cblxuZnVuY3Rpb24gcmVhY3Rpb24oZXhwcmVzc2lvbiwgZWZmZWN0LCBvcHRzKSB7XG4gIHZhciBfb3B0cyRuYW1lMjtcblxuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IEVNUFRZX09CSkVDVDtcbiAgfVxuXG4gIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oZXhwcmVzc2lvbikgfHwgIWlzRnVuY3Rpb24oZWZmZWN0KSkgZGllKFwiRmlyc3QgYW5kIHNlY29uZCBhcmd1bWVudCB0byByZWFjdGlvbiBzaG91bGQgYmUgZnVuY3Rpb25zXCIpO1xuICAgIGlmICghaXNQbGFpbk9iamVjdChvcHRzKSkgZGllKFwiVGhpcmQgYXJndW1lbnQgb2YgcmVhY3Rpb25zIHNob3VsZCBiZSBhbiBvYmplY3RcIik7XG4gIH1cblxuICB2YXIgbmFtZSA9IChfb3B0cyRuYW1lMiA9IG9wdHMubmFtZSkgIT0gbnVsbCA/IF9vcHRzJG5hbWUyIDogIFwiUmVhY3Rpb25AXCIgKyBnZXROZXh0SWQoKSA7XG4gIHZhciBlZmZlY3RBY3Rpb24gPSBhY3Rpb24obmFtZSwgb3B0cy5vbkVycm9yID8gd3JhcEVycm9ySGFuZGxlcihvcHRzLm9uRXJyb3IsIGVmZmVjdCkgOiBlZmZlY3QpO1xuICB2YXIgcnVuU3luYyA9ICFvcHRzLnNjaGVkdWxlciAmJiAhb3B0cy5kZWxheTtcbiAgdmFyIHNjaGVkdWxlciA9IGNyZWF0ZVNjaGVkdWxlckZyb21PcHRpb25zKG9wdHMpO1xuICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcbiAgdmFyIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIG9sZFZhbHVlID0gdW5kZWZpbmVkOyAvLyBvbmx5IGFuIGlzc3VlIHdpdGggZmlyZUltbWVkaWF0ZWx5XG5cbiAgdmFyIGVxdWFscyA9IG9wdHMuY29tcGFyZVN0cnVjdHVyYWwgPyBjb21wYXJlci5zdHJ1Y3R1cmFsIDogb3B0cy5lcXVhbHMgfHwgY29tcGFyZXJbXCJkZWZhdWx0XCJdO1xuICB2YXIgciA9IG5ldyBSZWFjdGlvbihuYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZpcnN0VGltZSB8fCBydW5TeW5jKSB7XG4gICAgICByZWFjdGlvblJ1bm5lcigpO1xuICAgIH0gZWxzZSBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzY2hlZHVsZXIocmVhY3Rpb25SdW5uZXIpO1xuICAgIH1cbiAgfSwgb3B0cy5vbkVycm9yLCBvcHRzLnJlcXVpcmVzT2JzZXJ2YWJsZSk7XG5cbiAgZnVuY3Rpb24gcmVhY3Rpb25SdW5uZXIoKSB7XG4gICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBpZiAoci5pc0Rpc3Bvc2VkXykgcmV0dXJuO1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgci50cmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmV4dFZhbHVlID0gYWxsb3dTdGF0ZUNoYW5nZXMoZmFsc2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24ocik7XG4gICAgICB9KTtcbiAgICAgIGNoYW5nZWQgPSBmaXJzdFRpbWUgfHwgIWVxdWFscyh2YWx1ZSwgbmV4dFZhbHVlKTtcbiAgICAgIG9sZFZhbHVlID0gdmFsdWU7XG4gICAgICB2YWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB9KTtcbiAgICBpZiAoZmlyc3RUaW1lICYmIG9wdHMuZmlyZUltbWVkaWF0ZWx5KSBlZmZlY3RBY3Rpb24odmFsdWUsIG9sZFZhbHVlLCByKTtlbHNlIGlmICghZmlyc3RUaW1lICYmIGNoYW5nZWQpIGVmZmVjdEFjdGlvbih2YWx1ZSwgb2xkVmFsdWUsIHIpO1xuICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICB9XG5cbiAgci5zY2hlZHVsZV8oKTtcbiAgcmV0dXJuIHIuZ2V0RGlzcG9zZXJfKCk7XG59XG5cbmZ1bmN0aW9uIHdyYXBFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyLCBiYXNlRm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJhc2VGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ySGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIE9OX0JFQ09NRV9PQlNFUlZFRCA9IFwib25CT1wiO1xudmFyIE9OX0JFQ09NRV9VTk9CU0VSVkVEID0gXCJvbkJVT1wiO1xuZnVuY3Rpb24gb25CZWNvbWVPYnNlcnZlZCh0aGluZywgYXJnMiwgYXJnMykge1xuICByZXR1cm4gaW50ZXJjZXB0SG9vayhPTl9CRUNPTUVfT0JTRVJWRUQsIHRoaW5nLCBhcmcyLCBhcmczKTtcbn1cbmZ1bmN0aW9uIG9uQmVjb21lVW5vYnNlcnZlZCh0aGluZywgYXJnMiwgYXJnMykge1xuICByZXR1cm4gaW50ZXJjZXB0SG9vayhPTl9CRUNPTUVfVU5PQlNFUlZFRCwgdGhpbmcsIGFyZzIsIGFyZzMpO1xufVxuXG5mdW5jdGlvbiBpbnRlcmNlcHRIb29rKGhvb2ssIHRoaW5nLCBhcmcyLCBhcmczKSB7XG4gIHZhciBhdG9tID0gdHlwZW9mIGFyZzMgPT09IFwiZnVuY3Rpb25cIiA/IGdldEF0b20odGhpbmcsIGFyZzIpIDogZ2V0QXRvbSh0aGluZyk7XG4gIHZhciBjYiA9IGlzRnVuY3Rpb24oYXJnMykgPyBhcmczIDogYXJnMjtcbiAgdmFyIGxpc3RlbmVyc0tleSA9IGhvb2sgKyBcIkxcIjtcblxuICBpZiAoYXRvbVtsaXN0ZW5lcnNLZXldKSB7XG4gICAgYXRvbVtsaXN0ZW5lcnNLZXldLmFkZChjYik7XG4gIH0gZWxzZSB7XG4gICAgYXRvbVtsaXN0ZW5lcnNLZXldID0gbmV3IFNldChbY2JdKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvb2tMaXN0ZW5lcnMgPSBhdG9tW2xpc3RlbmVyc0tleV07XG5cbiAgICBpZiAoaG9va0xpc3RlbmVycykge1xuICAgICAgaG9va0xpc3RlbmVyc1tcImRlbGV0ZVwiXShjYik7XG5cbiAgICAgIGlmIChob29rTGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIGF0b21bbGlzdGVuZXJzS2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciBORVZFUiA9IFwibmV2ZXJcIjtcbnZhciBBTFdBWVMgPSBcImFsd2F5c1wiO1xudmFyIE9CU0VSVkVEID0gXCJvYnNlcnZlZFwiOyAvLyBjb25zdCBJRl9BVkFJTEFCTEUgPSBcImlmYXZhaWxhYmxlXCJcblxuZnVuY3Rpb24gY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuaXNvbGF0ZUdsb2JhbFN0YXRlID09PSB0cnVlKSB7XG4gICAgaXNvbGF0ZUdsb2JhbFN0YXRlKCk7XG4gIH1cblxuICB2YXIgdXNlUHJveGllcyA9IG9wdGlvbnMudXNlUHJveGllcyxcbiAgICAgIGVuZm9yY2VBY3Rpb25zID0gb3B0aW9ucy5lbmZvcmNlQWN0aW9ucztcblxuICBpZiAodXNlUHJveGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2xvYmFsU3RhdGUudXNlUHJveGllcyA9IHVzZVByb3hpZXMgPT09IEFMV0FZUyA/IHRydWUgOiB1c2VQcm94aWVzID09PSBORVZFUiA/IGZhbHNlIDogdHlwZW9mIFByb3h5ICE9PSBcInVuZGVmaW5lZFwiO1xuICB9XG5cbiAgaWYgKHVzZVByb3hpZXMgPT09IFwiaWZhdmFpbGFibGVcIikgZ2xvYmFsU3RhdGUudmVyaWZ5UHJveGllcyA9IHRydWU7XG5cbiAgaWYgKGVuZm9yY2VBY3Rpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZWEgPSBlbmZvcmNlQWN0aW9ucyA9PT0gQUxXQVlTID8gQUxXQVlTIDogZW5mb3JjZUFjdGlvbnMgPT09IE9CU0VSVkVEO1xuICAgIGdsb2JhbFN0YXRlLmVuZm9yY2VBY3Rpb25zID0gZWE7XG4gICAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZUNoYW5nZXMgPSBlYSA9PT0gdHJ1ZSB8fCBlYSA9PT0gQUxXQVlTID8gZmFsc2UgOiB0cnVlO1xuICB9XG4gIFtcImNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvblwiLCBcInJlYWN0aW9uUmVxdWlyZXNPYnNlcnZhYmxlXCIsIFwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25cIiwgXCJkaXNhYmxlRXJyb3JCb3VuZGFyaWVzXCIsIFwic2FmZURlc2NyaXB0b3JzXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgaW4gb3B0aW9ucykgZ2xvYmFsU3RhdGVba2V5XSA9ICEhb3B0aW9uc1trZXldO1xuICB9KTtcbiAgZ2xvYmFsU3RhdGUuYWxsb3dTdGF0ZVJlYWRzID0gIWdsb2JhbFN0YXRlLm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uO1xuXG4gIGlmICggZ2xvYmFsU3RhdGUuZGlzYWJsZUVycm9yQm91bmRhcmllcyA9PT0gdHJ1ZSkge1xuICAgIGNvbnNvbGUud2FybihcIldBUk5JTkc6IERlYnVnIGZlYXR1cmUgb25seS4gTW9iWCB3aWxsIE5PVCByZWNvdmVyIGZyb20gZXJyb3JzIHdoZW4gYGRpc2FibGVFcnJvckJvdW5kYXJpZXNgIGlzIGVuYWJsZWQuXCIpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVhY3Rpb25TY2hlZHVsZXIpIHtcbiAgICBzZXRSZWFjdGlvblNjaGVkdWxlcihvcHRpb25zLnJlYWN0aW9uU2NoZWR1bGVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRlbmRPYnNlcnZhYmxlKHRhcmdldCwgcHJvcGVydGllcywgYW5ub3RhdGlvbnMsIG9wdGlvbnMpIHtcbiAge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gNCkgZGllKFwiJ2V4dGVuZE9ic2VydmFibGUnIGV4cGVjdGVkIDItNCBhcmd1bWVudHNcIik7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIpIGRpZShcIidleHRlbmRPYnNlcnZhYmxlJyBleHBlY3RzIGFuIG9iamVjdCBhcyBmaXJzdCBhcmd1bWVudFwiKTtcbiAgICBpZiAoaXNPYnNlcnZhYmxlTWFwKHRhcmdldCkpIGRpZShcIidleHRlbmRPYnNlcnZhYmxlJyBzaG91bGQgbm90IGJlIHVzZWQgb24gbWFwcywgdXNlIG1hcC5tZXJnZSBpbnN0ZWFkXCIpO1xuICAgIGlmICghaXNQbGFpbk9iamVjdChwcm9wZXJ0aWVzKSkgZGllKFwiJ2V4dGVuZE9ic2VydmFiZScgb25seSBhY2NlcHRzIHBsYWluIG9iamVjdHMgYXMgc2Vjb25kIGFyZ3VtZW50XCIpO1xuICAgIGlmIChpc09ic2VydmFibGUocHJvcGVydGllcykgfHwgaXNPYnNlcnZhYmxlKGFubm90YXRpb25zKSkgZGllKFwiRXh0ZW5kaW5nIGFuIG9iamVjdCB3aXRoIGFub3RoZXIgb2JzZXJ2YWJsZSAob2JqZWN0KSBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICB9IC8vIFB1bGwgZGVzY3JpcHRvcnMgZmlyc3QsIHNvIHdlIGRvbid0IGhhdmUgdG8gZGVhbCB3aXRoIHByb3BzIGFkZGVkIGJ5IGFkbWluaXN0cmF0aW9uICgkbW9ieClcblxuXG4gIHZhciBkZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocHJvcGVydGllcyk7XG4gIHZhciBhZG0gPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKVskbW9ieF07XG4gIHN0YXJ0QmF0Y2goKTtcblxuICB0cnkge1xuICAgIG93bktleXMoZGVzY3JpcHRvcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgYWRtLmV4dGVuZF8oa2V5LCBkZXNjcmlwdG9yc1trZXldLCAvLyBtdXN0IHBhc3MgXCJ1bmRlZmluZWRcIiBmb3IgeyBrZXk6IHVuZGVmaW5lZCB9XG4gICAgICAhYW5ub3RhdGlvbnMgPyB0cnVlIDoga2V5IGluIGFubm90YXRpb25zID8gYW5ub3RhdGlvbnNba2V5XSA6IHRydWUpO1xuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGVuZEJhdGNoKCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmN5VHJlZSh0aGluZywgcHJvcGVydHkpIHtcbiAgcmV0dXJuIG5vZGVUb0RlcGVuZGVuY3lUcmVlKGdldEF0b20odGhpbmcsIHByb3BlcnR5KSk7XG59XG5cbmZ1bmN0aW9uIG5vZGVUb0RlcGVuZGVuY3lUcmVlKG5vZGUpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBuYW1lOiBub2RlLm5hbWVfXG4gIH07XG4gIGlmIChub2RlLm9ic2VydmluZ18gJiYgbm9kZS5vYnNlcnZpbmdfLmxlbmd0aCA+IDApIHJlc3VsdC5kZXBlbmRlbmNpZXMgPSB1bmlxdWUobm9kZS5vYnNlcnZpbmdfKS5tYXAobm9kZVRvRGVwZW5kZW5jeVRyZWUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRPYnNlcnZlclRyZWUodGhpbmcsIHByb3BlcnR5KSB7XG4gIHJldHVybiBub2RlVG9PYnNlcnZlclRyZWUoZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpKTtcbn1cblxuZnVuY3Rpb24gbm9kZVRvT2JzZXJ2ZXJUcmVlKG5vZGUpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBuYW1lOiBub2RlLm5hbWVfXG4gIH07XG4gIGlmIChoYXNPYnNlcnZlcnMobm9kZSkpIHJlc3VsdC5vYnNlcnZlcnMgPSBBcnJheS5mcm9tKGdldE9ic2VydmVycyhub2RlKSkubWFwKG5vZGVUb09ic2VydmVyVHJlZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZShsaXN0KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQobGlzdCkpO1xufVxuXG52YXIgZ2VuZXJhdG9ySWQgPSAwO1xuZnVuY3Rpb24gRmxvd0NhbmNlbGxhdGlvbkVycm9yKCkge1xuICB0aGlzLm1lc3NhZ2UgPSBcIkZMT1dfQ0FOQ0VMTEVEXCI7XG59XG5GbG93Q2FuY2VsbGF0aW9uRXJyb3IucHJvdG90eXBlID0gLyojX19QVVJFX18qL09iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbmZ1bmN0aW9uIGlzRmxvd0NhbmNlbGxhdGlvbkVycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEZsb3dDYW5jZWxsYXRpb25FcnJvcjtcbn1cbnZhciBmbG93QW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVGbG93QW5ub3RhdGlvbihcImZsb3dcIik7XG52YXIgZmxvd0JvdW5kQW5ub3RhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVGbG93QW5ub3RhdGlvbihcImZsb3cuYm91bmRcIiwge1xuICBib3VuZDogdHJ1ZVxufSk7XG52YXIgZmxvdyA9IC8qI19fUFVSRV9fKi9PYmplY3QuYXNzaWduKGZ1bmN0aW9uIGZsb3coYXJnMSwgYXJnMikge1xuICAvLyBAZmxvd1xuICBpZiAoaXNTdHJpbmdpc2goYXJnMikpIHtcbiAgICByZXR1cm4gc3RvcmVBbm5vdGF0aW9uKGFyZzEsIGFyZzIsIGZsb3dBbm5vdGF0aW9uKTtcbiAgfSAvLyBmbG93KGZuKVxuXG5cbiAgaWYgKCBhcmd1bWVudHMubGVuZ3RoICE9PSAxKSBkaWUoXCJGbG93IGV4cGVjdHMgc2luZ2xlIGFyZ3VtZW50IHdpdGggZ2VuZXJhdG9yIGZ1bmN0aW9uXCIpO1xuICB2YXIgZ2VuZXJhdG9yID0gYXJnMTtcbiAgdmFyIG5hbWUgPSBnZW5lcmF0b3IubmFtZSB8fCBcIjx1bm5hbWVkIGZsb3c+XCI7IC8vIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS90ai9jby9ibG9iL21hc3Rlci9pbmRleC5qc1xuXG4gIHZhciByZXMgPSBmdW5jdGlvbiByZXMoKSB7XG4gICAgdmFyIGN0eCA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHJ1bklkID0gKytnZW5lcmF0b3JJZDtcbiAgICB2YXIgZ2VuID0gYWN0aW9uKG5hbWUgKyBcIiAtIHJ1bmlkOiBcIiArIHJ1bklkICsgXCIgLSBpbml0XCIsIGdlbmVyYXRvcikuYXBwbHkoY3R4LCBhcmdzKTtcbiAgICB2YXIgcmVqZWN0b3I7XG4gICAgdmFyIHBlbmRpbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHN0ZXBJZCA9IDA7XG4gICAgICByZWplY3RvciA9IHJlamVjdDtcblxuICAgICAgZnVuY3Rpb24gb25GdWxmaWxsZWQocmVzKSB7XG4gICAgICAgIHBlbmRpbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0ID0gYWN0aW9uKG5hbWUgKyBcIiAtIHJ1bmlkOiBcIiArIHJ1bklkICsgXCIgLSB5aWVsZCBcIiArIHN0ZXBJZCsrLCBnZW4ubmV4dCkuY2FsbChnZW4sIHJlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChyZXQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblJlamVjdGVkKGVycikge1xuICAgICAgICBwZW5kaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHJldDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldCA9IGFjdGlvbihuYW1lICsgXCIgLSBydW5pZDogXCIgKyBydW5JZCArIFwiIC0geWllbGQgXCIgKyBzdGVwSWQrKywgZ2VuW1widGhyb3dcIl0pLmNhbGwoZ2VuLCBlcnIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQocmV0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbmV4dChyZXQpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocmV0ID09IG51bGwgPyB2b2lkIDAgOiByZXQudGhlbikpIHtcbiAgICAgICAgICAvLyBhbiBhc3luYyBpdGVyYXRvclxuICAgICAgICAgIHJldC50aGVuKG5leHQsIHJlamVjdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldC5kb25lKSByZXR1cm4gcmVzb2x2ZShyZXQudmFsdWUpO1xuICAgICAgICBwZW5kaW5nUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShyZXQudmFsdWUpO1xuICAgICAgICByZXR1cm4gcGVuZGluZ1Byb21pc2UudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIG9uRnVsZmlsbGVkKHVuZGVmaW5lZCk7IC8vIGtpY2sgb2ZmIHRoZSBwcm9jZXNzXG4gICAgfSk7XG4gICAgcHJvbWlzZS5jYW5jZWwgPSBhY3Rpb24obmFtZSArIFwiIC0gcnVuaWQ6IFwiICsgcnVuSWQgKyBcIiAtIGNhbmNlbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocGVuZGluZ1Byb21pc2UpIGNhbmNlbFByb21pc2UocGVuZGluZ1Byb21pc2UpOyAvLyBGaW5hbGx5IGJsb2NrIGNhbiByZXR1cm4gKG9yIHlpZWxkKSBzdHVmZi4uXG5cbiAgICAgICAgdmFyIF9yZXMgPSBnZW5bXCJyZXR1cm5cIl0odW5kZWZpbmVkKTsgLy8gZWF0IGFueXRoaW5nIHRoYXQgcHJvbWlzZSB3b3VsZCBkbywgaXQncyBjYW5jZWxsZWQhXG5cblxuICAgICAgICB2YXIgeWllbGRlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoX3Jlcy52YWx1ZSk7XG4gICAgICAgIHlpZWxkZWRQcm9taXNlLnRoZW4obm9vcCwgbm9vcCk7XG4gICAgICAgIGNhbmNlbFByb21pc2UoeWllbGRlZFByb21pc2UpOyAvLyBtYXliZSBpdCBjYW4gYmUgY2FuY2VsbGVkIDopXG4gICAgICAgIC8vIHJlamVjdCBvdXIgb3JpZ2luYWwgcHJvbWlzZVxuXG4gICAgICAgIHJlamVjdG9yKG5ldyBGbG93Q2FuY2VsbGF0aW9uRXJyb3IoKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdG9yKGUpOyAvLyB0aGVyZSBjb3VsZCBiZSBhIHRocm93aW5nIGZpbmFsbHkgYmxvY2tcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICByZXMuaXNNb2JYRmxvdyA9IHRydWU7XG4gIHJldHVybiByZXM7XG59LCBmbG93QW5ub3RhdGlvbik7XG5mbG93LmJvdW5kID0gLyojX19QVVJFX18qL2NyZWF0ZURlY29yYXRvckFubm90YXRpb24oZmxvd0JvdW5kQW5ub3RhdGlvbik7XG5cbmZ1bmN0aW9uIGNhbmNlbFByb21pc2UocHJvbWlzZSkge1xuICBpZiAoaXNGdW5jdGlvbihwcm9taXNlLmNhbmNlbCkpIHByb21pc2UuY2FuY2VsKCk7XG59XG5cbmZ1bmN0aW9uIGZsb3dSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQ7IC8vIGp1c3QgdHJpY2tpbmcgVHlwZVNjcmlwdCA6KVxufVxuZnVuY3Rpb24gaXNGbG93KGZuKSB7XG4gIHJldHVybiAoZm4gPT0gbnVsbCA/IHZvaWQgMCA6IGZuLmlzTW9iWEZsb3cpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbnRlcmNlcHRSZWFkcyh0aGluZywgcHJvcE9ySGFuZGxlciwgaGFuZGxlcikge1xuICB2YXIgdGFyZ2V0O1xuXG4gIGlmIChpc09ic2VydmFibGVNYXAodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZUFycmF5KHRoaW5nKSB8fCBpc09ic2VydmFibGVWYWx1ZSh0aGluZykpIHtcbiAgICB0YXJnZXQgPSBnZXRBZG1pbmlzdHJhdGlvbih0aGluZyk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSkge1xuICAgIGlmICggIWlzU3RyaW5naXNoKHByb3BPckhhbmRsZXIpKSByZXR1cm4gZGllKFwiSW50ZXJjZXB0UmVhZHMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGEgc3BlY2lmaWMgcHJvcGVydHksIG5vdCB3aXRoIGFuIG9iamVjdCBpbiBnZW5lcmFsXCIpO1xuICAgIHRhcmdldCA9IGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wT3JIYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGllKFwiRXhwZWN0ZWQgb2JzZXJ2YWJsZSBtYXAsIG9iamVjdCBvciBhcnJheSBhcyBmaXJzdCBhcnJheVwiKTtcbiAgfVxuXG4gIGlmICggdGFyZ2V0LmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHJldHVybiBkaWUoXCJBbiBpbnRlcmNlcHQgcmVhZGVyIHdhcyBhbHJlYWR5IGVzdGFibGlzaGVkXCIpO1xuICB0YXJnZXQuZGVoYW5jZXIgPSB0eXBlb2YgcHJvcE9ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiID8gcHJvcE9ySGFuZGxlciA6IGhhbmRsZXI7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGFyZ2V0LmRlaGFuY2VyID0gdW5kZWZpbmVkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRlcmNlcHQodGhpbmcsIHByb3BPckhhbmRsZXIsIGhhbmRsZXIpIHtcbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHJldHVybiBpbnRlcmNlcHRQcm9wZXJ0eSh0aGluZywgcHJvcE9ySGFuZGxlciwgaGFuZGxlcik7ZWxzZSByZXR1cm4gaW50ZXJjZXB0SW50ZXJjZXB0YWJsZSh0aGluZywgcHJvcE9ySGFuZGxlcik7XG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdEludGVyY2VwdGFibGUodGhpbmcsIGhhbmRsZXIpIHtcbiAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nKS5pbnRlcmNlcHRfKGhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBpbnRlcmNlcHRQcm9wZXJ0eSh0aGluZywgcHJvcGVydHksIGhhbmRsZXIpIHtcbiAgcmV0dXJuIGdldEFkbWluaXN0cmF0aW9uKHRoaW5nLCBwcm9wZXJ0eSkuaW50ZXJjZXB0XyhoYW5kbGVyKTtcbn1cblxuZnVuY3Rpb24gX2lzQ29tcHV0ZWQodmFsdWUsIHByb3BlcnR5KSB7XG4gIGlmIChwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh2YWx1ZSkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF2YWx1ZVskbW9ieF0udmFsdWVzXy5oYXMocHJvcGVydHkpKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGF0b20gPSBnZXRBdG9tKHZhbHVlLCBwcm9wZXJ0eSk7XG4gICAgcmV0dXJuIGlzQ29tcHV0ZWRWYWx1ZShhdG9tKTtcbiAgfVxuXG4gIHJldHVybiBpc0NvbXB1dGVkVmFsdWUodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNDb21wdXRlZCh2YWx1ZSkge1xuICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxKSByZXR1cm4gZGllKFwiaXNDb21wdXRlZCBleHBlY3RzIG9ubHkgMSBhcmd1bWVudC4gVXNlIGlzQ29tcHV0ZWRQcm9wIHRvIGluc3BlY3QgdGhlIG9ic2VydmFiaWxpdHkgb2YgYSBwcm9wZXJ0eVwiKTtcbiAgcmV0dXJuIF9pc0NvbXB1dGVkKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzQ29tcHV0ZWRQcm9wKHZhbHVlLCBwcm9wTmFtZSkge1xuICBpZiAoICFpc1N0cmluZ2lzaChwcm9wTmFtZSkpIHJldHVybiBkaWUoXCJpc0NvbXB1dGVkIGV4cGVjdGVkIGEgcHJvcGVydHkgbmFtZSBhcyBzZWNvbmQgYXJndW1lbnRcIik7XG4gIHJldHVybiBfaXNDb21wdXRlZCh2YWx1ZSwgcHJvcE5hbWUpO1xufVxuXG5mdW5jdGlvbiBfaXNPYnNlcnZhYmxlKHZhbHVlLCBwcm9wZXJ0eSkge1xuICBpZiAoIXZhbHVlKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIChpc09ic2VydmFibGVNYXAodmFsdWUpIHx8IGlzT2JzZXJ2YWJsZUFycmF5KHZhbHVlKSkpIHJldHVybiBkaWUoXCJpc09ic2VydmFibGUob2JqZWN0LCBwcm9wZXJ0eU5hbWUpIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGFycmF5cyBhbmQgbWFwcy4gVXNlIG1hcC5oYXMgb3IgYXJyYXkubGVuZ3RoIGluc3RlYWQuXCIpO1xuXG4gICAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZVskbW9ieF0udmFsdWVzXy5oYXMocHJvcGVydHkpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBGb3IgZmlyc3QgY2hlY2ssIHNlZSAjNzAxXG5cblxuICByZXR1cm4gaXNPYnNlcnZhYmxlT2JqZWN0KHZhbHVlKSB8fCAhIXZhbHVlWyRtb2J4XSB8fCBpc0F0b20odmFsdWUpIHx8IGlzUmVhY3Rpb24odmFsdWUpIHx8IGlzQ29tcHV0ZWRWYWx1ZSh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZSh2YWx1ZSkge1xuICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIGRpZShcImlzT2JzZXJ2YWJsZSBleHBlY3RzIG9ubHkgMSBhcmd1bWVudC4gVXNlIGlzT2JzZXJ2YWJsZVByb3AgdG8gaW5zcGVjdCB0aGUgb2JzZXJ2YWJpbGl0eSBvZiBhIHByb3BlcnR5XCIpO1xuICByZXR1cm4gX2lzT2JzZXJ2YWJsZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc09ic2VydmFibGVQcm9wKHZhbHVlLCBwcm9wTmFtZSkge1xuICBpZiAoICFpc1N0cmluZ2lzaChwcm9wTmFtZSkpIHJldHVybiBkaWUoXCJleHBlY3RlZCBhIHByb3BlcnR5IG5hbWUgYXMgc2Vjb25kIGFyZ3VtZW50XCIpO1xuICByZXR1cm4gX2lzT2JzZXJ2YWJsZSh2YWx1ZSwgcHJvcE5hbWUpO1xufVxuXG5mdW5jdGlvbiBrZXlzKG9iaikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4gb2JqWyRtb2J4XS5rZXlzXygpO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopIHx8IGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ob2JqLmtleXMoKSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmoubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0pO1xuICB9XG5cbiAgZGllKDUpO1xufVxuZnVuY3Rpb24gdmFsdWVzKG9iaikge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlTWFwKG9iaikpIHtcbiAgICByZXR1cm4ga2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gb2JqLmdldChrZXkpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ob2JqLnZhbHVlcygpKTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9XG5cbiAgZGllKDYpO1xufVxuZnVuY3Rpb24gZW50cmllcyhvYmopIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIG9ialtrZXldXTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmouZ2V0KGtleSldO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ob2JqLmVudHJpZXMoKSk7XG4gIH1cblxuICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmoubWFwKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgICByZXR1cm4gW2luZGV4LCBrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgZGllKDcpO1xufVxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAhaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICBzdGFydEJhdGNoKCk7XG4gICAgdmFyIF92YWx1ZXMgPSBrZXk7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2tleSBpbiBfdmFsdWVzKSB7XG4gICAgICAgIHNldChvYmosIF9rZXksIF92YWx1ZXNbX2tleV0pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIG9ialskbW9ieF0uc2V0XyhrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIG9iai5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlU2V0KG9iaikpIHtcbiAgICBvYmouYWRkKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcIm51bWJlclwiKSBrZXkgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICBpZiAoa2V5IDwgMCkgZGllKFwiSW52YWxpZCBpbmRleDogJ1wiICsga2V5ICsgXCInXCIpO1xuICAgIHN0YXJ0QmF0Y2goKTtcbiAgICBpZiAoa2V5ID49IG9iai5sZW5ndGgpIG9iai5sZW5ndGggPSBrZXkgKyAxO1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgZW5kQmF0Y2goKTtcbiAgfSBlbHNlIGRpZSg4KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZShvYmosIGtleSkge1xuICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KG9iaikpIHtcbiAgICBvYmpbJG1vYnhdLmRlbGV0ZV8oa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVNYXAob2JqKSkge1xuICAgIG9ialtcImRlbGV0ZVwiXShrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZVNldChvYmopKSB7XG4gICAgb2JqW1wiZGVsZXRlXCJdKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcIm51bWJlclwiKSBrZXkgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICBvYmouc3BsaWNlKGtleSwgMSk7XG4gIH0gZWxzZSB7XG4gICAgZGllKDkpO1xuICB9XG59XG5mdW5jdGlvbiBoYXMob2JqLCBrZXkpIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0uaGFzXyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgcmV0dXJuIG9iai5oYXMoa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVTZXQob2JqKSkge1xuICAgIHJldHVybiBvYmouaGFzKGtleSk7XG4gIH0gZWxzZSBpZiAoaXNPYnNlcnZhYmxlQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBrZXkgPj0gMCAmJiBrZXkgPCBvYmoubGVuZ3RoO1xuICB9XG5cbiAgZGllKDEwKTtcbn1cbmZ1bmN0aW9uIGdldChvYmosIGtleSkge1xuICBpZiAoIWhhcyhvYmosIGtleSkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZU9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9ialskbW9ieF0uZ2V0XyhrZXkpO1xuICB9IGVsc2UgaWYgKGlzT2JzZXJ2YWJsZU1hcChvYmopKSB7XG4gICAgcmV0dXJuIG9iai5nZXQoa2V5KTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG5cbiAgZGllKDExKTtcbn1cbmZ1bmN0aW9uIGFwaURlZmluZVByb3BlcnR5KG9iaiwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmpbJG1vYnhdLmRlZmluZVByb3BlcnR5XyhrZXksIGRlc2NyaXB0b3IpO1xuICB9XG5cbiAgZGllKDM5KTtcbn1cbmZ1bmN0aW9uIGFwaU93bktleXMob2JqKSB7XG4gIGlmIChpc09ic2VydmFibGVPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBvYmpbJG1vYnhdLm93bktleXNfKCk7XG4gIH1cblxuICBkaWUoMzgpO1xufVxuXG5mdW5jdGlvbiBvYnNlcnZlKHRoaW5nLCBwcm9wT3JDYiwgY2JPckZpcmUsIGZpcmVJbW1lZGlhdGVseSkge1xuICBpZiAoaXNGdW5jdGlvbihjYk9yRmlyZSkpIHJldHVybiBvYnNlcnZlT2JzZXJ2YWJsZVByb3BlcnR5KHRoaW5nLCBwcm9wT3JDYiwgY2JPckZpcmUsIGZpcmVJbW1lZGlhdGVseSk7ZWxzZSByZXR1cm4gb2JzZXJ2ZU9ic2VydmFibGUodGhpbmcsIHByb3BPckNiLCBjYk9yRmlyZSk7XG59XG5cbmZ1bmN0aW9uIG9ic2VydmVPYnNlcnZhYmxlKHRoaW5nLCBsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZykub2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSk7XG59XG5cbmZ1bmN0aW9uIG9ic2VydmVPYnNlcnZhYmxlUHJvcGVydHkodGhpbmcsIHByb3BlcnR5LCBsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gIHJldHVybiBnZXRBZG1pbmlzdHJhdGlvbih0aGluZywgcHJvcGVydHkpLm9ic2VydmVfKGxpc3RlbmVyLCBmaXJlSW1tZWRpYXRlbHkpO1xufVxuXG5mdW5jdGlvbiBjYWNoZShtYXAsIGtleSwgdmFsdWUpIHtcbiAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0b0pTSGVscGVyKHNvdXJjZSwgX19hbHJlYWR5U2Vlbikge1xuICBpZiAoc291cmNlID09IG51bGwgfHwgdHlwZW9mIHNvdXJjZSAhPT0gXCJvYmplY3RcIiB8fCBzb3VyY2UgaW5zdGFuY2VvZiBEYXRlIHx8ICFpc09ic2VydmFibGUoc291cmNlKSkgcmV0dXJuIHNvdXJjZTtcbiAgaWYgKGlzT2JzZXJ2YWJsZVZhbHVlKHNvdXJjZSkgfHwgaXNDb21wdXRlZFZhbHVlKHNvdXJjZSkpIHJldHVybiB0b0pTSGVscGVyKHNvdXJjZS5nZXQoKSwgX19hbHJlYWR5U2Vlbik7XG5cbiAgaWYgKF9fYWxyZWFkeVNlZW4uaGFzKHNvdXJjZSkpIHtcbiAgICByZXR1cm4gX19hbHJlYWR5U2Vlbi5nZXQoc291cmNlKTtcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVBcnJheShzb3VyY2UpKSB7XG4gICAgdmFyIHJlcyA9IGNhY2hlKF9fYWxyZWFkeVNlZW4sIHNvdXJjZSwgbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpKTtcbiAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgcmVzW2lkeF0gPSB0b0pTSGVscGVyKHZhbHVlLCBfX2FscmVhZHlTZWVuKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgaWYgKGlzT2JzZXJ2YWJsZVNldChzb3VyY2UpKSB7XG4gICAgdmFyIF9yZXMgPSBjYWNoZShfX2FscmVhZHlTZWVuLCBzb3VyY2UsIG5ldyBTZXQoKSk7XG5cbiAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIF9yZXMuYWRkKHRvSlNIZWxwZXIodmFsdWUsIF9fYWxyZWFkeVNlZW4pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3JlcztcbiAgfVxuXG4gIGlmIChpc09ic2VydmFibGVNYXAoc291cmNlKSkge1xuICAgIHZhciBfcmVzMiA9IGNhY2hlKF9fYWxyZWFkeVNlZW4sIHNvdXJjZSwgbmV3IE1hcCgpKTtcblxuICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBfcmVzMi5zZXQoa2V5LCB0b0pTSGVscGVyKHZhbHVlLCBfX2FscmVhZHlTZWVuKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9yZXMyO1xuICB9IGVsc2Uge1xuICAgIC8vIG11c3QgYmUgb2JzZXJ2YWJsZSBvYmplY3RcbiAgICB2YXIgX3JlczMgPSBjYWNoZShfX2FscmVhZHlTZWVuLCBzb3VyY2UsIHt9KTtcblxuICAgIGFwaU93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChvYmplY3RQcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgX3JlczNba2V5XSA9IHRvSlNIZWxwZXIoc291cmNlW2tleV0sIF9fYWxyZWFkeVNlZW4pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfcmVzMztcbiAgfVxufVxuLyoqXHJcbiAqIEJhc2ljYWxseSwgYSBkZWVwIGNsb25lLCBzbyB0aGF0IG5vIHJlYWN0aXZlIHByb3BlcnR5IHdpbGwgZXhpc3QgYW55bW9yZS5cclxuICovXG5cblxuZnVuY3Rpb24gdG9KUyhzb3VyY2UsIG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zKSBkaWUoXCJ0b0pTIG5vIGxvbmdlciBzdXBwb3J0cyBvcHRpb25zXCIpO1xuICByZXR1cm4gdG9KU0hlbHBlcihzb3VyY2UsIG5ldyBNYXAoKSk7XG59XG5cbmZ1bmN0aW9uIHRyYWNlKCkge1xuICB2YXIgZW50ZXJCcmVha1BvaW50ID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSBcImJvb2xlYW5cIikgZW50ZXJCcmVha1BvaW50ID0gYXJncy5wb3AoKTtcbiAgdmFyIGRlcml2YXRpb24gPSBnZXRBdG9tRnJvbUFyZ3MoYXJncyk7XG5cbiAgaWYgKCFkZXJpdmF0aW9uKSB7XG4gICAgcmV0dXJuIGRpZShcIid0cmFjZShicmVhaz8pJyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhIHRyYWNrZWQgY29tcHV0ZWQgdmFsdWUgb3IgYSBSZWFjdGlvbi4gQ29uc2lkZXIgcGFzc2luZyBpbiB0aGUgY29tcHV0ZWQgdmFsdWUgb3IgcmVhY3Rpb24gZXhwbGljaXRseVwiKTtcbiAgfVxuXG4gIGlmIChkZXJpdmF0aW9uLmlzVHJhY2luZ18gPT09IFRyYWNlTW9kZS5OT05FKSB7XG4gICAgY29uc29sZS5sb2coXCJbbW9ieC50cmFjZV0gJ1wiICsgZGVyaXZhdGlvbi5uYW1lXyArIFwiJyB0cmFjaW5nIGVuYWJsZWRcIik7XG4gIH1cblxuICBkZXJpdmF0aW9uLmlzVHJhY2luZ18gPSBlbnRlckJyZWFrUG9pbnQgPyBUcmFjZU1vZGUuQlJFQUsgOiBUcmFjZU1vZGUuTE9HO1xufVxuXG5mdW5jdGlvbiBnZXRBdG9tRnJvbUFyZ3MoYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbjtcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBnZXRBdG9tKGFyZ3NbMF0pO1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGdldEF0b20oYXJnc1swXSwgYXJnc1sxXSk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIER1cmluZyBhIHRyYW5zYWN0aW9uIG5vIHZpZXdzIGFyZSB1cGRhdGVkIHVudGlsIHRoZSBlbmQgb2YgdGhlIHRyYW5zYWN0aW9uLlxyXG4gKiBUaGUgdHJhbnNhY3Rpb24gd2lsbCBiZSBydW4gc3luY2hyb25vdXNseSBub25ldGhlbGVzcy5cclxuICpcclxuICogQHBhcmFtIGFjdGlvbiBhIGZ1bmN0aW9uIHRoYXQgdXBkYXRlcyBzb21lIHJlYWN0aXZlIHN0YXRlXHJcbiAqIEByZXR1cm5zIGFueSB2YWx1ZSB0aGF0IHdhcyByZXR1cm5lZCBieSB0aGUgJ2FjdGlvbicgcGFyYW1ldGVyLlxyXG4gKi9cblxuZnVuY3Rpb24gdHJhbnNhY3Rpb24oYWN0aW9uLCB0aGlzQXJnKSB7XG4gIGlmICh0aGlzQXJnID09PSB2b2lkIDApIHtcbiAgICB0aGlzQXJnID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgc3RhcnRCYXRjaCgpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGFjdGlvbi5hcHBseSh0aGlzQXJnKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBlbmRCYXRjaCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdoZW4ocHJlZGljYXRlLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxIHx8IGFyZzEgJiYgdHlwZW9mIGFyZzEgPT09IFwib2JqZWN0XCIpIHJldHVybiB3aGVuUHJvbWlzZShwcmVkaWNhdGUsIGFyZzEpO1xuICByZXR1cm4gX3doZW4ocHJlZGljYXRlLCBhcmcxLCBhcmcyIHx8IHt9KTtcbn1cblxuZnVuY3Rpb24gX3doZW4ocHJlZGljYXRlLCBlZmZlY3QsIG9wdHMpIHtcbiAgdmFyIHRpbWVvdXRIYW5kbGU7XG5cbiAgaWYgKHR5cGVvZiBvcHRzLnRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJXSEVOX1RJTUVPVVRcIik7XG4gICAgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFkaXNwb3NlclskbW9ieF0uaXNEaXNwb3NlZF8pIHtcbiAgICAgICAgZGlzcG9zZXIoKTtcbiAgICAgICAgaWYgKG9wdHMub25FcnJvcikgb3B0cy5vbkVycm9yKGVycm9yKTtlbHNlIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0sIG9wdHMudGltZW91dCk7XG4gIH1cblxuICBvcHRzLm5hbWUgPSAgb3B0cy5uYW1lIHx8IFwiV2hlbkBcIiArIGdldE5leHRJZCgpIDtcbiAgdmFyIGVmZmVjdEFjdGlvbiA9IGNyZWF0ZUFjdGlvbiggb3B0cy5uYW1lICsgXCItZWZmZWN0XCIgLCBlZmZlY3QpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxuICB2YXIgZGlzcG9zZXIgPSBhdXRvcnVuKGZ1bmN0aW9uIChyKSB7XG4gICAgLy8gcHJlZGljYXRlIHNob3VsZCBub3QgY2hhbmdlIHN0YXRlXG4gICAgdmFyIGNvbmQgPSBhbGxvd1N0YXRlQ2hhbmdlcyhmYWxzZSwgcHJlZGljYXRlKTtcblxuICAgIGlmIChjb25kKSB7XG4gICAgICByLmRpc3Bvc2UoKTtcbiAgICAgIGlmICh0aW1lb3V0SGFuZGxlKSBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICBlZmZlY3RBY3Rpb24oKTtcbiAgICB9XG4gIH0sIG9wdHMpO1xuICByZXR1cm4gZGlzcG9zZXI7XG59XG5cbmZ1bmN0aW9uIHdoZW5Qcm9taXNlKHByZWRpY2F0ZSwgb3B0cykge1xuICBpZiAoIG9wdHMgJiYgb3B0cy5vbkVycm9yKSByZXR1cm4gZGllKFwidGhlIG9wdGlvbnMgJ29uRXJyb3InIGFuZCAncHJvbWlzZScgY2Fubm90IGJlIGNvbWJpbmVkXCIpO1xuICB2YXIgY2FuY2VsO1xuICB2YXIgcmVzID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBkaXNwb3NlciA9IF93aGVuKHByZWRpY2F0ZSwgcmVzb2x2ZSwgX2V4dGVuZHMoe30sIG9wdHMsIHtcbiAgICAgIG9uRXJyb3I6IHJlamVjdFxuICAgIH0pKTtcblxuICAgIGNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGRpc3Bvc2VyKCk7XG4gICAgICByZWplY3QoXCJXSEVOX0NBTkNFTExFRFwiKTtcbiAgICB9O1xuICB9KTtcbiAgcmVzLmNhbmNlbCA9IGNhbmNlbDtcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZ2V0QWRtKHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0WyRtb2J4XTtcbn0gLy8gT3B0aW1pemF0aW9uOiB3ZSBkb24ndCBuZWVkIHRoZSBpbnRlcm1lZGlhdGUgb2JqZWN0cyBhbmQgY291bGQgaGF2ZSBhIGNvbXBsZXRlbHkgY3VzdG9tIGFkbWluaXN0cmF0aW9uIGZvciBEeW5hbWljT2JqZWN0cyxcbi8vIGFuZCBza2lwIGVpdGhlciB0aGUgaW50ZXJuYWwgdmFsdWVzIG1hcCwgb3IgdGhlIGJhc2Ugb2JqZWN0IHdpdGggaXRzIHByb3BlcnR5IGRlc2NyaXB0b3JzIVxuXG5cbnZhciBvYmplY3RQcm94eVRyYXBzID0ge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIG5hbWUpIHtcbiAgICBpZiAoIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcImRldGVjdCBuZXcgcHJvcGVydGllcyB1c2luZyB0aGUgJ2luJyBvcGVyYXRvci4gVXNlICdoYXMnIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIHJldHVybiBnZXRBZG0odGFyZ2V0KS5oYXNfKG5hbWUpO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uIGdldCh0YXJnZXQsIG5hbWUpIHtcbiAgICByZXR1cm4gZ2V0QWRtKHRhcmdldCkuZ2V0XyhuYW1lKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBfZ2V0QWRtJHNldF87XG5cbiAgICBpZiAoIWlzU3RyaW5naXNoKG5hbWUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoICFnZXRBZG0odGFyZ2V0KS52YWx1ZXNfLmhhcyhuYW1lKSkge1xuICAgICAgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcImFkZCBhIG5ldyBvYnNlcnZhYmxlIHByb3BlcnR5IHRocm91Z2ggZGlyZWN0IGFzc2lnbm1lbnQuIFVzZSAnc2V0JyBmcm9tICdtb2J4JyBpbnN0ZWFkLlwiKTtcbiAgICB9IC8vIG51bGwgKGludGVyY2VwdGVkKSAtPiB0cnVlIChzdWNjZXNzKVxuXG5cbiAgICByZXR1cm4gKF9nZXRBZG0kc2V0XyA9IGdldEFkbSh0YXJnZXQpLnNldF8obmFtZSwgdmFsdWUsIHRydWUpKSAhPSBudWxsID8gX2dldEFkbSRzZXRfIDogdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgbmFtZSkge1xuICAgIHZhciBfZ2V0QWRtJGRlbGV0ZV87XG5cbiAgICB7XG4gICAgICB3YXJuQWJvdXRQcm94eVJlcXVpcmVtZW50KFwiZGVsZXRlIHByb3BlcnRpZXMgZnJvbSBhbiBvYnNlcnZhYmxlIG9iamVjdC4gVXNlICdyZW1vdmUnIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIH1cblxuICAgIGlmICghaXNTdHJpbmdpc2gobmFtZSkpIHJldHVybiBmYWxzZTsgLy8gbnVsbCAoaW50ZXJjZXB0ZWQpIC0+IHRydWUgKHN1Y2Nlc3MpXG5cbiAgICByZXR1cm4gKF9nZXRBZG0kZGVsZXRlXyA9IGdldEFkbSh0YXJnZXQpLmRlbGV0ZV8obmFtZSwgdHJ1ZSkpICE9IG51bGwgPyBfZ2V0QWRtJGRlbGV0ZV8gOiB0cnVlO1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gICAgdmFyIF9nZXRBZG0kZGVmaW5lUHJvcGVydDtcblxuICAgIHtcbiAgICAgIHdhcm5BYm91dFByb3h5UmVxdWlyZW1lbnQoXCJkZWZpbmUgcHJvcGVydHkgb24gYW4gb2JzZXJ2YWJsZSBvYmplY3QuIFVzZSAnZGVmaW5lUHJvcGVydHknIGZyb20gJ21vYngnIGluc3RlYWQuXCIpO1xuICAgIH0gLy8gbnVsbCAoaW50ZXJjZXB0ZWQpIC0+IHRydWUgKHN1Y2Nlc3MpXG5cblxuICAgIHJldHVybiAoX2dldEFkbSRkZWZpbmVQcm9wZXJ0ID0gZ2V0QWRtKHRhcmdldCkuZGVmaW5lUHJvcGVydHlfKG5hbWUsIGRlc2NyaXB0b3IpKSAhPSBudWxsID8gX2dldEFkbSRkZWZpbmVQcm9wZXJ0IDogdHJ1ZTtcbiAgfSxcbiAgb3duS2V5czogZnVuY3Rpb24gb3duS2V5cyh0YXJnZXQpIHtcbiAgICBpZiAoIGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikgd2FybkFib3V0UHJveHlSZXF1aXJlbWVudChcIml0ZXJhdGUga2V5cyB0byBkZXRlY3QgYWRkZWQgLyByZW1vdmVkIHByb3BlcnRpZXMuIFVzZSAna2V5cycgZnJvbSAnbW9ieCcgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIGdldEFkbSh0YXJnZXQpLm93bktleXNfKCk7XG4gIH0sXG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpIHtcbiAgICBkaWUoMTMpO1xuICB9XG59O1xuZnVuY3Rpb24gYXNEeW5hbWljT2JzZXJ2YWJsZU9iamVjdCh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgdmFyIF90YXJnZXQkJG1vYngsIF90YXJnZXQkJG1vYngkcHJveHlfO1xuXG4gIGFzc2VydFByb3hpZXMoKTtcbiAgdGFyZ2V0ID0gYXNPYnNlcnZhYmxlT2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XG4gIHJldHVybiAoX3RhcmdldCQkbW9ieCRwcm94eV8gPSAoX3RhcmdldCQkbW9ieCA9IHRhcmdldFskbW9ieF0pLnByb3h5XykgIT0gbnVsbCA/IF90YXJnZXQkJG1vYngkcHJveHlfIDogX3RhcmdldCQkbW9ieC5wcm94eV8gPSBuZXcgUHJveHkodGFyZ2V0LCBvYmplY3RQcm94eVRyYXBzKTtcbn1cblxuZnVuY3Rpb24gaGFzSW50ZXJjZXB0b3JzKGludGVyY2VwdGFibGUpIHtcbiAgcmV0dXJuIGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyAhPT0gdW5kZWZpbmVkICYmIGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXy5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJJbnRlcmNlcHRvcihpbnRlcmNlcHRhYmxlLCBoYW5kbGVyKSB7XG4gIHZhciBpbnRlcmNlcHRvcnMgPSBpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9yc18gfHwgKGludGVyY2VwdGFibGUuaW50ZXJjZXB0b3JzXyA9IFtdKTtcbiAgaW50ZXJjZXB0b3JzLnB1c2goaGFuZGxlcik7XG4gIHJldHVybiBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gaW50ZXJjZXB0b3JzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgaWYgKGlkeCAhPT0gLTEpIGludGVyY2VwdG9ycy5zcGxpY2UoaWR4LCAxKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbnRlcmNlcHRDaGFuZ2UoaW50ZXJjZXB0YWJsZSwgY2hhbmdlKSB7XG4gIHZhciBwcmV2VSA9IHVudHJhY2tlZFN0YXJ0KCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBJbnRlcmNlcHRvciBjYW4gbW9kaWZ5IHRoZSBhcnJheSwgY29weSBpdCB0byBhdm9pZCBjb25jdXJyZW50IG1vZGlmaWNhdGlvbiwgc2VlICMxOTUwXG4gICAgdmFyIGludGVyY2VwdG9ycyA9IFtdLmNvbmNhdChpbnRlcmNlcHRhYmxlLmludGVyY2VwdG9yc18gfHwgW10pO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbnRlcmNlcHRvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaGFuZ2UgPSBpbnRlcmNlcHRvcnNbaV0oY2hhbmdlKTtcbiAgICAgIGlmIChjaGFuZ2UgJiYgIWNoYW5nZS50eXBlKSBkaWUoMTQpO1xuICAgICAgaWYgKCFjaGFuZ2UpIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2U7XG4gIH0gZmluYWxseSB7XG4gICAgdW50cmFja2VkRW5kKHByZXZVKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNMaXN0ZW5lcnMobGlzdGVuYWJsZSkge1xuICByZXR1cm4gbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVyKGxpc3RlbmFibGUsIGhhbmRsZXIpIHtcbiAgdmFyIGxpc3RlbmVycyA9IGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzXyB8fCAobGlzdGVuYWJsZS5jaGFuZ2VMaXN0ZW5lcnNfID0gW10pO1xuICBsaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcbiAgcmV0dXJuIG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSBsaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkgbGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycyhsaXN0ZW5hYmxlLCBjaGFuZ2UpIHtcbiAgdmFyIHByZXZVID0gdW50cmFja2VkU3RhcnQoKTtcbiAgdmFyIGxpc3RlbmVycyA9IGxpc3RlbmFibGUuY2hhbmdlTGlzdGVuZXJzXztcbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybjtcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKCk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldKGNoYW5nZSk7XG4gIH1cblxuICB1bnRyYWNrZWRFbmQocHJldlUpO1xufVxuXG5mdW5jdGlvbiBtYWtlT2JzZXJ2YWJsZSh0YXJnZXQsIGFubm90YXRpb25zLCBvcHRpb25zKSB7XG4gIHZhciBhZG0gPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKVskbW9ieF07XG4gIHN0YXJ0QmF0Y2goKTtcblxuICB0cnkge1xuICAgIHZhciBfYW5ub3RhdGlvbnM7XG5cbiAgICAvLyBEZWZhdWx0IHRvIGRlY29yYXRvcnNcbiAgICAoX2Fubm90YXRpb25zID0gYW5ub3RhdGlvbnMpICE9IG51bGwgPyBfYW5ub3RhdGlvbnMgOiBhbm5vdGF0aW9ucyA9IGNvbGxlY3RTdG9yZWRBbm5vdGF0aW9ucyh0YXJnZXQpOyAvLyBBbm5vdGF0ZVxuXG4gICAgb3duS2V5cyhhbm5vdGF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gYWRtLm1ha2VfKGtleSwgYW5ub3RhdGlvbnNba2V5XSk7XG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgZW5kQmF0Y2goKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IC8vIHByb3RvW2tleXNTeW1ib2xdID0gbmV3IFNldDxQcm9wZXJ0eUtleT4oKVxuXG52YXIga2V5c1N5bWJvbCA9IC8qI19fUFVSRV9fKi9TeW1ib2woXCJtb2J4LWtleXNcIik7XG5mdW5jdGlvbiBtYWtlQXV0b09ic2VydmFibGUodGFyZ2V0LCBvdmVycmlkZXMsIG9wdGlvbnMpIHtcbiAge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmICFpc1BsYWluT2JqZWN0KE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgZGllKFwiJ21ha2VBdXRvT2JzZXJ2YWJsZScgY2FuIG9ubHkgYmUgdXNlZCBmb3IgY2xhc3NlcyB0aGF0IGRvbid0IGhhdmUgYSBzdXBlcmNsYXNzXCIpO1xuICAgIGlmIChpc09ic2VydmFibGVPYmplY3QodGFyZ2V0KSkgZGllKFwibWFrZUF1dG9PYnNlcnZhYmxlIGNhbiBvbmx5IGJlIHVzZWQgb24gb2JqZWN0cyBub3QgYWxyZWFkeSBtYWRlIG9ic2VydmFibGVcIik7XG4gIH0gLy8gT3B0aW1pemF0aW9uOiBhdm9pZCB2aXNpdGluZyBwcm90b3NcbiAgLy8gQXNzdW1lcyB0aGF0IGFubm90YXRpb24ubWFrZV8vLmV4dGVuZF8gd29ya3MgdGhlIHNhbWUgZm9yIHBsYWluIG9iamVjdHNcblxuXG4gIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gZXh0ZW5kT2JzZXJ2YWJsZSh0YXJnZXQsIHRhcmdldCwgb3ZlcnJpZGVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBhZG0gPSBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKVskbW9ieF07IC8vIE9wdGltaXphdGlvbjogY2FjaGUga2V5cyBvbiBwcm90b1xuICAvLyBBc3N1bWVzIG1ha2VBdXRvT2JzZXJ2YWJsZSBjYW4gYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgb2JqZWN0IGFuZCBjYW4ndCBiZSB1c2VkIGluIHN1YmNsYXNzXG5cbiAgaWYgKCF0YXJnZXRba2V5c1N5bWJvbF0pIHtcbiAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgICB2YXIga2V5cyA9IG5ldyBTZXQoW10uY29uY2F0KG93bktleXModGFyZ2V0KSwgb3duS2V5cyhwcm90bykpKTtcbiAgICBrZXlzW1wiZGVsZXRlXCJdKFwiY29uc3RydWN0b3JcIik7XG4gICAga2V5c1tcImRlbGV0ZVwiXSgkbW9ieCk7XG4gICAgYWRkSGlkZGVuUHJvcChwcm90bywga2V5c1N5bWJvbCwga2V5cyk7XG4gIH1cblxuICBzdGFydEJhdGNoKCk7XG5cbiAgdHJ5IHtcbiAgICB0YXJnZXRba2V5c1N5bWJvbF0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gYWRtLm1ha2VfKGtleSwgLy8gbXVzdCBwYXNzIFwidW5kZWZpbmVkXCIgZm9yIHsga2V5OiB1bmRlZmluZWQgfVxuICAgICAgIW92ZXJyaWRlcyA/IHRydWUgOiBrZXkgaW4gb3ZlcnJpZGVzID8gb3ZlcnJpZGVzW2tleV0gOiB0cnVlKTtcbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBlbmRCYXRjaCgpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIFNQTElDRSA9IFwic3BsaWNlXCI7XG52YXIgVVBEQVRFID0gXCJ1cGRhdGVcIjtcbnZhciBNQVhfU1BMSUNFX1NJWkUgPSAxMDAwMDsgLy8gU2VlIGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4L2lzc3Vlcy84NTlcblxudmFyIGFycmF5VHJhcHMgPSB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KHRhcmdldCwgbmFtZSkge1xuICAgIHZhciBhZG0gPSB0YXJnZXRbJG1vYnhdO1xuICAgIGlmIChuYW1lID09PSAkbW9ieCkgcmV0dXJuIGFkbTtcbiAgICBpZiAobmFtZSA9PT0gXCJsZW5ndGhcIikgcmV0dXJuIGFkbS5nZXRBcnJheUxlbmd0aF8oKTtcblxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiAhaXNOYU4obmFtZSkpIHtcbiAgICAgIHJldHVybiBhZG0uZ2V0XyhwYXJzZUludChuYW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1Byb3AoYXJyYXlFeHRlbnNpb25zLCBuYW1lKSkge1xuICAgICAgcmV0dXJuIGFycmF5RXh0ZW5zaW9uc1tuYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0W25hbWVdO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGFkbSA9IHRhcmdldFskbW9ieF07XG5cbiAgICBpZiAobmFtZSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgYWRtLnNldEFycmF5TGVuZ3RoXyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiIHx8IGlzTmFOKG5hbWUpKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbnVtZXJpYyBzdHJpbmdcbiAgICAgIGFkbS5zZXRfKHBhcnNlSW50KG5hbWUpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucygpIHtcbiAgICBkaWUoMTUpO1xuICB9XG59O1xudmFyIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gdGhpcyBpcyB0aGUgcHJvcCB0aGF0IGdldHMgcHJveGllZCwgc28gY2FuJ3QgcmVwbGFjZSBpdCFcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24obmFtZSwgZW5oYW5jZXIsIG93bmVkXywgbGVnYWN5TW9kZV8pIHtcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lID0gIFwiT2JzZXJ2YWJsZUFycmF5QFwiICsgZ2V0TmV4dElkKCkgO1xuICAgIH1cblxuICAgIHRoaXMub3duZWRfID0gdm9pZCAwO1xuICAgIHRoaXMubGVnYWN5TW9kZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5hdG9tXyA9IHZvaWQgMDtcbiAgICB0aGlzLnZhbHVlc18gPSBbXTtcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuZW5oYW5jZXJfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm94eV8gPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0S25vd25MZW5ndGhfID0gMDtcbiAgICB0aGlzLm93bmVkXyA9IG93bmVkXztcbiAgICB0aGlzLmxlZ2FjeU1vZGVfID0gbGVnYWN5TW9kZV87XG4gICAgdGhpcy5hdG9tXyA9IG5ldyBBdG9tKG5hbWUpO1xuXG4gICAgdGhpcy5lbmhhbmNlcl8gPSBmdW5jdGlvbiAobmV3Viwgb2xkVikge1xuICAgICAgcmV0dXJuIGVuaGFuY2VyKG5ld1YsIG9sZFYsICBuYW1lICsgXCJbLi5dXCIgKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVoYW5jZVZhbHVlXyA9IGZ1bmN0aW9uIGRlaGFuY2VWYWx1ZV8odmFsdWUpIHtcbiAgICBpZiAodGhpcy5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5kZWhhbmNlcih2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5kZWhhbmNlVmFsdWVzXyA9IGZ1bmN0aW9uIGRlaGFuY2VWYWx1ZXNfKHZhbHVlcykge1xuICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQgJiYgdmFsdWVzLmxlbmd0aCA+IDApIHJldHVybiB2YWx1ZXMubWFwKHRoaXMuZGVoYW5jZXIpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgX3Byb3RvLmludGVyY2VwdF8gPSBmdW5jdGlvbiBpbnRlcmNlcHRfKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVnaXN0ZXJJbnRlcmNlcHRvcih0aGlzLCBoYW5kbGVyKTtcbiAgfTtcblxuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgaWYgKGZpcmVJbW1lZGlhdGVseSA9PT0gdm9pZCAwKSB7XG4gICAgICBmaXJlSW1tZWRpYXRlbHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgICBsaXN0ZW5lcih7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcImFycmF5XCIsXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8sXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5hdG9tXy5uYW1lXyxcbiAgICAgICAgdHlwZTogXCJzcGxpY2VcIixcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIGFkZGVkOiB0aGlzLnZhbHVlc18uc2xpY2UoKSxcbiAgICAgICAgYWRkZWRDb3VudDogdGhpcy52YWx1ZXNfLmxlbmd0aCxcbiAgICAgICAgcmVtb3ZlZDogW10sXG4gICAgICAgIHJlbW92ZWRDb3VudDogMFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xuICB9O1xuXG4gIF9wcm90by5nZXRBcnJheUxlbmd0aF8gPSBmdW5jdGlvbiBnZXRBcnJheUxlbmd0aF8oKSB7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiB0aGlzLnZhbHVlc18ubGVuZ3RoO1xuICB9O1xuXG4gIF9wcm90by5zZXRBcnJheUxlbmd0aF8gPSBmdW5jdGlvbiBzZXRBcnJheUxlbmd0aF8obmV3TGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdMZW5ndGggIT09IFwibnVtYmVyXCIgfHwgbmV3TGVuZ3RoIDwgMCkgZGllKFwiT3V0IG9mIHJhbmdlOiBcIiArIG5ld0xlbmd0aCk7XG4gICAgdmFyIGN1cnJlbnRMZW5ndGggPSB0aGlzLnZhbHVlc18ubGVuZ3RoO1xuICAgIGlmIChuZXdMZW5ndGggPT09IGN1cnJlbnRMZW5ndGgpIHJldHVybjtlbHNlIGlmIChuZXdMZW5ndGggPiBjdXJyZW50TGVuZ3RoKSB7XG4gICAgICB2YXIgbmV3SXRlbXMgPSBuZXcgQXJyYXkobmV3TGVuZ3RoIC0gY3VycmVudExlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3TGVuZ3RoIC0gY3VycmVudExlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0l0ZW1zW2ldID0gdW5kZWZpbmVkO1xuICAgICAgfSAvLyBObyBBcnJheS5maWxsIGV2ZXJ5d2hlcmUuLi5cblxuXG4gICAgICB0aGlzLnNwbGljZVdpdGhBcnJheV8oY3VycmVudExlbmd0aCwgMCwgbmV3SXRlbXMpO1xuICAgIH0gZWxzZSB0aGlzLnNwbGljZVdpdGhBcnJheV8obmV3TGVuZ3RoLCBjdXJyZW50TGVuZ3RoIC0gbmV3TGVuZ3RoKTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlQXJyYXlMZW5ndGhfID0gZnVuY3Rpb24gdXBkYXRlQXJyYXlMZW5ndGhfKG9sZExlbmd0aCwgZGVsdGEpIHtcbiAgICBpZiAob2xkTGVuZ3RoICE9PSB0aGlzLmxhc3RLbm93bkxlbmd0aF8pIGRpZSgxNik7XG4gICAgdGhpcy5sYXN0S25vd25MZW5ndGhfICs9IGRlbHRhO1xuICAgIGlmICh0aGlzLmxlZ2FjeU1vZGVfICYmIGRlbHRhID4gMCkgcmVzZXJ2ZUFycmF5QnVmZmVyKG9sZExlbmd0aCArIGRlbHRhICsgMSk7XG4gIH07XG5cbiAgX3Byb3RvLnNwbGljZVdpdGhBcnJheV8gPSBmdW5jdGlvbiBzcGxpY2VXaXRoQXJyYXlfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5hdG9tXyk7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMudmFsdWVzXy5sZW5ndGg7XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIGluZGV4ID0gMDtlbHNlIGlmIChpbmRleCA+IGxlbmd0aCkgaW5kZXggPSBsZW5ndGg7ZWxzZSBpZiAoaW5kZXggPCAwKSBpbmRleCA9IE1hdGgubWF4KDAsIGxlbmd0aCArIGluZGV4KTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgZGVsZXRlQ291bnQgPSBsZW5ndGggLSBpbmRleDtlbHNlIGlmIChkZWxldGVDb3VudCA9PT0gdW5kZWZpbmVkIHx8IGRlbGV0ZUNvdW50ID09PSBudWxsKSBkZWxldGVDb3VudCA9IDA7ZWxzZSBkZWxldGVDb3VudCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRlbGV0ZUNvdW50LCBsZW5ndGggLSBpbmRleCkpO1xuICAgIGlmIChuZXdJdGVtcyA9PT0gdW5kZWZpbmVkKSBuZXdJdGVtcyA9IEVNUFRZX0FSUkFZO1xuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8sXG4gICAgICAgIHR5cGU6IFNQTElDRSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICByZW1vdmVkQ291bnQ6IGRlbGV0ZUNvdW50LFxuICAgICAgICBhZGRlZDogbmV3SXRlbXNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBFTVBUWV9BUlJBWTtcbiAgICAgIGRlbGV0ZUNvdW50ID0gY2hhbmdlLnJlbW92ZWRDb3VudDtcbiAgICAgIG5ld0l0ZW1zID0gY2hhbmdlLmFkZGVkO1xuICAgIH1cblxuICAgIG5ld0l0ZW1zID0gbmV3SXRlbXMubGVuZ3RoID09PSAwID8gbmV3SXRlbXMgOiBuZXdJdGVtcy5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBfdGhpcy5lbmhhbmNlcl8odiwgdW5kZWZpbmVkKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmxlZ2FjeU1vZGVfIHx8IFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHZhciBsZW5ndGhEZWx0YSA9IG5ld0l0ZW1zLmxlbmd0aCAtIGRlbGV0ZUNvdW50O1xuICAgICAgdGhpcy51cGRhdGVBcnJheUxlbmd0aF8obGVuZ3RoLCBsZW5ndGhEZWx0YSk7IC8vIGNoZWNrcyBpZiBpbnRlcm5hbCBhcnJheSB3YXNuJ3QgbW9kaWZpZWRcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gdGhpcy5zcGxpY2VJdGVtc0ludG9WYWx1ZXNfKGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpO1xuICAgIGlmIChkZWxldGVDb3VudCAhPT0gMCB8fCBuZXdJdGVtcy5sZW5ndGggIT09IDApIHRoaXMubm90aWZ5QXJyYXlTcGxpY2VfKGluZGV4LCBuZXdJdGVtcywgcmVzKTtcbiAgICByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVzXyhyZXMpO1xuICB9O1xuXG4gIF9wcm90by5zcGxpY2VJdGVtc0ludG9WYWx1ZXNfID0gZnVuY3Rpb24gc3BsaWNlSXRlbXNJbnRvVmFsdWVzXyhpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKSB7XG4gICAgaWYgKG5ld0l0ZW1zLmxlbmd0aCA8IE1BWF9TUExJQ0VfU0laRSkge1xuICAgICAgdmFyIF90aGlzJHZhbHVlc187XG5cbiAgICAgIHJldHVybiAoX3RoaXMkdmFsdWVzXyA9IHRoaXMudmFsdWVzXykuc3BsaWNlLmFwcGx5KF90aGlzJHZhbHVlc18sIFtpbmRleCwgZGVsZXRlQ291bnRdLmNvbmNhdChuZXdJdGVtcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzID0gdGhpcy52YWx1ZXNfLnNsaWNlKGluZGV4LCBpbmRleCArIGRlbGV0ZUNvdW50KTtcbiAgICAgIHZhciBvbGRJdGVtcyA9IHRoaXMudmFsdWVzXy5zbGljZShpbmRleCArIGRlbGV0ZUNvdW50KTtcbiAgICAgIHRoaXMudmFsdWVzXy5sZW5ndGggPSBpbmRleCArIG5ld0l0ZW1zLmxlbmd0aCAtIGRlbGV0ZUNvdW50O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0l0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudmFsdWVzX1tpbmRleCArIGldID0gbmV3SXRlbXNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvbGRJdGVtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdGhpcy52YWx1ZXNfW2luZGV4ICsgbmV3SXRlbXMubGVuZ3RoICsgX2ldID0gb2xkSXRlbXNbX2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubm90aWZ5QXJyYXlDaGlsZFVwZGF0ZV8gPSBmdW5jdGlvbiBub3RpZnlBcnJheUNoaWxkVXBkYXRlXyhpbmRleCwgbmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgdmFyIG5vdGlmeVNweSA9ICF0aGlzLm93bmVkXyAmJiBpc1NweUVuYWJsZWQoKTtcbiAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwiYXJyYXlcIixcbiAgICAgIG9iamVjdDogdGhpcy5wcm94eV8sXG4gICAgICB0eXBlOiBVUERBVEUsXG4gICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMuYXRvbV8ubmFtZV8sXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICBvbGRWYWx1ZTogb2xkVmFsdWVcbiAgICB9IDogbnVsbDsgLy8gVGhlIHJlYXNvbiB3aHkgdGhpcyBpcyBvbiByaWdodCBoYW5kIHNpZGUgaGVyZSAoYW5kIG5vdCBhYm92ZSksIGlzIHRoaXMgd2F5IHRoZSB1Z2xpZmllciB3aWxsIGRyb3AgaXQsIGJ1dCBpdCB3b24ndFxuICAgIC8vIGNhdXNlIGFueSBydW50aW1lIG92ZXJoZWFkIGluIGRldmVsb3BtZW50IG1vZGUgd2l0aG91dCBOT0RFX0VOViBzZXQsIHVubGVzcyBzcHlpbmcgaXMgZW5hYmxlZFxuXG4gICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KGNoYW5nZSk7XG4gICAgdGhpcy5hdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIGNoYW5nZSk7XG4gICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICB9O1xuXG4gIF9wcm90by5ub3RpZnlBcnJheVNwbGljZV8gPSBmdW5jdGlvbiBub3RpZnlBcnJheVNwbGljZV8oaW5kZXgsIGFkZGVkLCByZW1vdmVkKSB7XG4gICAgdmFyIG5vdGlmeVNweSA9ICF0aGlzLm93bmVkXyAmJiBpc1NweUVuYWJsZWQoKTtcbiAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwiYXJyYXlcIixcbiAgICAgIG9iamVjdDogdGhpcy5wcm94eV8sXG4gICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMuYXRvbV8ubmFtZV8sXG4gICAgICB0eXBlOiBTUExJQ0UsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgcmVtb3ZlZENvdW50OiByZW1vdmVkLmxlbmd0aCxcbiAgICAgIGFkZGVkQ291bnQ6IGFkZGVkLmxlbmd0aFxuICAgIH0gOiBudWxsO1xuICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgIHRoaXMuYXRvbV8ucmVwb3J0Q2hhbmdlZCgpOyAvLyBjb25mb3JtOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9vYnNlcnZlXG5cbiAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgY2hhbmdlKTtcbiAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0RW5kKCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldF8gPSBmdW5jdGlvbiBnZXRfKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgdGhpcy52YWx1ZXNfLmxlbmd0aCkge1xuICAgICAgdGhpcy5hdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVoYW5jZVZhbHVlXyh0aGlzLnZhbHVlc19baW5kZXhdKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLndhcm4oIFwiW21vYnhdIE91dCBvZiBib3VuZHMgcmVhZDogXCIgKyBpbmRleCApO1xuICB9O1xuXG4gIF9wcm90by5zZXRfID0gZnVuY3Rpb24gc2V0XyhpbmRleCwgbmV3VmFsdWUpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXNfO1xuXG4gICAgaWYgKGluZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgLy8gdXBkYXRlIGF0IGluZGV4IGluIHJhbmdlXG4gICAgICBjaGVja0lmU3RhdGVNb2RpZmljYXRpb25zQXJlQWxsb3dlZCh0aGlzLmF0b21fKTtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHZhbHVlc1tpbmRleF07XG5cbiAgICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8sXG4gICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybjtcbiAgICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIG5ld1ZhbHVlID0gdGhpcy5lbmhhbmNlcl8obmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIHZhciBjaGFuZ2VkID0gbmV3VmFsdWUgIT09IG9sZFZhbHVlO1xuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMubm90aWZ5QXJyYXlDaGlsZFVwZGF0ZV8oaW5kZXgsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgLy8gYWRkIGEgbmV3IGl0ZW1cbiAgICAgIHRoaXMuc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgMCwgW25ld1ZhbHVlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG91dCBvZiBib3VuZHNcbiAgICAgIGRpZSgxNywgaW5kZXgsIHZhbHVlcy5sZW5ndGgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb247XG59KCk7XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlQXJyYXkoaW5pdGlhbFZhbHVlcywgZW5oYW5jZXIsIG5hbWUsIG93bmVkKSB7XG4gIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICBuYW1lID0gIFwiT2JzZXJ2YWJsZUFycmF5QFwiICsgZ2V0TmV4dElkKCkgO1xuICB9XG5cbiAgaWYgKG93bmVkID09PSB2b2lkIDApIHtcbiAgICBvd25lZCA9IGZhbHNlO1xuICB9XG5cbiAgYXNzZXJ0UHJveGllcygpO1xuICB2YXIgYWRtID0gbmV3IE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKG5hbWUsIGVuaGFuY2VyLCBvd25lZCwgZmFsc2UpO1xuICBhZGRIaWRkZW5GaW5hbFByb3AoYWRtLnZhbHVlc18sICRtb2J4LCBhZG0pO1xuICB2YXIgcHJveHkgPSBuZXcgUHJveHkoYWRtLnZhbHVlc18sIGFycmF5VHJhcHMpO1xuICBhZG0ucHJveHlfID0gcHJveHk7XG5cbiAgaWYgKGluaXRpYWxWYWx1ZXMgJiYgaW5pdGlhbFZhbHVlcy5sZW5ndGgpIHtcbiAgICB2YXIgcHJldiA9IGFsbG93U3RhdGVDaGFuZ2VzU3RhcnQodHJ1ZSk7XG4gICAgYWRtLnNwbGljZVdpdGhBcnJheV8oMCwgMCwgaW5pdGlhbFZhbHVlcyk7XG4gICAgYWxsb3dTdGF0ZUNoYW5nZXNFbmQocHJldik7XG4gIH1cblxuICByZXR1cm4gcHJveHk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG52YXIgYXJyYXlFeHRlbnNpb25zID0ge1xuICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKDApO1xuICB9LFxuICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKG5ld0l0ZW1zKSB7XG4gICAgdmFyIGFkbSA9IHRoaXNbJG1vYnhdO1xuICAgIHJldHVybiBhZG0uc3BsaWNlV2l0aEFycmF5XygwLCBhZG0udmFsdWVzXy5sZW5ndGgsIG5ld0l0ZW1zKTtcbiAgfSxcbiAgLy8gVXNlZCBieSBKU09OLnN0cmluZ2lmeVxuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgpO1xuICB9LFxuXG4gIC8qXHJcbiAgICogZnVuY3Rpb25zIHRoYXQgZG8gYWx0ZXIgdGhlIGludGVybmFsIHN0cnVjdHVyZSBvZiB0aGUgYXJyYXksIChiYXNlZCBvbiBsaWIuZXM2LmQudHMpXHJcbiAgICogc2luY2UgdGhlc2UgZnVuY3Rpb25zIGFsdGVyIHRoZSBpbm5lciBzdHJ1Y3R1cmUgb2YgdGhlIGFycmF5LCB0aGUgaGF2ZSBzaWRlIGVmZmVjdHMuXHJcbiAgICogQmVjYXVzZSB0aGUgaGF2ZSBzaWRlIGVmZmVjdHMsIHRoZXkgc2hvdWxkIG5vdCBiZSB1c2VkIGluIGNvbXB1dGVkIGZ1bmN0aW9uLFxyXG4gICAqIGFuZCBmb3IgdGhhdCByZWFzb24gdGhlIGRvIG5vdCBjYWxsIGRlcGVuZGVuY3lTdGF0ZS5ub3RpZnlPYnNlcnZlZFxyXG4gICAqL1xuICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShpbmRleCwgZGVsZXRlQ291bnQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbmV3SXRlbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgbmV3SXRlbXNbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcblxuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW107XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIGFkbS5zcGxpY2VXaXRoQXJyYXlfKGluZGV4KTtcblxuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gYWRtLnNwbGljZVdpdGhBcnJheV8oaW5kZXgsIGRlbGV0ZUNvdW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRtLnNwbGljZVdpdGhBcnJheV8oaW5kZXgsIGRlbGV0ZUNvdW50LCBuZXdJdGVtcyk7XG4gIH0sXG4gIHNwbGljZVdpdGhBcnJheTogZnVuY3Rpb24gc3BsaWNlV2l0aEFycmF5KGluZGV4LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpIHtcbiAgICByZXR1cm4gdGhpc1skbW9ieF0uc3BsaWNlV2l0aEFycmF5XyhpbmRleCwgZGVsZXRlQ291bnQsIG5ld0l0ZW1zKTtcbiAgfSxcbiAgcHVzaDogZnVuY3Rpb24gcHVzaCgpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG5cbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBpdGVtc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGFkbS5zcGxpY2VXaXRoQXJyYXlfKGFkbS52YWx1ZXNfLmxlbmd0aCwgMCwgaXRlbXMpO1xuICAgIHJldHVybiBhZG0udmFsdWVzXy5sZW5ndGg7XG4gIH0sXG4gIHBvcDogZnVuY3Rpb24gcG9wKCkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZShNYXRoLm1heCh0aGlzWyRtb2J4XS52YWx1ZXNfLmxlbmd0aCAtIDEsIDApLCAxKVswXTtcbiAgfSxcbiAgc2hpZnQ6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZSgwLCAxKVswXTtcbiAgfSxcbiAgdW5zaGlmdDogZnVuY3Rpb24gdW5zaGlmdCgpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG5cbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBpdGVtc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cblxuICAgIGFkbS5zcGxpY2VXaXRoQXJyYXlfKDAsIDAsIGl0ZW1zKTtcbiAgICByZXR1cm4gYWRtLnZhbHVlc18ubGVuZ3RoO1xuICB9LFxuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIC8vIHJldmVyc2UgYnkgZGVmYXVsdCBtdXRhdGVzIGluIHBsYWNlIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlc3VsdFxuICAgIC8vIHdoaWNoIG1ha2VzIGl0IGJvdGggYSAnZGVyaXZhdGlvbicgYW5kIGEgJ211dGF0aW9uJy5cbiAgICBpZiAoZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB7XG4gICAgICBkaWUoMzcsIFwicmV2ZXJzZVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcGxhY2UodGhpcy5zbGljZSgpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgLy8gc29ydCBieSBkZWZhdWx0IG11dGF0ZXMgaW4gcGxhY2UgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0XG4gICAgLy8gd2hpY2ggZ29lcyBhZ2FpbnN0IGFsbCBnb29kIHByYWN0aWNlcy4gTGV0J3Mgbm90IGNoYW5nZSB0aGUgYXJyYXkgaW4gcGxhY2UhXG4gICAgaWYgKGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbikge1xuICAgICAgZGllKDM3LCBcInNvcnRcIik7XG4gICAgfVxuXG4gICAgdmFyIGNvcHkgPSB0aGlzLnNsaWNlKCk7XG4gICAgY29weS5zb3J0LmFwcGx5KGNvcHksIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5yZXBsYWNlKGNvcHkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSh2YWx1ZSkge1xuICAgIHZhciBhZG0gPSB0aGlzWyRtb2J4XTtcbiAgICB2YXIgaWR4ID0gYWRtLmRlaGFuY2VWYWx1ZXNfKGFkbS52YWx1ZXNfKS5pbmRleE9mKHZhbHVlKTtcblxuICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgdGhpcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbi8qKlxyXG4gKiBXcmFwIGZ1bmN0aW9uIGZyb20gcHJvdG90eXBlXHJcbiAqIFdpdGhvdXQgdGhpcywgZXZlcnl0aGluZyB3b3JrcyBhcyB3ZWxsLCBidXQgdGhpcyB3b3Jrc1xyXG4gKiBmYXN0ZXIgYXMgZXZlcnl0aGluZyB3b3JrcyBvbiB1bnByb3hpZWQgdmFsdWVzXHJcbiAqL1xuXG5hZGRBcnJheUV4dGVuc2lvbihcImNvbmNhdFwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZmxhdFwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiaW5jbHVkZXNcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImluZGV4T2ZcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImpvaW5cIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImxhc3RJbmRleE9mXCIsIHNpbXBsZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJzbGljZVwiLCBzaW1wbGVGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwidG9TdHJpbmdcIiwgc2ltcGxlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInRvTG9jYWxlU3RyaW5nXCIsIHNpbXBsZUZ1bmMpOyAvLyBtYXBcblxuYWRkQXJyYXlFeHRlbnNpb24oXCJldmVyeVwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZpbHRlclwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcImZpbmRcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmaW5kSW5kZXhcIiwgbWFwTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJmbGF0TWFwXCIsIG1hcExpa2VGdW5jKTtcbmFkZEFycmF5RXh0ZW5zaW9uKFwiZm9yRWFjaFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcIm1hcFwiLCBtYXBMaWtlRnVuYyk7XG5hZGRBcnJheUV4dGVuc2lvbihcInNvbWVcIiwgbWFwTGlrZUZ1bmMpOyAvLyByZWR1Y2VcblxuYWRkQXJyYXlFeHRlbnNpb24oXCJyZWR1Y2VcIiwgcmVkdWNlTGlrZUZ1bmMpO1xuYWRkQXJyYXlFeHRlbnNpb24oXCJyZWR1Y2VSaWdodFwiLCByZWR1Y2VMaWtlRnVuYyk7XG5cbmZ1bmN0aW9uIGFkZEFycmF5RXh0ZW5zaW9uKGZ1bmNOYW1lLCBmdW5jRmFjdG9yeSkge1xuICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZVtmdW5jTmFtZV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGFycmF5RXh0ZW5zaW9uc1tmdW5jTmFtZV0gPSBmdW5jRmFjdG9yeShmdW5jTmFtZSk7XG4gIH1cbn0gLy8gUmVwb3J0IGFuZCBkZWxlZ2F0ZSB0byBkZWhhbmNlZCBhcnJheVxuXG5cbmZ1bmN0aW9uIHNpbXBsZUZ1bmMoZnVuY05hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgYWRtLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgdmFyIGRlaGFuY2VkVmFsdWVzID0gYWRtLmRlaGFuY2VWYWx1ZXNfKGFkbS52YWx1ZXNfKTtcbiAgICByZXR1cm4gZGVoYW5jZWRWYWx1ZXNbZnVuY05hbWVdLmFwcGx5KGRlaGFuY2VkVmFsdWVzLCBhcmd1bWVudHMpO1xuICB9O1xufSAvLyBNYWtlIHN1cmUgY2FsbGJhY2tzIHJlY2lldmUgY29ycmVjdCBhcnJheSBhcmcgIzIzMjZcblxuXG5mdW5jdGlvbiBtYXBMaWtlRnVuYyhmdW5jTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgYWRtLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgdmFyIGRlaGFuY2VkVmFsdWVzID0gYWRtLmRlaGFuY2VWYWx1ZXNfKGFkbS52YWx1ZXNfKTtcbiAgICByZXR1cm4gZGVoYW5jZWRWYWx1ZXNbZnVuY05hbWVdKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgZWxlbWVudCwgaW5kZXgsIF90aGlzMik7XG4gICAgfSk7XG4gIH07XG59IC8vIE1ha2Ugc3VyZSBjYWxsYmFja3MgcmVjaWV2ZSBjb3JyZWN0IGFycmF5IGFyZyAjMjMyNlxuXG5cbmZ1bmN0aW9uIHJlZHVjZUxpa2VGdW5jKGZ1bmNOYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgYWRtID0gdGhpc1skbW9ieF07XG4gICAgYWRtLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgdmFyIGRlaGFuY2VkVmFsdWVzID0gYWRtLmRlaGFuY2VWYWx1ZXNfKGFkbS52YWx1ZXNfKTsgLy8gIzI0MzIgLSByZWR1Y2UgYmVoYXZpb3IgZGVwZW5kcyBvbiBhcmd1bWVudHMubGVuZ3RoXG5cbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG5cbiAgICBhcmd1bWVudHNbMF0gPSBmdW5jdGlvbiAoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlLCBpbmRleCwgX3RoaXMzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlaGFuY2VkVmFsdWVzW2Z1bmNOYW1lXS5hcHBseShkZWhhbmNlZFZhbHVlcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIGlzT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb24gPSAvKiNfX1BVUkVfXyovY3JlYXRlSW5zdGFuY2VvZlByZWRpY2F0ZShcIk9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uXCIsIE9ic2VydmFibGVBcnJheUFkbWluaXN0cmF0aW9uKTtcbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZUFycmF5KHRoaW5nKSB7XG4gIHJldHVybiBpc09iamVjdCh0aGluZykgJiYgaXNPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbih0aGluZ1skbW9ieF0pO1xufVxuXG52YXIgX1N5bWJvbCRpdGVyYXRvciwgX1N5bWJvbCR0b1N0cmluZ1RhZztcbnZhciBPYnNlcnZhYmxlTWFwTWFya2VyID0ge307XG52YXIgQUREID0gXCJhZGRcIjtcbnZhciBERUxFVEUgPSBcImRlbGV0ZVwiOyAvLyBqdXN0IGV4dGVuZCBNYXA/IFNlZSBhbHNvIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL25lc3RoYXJ1cy8xM2I0ZDc0ZjJlZjRhMmY0MzU3ZGJkM2ZjMjNjMWU1NFxuLy8gQnV0OiBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvaXNzdWVzLzE1NTZcblxuX1N5bWJvbCRpdGVyYXRvciA9IFN5bWJvbC5pdGVyYXRvcjtcbl9TeW1ib2wkdG9TdHJpbmdUYWcgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG52YXIgT2JzZXJ2YWJsZU1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIGhhc01hcCwgbm90IGhhc2hNYXAgPi0pLlxuICBmdW5jdGlvbiBPYnNlcnZhYmxlTWFwKGluaXRpYWxEYXRhLCBlbmhhbmNlcl8sIG5hbWVfKSB7XG4gICAgaWYgKGVuaGFuY2VyXyA9PT0gdm9pZCAwKSB7XG4gICAgICBlbmhhbmNlcl8gPSBkZWVwRW5oYW5jZXI7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVfID09PSB2b2lkIDApIHtcbiAgICAgIG5hbWVfID0gIFwiT2JzZXJ2YWJsZU1hcEBcIiArIGdldE5leHRJZCgpIDtcbiAgICB9XG5cbiAgICB0aGlzLmVuaGFuY2VyXyA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXNbJG1vYnhdID0gT2JzZXJ2YWJsZU1hcE1hcmtlcjtcbiAgICB0aGlzLmRhdGFfID0gdm9pZCAwO1xuICAgIHRoaXMuaGFzTWFwXyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleXNBdG9tXyA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmhhbmNlcl8gPSBlbmhhbmNlcl87XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKE1hcCkpIHtcbiAgICAgIGRpZSgxOCk7XG4gICAgfVxuXG4gICAgdGhpcy5rZXlzQXRvbV8gPSBjcmVhdGVBdG9tKCB0aGlzLm5hbWVfICsgXCIua2V5cygpXCIgKTtcbiAgICB0aGlzLmRhdGFfID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuaGFzTWFwXyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm1lcmdlKGluaXRpYWxEYXRhKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBPYnNlcnZhYmxlTWFwLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFzXyA9IGZ1bmN0aW9uIGhhc18oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YV8uaGFzKGtleSk7XG4gIH07XG5cbiAgX3Byb3RvLmhhcyA9IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCFnbG9iYWxTdGF0ZS50cmFja2luZ0Rlcml2YXRpb24pIHJldHVybiB0aGlzLmhhc18oa2V5KTtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmhhc01hcF8uZ2V0KGtleSk7XG5cbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICB2YXIgbmV3RW50cnkgPSBlbnRyeSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUodGhpcy5oYXNfKGtleSksIHJlZmVyZW5jZUVuaGFuY2VyLCAgdGhpcy5uYW1lXyArIFwiLlwiICsgc3RyaW5naWZ5S2V5KGtleSkgKyBcIj9cIiAsIGZhbHNlKTtcbiAgICAgIHRoaXMuaGFzTWFwXy5zZXQoa2V5LCBuZXdFbnRyeSk7XG4gICAgICBvbkJlY29tZVVub2JzZXJ2ZWQobmV3RW50cnksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhhc01hcF9bXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRyeS5nZXQoKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICB2YXIgaGFzS2V5ID0gdGhpcy5oYXNfKGtleSk7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogaGFzS2V5ID8gVVBEQVRFIDogQURELFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbmFtZToga2V5XG4gICAgICB9KTtcbiAgICAgIGlmICghY2hhbmdlKSByZXR1cm4gdGhpcztcbiAgICAgIHZhbHVlID0gY2hhbmdlLm5ld1ZhbHVlO1xuICAgIH1cblxuICAgIGlmIChoYXNLZXkpIHtcbiAgICAgIHRoaXMudXBkYXRlVmFsdWVfKGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZFZhbHVlXyhrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG9bXCJkZWxldGVcIl0gPSBmdW5jdGlvbiBfZGVsZXRlKGtleSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgY2hlY2tJZlN0YXRlTW9kaWZpY2F0aW9uc0FyZUFsbG93ZWQodGhpcy5rZXlzQXRvbV8pO1xuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IERFTEVURSxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuYW1lOiBrZXlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNfKGtleSkpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG5cbiAgICAgIHZhciBfY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgb2JzZXJ2YWJsZUtpbmQ6IFwibWFwXCIsXG4gICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgdHlwZTogREVMRVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG9sZFZhbHVlOiB0aGlzLmRhdGFfLmdldChrZXkpLnZhbHVlXyxcbiAgICAgICAgbmFtZToga2V5XG4gICAgICB9IDogbnVsbDtcblxuICAgICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UpO1xuICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcblxuICAgICAgICBfdGhpczIudXBkYXRlSGFzTWFwRW50cnlfKGtleSwgZmFsc2UpO1xuXG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gX3RoaXMyLmRhdGFfLmdldChrZXkpO1xuXG4gICAgICAgIG9ic2VydmFibGUuc2V0TmV3VmFsdWVfKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgX3RoaXMyLmRhdGFfW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlKTtcbiAgICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRFbmQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlSGFzTWFwRW50cnlfID0gZnVuY3Rpb24gdXBkYXRlSGFzTWFwRW50cnlfKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmhhc01hcF8uZ2V0KGtleSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnNldE5ld1ZhbHVlXyh2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by51cGRhdGVWYWx1ZV8gPSBmdW5jdGlvbiB1cGRhdGVWYWx1ZV8oa2V5LCBuZXdWYWx1ZSkge1xuICAgIHZhciBvYnNlcnZhYmxlID0gdGhpcy5kYXRhXy5nZXQoa2V5KTtcbiAgICBuZXdWYWx1ZSA9IG9ic2VydmFibGUucHJlcGFyZU5ld1ZhbHVlXyhuZXdWYWx1ZSk7XG5cbiAgICBpZiAobmV3VmFsdWUgIT09IGdsb2JhbFN0YXRlLlVOQ0hBTkdFRCkge1xuICAgICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJtYXBcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICB0eXBlOiBVUERBVEUsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgb2xkVmFsdWU6IG9ic2VydmFibGUudmFsdWVfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgfSA6IG51bGw7XG4gICAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICAgIG9ic2VydmFibGUuc2V0TmV3VmFsdWVfKG5ld1ZhbHVlKTtcbiAgICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYWRkVmFsdWVfID0gZnVuY3Rpb24gYWRkVmFsdWVfKGtleSwgbmV3VmFsdWUpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMua2V5c0F0b21fKTtcbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlVmFsdWUobmV3VmFsdWUsIF90aGlzMy5lbmhhbmNlcl8sICBfdGhpczMubmFtZV8gKyBcIi5cIiArIHN0cmluZ2lmeUtleShrZXkpICwgZmFsc2UpO1xuXG4gICAgICBfdGhpczMuZGF0YV8uc2V0KGtleSwgb2JzZXJ2YWJsZSk7XG5cbiAgICAgIG5ld1ZhbHVlID0gb2JzZXJ2YWJsZS52YWx1ZV87IC8vIHZhbHVlIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkXG5cbiAgICAgIF90aGlzMy51cGRhdGVIYXNNYXBFbnRyeV8oa2V5LCB0cnVlKTtcblxuICAgICAgX3RoaXMzLmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgfSk7XG4gICAgdmFyIG5vdGlmeVNweSA9IGlzU3B5RW5hYmxlZCgpO1xuICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgdmFyIGNoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICBvYnNlcnZhYmxlS2luZDogXCJtYXBcIixcbiAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgIHR5cGU6IEFERCxcbiAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgIG5hbWU6IGtleSxcbiAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgIH0gOiBudWxsO1xuICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRTdGFydChjaGFuZ2UpO1xuICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRFbmQoKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmICh0aGlzLmhhcyhrZXkpKSByZXR1cm4gdGhpcy5kZWhhbmNlVmFsdWVfKHRoaXMuZGF0YV8uZ2V0KGtleSkuZ2V0KCkpO1xuICAgIHJldHVybiB0aGlzLmRlaGFuY2VWYWx1ZV8odW5kZWZpbmVkKTtcbiAgfTtcblxuICBfcHJvdG8uZGVoYW5jZVZhbHVlXyA9IGZ1bmN0aW9uIGRlaGFuY2VWYWx1ZV8odmFsdWUpIHtcbiAgICBpZiAodGhpcy5kZWhhbmNlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWhhbmNlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5rZXlzID0gZnVuY3Rpb24ga2V5cygpIHtcbiAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiB0aGlzLmRhdGFfLmtleXMoKTtcbiAgfTtcblxuICBfcHJvdG8udmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIga2V5cyA9IHRoaXMua2V5cygpO1xuICAgIHJldHVybiBtYWtlSXRlcmFibGUoe1xuICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIF9rZXlzJG5leHQgPSBrZXlzLm5leHQoKSxcbiAgICAgICAgICAgIGRvbmUgPSBfa2V5cyRuZXh0LmRvbmUsXG4gICAgICAgICAgICB2YWx1ZSA9IF9rZXlzJG5leHQudmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBkb25lLFxuICAgICAgICAgIHZhbHVlOiBkb25lID8gdW5kZWZpbmVkIDogc2VsZi5nZXQodmFsdWUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIga2V5cyA9IHRoaXMua2V5cygpO1xuICAgIHJldHVybiBtYWtlSXRlcmFibGUoe1xuICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgdmFyIF9rZXlzJG5leHQyID0ga2V5cy5uZXh0KCksXG4gICAgICAgICAgICBkb25lID0gX2tleXMkbmV4dDIuZG9uZSxcbiAgICAgICAgICAgIHZhbHVlID0gX2tleXMkbmV4dDIudmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBkb25lLFxuICAgICAgICAgIHZhbHVlOiBkb25lID8gdW5kZWZpbmVkIDogW3ZhbHVlLCBzZWxmLmdldCh2YWx1ZSldXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvW19TeW1ib2wkaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfTtcblxuICBfcHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRoaXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIF9zdGVwJHZhbHVlID0gX3N0ZXAudmFsdWUsXG4gICAgICAgICAga2V5ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfc3RlcCR2YWx1ZVsxXTtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIGtleSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBNZXJnZSBhbm90aGVyIG9iamVjdCBpbnRvIHRoaXMgb2JqZWN0LCByZXR1cm5zIHRoaXMuICovXG4gIDtcblxuICBfcHJvdG8ubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZShvdGhlcikge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKGlzT2JzZXJ2YWJsZU1hcChvdGhlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IE1hcChvdGhlcik7XG4gICAgfVxuXG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qob3RoZXIpKSBnZXRQbGFpbk9iamVjdEtleXMob3RoZXIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gX3RoaXM0LnNldChrZXksIG90aGVyW2tleV0pO1xuICAgICAgfSk7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvdGhlcikpIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIGtleSA9IF9yZWZbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IF9yZWZbMV07XG4gICAgICAgIHJldHVybiBfdGhpczQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSk7ZWxzZSBpZiAoaXNFUzZNYXAob3RoZXIpKSB7XG4gICAgICAgIGlmIChvdGhlci5jb25zdHJ1Y3RvciAhPT0gTWFwKSBkaWUoMTksIG90aGVyKTtcbiAgICAgICAgb3RoZXIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3RoZXIgIT09IG51bGwgJiYgb3RoZXIgIT09IHVuZGVmaW5lZCkgZGllKDIwLCBvdGhlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICB1bnRyYWNrZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShfdGhpczUua2V5cygpKSwgX3N0ZXAyOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIoKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgX3RoaXM1W1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSh2YWx1ZXMpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIC8vIEltcGxlbWVudGF0aW9uIHJlcXVpcmVtZW50czpcbiAgICAvLyAtIHJlc3BlY3Qgb3JkZXJpbmcgb2YgcmVwbGFjZW1lbnQgbWFwXG4gICAgLy8gLSBhbGxvdyBpbnRlcmNlcHRvcnMgdG8gcnVuIGFuZCBwb3RlbnRpYWxseSBwcmV2ZW50IGluZGl2aWR1YWwgb3BlcmF0aW9uc1xuICAgIC8vIC0gZG9uJ3QgcmVjcmVhdGUgb2JzZXJ2YWJsZXMgdGhhdCBhbHJlYWR5IGV4aXN0IGluIG9yaWdpbmFsIG1hcCAoc28gd2UgZG9uJ3QgZGVzdHJveSBleGlzdGluZyBzdWJzY3JpcHRpb25zKVxuICAgIC8vIC0gZG9uJ3QgX2tleXNBdG9tLnJlcG9ydENoYW5nZWQgaWYgdGhlIGtleXMgb2YgcmVzdWx0aW5nIG1hcCBhcmUgaW5kZW50aWNhbCAob3JkZXIgbWF0dGVycyEpXG4gICAgLy8gLSBub3RlIHRoYXQgcmVzdWx0IG1hcCBtYXkgZGlmZmVyIGZyb20gcmVwbGFjZW1lbnQgbWFwIGR1ZSB0byB0aGUgaW50ZXJjZXB0b3JzXG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQ29udmVydCB0byBtYXAgc28gd2UgY2FuIGRvIHF1aWNrIGtleSBsb29rdXBzXG4gICAgICB2YXIgcmVwbGFjZW1lbnRNYXAgPSBjb252ZXJ0VG9NYXAodmFsdWVzKTtcbiAgICAgIHZhciBvcmRlcmVkRGF0YSA9IG5ldyBNYXAoKTsgLy8gVXNlZCBmb3Igb3B0aW1pemF0aW9uXG5cbiAgICAgIHZhciBrZXlzUmVwb3J0Q2hhbmdlZENhbGxlZCA9IGZhbHNlOyAvLyBEZWxldGUga2V5cyB0aGF0IGRvbid0IGV4aXN0IGluIHJlcGxhY2VtZW50IG1hcFxuICAgICAgLy8gaWYgdGhlIGtleSBkZWxldGlvbiBpcyBwcmV2ZW50ZWQgYnkgaW50ZXJjZXB0b3JcbiAgICAgIC8vIGFkZCBlbnRyeSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZXN1bHQgbWFwXG5cbiAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKF90aGlzNi5kYXRhXy5rZXlzKCkpLCBfc3RlcDM7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMygpKS5kb25lOykge1xuICAgICAgICB2YXIga2V5ID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgIC8vIENvbmN1cnJlbnRseSBpdGVyYXRpbmcvZGVsZXRpbmcga2V5c1xuICAgICAgICAvLyBpdGVyYXRvciBzaG91bGQgaGFuZGxlIHRoaXMgY29ycmVjdGx5XG4gICAgICAgIGlmICghcmVwbGFjZW1lbnRNYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICB2YXIgZGVsZXRlZCA9IF90aGlzNltcImRlbGV0ZVwiXShrZXkpOyAvLyBXYXMgdGhlIGtleSByZW1vdmVkP1xuXG5cbiAgICAgICAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICAgICAgLy8gX2tleXNBdG9tLnJlcG9ydENoYW5nZWQoKSB3YXMgYWxyZWFkeSBjYWxsZWRcbiAgICAgICAgICAgIGtleXNSZXBvcnRDaGFuZ2VkQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVsZXRlIHByZXZlbnRlZCBieSBpbnRlcmNlcHRvclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXM2LmRhdGFfLmdldChrZXkpO1xuXG4gICAgICAgICAgICBvcmRlcmVkRGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIE1lcmdlIGVudHJpZXNcblxuXG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShyZXBsYWNlbWVudE1hcC5lbnRyaWVzKCkpLCBfc3RlcDQ7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNCgpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXA0JHZhbHVlID0gX3N0ZXA0LnZhbHVlLFxuICAgICAgICAgICAgX2tleSA9IF9zdGVwNCR2YWx1ZVswXSxcbiAgICAgICAgICAgIF92YWx1ZSA9IF9zdGVwNCR2YWx1ZVsxXTtcblxuICAgICAgICAvLyBXZSB3aWxsIHdhbnQgdG8ga25vdyB3aGV0aGVyIGEgbmV3IGtleSBpcyBhZGRlZFxuICAgICAgICB2YXIga2V5RXhpc3RlZCA9IF90aGlzNi5kYXRhXy5oYXMoX2tleSk7IC8vIEFkZCBvciB1cGRhdGUgdmFsdWVcblxuXG4gICAgICAgIF90aGlzNi5zZXQoX2tleSwgX3ZhbHVlKTsgLy8gVGhlIGFkZGl0aW9uIGNvdWxkIGhhdmUgYmVlbiBwcmV2ZW50IGJ5IGludGVyY2VwdG9yXG5cblxuICAgICAgICBpZiAoX3RoaXM2LmRhdGFfLmhhcyhfa2V5KSkge1xuICAgICAgICAgIC8vIFRoZSB1cGRhdGUgY291bGQgaGF2ZSBiZWVuIHByZXZlbnRlZCBieSBpbnRlcmNlcHRvclxuICAgICAgICAgIC8vIGFuZCBhbHNvIHdlIHdhbnQgdG8gcHJlc2VydmUgZXhpc3RpbmcgdmFsdWVzXG4gICAgICAgICAgLy8gc28gdXNlIHZhbHVlIGZyb20gX2RhdGEgbWFwIChpbnN0ZWFkIG9mIHJlcGxhY2VtZW50IG1hcClcbiAgICAgICAgICB2YXIgX3ZhbHVlMiA9IF90aGlzNi5kYXRhXy5nZXQoX2tleSk7XG5cbiAgICAgICAgICBvcmRlcmVkRGF0YS5zZXQoX2tleSwgX3ZhbHVlMik7IC8vIFdhcyBhIG5ldyBrZXkgYWRkZWQ/XG5cbiAgICAgICAgICBpZiAoIWtleUV4aXN0ZWQpIHtcbiAgICAgICAgICAgIC8vIF9rZXlzQXRvbS5yZXBvcnRDaGFuZ2VkKCkgd2FzIGFscmVhZHkgY2FsbGVkXG4gICAgICAgICAgICBrZXlzUmVwb3J0Q2hhbmdlZENhbGxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENoZWNrIGZvciBwb3NzaWJsZSBrZXkgb3JkZXIgY2hhbmdlXG5cblxuICAgICAgaWYgKCFrZXlzUmVwb3J0Q2hhbmdlZENhbGxlZCkge1xuICAgICAgICBpZiAoX3RoaXM2LmRhdGFfLnNpemUgIT09IG9yZGVyZWREYXRhLnNpemUpIHtcbiAgICAgICAgICAvLyBJZiBzaXplIGRpZmZlcnMsIGtleXMgYXJlIGRlZmluaXRlbHkgbW9kaWZpZWRcbiAgICAgICAgICBfdGhpczYua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaXRlcjEgPSBfdGhpczYuZGF0YV8ua2V5cygpO1xuXG4gICAgICAgICAgdmFyIGl0ZXIyID0gb3JkZXJlZERhdGEua2V5cygpO1xuICAgICAgICAgIHZhciBuZXh0MSA9IGl0ZXIxLm5leHQoKTtcbiAgICAgICAgICB2YXIgbmV4dDIgPSBpdGVyMi5uZXh0KCk7XG5cbiAgICAgICAgICB3aGlsZSAoIW5leHQxLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChuZXh0MS52YWx1ZSAhPT0gbmV4dDIudmFsdWUpIHtcbiAgICAgICAgICAgICAgX3RoaXM2LmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5leHQxID0gaXRlcjEubmV4dCgpO1xuICAgICAgICAgICAgbmV4dDIgPSBpdGVyMi5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIFVzZSBjb3JyZWN0bHkgb3JkZXJlZCBtYXBcblxuXG4gICAgICBfdGhpczYuZGF0YV8gPSBvcmRlcmVkRGF0YTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IE9ic2VydmFibGVNYXBdXCI7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbiAgfTtcblxuICAvKipcclxuICAgKiBPYnNlcnZlcyB0aGlzIG9iamVjdC4gVHJpZ2dlcnMgZm9yIHRoZSBldmVudHMgJ2FkZCcsICd1cGRhdGUnIGFuZCAnZGVsZXRlJy5cclxuICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9vYnNlcnZlXHJcbiAgICogZm9yIGNhbGxiYWNrIGRldGFpbHNcclxuICAgKi9cbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8obGlzdGVuZXIsIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIGlmICggZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IGZpcmVJbW1lZGlhdGVseT10cnVlIGluIGNvbWJpbmF0aW9uIHdpdGggbWFwcy5cIik7XG4gICAgcmV0dXJuIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgbGlzdGVuZXIpO1xuICB9O1xuXG4gIF9wcm90by5pbnRlcmNlcHRfID0gZnVuY3Rpb24gaW50ZXJjZXB0XyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySW50ZXJjZXB0b3IodGhpcywgaGFuZGxlcik7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGVNYXAsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCR0b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBcIk1hcFwiO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYnNlcnZhYmxlTWFwO1xufSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblxudmFyIGlzT2JzZXJ2YWJsZU1hcCA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZU1hcFwiLCBPYnNlcnZhYmxlTWFwKTtcblxuZnVuY3Rpb24gY29udmVydFRvTWFwKGRhdGFTdHJ1Y3R1cmUpIHtcbiAgaWYgKGlzRVM2TWFwKGRhdGFTdHJ1Y3R1cmUpIHx8IGlzT2JzZXJ2YWJsZU1hcChkYXRhU3RydWN0dXJlKSkge1xuICAgIHJldHVybiBkYXRhU3RydWN0dXJlO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVN0cnVjdHVyZSkpIHtcbiAgICByZXR1cm4gbmV3IE1hcChkYXRhU3RydWN0dXJlKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGRhdGFTdHJ1Y3R1cmUpKSB7XG4gICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcblxuICAgIGZvciAodmFyIGtleSBpbiBkYXRhU3RydWN0dXJlKSB7XG4gICAgICBtYXAuc2V0KGtleSwgZGF0YVN0cnVjdHVyZVtrZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkaWUoMjEsIGRhdGFTdHJ1Y3R1cmUpO1xuICB9XG59XG5cbnZhciBfU3ltYm9sJGl0ZXJhdG9yJDEsIF9TeW1ib2wkdG9TdHJpbmdUYWckMTtcbnZhciBPYnNlcnZhYmxlU2V0TWFya2VyID0ge307XG5fU3ltYm9sJGl0ZXJhdG9yJDEgPSBTeW1ib2wuaXRlcmF0b3I7XG5fU3ltYm9sJHRvU3RyaW5nVGFnJDEgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG52YXIgT2JzZXJ2YWJsZVNldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGVTZXQoaW5pdGlhbERhdGEsIGVuaGFuY2VyLCBuYW1lXykge1xuICAgIGlmIChlbmhhbmNlciA9PT0gdm9pZCAwKSB7XG4gICAgICBlbmhhbmNlciA9IGRlZXBFbmhhbmNlcjtcbiAgICB9XG5cbiAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkge1xuICAgICAgbmFtZV8gPSAgXCJPYnNlcnZhYmxlU2V0QFwiICsgZ2V0TmV4dElkKCkgO1xuICAgIH1cblxuICAgIHRoaXMubmFtZV8gPSB2b2lkIDA7XG4gICAgdGhpc1skbW9ieF0gPSBPYnNlcnZhYmxlU2V0TWFya2VyO1xuICAgIHRoaXMuZGF0YV8gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5hdG9tXyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc18gPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcmNlcHRvcnNfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVoYW5jZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmhhbmNlcl8gPSB2b2lkIDA7XG4gICAgdGhpcy5uYW1lXyA9IG5hbWVfO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKFNldCkpIHtcbiAgICAgIGRpZSgyMik7XG4gICAgfVxuXG4gICAgdGhpcy5hdG9tXyA9IGNyZWF0ZUF0b20odGhpcy5uYW1lXyk7XG5cbiAgICB0aGlzLmVuaGFuY2VyXyA9IGZ1bmN0aW9uIChuZXdWLCBvbGRWKSB7XG4gICAgICByZXR1cm4gZW5oYW5jZXIobmV3Viwgb2xkViwgbmFtZV8pO1xuICAgIH07XG5cbiAgICBpZiAoaW5pdGlhbERhdGEpIHtcbiAgICAgIHRoaXMucmVwbGFjZShpbml0aWFsRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IE9ic2VydmFibGVTZXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZWhhbmNlVmFsdWVfID0gZnVuY3Rpb24gZGVoYW5jZVZhbHVlXyh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRlaGFuY2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlaGFuY2VyKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRyYW5zYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVudHJhY2tlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoX3RoaXMuZGF0YV8udmFsdWVzKCkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgX3RoaXNbXCJkZWxldGVcIl0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tGbiwgdGhpc0FyZykge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRoaXMpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgdmFyIHZhbHVlID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgY2FsbGJhY2tGbi5jYWxsKHRoaXNBcmcsIHZhbHVlLCB2YWx1ZSwgdGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGNoZWNrSWZTdGF0ZU1vZGlmaWNhdGlvbnNBcmVBbGxvd2VkKHRoaXMuYXRvbV8pO1xuXG4gICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuZXdWYWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiB0aGlzOyAvLyBpZGVhbGx5LCB2YWx1ZSA9IGNoYW5nZS52YWx1ZSB3b3VsZCBiZSBkb25lIGhlcmUsIHNvIHRoYXQgdmFsdWVzIGNhbiBiZVxuICAgICAgLy8gY2hhbmdlZCBieSBpbnRlcmNlcHRvci4gU2FtZSBhcHBsaWVzIGZvciBvdGhlciBTZXQgYW5kIE1hcCBhcGkncy5cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuZGF0YV8uYWRkKF90aGlzMi5lbmhhbmNlcl8odmFsdWUsIHVuZGVmaW5lZCkpO1xuXG4gICAgICAgIF90aGlzMi5hdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBub3RpZnlTcHkgPSAgaXNTcHlFbmFibGVkKCk7XG4gICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuXG4gICAgICB2YXIgX2NoYW5nZSA9IG5vdGlmeSB8fCBub3RpZnlTcHkgPyB7XG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcInNldFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgICBuZXdWYWx1ZTogdmFsdWVcbiAgICAgIH0gOiBudWxsO1xuXG4gICAgICBpZiAobm90aWZ5U3B5ICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIpIHNweVJlcG9ydFN0YXJ0KF9jaGFuZ2UpO1xuICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UpO1xuICAgICAgaWYgKG5vdGlmeVNweSAmJiBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiKSBzcHlSZXBvcnRFbmQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG9bXCJkZWxldGVcIl0gPSBmdW5jdGlvbiBfZGVsZXRlKHZhbHVlKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogREVMRVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMsXG4gICAgICAgIG9sZFZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgIHZhciBub3RpZnlTcHkgPSAgaXNTcHlFbmFibGVkKCk7XG4gICAgICB2YXIgbm90aWZ5ID0gaGFzTGlzdGVuZXJzKHRoaXMpO1xuXG4gICAgICB2YXIgX2NoYW5nZTIgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJzZXRcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICB0eXBlOiBERUxFVEUsXG4gICAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgICAgb2xkVmFsdWU6IHZhbHVlXG4gICAgICB9IDogbnVsbDtcblxuICAgICAgaWYgKG5vdGlmeVNweSAmJiBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiKSBzcHlSZXBvcnRTdGFydChfY2hhbmdlMik7XG4gICAgICB0cmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5hdG9tXy5yZXBvcnRDaGFuZ2VkKCk7XG5cbiAgICAgICAgX3RoaXMzLmRhdGFfW1wiZGVsZXRlXCJdKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5vdGlmeSkgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIF9jaGFuZ2UyKTtcbiAgICAgIGlmIChub3RpZnlTcHkgJiYgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIikgc3B5UmVwb3J0RW5kKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmhhcyA9IGZ1bmN0aW9uIGhhcyh2YWx1ZSkge1xuICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICByZXR1cm4gdGhpcy5kYXRhXy5oYXModGhpcy5kZWhhbmNlVmFsdWVfKHZhbHVlKSk7XG4gIH07XG5cbiAgX3Byb3RvLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgIHZhciBrZXlzID0gQXJyYXkuZnJvbSh0aGlzLmtleXMoKSk7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5LmZyb20odGhpcy52YWx1ZXMoKSk7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIG5leHRJbmRleCArPSAxO1xuICAgICAgICByZXR1cm4gaW5kZXggPCB2YWx1ZXMubGVuZ3RoID8ge1xuICAgICAgICAgIHZhbHVlOiBba2V5c1tpbmRleF0sIHZhbHVlc1tpbmRleF1dLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5rZXlzID0gZnVuY3Rpb24ga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgfTtcblxuICBfcHJvdG8udmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHRoaXMuYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgdmFyIG9ic2VydmFibGVWYWx1ZXMgPSBBcnJheS5mcm9tKHRoaXMuZGF0YV8udmFsdWVzKCkpO1xuICAgIHJldHVybiBtYWtlSXRlcmFibGUoe1xuICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIG5leHRJbmRleCA8IG9ic2VydmFibGVWYWx1ZXMubGVuZ3RoID8ge1xuICAgICAgICAgIHZhbHVlOiBzZWxmLmRlaGFuY2VWYWx1ZV8ob2JzZXJ2YWJsZVZhbHVlc1tuZXh0SW5kZXgrK10pLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShvdGhlcikge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKGlzT2JzZXJ2YWJsZVNldChvdGhlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNldChvdGhlcik7XG4gICAgfVxuXG4gICAgdHJhbnNhY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3RoZXIpKSB7XG4gICAgICAgIF90aGlzNC5jbGVhcigpO1xuXG4gICAgICAgIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5hZGQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFUzZTZXQob3RoZXIpKSB7XG4gICAgICAgIF90aGlzNC5jbGVhcigpO1xuXG4gICAgICAgIG90aGVyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5hZGQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3RoZXIgIT09IG51bGwgJiYgb3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkaWUoXCJDYW5ub3QgaW5pdGlhbGl6ZSBzZXQgZnJvbSBcIiArIG90aGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ub2JzZXJ2ZV8gPSBmdW5jdGlvbiBvYnNlcnZlXyhsaXN0ZW5lciwgZmlyZUltbWVkaWF0ZWx5KSB7XG4gICAgLy8gLi4uICdmaXJlSW1tZWRpYXRlbHknIGNvdWxkIGFsc28gYmUgdHJ1ZT9cbiAgICBpZiAoIGZpcmVJbW1lZGlhdGVseSA9PT0gdHJ1ZSkgZGllKFwiYG9ic2VydmVgIGRvZXNuJ3Qgc3VwcG9ydCBmaXJlSW1tZWRpYXRlbHk9dHJ1ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHNldHMuXCIpO1xuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGxpc3RlbmVyKTtcbiAgfTtcblxuICBfcHJvdG8uaW50ZXJjZXB0XyA9IGZ1bmN0aW9uIGludGVyY2VwdF8oaGFuZGxlcikge1xuICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICB9O1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBPYnNlcnZhYmxlU2V0XVwiO1xuICB9O1xuXG4gIF9wcm90b1tfU3ltYm9sJGl0ZXJhdG9yJDFdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhPYnNlcnZhYmxlU2V0LCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aGlzLmF0b21fLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCR0b1N0cmluZ1RhZyQxLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFwiU2V0XCI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9ic2VydmFibGVTZXQ7XG59KCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXG52YXIgaXNPYnNlcnZhYmxlU2V0ID0gLyojX19QVVJFX18qL2NyZWF0ZUluc3RhbmNlb2ZQcmVkaWNhdGUoXCJPYnNlcnZhYmxlU2V0XCIsIE9ic2VydmFibGVTZXQpO1xuXG52YXIgZGVzY3JpcHRvckNhY2hlID0gLyojX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG52YXIgUkVNT1ZFID0gXCJyZW1vdmVcIjtcbnZhciBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24odGFyZ2V0XywgdmFsdWVzXywgbmFtZV8sIC8vIFVzZWQgYW55dGltZSBhbm5vdGF0aW9uIGlzIG5vdCBleHBsaWNpdGVseSBwcm92aWRlZFxuICBkZWZhdWx0QW5ub3RhdGlvbl8pIHtcbiAgICBpZiAodmFsdWVzXyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZXNfID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIGlmIChkZWZhdWx0QW5ub3RhdGlvbl8gPT09IHZvaWQgMCkge1xuICAgICAgZGVmYXVsdEFubm90YXRpb25fID0gYXV0b0Fubm90YXRpb247XG4gICAgfVxuXG4gICAgdGhpcy50YXJnZXRfID0gdm9pZCAwO1xuICAgIHRoaXMudmFsdWVzXyA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWVfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVmYXVsdEFubm90YXRpb25fID0gdm9pZCAwO1xuICAgIHRoaXMua2V5c0F0b21fID0gdm9pZCAwO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzXyA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyY2VwdG9yc18gPSB2b2lkIDA7XG4gICAgdGhpcy5wcm94eV8gPSB2b2lkIDA7XG4gICAgdGhpcy5pc1BsYWluT2JqZWN0XyA9IHZvaWQgMDtcbiAgICB0aGlzLmFwcGxpZWRBbm5vdGF0aW9uc18gPSB2b2lkIDA7XG4gICAgdGhpcy5wZW5kaW5nS2V5c18gPSB2b2lkIDA7XG4gICAgdGhpcy50YXJnZXRfID0gdGFyZ2V0XztcbiAgICB0aGlzLnZhbHVlc18gPSB2YWx1ZXNfO1xuICAgIHRoaXMubmFtZV8gPSBuYW1lXztcbiAgICB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXyA9IGRlZmF1bHRBbm5vdGF0aW9uXztcbiAgICB0aGlzLmtleXNBdG9tXyA9IG5ldyBBdG9tKCB0aGlzLm5hbWVfICsgXCIua2V5c1wiICk7IC8vIE9wdGltaXphdGlvbjogd2UgdXNlIHRoaXMgZnJlcXVlbnRseVxuXG4gICAgdGhpcy5pc1BsYWluT2JqZWN0XyA9IGlzUGxhaW5PYmplY3QodGhpcy50YXJnZXRfKTtcblxuICAgIGlmICggIWlzQW5ub3RhdGlvbih0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXykpIHtcbiAgICAgIGRpZShcImRlZmF1bHRBbm5vdGF0aW9uIG11c3QgYmUgdmFsaWQgYW5ub3RhdGlvblwiKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICAvLyBQcmVwYXJlIHN0cnVjdHVyZSBmb3IgdHJhY2tpbmcgd2hpY2ggZmllbGRzIHdlcmUgYWxyZWFkeSBhbm5vdGF0ZWRcbiAgICAgIHRoaXMuYXBwbGllZEFubm90YXRpb25zXyA9IHt9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyA9IGZ1bmN0aW9uIGdldE9ic2VydmFibGVQcm9wVmFsdWVfKGtleSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc18uZ2V0KGtleSkuZ2V0KCk7XG4gIH07XG5cbiAgX3Byb3RvLnNldE9ic2VydmFibGVQcm9wVmFsdWVfID0gZnVuY3Rpb24gc2V0T2JzZXJ2YWJsZVByb3BWYWx1ZV8oa2V5LCBuZXdWYWx1ZSkge1xuICAgIHZhciBvYnNlcnZhYmxlID0gdGhpcy52YWx1ZXNfLmdldChrZXkpO1xuXG4gICAgaWYgKG9ic2VydmFibGUgaW5zdGFuY2VvZiBDb21wdXRlZFZhbHVlKSB7XG4gICAgICBvYnNlcnZhYmxlLnNldChuZXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIGludGVyY2VwdFxuXG5cbiAgICBpZiAoaGFzSW50ZXJjZXB0b3JzKHRoaXMpKSB7XG4gICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgIH0pO1xuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBudWxsO1xuICAgICAgbmV3VmFsdWUgPSBjaGFuZ2UubmV3VmFsdWU7XG4gICAgfVxuXG4gICAgbmV3VmFsdWUgPSBvYnNlcnZhYmxlLnByZXBhcmVOZXdWYWx1ZV8obmV3VmFsdWUpOyAvLyBub3RpZnkgc3B5ICYgb2JzZXJ2ZXJzXG5cbiAgICBpZiAobmV3VmFsdWUgIT09IGdsb2JhbFN0YXRlLlVOQ0hBTkdFRCkge1xuICAgICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICAgIHZhciBub3RpZnlTcHkgPSAgaXNTcHlFbmFibGVkKCk7XG5cbiAgICAgIHZhciBfY2hhbmdlID0gbm90aWZ5IHx8IG5vdGlmeVNweSA/IHtcbiAgICAgICAgdHlwZTogVVBEQVRFLFxuICAgICAgICBvYnNlcnZhYmxlS2luZDogXCJvYmplY3RcIixcbiAgICAgICAgZGVidWdPYmplY3ROYW1lOiB0aGlzLm5hbWVfLFxuICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgb2xkVmFsdWU6IG9ic2VydmFibGUudmFsdWVfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZVxuICAgICAgfSA6IG51bGw7XG5cbiAgICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRTdGFydChfY2hhbmdlKTtcbiAgICAgIG9ic2VydmFibGUuc2V0TmV3VmFsdWVfKG5ld1ZhbHVlKTtcbiAgICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBfY2hhbmdlKTtcbiAgICAgIGlmICggbm90aWZ5U3B5KSBzcHlSZXBvcnRFbmQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0XyA9IGZ1bmN0aW9uIGdldF8oa2V5KSB7XG4gICAgaWYgKGdsb2JhbFN0YXRlLnRyYWNraW5nRGVyaXZhdGlvbiAmJiAhaGFzUHJvcCh0aGlzLnRhcmdldF8sIGtleSkpIHtcbiAgICAgIC8vIEtleSBkb2Vzbid0IGV4aXN0IHlldCwgc3Vic2NyaWJlIGZvciBpdCBpbiBjYXNlIGl0J3MgYWRkZWQgbGF0ZXJcbiAgICAgIHRoaXMuaGFzXyhrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRhcmdldF9ba2V5XTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcclxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcclxuICAgKiBAcGFyYW0ge0Fubm90YXRpb258Ym9vbGVhbn0gYW5ub3RhdGlvbiB0cnVlIC0gdXNlIGRlZmF1bHQgYW5ub3RhdGlvbiwgZmFsc2UgLSBjb3B5IGFzIGlzXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBwcm94eVRyYXAgd2hldGhlciBpdCdzIGNhbGxlZCBmcm9tIHByb3h5IHRyYXBcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxudWxsfSB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUgKHByb3h5VHJhcCArIG5vbi1jb25maWd1cmFibGUpLCBudWxsIHdoZW4gY2FuY2VsbGVkIGJ5IGludGVyY2VwdG9yXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2V0XyA9IGZ1bmN0aW9uIHNldF8oa2V5LCB2YWx1ZSwgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCB1c2UgLmhhcyhrZXkpIC0gd2UgY2FyZSBhYm91dCBvd25cbiAgICBpZiAoaGFzUHJvcCh0aGlzLnRhcmdldF8sIGtleSkpIHtcbiAgICAgIC8vIEV4aXN0aW5nIHByb3BcbiAgICAgIGlmICh0aGlzLnZhbHVlc18uaGFzKGtleSkpIHtcbiAgICAgICAgLy8gT2JzZXJ2YWJsZSAoY2FuIGJlIGludGVyY2VwdGVkKVxuICAgICAgICByZXR1cm4gdGhpcy5zZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIC8vIE5vbi1vYnNlcnZhYmxlIC0gcHJveHlcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRoaXMudGFyZ2V0Xywga2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb24tb2JzZXJ2YWJsZVxuICAgICAgICB0aGlzLnRhcmdldF9ba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmV3IHByb3BcbiAgICAgIHJldHVybiB0aGlzLmV4dGVuZF8oa2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSwgdGhpcy5kZWZhdWx0QW5ub3RhdGlvbl8sIHByb3h5VHJhcCk7XG4gICAgfVxuICB9IC8vIFRyYXAgZm9yIFwiaW5cIlxuICA7XG5cbiAgX3Byb3RvLmhhc18gPSBmdW5jdGlvbiBoYXNfKGtleSkge1xuICAgIGlmICghZ2xvYmFsU3RhdGUudHJhY2tpbmdEZXJpdmF0aW9uKSB7XG4gICAgICAvLyBTa2lwIGtleSBzdWJzY3JpcHRpb24gb3V0c2lkZSBkZXJpdmF0aW9uXG4gICAgICByZXR1cm4ga2V5IGluIHRoaXMudGFyZ2V0XztcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmdLZXlzXyB8fCAodGhpcy5wZW5kaW5nS2V5c18gPSBuZXcgTWFwKCkpO1xuICAgIHZhciBlbnRyeSA9IHRoaXMucGVuZGluZ0tleXNfLmdldChrZXkpO1xuXG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgZW50cnkgPSBuZXcgT2JzZXJ2YWJsZVZhbHVlKGtleSBpbiB0aGlzLnRhcmdldF8sIHJlZmVyZW5jZUVuaGFuY2VyLCAgdGhpcy5uYW1lXyArIFwiLlwiICsgc3RyaW5naWZ5S2V5KGtleSkgKyBcIj9cIiAsIGZhbHNlKTtcbiAgICAgIHRoaXMucGVuZGluZ0tleXNfLnNldChrZXksIGVudHJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW50cnkuZ2V0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XHJcbiAgICogQHBhcmFtIHtBbm5vdGF0aW9ufGJvb2xlYW59IGFubm90YXRpb24gdHJ1ZSAtIHVzZSBkZWZhdWx0IGFubm90YXRpb24sIGZhbHNlIC0gaWdub3JlIHByb3BcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5tYWtlXyA9IGZ1bmN0aW9uIG1ha2VfKGtleSwgYW5ub3RhdGlvbikge1xuICAgIGlmIChhbm5vdGF0aW9uID09PSB0cnVlKSB7XG4gICAgICBhbm5vdGF0aW9uID0gdGhpcy5kZWZhdWx0QW5ub3RhdGlvbl87XG4gICAgfVxuXG4gICAgaWYgKGFubm90YXRpb24gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXNzZXJ0QW5ub3RhYmxlKHRoaXMsIGFubm90YXRpb24sIGtleSk7XG5cbiAgICBpZiAoIShrZXkgaW4gdGhpcy50YXJnZXRfKSkge1xuICAgICAgdmFyIF90aGlzJHRhcmdldF8kc3RvcmVkQTtcblxuICAgICAgLy8gVGhyb3cgb24gbWlzc2luZyBrZXksIGV4Y2VwdCBmb3IgZGVjb3JhdG9yczpcbiAgICAgIC8vIERlY29yYXRvciBhbm5vdGF0aW9ucyBhcmUgY29sbGVjdGVkIGZyb20gd2hvbGUgcHJvdG90eXBlIGNoYWluLlxuICAgICAgLy8gV2hlbiBjYWxsZWQgZnJvbSBzdXBlcigpIHNvbWUgcHJvcHMgbWF5IG5vdCBleGlzdCB5ZXQuXG4gICAgICAvLyBIb3dldmVyIHdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgbWlzc2luZyBwcm9wLFxuICAgICAgLy8gYmVjYXVzZSB0aGUgZGVjb3JhdG9yIG11c3QgaGF2ZSBiZWVuIGFwcGxpZWQgdG8gc29tZXRoaW5nLlxuICAgICAgaWYgKChfdGhpcyR0YXJnZXRfJHN0b3JlZEEgPSB0aGlzLnRhcmdldF9bc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdGFyZ2V0XyRzdG9yZWRBW2tleV0pIHtcbiAgICAgICAgcmV0dXJuOyAvLyB3aWxsIGJlIGFubm90YXRlZCBieSBzdWJjbGFzcyBjb25zdHJ1Y3RvclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGllKDEsIGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfLCB0aGlzLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZSA9IHRoaXMudGFyZ2V0XztcblxuICAgIHdoaWxlIChzb3VyY2UgJiYgc291cmNlICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0RGVzY3JpcHRvcihzb3VyY2UsIGtleSk7XG5cbiAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgIHZhciBvdXRjb21lID0gYW5ub3RhdGlvbi5tYWtlXyh0aGlzLCBrZXksIGRlc2NyaXB0b3IsIHNvdXJjZSk7XG4gICAgICAgIGlmIChvdXRjb21lID09PSAwXG4gICAgICAgIC8qIENhbmNlbCAqL1xuICAgICAgICApIHJldHVybjtcbiAgICAgICAgaWYgKG91dGNvbWUgPT09IDFcbiAgICAgICAgLyogQnJlYWsgKi9cbiAgICAgICAgKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgc291cmNlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQodGhpcywgYW5ub3RhdGlvbiwga2V5KTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5S2V5fSBrZXlcclxuICAgKiBAcGFyYW0ge1Byb3BlcnR5RGVzY3JpcHRvcn0gZGVzY3JpcHRvclxyXG4gICAqIEBwYXJhbSB7QW5ub3RhdGlvbnxib29sZWFufSBhbm5vdGF0aW9uIHRydWUgLSB1c2UgZGVmYXVsdCBhbm5vdGF0aW9uLCBmYWxzZSAtIGNvcHkgYXMgaXNcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5leHRlbmRfID0gZnVuY3Rpb24gZXh0ZW5kXyhrZXksIGRlc2NyaXB0b3IsIGFubm90YXRpb24sIHByb3h5VHJhcCkge1xuICAgIGlmIChwcm94eVRyYXAgPT09IHZvaWQgMCkge1xuICAgICAgcHJveHlUcmFwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFubm90YXRpb24gPT09IHRydWUpIHtcbiAgICAgIGFubm90YXRpb24gPSB0aGlzLmRlZmF1bHRBbm5vdGF0aW9uXztcbiAgICB9XG5cbiAgICBpZiAoYW5ub3RhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmluZVByb3BlcnR5XyhrZXksIGRlc2NyaXB0b3IsIHByb3h5VHJhcCk7XG4gICAgfVxuXG4gICAgYXNzZXJ0QW5ub3RhYmxlKHRoaXMsIGFubm90YXRpb24sIGtleSk7XG4gICAgdmFyIG91dGNvbWUgPSBhbm5vdGF0aW9uLmV4dGVuZF8odGhpcywga2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApO1xuXG4gICAgaWYgKG91dGNvbWUpIHtcbiAgICAgIHJlY29yZEFubm90YXRpb25BcHBsaWVkKHRoaXMsIGFubm90YXRpb24sIGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGNvbWU7XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eUtleX0ga2V5XHJcbiAgICogQHBhcmFtIHtQcm9wZXJ0eURlc2NyaXB0b3J9IGRlc2NyaXB0b3JcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3h5VHJhcCB3aGV0aGVyIGl0J3MgY2FsbGVkIGZyb20gcHJveHkgdHJhcFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufG51bGx9IHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZSAocHJveHlUcmFwICsgbm9uLWNvbmZpZ3VyYWJsZSksIG51bGwgd2hlbiBjYW5jZWxsZWQgYnkgaW50ZXJjZXB0b3JcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZWZpbmVQcm9wZXJ0eV8gPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eV8oa2V5LCBkZXNjcmlwdG9yLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzdGFydEJhdGNoKCk7IC8vIERlbGV0ZVxuXG4gICAgICB2YXIgZGVsZXRlT3V0Y29tZSA9IHRoaXMuZGVsZXRlXyhrZXkpO1xuXG4gICAgICBpZiAoIWRlbGV0ZU91dGNvbWUpIHtcbiAgICAgICAgLy8gRmFpbHVyZSBvciBpbnRlcmNlcHRlZFxuICAgICAgICByZXR1cm4gZGVsZXRlT3V0Y29tZTtcbiAgICAgIH0gLy8gQUREIGludGVyY2VwdG9yXG5cblxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgdHlwZTogQURELFxuICAgICAgICAgIG5ld1ZhbHVlOiBkZXNjcmlwdG9yLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcblxuICAgICAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yID0gX2V4dGVuZHMoe30sIGRlc2NyaXB0b3IsIHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IC8vIERlZmluZVxuXG5cbiAgICAgIGlmIChwcm94eVRyYXApIHtcbiAgICAgICAgaWYgKCFSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfSAvLyBOb3RpZnlcblxuXG4gICAgICB0aGlzLm5vdGlmeVByb3BlcnR5QWRkaXRpb25fKGtleSwgZGVzY3JpcHRvci52YWx1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSWYgb3JpZ2luYWwgZGVzY3JpcHRvciBiZWNvbWVzIHJlbGV2YW50LCBtb3ZlIHRoaXMgdG8gYW5ub3RhdGlvbiBkaXJlY3RseVxuICA7XG5cbiAgX3Byb3RvLmRlZmluZU9ic2VydmFibGVQcm9wZXJ0eV8gPSBmdW5jdGlvbiBkZWZpbmVPYnNlcnZhYmxlUHJvcGVydHlfKGtleSwgdmFsdWUsIGVuaGFuY2VyLCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzdGFydEJhdGNoKCk7IC8vIERlbGV0ZVxuXG4gICAgICB2YXIgZGVsZXRlT3V0Y29tZSA9IHRoaXMuZGVsZXRlXyhrZXkpO1xuXG4gICAgICBpZiAoIWRlbGV0ZU91dGNvbWUpIHtcbiAgICAgICAgLy8gRmFpbHVyZSBvciBpbnRlcmNlcHRlZFxuICAgICAgICByZXR1cm4gZGVsZXRlT3V0Y29tZTtcbiAgICAgIH0gLy8gQUREIGludGVyY2VwdG9yXG5cblxuICAgICAgaWYgKGhhc0ludGVyY2VwdG9ycyh0aGlzKSkge1xuICAgICAgICB2YXIgY2hhbmdlID0gaW50ZXJjZXB0Q2hhbmdlKHRoaXMsIHtcbiAgICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgdHlwZTogQURELFxuICAgICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBudWxsO1xuICAgICAgICB2YWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhY2hlZERlc2NyaXB0b3IgPSBnZXRDYWNoZWRPYnNlcnZhYmxlUHJvcERlc2NyaXB0b3Ioa2V5KTtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IGdsb2JhbFN0YXRlLnNhZmVEZXNjcmlwdG9ycyA/IHRoaXMuaXNQbGFpbk9iamVjdF8gOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGNhY2hlZERlc2NyaXB0b3IuZ2V0LFxuICAgICAgICBzZXQ6IGNhY2hlZERlc2NyaXB0b3Iuc2V0XG4gICAgICB9OyAvLyBEZWZpbmVcblxuICAgICAgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICBpZiAoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXksIGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVWYWx1ZSh2YWx1ZSwgZW5oYW5jZXIsIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB0aGlzLm5hbWVfICsgXCIuXCIgKyBrZXkudG9TdHJpbmcoKSA6IFwiT2JzZXJ2YWJsZU9iamVjdC5rZXlcIiwgZmFsc2UpO1xuICAgICAgdGhpcy52YWx1ZXNfLnNldChrZXksIG9ic2VydmFibGUpOyAvLyBOb3RpZnkgKHZhbHVlIHBvc3NpYmx5IGNoYW5nZWQgYnkgT2JzZXJ2YWJsZVZhbHVlKVxuXG4gICAgICB0aGlzLm5vdGlmeVByb3BlcnR5QWRkaXRpb25fKGtleSwgb2JzZXJ2YWJsZS52YWx1ZV8pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIElmIG9yaWdpbmFsIGRlc2NyaXB0b3IgYmVjb21lcyByZWxldmFudCwgbW92ZSB0aGlzIHRvIGFubm90YXRpb24gZGlyZWN0bHlcbiAgO1xuXG4gIF9wcm90by5kZWZpbmVDb21wdXRlZFByb3BlcnR5XyA9IGZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkUHJvcGVydHlfKGtleSwgb3B0aW9ucywgcHJveHlUcmFwKSB7XG4gICAgaWYgKHByb3h5VHJhcCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm94eVRyYXAgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc3RhcnRCYXRjaCgpOyAvLyBEZWxldGVcblxuICAgICAgdmFyIGRlbGV0ZU91dGNvbWUgPSB0aGlzLmRlbGV0ZV8oa2V5KTtcblxuICAgICAgaWYgKCFkZWxldGVPdXRjb21lKSB7XG4gICAgICAgIC8vIEZhaWx1cmUgb3IgaW50ZXJjZXB0ZWRcbiAgICAgICAgcmV0dXJuIGRlbGV0ZU91dGNvbWU7XG4gICAgICB9IC8vIEFERCBpbnRlcmNlcHRvclxuXG5cbiAgICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGludGVyY2VwdENoYW5nZSh0aGlzLCB7XG4gICAgICAgICAgb2JqZWN0OiB0aGlzLnByb3h5XyB8fCB0aGlzLnRhcmdldF8sXG4gICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgIHR5cGU6IEFERCxcbiAgICAgICAgICBuZXdWYWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMubmFtZSB8fCAob3B0aW9ucy5uYW1lID0gXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHRoaXMubmFtZV8gKyBcIi5cIiArIGtleS50b1N0cmluZygpIDogXCJPYnNlcnZhYmxlT2JqZWN0LmtleVwiKTtcbiAgICAgIG9wdGlvbnMuY29udGV4dCA9IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XztcbiAgICAgIHZhciBjYWNoZWREZXNjcmlwdG9yID0gZ2V0Q2FjaGVkT2JzZXJ2YWJsZVByb3BEZXNjcmlwdG9yKGtleSk7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBnbG9iYWxTdGF0ZS5zYWZlRGVzY3JpcHRvcnMgPyB0aGlzLmlzUGxhaW5PYmplY3RfIDogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogY2FjaGVkRGVzY3JpcHRvci5nZXQsXG4gICAgICAgIHNldDogY2FjaGVkRGVzY3JpcHRvci5zZXRcbiAgICAgIH07IC8vIERlZmluZVxuXG4gICAgICBpZiAocHJveHlUcmFwKSB7XG4gICAgICAgIGlmICghUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnRhcmdldF8sIGtleSwgZGVzY3JpcHRvcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMudGFyZ2V0Xywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52YWx1ZXNfLnNldChrZXksIG5ldyBDb21wdXRlZFZhbHVlKG9wdGlvbnMpKTsgLy8gTm90aWZ5XG5cbiAgICAgIHRoaXMubm90aWZ5UHJvcGVydHlBZGRpdGlvbl8oa2V5LCB1bmRlZmluZWQpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlLZXl9IGtleVxyXG4gICAqIEBwYXJhbSB7UHJvcGVydHlEZXNjcmlwdG9yfSBkZXNjcmlwdG9yXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBwcm94eVRyYXAgd2hldGhlciBpdCdzIGNhbGxlZCBmcm9tIHByb3h5IHRyYXBcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxudWxsfSB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUgKHByb3h5VHJhcCArIG5vbi1jb25maWd1cmFibGUpLCBudWxsIHdoZW4gY2FuY2VsbGVkIGJ5IGludGVyY2VwdG9yXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVsZXRlXyA9IGZ1bmN0aW9uIGRlbGV0ZV8oa2V5LCBwcm94eVRyYXApIHtcbiAgICBpZiAocHJveHlUcmFwID09PSB2b2lkIDApIHtcbiAgICAgIHByb3h5VHJhcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE5vIHN1Y2ggcHJvcFxuICAgIGlmICghaGFzUHJvcCh0aGlzLnRhcmdldF8sIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gSW50ZXJjZXB0XG5cblxuICAgIGlmIChoYXNJbnRlcmNlcHRvcnModGhpcykpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBpbnRlcmNlcHRDaGFuZ2UodGhpcywge1xuICAgICAgICBvYmplY3Q6IHRoaXMucHJveHlfIHx8IHRoaXMudGFyZ2V0XyxcbiAgICAgICAgbmFtZToga2V5LFxuICAgICAgICB0eXBlOiBSRU1PVkVcbiAgICAgIH0pOyAvLyBDYW5jZWxsZWRcblxuICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBudWxsO1xuICAgIH0gLy8gRGVsZXRlXG5cblxuICAgIHRyeSB7XG4gICAgICB2YXIgX3RoaXMkcGVuZGluZ0tleXNfLCBfdGhpcyRwZW5kaW5nS2V5c18kZ2U7XG5cbiAgICAgIHN0YXJ0QmF0Y2goKTtcbiAgICAgIHZhciBub3RpZnkgPSBoYXNMaXN0ZW5lcnModGhpcyk7XG4gICAgICB2YXIgbm90aWZ5U3B5ID0gXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1NweUVuYWJsZWQoKTtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gdGhpcy52YWx1ZXNfLmdldChrZXkpOyAvLyBWYWx1ZSBuZWVkZWQgZm9yIHNwaWVzL2xpc3RlbmVyc1xuXG4gICAgICB2YXIgdmFsdWUgPSB1bmRlZmluZWQ7IC8vIE9wdGltaXphdGlvbjogZG9uJ3QgcHVsbCB0aGUgdmFsdWUgdW5sZXNzIHdlIHdpbGwgbmVlZCBpdFxuXG4gICAgICBpZiAoIW9ic2VydmFibGUgJiYgKG5vdGlmeSB8fCBub3RpZnlTcHkpKSB7XG4gICAgICAgIHZhciBfZ2V0RGVzY3JpcHRvcjtcblxuICAgICAgICB2YWx1ZSA9IChfZ2V0RGVzY3JpcHRvciA9IGdldERlc2NyaXB0b3IodGhpcy50YXJnZXRfLCBrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX2dldERlc2NyaXB0b3IudmFsdWU7XG4gICAgICB9IC8vIGRlbGV0ZSBwcm9wIChkbyBmaXJzdCwgbWF5IGZhaWwpXG5cblxuICAgICAgaWYgKHByb3h5VHJhcCkge1xuICAgICAgICBpZiAoIVJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGhpcy50YXJnZXRfLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy50YXJnZXRfW2tleV07XG4gICAgICB9IC8vIEFsbG93IHJlLWFubm90YXRpbmcgdGhpcyBmaWVsZFxuXG5cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFwcGxpZWRBbm5vdGF0aW9uc19ba2V5XTtcbiAgICAgIH0gLy8gQ2xlYXIgb2JzZXJ2YWJsZVxuXG5cbiAgICAgIGlmIChvYnNlcnZhYmxlKSB7XG4gICAgICAgIHRoaXMudmFsdWVzX1tcImRlbGV0ZVwiXShrZXkpOyAvLyBmb3IgY29tcHV0ZWQsIHZhbHVlIGlzIHVuZGVmaW5lZFxuXG4gICAgICAgIGlmIChvYnNlcnZhYmxlIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUgPSBvYnNlcnZhYmxlLnZhbHVlXztcbiAgICAgICAgfSAvLyBOb3RpZnk6IGF1dG9ydW4oKCkgPT4gb2JqW2tleV0pLCBzZWUgIzE3OTZcblxuXG4gICAgICAgIHByb3BhZ2F0ZUNoYW5nZWQob2JzZXJ2YWJsZSk7XG4gICAgICB9IC8vIE5vdGlmeSBcImtleXMvZW50cmllcy92YWx1ZXNcIiBvYnNlcnZlcnNcblxuXG4gICAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRDaGFuZ2VkKCk7IC8vIE5vdGlmeSBcImhhc1wiIG9ic2VydmVyc1xuICAgICAgLy8gXCJpblwiIGFzIGl0IG1heSBzdGlsbCBleGlzdCBpbiBwcm90b1xuXG4gICAgICAoX3RoaXMkcGVuZGluZ0tleXNfID0gdGhpcy5wZW5kaW5nS2V5c18pID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkcGVuZGluZ0tleXNfJGdlID0gX3RoaXMkcGVuZGluZ0tleXNfLmdldChrZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcGVuZGluZ0tleXNfJGdlLnNldChrZXkgaW4gdGhpcy50YXJnZXRfKTsgLy8gTm90aWZ5IHNwaWVzL2xpc3RlbmVyc1xuXG4gICAgICBpZiAobm90aWZ5IHx8IG5vdGlmeVNweSkge1xuICAgICAgICB2YXIgX2NoYW5nZTIgPSB7XG4gICAgICAgICAgdHlwZTogUkVNT1ZFLFxuICAgICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm9iamVjdFwiLFxuICAgICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICAgIGRlYnVnT2JqZWN0TmFtZTogdGhpcy5uYW1lXyxcbiAgICAgICAgICBvbGRWYWx1ZTogdmFsdWUsXG4gICAgICAgICAgbmFtZToga2V5XG4gICAgICAgIH07XG4gICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiICYmIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoX2NoYW5nZTIpO1xuICAgICAgICBpZiAobm90aWZ5KSBub3RpZnlMaXN0ZW5lcnModGhpcywgX2NoYW5nZTIpO1xuICAgICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiAmJiBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBlbmRCYXRjaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxyXG4gICAqIE9ic2VydmVzIHRoaXMgb2JqZWN0LiBUcmlnZ2VycyBmb3IgdGhlIGV2ZW50cyAnYWRkJywgJ3VwZGF0ZScgYW5kICdkZWxldGUnLlxyXG4gICAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L29ic2VydmVcclxuICAgKiBmb3IgY2FsbGJhY2sgZGV0YWlsc1xyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9ic2VydmVfID0gZnVuY3Rpb24gb2JzZXJ2ZV8oY2FsbGJhY2ssIGZpcmVJbW1lZGlhdGVseSkge1xuICAgIGlmICggZmlyZUltbWVkaWF0ZWx5ID09PSB0cnVlKSBkaWUoXCJgb2JzZXJ2ZWAgZG9lc24ndCBzdXBwb3J0IHRoZSBmaXJlIGltbWVkaWF0ZWx5IHByb3BlcnR5IGZvciBvYnNlcnZhYmxlIG9iamVjdHMuXCIpO1xuICAgIHJldHVybiByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICBfcHJvdG8uaW50ZXJjZXB0XyA9IGZ1bmN0aW9uIGludGVyY2VwdF8oaGFuZGxlcikge1xuICAgIHJldHVybiByZWdpc3RlckludGVyY2VwdG9yKHRoaXMsIGhhbmRsZXIpO1xuICB9O1xuXG4gIF9wcm90by5ub3RpZnlQcm9wZXJ0eUFkZGl0aW9uXyA9IGZ1bmN0aW9uIG5vdGlmeVByb3BlcnR5QWRkaXRpb25fKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXMkcGVuZGluZ0tleXNfMiwgX3RoaXMkcGVuZGluZ0tleXNfMiRnO1xuXG4gICAgdmFyIG5vdGlmeSA9IGhhc0xpc3RlbmVycyh0aGlzKTtcbiAgICB2YXIgbm90aWZ5U3B5ID0gIGlzU3B5RW5hYmxlZCgpO1xuXG4gICAgaWYgKG5vdGlmeSB8fCBub3RpZnlTcHkpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBub3RpZnkgfHwgbm90aWZ5U3B5ID8ge1xuICAgICAgICB0eXBlOiBBREQsXG4gICAgICAgIG9ic2VydmFibGVLaW5kOiBcIm9iamVjdFwiLFxuICAgICAgICBkZWJ1Z09iamVjdE5hbWU6IHRoaXMubmFtZV8sXG4gICAgICAgIG9iamVjdDogdGhpcy5wcm94eV8gfHwgdGhpcy50YXJnZXRfLFxuICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgIG5ld1ZhbHVlOiB2YWx1ZVxuICAgICAgfSA6IG51bGw7XG4gICAgICBpZiAoIG5vdGlmeVNweSkgc3B5UmVwb3J0U3RhcnQoY2hhbmdlKTtcbiAgICAgIGlmIChub3RpZnkpIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBjaGFuZ2UpO1xuICAgICAgaWYgKCBub3RpZnlTcHkpIHNweVJlcG9ydEVuZCgpO1xuICAgIH1cblxuICAgIChfdGhpcyRwZW5kaW5nS2V5c18yID0gdGhpcy5wZW5kaW5nS2V5c18pID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkcGVuZGluZ0tleXNfMiRnID0gX3RoaXMkcGVuZGluZ0tleXNfMi5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBlbmRpbmdLZXlzXzIkZy5zZXQodHJ1ZSk7IC8vIE5vdGlmeSBcImtleXMvZW50cmllcy92YWx1ZXNcIiBvYnNlcnZlcnNcblxuICAgIHRoaXMua2V5c0F0b21fLnJlcG9ydENoYW5nZWQoKTtcbiAgfTtcblxuICBfcHJvdG8ub3duS2V5c18gPSBmdW5jdGlvbiBvd25LZXlzXygpIHtcbiAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiBvd25LZXlzKHRoaXMudGFyZ2V0Xyk7XG4gIH07XG5cbiAgX3Byb3RvLmtleXNfID0gZnVuY3Rpb24ga2V5c18oKSB7XG4gICAgLy8gUmV0dXJucyBlbnVtZXJhYmxlICYmIG93biwgYnV0IHVuZm9ydHVuYXRlbHkga2V5c0F0b20gd2lsbCByZXBvcnQgb24gQU5ZIGtleSBjaGFuZ2UuXG4gICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gT2JqZWN0LmtleXMob2JqZWN0KSBhbmQgUmVmbGVjdC5vd25LZXlzKG9iamVjdCkgLSBib3RoIGFyZSBoYW5kbGVkIGJ5IG93bktleXMgdHJhcC5cbiAgICAvLyBXZSBjYW4gZWl0aGVyIG92ZXItcmVwb3J0IGluIE9iamVjdC5rZXlzKG9iamVjdCkgb3IgdW5kZXItcmVwb3J0IGluIFJlZmxlY3Qub3duS2V5cyhvYmplY3QpXG4gICAgLy8gV2UgY2hvb3NlIHRvIG92ZXItcmVwb3J0IGluIE9iamVjdC5rZXlzKG9iamVjdCksIGJlY2F1c2U6XG4gICAgLy8gLSB0eXBpY2FsbHkgaXQncyB1c2VkIHdpdGggc2ltcGxlIGRhdGEgb2JqZWN0c1xuICAgIC8vIC0gd2hlbiBzeW1ib2xpYy9ub24tZW51bWVyYWJsZSBrZXlzIGFyZSByZWxldmFudCBSZWZsZWN0Lm93bktleXMgd29ya3MgYXMgZXhwZWN0ZWRcbiAgICB0aGlzLmtleXNBdG9tXy5yZXBvcnRPYnNlcnZlZCgpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRhcmdldF8pO1xuICB9O1xuXG4gIHJldHVybiBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb247XG59KCk7XG5mdW5jdGlvbiBhc09ic2VydmFibGVPYmplY3QodGFyZ2V0LCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRuYW1lO1xuXG4gIGlmICggb3B0aW9ucyAmJiBpc09ic2VydmFibGVPYmplY3QodGFyZ2V0KSkge1xuICAgIGRpZShcIk9wdGlvbnMgY2FuJ3QgYmUgcHJvdmlkZWQgZm9yIGFscmVhZHkgb2JzZXJ2YWJsZSBvYmplY3RzLlwiKTtcbiAgfVxuXG4gIGlmIChoYXNQcm9wKHRhcmdldCwgJG1vYngpKSB7XG4gICAgaWYgKCAhKGdldEFkbWluaXN0cmF0aW9uKHRhcmdldCkgaW5zdGFuY2VvZiBPYnNlcnZhYmxlT2JqZWN0QWRtaW5pc3RyYXRpb24pKSB7XG4gICAgICBkaWUoXCJDYW5ub3QgY29udmVydCAnXCIgKyBnZXREZWJ1Z05hbWUodGFyZ2V0KSArIFwiJyBpbnRvIG9ic2VydmFibGUgb2JqZWN0OlwiICsgXCJcXG5UaGUgdGFyZ2V0IGlzIGFscmVhZHkgb2JzZXJ2YWJsZSBvZiBkaWZmZXJlbnQgdHlwZS5cIiArIFwiXFxuRXh0ZW5kaW5nIGJ1aWx0aW5zIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBpZiAoICFPYmplY3QuaXNFeHRlbnNpYmxlKHRhcmdldCkpIGRpZShcIkNhbm5vdCBtYWtlIHRoZSBkZXNpZ25hdGVkIG9iamVjdCBvYnNlcnZhYmxlOyBpdCBpcyBub3QgZXh0ZW5zaWJsZVwiKTtcbiAgdmFyIG5hbWUgPSAoX29wdGlvbnMkbmFtZSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubmFtZSkgIT0gbnVsbCA/IF9vcHRpb25zJG5hbWUgOiAgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSA/IFwiT2JzZXJ2YWJsZU9iamVjdFwiIDogdGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWUpICsgXCJAXCIgKyBnZXROZXh0SWQoKSA7XG4gIHZhciBhZG0gPSBuZXcgT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uKHRhcmdldCwgbmV3IE1hcCgpLCBTdHJpbmcobmFtZSksIGdldEFubm90YXRpb25Gcm9tT3B0aW9ucyhvcHRpb25zKSk7XG4gIGFkZEhpZGRlblByb3AodGFyZ2V0LCAkbW9ieCwgYWRtKTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbnZhciBpc09ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbiA9IC8qI19fUFVSRV9fKi9jcmVhdGVJbnN0YW5jZW9mUHJlZGljYXRlKFwiT2JzZXJ2YWJsZU9iamVjdEFkbWluaXN0cmF0aW9uXCIsIE9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbik7XG5cbmZ1bmN0aW9uIGdldENhY2hlZE9ic2VydmFibGVQcm9wRGVzY3JpcHRvcihrZXkpIHtcbiAgcmV0dXJuIGRlc2NyaXB0b3JDYWNoZVtrZXldIHx8IChkZXNjcmlwdG9yQ2FjaGVba2V5XSA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzWyRtb2J4XS5nZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXkpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzWyRtb2J4XS5zZXRPYnNlcnZhYmxlUHJvcFZhbHVlXyhrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc09ic2VydmFibGVPYmplY3QodGhpbmcpIHtcbiAgaWYgKGlzT2JqZWN0KHRoaW5nKSkge1xuICAgIHJldHVybiBpc09ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvbih0aGluZ1skbW9ieF0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVjb3JkQW5ub3RhdGlvbkFwcGxpZWQoYWRtLCBhbm5vdGF0aW9uLCBrZXkpIHtcbiAgdmFyIF9hZG0kdGFyZ2V0XyRzdG9yZWRBbjtcblxuICB7XG4gICAgYWRtLmFwcGxpZWRBbm5vdGF0aW9uc19ba2V5XSA9IGFubm90YXRpb247XG4gIH0gLy8gUmVtb3ZlIGFwcGxpZWQgZGVjb3JhdG9yIGFubm90YXRpb24gc28gd2UgZG9uJ3QgdHJ5IHRvIGFwcGx5IGl0IGFnYWluIGluIHN1YmNsYXNzIGNvbnN0cnVjdG9yXG5cblxuICAoX2FkbSR0YXJnZXRfJHN0b3JlZEFuID0gYWRtLnRhcmdldF9bc3RvcmVkQW5ub3RhdGlvbnNTeW1ib2xdKSA9PSBudWxsID8gdHJ1ZSA6IGRlbGV0ZSBfYWRtJHRhcmdldF8kc3RvcmVkQW5ba2V5XTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QW5ub3RhYmxlKGFkbSwgYW5ub3RhdGlvbiwga2V5KSB7XG4gIC8vIFZhbGlkIGFubm90YXRpb25cbiAgaWYgKCAhaXNBbm5vdGF0aW9uKGFubm90YXRpb24pKSB7XG4gICAgZGllKFwiQ2Fubm90IGFubm90YXRlICdcIiArIGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCkgKyBcIic6IEludmFsaWQgYW5ub3RhdGlvbi5cIik7XG4gIH1cbiAgLypcclxuICAvLyBDb25maWd1cmFibGUsIG5vdCBzZWFsZWQsIG5vdCBmcm96ZW5cclxuICAvLyBQb3NzaWJseSBub3QgbmVlZGVkLCBqdXN0IGEgbGl0dGxlIGJldHRlciBlcnJvciB0aGVuIHRoZSBvbmUgdGhyb3duIGJ5IGVuZ2luZS5cclxuICAvLyBDYXNlcyB3aGVyZSB0aGlzIHdvdWxkIGJlIHVzZWZ1bCB0aGUgbW9zdCAoc3ViY2xhc3MgZmllbGQgaW5pdGlhbGl6ZXIpIGFyZSBub3QgaW50ZXJjZXB0YWJsZSBieSB0aGlzLlxyXG4gIGlmIChfX0RFVl9fKSB7XHJcbiAgICAgIGNvbnN0IGNvbmZpZ3VyYWJsZSA9IGdldERlc2NyaXB0b3IoYWRtLnRhcmdldF8sIGtleSk/LmNvbmZpZ3VyYWJsZVxyXG4gICAgICBjb25zdCBmcm96ZW4gPSBPYmplY3QuaXNGcm96ZW4oYWRtLnRhcmdldF8pXHJcbiAgICAgIGNvbnN0IHNlYWxlZCA9IE9iamVjdC5pc1NlYWxlZChhZG0udGFyZ2V0XylcclxuICAgICAgaWYgKCFjb25maWd1cmFibGUgfHwgZnJvemVuIHx8IHNlYWxlZCkge1xyXG4gICAgICAgICAgY29uc3QgZmllbGROYW1lID0gYCR7YWRtLm5hbWVffS4ke2tleS50b1N0cmluZygpfWBcclxuICAgICAgICAgIGNvbnN0IHJlcXVlc3RlZEFubm90YXRpb25UeXBlID0gYW5ub3RhdGlvbi5hbm5vdGF0aW9uVHlwZV9cclxuICAgICAgICAgIGxldCBlcnJvciA9IGBDYW5ub3QgYXBwbHkgJyR7cmVxdWVzdGVkQW5ub3RhdGlvblR5cGV9JyB0byAnJHtmaWVsZE5hbWV9JzpgXHJcbiAgICAgICAgICBpZiAoZnJvemVuKSB7XHJcbiAgICAgICAgICAgICAgZXJyb3IgKz0gYFxcbk9iamVjdCBpcyBmcm96ZW4uYFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHNlYWxlZCkge1xyXG4gICAgICAgICAgICAgIGVycm9yICs9IGBcXG5PYmplY3QgaXMgc2VhbGVkLmBcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghY29uZmlndXJhYmxlKSB7XHJcbiAgICAgICAgICAgICAgZXJyb3IgKz0gYFxcbnByb3BlcnR5IGlzIG5vdCBjb25maWd1cmFibGUuYFxyXG4gICAgICAgICAgICAgIC8vIE1lbnRpb24gb25seSBpZiBjYXVzZWQgYnkgdXMgdG8gYXZvaWQgY29uZnVzaW9uXHJcbiAgICAgICAgICAgICAgaWYgKGhhc1Byb3AoYWRtLmFwcGxpZWRBbm5vdGF0aW9ucyEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgZXJyb3IgKz0gYFxcblRvIHByZXZlbnQgYWNjaWRlbnRhbCByZS1kZWZpbml0aW9uIG9mIGEgZmllbGQgYnkgYSBzdWJjbGFzcywgYFxyXG4gICAgICAgICAgICAgICAgICBlcnJvciArPSBgYWxsIGFubm90YXRlZCBmaWVsZHMgb2Ygbm9uLXBsYWluIG9iamVjdHMgKGNsYXNzZXMpIGFyZSBub3QgY29uZmlndXJhYmxlLmBcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkaWUoZXJyb3IpXHJcbiAgICAgIH1cclxuICB9XHJcbiAgKi9cbiAgLy8gTm90IGFubm90YXRlZFxuXG5cbiAgaWYgKCAhaXNPdmVycmlkZShhbm5vdGF0aW9uKSAmJiBoYXNQcm9wKGFkbS5hcHBsaWVkQW5ub3RhdGlvbnNfLCBrZXkpKSB7XG4gICAgdmFyIGZpZWxkTmFtZSA9IGFkbS5uYW1lXyArIFwiLlwiICsga2V5LnRvU3RyaW5nKCk7XG4gICAgdmFyIGN1cnJlbnRBbm5vdGF0aW9uVHlwZSA9IGFkbS5hcHBsaWVkQW5ub3RhdGlvbnNfW2tleV0uYW5ub3RhdGlvblR5cGVfO1xuICAgIHZhciByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSA9IGFubm90YXRpb24uYW5ub3RhdGlvblR5cGVfO1xuICAgIGRpZShcIkNhbm5vdCBhcHBseSAnXCIgKyByZXF1ZXN0ZWRBbm5vdGF0aW9uVHlwZSArIFwiJyB0byAnXCIgKyBmaWVsZE5hbWUgKyBcIic6XCIgKyAoXCJcXG5UaGUgZmllbGQgaXMgYWxyZWFkeSBhbm5vdGF0ZWQgd2l0aCAnXCIgKyBjdXJyZW50QW5ub3RhdGlvblR5cGUgKyBcIicuXCIpICsgXCJcXG5SZS1hbm5vdGF0aW5nIGZpZWxkcyBpcyBub3QgYWxsb3dlZC5cIiArIFwiXFxuVXNlICdvdmVycmlkZScgYW5ub3RhdGlvbiBmb3IgbWV0aG9kcyBvdmVycmlkZW4gYnkgc3ViY2xhc3MuXCIpO1xuICB9XG59XG5cbi8qKlxyXG4gKiBUaGlzIGFycmF5IGJ1ZmZlciBjb250YWlucyB0d28gbGlzdHMgb2YgcHJvcGVydGllcywgc28gdGhhdCBhbGwgYXJyYXlzXHJcbiAqIGNhbiByZWN5Y2xlIHRoZWlyIHByb3BlcnR5IGRlZmluaXRpb25zLCB3aGljaCBzaWduaWZpY2FudGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlIG9mIGNyZWF0aW5nXHJcbiAqIHByb3BlcnRpZXMgb24gdGhlIGZseS5cclxuICovXG5cbnZhciBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFID0gMDsgLy8gVHlwZXNjcmlwdCB3b3JrYXJvdW5kIHRvIG1ha2Ugc3VyZSBPYnNlcnZhYmxlQXJyYXkgZXh0ZW5kcyBBcnJheVxuXG52YXIgU3R1YkFycmF5ID0gZnVuY3Rpb24gU3R1YkFycmF5KCkge307XG5cbmZ1bmN0aW9uIGluaGVyaXQoY3RvciwgcHJvdG8pIHtcbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihjdG9yLnByb3RvdHlwZSwgcHJvdG8pO1xuICB9IGVsc2UgaWYgKGN0b3IucHJvdG90eXBlLl9fcHJvdG9fXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3Rvci5wcm90b3R5cGUuX19wcm90b19fID0gcHJvdG87XG4gIH0gZWxzZSB7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBwcm90bztcbiAgfVxufVxuXG5pbmhlcml0KFN0dWJBcnJheSwgQXJyYXkucHJvdG90eXBlKTsgLy8gV2VleCBwcm90byBmcmVlemUgcHJvdGVjdGlvbiB3YXMgaGVyZSxcbi8vIGJ1dCBpdCBpcyB1bmNsZWFyIHdoeSB0aGUgaGFjayBpcyBuZWVkIGFzIE1vYlggbmV2ZXIgY2hhbmdlZCB0aGUgcHJvdG90eXBlXG4vLyBhbnl3YXksIHNvIHJlbW92ZWQgaXQgaW4gVjZcblxudmFyIExlZ2FjeU9ic2VydmFibGVBcnJheSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N0dWJBcnJheSkge1xuICBfaW5oZXJpdHNMb29zZShMZWdhY3lPYnNlcnZhYmxlQXJyYXksIF9TdHViQXJyYXkpO1xuXG4gIGZ1bmN0aW9uIExlZ2FjeU9ic2VydmFibGVBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSwgb3duZWQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW1lID0gIFwiT2JzZXJ2YWJsZUFycmF5QFwiICsgZ2V0TmV4dElkKCkgO1xuICAgIH1cblxuICAgIGlmIChvd25lZCA9PT0gdm9pZCAwKSB7XG4gICAgICBvd25lZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIF90aGlzID0gX1N0dWJBcnJheS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgdmFyIGFkbSA9IG5ldyBPYnNlcnZhYmxlQXJyYXlBZG1pbmlzdHJhdGlvbihuYW1lLCBlbmhhbmNlciwgb3duZWQsIHRydWUpO1xuICAgIGFkbS5wcm94eV8gPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgICBhZGRIaWRkZW5GaW5hbFByb3AoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICRtb2J4LCBhZG0pO1xuXG4gICAgaWYgKGluaXRpYWxWYWx1ZXMgJiYgaW5pdGlhbFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBwcmV2ID0gYWxsb3dTdGF0ZUNoYW5nZXNTdGFydCh0cnVlKTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgICBfdGhpcy5zcGxpY2VXaXRoQXJyYXkoMCwgMCwgaW5pdGlhbFZhbHVlcyk7XG5cbiAgICAgIGFsbG93U3RhdGVDaGFuZ2VzRW5kKHByZXYpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMZWdhY3lPYnNlcnZhYmxlQXJyYXkucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgdGhpc1skbW9ieF0uYXRvbV8ucmVwb3J0T2JzZXJ2ZWQoKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcnJheXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcnJheXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkodGhpcy5zbGljZSgpLCAvL0B0cy1pZ25vcmVcbiAgICBhcnJheXMubWFwKGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gaXNPYnNlcnZhYmxlQXJyYXkoYSkgPyBhLnNsaWNlKCkgOiBhO1xuICAgIH0pKTtcbiAgfTtcblxuICBfcHJvdG9bU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgcmV0dXJuIG1ha2VJdGVyYWJsZSh7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBuZXh0SW5kZXggPCBzZWxmLmxlbmd0aCA/IHtcbiAgICAgICAgICB2YWx1ZTogc2VsZltuZXh0SW5kZXgrK10sXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoTGVnYWN5T2JzZXJ2YWJsZUFycmF5LCBbe1xuICAgIGtleTogXCJsZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzWyRtb2J4XS5nZXRBcnJheUxlbmd0aF8oKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xlbmd0aCkge1xuICAgICAgdGhpc1skbW9ieF0uc2V0QXJyYXlMZW5ndGhfKG5ld0xlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBTeW1ib2wudG9TdHJpbmdUYWcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gXCJBcnJheVwiO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMZWdhY3lPYnNlcnZhYmxlQXJyYXk7XG59KFN0dWJBcnJheSk7XG5cbk9iamVjdC5lbnRyaWVzKGFycmF5RXh0ZW5zaW9ucykuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgcHJvcCA9IF9yZWZbMF0sXG4gICAgICBmbiA9IF9yZWZbMV07XG4gIGlmIChwcm9wICE9PSBcImNvbmNhdFwiKSBhZGRIaWRkZW5Qcm9wKExlZ2FjeU9ic2VydmFibGVBcnJheS5wcm90b3R5cGUsIHByb3AsIGZuKTtcbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVBcnJheUVudHJ5RGVzY3JpcHRvcihpbmRleCkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzWyRtb2J4XS5nZXRfKGluZGV4KTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzWyRtb2J4XS5zZXRfKGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJheUJ1ZmZlckl0ZW0oaW5kZXgpIHtcbiAgZGVmaW5lUHJvcGVydHkoTGVnYWN5T2JzZXJ2YWJsZUFycmF5LnByb3RvdHlwZSwgXCJcIiArIGluZGV4LCBjcmVhdGVBcnJheUVudHJ5RGVzY3JpcHRvcihpbmRleCkpO1xufVxuXG5mdW5jdGlvbiByZXNlcnZlQXJyYXlCdWZmZXIobWF4KSB7XG4gIGlmIChtYXggPiBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFOyBpbmRleCA8IG1heCArIDEwMDsgaW5kZXgrKykge1xuICAgICAgY3JlYXRlQXJyYXlCdWZmZXJJdGVtKGluZGV4KTtcbiAgICB9XG5cbiAgICBPQlNFUlZBQkxFX0FSUkFZX0JVRkZFUl9TSVpFID0gbWF4O1xuICB9XG59XG5yZXNlcnZlQXJyYXlCdWZmZXIoMTAwMCk7XG5mdW5jdGlvbiBjcmVhdGVMZWdhY3lBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IExlZ2FjeU9ic2VydmFibGVBcnJheShpbml0aWFsVmFsdWVzLCBlbmhhbmNlciwgbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldEF0b20odGhpbmcsIHByb3BlcnR5KSB7XG4gIGlmICh0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiYgdGhpbmcgIT09IG51bGwpIHtcbiAgICBpZiAoaXNPYnNlcnZhYmxlQXJyYXkodGhpbmcpKSB7XG4gICAgICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCkgZGllKDIzKTtcbiAgICAgIHJldHVybiB0aGluZ1skbW9ieF0uYXRvbV87XG4gICAgfVxuXG4gICAgaWYgKGlzT2JzZXJ2YWJsZVNldCh0aGluZykpIHtcbiAgICAgIHJldHVybiB0aGluZ1skbW9ieF07XG4gICAgfVxuXG4gICAgaWYgKGlzT2JzZXJ2YWJsZU1hcCh0aGluZykpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpbmcua2V5c0F0b21fO1xuICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGluZy5kYXRhXy5nZXQocHJvcGVydHkpIHx8IHRoaW5nLmhhc01hcF8uZ2V0KHByb3BlcnR5KTtcbiAgICAgIGlmICghb2JzZXJ2YWJsZSkgZGllKDI1LCBwcm9wZXJ0eSwgZ2V0RGVidWdOYW1lKHRoaW5nKSk7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYnNlcnZhYmxlT2JqZWN0KHRoaW5nKSkge1xuICAgICAgaWYgKCFwcm9wZXJ0eSkgcmV0dXJuIGRpZSgyNik7XG5cbiAgICAgIHZhciBfb2JzZXJ2YWJsZSA9IHRoaW5nWyRtb2J4XS52YWx1ZXNfLmdldChwcm9wZXJ0eSk7XG5cbiAgICAgIGlmICghX29ic2VydmFibGUpIGRpZSgyNywgcHJvcGVydHksIGdldERlYnVnTmFtZSh0aGluZykpO1xuICAgICAgcmV0dXJuIF9vYnNlcnZhYmxlO1xuICAgIH1cblxuICAgIGlmIChpc0F0b20odGhpbmcpIHx8IGlzQ29tcHV0ZWRWYWx1ZSh0aGluZykgfHwgaXNSZWFjdGlvbih0aGluZykpIHtcbiAgICAgIHJldHVybiB0aGluZztcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGluZykpIHtcbiAgICBpZiAoaXNSZWFjdGlvbih0aGluZ1skbW9ieF0pKSB7XG4gICAgICAvLyBkaXNwb3NlciBmdW5jdGlvblxuICAgICAgcmV0dXJuIHRoaW5nWyRtb2J4XTtcbiAgICB9XG4gIH1cblxuICBkaWUoMjgpO1xufVxuZnVuY3Rpb24gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcsIHByb3BlcnR5KSB7XG4gIGlmICghdGhpbmcpIGRpZSgyOSk7XG4gIGlmIChwcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0QWRtaW5pc3RyYXRpb24oZ2V0QXRvbSh0aGluZywgcHJvcGVydHkpKTtcbiAgaWYgKGlzQXRvbSh0aGluZykgfHwgaXNDb21wdXRlZFZhbHVlKHRoaW5nKSB8fCBpc1JlYWN0aW9uKHRoaW5nKSkgcmV0dXJuIHRoaW5nO1xuICBpZiAoaXNPYnNlcnZhYmxlTWFwKHRoaW5nKSB8fCBpc09ic2VydmFibGVTZXQodGhpbmcpKSByZXR1cm4gdGhpbmc7XG4gIGlmICh0aGluZ1skbW9ieF0pIHJldHVybiB0aGluZ1skbW9ieF07XG4gIGRpZSgyNCwgdGhpbmcpO1xufVxuZnVuY3Rpb24gZ2V0RGVidWdOYW1lKHRoaW5nLCBwcm9wZXJ0eSkge1xuICB2YXIgbmFtZWQ7XG5cbiAgaWYgKHByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBuYW1lZCA9IGdldEF0b20odGhpbmcsIHByb3BlcnR5KTtcbiAgfSBlbHNlIGlmIChpc0FjdGlvbih0aGluZykpIHtcbiAgICByZXR1cm4gdGhpbmcubmFtZTtcbiAgfSBlbHNlIGlmIChpc09ic2VydmFibGVPYmplY3QodGhpbmcpIHx8IGlzT2JzZXJ2YWJsZU1hcCh0aGluZykgfHwgaXNPYnNlcnZhYmxlU2V0KHRoaW5nKSkge1xuICAgIG5hbWVkID0gZ2V0QWRtaW5pc3RyYXRpb24odGhpbmcpO1xuICB9IGVsc2Uge1xuICAgIC8vIHZhbGlkIGZvciBhcnJheXMgYXMgd2VsbFxuICAgIG5hbWVkID0gZ2V0QXRvbSh0aGluZyk7XG4gIH1cblxuICByZXR1cm4gbmFtZWQubmFtZV87XG59XG5cbnZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvdHlwZS50b1N0cmluZztcbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiLCBkZXB0aCkge1xuICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgIGRlcHRoID0gLTE7XG4gIH1cblxuICByZXR1cm4gZXEoYSwgYiwgZGVwdGgpO1xufSAvLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvYmxvYi81YzIzN2E3YzY4MmZiNjhmZDUzNzgyMDNmMGJmMjJkY2UxNjI0ODU0L3VuZGVyc2NvcmUuanMjTDExODYtTDEyODlcbi8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG5cbmZ1bmN0aW9uIGVxKGEsIGIsIGRlcHRoLCBhU3RhY2ssIGJTdGFjaykge1xuICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiOyAvLyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgb25seSBlcXVhbCB0byBpdHNlbGYgKHN0cmljdCBjb21wYXJpc29uKS5cblxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlOyAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuXG4gIGlmIChhICE9PSBhKSByZXR1cm4gYiAhPT0gYjsgLy8gRXhoYXVzdCBwcmltaXRpdmUgY2hlY2tzXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgYTtcbiAgaWYgKCFpc0Z1bmN0aW9uKHR5cGUpICYmIHR5cGUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGIgIT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlOyAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuXG4gIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICBjYXNlIFwiW29iamVjdCBSZWdFeHBdXCI6IC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG5cbiAgICBjYXNlIFwiW29iamVjdCBTdHJpbmddXCI6XG4gICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgcmV0dXJuIFwiXCIgKyBhID09PSBcIlwiICsgYjtcblxuICAgIGNhc2UgXCJbb2JqZWN0IE51bWJlcl1cIjpcbiAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAvLyBPYmplY3QoTmFOKSBpcyBlcXVpdmFsZW50IHRvIE5hTi5cbiAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7IC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG5cbiAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG5cbiAgICBjYXNlIFwiW29iamVjdCBEYXRlXVwiOlxuICAgIGNhc2UgXCJbb2JqZWN0IEJvb2xlYW5dXCI6XG4gICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICByZXR1cm4gK2EgPT09ICtiO1xuXG4gICAgY2FzZSBcIltvYmplY3QgU3ltYm9sXVwiOlxuICAgICAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLnZhbHVlT2YuY2FsbChhKSA9PT0gU3ltYm9sLnZhbHVlT2YuY2FsbChiKTtcblxuICAgIGNhc2UgXCJbb2JqZWN0IE1hcF1cIjpcbiAgICBjYXNlIFwiW29iamVjdCBTZXRdXCI6XG4gICAgICAvLyBNYXBzIGFuZCBTZXRzIGFyZSB1bndyYXBwZWQgdG8gYXJyYXlzIG9mIGVudHJ5LXBhaXJzLCBhZGRpbmcgYW4gaW5jaWRlbnRhbCBsZXZlbC5cbiAgICAgIC8vIEhpZGUgdGhpcyBleHRyYSBsZXZlbCBieSBpbmNyZWFzaW5nIHRoZSBkZXB0aC5cbiAgICAgIGlmIChkZXB0aCA+PSAwKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9IC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuXG5cbiAgYSA9IHVud3JhcChhKTtcbiAgYiA9IHVud3JhcChiKTtcbiAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuXG4gIGlmICghYXJlQXJyYXlzKSB7XG4gICAgaWYgKHR5cGVvZiBhICE9IFwib2JqZWN0XCIgfHwgdHlwZW9mIGIgIT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlOyAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuXG4gICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvcixcbiAgICAgICAgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKGlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiYgaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcikgJiYgXCJjb25zdHJ1Y3RvclwiIGluIGEgJiYgXCJjb25zdHJ1Y3RvclwiIGluIGIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGVwdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoZGVwdGggPCAwKSB7XG4gICAgZGVwdGggPSAtMTtcbiAgfSAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cblxuXG4gIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gIH0gLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuXG5cbiAgYVN0YWNrLnB1c2goYSk7XG4gIGJTdGFjay5wdXNoKGIpOyAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cblxuICBpZiAoYXJlQXJyYXlzKSB7XG4gICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTsgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgZGVwdGggLSAxLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICB2YXIga2V5O1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoOyAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG5cbiAgICBpZiAoT2JqZWN0LmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XG4gICAgICBpZiAoIShoYXNQcm9wKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGRlcHRoIC0gMSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cblxuXG4gIGFTdGFjay5wb3AoKTtcbiAgYlN0YWNrLnBvcCgpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdW53cmFwKGEpIHtcbiAgaWYgKGlzT2JzZXJ2YWJsZUFycmF5KGEpKSByZXR1cm4gYS5zbGljZSgpO1xuICBpZiAoaXNFUzZNYXAoYSkgfHwgaXNPYnNlcnZhYmxlTWFwKGEpKSByZXR1cm4gQXJyYXkuZnJvbShhLmVudHJpZXMoKSk7XG4gIGlmIChpc0VTNlNldChhKSB8fCBpc09ic2VydmFibGVTZXQoYSkpIHJldHVybiBBcnJheS5mcm9tKGEuZW50cmllcygpKTtcbiAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIG1ha2VJdGVyYWJsZShpdGVyYXRvcikge1xuICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZ2V0U2VsZjtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxmKCkge1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gaXNBbm5vdGF0aW9uKHRoaW5nKSB7XG4gIHJldHVybiAoLy8gQ2FuIGJlIGZ1bmN0aW9uXG4gICAgdGhpbmcgaW5zdGFuY2VvZiBPYmplY3QgJiYgdHlwZW9mIHRoaW5nLmFubm90YXRpb25UeXBlXyA9PT0gXCJzdHJpbmdcIiAmJiBpc0Z1bmN0aW9uKHRoaW5nLm1ha2VfKSAmJiBpc0Z1bmN0aW9uKHRoaW5nLmV4dGVuZF8pXG4gICk7XG59XG5cbi8qKlxyXG4gKiAoYykgTWljaGVsIFdlc3RzdHJhdGUgMjAxNSAtIDIwMjBcclxuICogTUlUIExpY2Vuc2VkXHJcbiAqXHJcbiAqIFdlbGNvbWUgdG8gdGhlIG1vYnggc291cmNlcyEgVG8gZ2V0IGFuIGdsb2JhbCBvdmVydmlldyBvZiBob3cgTW9iWCBpbnRlcm5hbGx5IHdvcmtzLFxyXG4gKiB0aGlzIGlzIGEgZ29vZCBwbGFjZSB0byBzdGFydDpcclxuICogaHR0cHM6Ly9tZWRpdW0uY29tL0Btd2VzdHN0cmF0ZS9iZWNvbWluZy1mdWxseS1yZWFjdGl2ZS1hbi1pbi1kZXB0aC1leHBsYW5hdGlvbi1vZi1tb2JzZXJ2YWJsZS01NTk5NTI2MmEyNTQjLnh2Ymg2cWQ3NFxyXG4gKlxyXG4gKiBTb3VyY2UgZm9sZGVyczpcclxuICogPT09PT09PT09PT09PT09XHJcbiAqXHJcbiAqIC0gYXBpLyAgICAgTW9zdCBvZiB0aGUgcHVibGljIHN0YXRpYyBtZXRob2RzIGV4cG9zZWQgYnkgdGhlIG1vZHVsZSBjYW4gYmUgZm91bmQgaGVyZS5cclxuICogLSBjb3JlLyAgICBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgTW9iWCBhbGdvcml0aG07IGF0b21zLCBkZXJpdmF0aW9ucywgcmVhY3Rpb25zLCBkZXBlbmRlbmN5IHRyZWVzLCBvcHRpbWl6YXRpb25zLiBDb29sIHN0dWZmIGNhbiBiZSBmb3VuZCBoZXJlLlxyXG4gKiAtIHR5cGVzLyAgIEFsbCB0aGUgbWFnaWMgdGhhdCBpcyBuZWVkIHRvIGhhdmUgb2JzZXJ2YWJsZSBvYmplY3RzLCBhcnJheXMgYW5kIHZhbHVlcyBpcyBpbiB0aGlzIGZvbGRlci4gSW5jbHVkaW5nIHRoZSBtb2RpZmllcnMgbGlrZSBgYXNGbGF0YC5cclxuICogLSB1dGlscy8gICBVdGlsaXR5IHN0dWZmLlxyXG4gKlxyXG4gKi9cbltcIlN5bWJvbFwiLCBcIk1hcFwiLCBcIlNldFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gIHZhciBnID0gZ2V0R2xvYmFsKCk7XG5cbiAgaWYgKHR5cGVvZiBnW21dID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZGllKFwiTW9iWCByZXF1aXJlcyBnbG9iYWwgJ1wiICsgbSArIFwiJyB0byBiZSBhdmFpbGFibGUgb3IgcG9seWZpbGxlZFwiKTtcbiAgfVxufSk7XG5cbmlmICh0eXBlb2YgX19NT0JYX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09IFwib2JqZWN0XCIpIHtcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5keWtvZy9tb2J4LWRldnRvb2xzL1xuICBfX01PQlhfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3RNb2J4KHtcbiAgICBzcHk6IHNweSxcbiAgICBleHRyYXM6IHtcbiAgICAgIGdldERlYnVnTmFtZTogZ2V0RGVidWdOYW1lXG4gICAgfSxcbiAgICAkbW9ieDogJG1vYnhcbiAgfSk7XG59XG5cbmV4cG9ydHMuJG1vYnggPSAkbW9ieDtcbmV4cG9ydHMuRmxvd0NhbmNlbGxhdGlvbkVycm9yID0gRmxvd0NhbmNlbGxhdGlvbkVycm9yO1xuZXhwb3J0cy5PYnNlcnZhYmxlTWFwID0gT2JzZXJ2YWJsZU1hcDtcbmV4cG9ydHMuT2JzZXJ2YWJsZVNldCA9IE9ic2VydmFibGVTZXQ7XG5leHBvcnRzLlJlYWN0aW9uID0gUmVhY3Rpb247XG5leHBvcnRzLl9hbGxvd1N0YXRlQ2hhbmdlcyA9IGFsbG93U3RhdGVDaGFuZ2VzO1xuZXhwb3J0cy5fYWxsb3dTdGF0ZUNoYW5nZXNJbnNpZGVDb21wdXRlZCA9IHJ1bkluQWN0aW9uO1xuZXhwb3J0cy5fYWxsb3dTdGF0ZVJlYWRzRW5kID0gYWxsb3dTdGF0ZVJlYWRzRW5kO1xuZXhwb3J0cy5fYWxsb3dTdGF0ZVJlYWRzU3RhcnQgPSBhbGxvd1N0YXRlUmVhZHNTdGFydDtcbmV4cG9ydHMuX2F1dG9BY3Rpb24gPSBhdXRvQWN0aW9uO1xuZXhwb3J0cy5fZW5kQWN0aW9uID0gX2VuZEFjdGlvbjtcbmV4cG9ydHMuX2dldEFkbWluaXN0cmF0aW9uID0gZ2V0QWRtaW5pc3RyYXRpb247XG5leHBvcnRzLl9nZXRHbG9iYWxTdGF0ZSA9IGdldEdsb2JhbFN0YXRlO1xuZXhwb3J0cy5faW50ZXJjZXB0UmVhZHMgPSBpbnRlcmNlcHRSZWFkcztcbmV4cG9ydHMuX2lzQ29tcHV0aW5nRGVyaXZhdGlvbiA9IGlzQ29tcHV0aW5nRGVyaXZhdGlvbjtcbmV4cG9ydHMuX3Jlc2V0R2xvYmFsU3RhdGUgPSByZXNldEdsb2JhbFN0YXRlO1xuZXhwb3J0cy5fc3RhcnRBY3Rpb24gPSBfc3RhcnRBY3Rpb247XG5leHBvcnRzLmFjdGlvbiA9IGFjdGlvbjtcbmV4cG9ydHMuYXV0b3J1biA9IGF1dG9ydW47XG5leHBvcnRzLmNvbXBhcmVyID0gY29tcGFyZXI7XG5leHBvcnRzLmNvbXB1dGVkID0gY29tcHV0ZWQ7XG5leHBvcnRzLmNvbmZpZ3VyZSA9IGNvbmZpZ3VyZTtcbmV4cG9ydHMuY3JlYXRlQXRvbSA9IGNyZWF0ZUF0b207XG5leHBvcnRzLmRlZmluZVByb3BlcnR5ID0gYXBpRGVmaW5lUHJvcGVydHk7XG5leHBvcnRzLmVudHJpZXMgPSBlbnRyaWVzO1xuZXhwb3J0cy5leHRlbmRPYnNlcnZhYmxlID0gZXh0ZW5kT2JzZXJ2YWJsZTtcbmV4cG9ydHMuZmxvdyA9IGZsb3c7XG5leHBvcnRzLmZsb3dSZXN1bHQgPSBmbG93UmVzdWx0O1xuZXhwb3J0cy5nZXQgPSBnZXQ7XG5leHBvcnRzLmdldEF0b20gPSBnZXRBdG9tO1xuZXhwb3J0cy5nZXREZWJ1Z05hbWUgPSBnZXREZWJ1Z05hbWU7XG5leHBvcnRzLmdldERlcGVuZGVuY3lUcmVlID0gZ2V0RGVwZW5kZW5jeVRyZWU7XG5leHBvcnRzLmdldE9ic2VydmVyVHJlZSA9IGdldE9ic2VydmVyVHJlZTtcbmV4cG9ydHMuaGFzID0gaGFzO1xuZXhwb3J0cy5pbnRlcmNlcHQgPSBpbnRlcmNlcHQ7XG5leHBvcnRzLmlzQWN0aW9uID0gaXNBY3Rpb247XG5leHBvcnRzLmlzQm94ZWRPYnNlcnZhYmxlID0gaXNPYnNlcnZhYmxlVmFsdWU7XG5leHBvcnRzLmlzQ29tcHV0ZWQgPSBpc0NvbXB1dGVkO1xuZXhwb3J0cy5pc0NvbXB1dGVkUHJvcCA9IGlzQ29tcHV0ZWRQcm9wO1xuZXhwb3J0cy5pc0Zsb3cgPSBpc0Zsb3c7XG5leHBvcnRzLmlzRmxvd0NhbmNlbGxhdGlvbkVycm9yID0gaXNGbG93Q2FuY2VsbGF0aW9uRXJyb3I7XG5leHBvcnRzLmlzT2JzZXJ2YWJsZSA9IGlzT2JzZXJ2YWJsZTtcbmV4cG9ydHMuaXNPYnNlcnZhYmxlQXJyYXkgPSBpc09ic2VydmFibGVBcnJheTtcbmV4cG9ydHMuaXNPYnNlcnZhYmxlTWFwID0gaXNPYnNlcnZhYmxlTWFwO1xuZXhwb3J0cy5pc09ic2VydmFibGVPYmplY3QgPSBpc09ic2VydmFibGVPYmplY3Q7XG5leHBvcnRzLmlzT2JzZXJ2YWJsZVByb3AgPSBpc09ic2VydmFibGVQcm9wO1xuZXhwb3J0cy5pc09ic2VydmFibGVTZXQgPSBpc09ic2VydmFibGVTZXQ7XG5leHBvcnRzLmtleXMgPSBrZXlzO1xuZXhwb3J0cy5tYWtlQXV0b09ic2VydmFibGUgPSBtYWtlQXV0b09ic2VydmFibGU7XG5leHBvcnRzLm1ha2VPYnNlcnZhYmxlID0gbWFrZU9ic2VydmFibGU7XG5leHBvcnRzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlO1xuZXhwb3J0cy5vYnNlcnZlID0gb2JzZXJ2ZTtcbmV4cG9ydHMub25CZWNvbWVPYnNlcnZlZCA9IG9uQmVjb21lT2JzZXJ2ZWQ7XG5leHBvcnRzLm9uQmVjb21lVW5vYnNlcnZlZCA9IG9uQmVjb21lVW5vYnNlcnZlZDtcbmV4cG9ydHMub25SZWFjdGlvbkVycm9yID0gb25SZWFjdGlvbkVycm9yO1xuZXhwb3J0cy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuZXhwb3J0cy5vd25LZXlzID0gYXBpT3duS2V5cztcbmV4cG9ydHMucmVhY3Rpb24gPSByZWFjdGlvbjtcbmV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuZXhwb3J0cy5ydW5JbkFjdGlvbiA9IHJ1bkluQWN0aW9uO1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLnNweSA9IHNweTtcbmV4cG9ydHMudG9KUyA9IHRvSlM7XG5leHBvcnRzLnRyYWNlID0gdHJhY2U7XG5leHBvcnRzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG5leHBvcnRzLnVudHJhY2tlZCA9IHVudHJhY2tlZDtcbmV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuZXhwb3J0cy53aGVuID0gd2hlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vYnguY2pzLmRldmVsb3BtZW50LmpzLm1hcFxuIiwiZnVuY3Rpb24gdCh0KXtmb3IodmFyIG49YXJndW1lbnRzLmxlbmd0aCxpPW5ldyBBcnJheShuPjE/bi0xOjApLHI9MTtyPG47cisrKWlbci0xXT1hcmd1bWVudHNbcl07dGhyb3cgbmV3IEVycm9yKFwibnVtYmVyXCI9PXR5cGVvZiB0P1wiW01vYlhdIG1pbmlmaWVkIGVycm9yIG5yOiBcIit0KyhpLmxlbmd0aD9cIiBcIitpLm1hcChTdHJpbmcpLmpvaW4oXCIsXCIpOlwiXCIpK1wiLiBGaW5kIHRoZSBmdWxsIGVycm9yIGF0OiBodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngvYmxvYi9tYWluL3BhY2thZ2VzL21vYngvc3JjL2Vycm9ycy50c1wiOlwiW01vYlhdIFwiK3QpfWZ1bmN0aW9uIG4oKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOlwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6eG59ZnVuY3Rpb24gaSgpe1ZufHx0KFwiUHJveHkgbm90IGF2YWlsYWJsZVwiKX1mdW5jdGlvbiByKHQpe3ZhciBuPSExO3JldHVybiBmdW5jdGlvbigpe2lmKCFuKXJldHVybiBuPSEwLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX1mdW5jdGlvbiBlKHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHR9ZnVuY3Rpb24gbyh0KXtzd2l0Y2godHlwZW9mIHQpe2Nhc2VcInN0cmluZ1wiOmNhc2VcInN5bWJvbFwiOmNhc2VcIm51bWJlclwiOnJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIHUodCl7cmV0dXJuIG51bGwhPT10JiZcIm9iamVjdFwiPT10eXBlb2YgdH1mdW5jdGlvbiBzKHQpe3ZhciBuO2lmKCF1KHQpKXJldHVybiExO3ZhciBpPU9iamVjdC5nZXRQcm90b3R5cGVPZih0KTtyZXR1cm4gbnVsbD09aXx8KG51bGw9PShuPWkuY29uc3RydWN0b3IpP3ZvaWQgMDpuLnRvU3RyaW5nKCkpPT09Tm59ZnVuY3Rpb24gZih0KXt2YXIgbj1udWxsPT10P3ZvaWQgMDp0LmNvbnN0cnVjdG9yO3JldHVybiEhbiYmKFwiR2VuZXJhdG9yRnVuY3Rpb25cIj09PW4ubmFtZXx8XCJHZW5lcmF0b3JGdW5jdGlvblwiPT09bi5kaXNwbGF5TmFtZSl9ZnVuY3Rpb24gYSh0LG4saSl7Z24odCxuLHtlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx2YWx1ZTppfSl9ZnVuY3Rpb24gYyh0LG4saSl7Z24odCxuLHtlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiExLGNvbmZpZ3VyYWJsZTohMCx2YWx1ZTppfSl9ZnVuY3Rpb24gaCh0LG4pe3ZhciBpPVwiaXNNb2JYXCIrdDtyZXR1cm4gbi5wcm90b3R5cGVbaV09ITAsZnVuY3Rpb24odCl7cmV0dXJuIHUodCkmJiEwPT09dFtpXX19ZnVuY3Rpb24gdih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIE1hcH1mdW5jdGlvbiBsKHQpe3JldHVybiB0IGluc3RhbmNlb2YgU2V0fWZ1bmN0aW9uIGQodCl7cmV0dXJuIG51bGw9PT10P251bGw6XCJvYmplY3RcIj09dHlwZW9mIHQ/XCJcIit0OnR9ZnVuY3Rpb24gYih0LG4pe3JldHVybiBfbi5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbil9ZnVuY3Rpb24gcCh0LG4pe2Zvcih2YXIgaT0wO2k8bi5sZW5ndGg7aSsrKXt2YXIgcj1uW2ldO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLmtleSxyKX19ZnVuY3Rpb24geSh0LG4saSl7cmV0dXJuIG4mJnAodC5wcm90b3R5cGUsbiksaSYmcCh0LGkpLHR9ZnVuY3Rpb24gbSgpe3JldHVybihtPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspe3ZhciBpPWFyZ3VtZW50c1tuXTtmb3IodmFyIHIgaW4gaSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSxyKSYmKHRbcl09aVtyXSl9cmV0dXJuIHR9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZnVuY3Rpb24gdyh0LG4pe3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUobi5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXQsdC5fX3Byb3RvX189bn1mdW5jdGlvbiBqKHQpe2lmKHZvaWQgMD09PXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiB0fWZ1bmN0aW9uIHgodCxuKXsobnVsbD09bnx8bj50Lmxlbmd0aCkmJihuPXQubGVuZ3RoKTtmb3IodmFyIGk9MCxyPW5ldyBBcnJheShuKTtpPG47aSsrKXJbaV09dFtpXTtyZXR1cm4gcn1mdW5jdGlvbiBPKHQsbil7dmFyIGk7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFN5bWJvbHx8bnVsbD09dFtTeW1ib2wuaXRlcmF0b3JdKXtpZihBcnJheS5pc0FycmF5KHQpfHwoaT1mdW5jdGlvbih0KXtpZih0KXtpZihcInN0cmluZ1wiPT10eXBlb2YgdClyZXR1cm4geCh0LHZvaWQgMCk7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLnNsaWNlKDgsLTEpO3JldHVyblwiT2JqZWN0XCI9PT1uJiZ0LmNvbnN0cnVjdG9yJiYobj10LmNvbnN0cnVjdG9yLm5hbWUpLFwiTWFwXCI9PT1ufHxcIlNldFwiPT09bj9BcnJheS5mcm9tKHQpOlwiQXJndW1lbnRzXCI9PT1ufHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKT94KHQsdm9pZCAwKTp2b2lkIDB9fSh0KSl8fG4mJnQmJlwibnVtYmVyXCI9PXR5cGVvZiB0Lmxlbmd0aCl7aSYmKHQ9aSk7dmFyIHI9MDtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gcj49dC5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOnRbcisrXX19fXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX1yZXR1cm4oaT10W1N5bWJvbC5pdGVyYXRvcl0oKSkubmV4dC5iaW5kKGkpfWZ1bmN0aW9uIEEodCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oKGZ1bmN0aW9uKG4saSl7ZyhuLGksdCl9KSx0KX1mdW5jdGlvbiBnKHQsbixpKXtiKHQsQ24pfHxhKHQsQ24sbSh7fSx0W0NuXSkpLGZ1bmN0aW9uKHQpe3JldHVyblwib3ZlcnJpZGVcIj09PXQudH0oaSl8fCh0W0NuXVtuXT1pKX1mdW5jdGlvbiBfKHQsbixpKXt2b2lkIDA9PT1uJiYobj1Sbiksdm9pZCAwPT09aSYmKGk9Um4pO3ZhciByPW5ldyBMbih0KTtyZXR1cm4gbiE9PVJuJiZTdChyLG4pLGkhPT1SbiYmTXQocixpKSxyfWZ1bmN0aW9uIFModCxuLGkpe3JldHVybiBJdCh0KT90OkFycmF5LmlzQXJyYXkodCk/JG4uYXJyYXkodCx7bmFtZTppfSk6cyh0KT8kbi5vYmplY3QodCx2b2lkIDAse25hbWU6aX0pOnYodCk/JG4ubWFwKHQse25hbWU6aX0pOmwodCk/JG4uc2V0KHQse25hbWU6aX0pOlwiZnVuY3Rpb25cIiE9dHlwZW9mIHR8fEF0KHQpfHxDdCh0KT90OmYodCk/UmkodCk6X2koaSx0KX1mdW5jdGlvbiBNKHQpe3JldHVybiB0fWZ1bmN0aW9uIFYodCxuKXtyZXR1cm57dDp0LGk6bixvOk4sdTpSfX1mdW5jdGlvbiBOKHQsbixpLHIpe3ZhciBlO2lmKG51bGw9PShlPXRoaXMuaSk/dm9pZCAwOmUuYm91bmQpcmV0dXJuIG51bGw9PT10aGlzLnUodCxuLGksITEpPzA6MTtpZihyPT09dC5zKXJldHVybiBudWxsPT09dGhpcy51KHQsbixpLCExKT8wOjI7aWYoQXQoaS52YWx1ZSkpcmV0dXJuIDE7dmFyIG89ayh0LHRoaXMsbixpLCExKTtyZXR1cm4gZ24ocixuLG8pLDJ9ZnVuY3Rpb24gUih0LG4saSxyKXt2YXIgZT1rKHQsdGhpcyxuLGkpO3JldHVybiB0LmgobixlLHIpfWZ1bmN0aW9uIGsodCxuLGkscixlKXt2YXIgbyx1LHMsZixhO3ZvaWQgMD09PWUmJihlPXBpLnNhZmVEZXNjcmlwdG9ycyk7dmFyIGMsaD1yLnZhbHVlO3JldHVybihudWxsPT0obz1uLmkpP3ZvaWQgMDpvLmJvdW5kKSYmKGg9aC5iaW5kKG51bGwhPShjPXQudik/Yzp0LnMpKSx7dmFsdWU6eihudWxsIT0odT1udWxsPT0ocz1uLmkpP3ZvaWQgMDpzLm5hbWUpP3U6aS50b1N0cmluZygpLGgsbnVsbCE9KGY9bnVsbD09KGE9bi5pKT92b2lkIDA6YS5hdXRvQWN0aW9uKSYmZiksY29uZmlndXJhYmxlOiFlfHx0LmwsZW51bWVyYWJsZTohMSx3cml0YWJsZTohZX19ZnVuY3Rpb24gRSh0LG4pe3JldHVybnt0OnQsaTpuLG86VCx1OkN9fWZ1bmN0aW9uIFQodCxuLGkscil7dmFyIGU7aWYocj09PXQucylyZXR1cm4gbnVsbD09PXRoaXMudSh0LG4saSwhMSk/MDoyO2lmKChudWxsPT0oZT10aGlzLmkpP3ZvaWQgMDplLmJvdW5kKSYmIUN0KHQuc1tuXSkmJm51bGw9PT10aGlzLnUodCxuLGksITEpKXJldHVybiAwO2lmKEN0KGkudmFsdWUpKXJldHVybiAxO3ZhciBvPUsodCwwLDAsaSwhMSwhMSk7cmV0dXJuIGduKHIsbixvKSwyfWZ1bmN0aW9uIEModCxuLGkscil7dmFyIGUsbz1LKHQsMCwwLGksbnVsbD09KGU9dGhpcy5pKT92b2lkIDA6ZS5ib3VuZCk7cmV0dXJuIHQuaChuLG8scil9ZnVuY3Rpb24gSyh0LG4saSxyLGUsbyl7dm9pZCAwPT09byYmKG89cGkuc2FmZURlc2NyaXB0b3JzKTt2YXIgdSxzPXIudmFsdWU7cmV0dXJuIGUmJihzPXMuYmluZChudWxsIT0odT10LnYpP3U6dC5zKSkse3ZhbHVlOlJpKHMpLGNvbmZpZ3VyYWJsZTohb3x8dC5sLGVudW1lcmFibGU6ITEsd3JpdGFibGU6IW99fWZ1bmN0aW9uIEwodCxuKXtyZXR1cm57dDp0LGk6bixvOkksdTpQfX1mdW5jdGlvbiBJKHQsbixpKXtyZXR1cm4gbnVsbD09PXRoaXMudSh0LG4saSwhMSk/MDoxfWZ1bmN0aW9uIFAodCxuLGkscil7cmV0dXJuIHQucChuLG0oe30sdGhpcy5pLHtnZXQ6aS5nZXQsc2V0Omkuc2V0fSkscil9ZnVuY3Rpb24gRCh0LG4pe3JldHVybnt0OnQsaTpuLG86Qix1OnF9fWZ1bmN0aW9uIEIodCxuLGkpe3JldHVybiBudWxsPT09dGhpcy51KHQsbixpLCExKT8wOjF9ZnVuY3Rpb24gcSh0LG4saSxyKXt2YXIgZSxvO3JldHVybiB0Lm0obixpLnZhbHVlLG51bGwhPShlPW51bGw9PShvPXRoaXMuaSk/dm9pZCAwOm8uZW5oYW5jZXIpP2U6UyxyKX1mdW5jdGlvbiBHKHQpe3JldHVybnt0OlwidHJ1ZVwiLGk6dCxvOlgsdTpXfX1mdW5jdGlvbiBYKHQsbixpLHIpe3ZhciBlLG8sdSxzO2lmKGkuZ2V0KXJldHVybiBRbi5vKHQsbixpLHIpO2lmKGkuc2V0KXt2YXIgYT16KG4udG9TdHJpbmcoKSxpLnNldCk7cmV0dXJuIHI9PT10LnM/bnVsbD09PXQuaChuLHtjb25maWd1cmFibGU6IXBpLnNhZmVEZXNjcmlwdG9yc3x8dC5sLHNldDphfSk/MDoyOihnbihyLG4se2NvbmZpZ3VyYWJsZTohMCxzZXQ6YX0pLDIpfWlmKHIhPT10LnMmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGkudmFsdWUpcmV0dXJuIGYoaS52YWx1ZSk/KChudWxsPT0ocz10aGlzLmkpP3ZvaWQgMDpzLmF1dG9CaW5kKT9SaS5ib3VuZDpSaSkubyh0LG4saSxyKTooKG51bGw9PSh1PXRoaXMuaSk/dm9pZCAwOnUuYXV0b0JpbmQpP19pLmJvdW5kOl9pKS5vKHQsbixpLHIpO3ZhciBjLGg9ITE9PT0obnVsbD09KGU9dGhpcy5pKT92b2lkIDA6ZS5kZWVwKT8kbi5yZWY6JG47cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgaS52YWx1ZSYmKG51bGw9PShvPXRoaXMuaSk/dm9pZCAwOm8uYXV0b0JpbmQpJiYoaS52YWx1ZT1pLnZhbHVlLmJpbmQobnVsbCE9KGM9dC52KT9jOnQucykpLGgubyh0LG4saSxyKX1mdW5jdGlvbiBXKHQsbixpLHIpe3ZhciBlLG8sdTtyZXR1cm4gaS5nZXQ/UW4udSh0LG4saSxyKTppLnNldD90Lmgobix7Y29uZmlndXJhYmxlOiFwaS5zYWZlRGVzY3JpcHRvcnN8fHQubCxzZXQ6eihuLnRvU3RyaW5nKCksaS5zZXQpfSxyKTooXCJmdW5jdGlvblwiPT10eXBlb2YgaS52YWx1ZSYmKG51bGw9PShlPXRoaXMuaSk/dm9pZCAwOmUuYXV0b0JpbmQpJiYoaS52YWx1ZT1pLnZhbHVlLmJpbmQobnVsbCE9KHU9dC52KT91OnQucykpLCghMT09PShudWxsPT0obz10aGlzLmkpP3ZvaWQgMDpvLmRlZXApPyRuLnJlZjokbikudSh0LG4saSxyKSl9ZnVuY3Rpb24gSCh0KXtyZXR1cm4gdHx8cW59ZnVuY3Rpb24gVSh0KXtyZXR1cm4hMD09PXQuZGVlcD9TOiExPT09dC5kZWVwP006KG49dC5kZWZhdWx0RGVjb3JhdG9yKSYmbnVsbCE9KGk9bnVsbD09KHI9bi5pKT92b2lkIDA6ci5lbmhhbmNlcik/aTpTO3ZhciBuLGkscn1mdW5jdGlvbiBGKHQsbixpKXtpZighbyhuKSlyZXR1cm4gSXQodCk/dDpzKHQpPyRuLm9iamVjdCh0LG4saSk6QXJyYXkuaXNBcnJheSh0KT8kbi5hcnJheSh0LG4pOnYodCk/JG4ubWFwKHQsbik6bCh0KT8kbi5zZXQodCxuKTpcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXQ/dDokbi5ib3godCxuKTtnKHQsbixHbil9ZnVuY3Rpb24geih0LG4saSxyKXtmdW5jdGlvbiBlKCl7cmV0dXJuICQoMCxpLG4scnx8dGhpcyxhcmd1bWVudHMpfXJldHVybiB2b2lkIDA9PT1pJiYoaT0hMSksZS5pc01vYnhBY3Rpb249ITAsaWkmJihyaS52YWx1ZT10LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwibmFtZVwiLHJpKSksZX1mdW5jdGlvbiAkKHQsbixpLHIsZSl7dmFyIG89SigwLG4pO3RyeXtyZXR1cm4gaS5hcHBseShyLGUpfWNhdGNoKHQpe3Rocm93IG8uaj10LHR9ZmluYWxseXtZKG8pfX1mdW5jdGlvbiBKKHQsbil7dmFyIGk9cGkudHJhY2tpbmdEZXJpdmF0aW9uLHI9IW58fCFpO2R0KCk7dmFyIGU9cGkuYWxsb3dTdGF0ZUNoYW5nZXM7ciYmKHV0KCksZT1aKCEwKSk7dmFyIG89e086cixBOmksZzplLF86ZnQoITApLFM6ITEsTTowLFY6bmkrKyxOOnRpfTtyZXR1cm4gdGk9by5WLG99ZnVuY3Rpb24gWShuKXt0aSE9PW4uViYmdCgzMCksdGk9bi5OLHZvaWQgMCE9PW4uaiYmKHBpLnN1cHByZXNzUmVhY3Rpb25FcnJvcnM9ITApLHR0KG4uZyksYXQobi5fKSxidCgpLG4uTyYmc3Qobi5BKSxwaS5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzPSExfWZ1bmN0aW9uIFEodCxuKXt2YXIgaT1aKHQpO3RyeXtyZXR1cm4gbigpfWZpbmFsbHl7dHQoaSl9fWZ1bmN0aW9uIFoodCl7dmFyIG49cGkuYWxsb3dTdGF0ZUNoYW5nZXM7cmV0dXJuIHBpLmFsbG93U3RhdGVDaGFuZ2VzPXQsbn1mdW5jdGlvbiB0dCh0KXtwaS5hbGxvd1N0YXRlQ2hhbmdlcz10fWZ1bmN0aW9uIG50KHQpe3JldHVybiB0IGluc3RhbmNlb2YgaGl9ZnVuY3Rpb24gaXQodCl7c3dpdGNoKHQuUil7Y2FzZSBzaS5rOnJldHVybiExO2Nhc2Ugc2kuVDpjYXNlIHNpLkM6cmV0dXJuITA7Y2FzZSBzaS5LOmZvcih2YXIgbj1mdCghMCksaT11dCgpLHI9dC5MLGU9ci5sZW5ndGgsbz0wO288ZTtvKyspe3ZhciB1PXJbb107aWYoY2kodSkpe2lmKHBpLmRpc2FibGVFcnJvckJvdW5kYXJpZXMpdS5nZXQoKTtlbHNlIHRyeXt1LmdldCgpfWNhdGNoKHQpe3JldHVybiBzdChpKSxhdChuKSwhMH1pZih0LlI9PT1zaS5DKXJldHVybiBzdChpKSxhdChuKSwhMH19cmV0dXJuIGN0KHQpLHN0KGkpLGF0KG4pLCExfX1mdW5jdGlvbiBydCh0LG4saSl7dmFyIHI9ZnQoITApO2N0KHQpLHQuST1uZXcgQXJyYXkodC5MLmxlbmd0aCsxMDApLHQuUD0wLHQuRD0rK3BpLnJ1bklkO3ZhciBlLG89cGkudHJhY2tpbmdEZXJpdmF0aW9uO2lmKHBpLnRyYWNraW5nRGVyaXZhdGlvbj10LHBpLmluQmF0Y2grKywhMD09PXBpLmRpc2FibGVFcnJvckJvdW5kYXJpZXMpZT1uLmNhbGwoaSk7ZWxzZSB0cnl7ZT1uLmNhbGwoaSl9Y2F0Y2godCl7ZT1uZXcgaGkodCl9cmV0dXJuIHBpLmluQmF0Y2gtLSxwaS50cmFja2luZ0Rlcml2YXRpb249byxmdW5jdGlvbih0KXtmb3IodmFyIG49dC5MLGk9dC5MPXQuSSxyPXNpLmssZT0wLG89dC5QLHU9MDt1PG87dSsrKXt2YXIgcz1pW3VdOzA9PT1zLkImJihzLkI9MSxlIT09dSYmKGlbZV09cyksZSsrKSxzLlI+ciYmKHI9cy5SKX1mb3IoaS5sZW5ndGg9ZSx0Lkk9bnVsbCxvPW4ubGVuZ3RoO28tLTspe3ZhciBmPW5bb107MD09PWYuQiYmdnQoZix0KSxmLkI9MH1mb3IoO2UtLTspe3ZhciBhPWlbZV07MT09PWEuQiYmKGEuQj0wLGh0KGEsdCkpfXIhPT1zaS5rJiYodC5SPXIsdC5xKCkpfSh0KSxhdChyKSxlfWZ1bmN0aW9uIGV0KHQpe3ZhciBuPXQuTDt0Lkw9W107Zm9yKHZhciBpPW4ubGVuZ3RoO2ktLTspdnQobltpXSx0KTt0LlI9c2kuVH1mdW5jdGlvbiBvdCh0KXt2YXIgbj11dCgpO3RyeXtyZXR1cm4gdCgpfWZpbmFsbHl7c3Qobil9fWZ1bmN0aW9uIHV0KCl7dmFyIHQ9cGkudHJhY2tpbmdEZXJpdmF0aW9uO3JldHVybiBwaS50cmFja2luZ0Rlcml2YXRpb249bnVsbCx0fWZ1bmN0aW9uIHN0KHQpe3BpLnRyYWNraW5nRGVyaXZhdGlvbj10fWZ1bmN0aW9uIGZ0KHQpe3ZhciBuPXBpLmFsbG93U3RhdGVSZWFkcztyZXR1cm4gcGkuYWxsb3dTdGF0ZVJlYWRzPXQsbn1mdW5jdGlvbiBhdCh0KXtwaS5hbGxvd1N0YXRlUmVhZHM9dH1mdW5jdGlvbiBjdCh0KXtpZih0LlIhPT1zaS5rKXt0LlI9c2kuaztmb3IodmFyIG49dC5MLGk9bi5sZW5ndGg7aS0tOyluW2ldLkc9c2kua319ZnVuY3Rpb24gaHQodCxuKXt0LlguYWRkKG4pLHQuRz5uLlImJih0Lkc9bi5SKX1mdW5jdGlvbiB2dCh0LG4pe3QuWC5kZWxldGUobiksMD09PXQuWC5zaXplJiZsdCh0KX1mdW5jdGlvbiBsdCh0KXshMT09PXQuVyYmKHQuVz0hMCxwaS5wZW5kaW5nVW5vYnNlcnZhdGlvbnMucHVzaCh0KSl9ZnVuY3Rpb24gZHQoKXtwaS5pbkJhdGNoKyt9ZnVuY3Rpb24gYnQoKXtpZigwPT0tLXBpLmluQmF0Y2gpe210KCk7Zm9yKHZhciB0PXBpLnBlbmRpbmdVbm9ic2VydmF0aW9ucyxuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBpPXRbbl07aS5XPSExLDA9PT1pLlguc2l6ZSYmKGkuSCYmKGkuSD0hMSxpLm9uQlVPKCkpLGkgaW5zdGFuY2VvZiBhaSYmaS5VKCkpfXBpLnBlbmRpbmdVbm9ic2VydmF0aW9ucz1bXX19ZnVuY3Rpb24gcHQodCl7dmFyIG49cGkudHJhY2tpbmdEZXJpdmF0aW9uO3JldHVybiBudWxsIT09bj8obi5EIT09dC5GJiYodC5GPW4uRCxuLklbbi5QKytdPXQsIXQuSCYmcGkudHJhY2tpbmdDb250ZXh0JiYodC5IPSEwLHQub25CTygpKSksITApOigwPT09dC5YLnNpemUmJnBpLmluQmF0Y2g+MCYmbHQodCksITEpfWZ1bmN0aW9uIHl0KHQpe3QuRyE9PXNpLkMmJih0Lkc9c2kuQyx0LlguZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5SPT09c2kuayYmdC5xKCksdC5SPXNpLkN9KSkpfWZ1bmN0aW9uIG10KCl7cGkuaW5CYXRjaD4wfHxwaS5pc1J1bm5pbmdSZWFjdGlvbnN8fG1pKHd0KX1mdW5jdGlvbiB3dCgpe3BpLmlzUnVubmluZ1JlYWN0aW9ucz0hMDtmb3IodmFyIHQ9cGkucGVuZGluZ1JlYWN0aW9ucyxuPTA7dC5sZW5ndGg+MDspezEwMD09KytuJiYoY29uc29sZS5lcnJvcihcIlttb2J4XSBjeWNsZSBpbiByZWFjdGlvbjogXCIrdFswXSksdC5zcGxpY2UoMCkpO2Zvcih2YXIgaT10LnNwbGljZSgwKSxyPTAsZT1pLmxlbmd0aDtyPGU7cisrKWlbcl0uJCgpfXBpLmlzUnVubmluZ1JlYWN0aW9ucz0hMX1mdW5jdGlvbiBqdCgpe3JldHVybiBjb25zb2xlLndhcm4oXCJbbW9ieC5zcHldIElzIGEgbm8tb3AgaW4gcHJvZHVjdGlvbiBidWlsZHNcIiksZnVuY3Rpb24oKXt9fWZ1bmN0aW9uIHh0KHQpe3JldHVybiBmdW5jdGlvbihuLGkpe3JldHVybiBlKG4pP3oobi5uYW1lfHxcIjx1bm5hbWVkIGFjdGlvbj5cIixuLHQpOmUoaSk/eihuLGksdCk6byhpKT9nKG4saSx0P09pOmppKTpvKG4pP0EoVih0P1wiYXV0b0FjdGlvblwiOlwiYWN0aW9uXCIse25hbWU6bixhdXRvQWN0aW9uOnR9KSk6dm9pZCAwfX1mdW5jdGlvbiBPdCh0KXtyZXR1cm4gJCgwLCExLHQsdGhpcyx2b2lkIDApfWZ1bmN0aW9uIEF0KHQpe3JldHVybiBlKHQpJiYhMD09PXQuaXNNb2J4QWN0aW9ufWZ1bmN0aW9uIGd0KHQsbil7ZnVuY3Rpb24gaSgpe3Qobyl9dmFyIHIsZTt2b2lkIDA9PT1uJiYobj1Nbik7dmFyIG8sdT1udWxsIT0ocj1udWxsPT0oZT1uKT92b2lkIDA6ZS5uYW1lKT9yOlwiQXV0b3J1blwiO2lmKG4uc2NoZWR1bGVyfHxuLmRlbGF5KXt2YXIgcz1fdChuKSxmPSExO289bmV3IHlpKHUsKGZ1bmN0aW9uKCl7Znx8KGY9ITAscygoZnVuY3Rpb24oKXtmPSExLG8uSnx8by50cmFjayhpKX0pKSl9KSxuLm9uRXJyb3Isbi5yZXF1aXJlc09ic2VydmFibGUpfWVsc2Ugbz1uZXcgeWkodSwoZnVuY3Rpb24oKXt0aGlzLnRyYWNrKGkpfSksbi5vbkVycm9yLG4ucmVxdWlyZXNPYnNlcnZhYmxlKTtyZXR1cm4gby5ZKCksby5aKCl9ZnVuY3Rpb24gX3QodCl7cmV0dXJuIHQuc2NoZWR1bGVyP3Quc2NoZWR1bGVyOnQuZGVsYXk/ZnVuY3Rpb24obil7cmV0dXJuIHNldFRpbWVvdXQobix0LmRlbGF5KX06U2l9ZnVuY3Rpb24gU3QodCxuLGkpe3JldHVybiBWdChcIm9uQk9cIix0LG4saSl9ZnVuY3Rpb24gTXQodCxuLGkpe3JldHVybiBWdChcIm9uQlVPXCIsdCxuLGkpfWZ1bmN0aW9uIFZ0KHQsbixpLHIpe3ZhciBvPVwiZnVuY3Rpb25cIj09dHlwZW9mIHI/ZG4obixpKTpkbihuKSx1PWUocik/cjppLHM9dCtcIkxcIjtyZXR1cm4gb1tzXT9vW3NdLmFkZCh1KTpvW3NdPW5ldyBTZXQoW3VdKSxmdW5jdGlvbigpe3ZhciB0PW9bc107dCYmKHQuZGVsZXRlKHUpLDA9PT10LnNpemUmJmRlbGV0ZSBvW3NdKX19ZnVuY3Rpb24gTnQodCxuLGkscil7dmFyIGU9VG4obiksbz1zbih0LHIpW0tuXTtkdCgpO3RyeXtFbihlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtvLnUodCxlW3RdLCFpfHwhKHQgaW4gaSl8fGlbdF0pfSkpfWZpbmFsbHl7YnQoKX1yZXR1cm4gdH1mdW5jdGlvbiBSdCh0KXt2YXIgbixpPXtuYW1lOnQudHR9O3JldHVybiB0LkwmJnQuTC5sZW5ndGg+MCYmKGkuZGVwZW5kZW5jaWVzPShuPXQuTCxBcnJheS5mcm9tKG5ldyBTZXQobikpKS5tYXAoUnQpKSxpfWZ1bmN0aW9uIGt0KHQpe3ZhciBuPXtuYW1lOnQudHR9O3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gdC5YJiZ0Llguc2l6ZT4wfSh0KSYmKG4ub2JzZXJ2ZXJzPUFycmF5LmZyb20oZnVuY3Rpb24odCl7cmV0dXJuIHQuWH0odCkpLm1hcChrdCkpLG59ZnVuY3Rpb24gRXQoKXt0aGlzLm1lc3NhZ2U9XCJGTE9XX0NBTkNFTExFRFwifWZ1bmN0aW9uIFR0KHQpe2UodC5jYW5jZWwpJiZ0LmNhbmNlbCgpfWZ1bmN0aW9uIEN0KHQpe3JldHVybiEwPT09KG51bGw9PXQ/dm9pZCAwOnQuaXNNb2JYRmxvdyl9ZnVuY3Rpb24gS3QodCxuKXtpZih2b2lkIDAhPT1uKXtpZighMT09PWFuKHQpKXJldHVybiExO2lmKCF0W0tuXS5udC5oYXMobikpcmV0dXJuITE7dmFyIGk9ZG4odCxuKTtyZXR1cm4gY2koaSl9cmV0dXJuIGNpKHQpfWZ1bmN0aW9uIEx0KHQsbil7cmV0dXJuISF0JiYodm9pZCAwIT09bj8hIWFuKHQpJiZ0W0tuXS5udC5oYXMobik6YW4odCl8fCEhdFtLbl18fEluKHQpfHx3aSh0KXx8Y2kodCkpfWZ1bmN0aW9uIEl0KHQpe3JldHVybiBMdCh0KX1mdW5jdGlvbiBQdChuKXtyZXR1cm4gYW4obik/bltLbl0uaXQoKTpIaShuKXx8Smkobik/QXJyYXkuZnJvbShuLmtleXMoKSk6dW4obik/bi5tYXAoKGZ1bmN0aW9uKHQsbil7cmV0dXJuIG59KSk6dm9pZCB0KDUpfWZ1bmN0aW9uIER0KG4saSl7cmV0dXJuIGFuKG4pP25bS25dLnJ0KGkpOkhpKG4pfHxKaShuKT9uLmhhcyhpKTp1bihuKT9pPj0wJiZpPG4ubGVuZ3RoOnZvaWQgdCgxMCl9ZnVuY3Rpb24gQnQobil7aWYoYW4obikpcmV0dXJuIG5bS25dLmV0KCk7dCgzOCl9ZnVuY3Rpb24gcXQodCxuLGkpe3JldHVybiB0LnNldChuLGkpLGl9ZnVuY3Rpb24gR3QoKXt0KFwidHJhY2UoKSBpcyBub3QgYXZhaWxhYmxlIGluIHByb2R1Y3Rpb24gYnVpbGRzXCIpO2Zvcih2YXIgbj0hMSxpPWFyZ3VtZW50cy5sZW5ndGgscj1uZXcgQXJyYXkoaSksZT0wO2U8aTtlKyspcltlXT1hcmd1bWVudHNbZV07XCJib29sZWFuXCI9PXR5cGVvZiByW3IubGVuZ3RoLTFdJiYobj1yLnBvcCgpKTt2YXIgbz1YdChyKTtpZighbylyZXR1cm4gdChcIid0cmFjZShicmVhaz8pJyBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhIHRyYWNrZWQgY29tcHV0ZWQgdmFsdWUgb3IgYSBSZWFjdGlvbi4gQ29uc2lkZXIgcGFzc2luZyBpbiB0aGUgY29tcHV0ZWQgdmFsdWUgb3IgcmVhY3Rpb24gZXhwbGljaXRseVwiKTtvLm90PT09ZmkuTk9ORSYmY29uc29sZS5sb2coXCJbbW9ieC50cmFjZV0gJ1wiK28udHQrXCInIHRyYWNpbmcgZW5hYmxlZFwiKSxvLm90PW4/ZmkuQlJFQUs6ZmkuTE9HfWZ1bmN0aW9uIFh0KHQpe3N3aXRjaCh0Lmxlbmd0aCl7Y2FzZSAwOnJldHVybiBwaS50cmFja2luZ0Rlcml2YXRpb247Y2FzZSAxOnJldHVybiBkbih0WzBdKTtjYXNlIDI6cmV0dXJuIGRuKHRbMF0sdFsxXSl9fWZ1bmN0aW9uIFd0KHQsbil7dm9pZCAwPT09biYmKG49dm9pZCAwKSxkdCgpO3RyeXtyZXR1cm4gdC5hcHBseShuKX1maW5hbGx5e2J0KCl9fWZ1bmN0aW9uIEh0KHQsbixpKXt2YXIgcjtpZihcIm51bWJlclwiPT10eXBlb2YgaS50aW1lb3V0KXt2YXIgZT1uZXcgRXJyb3IoXCJXSEVOX1RJTUVPVVRcIik7cj1zZXRUaW1lb3V0KChmdW5jdGlvbigpe2lmKCF1W0tuXS5KKXtpZih1KCksIWkub25FcnJvcil0aHJvdyBlO2kub25FcnJvcihlKX19KSxpLnRpbWVvdXQpfWkubmFtZT1cIldoZW5cIjt2YXIgbz16KFwiV2hlbi1lZmZlY3RcIixuKSx1PWd0KChmdW5jdGlvbihuKXtRKCExLHQpJiYobi5kaXNwb3NlKCksciYmY2xlYXJUaW1lb3V0KHIpLG8oKSl9KSxpKTtyZXR1cm4gdX1mdW5jdGlvbiBVdCh0LG4pe3ZhciBpLHI9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHIsZSl7dmFyIG89SHQodCxyLG0oe30sbix7b25FcnJvcjplfSkpO2k9ZnVuY3Rpb24oKXtvKCksZShcIldIRU5fQ0FOQ0VMTEVEXCIpfX0pKTtyZXR1cm4gci5jYW5jZWw9aSxyfWZ1bmN0aW9uIEZ0KHQpe3JldHVybiB0W0tuXX1mdW5jdGlvbiB6dCh0KXtyZXR1cm4gdm9pZCAwIT09dC51dCYmdC51dC5sZW5ndGg+MH1mdW5jdGlvbiAkdCh0LG4pe3ZhciBpPXQudXR8fCh0LnV0PVtdKTtyZXR1cm4gaS5wdXNoKG4pLHIoKGZ1bmN0aW9uKCl7dmFyIHQ9aS5pbmRleE9mKG4pOy0xIT09dCYmaS5zcGxpY2UodCwxKX0pKX1mdW5jdGlvbiBKdChuLGkpe3ZhciByPXV0KCk7dHJ5e2Zvcih2YXIgZT1bXS5jb25jYXQobi51dHx8W10pLG89MCx1PWUubGVuZ3RoO288dSYmKChpPWVbb10oaSkpJiYhaS50eXBlJiZ0KDE0KSxpKTtvKyspO3JldHVybiBpfWZpbmFsbHl7c3Qocil9fWZ1bmN0aW9uIFl0KHQpe3JldHVybiB2b2lkIDAhPT10LnN0JiZ0LnN0Lmxlbmd0aD4wfWZ1bmN0aW9uIFF0KHQsbil7dmFyIGk9dC5zdHx8KHQuc3Q9W10pO3JldHVybiBpLnB1c2gobikscigoZnVuY3Rpb24oKXt2YXIgdD1pLmluZGV4T2Yobik7LTEhPT10JiZpLnNwbGljZSh0LDEpfSkpfWZ1bmN0aW9uIFp0KHQsbil7dmFyIGk9dXQoKSxyPXQuc3Q7aWYocil7Zm9yKHZhciBlPTAsbz0ocj1yLnNsaWNlKCkpLmxlbmd0aDtlPG87ZSsrKXJbZV0obik7c3QoaSl9fWZ1bmN0aW9uIHRuKHQsbixyLGUpe3ZvaWQgMD09PXImJihyPVwiT2JzZXJ2YWJsZUFycmF5XCIpLHZvaWQgMD09PWUmJihlPSExKSxpKCk7dmFyIG89bmV3IEtpKHIsbixlLCExKTtjKG8ubnQsS24sbyk7dmFyIHU9bmV3IFByb3h5KG8ubnQsQ2kpO2lmKG8udj11LHQmJnQubGVuZ3RoKXt2YXIgcz1aKCEwKTtvLmZ0KDAsMCx0KSx0dChzKX1yZXR1cm4gdX1mdW5jdGlvbiBubih0LG4pe1wiZnVuY3Rpb25cIj09dHlwZW9mIEFycmF5LnByb3RvdHlwZVt0XSYmKExpW3RdPW4odCkpfWZ1bmN0aW9uIHJuKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXNbS25dO24uYXQucmVwb3J0T2JzZXJ2ZWQoKTt2YXIgaT1uLmN0KG4ubnQpO3JldHVybiBpW3RdLmFwcGx5KGksYXJndW1lbnRzKX19ZnVuY3Rpb24gZW4odCl7cmV0dXJuIGZ1bmN0aW9uKG4saSl7dmFyIHI9dGhpcyxlPXRoaXNbS25dO3JldHVybiBlLmF0LnJlcG9ydE9ic2VydmVkKCksZS5jdChlLm50KVt0XSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gbi5jYWxsKGksdCxlLHIpfSkpfX1mdW5jdGlvbiBvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbj10aGlzLGk9dGhpc1tLbl07aS5hdC5yZXBvcnRPYnNlcnZlZCgpO3ZhciByPWkuY3QoaS5udCksZT1hcmd1bWVudHNbMF07cmV0dXJuIGFyZ3VtZW50c1swXT1mdW5jdGlvbih0LGkscil7cmV0dXJuIGUodCxpLHIsbil9LHJbdF0uYXBwbHkocixhcmd1bWVudHMpfX1mdW5jdGlvbiB1bih0KXtyZXR1cm4gdSh0KSYmRGkodFtLbl0pfWZ1bmN0aW9uIHNuKHQsbil7dmFyIGk7aWYoYih0LEtuKSlyZXR1cm4gdDt2YXIgcj1udWxsIT0oaT1udWxsPT1uP3ZvaWQgMDpuLm5hbWUpP2k6XCJPYnNlcnZhYmxlT2JqZWN0XCIsZT1uZXcgUWkodCxuZXcgTWFwLFN0cmluZyhyKSxmdW5jdGlvbih0KXt2YXIgbjtyZXR1cm4gdD9udWxsIT0obj10LmRlZmF1bHREZWNvcmF0b3IpP246Ryh0KTp2b2lkIDB9KG4pKTtyZXR1cm4gYSh0LEtuLGUpLHR9ZnVuY3Rpb24gZm4odCl7cmV0dXJuIFlpW3RdfHwoWWlbdF09e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW0tuXS5odCh0KX0sc2V0OmZ1bmN0aW9uKG4pe3JldHVybiB0aGlzW0tuXS52dCh0LG4pfX0pfWZ1bmN0aW9uIGFuKHQpe3JldHVybiEhdSh0KSYmWmkodFtLbl0pfWZ1bmN0aW9uIGNuKHQsbixpKXt2YXIgcjtudWxsPT0ocj10LnNbQ25dKXx8ZGVsZXRlIHJbaV19ZnVuY3Rpb24gaG4odCl7Z24oaXIucHJvdG90eXBlLFwiXCIrdCxmdW5jdGlvbih0KXtyZXR1cm57ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbS25dLmx0KHQpfSxzZXQ6ZnVuY3Rpb24obil7dGhpc1tLbl0uZHQodCxuKX19fSh0KSl9ZnVuY3Rpb24gdm4odCl7aWYodD50cil7Zm9yKHZhciBuPXRyO248dCsxMDA7bisrKWhuKG4pO3RyPXR9fWZ1bmN0aW9uIGxuKHQsbixpKXtyZXR1cm4gbmV3IGlyKHQsbixpKX1mdW5jdGlvbiBkbihuLGkpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBuJiZudWxsIT09bil7aWYodW4obikpcmV0dXJuIHZvaWQgMCE9PWkmJnQoMjMpLG5bS25dLmF0O2lmKEppKG4pKXJldHVybiBuW0tuXTtpZihIaShuKSl7aWYodm9pZCAwPT09aSlyZXR1cm4gbi5idDt2YXIgcj1uLnB0LmdldChpKXx8bi55dC5nZXQoaSk7cmV0dXJuIHJ8fHQoMjUsaSxwbihuKSkscn1pZihhbihuKSl7aWYoIWkpcmV0dXJuIHQoMjYpO3ZhciBvPW5bS25dLm50LmdldChpKTtyZXR1cm4gb3x8dCgyNyxpLHBuKG4pKSxvfWlmKEluKG4pfHxjaShuKXx8d2kobikpcmV0dXJuIG59ZWxzZSBpZihlKG4pJiZ3aShuW0tuXSkpcmV0dXJuIG5bS25dO3QoMjgpfWZ1bmN0aW9uIGJuKG4saSl7cmV0dXJuIG58fHQoMjkpLHZvaWQgMCE9PWk/Ym4oZG4obixpKSk6SW4obil8fGNpKG4pfHx3aShuKXx8SGkobil8fEppKG4pP246bltLbl0/bltLbl06dm9pZCB0KDI0LG4pfWZ1bmN0aW9uIHBuKHQsbil7dmFyIGk7aWYodm9pZCAwIT09bilpPWRuKHQsbik7ZWxzZXtpZihBdCh0KSlyZXR1cm4gdC5uYW1lO2k9YW4odCl8fEhpKHQpfHxKaSh0KT9ibih0KTpkbih0KX1yZXR1cm4gaS50dH1mdW5jdGlvbiB5bih0LG4saSl7cmV0dXJuIHZvaWQgMD09PWkmJihpPS0xKSxmdW5jdGlvbiB0KG4saSxyLG8sdSl7aWYobj09PWkpcmV0dXJuIDAhPT1ufHwxL249PTEvaTtpZihudWxsPT1ufHxudWxsPT1pKXJldHVybiExO2lmKG4hPW4pcmV0dXJuIGkhPWk7dmFyIHM9dHlwZW9mIG47aWYoIWUocykmJlwib2JqZWN0XCIhPT1zJiZcIm9iamVjdFwiIT10eXBlb2YgaSlyZXR1cm4hMTt2YXIgZj1yci5jYWxsKG4pO2lmKGYhPT1yci5jYWxsKGkpKXJldHVybiExO3N3aXRjaChmKXtjYXNlXCJbb2JqZWN0IFJlZ0V4cF1cIjpjYXNlXCJbb2JqZWN0IFN0cmluZ11cIjpyZXR1cm5cIlwiK249PVwiXCIraTtjYXNlXCJbb2JqZWN0IE51bWJlcl1cIjpyZXR1cm4rbiE9K24/K2khPStpOjA9PStuPzEvK249PTEvaTorbj09K2k7Y2FzZVwiW29iamVjdCBEYXRlXVwiOmNhc2VcIltvYmplY3QgQm9vbGVhbl1cIjpyZXR1cm4rbj09K2k7Y2FzZVwiW29iamVjdCBTeW1ib2xdXCI6cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnZhbHVlT2YuY2FsbChuKT09PVN5bWJvbC52YWx1ZU9mLmNhbGwoaSk7Y2FzZVwiW29iamVjdCBNYXBdXCI6Y2FzZVwiW29iamVjdCBTZXRdXCI6cj49MCYmcisrfW49bW4obiksaT1tbihpKTt2YXIgYT1cIltvYmplY3QgQXJyYXldXCI9PT1mO2lmKCFhKXtpZihcIm9iamVjdFwiIT10eXBlb2Ygbnx8XCJvYmplY3RcIiE9dHlwZW9mIGkpcmV0dXJuITE7dmFyIGM9bi5jb25zdHJ1Y3RvcixoPWkuY29uc3RydWN0b3I7aWYoYyE9PWgmJiEoZShjKSYmYyBpbnN0YW5jZW9mIGMmJmUoaCkmJmggaW5zdGFuY2VvZiBoKSYmXCJjb25zdHJ1Y3RvclwiaW4gbiYmXCJjb25zdHJ1Y3RvclwiaW4gaSlyZXR1cm4hMX1pZigwPT09cilyZXR1cm4hMTtyPDAmJihyPS0xKSx1PXV8fFtdO2Zvcih2YXIgdj0obz1vfHxbXSkubGVuZ3RoO3YtLTspaWYob1t2XT09PW4pcmV0dXJuIHVbdl09PT1pO2lmKG8ucHVzaChuKSx1LnB1c2goaSksYSl7aWYoKHY9bi5sZW5ndGgpIT09aS5sZW5ndGgpcmV0dXJuITE7Zm9yKDt2LS07KWlmKCF0KG5bdl0saVt2XSxyLTEsbyx1KSlyZXR1cm4hMX1lbHNle3ZhciBsLGQ9T2JqZWN0LmtleXMobik7aWYodj1kLmxlbmd0aCxPYmplY3Qua2V5cyhpKS5sZW5ndGghPT12KXJldHVybiExO2Zvcig7di0tOylpZighYihpLGw9ZFt2XSl8fCF0KG5bbF0saVtsXSxyLTEsbyx1KSlyZXR1cm4hMX1yZXR1cm4gby5wb3AoKSx1LnBvcCgpLCEwfSh0LG4saSl9ZnVuY3Rpb24gbW4odCl7cmV0dXJuIHVuKHQpP3Quc2xpY2UoKTp2KHQpfHxIaSh0KXx8bCh0KXx8SmkodCk/QXJyYXkuZnJvbSh0LmVudHJpZXMoKSk6dH1mdW5jdGlvbiB3bih0KXtyZXR1cm4gdFtTeW1ib2wuaXRlcmF0b3JdPWpuLHR9ZnVuY3Rpb24gam4oKXtyZXR1cm4gdGhpc31PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgeG49e30sT249T2JqZWN0LmFzc2lnbixBbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLGduPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxfbj1PYmplY3QucHJvdG90eXBlLFNuPVtdO09iamVjdC5mcmVlemUoU24pO3ZhciBNbj17fTtPYmplY3QuZnJlZXplKE1uKTt2YXIgVm49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb3h5LE5uPU9iamVjdC50b1N0cmluZygpLFJuPWZ1bmN0aW9uKCl7fSxrbj12b2lkIDAhPT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLEVuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBSZWZsZWN0JiZSZWZsZWN0Lm93bktleXM/UmVmbGVjdC5vd25LZXlzOmtuP2Z1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0KS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0KSl9Ok9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFRuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzfHxmdW5jdGlvbih0KXt2YXIgbj17fTtyZXR1cm4gRW4odCkuZm9yRWFjaCgoZnVuY3Rpb24oaSl7bltpXT1Bbih0LGkpfSkpLG59LENuPVN5bWJvbChcIm1vYngtc3RvcmVkLWFubm90YXRpb25zXCIpLEtuPVN5bWJvbChcIm1vYnggYWRtaW5pc3RyYXRpb25cIiksTG49ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZvaWQgMD09PXQmJih0PVwiQXRvbVwiKSx0aGlzLnR0PXZvaWQgMCx0aGlzLlc9ITEsdGhpcy5IPSExLHRoaXMuWD1uZXcgU2V0LHRoaXMuQj0wLHRoaXMuRj0wLHRoaXMuRz1zaS5ULHRoaXMub25CT0w9dm9pZCAwLHRoaXMub25CVU9MPXZvaWQgMCx0aGlzLnR0PXR9dmFyIG49dC5wcm90b3R5cGU7cmV0dXJuIG4ub25CTz1mdW5jdGlvbigpe3RoaXMub25CT0wmJnRoaXMub25CT0wuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQoKX0pKX0sbi5vbkJVTz1mdW5jdGlvbigpe3RoaXMub25CVU9MJiZ0aGlzLm9uQlVPTC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdCgpfSkpfSxuLnJlcG9ydE9ic2VydmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHB0KHRoaXMpfSxuLnJlcG9ydENoYW5nZWQ9ZnVuY3Rpb24oKXtkdCgpLHl0KHRoaXMpLGJ0KCl9LG4udG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50dH0sdH0oKSxJbj1oKFwiQXRvbVwiLExuKSxQbj17aWRlbnRpdHk6ZnVuY3Rpb24odCxuKXtyZXR1cm4gdD09PW59LHN0cnVjdHVyYWw6ZnVuY3Rpb24odCxuKXtyZXR1cm4geW4odCxuKX0sZGVmYXVsdDpmdW5jdGlvbih0LG4pe3JldHVybiBPYmplY3QuaXM/T2JqZWN0LmlzKHQsbik6dD09PW4/MCE9PXR8fDEvdD09MS9uOnQhPXQmJm4hPW59LHNoYWxsb3c6ZnVuY3Rpb24odCxuKXtyZXR1cm4geW4odCxuLDEpfX0sRG49QSh7dDpcIm92ZXJyaWRlXCIsbzpmdW5jdGlvbigpe3JldHVybiAwfSx1OmZ1bmN0aW9uKCl7dChcIidcIit0aGlzLnQrXCInIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCAnbWFrZU9ic2VydmFibGUnXCIpfX0pLEJuPUcoKSxxbj17ZGVlcDohMCxuYW1lOnZvaWQgMCxkZWZhdWx0RGVjb3JhdG9yOnZvaWQgMCxwcm94eTohMH07T2JqZWN0LmZyZWV6ZShxbik7dmFyIEduPUQoXCJvYnNlcnZhYmxlXCIpLFhuPUQoXCJvYnNlcnZhYmxlLnJlZlwiLHtlbmhhbmNlcjpNfSksV249RChcIm9ic2VydmFibGUuc2hhbGxvd1wiLHtlbmhhbmNlcjpmdW5jdGlvbih0LG4saSl7cmV0dXJuIG51bGw9PXR8fGFuKHQpfHx1bih0KXx8SGkodCl8fEppKHQpP3Q6QXJyYXkuaXNBcnJheSh0KT8kbi5hcnJheSh0LHtuYW1lOmksZGVlcDohMX0pOnModCk/JG4ub2JqZWN0KHQsdm9pZCAwLHtuYW1lOmksZGVlcDohMX0pOnYodCk/JG4ubWFwKHQse25hbWU6aSxkZWVwOiExfSk6bCh0KT8kbi5zZXQodCx7bmFtZTppLGRlZXA6ITF9KTp2b2lkIDB9fSksSG49RChcIm9ic2VydmFibGUuc3RydWN0XCIse2VuaGFuY2VyOmZ1bmN0aW9uKHQsbil7cmV0dXJuIHluKHQsbik/bjp0fX0pLFVuPUEoR24pO09iamVjdC5hc3NpZ24oRixVbik7dmFyIEZuLHpuLCRuPU9uKEYse2JveDpmdW5jdGlvbih0LG4pe3ZhciBpPUgobik7cmV0dXJuIG5ldyBvaSh0LFUoaSksaS5uYW1lLCEwLGkuZXF1YWxzKX0sYXJyYXk6ZnVuY3Rpb24odCxuKXt2YXIgaT1IKG4pO3JldHVybighMT09PXBpLnVzZVByb3hpZXN8fCExPT09aS5wcm94eT9sbjp0bikodCxVKGkpLGkubmFtZSl9LG1hcDpmdW5jdGlvbih0LG4pe3ZhciBpPUgobik7cmV0dXJuIG5ldyBXaSh0LFUoaSksaS5uYW1lKX0sc2V0OmZ1bmN0aW9uKHQsbil7dmFyIGk9SChuKTtyZXR1cm4gbmV3ICRpKHQsVShpKSxpLm5hbWUpfSxvYmplY3Q6ZnVuY3Rpb24odCxuLHIpe3JldHVybiBOdCghMT09PXBpLnVzZVByb3hpZXN8fCExPT09KG51bGw9PXI/dm9pZCAwOnIucHJveHkpP3NuKHt9LHIpOmZ1bmN0aW9uKHQsbil7dmFyIHIsZTtyZXR1cm4gaSgpLG51bGwhPShlPShyPSh0PXNuKHQsbikpW0tuXSkudik/ZTpyLnY9bmV3IFByb3h5KHQsa2kpfSh7fSxyKSx0LG4pfSxyZWY6QShYbiksc2hhbGxvdzpBKFduKSxkZWVwOlVuLHN0cnVjdDpBKEhuKX0pLEpuPUwoXCJjb21wdXRlZFwiKSxZbj1MKFwiY29tcHV0ZWQuc3RydWN0XCIse2VxdWFsczpQbi5zdHJ1Y3R1cmFsfSksUW49ZnVuY3Rpb24odCxuKXtpZihvKG4pKXJldHVybiBnKHQsbixKbik7aWYocyh0KSlyZXR1cm4gQShMKFwiY29tcHV0ZWRcIix0KSk7dmFyIGk9cyhuKT9uOnt9O3JldHVybiBpLmdldD10LGkubmFtZXx8KGkubmFtZT10Lm5hbWV8fFwiXCIpLG5ldyBhaShpKX07T2JqZWN0LmFzc2lnbihRbixKbiksUW4uc3RydWN0PUEoWW4pO3ZhciBabix0aT0wLG5pPTEsaWk9bnVsbCE9KEZuPW51bGw9PSh6bj1BbigoZnVuY3Rpb24oKXt9KSxcIm5hbWVcIikpP3ZvaWQgMDp6bi5jb25maWd1cmFibGUpJiZGbixyaT17dmFsdWU6XCJhY3Rpb25cIixjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITEsZW51bWVyYWJsZTohMX07Wm49U3ltYm9sLnRvUHJpbWl0aXZlO3ZhciBlaSxvaT1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKG4saSxyLGUsbyl7dmFyIHU7cmV0dXJuIHZvaWQgMD09PXImJihyPVwiT2JzZXJ2YWJsZVZhbHVlXCIpLHZvaWQgMD09PW8mJihvPVBuLmRlZmF1bHQpLCh1PXQuY2FsbCh0aGlzLHIpfHx0aGlzKS5lbmhhbmNlcj12b2lkIDAsdS50dD12b2lkIDAsdS5lcXVhbHM9dm9pZCAwLHUud3Q9ITEsdS51dD12b2lkIDAsdS5zdD12b2lkIDAsdS5qdD12b2lkIDAsdS5kZWhhbmNlcj12b2lkIDAsdS5lbmhhbmNlcj1pLHUudHQ9cix1LmVxdWFscz1vLHUuanQ9aShuLHZvaWQgMCxyKSx1fXcobix0KTt2YXIgaT1uLnByb3RvdHlwZTtyZXR1cm4gaS5kZWhhbmNlVmFsdWU9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuZGVoYW5jZXI/dGhpcy5kZWhhbmNlcih0KTp0fSxpLnNldD1mdW5jdGlvbih0KXsodD10aGlzLnh0KHQpKSE9PXBpLlVOQ0hBTkdFRCYmdGhpcy5PdCh0KX0saS54dD1mdW5jdGlvbih0KXtpZih6dCh0aGlzKSl7dmFyIG49SnQodGhpcyx7b2JqZWN0OnRoaXMsdHlwZTpUaSxuZXdWYWx1ZTp0fSk7aWYoIW4pcmV0dXJuIHBpLlVOQ0hBTkdFRDt0PW4ubmV3VmFsdWV9cmV0dXJuIHQ9dGhpcy5lbmhhbmNlcih0LHRoaXMuanQsdGhpcy50dCksdGhpcy5lcXVhbHModGhpcy5qdCx0KT9waS5VTkNIQU5HRUQ6dH0saS5PdD1mdW5jdGlvbih0KXt2YXIgbj10aGlzLmp0O3RoaXMuanQ9dCx0aGlzLnJlcG9ydENoYW5nZWQoKSxZdCh0aGlzKSYmWnQodGhpcyx7dHlwZTpUaSxvYmplY3Q6dGhpcyxuZXdWYWx1ZTp0LG9sZFZhbHVlOm59KX0saS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXBvcnRPYnNlcnZlZCgpLHRoaXMuZGVoYW5jZVZhbHVlKHRoaXMuanQpfSxpLkF0PWZ1bmN0aW9uKHQpe3JldHVybiAkdCh0aGlzLHQpfSxpLmd0PWZ1bmN0aW9uKHQsbil7cmV0dXJuIG4mJnQoe29ic2VydmFibGVLaW5kOlwidmFsdWVcIixkZWJ1Z09iamVjdE5hbWU6dGhpcy50dCxvYmplY3Q6dGhpcyx0eXBlOlRpLG5ld1ZhbHVlOnRoaXMuanQsb2xkVmFsdWU6dm9pZCAwfSksUXQodGhpcyx0KX0saS5yYXc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5qdH0saS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXQoKX0saS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnR0K1wiW1wiK3RoaXMuanQrXCJdXCJ9LGkudmFsdWVPZj1mdW5jdGlvbigpe3JldHVybiBkKHRoaXMuZ2V0KCkpfSxpW1puXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlT2YoKX0sbn0oTG4pLHVpPWgoXCJPYnNlcnZhYmxlVmFsdWVcIixvaSk7ZWk9U3ltYm9sLnRvUHJpbWl0aXZlO3ZhciBzaSxmaSxhaT1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obil7dGhpcy5SPXNpLlQsdGhpcy5MPVtdLHRoaXMuST1udWxsLHRoaXMuSD0hMSx0aGlzLlc9ITEsdGhpcy5YPW5ldyBTZXQsdGhpcy5CPTAsdGhpcy5EPTAsdGhpcy5GPTAsdGhpcy5HPXNpLmssdGhpcy5QPTAsdGhpcy5qdD1uZXcgaGkobnVsbCksdGhpcy50dD12b2lkIDAsdGhpcy5fdD12b2lkIDAsdGhpcy5TdD0hMSx0aGlzLk10PSExLHRoaXMuZGVyaXZhdGlvbj12b2lkIDAsdGhpcy5WdD12b2lkIDAsdGhpcy5vdD1maS5OT05FLHRoaXMuTnQ9dm9pZCAwLHRoaXMuUnQ9dm9pZCAwLHRoaXMua3Q9dm9pZCAwLHRoaXMuRXQ9dm9pZCAwLHRoaXMub25CT0w9dm9pZCAwLHRoaXMub25CVU9MPXZvaWQgMCxuLmdldHx8dCgzMSksdGhpcy5kZXJpdmF0aW9uPW4uZ2V0LHRoaXMudHQ9bi5uYW1lfHxcIkNvbXB1dGVkVmFsdWVcIixuLnNldCYmKHRoaXMuVnQ9eihcIkNvbXB1dGVkVmFsdWUtc2V0dGVyXCIsbi5zZXQpKSx0aGlzLlJ0PW4uZXF1YWxzfHwobi5jb21wYXJlU3RydWN0dXJhbHx8bi5zdHJ1Y3Q/UG4uc3RydWN0dXJhbDpQbi5kZWZhdWx0KSx0aGlzLk50PW4uY29udGV4dCx0aGlzLmt0PSEhbi5yZXF1aXJlc1JlYWN0aW9uLHRoaXMuRXQ9ISFuLmtlZXBBbGl2ZX12YXIgaT1uLnByb3RvdHlwZTtyZXR1cm4gaS5xPWZ1bmN0aW9uKCl7IWZ1bmN0aW9uKHQpe3QuRz09PXNpLmsmJih0Lkc9c2kuSyx0LlguZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5SPT09c2kuayYmKHQuUj1zaS5LLHQucSgpKX0pKSl9KHRoaXMpfSxpLm9uQk89ZnVuY3Rpb24oKXt0aGlzLm9uQk9MJiZ0aGlzLm9uQk9MLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiB0KCl9KSl9LGkub25CVU89ZnVuY3Rpb24oKXt0aGlzLm9uQlVPTCYmdGhpcy5vbkJVT0wuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQoKX0pKX0saS5nZXQ9ZnVuY3Rpb24oKXtpZih0aGlzLlN0JiZ0KDMyLHRoaXMudHQsdGhpcy5kZXJpdmF0aW9uKSwwIT09cGkuaW5CYXRjaHx8MCE9PXRoaXMuWC5zaXplfHx0aGlzLkV0KXtpZihwdCh0aGlzKSxpdCh0aGlzKSl7dmFyIG49cGkudHJhY2tpbmdDb250ZXh0O3RoaXMuRXQmJiFuJiYocGkudHJhY2tpbmdDb250ZXh0PXRoaXMpLHRoaXMudHJhY2tBbmRDb21wdXRlKCkmJmZ1bmN0aW9uKHQpe3QuRyE9PXNpLkMmJih0Lkc9c2kuQyx0LlguZm9yRWFjaCgoZnVuY3Rpb24obil7bi5SPT09c2kuSz9uLlI9c2kuQzpuLlI9PT1zaS5rJiYodC5HPXNpLmspfSkpKX0odGhpcykscGkudHJhY2tpbmdDb250ZXh0PW59fWVsc2UgaXQodGhpcykmJih0aGlzLlR0KCksZHQoKSx0aGlzLmp0PXRoaXMuQ3QoITEpLGJ0KCkpO3ZhciBpPXRoaXMuanQ7aWYobnQoaSkpdGhyb3cgaS5jYXVzZTtyZXR1cm4gaX0saS5zZXQ9ZnVuY3Rpb24obil7aWYodGhpcy5WdCl7dGhpcy5NdCYmdCgzMyx0aGlzLnR0KSx0aGlzLk10PSEwO3RyeXt0aGlzLlZ0LmNhbGwodGhpcy5OdCxuKX1maW5hbGx5e3RoaXMuTXQ9ITF9fWVsc2UgdCgzNCx0aGlzLnR0KX0saS50cmFja0FuZENvbXB1dGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmp0LG49dGhpcy5SPT09c2kuVCxpPXRoaXMuQ3QoITApLHI9bnx8bnQodCl8fG50KGkpfHwhdGhpcy5SdCh0LGkpO3JldHVybiByJiYodGhpcy5qdD1pKSxyfSxpLkN0PWZ1bmN0aW9uKHQpe3RoaXMuU3Q9ITA7dmFyIG4saT1aKCExKTtpZih0KW49cnQodGhpcyx0aGlzLmRlcml2YXRpb24sdGhpcy5OdCk7ZWxzZSBpZighMD09PXBpLmRpc2FibGVFcnJvckJvdW5kYXJpZXMpbj10aGlzLmRlcml2YXRpb24uY2FsbCh0aGlzLk50KTtlbHNlIHRyeXtuPXRoaXMuZGVyaXZhdGlvbi5jYWxsKHRoaXMuTnQpfWNhdGNoKHQpe249bmV3IGhpKHQpfXJldHVybiB0dChpKSx0aGlzLlN0PSExLG59LGkuVT1mdW5jdGlvbigpe3RoaXMuRXR8fChldCh0aGlzKSx0aGlzLmp0PXZvaWQgMCl9LGkuZ3Q9ZnVuY3Rpb24odCxuKXt2YXIgaT10aGlzLHI9ITAsZT12b2lkIDA7cmV0dXJuIGd0KChmdW5jdGlvbigpe3ZhciBvPWkuZ2V0KCk7aWYoIXJ8fG4pe3ZhciB1PXV0KCk7dCh7b2JzZXJ2YWJsZUtpbmQ6XCJjb21wdXRlZFwiLGRlYnVnT2JqZWN0TmFtZTppLnR0LHR5cGU6VGksb2JqZWN0OmksbmV3VmFsdWU6byxvbGRWYWx1ZTplfSksc3QodSl9cj0hMSxlPW99KSl9LGkuVHQ9ZnVuY3Rpb24oKXt9LGkudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50dCtcIltcIit0aGlzLmRlcml2YXRpb24udG9TdHJpbmcoKStcIl1cIn0saS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIGQodGhpcy5nZXQoKSl9LGlbZWldPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVPZigpfSxufSgpLGNpPWgoXCJDb21wdXRlZFZhbHVlXCIsYWkpOyFmdW5jdGlvbih0KXt0W3QuVD0tMV09XCJOT1RfVFJBQ0tJTkdfXCIsdFt0Lms9MF09XCJVUF9UT19EQVRFX1wiLHRbdC5LPTFdPVwiUE9TU0lCTFlfU1RBTEVfXCIsdFt0LkM9Ml09XCJTVEFMRV9cIn0oc2l8fChzaT17fSkpLGZ1bmN0aW9uKHQpe3RbdC5OT05FPTBdPVwiTk9ORVwiLHRbdC5MT0c9MV09XCJMT0dcIix0W3QuQlJFQUs9Ml09XCJCUkVBS1wifShmaXx8KGZpPXt9KSk7dmFyIGhpPWZ1bmN0aW9uKHQpe3RoaXMuY2F1c2U9dm9pZCAwLHRoaXMuY2F1c2U9dH0sdmk9W1wibW9ieEd1aWRcIixcInNweUxpc3RlbmVyc1wiLFwiZW5mb3JjZUFjdGlvbnNcIixcImNvbXB1dGVkUmVxdWlyZXNSZWFjdGlvblwiLFwicmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGVcIixcIm9ic2VydmFibGVSZXF1aXJlc1JlYWN0aW9uXCIsXCJhbGxvd1N0YXRlUmVhZHNcIixcImRpc2FibGVFcnJvckJvdW5kYXJpZXNcIixcInJ1bklkXCIsXCJVTkNIQU5HRURcIixcInVzZVByb3hpZXNcIl0sbGk9ZnVuY3Rpb24oKXt0aGlzLnZlcnNpb249Nix0aGlzLlVOQ0hBTkdFRD17fSx0aGlzLnRyYWNraW5nRGVyaXZhdGlvbj1udWxsLHRoaXMudHJhY2tpbmdDb250ZXh0PW51bGwsdGhpcy5ydW5JZD0wLHRoaXMubW9ieEd1aWQ9MCx0aGlzLmluQmF0Y2g9MCx0aGlzLnBlbmRpbmdVbm9ic2VydmF0aW9ucz1bXSx0aGlzLnBlbmRpbmdSZWFjdGlvbnM9W10sdGhpcy5pc1J1bm5pbmdSZWFjdGlvbnM9ITEsdGhpcy5hbGxvd1N0YXRlQ2hhbmdlcz0hMSx0aGlzLmFsbG93U3RhdGVSZWFkcz0hMCx0aGlzLmVuZm9yY2VBY3Rpb25zPSEwLHRoaXMuc3B5TGlzdGVuZXJzPVtdLHRoaXMuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzPVtdLHRoaXMuY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uPSExLHRoaXMucmVhY3Rpb25SZXF1aXJlc09ic2VydmFibGU9ITEsdGhpcy5vYnNlcnZhYmxlUmVxdWlyZXNSZWFjdGlvbj0hMSx0aGlzLmRpc2FibGVFcnJvckJvdW5kYXJpZXM9ITEsdGhpcy5zdXBwcmVzc1JlYWN0aW9uRXJyb3JzPSExLHRoaXMudXNlUHJveGllcz0hMCx0aGlzLnZlcmlmeVByb3hpZXM9ITEsdGhpcy5zYWZlRGVzY3JpcHRvcnM9ITB9LGRpPSEwLGJpPSExLHBpPWZ1bmN0aW9uKCl7dmFyIGk9bigpO3JldHVybiBpLl9fbW9ieEluc3RhbmNlQ291bnQ+MCYmIWkuX19tb2J4R2xvYmFscyYmKGRpPSExKSxpLl9fbW9ieEdsb2JhbHMmJmkuX19tb2J4R2xvYmFscy52ZXJzaW9uIT09KG5ldyBsaSkudmVyc2lvbiYmKGRpPSExKSxkaT9pLl9fbW9ieEdsb2JhbHM/KGkuX19tb2J4SW5zdGFuY2VDb3VudCs9MSxpLl9fbW9ieEdsb2JhbHMuVU5DSEFOR0VEfHwoaS5fX21vYnhHbG9iYWxzLlVOQ0hBTkdFRD17fSksaS5fX21vYnhHbG9iYWxzKTooaS5fX21vYnhJbnN0YW5jZUNvdW50PTEsaS5fX21vYnhHbG9iYWxzPW5ldyBsaSk6KHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7Yml8fHQoMzUpfSksMSksbmV3IGxpKX0oKSx5aT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxuLGkscil7dm9pZCAwPT09dCYmKHQ9XCJSZWFjdGlvblwiKSx2b2lkIDA9PT1yJiYocj0hMSksdGhpcy50dD12b2lkIDAsdGhpcy5LdD12b2lkIDAsdGhpcy5MdD12b2lkIDAsdGhpcy5JdD12b2lkIDAsdGhpcy5MPVtdLHRoaXMuST1bXSx0aGlzLlI9c2kuVCx0aGlzLkI9MCx0aGlzLkQ9MCx0aGlzLlA9MCx0aGlzLko9ITEsdGhpcy5QdD0hMSx0aGlzLkR0PSExLHRoaXMuQnQ9ITEsdGhpcy5vdD1maS5OT05FLHRoaXMudHQ9dCx0aGlzLkt0PW4sdGhpcy5MdD1pLHRoaXMuSXQ9cn12YXIgbj10LnByb3RvdHlwZTtyZXR1cm4gbi5xPWZ1bmN0aW9uKCl7dGhpcy5ZKCl9LG4uWT1mdW5jdGlvbigpe3RoaXMuUHR8fCh0aGlzLlB0PSEwLHBpLnBlbmRpbmdSZWFjdGlvbnMucHVzaCh0aGlzKSxtdCgpKX0sbi5pc1NjaGVkdWxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLlB0fSxuLiQ9ZnVuY3Rpb24oKXtpZighdGhpcy5KKXtkdCgpLHRoaXMuUHQ9ITE7dmFyIHQ9cGkudHJhY2tpbmdDb250ZXh0O2lmKHBpLnRyYWNraW5nQ29udGV4dD10aGlzLGl0KHRoaXMpKXt0aGlzLkR0PSEwO3RyeXt0aGlzLkt0KCl9Y2F0Y2godCl7dGhpcy5xdCh0KX19cGkudHJhY2tpbmdDb250ZXh0PXQsYnQoKX19LG4udHJhY2s9ZnVuY3Rpb24odCl7aWYoIXRoaXMuSil7ZHQoKSx0aGlzLkJ0PSEwO3ZhciBuPXBpLnRyYWNraW5nQ29udGV4dDtwaS50cmFja2luZ0NvbnRleHQ9dGhpczt2YXIgaT1ydCh0aGlzLHQsdm9pZCAwKTtwaS50cmFja2luZ0NvbnRleHQ9bix0aGlzLkJ0PSExLHRoaXMuRHQ9ITEsdGhpcy5KJiZldCh0aGlzKSxudChpKSYmdGhpcy5xdChpLmNhdXNlKSxidCgpfX0sbi5xdD1mdW5jdGlvbih0KXt2YXIgbj10aGlzO2lmKHRoaXMuTHQpdGhpcy5MdCh0LHRoaXMpO2Vsc2V7aWYocGkuZGlzYWJsZUVycm9yQm91bmRhcmllcyl0aHJvdyB0O3BpLnN1cHByZXNzUmVhY3Rpb25FcnJvcnN8fGNvbnNvbGUuZXJyb3IoXCJbbW9ieF0gdW5jYXVnaHQgZXJyb3IgaW4gJ1wiK3RoaXMrXCInXCIsdCkscGkuZ2xvYmFsUmVhY3Rpb25FcnJvckhhbmRsZXJzLmZvckVhY2goKGZ1bmN0aW9uKGkpe3JldHVybiBpKHQsbil9KSl9fSxuLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLkp8fCh0aGlzLko9ITAsdGhpcy5CdHx8KGR0KCksZXQodGhpcyksYnQoKSkpfSxuLlo9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmRpc3Bvc2UuYmluZCh0aGlzKTtyZXR1cm4gdFtLbl09dGhpcyx0fSxuLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJSZWFjdGlvbltcIit0aGlzLnR0K1wiXVwifSxuLnRyYWNlPWZ1bmN0aW9uKHQpe3ZvaWQgMD09PXQmJih0PSExKSxHdCh0aGlzLHQpfSx0fSgpLG1pPWZ1bmN0aW9uKHQpe3JldHVybiB0KCl9LHdpPWgoXCJSZWFjdGlvblwiLHlpKSxqaT1WKFwiYWN0aW9uXCIpLHhpPVYoXCJhY3Rpb24uYm91bmRcIix7Ym91bmQ6ITB9KSxPaT1WKFwiYXV0b0FjdGlvblwiLHthdXRvQWN0aW9uOiEwfSksQWk9VihcImF1dG9BY3Rpb24uYm91bmRcIix7YXV0b0FjdGlvbjohMCxib3VuZDohMH0pLGdpPXh0KCExKTtPYmplY3QuYXNzaWduKGdpLGppKTt2YXIgX2k9eHQoITApO09iamVjdC5hc3NpZ24oX2ksT2kpLGdpLmJvdW5kPUEoeGkpLF9pLmJvdW5kPUEoQWkpO3ZhciBTaT1mdW5jdGlvbih0KXtyZXR1cm4gdCgpfSxNaT0wO0V0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7dmFyIFZpPUUoXCJmbG93XCIpLE5pPUUoXCJmbG93LmJvdW5kXCIse2JvdW5kOiEwfSksUmk9T2JqZWN0LmFzc2lnbigoZnVuY3Rpb24odCxuKXtpZihvKG4pKXJldHVybiBnKHQsbixWaSk7dmFyIGk9dCxyPWkubmFtZXx8XCI8dW5uYW1lZCBmbG93PlwiLHU9ZnVuY3Rpb24oKXt2YXIgdCxuPXRoaXMsbz1hcmd1bWVudHMsdT0rK01pLHM9Z2kocitcIiAtIHJ1bmlkOiBcIit1K1wiIC0gaW5pdFwiLGkpLmFwcGx5KG4sbyksZj12b2lkIDAsYT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24obixpKXtmdW5jdGlvbiBvKHQpe3ZhciBuO2Y9dm9pZCAwO3RyeXtuPWdpKHIrXCIgLSBydW5pZDogXCIrdStcIiAtIHlpZWxkIFwiK2grKyxzLm5leHQpLmNhbGwocyx0KX1jYXRjaCh0KXtyZXR1cm4gaSh0KX1jKG4pfWZ1bmN0aW9uIGEodCl7dmFyIG47Zj12b2lkIDA7dHJ5e249Z2kocitcIiAtIHJ1bmlkOiBcIit1K1wiIC0geWllbGQgXCIraCsrLHMudGhyb3cpLmNhbGwocyx0KX1jYXRjaCh0KXtyZXR1cm4gaSh0KX1jKG4pfWZ1bmN0aW9uIGModCl7aWYoIWUobnVsbD09dD92b2lkIDA6dC50aGVuKSlyZXR1cm4gdC5kb25lP24odC52YWx1ZSk6KGY9UHJvbWlzZS5yZXNvbHZlKHQudmFsdWUpKS50aGVuKG8sYSk7dC50aGVuKGMsaSl9dmFyIGg9MDt0PWksbyh2b2lkIDApfSkpO3JldHVybiBhLmNhbmNlbD1naShyK1wiIC0gcnVuaWQ6IFwiK3UrXCIgLSBjYW5jZWxcIiwoZnVuY3Rpb24oKXt0cnl7ZiYmVHQoZik7dmFyIG49cy5yZXR1cm4odm9pZCAwKSxpPVByb21pc2UucmVzb2x2ZShuLnZhbHVlKTtpLnRoZW4oUm4sUm4pLFR0KGkpLHQobmV3IEV0KX1jYXRjaChuKXt0KG4pfX0pKSxhfTtyZXR1cm4gdS5pc01vYlhGbG93PSEwLHV9KSxWaSk7UmkuYm91bmQ9QShOaSk7dmFyIGtpPXtoYXM6ZnVuY3Rpb24odCxuKXtyZXR1cm4gRnQodCkucnQobil9LGdldDpmdW5jdGlvbih0LG4pe3JldHVybiBGdCh0KS5sdChuKX0sc2V0OmZ1bmN0aW9uKHQsbixpKXt2YXIgcjtyZXR1cm4hIW8obikmJihudWxsPT0ocj1GdCh0KS5kdChuLGksITApKXx8cil9LGRlbGV0ZVByb3BlcnR5OmZ1bmN0aW9uKHQsbil7dmFyIGk7cmV0dXJuISFvKG4pJiYobnVsbD09KGk9RnQodCkuR3QobiwhMCkpfHxpKX0sZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24odCxuLGkpe3ZhciByO3JldHVybiBudWxsPT0ocj1GdCh0KS5oKG4saSkpfHxyfSxvd25LZXlzOmZ1bmN0aW9uKHQpe3JldHVybiBGdCh0KS5ldCgpfSxwcmV2ZW50RXh0ZW5zaW9uczpmdW5jdGlvbigpe3QoMTMpfX0sRWk9U3ltYm9sKFwibW9ieC1rZXlzXCIpLFRpPVwidXBkYXRlXCIsQ2k9e2dldDpmdW5jdGlvbih0LG4pe3ZhciBpPXRbS25dO3JldHVybiBuPT09S24/aTpcImxlbmd0aFwiPT09bj9pLlh0KCk6XCJzdHJpbmdcIiE9dHlwZW9mIG58fGlzTmFOKG4pP2IoTGksbik/TGlbbl06dFtuXTppLmx0KHBhcnNlSW50KG4pKX0sc2V0OmZ1bmN0aW9uKHQsbixpKXt2YXIgcj10W0tuXTtyZXR1cm5cImxlbmd0aFwiPT09biYmci5XdChpKSxcInN5bWJvbFwiPT10eXBlb2Ygbnx8aXNOYU4obik/dFtuXT1pOnIuZHQocGFyc2VJbnQobiksaSksITB9LHByZXZlbnRFeHRlbnNpb25zOmZ1bmN0aW9uKCl7dCgxNSl9fSxLaT1mdW5jdGlvbigpe2Z1bmN0aW9uIG4odCxuLGkscil7dm9pZCAwPT09dCYmKHQ9XCJPYnNlcnZhYmxlQXJyYXlcIiksdGhpcy5IdD12b2lkIDAsdGhpcy5VdD12b2lkIDAsdGhpcy5hdD12b2lkIDAsdGhpcy5udD1bXSx0aGlzLnV0PXZvaWQgMCx0aGlzLnN0PXZvaWQgMCx0aGlzLkZ0PXZvaWQgMCx0aGlzLmRlaGFuY2VyPXZvaWQgMCx0aGlzLnY9dm9pZCAwLHRoaXMuenQ9MCx0aGlzLkh0PWksdGhpcy5VdD1yLHRoaXMuYXQ9bmV3IExuKHQpLHRoaXMuRnQ9ZnVuY3Rpb24odCxpKXtyZXR1cm4gbih0LGksXCJPYnNlcnZhYmxlQXJyYXlbLi5dXCIpfX12YXIgaT1uLnByb3RvdHlwZTtyZXR1cm4gaS4kdD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dGhpcy5kZWhhbmNlcj90aGlzLmRlaGFuY2VyKHQpOnR9LGkuY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuZGVoYW5jZXImJnQubGVuZ3RoPjA/dC5tYXAodGhpcy5kZWhhbmNlcik6dH0saS5BdD1mdW5jdGlvbih0KXtyZXR1cm4gJHQodGhpcyx0KX0saS5ndD1mdW5jdGlvbih0LG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0hMSksbiYmdCh7b2JzZXJ2YWJsZUtpbmQ6XCJhcnJheVwiLG9iamVjdDp0aGlzLnYsZGVidWdPYmplY3ROYW1lOnRoaXMuYXQudHQsdHlwZTpcInNwbGljZVwiLGluZGV4OjAsYWRkZWQ6dGhpcy5udC5zbGljZSgpLGFkZGVkQ291bnQ6dGhpcy5udC5sZW5ndGgscmVtb3ZlZDpbXSxyZW1vdmVkQ291bnQ6MH0pLFF0KHRoaXMsdCl9LGkuWHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hdC5yZXBvcnRPYnNlcnZlZCgpLHRoaXMubnQubGVuZ3RofSxpLld0PWZ1bmN0aW9uKG4peyhcIm51bWJlclwiIT10eXBlb2Ygbnx8bjwwKSYmdChcIk91dCBvZiByYW5nZTogXCIrbik7dmFyIGk9dGhpcy5udC5sZW5ndGg7aWYobiE9PWkpaWYobj5pKXtmb3IodmFyIHI9bmV3IEFycmF5KG4taSksZT0wO2U8bi1pO2UrKylyW2VdPXZvaWQgMDt0aGlzLmZ0KGksMCxyKX1lbHNlIHRoaXMuZnQobixpLW4pfSxpLkp0PWZ1bmN0aW9uKG4saSl7biE9PXRoaXMuenQmJnQoMTYpLHRoaXMuenQrPWksdGhpcy5VdCYmaT4wJiZ2bihuK2krMSl9LGkuZnQ9ZnVuY3Rpb24odCxuLGkpe3ZhciByPXRoaXMsZT10aGlzLm50Lmxlbmd0aDtpZih2b2lkIDA9PT10P3Q9MDp0PmU/dD1lOnQ8MCYmKHQ9TWF0aC5tYXgoMCxlK3QpKSxuPTE9PT1hcmd1bWVudHMubGVuZ3RoP2UtdDpudWxsPT1uPzA6TWF0aC5tYXgoMCxNYXRoLm1pbihuLGUtdCkpLHZvaWQgMD09PWkmJihpPVNuKSx6dCh0aGlzKSl7dmFyIG89SnQodGhpcyx7b2JqZWN0OnRoaXMudix0eXBlOlwic3BsaWNlXCIsaW5kZXg6dCxyZW1vdmVkQ291bnQ6bixhZGRlZDppfSk7aWYoIW8pcmV0dXJuIFNuO249by5yZW1vdmVkQ291bnQsaT1vLmFkZGVkfWlmKGk9MD09PWkubGVuZ3RoP2k6aS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiByLkZ0KHQsdm9pZCAwKX0pKSx0aGlzLlV0KXt2YXIgdT1pLmxlbmd0aC1uO3RoaXMuSnQoZSx1KX12YXIgcz10aGlzLll0KHQsbixpKTtyZXR1cm4gMD09PW4mJjA9PT1pLmxlbmd0aHx8dGhpcy5RdCh0LGkscyksdGhpcy5jdChzKX0saS5ZdD1mdW5jdGlvbih0LG4saSl7dmFyIHI7aWYoaS5sZW5ndGg8MWU0KXJldHVybihyPXRoaXMubnQpLnNwbGljZS5hcHBseShyLFt0LG5dLmNvbmNhdChpKSk7dmFyIGU9dGhpcy5udC5zbGljZSh0LHQrbiksbz10aGlzLm50LnNsaWNlKHQrbik7dGhpcy5udC5sZW5ndGg9dCtpLmxlbmd0aC1uO2Zvcih2YXIgdT0wO3U8aS5sZW5ndGg7dSsrKXRoaXMubnRbdCt1XT1pW3VdO2Zvcih2YXIgcz0wO3M8by5sZW5ndGg7cysrKXRoaXMubnRbdCtpLmxlbmd0aCtzXT1vW3NdO3JldHVybiBlfSxpLlp0PWZ1bmN0aW9uKHQsbixpKXt2YXIgcj0hdGhpcy5IdCYmITEsZT1ZdCh0aGlzKSxvPWV8fHI/e29ic2VydmFibGVLaW5kOlwiYXJyYXlcIixvYmplY3Q6dGhpcy52LHR5cGU6VGksZGVidWdPYmplY3ROYW1lOnRoaXMuYXQudHQsaW5kZXg6dCxuZXdWYWx1ZTpuLG9sZFZhbHVlOml9Om51bGw7dGhpcy5hdC5yZXBvcnRDaGFuZ2VkKCksZSYmWnQodGhpcyxvKX0saS5RdD1mdW5jdGlvbih0LG4saSl7dmFyIHI9IXRoaXMuSHQmJiExLGU9WXQodGhpcyksbz1lfHxyP3tvYnNlcnZhYmxlS2luZDpcImFycmF5XCIsb2JqZWN0OnRoaXMudixkZWJ1Z09iamVjdE5hbWU6dGhpcy5hdC50dCx0eXBlOlwic3BsaWNlXCIsaW5kZXg6dCxyZW1vdmVkOmksYWRkZWQ6bixyZW1vdmVkQ291bnQ6aS5sZW5ndGgsYWRkZWRDb3VudDpuLmxlbmd0aH06bnVsbDt0aGlzLmF0LnJlcG9ydENoYW5nZWQoKSxlJiZadCh0aGlzLG8pfSxpLmx0PWZ1bmN0aW9uKHQpe2lmKHQ8dGhpcy5udC5sZW5ndGgpcmV0dXJuIHRoaXMuYXQucmVwb3J0T2JzZXJ2ZWQoKSx0aGlzLiR0KHRoaXMubnRbdF0pO2NvbnNvbGUud2FybihcIlttb2J4LmFycmF5XSBBdHRlbXB0IHRvIHJlYWQgYW4gYXJyYXkgaW5kZXggKFwiK3QrXCIpIHRoYXQgaXMgb3V0IG9mIGJvdW5kcyAoXCIrdGhpcy5udC5sZW5ndGgrXCIpLiBQbGVhc2UgY2hlY2sgbGVuZ3RoIGZpcnN0LiBPdXQgb2YgYm91bmQgaW5kaWNlcyB3aWxsIG5vdCBiZSB0cmFja2VkIGJ5IE1vYlhcIil9LGkuZHQ9ZnVuY3Rpb24obixpKXt2YXIgcj10aGlzLm50O2lmKG48ci5sZW5ndGgpe3ZhciBlPXJbbl07aWYoenQodGhpcykpe3ZhciBvPUp0KHRoaXMse3R5cGU6VGksb2JqZWN0OnRoaXMudixpbmRleDpuLG5ld1ZhbHVlOml9KTtpZighbylyZXR1cm47aT1vLm5ld1ZhbHVlfShpPXRoaXMuRnQoaSxlKSkhPT1lJiYocltuXT1pLHRoaXMuWnQobixpLGUpKX1lbHNlIG49PT1yLmxlbmd0aD90aGlzLmZ0KG4sMCxbaV0pOnQoMTcsbixyLmxlbmd0aCl9LG59KCksTGk9e2NsZWFyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3BsaWNlKDApfSxyZXBsYWNlOmZ1bmN0aW9uKHQpe3ZhciBuPXRoaXNbS25dO3JldHVybiBuLmZ0KDAsbi5udC5sZW5ndGgsdCl9LHRvSlNPTjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNsaWNlKCl9LHNwbGljZTpmdW5jdGlvbih0LG4pe2Zvcih2YXIgaT1hcmd1bWVudHMubGVuZ3RoLHI9bmV3IEFycmF5KGk+Mj9pLTI6MCksZT0yO2U8aTtlKyspcltlLTJdPWFyZ3VtZW50c1tlXTt2YXIgbz10aGlzW0tuXTtzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybltdO2Nhc2UgMTpyZXR1cm4gby5mdCh0KTtjYXNlIDI6cmV0dXJuIG8uZnQodCxuKX1yZXR1cm4gby5mdCh0LG4scil9LHNwbGljZVdpdGhBcnJheTpmdW5jdGlvbih0LG4saSl7cmV0dXJuIHRoaXNbS25dLmZ0KHQsbixpKX0scHVzaDpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzW0tuXSxuPWFyZ3VtZW50cy5sZW5ndGgsaT1uZXcgQXJyYXkobikscj0wO3I8bjtyKyspaVtyXT1hcmd1bWVudHNbcl07cmV0dXJuIHQuZnQodC5udC5sZW5ndGgsMCxpKSx0Lm50Lmxlbmd0aH0scG9wOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3BsaWNlKE1hdGgubWF4KHRoaXNbS25dLm50Lmxlbmd0aC0xLDApLDEpWzBdfSxzaGlmdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNwbGljZSgwLDEpWzBdfSx1bnNoaWZ0OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXNbS25dLG49YXJndW1lbnRzLmxlbmd0aCxpPW5ldyBBcnJheShuKSxyPTA7cjxuO3IrKylpW3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4gdC5mdCgwLDAsaSksdC5udC5sZW5ndGh9LHJldmVyc2U6ZnVuY3Rpb24oKXtyZXR1cm4gcGkudHJhY2tpbmdEZXJpdmF0aW9uJiZ0KDM3LFwicmV2ZXJzZVwiKSx0aGlzLnJlcGxhY2UodGhpcy5zbGljZSgpLnJldmVyc2UoKSksdGhpc30sc29ydDpmdW5jdGlvbigpe3BpLnRyYWNraW5nRGVyaXZhdGlvbiYmdCgzNyxcInNvcnRcIik7dmFyIG49dGhpcy5zbGljZSgpO3JldHVybiBuLnNvcnQuYXBwbHkobixhcmd1bWVudHMpLHRoaXMucmVwbGFjZShuKSx0aGlzfSxyZW1vdmU6ZnVuY3Rpb24odCl7dmFyIG49dGhpc1tLbl0saT1uLmN0KG4ubnQpLmluZGV4T2YodCk7cmV0dXJuIGk+LTEmJih0aGlzLnNwbGljZShpLDEpLCEwKX19O25uKFwiY29uY2F0XCIscm4pLG5uKFwiZmxhdFwiLHJuKSxubihcImluY2x1ZGVzXCIscm4pLG5uKFwiaW5kZXhPZlwiLHJuKSxubihcImpvaW5cIixybiksbm4oXCJsYXN0SW5kZXhPZlwiLHJuKSxubihcInNsaWNlXCIscm4pLG5uKFwidG9TdHJpbmdcIixybiksbm4oXCJ0b0xvY2FsZVN0cmluZ1wiLHJuKSxubihcImV2ZXJ5XCIsZW4pLG5uKFwiZmlsdGVyXCIsZW4pLG5uKFwiZmluZFwiLGVuKSxubihcImZpbmRJbmRleFwiLGVuKSxubihcImZsYXRNYXBcIixlbiksbm4oXCJmb3JFYWNoXCIsZW4pLG5uKFwibWFwXCIsZW4pLG5uKFwic29tZVwiLGVuKSxubihcInJlZHVjZVwiLG9uKSxubihcInJlZHVjZVJpZ2h0XCIsb24pO3ZhciBJaSxQaSxEaT1oKFwiT2JzZXJ2YWJsZUFycmF5QWRtaW5pc3RyYXRpb25cIixLaSksQmk9e30scWk9XCJhZGRcIjtJaT1TeW1ib2wuaXRlcmF0b3IsUGk9U3ltYm9sLnRvU3RyaW5nVGFnO3ZhciBHaSxYaSxXaT1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obixpLHIpe3ZvaWQgMD09PWkmJihpPVMpLHZvaWQgMD09PXImJihyPVwiT2JzZXJ2YWJsZU1hcFwiKSx0aGlzLkZ0PXZvaWQgMCx0aGlzLnR0PXZvaWQgMCx0aGlzW0tuXT1CaSx0aGlzLnB0PXZvaWQgMCx0aGlzLnl0PXZvaWQgMCx0aGlzLmJ0PXZvaWQgMCx0aGlzLnV0PXZvaWQgMCx0aGlzLnN0PXZvaWQgMCx0aGlzLmRlaGFuY2VyPXZvaWQgMCx0aGlzLkZ0PWksdGhpcy50dD1yLGUoTWFwKXx8dCgxOCksdGhpcy5idD1fKFwiT2JzZXJ2YWJsZU1hcC5rZXlzKClcIiksdGhpcy5wdD1uZXcgTWFwLHRoaXMueXQ9bmV3IE1hcCx0aGlzLm1lcmdlKG4pfXZhciBpPW4ucHJvdG90eXBlO3JldHVybiBpLnJ0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnB0Lmhhcyh0KX0saS5oYXM9ZnVuY3Rpb24odCl7dmFyIG49dGhpcztpZighcGkudHJhY2tpbmdEZXJpdmF0aW9uKXJldHVybiB0aGlzLnJ0KHQpO3ZhciBpPXRoaXMueXQuZ2V0KHQpO2lmKCFpKXt2YXIgcj1pPW5ldyBvaSh0aGlzLnJ0KHQpLE0sXCJPYnNlcnZhYmxlTWFwLmtleT9cIiwhMSk7dGhpcy55dC5zZXQodCxyKSxNdChyLChmdW5jdGlvbigpe3JldHVybiBuLnl0LmRlbGV0ZSh0KX0pKX1yZXR1cm4gaS5nZXQoKX0saS5zZXQ9ZnVuY3Rpb24odCxuKXt2YXIgaT10aGlzLnJ0KHQpO2lmKHp0KHRoaXMpKXt2YXIgcj1KdCh0aGlzLHt0eXBlOmk/VGk6cWksb2JqZWN0OnRoaXMsbmV3VmFsdWU6bixuYW1lOnR9KTtpZighcilyZXR1cm4gdGhpcztuPXIubmV3VmFsdWV9cmV0dXJuIGk/dGhpcy50bih0LG4pOnRoaXMubm4odCxuKSx0aGlzfSxpLmRlbGV0ZT1mdW5jdGlvbih0KXt2YXIgbj10aGlzO2lmKHp0KHRoaXMpJiYhSnQodGhpcyx7dHlwZTpcImRlbGV0ZVwiLG9iamVjdDp0aGlzLG5hbWU6dH0pKXJldHVybiExO2lmKHRoaXMucnQodCkpe3ZhciBpPVl0KHRoaXMpLHI9aT97b2JzZXJ2YWJsZUtpbmQ6XCJtYXBcIixkZWJ1Z09iamVjdE5hbWU6dGhpcy50dCx0eXBlOlwiZGVsZXRlXCIsb2JqZWN0OnRoaXMsb2xkVmFsdWU6dGhpcy5wdC5nZXQodCkuanQsbmFtZTp0fTpudWxsO3JldHVybiBXdCgoZnVuY3Rpb24oKXtuLmJ0LnJlcG9ydENoYW5nZWQoKSxuLmluKHQsITEpLG4ucHQuZ2V0KHQpLk90KHZvaWQgMCksbi5wdC5kZWxldGUodCl9KSksaSYmWnQodGhpcyxyKSwhMH1yZXR1cm4hMX0saS5pbj1mdW5jdGlvbih0LG4pe3ZhciBpPXRoaXMueXQuZ2V0KHQpO2kmJmkuT3Qobil9LGkudG49ZnVuY3Rpb24odCxuKXt2YXIgaT10aGlzLnB0LmdldCh0KTtpZigobj1pLnh0KG4pKSE9PXBpLlVOQ0hBTkdFRCl7dmFyIHI9WXQodGhpcyksZT1yP3tvYnNlcnZhYmxlS2luZDpcIm1hcFwiLGRlYnVnT2JqZWN0TmFtZTp0aGlzLnR0LHR5cGU6VGksb2JqZWN0OnRoaXMsb2xkVmFsdWU6aS5qdCxuYW1lOnQsbmV3VmFsdWU6bn06bnVsbDtpLk90KG4pLHImJlp0KHRoaXMsZSl9fSxpLm5uPWZ1bmN0aW9uKHQsbil7dmFyIGk9dGhpcztXdCgoZnVuY3Rpb24oKXt2YXIgcj1uZXcgb2kobixpLkZ0LFwiT2JzZXJ2YWJsZU1hcC5rZXlcIiwhMSk7aS5wdC5zZXQodCxyKSxuPXIuanQsaS5pbih0LCEwKSxpLmJ0LnJlcG9ydENoYW5nZWQoKX0pKTt2YXIgcj1ZdCh0aGlzKTtyJiZadCh0aGlzLHI/e29ic2VydmFibGVLaW5kOlwibWFwXCIsZGVidWdPYmplY3ROYW1lOnRoaXMudHQsdHlwZTpxaSxvYmplY3Q6dGhpcyxuYW1lOnQsbmV3VmFsdWU6bn06bnVsbCl9LGkuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmhhcyh0KT90aGlzLiR0KHRoaXMucHQuZ2V0KHQpLmdldCgpKTp0aGlzLiR0KHZvaWQgMCl9LGkuJHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuZGVoYW5jZXI/dGhpcy5kZWhhbmNlcih0KTp0fSxpLmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idC5yZXBvcnRPYnNlcnZlZCgpLHRoaXMucHQua2V5cygpfSxpLnZhbHVlcz1mdW5jdGlvbigpe3ZhciB0PXRoaXMsbj10aGlzLmtleXMoKTtyZXR1cm4gd24oe25leHQ6ZnVuY3Rpb24oKXt2YXIgaT1uLm5leHQoKSxyPWkuZG9uZTtyZXR1cm57ZG9uZTpyLHZhbHVlOnI/dm9pZCAwOnQuZ2V0KGkudmFsdWUpfX19KX0saS5lbnRyaWVzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxuPXRoaXMua2V5cygpO3JldHVybiB3bih7bmV4dDpmdW5jdGlvbigpe3ZhciBpPW4ubmV4dCgpLHI9aS5kb25lLGU9aS52YWx1ZTtyZXR1cm57ZG9uZTpyLHZhbHVlOnI/dm9pZCAwOltlLHQuZ2V0KGUpXX19fSl9LGlbSWldPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW50cmllcygpfSxpLmZvckVhY2g9ZnVuY3Rpb24odCxuKXtmb3IodmFyIGkscj1PKHRoaXMpOyEoaT1yKCkpLmRvbmU7KXt2YXIgZT1pLnZhbHVlO3QuY2FsbChuLGVbMV0sZVswXSx0aGlzKX19LGkubWVyZ2U9ZnVuY3Rpb24obil7dmFyIGk9dGhpcztyZXR1cm4gSGkobikmJihuPW5ldyBNYXAobikpLFd0KChmdW5jdGlvbigpe3Mobik/ZnVuY3Rpb24odCl7dmFyIG49T2JqZWN0LmtleXModCk7aWYoIWtuKXJldHVybiBuO3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCk7cmV0dXJuIGkubGVuZ3RoP1tdLmNvbmNhdChuLGkuZmlsdGVyKChmdW5jdGlvbihuKXtyZXR1cm4gX24ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0LG4pfSkpKTpufShuKS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gaS5zZXQodCxuW3RdKX0pKTpBcnJheS5pc0FycmF5KG4pP24uZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGkuc2V0KHRbMF0sdFsxXSl9KSk6dihuKT8obi5jb25zdHJ1Y3RvciE9PU1hcCYmdCgxOSxuKSxuLmZvckVhY2goKGZ1bmN0aW9uKHQsbil7cmV0dXJuIGkuc2V0KG4sdCl9KSkpOm51bGwhPW4mJnQoMjAsbil9KSksdGhpc30saS5jbGVhcj1mdW5jdGlvbigpe3ZhciB0PXRoaXM7V3QoKGZ1bmN0aW9uKCl7b3QoKGZ1bmN0aW9uKCl7Zm9yKHZhciBuLGk9Tyh0LmtleXMoKSk7IShuPWkoKSkuZG9uZTspdC5kZWxldGUobi52YWx1ZSl9KSl9KSl9LGkucmVwbGFjZT1mdW5jdGlvbihuKXt2YXIgaT10aGlzO3JldHVybiBXdCgoZnVuY3Rpb24oKXtmb3IodmFyIHIsZT1mdW5jdGlvbihuKXtpZih2KG4pfHxIaShuKSlyZXR1cm4gbjtpZihBcnJheS5pc0FycmF5KG4pKXJldHVybiBuZXcgTWFwKG4pO2lmKHMobikpe3ZhciBpPW5ldyBNYXA7Zm9yKHZhciByIGluIG4paS5zZXQocixuW3JdKTtyZXR1cm4gaX1yZXR1cm4gdCgyMSxuKX0obiksbz1uZXcgTWFwLHU9ITEsZj1PKGkucHQua2V5cygpKTshKHI9ZigpKS5kb25lOyl7dmFyIGE9ci52YWx1ZTtpZighZS5oYXMoYSkpaWYoaS5kZWxldGUoYSkpdT0hMDtlbHNle3ZhciBjPWkucHQuZ2V0KGEpO28uc2V0KGEsYyl9fWZvcih2YXIgaCxsPU8oZS5lbnRyaWVzKCkpOyEoaD1sKCkpLmRvbmU7KXt2YXIgZD1oLnZhbHVlLGI9ZFswXSxwPWRbMV0seT1pLnB0LmhhcyhiKTtpZihpLnNldChiLHApLGkucHQuaGFzKGIpKXt2YXIgbT1pLnB0LmdldChiKTtvLnNldChiLG0pLHl8fCh1PSEwKX19aWYoIXUpaWYoaS5wdC5zaXplIT09by5zaXplKWkuYnQucmVwb3J0Q2hhbmdlZCgpO2Vsc2UgZm9yKHZhciB3PWkucHQua2V5cygpLGo9by5rZXlzKCkseD13Lm5leHQoKSxBPWoubmV4dCgpOyF4LmRvbmU7KXtpZih4LnZhbHVlIT09QS52YWx1ZSl7aS5idC5yZXBvcnRDaGFuZ2VkKCk7YnJlYWt9eD13Lm5leHQoKSxBPWoubmV4dCgpfWkucHQ9b30pKSx0aGlzfSxpLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJbb2JqZWN0IE9ic2VydmFibGVNYXBdXCJ9LGkudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5LmZyb20odGhpcyl9LGkuZ3Q9ZnVuY3Rpb24odCl7cmV0dXJuIFF0KHRoaXMsdCl9LGkuQXQ9ZnVuY3Rpb24odCl7cmV0dXJuICR0KHRoaXMsdCl9LHkobixbe2tleTpcInNpemVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idC5yZXBvcnRPYnNlcnZlZCgpLHRoaXMucHQuc2l6ZX19LHtrZXk6UGksZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCJNYXBcIn19XSksbn0oKSxIaT1oKFwiT2JzZXJ2YWJsZU1hcFwiLFdpKSxVaT17fTtHaT1TeW1ib2wuaXRlcmF0b3IsWGk9U3ltYm9sLnRvU3RyaW5nVGFnO3ZhciBGaSx6aSwkaT1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obixpLHIpe3ZvaWQgMD09PWkmJihpPVMpLHZvaWQgMD09PXImJihyPVwiT2JzZXJ2YWJsZVNldFwiKSx0aGlzLnR0PXZvaWQgMCx0aGlzW0tuXT1VaSx0aGlzLnB0PW5ldyBTZXQsdGhpcy5hdD12b2lkIDAsdGhpcy5zdD12b2lkIDAsdGhpcy51dD12b2lkIDAsdGhpcy5kZWhhbmNlcj12b2lkIDAsdGhpcy5GdD12b2lkIDAsdGhpcy50dD1yLGUoU2V0KXx8dCgyMiksdGhpcy5hdD1fKHRoaXMudHQpLHRoaXMuRnQ9ZnVuY3Rpb24odCxuKXtyZXR1cm4gaSh0LG4scil9LG4mJnRoaXMucmVwbGFjZShuKX12YXIgaT1uLnByb3RvdHlwZTtyZXR1cm4gaS4kdD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dGhpcy5kZWhhbmNlcj90aGlzLmRlaGFuY2VyKHQpOnR9LGkuY2xlYXI9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO1d0KChmdW5jdGlvbigpe290KChmdW5jdGlvbigpe2Zvcih2YXIgbixpPU8odC5wdC52YWx1ZXMoKSk7IShuPWkoKSkuZG9uZTspdC5kZWxldGUobi52YWx1ZSl9KSl9KSl9LGkuZm9yRWFjaD1mdW5jdGlvbih0LG4pe2Zvcih2YXIgaSxyPU8odGhpcyk7IShpPXIoKSkuZG9uZTspe3ZhciBlPWkudmFsdWU7dC5jYWxsKG4sZSxlLHRoaXMpfX0saS5hZGQ9ZnVuY3Rpb24odCl7dmFyIG49dGhpcztpZih6dCh0aGlzKSYmIUp0KHRoaXMse3R5cGU6cWksb2JqZWN0OnRoaXMsbmV3VmFsdWU6dH0pKXJldHVybiB0aGlzO2lmKCF0aGlzLmhhcyh0KSl7V3QoKGZ1bmN0aW9uKCl7bi5wdC5hZGQobi5GdCh0LHZvaWQgMCkpLG4uYXQucmVwb3J0Q2hhbmdlZCgpfSkpO3ZhciBpPVl0KHRoaXMpO2kmJlp0KHRoaXMsaT97b2JzZXJ2YWJsZUtpbmQ6XCJzZXRcIixkZWJ1Z09iamVjdE5hbWU6dGhpcy50dCx0eXBlOnFpLG9iamVjdDp0aGlzLG5ld1ZhbHVlOnR9Om51bGwpfXJldHVybiB0aGlzfSxpLmRlbGV0ZT1mdW5jdGlvbih0KXt2YXIgbj10aGlzO2lmKHp0KHRoaXMpJiYhSnQodGhpcyx7dHlwZTpcImRlbGV0ZVwiLG9iamVjdDp0aGlzLG9sZFZhbHVlOnR9KSlyZXR1cm4hMTtpZih0aGlzLmhhcyh0KSl7dmFyIGk9WXQodGhpcykscj1pP3tvYnNlcnZhYmxlS2luZDpcInNldFwiLGRlYnVnT2JqZWN0TmFtZTp0aGlzLnR0LHR5cGU6XCJkZWxldGVcIixvYmplY3Q6dGhpcyxvbGRWYWx1ZTp0fTpudWxsO3JldHVybiBXdCgoZnVuY3Rpb24oKXtuLmF0LnJlcG9ydENoYW5nZWQoKSxuLnB0LmRlbGV0ZSh0KX0pKSxpJiZadCh0aGlzLHIpLCEwfXJldHVybiExfSxpLmhhcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hdC5yZXBvcnRPYnNlcnZlZCgpLHRoaXMucHQuaGFzKHRoaXMuJHQodCkpfSxpLmVudHJpZXM9ZnVuY3Rpb24oKXt2YXIgdD0wLG49QXJyYXkuZnJvbSh0aGlzLmtleXMoKSksaT1BcnJheS5mcm9tKHRoaXMudmFsdWVzKCkpO3JldHVybiB3bih7bmV4dDpmdW5jdGlvbigpe3ZhciByPXQ7cmV0dXJuIHQrPTEscjxpLmxlbmd0aD97dmFsdWU6W25bcl0saVtyXV0sZG9uZTohMX06e2RvbmU6ITB9fX0pfSxpLmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZXMoKX0saS52YWx1ZXM9ZnVuY3Rpb24oKXt0aGlzLmF0LnJlcG9ydE9ic2VydmVkKCk7dmFyIHQ9dGhpcyxuPTAsaT1BcnJheS5mcm9tKHRoaXMucHQudmFsdWVzKCkpO3JldHVybiB3bih7bmV4dDpmdW5jdGlvbigpe3JldHVybiBuPGkubGVuZ3RoP3t2YWx1ZTp0LiR0KGlbbisrXSksZG9uZTohMX06e2RvbmU6ITB9fX0pfSxpLnJlcGxhY2U9ZnVuY3Rpb24obil7dmFyIGk9dGhpcztyZXR1cm4gSmkobikmJihuPW5ldyBTZXQobikpLFd0KChmdW5jdGlvbigpe0FycmF5LmlzQXJyYXkobil8fGwobik/KGkuY2xlYXIoKSxuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBpLmFkZCh0KX0pKSk6bnVsbCE9biYmdChcIkNhbm5vdCBpbml0aWFsaXplIHNldCBmcm9tIFwiK24pfSkpLHRoaXN9LGkuZ3Q9ZnVuY3Rpb24odCl7cmV0dXJuIFF0KHRoaXMsdCl9LGkuQXQ9ZnVuY3Rpb24odCl7cmV0dXJuICR0KHRoaXMsdCl9LGkudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5LmZyb20odGhpcyl9LGkudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIltvYmplY3QgT2JzZXJ2YWJsZVNldF1cIn0saVtHaV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZXMoKX0seShuLFt7a2V5Olwic2l6ZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmF0LnJlcG9ydE9ic2VydmVkKCksdGhpcy5wdC5zaXplfX0se2tleTpYaSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIlNldFwifX1dKSxufSgpLEppPWgoXCJPYnNlcnZhYmxlU2V0XCIsJGkpLFlpPU9iamVjdC5jcmVhdGUobnVsbCksUWk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHQsbixpLHIpe3ZvaWQgMD09PW4mJihuPW5ldyBNYXApLHZvaWQgMD09PXImJihyPUJuKSx0aGlzLnM9dm9pZCAwLHRoaXMubnQ9dm9pZCAwLHRoaXMudHQ9dm9pZCAwLHRoaXMucm49dm9pZCAwLHRoaXMuYnQ9dm9pZCAwLHRoaXMuc3Q9dm9pZCAwLHRoaXMudXQ9dm9pZCAwLHRoaXMudj12b2lkIDAsdGhpcy5sPXZvaWQgMCx0aGlzLmVuPXZvaWQgMCx0aGlzLm9uPXZvaWQgMCx0aGlzLnM9dCx0aGlzLm50PW4sdGhpcy50dD1pLHRoaXMucm49cix0aGlzLmJ0PW5ldyBMbihcIk9ic2VydmFibGVPYmplY3Qua2V5c1wiKSx0aGlzLmw9cyh0aGlzLnMpfXZhciBpPW4ucHJvdG90eXBlO3JldHVybiBpLmh0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm50LmdldCh0KS5nZXQoKX0saS52dD1mdW5jdGlvbih0LG4pe3ZhciBpPXRoaXMubnQuZ2V0KHQpO2lmKGkgaW5zdGFuY2VvZiBhaSlyZXR1cm4gaS5zZXQobiksITA7aWYoenQodGhpcykpe3ZhciByPUp0KHRoaXMse3R5cGU6VGksb2JqZWN0OnRoaXMudnx8dGhpcy5zLG5hbWU6dCxuZXdWYWx1ZTpufSk7aWYoIXIpcmV0dXJuIG51bGw7bj1yLm5ld1ZhbHVlfWlmKChuPWkueHQobikpIT09cGkuVU5DSEFOR0VEKXt2YXIgZT1ZdCh0aGlzKSxvPWU/e3R5cGU6VGksb2JzZXJ2YWJsZUtpbmQ6XCJvYmplY3RcIixkZWJ1Z09iamVjdE5hbWU6dGhpcy50dCxvYmplY3Q6dGhpcy52fHx0aGlzLnMsb2xkVmFsdWU6aS5qdCxuYW1lOnQsbmV3VmFsdWU6bn06bnVsbDtpLk90KG4pLGUmJlp0KHRoaXMsbyl9cmV0dXJuITB9LGkubHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHBpLnRyYWNraW5nRGVyaXZhdGlvbiYmIWIodGhpcy5zLHQpJiZ0aGlzLnJ0KHQpLHRoaXMuc1t0XX0saS5kdD1mdW5jdGlvbih0LG4saSl7cmV0dXJuIHZvaWQgMD09PWkmJihpPSExKSxiKHRoaXMucyx0KT90aGlzLm50Lmhhcyh0KT90aGlzLnZ0KHQsbik6aT9SZWZsZWN0LnNldCh0aGlzLnMsdCxuKToodGhpcy5zW3RdPW4sITApOnRoaXMudSh0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSx0aGlzLnJuLGkpfSxpLnJ0PWZ1bmN0aW9uKHQpe2lmKCFwaS50cmFja2luZ0Rlcml2YXRpb24pcmV0dXJuIHQgaW4gdGhpcy5zO3RoaXMub258fCh0aGlzLm9uPW5ldyBNYXApO3ZhciBuPXRoaXMub24uZ2V0KHQpO3JldHVybiBufHwobj1uZXcgb2kodCBpbiB0aGlzLnMsTSxcIk9ic2VydmFibGVPYmplY3Qua2V5P1wiLCExKSx0aGlzLm9uLnNldCh0LG4pKSxuLmdldCgpfSxpLm89ZnVuY3Rpb24obixpKXtpZighMD09PWkmJihpPXRoaXMucm4pLCExIT09aSl7aWYoIShuIGluIHRoaXMucykpe3ZhciByO2lmKG51bGw9PShyPXRoaXMuc1tDbl0pP3ZvaWQgMDpyW25dKXJldHVybjt0KDEsaS50LHRoaXMudHQrXCIuXCIrbi50b1N0cmluZygpKX1mb3IodmFyIGU9dGhpcy5zO2UmJmUhPT1fbjspe3ZhciBvPUFuKGUsbik7aWYobyl7dmFyIHU9aS5vKHRoaXMsbixvLGUpO2lmKDA9PT11KXJldHVybjtpZigxPT09dSlicmVha31lPU9iamVjdC5nZXRQcm90b3R5cGVPZihlKX1jbih0aGlzLDAsbil9fSxpLnU9ZnVuY3Rpb24odCxuLGkscil7aWYodm9pZCAwPT09ciYmKHI9ITEpLCEwPT09aSYmKGk9dGhpcy5ybiksITE9PT1pKXJldHVybiB0aGlzLmgodCxuLHIpO3ZhciBlPWkudSh0aGlzLHQsbixyKTtyZXR1cm4gZSYmY24odGhpcywwLHQpLGV9LGkuaD1mdW5jdGlvbih0LG4saSl7dm9pZCAwPT09aSYmKGk9ITEpO3RyeXtkdCgpO3ZhciByPXRoaXMuR3QodCk7aWYoIXIpcmV0dXJuIHI7aWYoenQodGhpcykpe3ZhciBlPUp0KHRoaXMse29iamVjdDp0aGlzLnZ8fHRoaXMucyxuYW1lOnQsdHlwZTpxaSxuZXdWYWx1ZTpuLnZhbHVlfSk7aWYoIWUpcmV0dXJuIG51bGw7dmFyIG89ZS5uZXdWYWx1ZTtuLnZhbHVlIT09byYmKG49bSh7fSxuLHt2YWx1ZTpvfSkpfWlmKGkpe2lmKCFSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucyx0LG4pKXJldHVybiExfWVsc2UgZ24odGhpcy5zLHQsbik7dGhpcy51bih0LG4udmFsdWUpfWZpbmFsbHl7YnQoKX1yZXR1cm4hMH0saS5tPWZ1bmN0aW9uKHQsbixpLHIpe3ZvaWQgMD09PXImJihyPSExKTt0cnl7ZHQoKTt2YXIgZT10aGlzLkd0KHQpO2lmKCFlKXJldHVybiBlO2lmKHp0KHRoaXMpKXt2YXIgbz1KdCh0aGlzLHtvYmplY3Q6dGhpcy52fHx0aGlzLnMsbmFtZTp0LHR5cGU6cWksbmV3VmFsdWU6bn0pO2lmKCFvKXJldHVybiBudWxsO249by5uZXdWYWx1ZX12YXIgdT1mbih0KSxzPXtjb25maWd1cmFibGU6IXBpLnNhZmVEZXNjcmlwdG9yc3x8dGhpcy5sLGVudW1lcmFibGU6ITAsZ2V0OnUuZ2V0LHNldDp1LnNldH07aWYocil7aWYoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGhpcy5zLHQscykpcmV0dXJuITF9ZWxzZSBnbih0aGlzLnMsdCxzKTt2YXIgZj1uZXcgb2kobixpLFwiT2JzZXJ2YWJsZU9iamVjdC5rZXlcIiwhMSk7dGhpcy5udC5zZXQodCxmKSx0aGlzLnVuKHQsZi5qdCl9ZmluYWxseXtidCgpfXJldHVybiEwfSxpLnA9ZnVuY3Rpb24odCxuLGkpe3ZvaWQgMD09PWkmJihpPSExKTt0cnl7ZHQoKTt2YXIgcj10aGlzLkd0KHQpO2lmKCFyKXJldHVybiByO2lmKHp0KHRoaXMpJiYhSnQodGhpcyx7b2JqZWN0OnRoaXMudnx8dGhpcy5zLG5hbWU6dCx0eXBlOnFpLG5ld1ZhbHVlOnZvaWQgMH0pKXJldHVybiBudWxsO24ubmFtZXx8KG4ubmFtZT1cIk9ic2VydmFibGVPYmplY3Qua2V5XCIpLG4uY29udGV4dD10aGlzLnZ8fHRoaXMuczt2YXIgZT1mbih0KSxvPXtjb25maWd1cmFibGU6IXBpLnNhZmVEZXNjcmlwdG9yc3x8dGhpcy5sLGVudW1lcmFibGU6ITEsZ2V0OmUuZ2V0LHNldDplLnNldH07aWYoaSl7aWYoIVJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGhpcy5zLHQsbykpcmV0dXJuITF9ZWxzZSBnbih0aGlzLnMsdCxvKTt0aGlzLm50LnNldCh0LG5ldyBhaShuKSksdGhpcy51bih0LHZvaWQgMCl9ZmluYWxseXtidCgpfXJldHVybiEwfSxpLkd0PWZ1bmN0aW9uKHQsbil7aWYodm9pZCAwPT09biYmKG49ITEpLCFiKHRoaXMucyx0KSlyZXR1cm4hMDtpZih6dCh0aGlzKSYmIUp0KHRoaXMse29iamVjdDp0aGlzLnZ8fHRoaXMucyxuYW1lOnQsdHlwZTpcInJlbW92ZVwifSkpcmV0dXJuIG51bGw7dHJ5e3ZhciBpLHI7ZHQoKTt2YXIgZSxvPVl0KHRoaXMpLHU9dGhpcy5udC5nZXQodCkscz12b2lkIDA7aWYoIXUmJm8mJihzPW51bGw9PShlPUFuKHRoaXMucyx0KSk/dm9pZCAwOmUudmFsdWUpLG4pe2lmKCFSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRoaXMucyx0KSlyZXR1cm4hMX1lbHNlIGRlbGV0ZSB0aGlzLnNbdF07dSYmKHRoaXMubnQuZGVsZXRlKHQpLHUgaW5zdGFuY2VvZiBvaSYmKHM9dS5qdCkseXQodSkpLHRoaXMuYnQucmVwb3J0Q2hhbmdlZCgpLG51bGw9PShpPXRoaXMub24pfHxudWxsPT0ocj1pLmdldCh0KSl8fHIuc2V0KHQgaW4gdGhpcy5zKSxvJiZvJiZadCh0aGlzLHt0eXBlOlwicmVtb3ZlXCIsb2JzZXJ2YWJsZUtpbmQ6XCJvYmplY3RcIixvYmplY3Q6dGhpcy52fHx0aGlzLnMsZGVidWdPYmplY3ROYW1lOnRoaXMudHQsb2xkVmFsdWU6cyxuYW1lOnR9KX1maW5hbGx5e2J0KCl9cmV0dXJuITB9LGkuZ3Q9ZnVuY3Rpb24odCl7cmV0dXJuIFF0KHRoaXMsdCl9LGkuQXQ9ZnVuY3Rpb24odCl7cmV0dXJuICR0KHRoaXMsdCl9LGkudW49ZnVuY3Rpb24odCxuKXt2YXIgaSxyLGU9WXQodGhpcyk7ZSYmZSYmWnQodGhpcyxlP3t0eXBlOnFpLG9ic2VydmFibGVLaW5kOlwib2JqZWN0XCIsZGVidWdPYmplY3ROYW1lOnRoaXMudHQsb2JqZWN0OnRoaXMudnx8dGhpcy5zLG5hbWU6dCxuZXdWYWx1ZTpufTpudWxsKSxudWxsPT0oaT10aGlzLm9uKXx8bnVsbD09KHI9aS5nZXQodCkpfHxyLnNldCghMCksdGhpcy5idC5yZXBvcnRDaGFuZ2VkKCl9LGkuZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idC5yZXBvcnRPYnNlcnZlZCgpLEVuKHRoaXMucyl9LGkuaXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idC5yZXBvcnRPYnNlcnZlZCgpLE9iamVjdC5rZXlzKHRoaXMucyl9LG59KCksWmk9aChcIk9ic2VydmFibGVPYmplY3RBZG1pbmlzdHJhdGlvblwiLFFpKSx0cj0wLG5yPWZ1bmN0aW9uKCl7fTtGaT1ucix6aT1BcnJheS5wcm90b3R5cGUsT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihGaS5wcm90b3R5cGUsemkpOnZvaWQgMCE9PUZpLnByb3RvdHlwZS5fX3Byb3RvX18/RmkucHJvdG90eXBlLl9fcHJvdG9fXz16aTpGaS5wcm90b3R5cGU9emk7dmFyIGlyPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4obixpLHIsZSl7dmFyIG87dm9pZCAwPT09ciYmKHI9XCJPYnNlcnZhYmxlQXJyYXlcIiksdm9pZCAwPT09ZSYmKGU9ITEpLG89dC5jYWxsKHRoaXMpfHx0aGlzO3ZhciB1PW5ldyBLaShyLGksZSwhMCk7aWYodS52PWoobyksYyhqKG8pLEtuLHUpLG4mJm4ubGVuZ3RoKXt2YXIgcz1aKCEwKTtvLnNwbGljZVdpdGhBcnJheSgwLDAsbiksdHQocyl9cmV0dXJuIG99dyhuLHQpO3ZhciBpPW4ucHJvdG90eXBlO3JldHVybiBpLmNvbmNhdD1mdW5jdGlvbigpe3RoaXNbS25dLmF0LnJlcG9ydE9ic2VydmVkKCk7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsbj1uZXcgQXJyYXkodCksaT0wO2k8dDtpKyspbltpXT1hcmd1bWVudHNbaV07cmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkodGhpcy5zbGljZSgpLG4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdW4odCk/dC5zbGljZSgpOnR9KSkpfSxpW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXt2YXIgdD10aGlzLG49MDtyZXR1cm4gd24oe25leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gbjx0Lmxlbmd0aD97dmFsdWU6dFtuKytdLGRvbmU6ITF9Ontkb25lOiEwLHZhbHVlOnZvaWQgMH19fSl9LHkobixbe2tleTpcImxlbmd0aFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW0tuXS5YdCgpfSxzZXQ6ZnVuY3Rpb24odCl7dGhpc1tLbl0uV3QodCl9fSx7a2V5OlN5bWJvbC50b1N0cmluZ1RhZyxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIkFycmF5XCJ9fV0pLG59KG5yKTtPYmplY3QuZW50cmllcyhMaSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIG49dFswXTtcImNvbmNhdFwiIT09biYmYShpci5wcm90b3R5cGUsbix0WzFdKX0pKSx2bigxZTMpO3ZhciBycj1fbi50b1N0cmluZztbXCJTeW1ib2xcIixcIk1hcFwiLFwiU2V0XCJdLmZvckVhY2goKGZ1bmN0aW9uKGkpe3ZvaWQgMD09PW4oKVtpXSYmdChcIk1vYlggcmVxdWlyZXMgZ2xvYmFsICdcIitpK1wiJyB0byBiZSBhdmFpbGFibGUgb3IgcG9seWZpbGxlZFwiKX0pKSxcIm9iamVjdFwiPT10eXBlb2YgX19NT0JYX0RFVlRPT0xTX0dMT0JBTF9IT09LX18mJl9fTU9CWF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdE1vYngoe3NweTpqdCxleHRyYXM6e2dldERlYnVnTmFtZTpwbn0sJG1vYng6S259KSxleHBvcnRzLiRtb2J4PUtuLGV4cG9ydHMuRmxvd0NhbmNlbGxhdGlvbkVycm9yPUV0LGV4cG9ydHMuT2JzZXJ2YWJsZU1hcD1XaSxleHBvcnRzLk9ic2VydmFibGVTZXQ9JGksZXhwb3J0cy5SZWFjdGlvbj15aSxleHBvcnRzLl9hbGxvd1N0YXRlQ2hhbmdlcz1RLGV4cG9ydHMuX2FsbG93U3RhdGVDaGFuZ2VzSW5zaWRlQ29tcHV0ZWQ9T3QsZXhwb3J0cy5fYWxsb3dTdGF0ZVJlYWRzRW5kPWF0LGV4cG9ydHMuX2FsbG93U3RhdGVSZWFkc1N0YXJ0PWZ0LGV4cG9ydHMuX2F1dG9BY3Rpb249X2ksZXhwb3J0cy5fZW5kQWN0aW9uPVksZXhwb3J0cy5fZ2V0QWRtaW5pc3RyYXRpb249Ym4sZXhwb3J0cy5fZ2V0R2xvYmFsU3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gcGl9LGV4cG9ydHMuX2ludGVyY2VwdFJlYWRzPWZ1bmN0aW9uKHQsbixpKXt2YXIgcjtyZXR1cm4gSGkodCl8fHVuKHQpfHx1aSh0KT9yPWJuKHQpOmFuKHQpJiYocj1ibih0LG4pKSxyLmRlaGFuY2VyPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4/bjppLGZ1bmN0aW9uKCl7ci5kZWhhbmNlcj12b2lkIDB9fSxleHBvcnRzLl9pc0NvbXB1dGluZ0Rlcml2YXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXBpLnRyYWNraW5nRGVyaXZhdGlvbn0sZXhwb3J0cy5fcmVzZXRHbG9iYWxTdGF0ZT1mdW5jdGlvbigpe3ZhciB0PW5ldyBsaTtmb3IodmFyIG4gaW4gdCktMT09PXZpLmluZGV4T2YobikmJihwaVtuXT10W25dKTtwaS5hbGxvd1N0YXRlQ2hhbmdlcz0hcGkuZW5mb3JjZUFjdGlvbnN9LGV4cG9ydHMuX3N0YXJ0QWN0aW9uPUosZXhwb3J0cy5hY3Rpb249Z2ksZXhwb3J0cy5hdXRvcnVuPWd0LGV4cG9ydHMuY29tcGFyZXI9UG4sZXhwb3J0cy5jb21wdXRlZD1RbixleHBvcnRzLmNvbmZpZ3VyZT1mdW5jdGlvbihpKXshMD09PWkuaXNvbGF0ZUdsb2JhbFN0YXRlJiZmdW5jdGlvbigpe2lmKChwaS5wZW5kaW5nUmVhY3Rpb25zLmxlbmd0aHx8cGkuaW5CYXRjaHx8cGkuaXNSdW5uaW5nUmVhY3Rpb25zKSYmdCgzNiksYmk9ITAsZGkpe3ZhciBpPW4oKTswPT0tLWkuX19tb2J4SW5zdGFuY2VDb3VudCYmKGkuX19tb2J4R2xvYmFscz12b2lkIDApLHBpPW5ldyBsaX19KCk7dmFyIHIsZSxvPWkudXNlUHJveGllcyx1PWkuZW5mb3JjZUFjdGlvbnM7aWYodm9pZCAwIT09byYmKHBpLnVzZVByb3hpZXM9XCJhbHdheXNcIj09PW98fFwibmV2ZXJcIiE9PW8mJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm94eSksXCJpZmF2YWlsYWJsZVwiPT09byYmKHBpLnZlcmlmeVByb3hpZXM9ITApLHZvaWQgMCE9PXUpe3ZhciBzPVwiYWx3YXlzXCI9PT11P1wiYWx3YXlzXCI6XCJvYnNlcnZlZFwiPT09dTtwaS5lbmZvcmNlQWN0aW9ucz1zLHBpLmFsbG93U3RhdGVDaGFuZ2VzPSEwIT09cyYmXCJhbHdheXNcIiE9PXN9W1wiY29tcHV0ZWRSZXF1aXJlc1JlYWN0aW9uXCIsXCJyZWFjdGlvblJlcXVpcmVzT2JzZXJ2YWJsZVwiLFwib2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb25cIixcImRpc2FibGVFcnJvckJvdW5kYXJpZXNcIixcInNhZmVEZXNjcmlwdG9yc1wiXS5mb3JFYWNoKChmdW5jdGlvbih0KXt0IGluIGkmJihwaVt0XT0hIWlbdF0pfSkpLHBpLmFsbG93U3RhdGVSZWFkcz0hcGkub2JzZXJ2YWJsZVJlcXVpcmVzUmVhY3Rpb24saS5yZWFjdGlvblNjaGVkdWxlciYmKHI9aS5yZWFjdGlvblNjaGVkdWxlcixlPW1pLG1pPWZ1bmN0aW9uKHQpe3JldHVybiByKChmdW5jdGlvbigpe3JldHVybiBlKHQpfSkpfSl9LGV4cG9ydHMuY3JlYXRlQXRvbT1fLGV4cG9ydHMuZGVmaW5lUHJvcGVydHk9ZnVuY3Rpb24obixpLHIpe2lmKGFuKG4pKXJldHVybiBuW0tuXS5oKGkscik7dCgzOSl9LGV4cG9ydHMuZW50cmllcz1mdW5jdGlvbihuKXtyZXR1cm4gYW4obik/UHQobikubWFwKChmdW5jdGlvbih0KXtyZXR1cm5bdCxuW3RdXX0pKTpIaShuKT9QdChuKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblt0LG4uZ2V0KHQpXX0pKTpKaShuKT9BcnJheS5mcm9tKG4uZW50cmllcygpKTp1bihuKT9uLm1hcCgoZnVuY3Rpb24odCxuKXtyZXR1cm5bbix0XX0pKTp2b2lkIHQoNyl9LGV4cG9ydHMuZXh0ZW5kT2JzZXJ2YWJsZT1OdCxleHBvcnRzLmZsb3c9UmksZXhwb3J0cy5mbG93UmVzdWx0PWZ1bmN0aW9uKHQpe3JldHVybiB0fSxleHBvcnRzLmdldD1mdW5jdGlvbihuLGkpe2lmKER0KG4saSkpcmV0dXJuIGFuKG4pP25bS25dLmx0KGkpOkhpKG4pP24uZ2V0KGkpOnVuKG4pP25baV06dm9pZCB0KDExKX0sZXhwb3J0cy5nZXRBdG9tPWRuLGV4cG9ydHMuZ2V0RGVidWdOYW1lPXBuLGV4cG9ydHMuZ2V0RGVwZW5kZW5jeVRyZWU9ZnVuY3Rpb24odCxuKXtyZXR1cm4gUnQoZG4odCxuKSl9LGV4cG9ydHMuZ2V0T2JzZXJ2ZXJUcmVlPWZ1bmN0aW9uKHQsbil7cmV0dXJuIGt0KGRuKHQsbikpfSxleHBvcnRzLmhhcz1EdCxleHBvcnRzLmludGVyY2VwdD1mdW5jdGlvbih0LG4saSl7cmV0dXJuIGUoaSk/ZnVuY3Rpb24odCxuLGkpe3JldHVybiBibih0LG4pLkF0KGkpfSh0LG4saSk6ZnVuY3Rpb24odCxuKXtyZXR1cm4gYm4odCkuQXQobil9KHQsbil9LGV4cG9ydHMuaXNBY3Rpb249QXQsZXhwb3J0cy5pc0JveGVkT2JzZXJ2YWJsZT11aSxleHBvcnRzLmlzQ29tcHV0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIEt0KHQpfSxleHBvcnRzLmlzQ29tcHV0ZWRQcm9wPWZ1bmN0aW9uKHQsbil7cmV0dXJuIEt0KHQsbil9LGV4cG9ydHMuaXNGbG93PUN0LGV4cG9ydHMuaXNGbG93Q2FuY2VsbGF0aW9uRXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBFdH0sZXhwb3J0cy5pc09ic2VydmFibGU9SXQsZXhwb3J0cy5pc09ic2VydmFibGVBcnJheT11bixleHBvcnRzLmlzT2JzZXJ2YWJsZU1hcD1IaSxleHBvcnRzLmlzT2JzZXJ2YWJsZU9iamVjdD1hbixleHBvcnRzLmlzT2JzZXJ2YWJsZVByb3A9ZnVuY3Rpb24odCxuKXtyZXR1cm4gTHQodCxuKX0sZXhwb3J0cy5pc09ic2VydmFibGVTZXQ9SmksZXhwb3J0cy5rZXlzPVB0LGV4cG9ydHMubWFrZUF1dG9PYnNlcnZhYmxlPWZ1bmN0aW9uKHQsbixpKXtpZihzKHQpKXJldHVybiBOdCh0LHQsbixpKTt2YXIgcj1zbih0LGkpW0tuXTtpZighdFtFaV0pe3ZhciBlPU9iamVjdC5nZXRQcm90b3R5cGVPZih0KSxvPW5ldyBTZXQoW10uY29uY2F0KEVuKHQpLEVuKGUpKSk7by5kZWxldGUoXCJjb25zdHJ1Y3RvclwiKSxvLmRlbGV0ZShLbiksYShlLEVpLG8pfWR0KCk7dHJ5e3RbRWldLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiByLm8odCwhbnx8ISh0IGluIG4pfHxuW3RdKX0pKX1maW5hbGx5e2J0KCl9cmV0dXJuIHR9LGV4cG9ydHMubWFrZU9ic2VydmFibGU9ZnVuY3Rpb24odCxuLGkpe3ZhciByPXNuKHQsaSlbS25dO2R0KCk7dHJ5e251bGwhPW58fChuPWZ1bmN0aW9uKHQpe3JldHVybiBiKHQsQ24pfHxhKHQsQ24sbSh7fSx0W0NuXSkpLHRbQ25dfSh0KSksRW4obikuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHIubyh0LG5bdF0pfSkpfWZpbmFsbHl7YnQoKX1yZXR1cm4gdH0sZXhwb3J0cy5vYnNlcnZhYmxlPSRuLGV4cG9ydHMub2JzZXJ2ZT1mdW5jdGlvbih0LG4saSxyKXtyZXR1cm4gZShpKT9mdW5jdGlvbih0LG4saSxyKXtyZXR1cm4gYm4odCxuKS5ndChpLHIpfSh0LG4saSxyKTpmdW5jdGlvbih0LG4saSl7cmV0dXJuIGJuKHQpLmd0KG4saSl9KHQsbixpKX0sZXhwb3J0cy5vbkJlY29tZU9ic2VydmVkPVN0LGV4cG9ydHMub25CZWNvbWVVbm9ic2VydmVkPU10LGV4cG9ydHMub25SZWFjdGlvbkVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBwaS5nbG9iYWxSZWFjdGlvbkVycm9ySGFuZGxlcnMucHVzaCh0KSxmdW5jdGlvbigpe3ZhciBuPXBpLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5pbmRleE9mKHQpO24+PTAmJnBpLmdsb2JhbFJlYWN0aW9uRXJyb3JIYW5kbGVycy5zcGxpY2UobiwxKX19LGV4cG9ydHMub3ZlcnJpZGU9RG4sZXhwb3J0cy5vd25LZXlzPUJ0LGV4cG9ydHMucmVhY3Rpb249ZnVuY3Rpb24odCxuLGkpe2Z1bmN0aW9uIHIoKXtpZihsPSExLCFwLkope3ZhciBuPSExO3AudHJhY2soKGZ1bmN0aW9uKCl7dmFyIGk9USghMSwoZnVuY3Rpb24oKXtyZXR1cm4gdChwKX0pKTtuPXZ8fCFiKHMsaSksZD1zLHM9aX0pKSwodiYmaS5maXJlSW1tZWRpYXRlbHl8fCF2JiZuKSYmYShzLGQscCksdj0hMX19dmFyIGU7dm9pZCAwPT09aSYmKGk9TW4pO3ZhciBvLHUscyxmPW51bGwhPShlPWkubmFtZSk/ZTpcIlJlYWN0aW9uXCIsYT1naShmLGkub25FcnJvcj8obz1pLm9uRXJyb3IsdT1uLGZ1bmN0aW9uKCl7dHJ5e3JldHVybiB1LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jYXRjaCh0KXtvLmNhbGwodGhpcyx0KX19KTpuKSxjPSFpLnNjaGVkdWxlciYmIWkuZGVsYXksaD1fdChpKSx2PSEwLGw9ITEsZD12b2lkIDAsYj1pLmNvbXBhcmVTdHJ1Y3R1cmFsP1BuLnN0cnVjdHVyYWw6aS5lcXVhbHN8fFBuLmRlZmF1bHQscD1uZXcgeWkoZiwoZnVuY3Rpb24oKXt2fHxjP3IoKTpsfHwobD0hMCxoKHIpKX0pLGkub25FcnJvcixpLnJlcXVpcmVzT2JzZXJ2YWJsZSk7cmV0dXJuIHAuWSgpLHAuWigpfSxleHBvcnRzLnJlbW92ZT1mdW5jdGlvbihuLGkpe2FuKG4pP25bS25dLkd0KGkpOkhpKG4pfHxKaShuKT9uLmRlbGV0ZShpKTp1bihuKT8oXCJudW1iZXJcIiE9dHlwZW9mIGkmJihpPXBhcnNlSW50KGksMTApKSxuLnNwbGljZShpLDEpKTp0KDkpfSxleHBvcnRzLnJ1bkluQWN0aW9uPU90LGV4cG9ydHMuc2V0PWZ1bmN0aW9uIG4oaSxyLGUpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RofHxKaShpKSlhbihpKT9pW0tuXS5kdChyLGUpOkhpKGkpP2kuc2V0KHIsZSk6SmkoaSk/aS5hZGQocik6dW4oaSk/KFwibnVtYmVyXCIhPXR5cGVvZiByJiYocj1wYXJzZUludChyLDEwKSkscjwwJiZ0KFwiSW52YWxpZCBpbmRleDogJ1wiK3IrXCInXCIpLGR0KCkscj49aS5sZW5ndGgmJihpLmxlbmd0aD1yKzEpLGlbcl09ZSxidCgpKTp0KDgpO2Vsc2V7ZHQoKTt2YXIgbz1yO3RyeXtmb3IodmFyIHUgaW4gbyluKGksdSxvW3VdKX1maW5hbGx5e2J0KCl9fX0sZXhwb3J0cy5zcHk9anQsZXhwb3J0cy50b0pTPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbiB0KG4saSl7aWYobnVsbD09bnx8XCJvYmplY3RcIiE9dHlwZW9mIG58fG4gaW5zdGFuY2VvZiBEYXRlfHwhSXQobikpcmV0dXJuIG47aWYodWkobil8fGNpKG4pKXJldHVybiB0KG4uZ2V0KCksaSk7aWYoaS5oYXMobikpcmV0dXJuIGkuZ2V0KG4pO2lmKHVuKG4pKXt2YXIgcj1xdChpLG4sbmV3IEFycmF5KG4ubGVuZ3RoKSk7cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24obixlKXtyW2VdPXQobixpKX0pKSxyfWlmKEppKG4pKXt2YXIgZT1xdChpLG4sbmV3IFNldCk7cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24obil7ZS5hZGQodChuLGkpKX0pKSxlfWlmKEhpKG4pKXt2YXIgbz1xdChpLG4sbmV3IE1hcCk7cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24obixyKXtvLnNldChyLHQobixpKSl9KSksb312YXIgdT1xdChpLG4se30pO3JldHVybiBCdChuKS5mb3JFYWNoKChmdW5jdGlvbihyKXtfbi5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG4scikmJih1W3JdPXQobltyXSxpKSl9KSksdX0odCxuZXcgTWFwKX0sZXhwb3J0cy50cmFjZT1HdCxleHBvcnRzLnRyYW5zYWN0aW9uPVd0LGV4cG9ydHMudW50cmFja2VkPW90LGV4cG9ydHMudmFsdWVzPWZ1bmN0aW9uKG4pe3JldHVybiBhbihuKT9QdChuKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBuW3RdfSkpOkhpKG4pP1B0KG4pLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG4uZ2V0KHQpfSkpOkppKG4pP0FycmF5LmZyb20obi52YWx1ZXMoKSk6dW4obik/bi5zbGljZSgpOnZvaWQgdCg2KX0sZXhwb3J0cy53aGVuPWZ1bmN0aW9uKHQsbixpKXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGh8fG4mJlwib2JqZWN0XCI9PXR5cGVvZiBuP1V0KHQsbik6SHQodCxuLGl8fHt9KX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2J4LmNqcy5wcm9kdWN0aW9uLm1pbi5qcy5tYXBcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIiwiYXNzZXJ0Lm5vdEVxdWFsID0gbm90RXF1YWxcbmFzc2VydC5ub3RPayA9IG5vdE9rXG5hc3NlcnQuZXF1YWwgPSBlcXVhbFxuYXNzZXJ0Lm9rID0gYXNzZXJ0XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzZXJ0XG5cbmZ1bmN0aW9uIGVxdWFsIChhLCBiLCBtKSB7XG4gIGFzc2VydChhID09IGIsIG0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG59XG5cbmZ1bmN0aW9uIG5vdEVxdWFsIChhLCBiLCBtKSB7XG4gIGFzc2VydChhICE9IGIsIG0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG59XG5cbmZ1bmN0aW9uIG5vdE9rICh0LCBtKSB7XG4gIGFzc2VydCghdCwgbSlcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0LCBtKSB7XG4gIGlmICghdCkgdGhyb3cgbmV3IEVycm9yKG0gfHwgJ0Fzc2VydGlvbkVycm9yJylcbn1cbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG52YXIgc2FmZUV4dGVybmFsTGluayA9IC8obm9vcGVuZXJ8bm9yZWZlcnJlcikgKG5vb3BlbmVyfG5vcmVmZXJyZXIpL1xudmFyIHByb3RvY29sTGluayA9IC9eW1xcdy1fXSs6L1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhyZWZcblxuZnVuY3Rpb24gaHJlZiAoY2IsIHJvb3QpIHtcbiAgYXNzZXJ0Lm5vdEVxdWFsKHR5cGVvZiB3aW5kb3csICd1bmRlZmluZWQnLCAnbmFub2hyZWY6IGV4cGVjdGVkIHdpbmRvdyB0byBleGlzdCcpXG5cbiAgcm9vdCA9IHJvb3QgfHwgd2luZG93LmRvY3VtZW50XG5cbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBjYiwgJ2Z1bmN0aW9uJywgJ25hbm9ocmVmOiBjYiBzaG91bGQgYmUgdHlwZSBmdW5jdGlvbicpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygcm9vdCwgJ29iamVjdCcsICduYW5vaHJlZjogcm9vdCBzaG91bGQgYmUgdHlwZSBvYmplY3QnKVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKChlLmJ1dHRvbiAmJiBlLmJ1dHRvbiAhPT0gMCkgfHxcbiAgICAgIGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5hbHRLZXkgfHwgZS5zaGlmdEtleSB8fFxuICAgICAgZS5kZWZhdWx0UHJldmVudGVkKSByZXR1cm5cblxuICAgIHZhciBhbmNob3IgPSAoZnVuY3Rpb24gdHJhdmVyc2UgKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSB8fCBub2RlID09PSByb290KSByZXR1cm5cbiAgICAgIGlmIChub2RlLmxvY2FsTmFtZSAhPT0gJ2EnIHx8IG5vZGUuaHJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cmF2ZXJzZShub2RlLnBhcmVudE5vZGUpXG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZVxuICAgIH0pKGUudGFyZ2V0KVxuXG4gICAgaWYgKCFhbmNob3IpIHJldHVyblxuXG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAhPT0gYW5jaG9yLnByb3RvY29sIHx8XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gYW5jaG9yLmhvc3RuYW1lIHx8XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wb3J0ICE9PSBhbmNob3IucG9ydCB8fFxuICAgICAgYW5jaG9yLmhhc0F0dHJpYnV0ZSgnZGF0YS1uYW5vaHJlZi1pZ25vcmUnKSB8fFxuICAgICAgYW5jaG9yLmhhc0F0dHJpYnV0ZSgnZG93bmxvYWQnKSB8fFxuICAgICAgKGFuY2hvci5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpID09PSAnX2JsYW5rJyAmJlxuICAgICAgICBzYWZlRXh0ZXJuYWxMaW5rLnRlc3QoYW5jaG9yLmdldEF0dHJpYnV0ZSgncmVsJykpKSB8fFxuICAgICAgcHJvdG9jb2xMaW5rLnRlc3QoYW5jaG9yLmdldEF0dHJpYnV0ZSgnaHJlZicpKSkgcmV0dXJuXG5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBjYihhbmNob3IpXG4gIH0pXG59XG4iLCIhZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy50YWJsZT1uZXcgVWludDE2QXJyYXkoMTYpLHRoaXMudD1uZXcgVWludDE2QXJyYXkoMjg4KX1mdW5jdGlvbiBmKGYsdil7dGhpcy5zb3VyY2U9Zix0aGlzLnNvdXJjZUluZGV4PTAsdGhpcy50YWc9MCx0aGlzLnY9MCx0aGlzLk09dix0aGlzLko9MCx0aGlzLm89bmV3IHQsdGhpcy51PW5ldyB0fXZhciB2PW5ldyB0LGI9bmV3IHQsTT1uZXcgVWludDhBcnJheSgzMCksSj1uZXcgVWludDE2QXJyYXkoMzApLHI9bmV3IFVpbnQ4QXJyYXkoMzApLGU9bmV3IFVpbnQxNkFycmF5KDMwKSxhPW5ldyBVaW50OEFycmF5KFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSksbj1uZXcgdCxpPW5ldyBVaW50OEFycmF5KDMyMCk7ZnVuY3Rpb24gbyh0LGYsdixiKXt2YXIgTSxKO2ZvcihNPTA7TTx2OysrTSl0W01dPTA7Zm9yKE09MDtNPDMwLXY7KytNKXRbTSt2XT1NL3Z8MDtmb3IoSj1iLE09MDtNPDMwOysrTSlmW01dPUosSis9MTw8dFtNXX12YXIgcz1uZXcgVWludDE2QXJyYXkoMTYpO2Z1bmN0aW9uIHUodCxmLHYsYil7dmFyIE0sSjtmb3IoTT0wO008MTY7KytNKXQudGFibGVbTV09MDtmb3IoTT0wO008YjsrK00pdC50YWJsZVtmW3YrTV1dKys7Zm9yKHQudGFibGVbMF09MCxKPTAsTT0wO008MTY7KytNKXNbTV09SixKKz10LnRhYmxlW01dO2ZvcihNPTA7TTxiOysrTSlmW3YrTV0mJih0LnRbc1tmW3YrTV1dKytdPU0pfWZ1bmN0aW9uIGModCl7dC52LS18fCh0LnRhZz10LnNvdXJjZVt0LnNvdXJjZUluZGV4KytdLHQudj03KTt2YXIgZj0xJnQudGFnO3JldHVybiB0LnRhZz4+Pj0xLGZ9ZnVuY3Rpb24gaCh0LGYsdil7aWYoIWYpcmV0dXJuIHY7Zm9yKDt0LnY8MjQ7KXQudGFnfD10LnNvdXJjZVt0LnNvdXJjZUluZGV4KytdPDx0LnYsdC52Kz04O3ZhciBiPXQudGFnJjY1NTM1Pj4+MTYtZjtyZXR1cm4gdC50YWc+Pj49Zix0LnYtPWYsYit2fWZ1bmN0aW9uIGQodCxmKXtmb3IoO3QudjwyNDspdC50YWd8PXQuc291cmNlW3Quc291cmNlSW5kZXgrK108PHQudix0LnYrPTg7dmFyIHY9MCxiPTAsTT0wLEo9dC50YWc7ZG97Yj0yKmIrKDEmSiksSj4+Pj0xLCsrTSx2Kz1mLnRhYmxlW01dLGItPWYudGFibGVbTV19d2hpbGUoYj49MCk7cmV0dXJuIHQudGFnPUosdC52LT1NLGYudFt2K2JdfWZ1bmN0aW9uIHcodCxmLHYpe3ZhciBiLE0sSixyLGUsbztmb3IoYj1oKHQsNSwyNTcpLE09aCh0LDUsMSksSj1oKHQsNCw0KSxyPTA7cjwxOTsrK3IpaVtyXT0wO2ZvcihyPTA7cjxKOysrcil7dmFyIHM9aCh0LDMsMCk7aVthW3JdXT1zfWZvcih1KG4saSwwLDE5KSxlPTA7ZTxiK007KXt2YXIgYz1kKHQsbik7c3dpdGNoKGMpe2Nhc2UgMTY6dmFyIHc9aVtlLTFdO2ZvcihvPWgodCwyLDMpO287LS1vKWlbZSsrXT13O2JyZWFrO2Nhc2UgMTc6Zm9yKG89aCh0LDMsMyk7bzstLW8paVtlKytdPTA7YnJlYWs7Y2FzZSAxODpmb3Iobz1oKHQsNywxMSk7bzstLW8paVtlKytdPTA7YnJlYWs7ZGVmYXVsdDppW2UrK109Y319dShmLGksMCxiKSx1KHYsaSxiLE0pfWZ1bmN0aW9uIGwodCxmLHYpe2Zvcig7Oyl7dmFyIGIsYSxuLGksbz1kKHQsZik7aWYoMjU2PT09bylyZXR1cm4gMDtpZihvPDI1Nil0Lk1bdC5KKytdPW87ZWxzZSBmb3IoYj1oKHQsTVtvLT0yNTddLEpbb10pLGE9ZCh0LHYpLGk9bj10LkotaCh0LHJbYV0sZVthXSk7aTxuK2I7KytpKXQuTVt0LkorK109dC5NW2ldfX1mdW5jdGlvbiB5KHQpe2Zvcih2YXIgZix2O3Qudj44Oyl0LnNvdXJjZUluZGV4LS0sdC52LT04O2lmKChmPTI1NiooZj10LnNvdXJjZVt0LnNvdXJjZUluZGV4KzFdKSt0LnNvdXJjZVt0LnNvdXJjZUluZGV4XSkhPT0oNjU1MzUmfigyNTYqdC5zb3VyY2VbdC5zb3VyY2VJbmRleCszXSt0LnNvdXJjZVt0LnNvdXJjZUluZGV4KzJdKSkpcmV0dXJuLTM7Zm9yKHQuc291cmNlSW5kZXgrPTQsdj1mO3Y7LS12KXQuTVt0LkorK109dC5zb3VyY2VbdC5zb3VyY2VJbmRleCsrXTtyZXR1cm4gdC52PTAsMH0hZnVuY3Rpb24odCxmKXt2YXIgdjtmb3Iodj0wO3Y8NzsrK3YpdC50YWJsZVt2XT0wO2Zvcih0LnRhYmxlWzddPTI0LHQudGFibGVbOF09MTUyLHQudGFibGVbOV09MTEyLHY9MDt2PDI0Oysrdil0LnRbdl09MjU2K3Y7Zm9yKHY9MDt2PDE0NDsrK3YpdC50WzI0K3ZdPXY7Zm9yKHY9MDt2PDg7Kyt2KXQudFsxNjgrdl09MjgwK3Y7Zm9yKHY9MDt2PDExMjsrK3YpdC50WzE3Nit2XT0xNDQrdjtmb3Iodj0wO3Y8NTsrK3YpZi50YWJsZVt2XT0wO2ZvcihmLnRhYmxlWzVdPTMyLHY9MDt2PDMyOysrdilmLnRbdl09dn0odixiKSxvKE0sSiw0LDMpLG8ocixlLDIsMSksTVsyOF09MCxKWzI4XT0yNTg7dmFyIHAsUSxPPU87ZnVuY3Rpb24gZygpe31PPW1vZHVsZTtmb3IodmFyIEE9bmV3IFVpbnQ4QXJyYXkoMTIzKSxTPTI1O1M+PTA7LS1TKUFbNDgrU109NTIrUyxBWzY1K1NdPVMsQVs5NytTXT0yNitTO0FbNDNdPTYyLEFbNDddPTYzLE8ud2FzbT1mdW5jdGlvbih0LE0pe3ZhciBKLHIsZT1uZXcgZih0LG5ldyBVaW50OEFycmF5KDExNjIxMCkpO2Rve3N3aXRjaChKPWMoZSksaChlLDIsMCkpe2Nhc2UgMDpyPXkoZSk7YnJlYWs7Y2FzZSAxOnI9bChlLHYsYik7YnJlYWs7Y2FzZSAyOncoZSxlLm8sZS51KSxyPWwoZSxlLm8sZS51KTticmVhaztkZWZhdWx0OnI9LTN9aWYoMCE9PXIpdGhyb3cgRXJyb3IoXCJEYXRhIGVycm9yXCIpfXdoaWxlKCFKKTtyZXR1cm4gZS5KPGUuTS5sZW5ndGg/XCJmdW5jdGlvblwiPT10eXBlb2YgZS5NLnNsaWNlP2UuTS5zbGljZSgwLGUuSik6ZS5NLnN1YmFycmF5KDAsZS5KKTplLk19KCh0PT57Y29uc3QgZj1uZXcgVWludDhBcnJheSg3MjM3NCk7bGV0IHYsYj0hMSxNPTA7Zm9yKGxldCBKPTA7Sjw3MjM3NDtKKyspdj10LmNoYXJDb2RlQXQoSiksMTMhPT12JiYxMCE9PXYmJig2MSE9PXZ8fGI/KGImJihiPSExLHYtPTY0KSxmW00rK109djw0MiYmdj4wP3YrMjE0OnYtNDIpOmI9ITApO3JldHVybiBmLnN1YmFycmF5KDAsTSl9KShcIsOWw6c1wrpHXHUwMDAxwqNcdTAwMTHCocOlXHUwMDE5wqVcdTAwMTjDh8ODw4hRMF0tXFxmwp4tLsKxTjLCrExewq5cXFwiLETCpsKrSm/Ck3dcdTAwMWLCj8OZwpLCpMKBQFx1MDAwZsKlMcOeKzh6XFxiP8KrwqvDncOebcOxw7bCsHXDq1vClcKBP8OdfMOUwrzClMK1w5h8wpvCj8OZw5TDlsOuw5rDtcK/w6I8woPCjH50w6xcdTAwMDRcdTAwMDLDn8K2woFcdTAwMTXCksOHw7FcXFxcP8OPXHUwMDE2XHUwMDA3wr/DtyYoXFx0wqEkw7hHwrrDvsKYwo/DgVZ2IVx1MDAxN2jCuVx1MDAxOcOGXHUwMDFkw6fDucKhw6jDmCfDvlx1MDAxZMORwr3ChMOXw4DCpltXw4hzw6HDoMK8w5fCkVx1MDAxNMKFwqBzw6DClMO5XsOiXHUwMDBmwrx+wrnClcO5Xlx1MDAxZsKuwpXCp1x1MDAxNcOMSHzDjcKkw7DDmcOgXHUwMDA3XHUwMDEye8OVw6RzwohywojDmixBWMO+w4hcdTAwMTPDsCHCpHvCv8OPw4RcdTAwMWZ8wp/CpmvDp8KHwqbDkMKBwr/DpnrDp8Okw7J9wqTDp8Oyw5nDlMOHNcKkP8OlXFxcXMKKXHUwMDFlwpx+XcOsw6Nvw7EoXHUwMDE2LMKXXHUwMDEzwoPDlyB2wqnDljp5ZMO/w5fChMObWFx1MDAxNsOzb0nCjldcdTAwMDN0wqFhwrzDiXTCqMOUPUBcdTAwMTFcdTAwMTlcXHTDmsOpwqnDncOAXHUwMDFhIV3Dn3Anwq/DuVFzV8OXw5/CvHB8w4XClV7ClFx1MDAxNyNcdTAwMTBsw4TDjsK1XHUwMDFmwoRhw5PCn8K8wqTCl8OcXFxiw4LDgsOUw489fcOlwqTDvXXCk8O8wpYgw5xcdTAwMTBcdTAwMTjDg1x1MDAwZsK/TsOXX8O8woTDvHLCgWVfXHUwMDE4w4XDn8KQw41fwofDoSnChF3Dt8KAXFxcXMODw7/DvMKQw5l7w5VcdTAwMDFlw7c9QMOIw5PCs8Kkw5XDv1x1MDAxM17DvcKYV8OTXHUwMDE3w5fCr8KQTXdcdTAwMWPCmMO8wpJQacOBw45Tw6/CvXVcdTAwMTPDj8Oew7/CjyDDtMKhXFxiJsOnw55cdTAwMDHDqMOgw4UmXlx1MDAxN8Kpw6DCoHlcdTAwMWPCllx1MDAxN8KMXHUwMDFjw6NcdTAwMDTCr1x1MDAwZcKRwpRZTsKtXHUwMDA0XFx0dMKww5/DqcOHwpbDvlx1MDAwNDN1XFx0wpdRw59cXFxcXHUwMDEzT8OJw4lcXFwiw6vCiV5oKcKhRHPCp1XDjlx1MDAwZsOPw7BRRMOxbVdOS8O3w7xcdTAwMGZ6w4VcdTAwMThcdTAwMWJNR1x1MDAwZVx1MDAxZsO+w4howok9QMO5XHUwMDA2XHUwMDAxYsOYScKoQcKUwqNcdTAwMDR5wqTDvnZ4wpgpXFxmfGlIw7zCulx1MDAwNn7DlVx1MDAwN8KIw43CiMODNsKcw4RcdTAwMGV8w47DlGLDs8K5esKpwprDnD1AXHUwMDE1w7vCgMOnwqZcXHZ2w7tSw5nDvsKiOkRcdTAwMGZcdTAwMWJrw7s2UyFcXGLDsMKEwoTChXkrbMKhwrdcdTAwMWbDnlxcdsKhw4dcdTAwMWbDnj1NwqEnXHUwMDFmw55cdTAwMTnCoVx1MDAwM8Kkw4QjXHUwMDA3JsKkZFx1MDAxOcKhdVx1MDAxNVx1MDAxM8K8XFx0w5fDmMORw5XCqEE9QMO9PUrCoSVcdTAwMDHDvSfCqMOhw6DDiMOYI1x1MDAwN8OrXHUwMDFmXHUwMDFlw4pcXHRHwoh5OSVcdTAwMDfCu1x1MDAxZlx1MDAxZcKyXFx0R8KHecK5JFx1MDAwN8OHXHUwMDE1XHUwMDEzw4fCtlx1MDAxNlxcXCLCusK7K1lhbyQzwrfCslx1MDAwMcK3eXZQZcOKecO0wrDCkCo9SsOjU8O8wrFSw5HCs8OUw4HCtzHDocORwrfCicOtw4w7wpTCjcK5w5jDiHPDpXXCmMOZwpMow6J1wpnDmcOPwqjCgcOpw6fCgMOpw6TDgTTDhGQ3wqjDusKkw749TcK0ZsKKXHUwMDBmwpTDp3HCvcOwwoDDklt9L8KZw7hcdTAwMTF3XHUwMDA3wrHDpnvCmEM6XHUwMDFmw6bCj1fDlXByMF4/w4RFwq9XTMOSw7s0XHUwMDFmw4tQw4Ivw57DpTrClFx1MDAwM1x1MDAxZktcdTAwMTfDpzdvwpbDm8Oww7PCp8OWV2c1K8K8wovCk8KKw74mwrzCvsKUwq7DgMO9XHUwMDFiXHUwMDExbMOBJFxcXCItZFdcdTAwMDXCiMOaWyjChsOtXHUwMDE4XHUwMDFjw6ZcdTAwMGUhOlx1MDAwZSxcXFwiw4TCpFx1MDAxYsKjMULCi0EtRD52OT9cdTAwMWbDosKYX8KSwrPCicOKwrtYN8OEXHUwMDEzw65cdTAwMDFzXHUwMDAzST9cdTAwMDZnVDJIXHUwMDEzLMKMXHUwMDEzLMOQXHUwMDEzw7zDkcKaYMOUYGnDpMKFRFx1MDAwN8OXwoB3M1x1MDAxYV1cdTAwMGbDvFx1MDAwM8OMaC7CvsKKXHUwMDE3wrAkw6rCgVxcXCJuXHUwMDE3w6BkR1x1MDAxMmzDtcOkKsOBWFx1MDAxNGZ6wrLDgMKsXHUwMDE0XHUwMDE3P1x1MDAxOMKSw5/DqC11wovDo8KuVcOsw4Vkw4LCgF7DnsOUwr7Dl1s+J8KYw4BBw7lcdTAwMGXDhCFcdTAwMTAtwr7CjcKMw6p7w5LDksKKwpxVPFxcZkQ8N8OJwr8tU8OqbMOYL1XCicO9bixJwrdcdTAwMWRtXHUwMDFmwqNcdTAwMDI6wqjDsMOUw6Qww41yZMOfw5QqXHUwMDEzwo3CqFxcdjZcdTAwMWR3b8KLXHUwMDA0woPDjVxcYj5cdTAwMThsXcOqf8O+w7QhwpRJYcOaXHUwMDE1XHUwMDExw6svbVx1MDAxZMKcecOSZ8KFTsOtXHUwMDFkwo89TcKjVMOPw4XDrVx1MDAxYynDlDfCoihcXGJcXGLCuXk9QMKKblx1MDAwZl9rwpl9w6d3wqIlXFx0w5zDsMOfXHUwMDFjQlnCuGfDosO8VUrDh3fCqMOpXHUwMDFmOcO9wqvDncKywoQjYCFgOMKtX8OOMMKwalx1MDAxMMOYe8OoJ8KQw5TCqVx1MDAwMVx1MDAwMcKVUcKqKGHCqFx1MDAxM2/CkMOkXHUwMDAxw6V1woZ6woLDmcObwrU6Qlx1MDAwNSNMwqPDmnLCt1x1MDAwMVthwrPCmsKFMllcXFxcdcKwS8KHW8OWYcKGw6nCrcORwrbDncKIUMK5woLCk8KAw6HCplx1MDAxMWDDjcK+w7DDilx1MDAxNsKOw7fDjMKgccOMcMKUwpvDuiTCgz1AwqQmXHUwMDE3wqfDmcOzwpRcdTAwMTjDlcKrdW/Cp8OpSzXDon/CqGh5fcOiXHUwMDE3wrEpw7nCliZcdTAwMDTDocKUw63Dk8KzcMKnVMODdMORw5BcdTAwMDTDh8OEwoLClHzCqMKNXHUwMDE5wprDlMO/w4bDhFx1MDAxNHjDn0rDusOOJkDDqcO9XHUwMDE4w67DjkBCwoZcdTAwMTPCtUTDgsOVw6jDklx1MDAwNVx1MDAwMj45wpRRUSVEw6HDl8KWXHUwMDFjw5rCqMKSb1x1MDAxMSU9fWnDlMKAwpzCvHBxw59cdTAwMTbCscKUV1x1MDAxZsOlacOcPUDDmnZIw4TDhlx1MDAxYcOcJ8KoXHUwMDExXHUwMDE0w5zDm1x1MDAwNsKnwr3DnsOTPUDCi8O1w7bCv1xcdmBVwqR6wrdFwrxgXHUwMDEyP8OWQcKYXHUwMDEww5fCgsKKN8O2XFx2W8KMwq7DoTfDmsOTwqZcdTAwMTF0wpfDmsOLwonDh8Ocw6NjUsK5NsOcPUDDnFpzNS8pXHUwMDAzVlx1MDAwNMOLf8KIw7Qww5pewrTDrWpsw53CpsORw6BbQsK+wql+RVx1MDAwZTc9QMOkZ8KqSzQhLsOlwph4w5fCgsKpXFxmXHUwMDFkbMKCwoTCkjjDtHXDgVgnwpFZMsO9fsKLJcKBw7XCgsKYwrtueMKFXFxcXFx1MDAwZcONacKMw7I+XHUwMDAxKsK6WsOfwqhcdTAwMWRtdSvCuHfCq3RfXFxiwoHCtMKjw5/CocOVJyTCscOgKmTDlS/CjsKJw5fDiSjDssOvwqTCssOcw6B8w6suw78xYcOxw55CXHUwMDFiw7rChnlVa3tfTMOrw4A3alx1MDAxNMOeIcO1wrfDnsOjwr/CiF4nXFx2K0LCg8K0woYswrfDoUxTQFfDsjHDoFrCqsKrwr46wpdcdTAwMDPCo8KSXHUwMDBmaUbDpcOSw61YXFxcIsKRXHUwMDE2XFxmYcKIVFx1MDAwNMOJwq7DkMKDw6bCoMKSKVx1MDAxN8OMXHUwMDFmfFxcYnhZwrA9QMOBXFx2wo7DuHbCijlaOkVDRsKCwrbDj1pQw7Q6w51lwrXCsMO6w7xcdTAwMDPCi8OPwrZcdTAwMTLChMObw63DkGfDilxcYsKhf3nCtllUWMOwSMOTw5HDpcK4Yi/DlH/CksOJcsKIw7zChsK3XHUwMDFiw47CtVx1MDAxYcOOwokoZVxcZijDpibDr8KIw7toeyVbwppRw6jDuMKFw6fDuiRcdTAwMGXCp8Onw7DCm8Kww74kwoXCiUg0PUrDpCszwrw9QFXDssOvZmxcdTAwMTUuwoLCosOTXHUwMDFiUy5cdTAwMGXDicO+XHUwMDEyVjfDtyXDjcKUXHUwMDBmLcKTc8KlO8Ofw44hw53CrMKfTXfDtE87fzk5w5zDpcOew55WXHUwMDAyw7FRfcK6wrPCv28ww65cdTAwMTHCisKvw4hRZsKxJ3XDsMOpw5nCp0jDriA3JX/Dp0FEw6dcdTAwMTlxw6/CqiPDisOmw5B/TMKELMKEZMOwXHUwMDEww7rDgFx1MDAwNlx1MDAxZcO6wrBTw4vDkMKldDlcdTAwMWZkw7zCu1x1MDAxNMOQUcO/wq89Slx1MDAwNVx1MDAxNMKSwofDgsO2bzpcdTAwMDZhwrNcXFxcXHUwMDFjK8KEXHUwMDEyOsO2PUBcdTAwMDZdwpFcdTAwMWZdw5jCtHM3X1x1MDAxN8OdwqjDsMK/T8O7w4HCtMOMXHUwMDE2MsKhLsKzYsOjRMK0w5/Djlx1MDAxZj1Aa2HCv8OALsKAa1XCgMKTw5bCj1x1MDAwN8KPX8KXw4PCtsOZwoRFwplVfyFqZsKUwrTDiMKgXHUwMDE0wrbCisONwrrDrsOlQsKVXFxcXEBIw6vCjsOSXmDDsGx3dXtcXFwiXHUwMDE5w4VzMcOcw7xcdTAwMWVOwoPCucOzdsKWw5DDnMKgwrPCpMKZw5xsw45SYEJcdTAwMTM4bzLDpMKVw4FHwpvDqMK7wpxLw7bCrMOvP1fDu25hw54wwqPCscO0R8KBOWxcdTAwMDE/Nn4xXHUwMDFlw4trXHUwMDEywpIjUlx1MDAwM8KKw6rChsK2asKeX1xcdsO1XFxcIlx1MDAxMy4qwqfDgHpAPH1AwqpcdTAwMDTCvi8ze3fCrMK+wq9efGlNw5nDkmnCryTDvcKRwrXDkH3CqcKdbic+wp9cdTAwMTR5w4vCqMOnwq8kw4VNXHUwMDE0eUs/KMKzJMKFeFxcdMK/w5zDilx1MDAxM1xcXFzCj8OrXHUwMDEzw77DtsK0csORw5hEXHUwMDE3fkDChMOYVsKSw5rCm8K/wrDCqFHCjcKzwrtnLsObXHUwMDAyw7JcdTAwMTfDnGfCnH3DnMOCw6vDusKPwrhwwpTCvFx1MDAxM8KBXFxiw4lcdTAwMTTDocO1T27CuTBGw4UhU8OPw4DCgMKpwpHCqSnDqcKRw5hcdTAwMThdwoEpPUrDg8O9woXCkDjCrsKkKcO2XyjDp8KQw5g7wpF4LcKXwq7DkMK6w7jDsMOGXHUwMDFmTmfDhjHDnk/ChEbCqMKEwpVpw57CvF/Cilx1MDAxMcKDZU48TsKTXHUwMDE5w7/CoMO8Xz/Cl1PDiV9cdTAwMTPDgXnDtFxcYsKkWMOBaMOIXHUwMDA2XHUwMDE5di1Iw7zDuCjCkMODw7pcXFwiwpbCg2XCvyHCt8KVwp7Dv3HCvWlcdTAwMDZcdTAwMTVbw6nDnFxcXFxjwp3DicKoZiprbSZcdTAwMTPDs3PDkMOTwpUgwobDpHNcdTAwMDHDhMOfwpDCuMOYa8ODw7rCicOzw5HDosK7w7wqXHUwMDE3d8OEWmpDZsKxaMO6XHUwMDA1w7ZcdTAwMTDDk8Oyw41cdTAwMTjDuHE9fVx1MDAwZlx1MDAxZcODXHUwMDFjw5VxdzPDhlJFXHUwMDExXFxmZ8OXw4nDt1HDrH5cdTAwMTLCszdcdTAwMWbChlnCksKuw5PCncKjw73CisO3w6zDvsKQw7sxZMOqw4RXw6EuXHUwMDE1wpZoZ1x1MDAxNMOfScOEXHUwMDA1J8OvScKdTCfDo2rDj8KddsKwOmnDkSXDulx1MDAwNjY9fVx1MDAxNMOUwonDkMKRPUrDr8O9XHUwMDBmPUDDs8KmwrA1wq/DkW05w4zDuFx1MDAxY8Kow4LCsyDCksKJX8KdwqvDrMKGXHUwMDEwNypcdTAwMTPCk3jClMObwoXDimTCsVx1MDAxY2XDn0NEXHUwMDAzXFx0w4rCpXfCkiFcdTAwMTTDkcOww57Dq8KFw7fCjTVsw4nDssKgw73Dp1x1MDAxZV3DlnXDhMKNIMK6K10lwrogwoDDn1x1MDAxMsKFXHUwMDBmwozCpC3CnS9/wpfCpHooXHUwMDA2w4PCi8O7XHUwMDA3w5nCn8KUwrJ/d8OBw5/CsUtUcMKgw7xcXFwiwqTChzkrwqRNw4FwYsOTwoMzw71FwovCkErDv8OXwrVEOlBcdTAwMTdgQ1x1MDAwNsK6PUDCuMKswrknWsOTwpPDiFx1MDAxZcKTw4g4XSRfw43CiURewp3Di0t4w5VcdTAwMWRpYlTDiMOhw53DkUPDn8O/OsKBOScpKsKHwrRzwqrCi8K4wonDi8OfSVx1MDAxN8Kmw7jDkMOOU3d8UsOjwoPCjsOswrXCnW9Zw4XCkS/CpVx1MDAxMcKnL1x1MDAxMcOew5LDvGzDjELCl0RARVjClMOww4Vsw6RQcjHDiMKHW05dLkXDlcKNXHUwMDFkwpbDmMOGw6BzwpRJwqEkwrnCqSfDoVx1MDAxYzhcdTAwMTdcdTAwMWbCksKyXHUwMDFmw6vCuGzCoV/ChcOHw5vCrsO4wo83w7HDu15uO8K4wrfDncKDwphnSVDDuF7DrW7DmSFiwpbDsXfDgS5XWVPDqSnCpcKYQsONTcOkdsOzw71cdTAwMWPDr8KpUMKMw5d+XHUwMDFielx1MDAwNVLCiVx1MDAxY1F8w7HDj8KNw5XDjMKTwrPCgsKYwoxzwq1cXGJnw7tCwoVXwrzCkcO3KMKvw67CsVx1MDAxMcK7XHUwMDAzJ1x1MDAxZMOYXHUwMDFhw7nDjcOiwrXDp8KXTHvDv1x1MDAxY8K/acOTXHUwMDAzVMO/ScKuw404w7XDqXLCsMOnwqnCum7DiXBcXHTDmsODw4V2w5zChnhYXHUwMDE2wo7CgMOJW8OFw5PCqsKGQMO5wphow5JcXGbDu8O1O8K3wobDgjBHwpVsw4VCwpU2Z17DuMKsTlx1MDAxZsKcXHUwMDEww47Ck8KFR8K0TMKkw4VYwpjDry3DmztdXHUwMDFkwq5OXHUwMDExwoc/QcOaw7ZRw5A+wp3DgVx1MDAwMlx1MDAwNl/DuFx1MDAxZSh7wrw9SsKLw5ZWYyRewpVcdTAwMGXDrj1APX3DkC3Cl2cpcHLDiMKCa8Kvc8KpPU3DrsKlw7/CqcOfwok2w7N9w7zDnsOpwpbCmGN9XHUwMDE4XHUwMDE2w6nDl8KGdMOCXHUwMDE0w4fCrMO2wr09fcOfw5F0w6Nuw7xcXHbCmcKuXHUwMDBlw5vCv8OzXHUwMDFiwrxLwqc9TSw5w69cdTAwMTQqwoZOworDl8ODMFs9QMK9VsKkUD19UsKIwqrClXXCg1IpXHUwMDFjwoxcdTAwMTlcXHTDnsO9wrPDlyTDrz19woVRKCbDjGY+wrlAw5rDr8KTwoA3ccOCXHUwMDFiWMKTXHUwMDFlw6ZySD/CpcOpw6jCuDHCt8OlPX3ChcO+cFUtd1x1MDAxYcKMalx1MDAwNcOLw5NfayHCviPCsFx1MDAxM054w5g/XFxmw5B7XHUwMDE4Z3HCh1bDnEtGw5Y7XzfCqWHCicOeb8K8w6fCnFx1MDAwZk7DpMKRw5Emw48pL8Kjw4JcdTAwMTfCjGzCpMOLwp19wpdDM8OfXFxcXFJcdTAwMDTCpFx1MDAwM8OKRl/DgMKawoprM8OWwp19w7bCssKPwobCu3JvwqxYa1JWXHUwMDFkwq5/XsKJTm9cdTAwMDTDljvCgVx1MDAxNMKzMsKkw4TDtcKYXHUwMDEyw5bDv0DCtcOkNsKnXHUwMDEywo7Dp8Ogw5JxbDjDssKCSsO7woDDiSVwXHUwMDEyw5rDrMODacOvXHUwMDE5YknDpMOswrfDgMKVbFx1MDAxMMOVwoRGXHUwMDA3XHUwMDE3RFx1MDAwN1fCt1x1MDAxOMKgw53CiMOQwodbwpDDkEvDpVxcdD8xKFx1MDAxZcOdJcODTsKWw7TDlDM+wq/DuCPDlD/CqMKOJlx1MDAxYcKww45sXHUwMDFhwo1hXHUwMDE2w6HChm87VUFDw5ZcdTAwMTBydGbCgsOlwogtwrHDhcKiw4DCqsO5wpDDp09cXGZww69tMlx1MDAxMD19TcKWXHUwMDE2wpLClMOON8K1fcO+wodcdTAwMDXClnLCmsKnw6XCoGnCncKswqB6f8K7w5bDksK0w4zDl1x1MDAwNGZ4woLCkX/Cm8KTw5E3IVx1MDAxMcKMwqtcdTAwMDHDulbDqynCoCNcdTAwMTcpXFxmw6kkXHUwMDAxwrdcdTAwMTHDtcKJXFxcIsK5wohcdTAwMTY2w7nCvsOBw6IoJkN/wr3DqFVcdTAwMWPCvFxcYsKDXHUwMDEzw6VcdTAwMTnCsWrDp8KEWytcXFxcwpDCgj7DsMOdwq/CgGxGUmzClMKVNcK0XHUwMDE2w50mwp9WRcKBIHcxwqBcdTAwMWXDmm/CtsKew4rCn8K/KsOdwp/Cj8Ovw7fDocKPXHUwMDE1VMKleFx1MDAwZsKXw589TTZ0w7bDhMKNesKnwqp+Wis9QHRgw5vCkGnCssOFw7/DtcOXwrF3U1t8w5LDqcKbXFx2w6Akwotdw4tRS8Kew77Cs1x1MDAxZcK9wrbDj1xcdFx1MDAwMsOsI8Kqw6l/wo/ClHHDvMK9WVx1MDAxMlx1MDAxOcOtQTTCnsOFw5FqXHUwMDBmXnbCnMKpXFxmfEBcdTAwMWVcdTAwMTHDu8K/WSE9SmHDjGLDhjhcdTAwMWZcdTAwMTZowpNcdTAwMTNaYMOXw5hcdTAwMWLDlcODLlxcdMOHwps9fcObJMKXwqzDvMOGwopcXGLCrHBmwr10K3RbWndZw5jDicOwXHUwMDFiPX3DgcOKfMKFw6tawpdgw4E9SlPDkFpvwosqwrE7SMOnWVHDnFxcdFl+w6Z0wrDDhMKlb8O4w5NtV3BcdTAwMWXCtMOyPHN5XHUwMDEwXHUwMDE3w6QuwoXCrMOmwrPCjMOUw6NLwrdcdTAwMDFmVm8tXHUwMDFiwpzDuSnDvVxcXCJcdTAwMTLDm8O1Y8Kww512LMOEbcK7N1x1MDAxMzFAVMOkw5l0PMOTwoohNcOkXHUwMDA1XHUwMDEzfsKbwqVYdMOSXFxib1M5X1bCpE49TVnDrHtNwo3Cj8K2XHUwMDA1JlfDjkHCtD51ZcOjXHUwMDFhw4LCo2zDvEHDsMKIwojCunvDgMK2W8O3QVx1MDAwZjHCon7DlsK/wqTCjcO5WWJcXGLDjkHCpMKNdlx1MDAxY1HDjVx1MDAxMsKcI0vDuVx1MDAwNC1cdTAwMTDCvMKgwpPClz1Aw4PDnsKZbizDmXvCmMO7YMO3wo9SwqReOVjCt8Okwql1dmLDi8Kuw47CvcKJJMKDXHUwMDA1bsONw6LDln1vN8OUwrp+w73Dj0s/YsKEwqtcXFwiw4NOwoHDjVvDglpMXHUwMDFkXHUwMDE4w6zDkcOrwonDpsK4c8KeSUXCssKQR8Ogw5fDvcKWw7HDmSPDm8KJXHUwMDBmIX1GwpHDp1xcYsOpwoR2JcKFXHUwMDE3NcO4w7dRa1x1MDAxZHM7w7g8QT1NwrxEY8OWXHUwMDA1w65cdTAwMTjCvsKzwppcdTAwMWV0X8KvwqjClMKtw4RIXHUwMDFkwovCmFxcdsKjXHUwMDA1PMO+SkLDvMO7KT1Aw53DiVJQw5xNw4RcdTAwMDVcXGLChCRDJ8KjcMKpSsKUMMOfO8OQwrrCgMOFwq1tM0LDvDfChzDCmHTCn8KpOlx1MDAxNFF3wqLDkMORwoB2UHbCq08oYcOgXHUwMDAybVx1MDAwNV/Co0Zsw4lvw7pwwq9yw77CkHHCl8OtSsO0wq5cXFxcdlx1MDAwNMKjwoDDtj1AUlx1MDAxOXQ9fVc9fVx1MDAxZMKrXXBcdTAwMTPCmcK6w45cdTAwMDLDlcOiwrrDmsOpWVxcZsONXHUwMDExc1x1MDAxNsOhwpbCh8KKXU3Dklx1MDAxOSTDncKzwpPDoMKef8OvfHjDrlx1MDAxNzQ+wpFcdTAwMDRcXHbDj8KGZMKZXHUwMDEwNcOkYFxcYsO2wqFcdTAwMTNkw7l2wpxcdTAwMTPDhcOjwpdQwrRWM3rDvsKCXHUwMDFkbiM1woHClMOsw4c4wodfwovCnlx1MDAxMcKwwqPDscKXZ8Kew57DgEjDqsOoesOfwoVawqtdY2jDscKvwqVcdTAwMDIgZ8Kkw4N4wqDDr2VcdTAwMTXCkD9rOlHDkGFWwqTDoG/DkFxcdj1Nw75uwoLDtVx1MDAxY8OLN1NcdTAwMWXDrVxcXFxnwofDmjjDi8KdwpwvfURkLsOZw6PDjcKJZ8KeXHUwMDAxw6E+w7zDgFY9fTrCmMKBwpLCicKAOXVvwrxcdTAwMTdcdTAwMTDDh1x1MDAxMEogLcK1w7DDqcORw6fCvFrDm8OMN8OGwpxcdTAwMTPDvjRcdTAwMWF8PX3DoD19QH49fcOvKUZcdTAwMWbDglx1MDAxM8KdXHUwMDAydsKHw6Nkw6fCt8O4wqJTwpVJwoXCssOMbGMtw4pcdTAwMTTCrlx1MDAxYsKBw4c9SsK8d0hcdTAwMDJcdTAwMTjDk8OPw4hwWsKgXHUwMDEzwpDClMOlTcKOMTQsw71XPMONdkkowoxFwoXCkFx1MDAwNsKSaMKiwrdcXFxcwr1HU8OwenNELcO5ecKLwo7Cn8KDw7rDtMOcw4TCujvCkyDChMOzPsKXwpvCkz1NwpRjw7XDv8OWXHUwMDFkd1x1MDAwNizCjFx1MDAxNMO9wpvDhU/DicOwaMOEw5s/worCuMKBXHUwMDA2TsOUc8OlQMKQRMORw4nDtcKYw69SMFxcXCJmw4tcdTAwMTZWw7XCisOAfcKrXHUwMDEzwrZ7wotVf1x1MDAxZVx1MDAxN3BfXFxcIsOxTHfDslx1MDAxNMKSXHUwMDBmwofDgsKcwrV7w5/DvsKmcXjDh0jClkDCtsKKdDHCuErDn3l1OsKsV8OpTMKAwrVDKkRcdTAwMTLDs8KuO8KKw7s8w4XDn8Kcw77DjFx1MDAxN8KdYijDt8Kye8OdNT1AWsO3w7xcdTAwMTLDlcOmScOZPX3CvGFcdTAwMTkjw63CmWjCplx1MDAxNsO/wqbCu8K4WFx1MDAxNsKjXHUwMDBmw6rDvcOWwrDDpMOmwp5cXGbDvVVQwr5cdTAwMGZgKUvDvTNcdTAwMDTDizTCkjjDhsOKw49cXGZhwrBcdTAwMWFJP2jDgFlcdTAwMWXDrMOMXHUwMDA3wq/Cr8KJw6fDhlnDu8KhUSwuMkfCtzZuQ8OqwohOw4jCpcKsw49cdTAwMDLCpyNcdTAwMTlAwrXDqcOMfMOJXFxcIl5nV8Kob8KIwoHCm1x1MDAxYsOJw7FTw444w6U+NsOXYcK1w6/DmsKSw6zCkMKBXHUwMDAyR0BZw6k0wq89SsO2w7twXHUwMDE5bD1KPzleUn3Cu2RQwpl2wqfDmcKNwrDCkj19w6bDlcOjXHUwMDA2XHUwMDBmw65OVXQ3WVpcdTAwMTjCjEtWwobCqMK/YCPDhVnDglx1MDAwMsKyQMKCX8OsRsK/dsK/ey7Dt0TDncKTYyDClMObwo7Cl8OUwoEqwqR/w7rCh8O4QcKLfcK8w55Hw7TDiyPCk8OmfcKCw4xUwoFWw73DicO0YFxcdsK9IGpnQVXDgSvCqCNcdTAwMWPDvcOvw740V8OXXHUwMDFhwq1Fw75zwoDDh8OFeMOCScKJUMOFasO+wp3Dv8OhbMKiw5dkP8K8QsKwRsOhQyzDqcK2w6Vywq9cdTAwMWbDi1jCry/CscKee1x1MDAxZEA3cUHDvD1NwpLCscKiw4xve8Khwp7DnMKhdjXDsMKiwqRcXGLDhFx1MDAwM8KrXsOdw5w1w7c7OcOrw7PCtMOeZMKMwpPDuMKzMMO5wrUjwr7CpcO5w4XDjMOZV0rDtMOfw4p3w5vDr8O6wp9cdTAwMDbDo8Kcw6XCg8KxXHUwMDFiXHUwMDAzc2fDnTE9fS1cdTAwMTJ+w79VwqvCtj1Nw69EQF9mwrlcdTAwMWLCq2nDqsK+w6LDolx1MDAwZT19PUDCrmHDmlx1MDAwN8OSw4h4woJxwqRqwr3DoMO5wp1Uw7Ezwqw2XHUwMDE4wpQ+Q8KvdnfCu8K7wrI4wqfDlMKSwrfDoStcdTAwMDJcXFxcScOhK8K9QcKvwqllZMO8XcOVwo/Dp8KOeUXDscOaKi5cdTAwMWLDq1x1MDAxNsOxw7fCn8Off1syw712wprDtWYvQl0lw5/Dsy3DlcO6MCDDoMOJw49Rw5Asw7Vew7HDqVx1MDAxN8Kbwq/DnsKSP8Ofwr3CtkUnwoDDjmlcXGLDqcK2wosowrcwwpTDlsOAwqllwqrDvl3DlVx1MDAwZmrDmMO6wqXDmVx1MDAxMsOyNX49QMO3wqPDkMKXSD19w67Cs1x1MDAxMD9YwoDCmMOzw6lQw6bDgsKzwrfDqsO7wo7DvsKdXHUwMDA1UsOQbSE9TVXCo1BJSMOYwr42w5LCm8OSwq7Cgz9cdTAwMWTDujBcdTAwMDPDiTtdVELCkMOWO8KXXHUwMDFkXVx1MDAxNMOEw5LCs1x1MDAxN8KBw7Mhw5DCv8KQw5fDl8Oowr/CusOvTFx1MDAwMTXCqMKzwovDssOIWcOdw7dcXFxcZVx1MDAxMXhcdTAwMDTCl8OsL8ORw4/DhivCtSN8N1x1MDAwMsO2w6Eow4RcdTAwMGZcdTAwMTnChcORw6BcdTAwMTNMw7fDncKDa8K7woNJWsKhwp3CoFxcXFw2PX1cdTAwMDPDsHNbPX3Dl8OLw5jCt8KHXHUwMDE5woDDqlx1MDAwMVx1MDAwNMODSz1Awp7CvMOFw7rDi1xcdsOVcFx1MDAwZlx1MDAxN1xcdsOpwr3Cg8KOaj1NwqbClMOcwr9kMlx1MDAwN8KpRVx1MDAwNl3DrUg1wqvCmcKVMmxcXGbCtT5cdTAwMDQ9TcOKw6s6w7pcXFwiN8K0w5LCq8Ktw4pcdTAwMDfCuUHDtz/DvkR6wpUyw5JWOMOdwpgkYMK9wqJIXHUwMDExwqXDv8KFXHUwMDAxwrN/woDCqsOOXHUwMDE0w69dw57DmSPCp8KaL8OyT8KdwpXDjcOMw6AzMMOdwqvCjEFsw6FcXGbCscOfXHUwMDE0cFx1MDAwMsK1a8OewrfDp8Kyw4k0wqNcdTAwMTFrwojDo03DqjDCji7CpsOOwpVkw4DDtMO0w4XCrHfDvWNNej1Kwr5cdTAwMWLDp3N0c2UjwppcdTAwMDfCpz1KQMO1cy7DnmBne1x1MDAxZVx1MDAwNllKw4vDksKnZsOeY1x1MDAxMcKhXFxmw6TCoVx1MDAxMsO5wpltw5gpXHUwMDEzYSljw7jDlMKpJMORw6knw7nClsKRXHUwMDFhw7zDj1x1MDAxZcO2wrTCm8OoXHUwMDEyZlrCrcKNVi7DlCvCklx1MDAwNMKrw6TDpDHDnynDqD1AXHUwMDEww7nDp8Kjwp99wpTDqiZYLk5jI8Ogw53DjUTDlMODwr3Ch2w+w47DoMOlwpjDrcOJJ2o4w4FCPMKzPU17YWs4WSPDimzCjcOtTMKiwoDDm8Kke1x1MDAxMVZyw4shY2FGw57DscORw6vDjkhcdTAwMTdPXcKfU8O+w4nCj8Kve3Baw6TDnF/Do1xcdMKvf8K3wpbCg8KATyRpXHUwMDA0MsOYw5XDnTRVXFxcXMO9bMKLfMKfYT19wqNlw5TCusKOw7VcdTAwMWPDvSlcdTAwMTBcdTAwMTMkUcOhMizCvsK3wprCr8O4w67Dq8KbwoHDmMORWU9cdTAwMGZvTcKPwoMxw6/Dp1x1MDAwZnF4QWHDgVx1MDAxZsKdw69cdTAwMWbDq3Z8XTl4w6M4XkPCmFjDvcKdI8KfwoZcdTAwMWHCk1UkXHUwMDEyXFxiwpwhXHUwMDEzw5zDqMKrw47DrcKBwqjDvMKCwqxgO3HCqVxcdElJK3bCjFvCkMKoRnHCrGpcdTAwMGbDslx1MDAwM8O2w47DmUbCilx1MDAwNMKQWcOYw5s3W8KDQVx1MDAwM8KwXHUwMDFhJVx1MDAwZcKOw5BrcVx1MDAxZcOzw67Do8KZw7DCnsOtf1xcYjrCg8OEwo03bVRcdTAwMDbDlsKpUcKBXFxcXGbCvsKQam3DocKDwqk9QERvw5zCg04rwqtbVMOzNj1KwrA8w5PDr1x1MDAxMEjDg8KON1x1MDAxY8K5ajTDg1TDoFx1MDAxY3BJLVx1MDAxNcOEXHUwMDFjJcKXdktcdTAwMDPDtlx1MDAwNlx1MDAwZlx1MDAwMVx1MDAxZVx1MDAwM1x1MDAxMsOnwrhcXGbCvmzChcO3XFxcIilkw4rCmVx1MDAxMlvCp0bDs1x1MDAxYkA6wrzDgMKJwo3DjcOtN1rChcOow4xPworDvVx1MDAxZcKRwpMnwrLCucKYdC3DnMK3fVx1MDAxMD1Nw4RcdTAwMWPDuVx1MDAwNMOKQ3A9QMOJw59cdTAwMGbDg8OLw67Dp2LClcO+w59Iw75cdTAwMTfDry3CvXd3esKmPsOxwp1cdTAwMDdwKDtEw6fCucO4wqPCuMOuw5rDkCrDgMKLMsKKU1x1MDAxMMOdwpwsXFx0wrrCqVZcdTAwMDbDmsOJwpPCjsKiw7bDgiZcdTAwMGZcdTAwMDZcdTAwMTnDnFxcXFxyw68wwo3Ds8ObXHUwMDFiWjPDkVB7OVx1MDAxY8K5UsOww6tgwp3DvsOzw4LCksK8wotcdTAwMTPCvWfDs1ZSMsKtw7vCkcOVw7Vlw4XDqsKSXHUwMDA0XHUwMDAzXHUwMDE1wqcww4jCq8K/MsKCXHUwMDFmKm8swrRcdTAwMTnCiF3DnEc3w55cXGbDjlx1MDAxYcKmMSY9QMK0K1lfw7vCsEbDiz5UXFxmw41lw6PDnEvCqEPDi8K3w7/DlMOww5bCkMOXwpE9TWBlwoDChS7CnMK+w5xOw4TCgVx1MDAxN8KVwo7CoVx1MDAxNcKbwq3Dj1xcYlrCnGI3w63CscK/w4BcdTAwMTI7w4xcdTAwMGZNeMOGQMKyYsO5XHUwMDA3XFx2XHUwMDFjOcO7XHUwMDEzw4VcdTAwMGZcdTAwMTXCpWHDtFXCoT19wohcdTAwMWPDgXzCu1x1MDAxNTnDmFx1MDAwMsOHXFx2wrjDjMK7w47CosKOwq1cdTAwMDZ2w5DDtyZLwobChyNxK0w1YVx1MDAwZcOlasKJw63Cu8KmwplcdTAwMDLCv1xcdMOyJ8O1XHUwMDA2XFx0XHUwMDE4w5pcdTAwMTBPw54kdMKdwoLDhsKKPlE0w5bDjlx1MDAxZlx1MDAxZVx1MDAwZsKQwoJ7Plx1MDAwNMOPwpBcdTAwMDLClztgXHUwMDA0w4UswpfDusO3XHUwMDA2WsOEVsOpwrzCmS7DkMKqw6xcXHTDh8K3w4VIw6vDnsOgSHzCqMKkV8KnXHUwMDExLl3Cj8OlYsKJw7MxXHUwMDAzR8ObR0Bswrd6wpjDg2VVwoDCtClXXHUwMDE1wqfCiTnCiMOIw7/Dplx1MDAwNlxcdMO1SWDDrlx1MDAwZsOzwqHCkT9cdTAwMGYxwoXDksKkYT9cXFwiYVlcdTAwMTB9w6bDkcKEw7BcdTAwMDbDtmtcdTAwMTfCj8K0wo7CjcONOVx1MDAwM394OsO+SsO2wpbDgMKhw7TCpsKZw4DClcKow4Mxw7HDtXBoK8KQXHUwMDEybMK/w4DCgMKDw6EuZMK0XFx0JMOiwrpcdTAwMDc9fVx1MDAxNVx1MDAxM1x1MDAwZsKDLkZAw6xcdTAwMDXDnVx1MDAwZlx1MDAwMcOXZVx1MDAxOcOawol4w4bDrcOQXHUwMDE0N8ORw4Rzw41rQsOaXHUwMDBlUsK1OcOzXHUwMDFhQMOpw6A+wohcdTAwMWXCuFNcdTAwMTFcdTAwMWEnUjHCpcKPwp3CjWcnTMKXSHTCksKDUMOyJjBZYFx1MDAxY0x8U8KYw67DgcKRbcKJclxcXFzDn8OAw6hcXFxcRcOKbXrCksOUw6ZeYVJcXHTDqjEtw4LChcKENlx1MDAwNcOLwo3DhEIjwr/DpW/DucKCecKpwpNYwoFcXGbDgSjDolDDjsOAOcOawqZcdTAwMTnCsV/Dm8Orw6DCv8OsScORw4HDhENcdTAwMTLDjMKHw789Slx1MDAxMMO5wrMrw7vDt8K/XFx0wpDCj8KOw5/DlFx1MDAxNMKlXHUwMDFmXcKeXHUwMDFiXHUwMDA2wqQkZMOAV1x1MDAxN8KAOTTChmjCicO+w414Y8OrwqLCiCDDoSdcdTAwMWTCtsK4wpQnXHUwMDFkXFxiXHUwMDFjw5PDi8OhwqFcdTAwMTQmw4rCpsKfwozCmsOaMMOMwqZzwqtTXFxcIlx1MDAwNMKPXFxcXMOcwq7DoMKDw7M6w4/CjHXDmMOmwq7DkcK2XHUwMDBmKmA9QG9pwpdBYMOew6/CrMKDSGfDi3dhwofCuzDCiFx1MDAxOcOVVsO9woEqXFx2w67DlVx1MDAwMsKdwrHCmXVZwrlEwpN1wozDtsKCUcKIXHUwMDFlXHUwMDA3XHUwMDFiw4zCi8KReyrCk8Kkw5NcdTAwMDE7w4TCgFx1MDAxNF90wo89TcOPw4TCi8OwwrXChsOTwrTCplx1MDAxMydvZMObw5k5V8O8WMKFRcOuwo/DhMOlPUrCn8Ksw4Jpw4o+MlMuXFxcXMKvXHUwMDFiT8KVw5/Dn8KzwokrwqHDqVx1MDAxYTIvw6fCh3h1worDjcK7w7PCnsKuWMOQw7hcXFxcwrvDkcODRVx1MDAwNXfClsKMTMODeFxcdMOMwqJcdTAwMTLClsOqw6JcdTAwMTBhWsKawpczI8O3w71rw4LCq8K+w57DvMOKIVU9QMOXwqZFwpbCrcOmwqzDoj1AOMOMw43DjMO6wqvDn8OcXFx0w5nDt8KwTFxcZj1Nw4lGWCnDv8KLZ8OlZsKFYFx1MDAxOHHCj1bDmUZYKcO5w61iwrZ6V2XCjHHCmcO3w5xFSmYwe1x1MDAxMWvCvVx1MDAwMcKRw5Mgwr9nXHUwMDBmOcKYw4zDrlx1MDAxMVx1MDAxYsKrw5I9QMKkJMOwLMK5UVx1MDAwMlxcZsO9wrlZw7fDgFx1MDAxOVxcYmbDoEPDu1FIwqHDlHM9SsKnwrzCtD19XHUwMDFkdH1cdTAwMWTDqcKcf1nCsMOTwrpcdTAwMDLCpCR3wo5ZVsKlZycnw4o9QMKYw5nDp8OOw7jDqMOxwq1Bwp8twpQnwqvDmFl4w6plZcKcwo58w5fCglx1MDAwMcKiw5AsVVx1MDAxYVxcXFzDv8KFw4tGXHUwMDBlw49bU8O2woTCkcKRw5BLw61LUMOHXHUwMDE0w4/DgMORw7BvXHUwMDFjc8KLUMKww41OVDZcdTAwMTTCuXjDgsK9esO2TsOcXlFNYMOaXFx2R1EmJMOAw5jCiWNcXFxcPUrCmcOOwpDDoMKrw4dTwoRcdTAwMTVjK8K+w73ChDdCXHUwMDExwp7DgsKGwoHDlcKMZMOwfMOKXFx0wovCo1x1MDAwZlx1MDAxNTRKw6HDgyPDknE9TXFcdTAwMTDDksKaWcKNwrfDllx1MDAwNsK+w6NcXGJRX1x1MDAwM8K7wrvDl8KzwqfDsy83U8OmZ2VafcKmXFxcXMOkXFxcIsOoYWUywqXDtU7DnVx1MDAxN8K5wrTCsy3CtsKabcKiQVxcdMOnZcKFw7c2w51jUsOQXl3CsE/CokxIYMKjWltcdTAwMTR4RU5pwqrDscK/acOGwp9cXHTCu1x1MDAxZMOfwqHCkVc2bcOqcl07wr9ew7VJem7CkMK1w5DCnVnCl8ONLcKmXHUwMDFmwpDDg2TCtMOEwo9cdTAwMTIww5rDhSZcdTAwMTBbe1x1MDAxOVjDhsOxw7BqTcOWPU1OLsKbw7DCjVjDscKhPUpNXHUwMDAyw5jCk8Olw7PDrcOOKy3Cr8KmISnCtXEww7DDmsODYsO3w4wmw4LCnl3DnlPCrlx1MDAwMVx1MDAxZT8rwpTCrVx1MDAwN1t0woYuXHUwMDE0Qlx1MDAwMsKWS0xYdlx1MDAxYcKZwplqWGExXHUwMDAzwp1cdTAwMWPChVx1MDAwMVxcZsKtw4HCo8KaXHUwMDA0UH7Ct01Kw5HCrlg9TW16XHUwMDAzwo7Dg8K4wqRcdTAwMDPCsMOUWiBpwoY6XHUwMDA1XHUwMDBlXHUwMDEwwoVcdTAwMWJwTsOCN1VzwoTDgzlXTcKORcK/wprDssKBUnYkPETCisKTXFxcIlLDtsKpRVptRcKfwrcmwqgjwrLDpEDDj8K4PUrCvjFewpQrXHUwMDE4R8ORM0DCkk92SXRcXGJkw5vDiMOMPlx1MDAwMifCocOiwqk7R8KYL8KAw7vDvlDDmsO5YMKtw7zChsOaWVhcdTAwMDR7wpFcXHRdwqzDusKOw6nCm8KNTmvDkcKzKcONXHUwMDBlNMOnwqhcdTAwMWbCgMOYw4xcdTAwMDFhwp4tcMOmwqXDlcK5wpx8w7TCrsKTMMK9RXBPcDdFwrk+SUHDrmHCrEzDvVx1MDAwZsKVw50tXFx2OUrCk8Kow7TCnmpcdTAwMDNbJ8KWVGk7w5DDusKWw5bDisOALlx1MDAwN2s2wpdPdjPCh8KaMMK1I8Odw5vDqnBIO8ObN8K1eD7Cp8OLdGLDrVtEKVxcYjNXOcKLOSPCpMOPMMOKwpHCo3o1XHUwMDAyw7LCvcOzJcOsJMKDw7FcdTAwMTZ0wrXDqkbDn0/CiFvDhsOwXHUwMDFjWMOCXHUwMDAyw4HDhMKtJjvCjMKJw5fCg1x1MDAxM3h6w7rDnEzCl8KaXHUwMDAxwrhkVMO9w4jDoyM4cmHDrcK0w4LCujvDklx1MDAxYlx1MDAwZsKlw4zChnJUWlHDrEjCt1x1MDAxZsKHw6DDmVx1MDAxYVc9fcOnf1x1MDAxNn3Ciz1Awr00w5ZdTsKLUsOfOcOBLVJ/wqZsw6LDvsOXwrrDtETDt8Kwwp7DrSPDhWNUw6zCtlx1MDAwZiVcdTAwMTTDgMKJwodCPUrDlVx1MDAxM8OAWcOrXU50w7wlXHUwMDFkQ2NSf1x1MDAwZlx1MDAxY8KWW8KJL25fwoPDjMKIw4JjwpXDu2NeUyFLQcOTw75cdTAwMTZcdTAwMGZNw6jCgcKWZTHCtMO7fcKgwqEnw6cvREB1XFxmdcOgLHVSNsOgwrp+Q1LCgnnCtFxcZsO8wpDDo8Kew7ghQz5cdTAwMWNEwqlJwo0xwqxXwpvCr8ORWsOjR8OGw6fCtCZUXFx0dcO4w7pcdTAwMTJIwpNLKSF7wq5Gw4TDsWnDtsKyNFJcXHTDpXDCmcOZe1fDr8Okw43CpMKUw5nCuSo9Slx1MDAxY8OZw5jCq1FWXHUwMDE1wpdcdTAwMTfCtlx1MDAxYcKsw6UgI8KMwqM9fVx1MDAwMS7DucOQST1AMMOXwobDqsOLw597wqhcdTAwMTHDjC7DkSA4w4Bhw7UgY17DmCHDqcKDw4okcMKZwqpcdTAwMWHDmVxcdsKBRzlcdTAwMWPDhMOtwrpZwpjDu8Ouw5hLXHUwMDFlwrbDjcKyXHUwMDE1LlAoV8K4wpFWXVx1MDAxZMO1PlxcdjlcdTAwMDXDpXXCtMOMVMOpw7jCjMO3Wn1cdTAwMDPDkVbCtjLCsXhcdTAwMTl6w7zCilfDoj1Kw5XCncKIw7/CtnRracK0wqHCgSrDtjlEwpbCr8KDw5LCs8O3wozCqSPDkVxcXCLDolx1MDAxZSHClsOCXHUwMDAxw4A6wqlfw5dcdTAwMWQsw6ZZN8KLw7PCjMO/w4zCuMObe8KgejtcdTAwMTDDtcOpwrzDrMO6YcKvwqtqLsKFw5FcdTAwMGZrwpJcdTAwMTViLcKnw4ZsJcKSK8O5w6ZxQzNUXHUwMDA2dsKsdMKKfTlow5PDt8OlK8O0NcKBw6DChsOewqXDgcO9wp0vw4/CpsO3w7VcdTAwMDTDuVUzTW11w7tcdTAwMTfCk1PChMOgw5lcdTAwMDFcXGLDvlx1MDAxNDNSan8pXHUwMDA0TMK8wpDDlMKfXFxmXHUwMDE5w7PCvzLCskLDnMKhXHUwMDE5wobCucO4ID1NXHUwMDE5LkLDpFx1MDAwNcKZw6hZw57CmcKqMcK+L8OjXHUwMDFheFx1MDAxMMK1wrTCgjNHJMONXHUwMDE4w6ZYXHUwMDE3S8OlM1x1MDAxOMKGw4kzwrXDqMKdw5dcdTAwMDPDt8KBwpc9SsOvw5/DvsK4w6/DrcOfw6Q1w5XDhMOBS1nDgHh8wrJ1woLCh8OzwpvDtD1Nw45cdTAwMGXCkMKwZ8OQwpfCicOgw54nXlx1MDAxNsKBLcOVwotrZcOCwoRLVGzChFx1MDAwNMOUwoLDu0DCvMKSw4QqYcKoP3fCuz19w4RITUZjw5x6w7HClsOvPX3CozvDqknCm1x1MDAxMS9cdTAwMDTDp0LCgMKxVMKxdz19w7/ClDnDr8OgXHUwMDFmw5xjwr86TVx1MDAwNMKQRkjDiShPXFxiQcOjQMKqXHUwMDA3w7bClcOXw4Iqw7fCkcOmw6lxwopcXGbCrMKlwp/DssKaw4I9TcOMw689fcKEw4hDwpVcdTAwMDXCicKTOcOfWnvDrlAsw7J+w5bCnMOYVWlCwoDDvyVrXHUwMDA1w5vDj8Otwp1cdTAwMTRcdTAwMWbDtkrCicOMI8ODwprDl8OQaj1AKj19w7pYw4TCtlxcdFx1MDAxMMKswqlWw6HDo0xcXFwiw4tcdTAwMTE0woPDisKyaVx1MDAxOcKvwq1cdTAwMWVxXHUwMDA3w5DCgMKpX1x1MDAwZWE1MzBkdz19wqzDsEHCjlx1MDAwZlx1MDAxYsKtwp9AwqnCkHTDlMOjw5ovwq7CrcKrw57DoCZwUcOQJiXDvMKsw5DCtGJew6UufsOFQ1xcdmPDtGE1w493Z1xcdsOYw7nDh3RcdTAwMTI2w7nDuMKPPUBYw61CfFPDtMOoL8OHwoN9bGY1wo5Ewq3Cs3c8w5trw6vDv1x1MDAxZVfDlcOiwoxdeMKzWjptwqIlNTE9fUjCh15cdTAwMDVcdTAwMWJMw7d0w49cdTAwMTLCt8OEXFx0KzHDuH/CrcKNwq7CocOwwqJcdTAwMGbDp1x1MDAxYcO8wpfCkD/CqsKwXHUwMDA1wrrDni9zXFx0S8O7IMKSwq7CqsKjQW7Dk1x1MDAwMsOjwrbDocKCwolcdTAwMDXDqVBBw7rCv8KSXHUwMDAyJMKGwrDDgcOzwodjXFx2W1TDocKyXHUwMDAzwqfCk2AlMjliw7VcdTAwMTDCoFXCuSjCqsKKwoTCs8OzwphcdTAwMDPDosOnIMKXXHUwMDA1PFx1MDAxNUhcdTAwMGXCsHcqw6PDj8OnwoDCjk89TcOmwqzCjMKtXHUwMDFjVcOdw6DCskdQwpTCmMKKwpbCv8O3ZXfCgsKRcsKSwpLDg8OIwpE+aEU9TUvCulfDrFIlXHUwMDAzccOMwqZcdTAwMWJIwpI8R8KGw4bDgGDDp09cdTAwMTnCg8OHc2VcdTAwMTFcdTAwMDHCv0ojbn1cXHTCo8Ohw4hcdTAwMDdcXFxcw5TCk8Opw7owNDNpPX3DlUBcdTAwMDZcdTAwMTXCrSRcdTAwMTlANmzDtMOAXFx0XkBWTcO3XHUwMDBmXHUwMDEww7XDncOwwok6w5VQbcKLXHUwMDE1RFxcZmXDh1x1MDAxY8KVR8OQXHUwMDA1V8OTwoHDpFx1MDAwZj9WwoZTUEJzR2J0XHUwMDAzVTNbwoRTwrXCvGvDm3nDqMK8PX1qw7RcXGYqXHUwMDEyXHUwMDFlY8K7wrrDokTDllx1MDAxNMKGY8Olw4tcdTAwMDJFXHUwMDA1w47CisKAwpzCrEfDrFx1MDAxYzDDtTFrwrRNTcO7P3dKw4vCllx1MDAwNsOvwrI1wpBUcD19ZD/Du1x1MDAxYsOtwrN4woXCribCncOMNWRcdTAwMDcswoTCtMOFwqxQaMOXaMK2UsK0w6RcdTAwMGbChWDChsOTXHUwMDFiw5nDhXDClUx4ZcK/w65SwpZawpTDjlxcdMOKJsOEQVxcZsKrw74zwoXChsKTw706PsOFw5rCjCfCtnEvXHUwMDA0w4XCoU7DucOub1bCl0Mvw7YgXHUwMDEwVScnOVxcYj7DtFxcYlx1MDAwNWHClcO4XHUwMDA3wovCimrDgz19w4HDncKGw6DDkCbDhlx1MDAwMsK6PUDCk0pcdTAwMDRLfD7Cl1N7ViVcdTAwMWJLQsKFXFxcInjDnHHDoEZcdTAwMGXDq2vDv8KlwodifFPCvMOhXHUwMDFhw75aJFx1MDAxZlx1MDAwM8KMw6lcdTAwMTV3L8OkJcOgXFx0XHUwMDFjwoQ0wobDlUHCiX5cdTAwMTnDtnTCpsO4OMOGW8O2wplcdTAwMDEmw6HCoFx1MDAxMTfCkcKuRETDsMOhccKCXFxmPX1Te8OPSil0c8K9QlVcXHTDnDs8wrJ5WnfDoSbCuMKBw7vCjMKVw7XCgFx1MDAxZDQvwpI8IcOjwrpsw4osw6vDjzM+PijDiF9Gw5jDh8K+woPCq1bCr8KcXHUwMDAyUD9Iwr7DqSPDvMOhKMOCw5fCsyknw6kjXHUwMDExwonCj8KVLFx1MDAwZWbCs0vDuMKwwrLDjFx1MDAxMsOqM8OFwphJw5bDg0NgJsKmacO2P0paw5LCtXnCnMKoZcKVXHUwMDBlJcOGw5zDg8KSXcOVw4rCllPCuVx1MDAxZMKPPU3CjihcdTAwMDHDglx1MDAwNsKjPUpmQjgqwqcjw7ZDwqDCiMOPNsOXwrh7S8KNZMOqPMKTecKgQ8K0ZMOKS8O7XFxcIsKsw4bCpWvDpcOcd0o0wq1cdTAwMTHDiT8jw4Igw4DCqsK6XFxmZ8OaVyM9QGTDkcK1b3tuw5hJwppTw73Cr3ZVw61Pw51bSlLCkMOywppAw4tBwrlcdTAwMDYzw6LCiMKdUz19VMKrwpnDjsKHKMKvfkfCuCt0w7/Cq8OYelx1MDAxN05DXHUwMDBlw5TCnMKPwrtcdTAwMGbCrsKtw4hcdTAwMTHDi284wq7DgMOgwrQvQFx1MDAxYlpcdTAwMTDDj8Kswophw43DsTTCv8K/QMOtw7PCv8OIwrN9w4NcXFwiwrZ/bEtKw6t7woHDlTtcdTAwMDJcdTAwMDI+wojDjcObP8O2YD1NwotGXHUwMDExeHHDgcOLYsKgfcKPwpzCmMKcwr/Ds8OXwrbCpT1NwqbCpsOQwqTCmDbCtMOFUsKcw71FwotcdTAwMWLCt8K1USDDplx1MDAxZVx1MDAwZlx1MDAxY1x1MDAxMcOrw55cdTAwMTTCh1x1MDAxZVxcYnPCgcOfXFx2wq/Chlx1MDAxYmbCpcOeXFxiXHUwMDA0wrBcdTAwMWE7XFxmwq7Ci8O2wrbDmsOdZ8Osb0VcXHbDjMK3OmhaREtcdTAwMWbCsETCjsOVZsO2SsKTw7B+eVxcZi/DjsK0XHUwMDEwTcOMwpE/ISvDgsKwwqjClcO+fcKre23Dqy9AQFx1MDAwNzvCn1x1MDAxNSDDjCrDlMKiwrbCjcKHw4Njw4NZwrXCtFxcdsKiXHUwMDA3w4o9fcKww6g9TT1Nw5ZcdTAwMDPDuEvDllxcdlx1MDAxZsKbwrU9fTvDg8OGwqszwp3CpWpxQcO7w5LCm3BKNMKaX1xcdMK7wp7DosKGNMKhTjfCl2zDmFxcdkN8w5rCvcKbwrbCgnnDpMK/O1nDpMKGXFx0flXCm1ovwqMyTcO3w7YxWcO/w7vCicK1R8KpM8KYSEPCrMK7SG5cXFwiJT19XHUwMDFhXHUwMDA0OznCsmzCrsKcPUBRwr7DjcKKwo5sw70wbcOhw5bDqzcvw588woTDmVx1MDAxN8OzYsK3w6xfwpA0wp/CicKEKVx1MDAxNMKSYMKzw4hcdTAwMDfCmVx1MDAxYsK7XHUwMDAxOMK0b8O3U8OySFx1MDAxMX5cdTAwMTXDnsOKY8KXJcOGXHUwMDEwXHUwMDE5w4nDvcOaJMKqwqTCgcK9PUrCl2bCqFx1MDAxMMOqRcO1blx1MDAxOMO7PU3CisKydy9AwpJiw6FCXHUwMDE5w67CicKnKiXDqkLCnkY9SsOUWsKKQkDDnMK5wrEtwpDCq0h0woh0wqB8wodvwoLCnHPDnMOrwo8tXkV3LT5cXHQrXHUwMDE2w6A5w5rDhMOEXHUwMDFiwqvCrMKiNMOAPX02w5jCuVbCuMKwwpjCrT4qYHxJXHUwMDA0w6wnwo1two3Cm8KGXFxcXMKnwptAT8O+Qlx1MDAxNMKow6zDq8Omw6A4w6HCqzPCscK8OF/DosOeKsKwdS3CisOiw47DmsKNWMOfRsK2w5vCosOML1tcdTAwMWNcdTAwMDbCjX9WfMOvw5J9XFxcXMKfw7tTwpRcdTAwMDNcdTAwMTFlSMKxXHUwMDFkw6FnMljDqFx1MDAxOH/DmSfChsOow6fCmMKZw6nCuMOVw7/Dq8O5Y8KkV8KcwrfDmcKnwrLDpsO4w6DCicK1woPDr1x1MDAwMcO4w5Z2YsOqwpdBwrtbwprDnm/Dt8OyKGJ/LjXClyTCmcOQwpDDqcOKw75cdTAwMTLDm2luwoo1eMKIXWfCklXDuH3Dqn7DvsO0VsKcw6E6O1Ipw5tawqFSw6MwwofCrMO1wpTDiFx1MDAxNcOcw4ZcXHTDjsO1fMKow5VYwrUjwpfDpMO2XHUwMDExccKfw4PDtzlcdTAwMTPCvFx1MDAwZsKhXHUwMDEyXFxcXMK/XFx0w5N1acOpdcOBwrMmwpjCh2QjW8KHwoQjJ8OkXlx1MDAxYzHCnnNcdTAwMWTCvcOkw75cdTAwMWMxTWBow5TDuGk/IFNww5vDk8O1wqg9QMK0w7VrPUDCtMO1Oz1AwrTDtcOHwqDCsMOvwo3DqcOCw4gxYcOsw5Fewo1gazkkJlx1MDAwM0xIQVHCjC/CuUDCnVTCocK8wpPDhlx1MDAxZHxRw6d+ecK5ST1Kw5tewpdIaTpRw4nCl2LCvsKYXFxiXHUwMDA3w6knXHUwMDE4wqjCqcKRcsKow7bDjsKxZ2hgw5TDnMKQfFNcdTAwMDbDpydcdTAwMTjCmMKpwpFII8Olw6DDh1x1MDAxYsKhwrfDlC5bPU3CnVxcdsO4XHUwMDE3wqHCoSRlwo1cXGbCocKWXVx1MDAxYmVwf8OAw4bDq0lcdTAwMDTCqMKhw5LCjFx1MDAxYTXCosKbw4Ynw6xaw6HDrMONwo/CkEjCgcO/w4QhwoRxw6HClcOzwoNcXGZXwpRVwrfCocOhwpfDqcOlwpdcdTAwMWXDmFx1MDAxOVx1MDAxOcKYXHUwMDA3wqjCoVx1MDAxNVx1MDAxMkfCkVx1MDAxOFx1MDAxZlx1MDAxOMOQXHUwMDE3wqFhwrdcXGLCm8OkcFx1MDAxOVx1MDAxY1x1MDAxN8KhI1x1MDAxMsOHPj9cXGLCr1x1MDAxN8KhS8K4asOLw7TCvG1bWlx1MDAxYWJwwrh0w6bCocO2NMOowrE1csKRPMOLXFx2wppcdTAwMDZmw67DglhcdTAwMDI0bFxcZj1Ne8KmW1x1MDAwMl1Cw79cdTAwMWNobzvCmD19wprCgMO5MnXDnMKSQ2HCjMKPwoTDg8KDwo9Sw57DoitxI1tKwrTCglx1MDAwZcKMwrRcXGJcdTAwMDXCm8O5bzrDpyFcXGJcdTAwMTF3w4PCpDk5w7NTwp1tw7I7w7w9QMOTNMO6wp04XHUwMDA2XHUwMDA2c8KPJUpbbzbDm0rDkFpXdW43wrQtw5hewovDucOFPMK2w7QuTzROwr5rw6zDhSk6cXvDqXBCfVxcXCLCjlx1MDAwMkFcdTAwMTVHwrY7S1xcXCInwrTDnMOAZ8K0w5jCr2VcdTAwMWF0XHUwMDFhVUVHXHUwMDA3SjnDiWBtw7bDmsOcwpxzIMKSwo4gwr9cXGZ0XHUwMDE2wrrDhlnCh1vCnkPCoMOgPzFcdTAwMTTCj27CrEDCiFLChGs9fcKCw6nCpcK2w7TChMOYSMO5QcKlXHUwMDA2RcOzMHvDoSZww7omw4VcdTAwMWHDtsKowrhcdTAwMThcdTAwMTYjwqQkN8KdwovCp8KBaMOuW8Krwpd8w75uIMOyw7bCvcKdw7HCpldQwp0yYcOGUsOpw6VBw5VcdTAwMDEjw6jCvjfDplx1MDAxOMKQXHUwMDFkO8K8Pj/DiVx1MDAxY8K5XFxibcKRw7fDnjxcdTAwMDPCoyVbWsOFw7nChn5NwrE1KsKBwoTDk8Kkw7s4W8KYwqZcXHTCh8OtwrHClMOQwrFvKVPCkFZVYsKRwqHCtMKfPU08wqTCgmbCtFx1MDAxZMO/N8Klw4tlXHUwMDE2wpRBVmTDsVHCm8OyKnvCr8OfVcOTXHUwMDFkw6LDt8K3w5bDqVbDv1x1MDAwMsO1wq4zwrUvw4tCXHUwMDFiw5bDv8OzacKxw7FNwrZcdTAwMWY9TcKVw6t2bCvDjcKtwr09QFpcdTAwMTE1XHUwMDBmw6LCvsO6wrt0UMO1XHUwMDE4XHUwMDE5XHUwMDE5SVswXHUwMDA3w7XDpcOTXHUwMDAyw7/DmS/Dh1x1MDAxNMOqwqPCj8OGw48mw7DDicKHwr7DlsOYNFx1MDAxNMORwrpcdTAwMDHDrH3Dn8Ojw5FcXGbDoMKfw5rDrWLCuMO0Plx1MDAwMlxcXFzCmXRcdTAwMDXDsnxLcsOaw7bDtsK6wqdbST1KwpA7UmQjS8OmwqNXwrllXcOYw5NcXFxcfn1wIcOIwo3DvizCisOOwqrCssOse3l3w5HCi8KZw7nCisKlw5kgWlx1MDAwNMKNw6Emw4RLOcOdIzXCkmxRwo1Gw5rCk1x1MDAxYcKWUHnCkijDhFJcdTAwMThcdTAwMDQ7w5dGw4fCsMOVXsKSMMOawqhVwqbCn8OOwqB2w67Ct8O4XHUwMDAyI8Kjc31fe8Kbw4FSwprCj2HCgcO6wpc9SsOCUlx1MDAwM8OdcUfDtUjDsMKlXHUwMDAxw73Cs2DDg8KCwonDscKPW8K5wpTDosOnw4/DlFx1MDAwNnLDnMKxwo8yw7d1Y8Oew7LDusKbUS/ClcKxfcKMXFxmVMOVwpTCrMONwoPDi8KvwrTDo1x1MDAxM8OEwq5VVz1NVcOqXFx2d2dcdTAwMDZNwrxcdTAwMDNFXHUwMDA3OsOid25sacKqQlx1MDAxOMKaTcKVWMKgUcKJw4LClipBPUBiwrfDoMKvXHUwMDFmw4fCi8K5wq5cdTAwMWbDnFjDlcOSwoDChsOAXHUwMDFkwqfDpFZcdTAwMGYxwp7Cg27CusKdw4NxRz1KTMKHw4F1w4DCicOVw7U+KGRYJyZAwodQei3DosKeOiPChsKEwrLCplg3bmjDgT7Cu8O5w4/CsMOywqFUw6h1w4dNXHUwMDA2wofCgsKdXHUwMDAzOVk9TcKcejHCgk/DlsKLwrQ8PUB/VsOac8O+w41FXFx2XHUwMDE4wrt2wrdsw7IyPFx1MDAxZD5BXHUwMDE4eyF4dULDmzjCjcOsw7LCjsOVXHUwMDBlesK+w5d7OHtcdTAwMGbDmsO1wofDs8OLXFxcIljDtEvCoF/Chi5cdTAwMTMyw6/DoDLDjMO0RMO1wo3ChsKpXHUwMDFlWFx1MDAwNE/CrsKXw4Y1w6FcdTAwMWHDolx1MDAxOcK5wplDfzM0XHUwMDEzYkE4wpjDqWViUMOUw5lcdTAwMDdAwpBcdTAwMDHCuMOUbnvDp8OkJ8KYw588w79KXHUwMDFjSmnCjsKMJMOYdHZ9TcK0wpPCu8Knw5ZLw5QhPUDDjMOCwqjDiVx1MDAwMl5Zw6XDqWXDmidcdTAwMTjDqlx1MDAxMsKHPsO9JcOgXFx0XHUwMDE3RcOnwrXCjMKkwoslXHUwMDA3w6xcdTAwMTLChz7DvcO1XHUwMDA1XHUwMDE5woZcdTAwMTknwqFBw73CsVxcZsOcSH3CjcOna8Kbw7LCj1x1MDAxZsOLwrvDllx1MDAxOMKHT8OVOVx1MDAxM8ODw7XClMOCXHUwMDFjw5vCisKFVFBMNMKUw7U9fXwzwpdtw4/DjzfCsm/DpH3DrsOQw4/Cu8O6XFxiwpBtwoEzwpfDp3/CpyVVScOBJF7CicOVJ1x1MDAxZsO3wq9owrlRalx1MDAwZmDComZZwrHDsjjCg8KawrFcdTAwMDXDosKWXHUwMDExw4XCliDDmsKIMmDCpGBWwrjDmsOxIMOGTsOgw4nCvlx1MDAxMMKycE82w7fCjSA8VMKlw6HCpsODw6lvXHUwMDEywo5jIWk2w41nwpvCv8O+wpnCl8O6woRcdTAwMWE/SFx1MDAxMcOAeGXCg8KDw5t8woXCmMKZw6rDjsKqXHUwMDA2wqQ9QFIlw6w9fcKowq7Do2dmQVx1MDAxN8KGXHUwMDE4XHUwMDFiXFxiXHUwMDE1XsK5wqxcdTAwMDM9SsONwqTDrcOzSifCrsOXwoRnwoXClWBOV0Nswr3ClkVcdTAwMTDCmEpyXFxmT8KDXHUwMDFmZHHDrVvCo8KSwpXDoTXCjcOjw7FcdTAwMWJRw6vDmsKfMsKHwpF3eMKROVx1MDAwNcK0wp0mXHUwMDEww55lwrpcdTAwMDZcdTAwMWHDrThcdTAwMTZcdTAwMDU4w6TDmcOKwrPCoTZqwr09SsKQw7rCv2nDlkJcdTAwMWXCo8K9XHUwMDBmw7zCscKWwq/Csjl/XFxmwrpcdTAwMWJXwqZ9wp/CqHLCl8O7wrhTbcK/w7l5w4zDvXZbwrUnwqLDrsO5wp/DuFJcdTAwMWXDt03Cs8KhwpbDscKUXHUwMDExJE/CnSDClMODw7Bsw6lcdTAwMDLCk8KRPU1+XHUwMDExRMOgwo1cdTAwMDXClsKZw6XCk3hawpduPU3CkcOaw7vDkSFcdTAwMTXDrsODX8K+PX3DosO1wrBewp95w5ZdwqpcdTAwMTPDmlx1MDAxMGXDtcKVwrPCrFx1MDAwZXjCgsO4K8KhK8OxXHUwMDFjZMORacKHw6hcdTAwMWbCpVx1MDAxNsK3w55cdTAwMDHCvMKwVMOXS8O4wr3CuFx1MDAxOFx1MDAwNGDCgSo9TTc9SsOhwrolwqfDt8Kpw7JvbU7DjFxcXFzCgl95w53Ds8KYZSVvwonChVx1MDAxMMOiXHUwMDEwTsOEwrRUw4LCq1LDs1x1MDAxMnRMIFx1MDAxMsKQXHUwMDE3wrs3w5Vnw6h0MsOMPUo/wqTCsUBHXFx0w7NcdTAwMWVGw6dfw6nDjsOZwpjDqFEwwonDmnXDn0dcdTAwMDJgXHUwMDExwp3CjsOFMlx1MDAxNcOqVTFcdTAwMGVcXGLDnMKzwrrCiDVcdTAwMTXCrcKMwofDvlx1MDAwNFxcdsOeKFxcYsOcw6HCg8KIwqTDgcKPw4jCtUDCqsKgw4l6w6TDocKFw7vCpj/CvcOyw4PDqknDhsOhLsOKw5ozYjNDbVx1MDAwNcK9wo/DgSRpRsO/w5HCvcK0w6bDg8Ktwp/DjVx1MDAwN3PDjcKTJcK1w6nClFx1MDAxOcOCwqzDqDHCocKhwrY0wqvDkMOPPMOrY3bCrMOgw7rCuid4bcOdPkTCv8KiPUDCusKyXHUwMDAzw5pLXHUwMDFmQzw9fcOtwoAkRMKHwoHCrVx1MDAxNMK5MH/Dg1x1MDAxNUQswqVqw67DkFx1MDAwNTrClkHCvMO0XHUwMDE3wp0uUFx1MDAxMsKRXzLDrD5ewrLDuCBKJCzDgmtcdTAwMWXClzogwoFcdTAwMTFcXGbDsDArXHUwMDBlaC7Cklx1MDAxMcK4wq7CosOielx1MDAxMlvDksOcwo3DmU5seMOmwrh6woF9w5PDqkjDq1x1MDAwN8Ocw5d4w6s9TUcjw5jDvMK4OMO3w4RLIMOgV8O/fcOPXHUwMDE2w5nDhyR9UyXCpT9eTSbDqVx1MDAwNyxew6xEwq7CnlJcdTAwMWJ6eMOMwoVvwq5RNsK1VsK4wrRcdTAwMWHDqCXCnzDCkFx1MDAwNcOhXFxiw75cdTAwMThOwq5cdTAwMTZrScOrw4xlXHUwMDA0SMO6wqtuw5lsZCrDnTRcdTAwMTTDilYrRlxcdnBgwp9EwrTDu8Kzwog6w6PDmDNrfVBcXFxcwqrDpcK7TV1Aw4Fsw5bDmihLwrbCjMK+Pj19wo3ClVx1MDAwN8OUw6zCgjPDs8OMLFx1MDAwNsKLOj1Aw5xrP1x1MDAxYS/DisK2w7lcXGbDk8KYIT19XHUwMDE2w41cdTAwMWHCgWs9fcOnwoxhw5TClMKJJMObXHUwMDA1Sj1NXHUwMDFicVhXXHUwMDEyXHUwMDA2bcKNRjTDg8Klw5BcdTAwMTFCTUzDhHZQw4jDqsKeIUxcdTAwMWbCn8KjXHUwMDAyeV7DrsOYXFx2w53ClnfDsMOaUUzDksO8w51cdTAwMTTDgUPDkiQ/XHUwMDFlf8Opw4hcXGJuw6vCkMOawrliUMKZw7DCrMOsccOjdsOOXHUwMDE1wqVtcMKkw7fDlFfDrMKxw6DDscKKWlx1MDAxNj1AwozDssO7wqRpw7E2ZnRBwohrXHUwMDA0w5LDmcKew7Zhw7DDjUHCkWHCvlLCrcOCwo9vw5BSXHUwMDFjwoHDi8KabG7DnFx1MDAxNcK2wrE2wqXCqlxcYiU9Slx1MDAxZmLDjMKfLMKKwqTDi8O2w5E+wq1cdTAwMWV0PX3DoHfClX3DrMKxwoPCiMO1w7XDknpcdTAwMTY3w6EzYsOLwobCiEogXFxiLMOzY8O9KMOcXHUwMDBmMcObLsKqRcO/w5jCvsK4w61nw47Dt0lHw5vDisOKXHUwMDEzOsOlMMOGe00xw7jCqsONZjdcdTAwMWLCnsKgwo5XwrUvw4dHwrNcdTAwMWTCiMO4woIqwqHCn1x1MDAxNSvDvi9bwrlcdTAwMWQ0wqbChsKnwqB6PMOyworCq1xcXCJcdTAwMGbDqUoswqXDqijCqsOHw6jCj8ODwrLDi8O5w5FOw6rDoTLDuVx1MDAxMMOPw4rCgVx1MDAxN8Ocw4nCn8K0w4BcdTAwMDQpQcKuwr9Vw7hUYMOUWsOlJkgvJMOQQzHDksKqwrg8XHUwMDE0woYlI2XDtcOOXHUwMDE0wqcuw6zCmHzDicKcXHUwMDFlwqHCgcOiw5DCkcKbXHUwMDE0dsO8wo/Dh8OyXHUwMDAzP8KVwo9Uw7VJwr83w6pBwqDCg2DDm8O3fW/DsMObesK4wrjCglx1MDAxM17CmsKCdWvDim7Dl1x1MDAxNcO6w6vCtGwzXFxcIj9Xwo/Do15oMFx1MDAxYsKoTsOeXHUwMDE3w6LCgU5sXHUwMDAxwo9cdTAwMDQhP2/Dolx1MDAxOXbCm8KNwr/CkFPDsFx1MDAxOMOhwqDDsFx1MDAxOMOhPsOFwoA1w5HDjGnCij49TcKTw6tcdTAwMTd9N8KsZn3DjFx1MDAxZVHCg3ZYXcKGwqrCisO4OMKWwr41w67DmklgXHUwMDFkwp5gwrpcdTAwMTUhfMOMX8KxwoPCp1x1MDAxYsKFZMKFwpxTQ8KOPX0ow7xtXHUwMDEwwqlYw6jCqMO3wojDqcO1a17DrFx1MDAxY8KCM8O1SsKcwrnCnMKBRsOgJ8K1XFxmRMOWwoV9NGIrJ8OobTLDpjYhYlBGIHzCoMK2XHUwMDBmQ0QoJT1AWsOFPFx1MDAxNEFzw5LDnsKYOiBfXFx2ZCZbYVjClT/DtMOBw45mwqbCvMOsw6nDncOBwolcdTAwMTbCtMOVVsOVwqPDglx1MDAwNsO1w7Q9Sj19clfDlsKnwoTCmVx1MDAxNVxcXCJaw6xiL8Otw744wrtHdcOjfSbChcOlQ1ske8KRYMKWw70oRcKlXHUwMDEzwpJsXFx2XHUwMDEwPUBjwpF8wp5Mwq9dUzI1woUgXHUwMDE2cDFCf1xcXCLCuFx1MDAwZW9RwrRbwrw9SlLCi8O+d8KNcUrDhcKvXHUwMDE2I8Kbw4LCpSdyLsONZ2bCrMK6w57CqT19w7TCgsOrXHUwMDE3wrU9SsObJMOmXFxicMOVwrJvXHUwMDFkw51cdTAwMTbCnDLDl0lcdTAwMWE9QMOjwrY4SFx1MDAxNlx1MDAxY1x1MDAxZFpkwoLDk8OubMOlbsKpYXLDisOoXHUwMDEzXHUwMDExw7pcdTAwMTd+f3nDuTHDr1hcdTAwMTHDhMOEa8Okw7vCi8KywqgjXHUwMDE1MGrDmsKPPsKow6nDkk7DtsOSY29iXHUwMDE2W8KRw7/Cpk44w549QFxcYsKrw7gow5dVw45cdTAwMDPDvjTCg2PCjUdkwo7Cpydaw4hcXHbDu2vDqcKaw6cnw6LCkMOqU8OGXHUwMDE1I1x1MDAxMyM3w5xFOlpcdTAwMWJcdTAwMWXCusKCw4bDkFx1MDAxZsKkcsKuwqlkwpHCjlx1MDAwM1lcdTAwMThXwonDk8OJflx1MDAwNsOSUMOsw4zDi8KXw5nCpVx1MDAwMcKww5zDocKDwpJTccKxJcOeRsKdccKPZVx1MDAxMMOqXHUwMDFjwpXCtsO8woZeRzYqfMO0wofCtCzCuXhfwofCmTtNO0zCgMOrw5LDulx1MDAxY1rCkkpcdTAwMDHCg8KQS8OUcDrDscKAw67ChGxWwpB/XHUwMDE5KmBcXGIlw5JdXFxcIsOeeHLClEnCmsKmXFxcIsOIXHUwMDE1wqrCtsOKZVHDrzvClMO3PX3DpUNGwrY9TcO3wqXCmMKEw6JcXHYgw7XDqcKnXHUwMDE5w6kmXHUwMDAyw6kow5U9fcKxKFx1MDAxZVx1MDAwMsKpw4PDv1x1MDAxY8Oxwp5cdTAwMTbCmMOtXHUwMDFkw7I9QMOswo3DqcK/acKoP8Oow7rDjVx1MDAxYVx1MDAwZsKbdW7Cv1x1MDAxNsOuOcO+wrfCrjvCnMKnTXt4PsOvwpxcXGLCk3HCjzzDj8OCS8OZXHUwMDA1wqTCpMOZQsK7XHUwMDFjw6Jmw5k9fcKrXHUwMDA0PUAowr7Dhz1Kw5tnXHUwMDE4Zn1dRnvCvSPCusK7LMOFd1x1MDAwM8Kuwr1+wqjDhHkjZlbDi8KIw6rDm8Ojwo/Du8OHTsOCM0BcXHQ7fVHCg1xcZm9PwqnDkng5fT7DpMObw6ZcdTAwMDXDkcOCXHUwMDE3wohcdTAwMTlJw5HCk8K1w74gRlx1MDAxMXYzTcOWwpvCkHtcdTAwMTNcdTAwMWPCgGJcdTAwMWTDlC7DiEZCb8KEVHfCsUlcdTAwMTA9TTzDvlx1MDAxZMOAacO0WsOywr7Dq2AkXHUwMDAyWMKfVsO3T2E3wrzCi8O0U1x1MDAwZmtcXHQ0wqPDrsKEw58+P8O3wobCljTClsOtXFxcXD1KXHUwMDE2w4PCkVx1MDAxMSvDpMKgwp7Dm3vCn28jw5TDpjzDscOaXHUwMDEzc2k9SlrCoMK8XHUwMDA3fD1Nw7rCn8Opw7TCs23CmVNcdTAwMWTDksOtXHUwMDA0RsOoWlTCvMOnw7NmXHUwMDEyw7bDlVHDtkvDr1xcdFx1MDAwNcOTw4/DmsOAw4pLRcO6XHUwMDEwasKzdFfCo8KZdiNywpDClcO3wrTCnHRVw6dWw4pcdTAwMDUjeF3DmcK+wq9cdTAwMDfDhGLDi8KOfcKZVX1zw5chw6XDh8KefD19w5Fuwox2w5vDnDQ0wrVcdTAwMTJcdTAwMWXDkMOEw6DDvCd4wqvCjlx1MDAxNFEocsO5XHUwMDEyXHUwMDE2wpEmw6tOd1x1MDAwM8K5XHUwMDE1wpVXR8OVf8K8XFxmXHUwMDA0PiDDgFxcdMO3w4zCksKFXHUwMDFjXHUwMDA0c1xcXFxqwrsqQMOGwrdVw47CjcKyw6BswrjDpyVnXFx2woLDiT/CtnHDnMOywp/CkmNJw7LDkn3Dj3rDu8KSwrLChsOTPU0kw59cdTAwMGXDuMOAMHLDo33DlsOsw5TCj8OmXHUwMDFlwo7CjsOAwq3DtsObXHUwMDA1OcOTXFxmVsOgdlXDtMKcw5DDhsKQw4DDqcKCX1xcXCI/wolcdTAwMTTDgcOVf8OGXHUwMDBlfj1NJcOVfcOKf3RcdTAwMTTDn1x1MDAxZVfCuMK6wrLCqVVOdcKMw67Cs8O6XHUwMDFjw5vCusKmbcO0W8KDwpLCsMOMwqkhw5fDjlx1MDAwZXNtUVx1MDAxZFx1MDAxNmtcXGbCt8O0dcKYJsOOJsORVMKqw5RZWsOdc1x1MDAxY8KJw5XDgsOcwqHCpExBwq3CnSXDo8O8ZyVcdTAwMTXCo1x1MDAwZcKqw4fCoMO1w4DCliBGwq5cdTAwMTk8w5DDtMKbUMOJw7Z7wpzCl8Odw6fCtmFcdTAwMDLCs1x1MDAwNjbCiHhcXFxcNcO5flx1MDAxOcKrdS59U8KBVVx1MDAxNV/CjMKrXFxiN1xcYjRlTMOVwrrDtlfClVx1MDAwMXk9QC3CsjdBwrhPw4zCq8KIVsOdw5DCj1jDoMOGw650wpdcdTAwMGZTSmfDnVx1MDAwNnLDjCR7XHUwMDE4XHUwMDEyXj1KI8OPwrjDj8OPw5/CuirDu8KwU8KqXFxcIsO4w5Nmw7QkNlx1MDAwZsKtw6rDtlx1MDAwMcOOw7zCtMK7wrnCgsKCwrQgwpZjwrtKcDXDk3RNXHUwMDA2wpdPw5pOU8KDw59Ww4BFcsKDbEXCjVXDjMKGw4rCm29Ww6/DosKAXHUwMDBlPFxcYkhXw7PCpcKpSMOBwq7Co1FJw4BcdTAwMTBcdTAwMDfDnMKOXHUwMDAyXHUwMDEyRGVcdTAwMTFnw6DDisKYw67DnEXDgG9dwrTCj0/DncOcwrY/XHUwMDE4MMOcXHUwMDFlZsOIecO5fSjCkVx1MDAxNlx1MDAxYsKWXHUwMDAzc8KBwoUvYMO+Vi3CvzfDu8Ocwo5CwrhgMVHDoMK+w7Z9Y3fDjnHChnTCv8Krw77DvGnChFBQwolFXHUwMDExcjBSwrJ0wqxYw4VuwoDCgz19XSRcXFwiKnbDqkB7wpbCrcKww63DnsK8w5vDhcOkwpnChMOOw7hcdTAwMTdCwrDCplx1MDAxYcKkXHUwMDEzfsOZRlvDgUQ/LsK0dsOtw70sQSM9TcK+LcO5XHUwMDA1wpPDv1x1MDAxN8KCw5s3fHPCtmfDs8OkUcOowpnCpnrDmFx1MDAxZsOCcMOnw4fDjlx1MDAxN8KEw6VcXGLCisKVPUpxw5FcXGYowr7DkVxcZsK4woPDsjk5w7Rfw6/DhF/DjMKIw4w/PUrCgsOvXHUwMDA3wptLw45/XHUwMDAzwodJXHUwMDFmPUpewoQ9SsK5clx1MDAxZkc9fcKfw7XDiMKnwqnDjFx1MDAxOHtTw4XDjVx1MDAxNMKaU39WOcKjI8OlwqXCi3M9fcOOwr5cXGY+w47Dn8OscVk2f2hmXHUwMDA3YcK7w4xcdTAwMDQ1TyHDhFx1MDAwMl9cdTAwMTfDlsKncmhcdTAwMTlZw49zw7U8XFxiVSN5J8KDw6hpw7pYIcKEwrBTJcOWcVQsw5nCnVx1MDAxOMKAw6dDcHNcdTAwMTTCjFtNwrlyXHUwMDFkwo/DuD7ChsKgRTwtIC1cdTAwMGZ/w5hcdTAwMGZcdTAwMWTCvMOSw4DCuy3DhVx1MDAwM8KgwoNcdTAwMTQkwrorJX/CisOEwobDhVxcYnbClmvCv8OmwrgvXHUwMDBmw4BvwpJmwrXDmsOdPX1cdTAwMDHCtlxcdG3DsDdCwqLDpcKOw5cgR1bCisKfMUrDoMO/w549fcK6YMK3woTDisO4eGrDssKtdcKAOMKrw5s3LlxcZsK1XHUwMDFkMMKWbsOEWUZcdTAwMWXCoMO0wr7DscONIcO9XHUwMDA2U2FBUsOEwrrCh8KEw5XDisOWaVx1MDAxZl3DhcKEwqNHw4vDscKyYsOtaXXCicKFwqDDljYxPU3Dj8KlwppEw7B1woIvw4TDksKlwqxZwowsw6hcXHTDoDzDi8Ogw5Nsw6dcdTAwMTnDrlx1MDAwNsKWXHUwMDFhwpvCtcKCXHUwMDFkLsKXw6LChcKLXlvDpDx8w6BcdTAwMGVew7R/TMOHNMK7w7/DosOWw45Ow5jCpXXCrcOWXHUwMDE1wqE9TcOcT8KCfSRHwpfCkFx1MDAxOcKawp9VXHUwMDExw4VMwrrDtsO5wpHDqMKlXHUwMDFkworDim/DksK5w4JcXFxcw5TDksKjYcOeXHUwMDFiXHUwMDE5w77Ct8OcwpzCgkbDm1x1MDAwM2LCtE1cdTAwMTDDqj7Ck1x1MDAwNkg9QDtTTcKmXHUwMDFjRmfDkWbCoXTCmsKGwrN+YjTDozfCllx1MDAxZjHCkE3DrsOeMcOAwrfCi1x1MDAxZVBcdTAwMTBoXFxcIsKeXHUwMDE5wr3ChDpgPU3DssK1wo8yw5jCtj52XHUwMDE2XFx0JybCsMOcbMKLw6DDiVUpw7HDgsOFwr5LwojDpFx1MDAxZcOJJnVcdTAwMGXDmVx1MDAwNsONKCDDpmhZwqzCocO6YFRcdTAwMWXDjCHDgcK3w57DpcO/w6Q9Slx1MDAwM8Kyw7PCu0vDmMKMKGxpOcKtw7XDhcO6alxcdFxcXCLCv1x1MDAwZcO6TlxcZlx1MDAwN8K0w6PCqMKNwpJRUMOoYFxcXFzClzBPM8OfW1x1MDAwNFNcdTAwMTXDiMKYw5DDh8Knw7BHOTTClHQrQcOtbHPCj8KAwprDrsKCXHUwMDE1ZMO6SsKhw43DkVPDrWHDmMK3w6DCosOeRMOZw4nCjMOHXHUwMDE2ZsOFw6ZcdTAwMTZcdTAwMWM7ecOBwrfDnVx1MDAwNFx1MDAwN8OBK3DCrMK/w6LCo8OXScKdTlx1MDAwNMO8f8KjdVfDgl9ow4lcdTAwMWJfw60xccOGdsOyWMKNXFxcXMO3XFxcIsOcO0nDsMKrYlx1MDAxZMKcwoRcdTAwMWNHwrErwoNiw6DDi1x1MDAxM8KNw5puwp4swqFcdTAwMTbDtTNIw4R2w6rDnDhawoJcdTAwMTDChcKbwpzDtVrDjsOuWcOGwp1BYlx1MDAxNsKewpxkXHUwMDExMMOuw458V8K4K8OPwrHDtMKOw509fcKCw5zCsjJcXFxcT8OYwoPDosO2wojClMKuPiXCqlx1MDAwNC7CvWszwo3Dj0M2RcOTNGPCqCnCkl90RVk3PUrCmsKBw57DgsK4w4fCtsKZw7/DrGR4wq3DmcKGbi7DvMOawr/DinJVwpfDiW17w67DnXtucsKnw5xcdTAwMDVEw4rCq8O3woY9fUF1wqBMw4lcdTAwMWHDpCHClsOKVMOFXFxcXMOZw7/Dp2vDnMOHJsKHw5Rwwp/DsMOvwp1GwqjDg8O5aVx1MDAxYlx1MDAwN1YlYjByPUpzw4DCrcK4LMOuXHUwMDA2wqLCpMOSV8OBUsKtwoPCtcO9Skp5WsKlwp7CqmtGwotPXHUwMDE5wrV1wpwtWcOew7pcdTAwMTVcdTAwMTJNXFxiUsOkQMOdwrHDh8ONwrdPwpFRw5bDkG/Dg8OdXHUwMDAxwpFzw6vCvlx1MDAwM8KxwqdKdcKnw4tcdTAwMTE0XHUwMDA1w53Dg8K6wrxZw403w7ggacKDSFxcdsKBwo89TcOJXFxcIsO5wqHDgsKow6nCj3NcdTAwMGZQL8KOw558wqAqwop0QErDlMOHU10oTG3CtFxcdsKVw4g9SsOaw5rDlkTCrMOMNDDCkV/Dt8O0XHUwMDE5NCdcdTAwMGZcdTAwMDbDosKbwr5cXFxcL08kY1x1MDAwZlx1MDAxZlx1MDAwN1x1MDAxOThlYsOwwp3Cu8OBw4NEXHUwMDFmw7p0XHUwMDE5XHUwMDAxXHUwMDFiaX/Cg8Kxb1x1MDAxNDclOMKrwrzDo1LCr8Opwr7DhTjCu8KeJMO4wrtPSsKAwpB6wovCi8O+w5rDj8KJwqIwwotTa8OQPsKlOMOaw4JmwoIkXHUwMDEzwoTCjsKIXn7CiCRVw4fDv8KNwqNlOjnCkTDDuXVcdTAwMDdmw7XDiVx1MDAxMcKHwolEwpNnNMK1w5pub8OnwolcdTAwMTA2XHUwMDFlL0dxJcKdXFxmbnnCpSR/XHUwMDFkXHUwMDBmUsKRw5/DlmjDtVx1MDAxMlx1MDAxNGgww65OW3ZcdTAwMTDCjUrCi0jCpcKwWzrDr8OcXHUwMDA2wqo0XHUwMDE3w7UmezRLwqjCiCDChsKUXHUwMDE3WVI/wrtnWi7CtsKoXHUwMDE1wqRmw71cXGbCiz1KN3HDqikhwpFcdTAwMTTDiVx1MDAwMlx1MDAxNMKHcsKIwrLCkVx1MDAwMT4hwphcdTAwMTQmw5dcXHbChClgwrzCh8OOd1TCrcOMQ3NcdTAwMDHDssO0T1x1MDAwM8Kuw55iXHUwMDE4RSPDpFjCtFdcdTAwMWE+w5BFwo7DkFrCqMO0QWjDjsK7wrxxdz1AwonChcOPLFBGw4HCrXvCvcOCXHUwMDA3NsKlwq9cdTAwMDPCvcKLIMKoXHUwMDEwayXCnlx1MDAxYTjDj8OIw592w4HCkyPCmVZcdTAwMTXCvHzDscOcUcOuw7HCh8OqVEwuJlx1MDAxZFjDoVx1MDAwNFx1MDAxMcKHwr7Co0TDmcKPWFxcYsKyw5jCp240IcOxw444w4hcdTAwMGVDw6VpwqHDqsOawpBhM3nDpsK/RSjDq8OjwppGwrDDp8OwwoIvwq/Dj3PDhcKKw4Z1LcKXXFxcIsOaZcKLw7fChcOlw4BDXHUwMDEzwoTCpzfCq3pcdTAwMDPCsMOMwqlYR8OxfsOtw4diwqDCpMOrw7xQwoPCnMOoXFxcIl9fIyzDgsO5wqHCnFxcXCJtw5t1woTDgGZ1ZMK8w7JpJFx1MDAxMcOmVic9fcODSz1Nw6XCqlxcdmE+wrN4XHUwMDBlakxcdTAwMThJwr5cdTAwMWTCh1x1MDAxZFN0w74rNn7Cv8KHXHUwMDBmXHUwMDA1Y8O6wqvCsDBHwrx5w7pcdTAwMDPCiMO2w5hcdTAwMWNXwqDDhlx1MDAwMyrDp09IasK4OsKEaFfCssOsS8K2PMOwVTzCkEw9fWlcdTAwMTHCssOEUVx1MDAwMkvDksONXHUwMDAywofChFx1MDAxY0jDqEPDjFxcdHHDt3HCtT49fUnDulx1MDAwM8K1N8OHLcKNayvCjMOqw6PCl8ObwqzCjSbDo8KcVlx1MDAxNsKIw6spbT/DvFx1MDAxNDRcdTAwMTjDqMO7wovDrS7DhsKsw4pywp7DnE1NJlJ1wqRtVnE7J8KiwqLCjcOcVsOGfURcdTAwMTnChkrDhsKnwrDDh8K1Y21cdTAwMWNRw6zCtlxcXCLDscKNwolSSDnCucKxUWjDp1xcZmPCjsOhwrHDkTfCsVvCq08jw69pSko/wr/DslxcYn53wqHDg8KTeMKjw5HDmGXCqsOwwpjCk8K2M1x1MDAwNFx1MDAxMMKFwp3DrMO0w4PCq2MoVMKYZ8KkRVx1MDAxMMKww6ZQXHUwMDE4XlQyO8KOw49cdTAwMWHClFx1MDAxNsO2NsO/w5JcXFxcbcK7WcKfNsO8VsOAw4hdwoTDt8K4wpTCgcORZD1AXsKoSjBXwoDCpjDDuMKpXFxiwpt/XHUwMDE1wpTDg8KiXn3CsDnCsEZbY1x1MDAwM8KIwonCpsOWbsKGN2XDgMKIwrTDjD1Nw7JIcMKYU2prw6nCg8KddsKLw7xmw5XDl8K3NcKLYcOSw5U9TcOzW0HDlsOfwonCilx1MDAxNm/DoMKKwpNVV8K/w5dgwoHDlFx1MDAxYcOSc8KvwrrCqkt2w6PCkUDDnlx1MDAwMsKTwofDs8Oswpw9QMK9w7nDhcO6YsKgY8KIwoYsXHUwMDAywrbCiMKcXHUwMDA0wovDk8O6NybDl8OTWcObwo5cdTAwMWLDgsOdWFx1MDAxZMO9XHUwMDEzPX16woHCoVcnwojCh0MudCd/w55cdTAwMWXCvTnCrUIuw47DiihqMsKGwqfDpzTCrsOxaC4yPz1AwqVdLsOfP8O8w7JoVT1AwqltwqRcXFwiw4gxXHUwMDE0w4FeSMOmwr4wwr/CtELCknbDhcOeSMOEw45cdTAwMDNcdTAwMTDDhSEmXHUwMDE2wpYnw7jDtcKww6PCucKHw5jCvlx1MDAwZsObwo16bsKLwpRLwpPDqcK7J8OewpHDr8KmVsK8wrLDp8K0d8Kww7FcdTAwMTgjXHUwMDE2wpFpw5XCk1tcXFwiw7BRw7xiw6NtP8K0w7FmXcORw5HCn1x1MDAwZcOzw6tcXGbCm8KlbC/Dk8KvKCTDnFxcYlx1MDAxNllIw43DgsOoQ2EgwprDt0hcdTAwMTTChcKVwqpcdTAwMTXCuSNcdTAwMDchw47DhsK5I1x1MDAwZsKbP8O2XHUwMDFjSVx1MDAwMcOPw4kpwp/Ch2Qjw5HCn8KTXHUwMDBleVx1MDAxNXzDtcKpfMKzw6bDjUjDi8OPw5xDIzPCkFx1MDAwZcOxw63CvcOBw63CiTl5woc4w4k4ecKGOHldUVxcdlHCmzXCscOJwqJ/KTNcdTAwMTbDkVx1MDAxY1HDrT19I31cXHbDmybCs1x1MDAxYWLDvVxcXCI9fcKeQn/CtcOiwohsc1x1MDAwM8OYwr1cdTAwMGXCocK7wr9jwoPDqHbCosOJwpcvVX1cdTAwMDPDqFxcXCI3LVx1MDAwZmYkJGh9dVlcdTAwMTcgwopeJ39cdTAwMTgpw7R5XHUwMDE4wrzDmybDkMKjWsOMf8OzUWJLw7nDm8O8wr3CgcK/KFxcdHbCusOwwoDDl15cdTAwMWXDgcO6ciM5wrxcdTAwMTZzY8K5JsOIwpHCiVxcdGHDssKCd8K7w7hhIFx1MDAxM2Jpw5DDlyckw6QpXHUwMDA0wrt3PX3ClzI4woXDj1x1MDAwM8O6w6vCvMKMwoDDscKvw5BKXHUwMDA0XHUwMDAzK8OJeHzDjGHDh1x1MDAwZlx1MDAwNCPDgmZMwppcdTAwMTRnw4B+w4U5woLDpj1Aw7ZIQUQnw7jDmUNcdTAwMThww4LCqcO1wqdeNMOTwqLDl8Ozw5k0YEPCjT9uw4jDk8OafyhNwo9QwoPDsMKrwpTCrsOQfVx1MDAxOXxcXGJJw5XDti09TcOywokyw7RgNcKAaVx1MDAxYsKvwqXCmMOnXHUwMDFmPUDCjcOBw4k9QMO7JVE9SsO7bMOGXHUwMDE0woN+wo1cdTAwMDdcXHTCnsKPw4nDl0NFw6krw6BkM8OVWyltI0DDqEbCrDDCmsOPQiDDhVxcdsOxXFxiwolcXGJeXHUwMDFlXHUwMDE1wqsrQCjCqlxcdsOXw5nCs8KHfMOwwowlw5rDsMOgS8Kfw41cXGbCi8Oxwq42wpFcdTAwMWV+w6Jhw7Z7Q8OSXsO2wpnCkTnDv2jCtcKbwppSeMKywo7DjCZcdTAwMTMmwqrCiGHCscOufsOgLcK7w4PCnHDDi3TCvcOMwqdcdTAwMTnDmsO6ay1cXGZUwpHCssO7wrjDt1R6RHDCtMKwwrx1w7hcdTAwMDfDgz19w5zCl1x1MDAxY8Ouw4PDm8O+MjUresO4R8K9wpDCv1x1MDAxMsKQXHUwMDA1fMO0LSN7wohcXHTChVxcdsK8XVx1MDAxMlx1MDAxY1/DrcKSwq9SckrCv3VcdTAwMTLDu8OEwqpGwqLCs1xcZlPDgcKKYcOlw6xYXHUwMDBmXcK2XHUwMDE2cMOzw7vDlMOwXHUwMDAzI8OgXHUwMDA2XHUwMDE0OnTCrcOjwqlcXGbDiCkkw6DCiSRkwo4mwpArwpNnXFx2w4ZYIMOdZVDCrsKHfMKYZsKUXHUwMDFjwq/DjMKHw54ow71MUCXCg3bDgsKWOyvDp1x1MDAxNSbDqDTDknA9fVxcZj19L8KgXHUwMDBlXHUwMDEwwpTDpMKDwrTCjm3ClHo4JcKEOjhcdTAwMDMjwq/DusK0McOgw7ttJn3CgFx1MDAxM0PDtcK8PUBiwrXDmz4zNMOFwrxRw4fDnTRAXHUwMDFjUcOJw51RJ8Odw6/Cn8O/PX3CnMOUw5vCuSQ4XHUwMDEzOFx1MDAwZcKJQ8KORFx1MDAxM0hcXFwiXHUwMDBmN1x1MDAxM13DqMO1XHUwMDEwaWg9TcKcPUDCqcKmeGkgwq5cdTAwMTVcdTAwMTbDscKwwpHDg1x1MDAwMUPDsMOMRS3DuGw5XHUwMDFiw5k6wpc8dMOtaDZ8w4xOVnfDmGDDmF7CqsOxw5XDq8OFVnvCmsKywptcXFxcw73Dk8KLcj1NPX0qR8O8XHUwMDFiPU3DqFx1MDAxZMKzwr9vccO/YSzCg8KjdcOWw6hRRsOuwqVcdTAwMTVcdTAwMDbCh2fCgsKkw7TCjVrDpMK7w40rw5B0wqLCv2TDs8ONw7jDrSzDvMO7wr1mw6knwqfDucOJTkbCkMKGw5PDgsKfI8O5w7NcdTAwMTEnw4PCqU9veD1AwozDl8KbXHUwMDA2woMgwr1sw5TDscKSdsKMXHUwMDEyw7PDkcKBw6w9TcOpJCFqwrzChsOGbMOZL3xGw6I4QCXChHVcdTAwMDE8wpU9QMOLIcOMw6Usw5t1wpvDqsK6TlVSwrHCoUJcdTAwMTAyVj19ccOAw5HDlG9Rw45VwrNcdTAwMTLDrEtnwq0kU2LDqMOKw5jDtsOnVEDCjzbCvcOzw7prXFx0wqUxZTtXw4zDmcO5XSzCqsONXHUwMDEyIcOEw4w1woRDw4tTXHUwMDA2w6jDpcK3w57CkMOfwqvDt8Kdwo1cdTAwMTZKXcKGYMKKN8OBw7fDkG7DicK5wodcXFwiwrTCo0E/w7jDjcO9f2LDqXVcdTAwMGbCiMOoRFx1MDAxM2PCmcOewoVAwoXCkMORwrzCl8KtL03Dn8KscVxcYsKfwrstw4HCi8Kow61gY8O2wqNYwpFRwrBjOy3Co8Ohw6DCs8KLeMOuw5rChGc7W8O2wrNCw7LCrcOfdzbDokAwwrpxbzdcdTAwMDZrNMOvPX0qXFxcIjbCgmo9SsO9PX0sw79IwqnCsFx1MDAwZsOFw7pcXGbDimFcdTAwMWQoXcOmcW9bZsOfIcOJwo3CqyfDp0HDrsK/woFmb8Orw7l7wrrDnlxcXCJ5wrc0wpjCrsORw5TCrMKAwq3CrMKIw41tN8Kfw6drN34/XHUwMDE1JMKwR8OewrDCi1x1MDAxNDFswpYmw65yZMK7wod3wop0d1x1MDAxN1x1MDAxZMKYXHUwMDA3woZ3woo9fVx1MDAwNMOeMFx1MDAxYcKRw6Itw7FfLl3Cu8KTwqfDhVx1MDAwNsOUw59cdTAwMDVPw5vClzgrUcKzOcKKwoM/wo9wwqfDsMKWw4pfwrk5O8OUwrJAVUxCw5HDr8KbXHUwMDE2N8OQwoBcdTAwMDfCp2NmI8KTJVDDtcKowqApwr/Ckj7DuSTCvT1AXHUwMDE2w73CkGrCs1x1MDAwNMKOw6VcdTAwMTRDwoPDqsOTwo9cdTAwMDHCiSfCpWNJMlxcXFzDscK4OMO2w6JcdTAwMDMoLj1NXFxia8KqZHZGfVx1MDAwM0g9fXrCpMKEXFxcIjZDw6tcXHYxRD1NK8KXw4TCjcK5w6x9wqJcdTAwMTfCklx1MDAwZTPClVDCmMOnwpklwoXCtio7wpohdFxcYlRob8OzPsKawp5cdTAwMDclw5xww5bCsTlcdTAwMDVhMcOCXHUwMDE1XHUwMDE2wo08w4LDu1xcZlx1MDAxYsOWXFxmTFx1MDAxOD1NZMKgwpg6XHUwMDFiflxcdMKtW1x1MDAxNcK3wq4jMMOOOFXDr8O/XHUwMDFmMVDCujjChsKPw6FcdTAwMTfDnsKjwqDDhcO1XHUwMDBmMsOsXHUwMDEzw4fChsOWw712XHUwMDE5ZHvDhMOhw4TDp2wuQMOpI05Rw7IpXWbDv8Odw73DiHFCw5FsacKJwrpuwqBcXHTDtjssMVx1MDAxZcOHwpnDtcOnwpzDl8O4w5LChcKEXHUwMDE2XHUwMDE2wpE/wrHCn8ORT37DnsOyZsKmLkgwwpLCiMKIw4zDg8Oxw54hOFx1MDAwNsKXXlx1MDAxM3bDtMKNXFx2wrPDkcO3XFxcIlx1MDAwZcOyXHUwMDFmwoJcXGbCosKXMFx1MDAxNMKNXSQ9TcObwoNcdTAwMTLCnDTDtlTDmH3DuMK/woTCqMORw4lcdTAwMTHCkVnCm8KDw7F/wrJFw6VdaHnCnkDDtT1Nw6PDl8KvXHUwMDE1w5jClMKSwpLDqMOTXHUwMDE1Um/DksO7w6dbXFxcXMKxSlx1MDAwNSvDi8KCw4BKwrxiXFxcXMKmf2TCglxcYkwydiVqQ8OTaHJcdTAwMWPCtcOdwqDDglxcdFFcdTAwMTXCsjHDs2pcdTAwMWJjwoFcdTAwMTjDpFbCu109QMOrX8OtwppHwqPCu1JcdTAwMWZcXGZcdTAwMTfCj8OEX1x1MDAwZlxcdMO8aT7DkMOHwppcdTAwMTLDjT19Yi1mXHUwMDBmwq7Cj8KpTcOuw7RLw5I9fcOzwpBcXHTCqkQ/XFx0wo3Dr8OZw6vDllxcdMKPwqVqw5s1NMKEXHUwMDA1wqJDc8KWZMOFeSPDiMOIwqfCpMOuacOAw4deWFx1MDAwNn3CpcKXIVx1MDAwN0BcdTAwMTLDksKOKsOZKT19w71hw4vDp8KgI3/DqcOBbMKyOMKKw6gtw49cdTAwMTfDlMKZXFxmcSvCl1x1MDAxZTnCh1x1MDAxYUp/w6nCtcOdTFPCmcOqX1x1MDAxZT1AKcOWXHUwMDE5XHUwMDEzw4NLw4zCqsKwwqMvwrfDtMOvZcORPX3DniTDmMOfXHUwMDE4wpjCnl/CuMKrXHUwMDA3wpxcdTAwMWZcdTAwMTZdw4vDvcKgXHUwMDEwXHUwMDAyXUIrJMK3w6RNwq3DjVxcXFx2XHUwMDEyXHUwMDA2w4NcXGbDon/DiMOnL2PCtSDDkVo7acKhSlx1MDAwMcKOIWNcdTAwMGbDmVx1MDAxOcKUw5nCrMOZwptMQVx1MDAxZcOzw73CrsKdwqrDiC9yw6U8XHUwMDBlw7RUXFx0w4vCpmzDhsK8T8KsbsOld8OnQkJcdTAwMTRxXHUwMDA2w6JcdTAwMDLCs1xcXFxcdTAwMGbCvD1Kw4LDiyBKSFx1MDAxZXl+UilhMVx1MDAwM8Kxw4bCu1I4wqLCp8OmccKXKmdKUibDrXVGMXomwpnDhcKXWcOjw4LDtsOPw4rCriPCnCrCvX1sQ8Oyw5tfXHUwMDFhPX1mwq7DgsKRbsKiw4s6XHUwMDFjw7TCqHl2w5o4w7hcdTAwMDM4YMODwpFcdTAwMTbDmXzDvzxcdTAwMDPCkjFOOsKmw4jDoVx1MDAxNMO0aVxcdsOAwrnCjVx1MDAxNV1sw4jCrSbDtlx1MDAxYcKjwrxEXHUwMDAzwphNV0TDl8KDwrZnMnUgMCZKXHUwMDA0w7FQw4dPwqZOw7xHYCtFXHUwMDA3w5BwQTxhwpI3XHUwMDFhwobCkcKqXHUwMDAzXHUwMDE5KMOEw5zCtcONXHUwMDAzwqRcXGLCmE7DvD19w5nCtEhcdTAwMDfDjGhiXHUwMDE4wrfDrT5cXFxcwp3Du8KjNEtcdTAwMWRaPMOcXHUwMDAxR0rDiXFofDXCtE98wq3Cqi7DjjF7SF5zwpclUlgzM3nCm2p2aGMpw45cdTAwMWXDv8KuwodcXGbDsVFcXFwiJkDDh8K3c8O4OGjCm8KwJ8K3wocqw6nDkcOCwqbCrsOic8KucsKtwpnDolx1MDAwNsOMXHUwMDE3O8K4c8Ozw6DCiks9TcO4wodcdTAwMDJReV5cdTAwMTFcdTAwMWZcXFxcw7zCmmY5aFx1MDAxZcO4w6TDmcK5TcKNPU3CvlDCjVBGXHUwMDBlWsKzw4fCvcObw5JXXFx0wqNcdTAwMWNLcynDm1x1MDAwN1x1MDAwM2M7XFxmwr5gw63CiMOpwofCtsKIXFx0w7JcdTAwMWHCuSTClXV+w4nDq8O6WVx1MDAxN8O0wq1Uw4PDvERcdTAwMTJcdTAwMWTChCzDvMO8w45cdTAwMDXCmsOLSVxcdMOkw5tYPU3CkUrDjidcXHZzw45/ZcKnwpRcXHTDp0M1wopFwrHCosO/woLCslxcZsOHKT1NXHUwMDA1w7VQw4NIOVx1MDAxZWLDjMO5XHUwMDE2XHUwMDE0w6bDi0xcdTAwMTHDnsO6f35HwpvDmcOFwovDocObUMO8YcOZw4/DicKNw4DDosKubDFAwozDrCo4T3TCq8OcXHUwMDAyOzVVfT1Awp9FMsOLwr87Nmk9SlTCkcOHwrxcdTAwMDXCj1x1MDAxMcKwJMKcXHUwMDBmXHUwMDE4N2bCt2RJPX3DpTbCs3VjXHUwMDFjwpzDrcK3w4tcdTAwMDNjXHUwMDFlwp0qXHUwMDA1wrnDq8OiwonCs8K3XFxcXMO4XHUwMDA3Ulx1MDAwMcKJXHUwMDAyw48rw7bCu1x1MDAwNETCvlxcYsKvKlxcdsKAw4oywpTCr1x1MDAxZcO9XHUwMDAzw57DicKDR1x1MDAwN8K8w6LCuzlCU1V1Jlx1MDAxOMOiw6x6OVXDn8OHwpHDs8Odwq3CpsOaw5rCp8O0XHUwMDA2w61cdTAwMThowpVcdTAwMTLDiWBcdTAwMTlEw41cdTAwMTPCtMKZXHUwMDEyPU3DnEhTw45dZGRcdTAwMTI7XHUwMDA0w6Q9fXXDmldcdTAwMDVPwpduwrs9fTwww6VcdTAwMTDDusKEMlx1MDAxYsOEwq/DkFx1MDAxN8K9w7TCi2XDvsKKZcOEw5TCplfCrsK2wpTDjXXDpVx1MDAwZlx1MDAxMDdcdTAwMWHDv8Okwps2XHUwMDE3I1x1MDAxNCzDmcOQwoPDhFBXw49cdTAwMWPCg8KDwphcdTAwMWbCs1x1MDAxY8KBwphZXHUwMDA1w5bDiMO4wr3CkMODwq5jw4Z7JcKkTsKOworCsFDDrSzCt2hCwp54MFx1MDAwNigyJ8K2w7s8w4XDv8Kxw4N6aD19YlZodMKgwqrCucO0fMKQMlx1MDAwMcKcw6jCs8Ozw6jCgMKFwpnClcKGwprDtFxcdMO3w7FVXHUwMDA0w442cjTCvF3CsMKFwoZcdTAwMTPDjElcXHRNwr9NRz1Aw7lYw7PDnD1NX8Ksw5hcdTAwMWJaXHUwMDE1wodcXHRcdTAwMTY/YVJcdTAwMDTCg0gtXHUwMDBmw6R1w7UgU1xcdlx1MDAxOMKXUjfDoTdjI8OSX8KBXHUwMDEwRFx1MDAwM8O8SMKkw6nDlMKXdlx1MDAxNsKnXHUwMDBlwrDCoFx1MDAxOMOBw57Ch8ObVC7Dklx1MDAxNFRFKDbCn8OnXHUwMDE5T1vDtMKnZTDCnz19PU3DonPCrcO8w7E4XHUwMDAzwqdDQMK1ZFx1MDAwMcOKw6RcdTAwMGXDicO7XHUwMDE5w4rDmUowUsKpXFxiXHUwMDFjPU10bMKcwrxKdjd1OHdcdTAwMTdcXGLDsnNcXFwiWFx1MDAxZcOAXHUwMDAycU41w7PDq8KSXHUwMDA1wrDClDLDu1x1MDAxZlx1MDAwN0fDmlx1MDAwZXrCgsKOV2fDglBcdTAwMTBcdTAwMGZcdTAwMWQqMHgow4nCvVXDjFjCjsO9wqZewr7CjsOpR8OYwoHCnFx1MDAxYkRTwpE4c0XCjMObXHUwMDFhw67DmMKWUsKVcsOJOXBTwo3CscOoSGvCv1x1MDAwZSg/XHUwMDA1NsKKWVjCqMOlwoUqR1x1MDAxMMKiZ07CslpcdTAwMWXDrkLDhsKHw7rCsz9Pw7TCki5Fw7NcXFxcwrEzYznClMOqw4HCoMOKw6rCqmnDjlFxXHUwMDFjPX3DgCDClMO8w7DCm1JIXFxcXFx1MDAxY1nCvjNcXFwiw7zCqmnCjk7CvMKww43CrcKabFx1MDAxZMKZXHUwMDBlwpzDp8OoL8O6TMOaw6DDi1x1MDAxOVHCg8OKwqvDh8Kyw505w7p+w4nDi8OsXFxiw77DuDlcdTAwMWTCnGdiwphJwoxcXHbDhVx1MDAxY8K0w5pAwo7CtVxcdsKkw5nDq3NcXFxcc3B3wqHDucOJe8OIw6B5XHUwMDA0w6ttKn5cXGJIe01zwpdWZHJcXHTCgcKfw5XCjsKrXHUwMDFlWyDDk8Kyw799b8OUOVx1MDAxM1x1MDAwMsKtS8ORd8O8wr/CjC9Ew74xwq3Ds8KKw5IoQF49fcKxwp4owqnDksOlXHUwMDE1wqd4w7pVw5VjXHUwMDAzXHUwMDExwp3DrMKDbmhLVDXCpMOJwoA9QMOMecK/XHUwMDFiwrozY8KUPX3DnHl1OMORXHUwMDA0w6fDizJ7SsKQPUA9TcOmwoLDiMOOwq/CmsOmNCHCqsKTWkY5wqvCisKvw5fDhixLwoLDulx1MDAxZcKGwrnDoMOBX8K5w44tw71mw7BUaMK5RsOdw73DoiMxw6M8w6RCYUDDsXRcdTAwMTLDpcODw43DgkTDjsKraMK9wpBcdTAwMWLDtWDDv8KvXFxcXMOjXcKAeH7CnH7DlknCmFxcZsOiw5jCqVx1MDAxMsKuwr3CtD1Kw7A6w75cdTAwMDbDmMKZwonDmsKQwrTDk8KOXHUwMDFiKsKyw5M7w4BLwoXCnzrDksOPJsKSXHUwMDE2wqsgw4JRL8KCw7bDqkPDkcO7NlF2woHDgTBvXFxmwo7Cj1x1MDAwZmVcdTAwMGXCnj9iwqfDg8OZQsK9TsOXw5XDi8OPJnxcdTAwMTbDgnPDmTPCvcOOT8OWPDbDssKBM1x1MDAwZcKmNMOxMcOgS8O2w4kxwo5tw4NDbUPCl8OMXHUwMDFjwpbDu2lRTcK+w6s9SsODw7HCo8OLw5s8woY6ejNzwofCkMKJMTpnw7cuPGdTw4HDgzjDlFx1MDAxY8OjP8KPJUFtwqFVPsO4U8K+XFx2SsK8XHUwMDE4w7PDisOew6zDnDXCv8OCYGzClcOeXHUwMDE5YS3Cg0LDmiTDjMK3worDvlHCs8OfPUoow4NMwq3DmzvCi8K+P1x1MDAwZsOKZ2xlN8KDXHUwMDExw6hjbWBWw6s7woDCgHLChMKKw49Gwoolwowrw7bDuWhHXFxiOsKeTmM2VXxMMlx1MDAxOMO6w7tBcSdDwq3Cv0ZmUWk+woBuw7LCuFJjJT1AW2xcdTAwMDV4Q8OcwojCh2nCvsOtOMOhfsO2c1x1MDAxZFx1MDAxMMOZw6xXw4PDnidMKjUkw58yL1x1MDAwZsOWXHUwMDA1wrjDi8OESGjDscK0w5xcXGLDsDXCjMK0w7Byw7bCscKNJFLCqsO7UVx1MDAwN8KeLMKDw5PDo8KMwoBlw6jCjmdGPU0sLcOoOT7Ck1x1MDAwN8O4woZcdTAwMWJcdTAwMTnDvsK0w4otZcOdOMO7wp7ClMK0S8O3MmzCpzZFw5/CvHrDlMKYwp9YwqxiwrE7XHUwMDE5w4F+w6XDs1x1MDAxMMKfwoRcdTAwMWRcdTAwMTRcdTAwMWTDscOhXHUwMDA3aloswrbDjsKHw7osw4l+PX1bUsKswqvCo1x1MDAxYVx1MDAwZcOBw5VcXHZgeVx1MDAwNC7DhsK0w7FvKWEpZsKXwpvCllxcdMKMw7lfwqTDnMKnYCxAw6vDk8Ozw6TCsThcdTAwMWPCq0spXFxiwp9tw4vCoGFsXHUwMDA1MDjCsWPCgMO6woXDlsKpwpUswpPCl8Kuw61cdTAwMWbCiz7CpHzDgMKcw4Z2aMKuOVx1MDAxM8Oww6h3wr3DlCpBXHUwMDFmwpJcdTAwMTHCvcKWcF5cXFwiw59aw5fCu8KTw4cmwr3CiMOgfsKWIMKAdT/DnT1NWVx1MDAwM8K5M8OAw7TCv8KIwqp9w73DkDbDmHJcXHZcdTAwMTHCnWt0Z0tuXFxcXMKdTMOIXHUwMDFjQcKFXUk1VcKTwrPCg3HCmMK/e8ONwoxjXFxmwpzCh8O5fi/CocKaOcO4wrFfLXFcXFwiw5pgNlx1MDAwN8KRwq5cdTAwMTjDgMKaw7dcdTAwMDTDhXvCisOMXHUwMDBlw6BfwrXDlMKHwrnCoFxcdEzCnU8wXFxcXMO2woPCksOtwoBcXFxcK8Kiw4zCp8K1w4Y6w67DuChcdTAwMWVcXHZ0woHDkcOxw6TDrsKRO8O/clxcXCLCkSbDpiNcXFxcw55fw5fCmW9jXHUwMDFmwrPCvsK/wqPChFx1MDAwNDFcdTAwMDM9TcKAXHUwMDE3w6rCs8KOw6bDvMOVcMK/wq3DpMO8w6BcdTAwMDFmwoNcXFwiwrfDkMO8w4fDtFx1MDAxN8KSOMK1TFxcYnPCgMO2d1Jawr/Cv8OOw7xsPUpLwq7DqnRHXHUwMDFmwr3CuXxewoHDssKBw6TDi8OyWsK4wr7CrFlaVMO4wovDtVx1MDAwZcOPNMO8w4fDsk47XHUwMDExNlx1MDAxOCZawpnDtE0xw7FcdTAwMTbDm8OmXHUwMDA1LnPCmsOMwoFcdTAwMWTCtUHCuVx1MDAwND1Kw5nCoivDtFxcdsO2wp3CrkpAXTjDo8OPLMKCN8Kxw7jDk1x1MDAxODYpTcOYwoHDo8KBMMO8fENWw5/DvcKMwo/DpVxcdsONw4hjasKLwpHCtsKMPU3CiynDmMOKZ1xcXFzDp8K/Rjd/KF/DhVxcXFw2w497w5jCiVDDtUXDq8OTRGnDhFx1MDAxZntpP3nCg0dqNsK1dMOuw5FZWy3Do2svw4VcXHZCUltzw5xww69cdTAwMDXCkMKWXHUwMDFiN8K4YFx1MDAxMzvDusOiw5E/wpxcdTAwMTfCizjCl8K1w5NBeFx1MDAxYlx1MDAwNiHDo3zDt8OuXHUwMDA3XHUwMDA0a8OhXcOGWFxcXFw2PX1aZcOGXHUwMDE5wqw6wqDDklxcYsOwwplcXHTDqcKcXHUwMDEyRFx1MDAxNMOuacKvwqHDvF/DkcKbw711wokvYsOQfVDCij1AWCFswpYlSCZ1w6PCkkPCqMKgw6fCisOZNcOIwofCo1xcXCJBXHUwMDAyw4XDiSt0woBEXHUwMDE5wrrDjETDjVxcdsK1wrPCl8OFNsKgwq5cdTAwMTRcdTAwMDLDlcKmwoDCvsO3MsOVZFx1MDAwNsKmw71swqTCuFx1MDAxNMKZXHUwMDE3wqHCpsKpwp5mXHUwMDEywoTDsFx1MDAxOMKiZlx1MDAwNWTDpcKEwo3DuyzDvMO5Pj1AXFxcXFx1MDAwNMOFwoxcXFwiw6B7w4p5XFxcXFR6wopxPsO1wodGNsO3YcOyKDtXL1x1MDAxM8OgwqvCkWUsYsKAXHUwMDBlwr7CvcOUw6fDjnXDiV5LMcO7XHUwMDFhXHUwMDExw6w3bcOoXFxcIsOuPX3Cr8KQw6FcdTAwMWHDrFx1MDAwMsKrNWXCtUFcdTAwMWPDoFFOXHUwMDE5w4J/w5pcXHTDjMKqambDh0dFPjlzbFx1MDAwNk4qw4Nwwq03w4tZfMKwXsK0XHUwMDA1woB6wrc/woRObE/CscKGZD7Cm1x1MDAwNsOOMsK2wpvDgj1AXHUwMDFlw6/DiMOVdFPDpFxcXFxWfsOJJVx1MDAxMMOKb1FcdTAwMDbDl8KtOSB1XFxiw5XClVx1MDAxNsO1XHUwMDFhT8ORw5I/wq7CjSA8PUDDvjtvNFx1MDAxNcOVwoIuclMmw6zCtEk9QFYjwqHDuTjDskfDsVnDr8KqRsO9U3TDusOFw5/CgXYne8K6wo3CicKvPsKVwrZcXHbDoMK/JsKLw77CjT7Cl09Fw5ZpOsKEwpFcdTAwMWTCuVx1MDAwNcO7w5EmO1x1MDAxY3JcdTAwMWEmUsOFw5bDvcK0w67Dv1x1MDAxMcKLd8OlXHUwMDA1bsOaw5g3WmTCim5PaXNQeHXDj8KAwr49SsOQJj19w4pcdTAwMTFcdTAwMDQqT17Cj8OEXHUwMDFjRcOCeMKTemLDq1dJLcObw43Dr8OGbMOgVlvDrVRDw5NeO1x1MDAxOFF8wrxMZ8O9PX03XHUwMDBlPkMpw5xcXGbCrsKPMcOewrnCuEsvwo7CvsKdTH/CisKCasOVw7jCo8O5wq8nw4I6Iy3DoHdmQThcXGbDun7DsMKfY8Kfw5/DsSxDJ8Kpw5bDhzXCtsKIwpHCp1x1MDAxMFx1MDAxMcOlw7ZhXFx0w7Zhw4E9TVx1MDAxYsKiZiBcXFwiwpxcdTAwMTA6w6o4eMKWbDx2MnPCuXdHUStsMsKrfCzDt8OUwocvwqNGw4Biw5tvw7/DrsOIWDtuXHUwMDA1w5I3PU3Ds0DCn8KDwpRLw47DusOYwoXDg8OSwo/Cu8OgT0B1wpPDpUXDklx1MDAwNXB/wqDCi8OhXHUwMDEzbFXChMOUYFx1MDAwNcO1PHTDqiXCpcOIKcKlw7ghwrc9TUvDi8KUTMO5wqFYXHUwMDE5wqPDucKlXFxiXHUwMDE1KSfCicOIccKtXHUwMDEyMF5aXHUwMDE1wq9Lw4vCuk7DsjhcdTAwMTnCoMOuw4HCjz9cXHbCmXJcdTAwMDfDlld6bMOCXHUwMDEyw7Mow5TCv39qw6jDjSRxw4JhU8KPwoVcXGZcdTAwMTZXbMO4wr8pwrXCoVx1MDAxZlx1MDAxNEomw6hvwpjCtDTDvH1cdTAwMTk7MEjCp8ORU8K+XHUwMDFhVlx1MDAxMcKxJ1xcXCJcdTAwMWbCtMK1w51KdSfCo8ONw7jCn3DDpVx1MDAxOV7Ch8Krw4PCmFtmwqfCjMO0wrhjd8OTbGvDuVx1MDAxZXHDgUZcdTAwMTBcdTAwMTfDoE1qwoDCv1bDtMKgTsKewqTCuGnDosKiVTs9QERzwqJKw7hcdTAwMGbDgcK8fsK0XHUwMDExwqYnd8Ovw7ZmN8OcaFxcdMKlwqrDn1x1MDAxMsKuLMKNd8KNwrFKw67CgMOsXcONOMOewqVnw4LDqUNha1dBw49cdTAwMTZBw5N/Vj/CpCtcdTAwMTTCmcKcXHUwMDAzZ3U8NXk0w73CucO/w5PDk8ODw5DDj3zDrMKnOVdcdTAwMTbCgHB8RMOiYFM3woVlOcKpwrHCssKqwqE+w6vCmFjCscKBwoXCgXrDh8O9wpjDrH9cdTAwMTbCqsK+UsObXHUwMDE2w6vCgMKjXHUwMDAzw6Erw4xVwqDDncKlw5rCjFx1MDAxMzJZXHUwMDAzN3bChWTDkXVcdTAwMWR3Yj19fMKuw65cdTAwMTDDqGV2NULCrMKQf01Nck9+w7cyK8OxwpnDvGt9PUpic1x1MDAxMsOGwr0owpTCp8Kowod6wpfDn8KdXHUwMDFmwoE3wplUK3tSw75cdTAwMWPCoG/DhztcdTAwMDTDqz8jP8OEUcKRwpLDlMOowrHCuMKQblx1MDAwZcOSK8Kvw4nDrMODw57Dh3nCjWHCm3zDlFx1MDAxM8Kzwrliw4rCoMOHwp86a8Omw7fDp0dbwr1cdTAwMWZNKsO7Llx1MDAxMlXDqlx1MDAxNsO4wrtcXGbCgF9bwqxbw51ywq7CvsKNXHUwMDE4XT1Aw58qwoHDrsKUXFxcIsK9cMKCwoBcdTAwMTbDt8KYLT1KK8OZUmzCjVx1MDAwN349SlTDtcOZQG3CvsKIw4bCskzChMK1wo9hb8O0w4zDsEDDrnHCnyA4w4fDt8Kqw7zDrnlQw7bCmMKPITTDqcO8SHrDhsK1XHUwMDA3Q8K/w5Mkw6kww79cdTAwMWLCpWp/RsOka1x1MDAxY8OuXHUwMDA1XHUwMDAzb8KiOlx1MDAxNcO3w6Jfw4dHw6TCs0vDrjB4w4I8RsKyJVx1MDAxZlx1MDAxNyBnwpvCnlx1MDAxOcKXw5Qgw6HCu1x1MDAxM1x1MDAxOMKmPUBfVMK9w4g4XHUwMDAzPUpcdTAwMDPDpD5cdTAwMGXDq8OERMOcw5VcdTAwMWXCs8KaIcObwp5LbsKha8OLXHUwMDBlN8Kmw74/wozCgzjDtcO+w48jw5dcdTAwMDPDjsOCLcOGL1x1MDAxNMKZw6VjXFxcXMKfw59BScKhJVxcXCLCsEBiw7jDgsKlw64pXHUwMDEyw5JUw54kwr/Ch1TDh8Oew4fDjMKzwozCgThcdTAwMDFVwq9XwrRcdTAwMTNeXHUwMDE4XHUwMDAzwr/CpjLCmcK+wqHChFx1MDAxYsKFT3dVw41cdTAwMDfDtk3Dn8OHw6jDlXFcdTAwMGZcdTAwMTLCjsOsw7nDkm/CqMOww5PDh37Dg8OdwrXDr8KYcVHDtcKPf3/DjynCkXbCuzdIw4PCoMKyw5VTw5zCp1tcdTAwMTLDpHHDtlx1MDAxNcKha8KXw7bCkMK9XHUwMDA2fEHCmiDDpVfCtcOhwq3DpkQ9SsKZXHUwMDE3w4fDr8KFw5dXwrnDv8KHYsKKXHUwMDFiwplgw4lkw4R3XFxcXMOmLMOfwoXCucO5woZOayfDvFTCmWrCgcOawpRkXHUwMDE5w4RCw4U1wpbDilh8WMOcwqHCscOPK8K6wos2wr3DhcOGaFrDrsOeXHUwMDEzI17DiUA6KcOaLnTCqcKxw5h5woXDllx1MDAwN8KLVsKnwpHCnC89TcObwoM3wrHCusKXwpjCgcOpwrLDl8KiUlx1MDAxOMOFwr5VwqZPwpJTwr5cdTAwMWbCrMOHwrlcdTAwMWTCoXzCpMOKdmvDp8K3XFx2wqRvw4LCt8KhXHUwMDExXHUwMDFjIVx1MDAxZMOWwqp1w7Viwqgxw549TVx1MDAxN8O1JsOrwo/Ci29cdTAwMDHDpMO1UinCtcKhXHUwMDE3wqlcdTAwMDXCt8KFw5nCo8K5wpDCgMKjRVxcdlx1MDAxOUBcdTAwMTFcdTAwMDQxw5PDocO1w6dcXFxcw4the2TDkMK6XFxcIiTCocKnXHUwMDFle0HDh8OtXHUwMDA1Y8KmwoFcdTAwMGbCnV9VK8KDw4fDiMOBesO+Q8K0dMK5wotiP1x1MDAxNMOcw6/DpcOtw7pkw5XCoVxcdsOMXHUwMDEwPX1UwqlKwr7CsMOHNFx1MDAxMMKvSFx1MDAwMsOjw5jDuzTCvMOOXFxcXHA9fcKdPsKYwrQgSsKCJ1x1MDAxMsKiwqppwrTDgcORTMO4w79cdTAwMTRcdTAwMTjCk8OUQlx1MDAwMVx1MDAxYcKPdcKoNsKcwrU9fcKIwoDDvn52w7DDln1cdTAwMDY9fSbDpCQrw4fCrGzDvW/DlHBIwpBSw7zCpMOLw7nCgk1cdTAwMWZcdTAwMTTDg8KZw7/CvcKtw6HCmMKLfH5cdTAwMGXCvsOkw4zDiD59JcKawr/DpMK9dzDDmC5cdTAwMWTDllx1MDAxZMKwRlx1MDAxMsOsw5PDgFx1MDAxZUHDh8KUXHUwMDE1YVxcXFzDs8KQwr1uwoxcdTAwMWbCglx1MDAxMD1AwpXDgztYwqI4wrnCqsK+w5TCiMKNXHUwMDFjw5B4IFx1MDAwZcKZw5/CkT/Cplx1MDAxYlx1MDAxNMOCwqXCu3XCmD1Kw4BcXGYyXFxcXMKlXHUwMDEyR1x1MDAwZT19w4vDuDNRUcKlJnRrwphcdTAwMWLDqcKVdsKiwqPDrk5cdTAwMDfDq2TCljxcdTAwMDVOw5FcXHbCi8OfWMOpNMK9VVx1MDAwMsO6XSTCvcK2wqhyXHUwMDE0w4XDnCE7bMO3Ti9Sw5dGN8Ogw7TDrsOtQGMuw6nDhMK1wofCglTDn1x1MDAxZWnCtCHCpFx1MDAxNSrCvEZcXGLCozE+w5s9fcOJwpPCk0Ehfmc/w4A1w5nDpFx1MDAwNMK8NcOZw67DsC5cdTAwMTjDtcORXFxcImkpXHUwMDFjwpFcdTAwMTPDhMOLw5bDncKGwo9PXHUwMDBmJVx1MDAxZFx1MDAxM8KNwohPaMOpZFx1MDAxMijDncObKlxcXFzDilrDhUnDoMO8c8KgUDPDrMKWU2pcXHbDrFx1MDAwMVx1MDAwNVLDj8OZw50zP2HDpCbDtMKOdkc4wrXDoFx1MDAwNsKowo1rfcOJMcOyw6fDicOmXFxcIsKbw5gnXFxcIsKlXHUwMDBmXHUwMDAzw5dcdTAwMGXCqMK6wpVcdTAwMTlcdTAwMWHDn8KhPUpcdTAwMDFKwqFMXHUwMDE4w6fCoWhAwrXCicOWwrUgwq5cdTAwMWEqXHUwMDE4fj1KUS0sVcKHwqhcdTAwMTHCkcO9clxcYikhXHUwMDE3XFx0w67DtVx1MDAxZcKgXHUwMDEzw55cdTAwMWVaw6DCnjAjw61cXFxcXHUwMDE4w7BIbVx1MDAwNcKIwrXCocODw5XCksKEJ29cdTAwMDRRMVhcXHZcXHbCk8K0K8ODTsO2IcObeMK0w4djwrViXHUwMDFla1vCsD/DpUbCqcOEw7DCisKuw7VcXHbDtFx1MDAxNz1KMyNcdTAwMTlcdTAwMTXChWTDlcOHw57Cr8KpLkPCmmLCviHCoXzChFx1MDAxOFx1MDAxM8O7w79cdTAwMTDDklPCnkFLSFx1MDAxNzzDnMKGKcOkw6s/Zlx1MDAxZirCtsOCJsOjw58tXHUwMDE5XHUwMDE5QltcdTAwMTDDosKBRD9cdTAwMTFPXHUwMDFlZMK3w5JYw7rCq0JLXFx0cjLCi1xcdFdrwptWw6nCmsOpZFx1MDAxZUXCgMOnwqhFw5RnZXM+wo7CqE3DpcOfXHUwMDAxworDr2DCpHTDgMKJw4VcdTAwMDfCv2Y+XHUwMDE3O8Kbw5fDllx1MDAwM0LDusOQwo5oM8Kywq9Kw77Dl8OZXFxcXMKKw57Ci07DocKkw61SwoY0w5fDjcK0XHUwMDAzwrpZw7prJyvCt8KLMcKqUibCo8K9wpjChsOFwonCt8Ktw7LDni3CssK+w7jCuMK+wrJcdTAwMTEsNMO6XHUwMDA3ScOvfW3CrsO8wqQ6wqlgZ8KfdyfChsKZXHUwMDFmUF50w5TCnFJjXHUwMDA3OVxcdMODw6fCpMOLPUAxwojDuMOtNMKew7jDmcOjw4TChkZcdTAwMDF0Y1x1MDAxY0nDv1x1MDAxMcOSKsOow4tVZm7ClFx1MDAwN1xcXCI7WlxcYsOMw4HDtcKMw68xP8OUw5bCsMKOwqfDgybCp1x1MDAwN1x1MDAxYlx1MDAwNDQ+XFx2SW3Cg1x1MDAxYz1Nw57Ck8KAw6dLw6VcXFxcw6PCg8O0XHUwMDFiak3Cj8OqR07CjDsuwoDDrEF2woFcdTAwMWFxw5nDtcOZwrbCoj7Dp8KvPU3CosKHwpxfw7M5w7JRJm1cdTAwMDHDjsKKR8Olw5TCtkvCncOpXHUwMDFkTC/CosKRf8Kuwq17LlfDkcKtwo/Dqlx1MDAwMWDCqcOxNcO1w4oowoXCqS3CpcKkw7VcdTAwMWTDvcKWZz19ZMKZfcOow5LCiMKYXHUwMDEywoJzXHUwMDE1XHUwMDFiw6TCq1g9QFx1MDAxMMK9JcKRwqxJw5TCncOwXHUwMDFmwo/ClVsnw7nDs8KQXFx2wqwsVG46w74xP8K3XHUwMDEzXlx1MDAwNMKIw61rXHUwMDA1XHUwMDE4K8OhSSHCjsOlJzZPw6FJTVHChjNaw7pcdTAwMTIvwo1SNsO7w4ZcdTAwMTjCnDbDmFx1MDAwMsOXb2/DkkbCmjzDjFx1MDAxNll5wrg9TcONw6fDrcKuwr1Tw6ZcdTAwMDPDuDUzwrZ1W1xcXFxbwpNUw7RvwpvCgStcdTAwMTnDmsO0wqtWwoxpLcOtYCPChMOXwqRYXHUwMDE0wotawpfDmSHDpcONw7dTWlpsw7TDrCDClFPDkcKNw6rCrVN8N1x1MDAxN8KWXHUwMDE3U8KQITtHwqApaEsyXFxcImnCrjh4w6jDhXjCmMOFw7k9QFx1MDAxOUXCpEFcdTAwMWRcdTAwMDRcdTAwMWTDscKNQcKxccOtw7/Dt2V6w59Ow4Q9fcOWXHUwMDE3KER1wpggwpotPX3DkcKswpHDvF58bcKVwpLCg310wocrcm0rXHUwMDBlXj/CqcOcw5fCksO/w71/woBgwodhw4gww7g5NFx1MDAxYsKAwrzCjHbDqsO1XHUwMDExUy1FeMOBVlLCkcOewrc/XHUwMDExw6bDpiZqYCrCimvCncKMbsKxwpQpTsOUXHUwMDE3w5p/woVDw4tNIMOUPUDCmsKVwoVLPsOBwrPCoMOsw4XDoy1lw6B+w4R/e8OcYVx1MDAxNGJcdTAwMDVYwr/Cj8OgV8KwwrrDkylwwoZDXFxcXFx1MDAxY1LCqsKUw5ZcdTAwMTbCjGDCkFx1MDAxNCdIw5hSXHUwMDA3NmlTwq3DmsK3wpzDmyZRP8KiXHUwMDBlw5zDi1h7wpXDmlx1MDAxOD1NXFx0fMOYwqFcXGbDtcKwcD/Dv8OlwqVyw6JcdTAwMDJNZcKww7BcdTAwMTPCv8Kqw7jDvMKgw4E3XFx2cTTCt8ODXHUwMDA2OMOcJcK4MnnCmifCqsOjwq5Rw5HCtcKWw5xjw75qw7zDulxcYlx1MDAwNUI9fVxcXCJcdTAwMDVSRMOLwqvDgXEjwofDp8K9IVx1MDAwNmbDqzFkw5pJXHUwMDE5w4NcdTAwMTBcdTAwMTVLNFx1MDAxYsKAw4fClMKywrDDlklIw6PDg1x1MDAxNElXXFx2wrM9TWNHVU3CjcKZwrdcdTAwMDdiw7lTw5nChjlcXGLCgkbDt8KyVXzCs8OiRU7CljQ7SMOrw6lcdTAwMWPDnMOLN0LCtsOrwpY9SnvDsMOww4VcdTAwMTFTw7zCkkzCvMK2P3NHw6pCS03DpjbDisKZw7tQe0/DvMK/w7vCv8OfXHUwMDExw6/Ck23CpFgmw47DjlxcXFzCjcKQM8OuQsK+w6vCtFx1MDAwMsOOXHUwMDA3wrbDgcOLwqjDgMKywprDtVx1MDAxOVx1MDAxNcKVw500wo5tXFx0XHUwMDE4woDDv1jCs8OKwo/CpMKUwpJIw4hpwqgtXHUwMDE3w5bDksO9w5RcdTAwMDEhJVxcXCIvR1xcYj1NwqvCiMKpXFxmwqDDl8Oxw7lJUcO9XHUwMDEyR8OSw4HCrMKmYcO4w57Cr1x1MDAxYsOKwrJVeVx1MDAwMcKHXFxcIsKwKlxcXCJaw5TCviTCuVx1MDAxMG7Cs8OvVMKGwpdcdTAwMWXCnMK5ZF5cdTAwMDPCrsOCwoBAw6VJw5DCim3DoXvDncOVXFxiUiDCucOrwpvDsGbCq1x1MDAwNj1Kw6hcdTAwMDTCnFHDn8K4wqtjwqpcdTAwMWE+U8KQw57CisK0wotfwox/LMOFMcOXw6zDp3JPUV7CvV/DnMKDwqc/ZzFCSE9cdTAwMWR7w4HCvktcXGJlw5vClMOkO8KCOEhww5dcXFwiw5TCmsOWXHUwMDFhYMO7woXCmMKQw5DDsMOMZMOdSnfCksKsw5BcdTAwMWRgw4nDpSo1fcK9XHUwMDFmwox1w6wlw7c9TVx1MDAxOWNwXHUwMDEywq3Cu8KnXHUwMDE5UcKzw5XDv0rDj8KwXHUwMDFjw7DDl8OMwr09fT1Kwq5LekbDi8ODSmdSXHUwMDAzw6Q7Q2pcXFwiw5pcdTAwMDHCvH7CuGXCr3w7w6BcXGYyw7NcXFwiwoTDuT1Nblx1MDAwMVx1MDAxNFZdYi/Dr1x1MDAxNMOnw7DCq8OoP0jCucKuIHDCsFxcXFxcXHTDkzZxXHUwMDAxwqlQwo/Dvlx1MDAxNVx1MDAwNzRqMmRhw5rCvsO4LXvCu8OmXFx0XHUwMDFmwqgjwqcqcMKVw6HDpcKLIG89SnVPw6HDn8KeXHUwMDA1wqhwXHUwMDFjwq7DrGvCtsOgbMOTTcOyw67CgFx1MDAxOWJjVMOBb8KEWGPDo18vw71EO8KiM2NwXHUwMDFkw6fDnsOAw4BcdTAwMTHCvSFIZWBcdTAwMGZqcMKnw7p/XHUwMDE3fi7DnGBcdTAwMTJsb8OSw5lJw5E+WcKmw6YhwprDkcO7P1x1MDAwZcOzwoPChnbDnlfCkcOhSsOFw758w6HCpm7DiMOPQ8KUVsOzJMO4w447cMKCckjDn8OPXHUwMDEyw4DCkVA8w7d0w6XCpsKwJy3DvW9cdTAwMWHDgzvDuMO+V0khd37DisKrYU/DksKIwpp5w5vCqm5zZ31FJE82U1x1MDAwNFxcdMOIw7xQbsKDXHUwMDEzw4w7KsOcw4XCn8KrX8K8w7LCoMKMXHUwMDE2YsKPw7XCjMKew5xERSpcdTAwMDfDq8K4XHUwMDEww4dULmYvS8K2w55+wpPCq1xcZlxcdsO6Klx1MDAxM8KVJljCmcOuwoPCiVx1MDAxZcOQwrpjwo89fcKzYcK2MD7DnCvCtMOPXFxmfFx1MDAxYsKawqHCs8O/woB4wpRiWlx1MDAwNMOyPX1CSW/DrmLCsVHCuyE0w6DDgEbDvsOAa8O1w4rCtMK7wqFRwo5BwpvDtcOhPX1OQVxcdn40f0dnTsORw6Y9QHfChFxcYi59TMKyV1fCmUZyw51gKsKKw77CrMOMXHUwMDFmwqTCjTDCuilcdTAwMTHDuS3DrXzDoH0lSyfCqCnDpmZcdTAwMDJcXFwiwqXDjcKGwpxcdTAwMDMhWCvCgcK3LsOWwqfCq03CosK5XFxiw6fDglx1MDAwN8KSw6tRw69cdTAwMWErI1x1MDAwZcKyXHUwMDExwp43w7DCpXVAw7tzMMO0woTDqU9kwoPDqW5wNcOVSFpTwr/DhEzCo8KqMcKQXHUwMDAyXFx0w4jDqcKIwqRcXFwiwq7CvSdcdTAwMTYjUW49TU3Dn8KmZcOfwqjDmSrCi3o1eDXDgifDmlxcYjjCnlx1MDAwM8K6w71+w4NcdTAwMTbDll41WsKxYsKKwoJ1w5TCgCDCkDPDtsOBw6g/ScKOwqdGw6DCqjLCi3nCp8OnwpQjNWnCjcKfwrFdTMK9UMKUXHUwMDFmw6fDnXdTwoHCqMOnXHUwMDAzwpRpw6rDtsKdw6nCvm1cdTAwMThcdTAwMWPDrGZcXFxcZsKPPU3Cm8KFXHUwMDA1w7TCmcKKXHUwMDEyOVE6w7DDrT1NwrnDtDfDuWBdLFBlJcOpZFx1MDAxZiVcdTAwMDHDmSbDgTZNc8KyXHUwMDA2w4fCvSd1wq7Dm8Olw4kyJzd3wqzDh1xcdlJcdTAwMTF7woZsw61cdTAwMTXCoHbChMKhXHUwMDE3bDd7bcOBw61BNcOxbsO3WcK4wpkqw7zCrmlbXFx0wrbCqcOgXHUwMDEyZnZcXHTDiVxcXCLClltcdTAwMWNawqwvw5jCg2FjPX1cdTAwMDQ+S8KGLMKzwqdZVcK5Rl/Dl8KWKcKSfcKIQMKIPMO7XHUwMDA0w4zDuEbDs8KIwpAxw4rDosKSflvCh0jDt8O6wpVcdTAwMTLDtcOjPUpxw6XCpF7Du8OQcFx1MDAxOVx1MDAxOcKHw5PCqiMuwqbDsVZ0wpIzwo1bK8OIwrvDusK6wq/Di8KwPUrClWZjXjhcdTAwMWZoXHUwMDAxwpI2RV4rwr5cdTAwMWU6w65cXFxcwpQ7J3/DlcKGw7pcdTAwMWXCs0HCj1x1MDAxZVvCjcO4M8OwT3cmK8OFclYsXHUwMDE0w71tYUViSyDDqWDDmsOTe8OCwqxAbcOXTVx1MDAxNsOIPX1Yw75YwprDiMOKKFbDpVx1MDAxMMKLwoohc8Khwos4wo3DpMKNXHUwMDFhw5/DrMOaS1x1MDAwMsK2wq47w5BcdTAwMDJ/w6jDgcOjw4RcdTAwMTEuIcKOKsOdw5DDpj1NwqXCicOEwpTCuMOHwpJFbT1NPFx1MDAwZWHCjcKLw4vDq8KBw5FRw45ywq/CrcOXworCmcKKw6lcXHZcdTAwMTQ9fSRBb8Ogw51cdTAwMTHChsK+XHUwMDE2ZjtyWMOxw5vDsMObOEZSwqRcdTAwMWHDocKMwr08XHUwMDFkw6A6woTDtDnCviHDjcOdPUo5XHUwMDAxLsKkw4V5XFxiVyp2b8OCXVxcdMOIf8KQwpFcdTAwMWLDuz1KXHUwMDAywpjCl8KKasK1w6TDo2Yhw6RKw63Dv8OlwrjDq8OacMOXScOpccKSwqzCnFPCt8OfPFx1MDAxOTBcdTAwMWJSw7hZYsKywopcdTAwMTcpwo1bw7YuZjAywr1iXHUwMDE2wqtcdTAwMTZcdTAwMDQpw6o9QHHCiCvDosKsXkjDv1x1MDAwM8KwwoLDvsKFXHUwMDEzw7bCkMKRN2VoT37DncOdXFxcXF4kwpJcdTAwMThORsKLw4rDlz1KKMOgOydcXGJcdTAwMDZcXFxcIcKQY0/DrV5Ow5XDh8K4YFx1MDAxY1x1MDAxN1x1MDAxNsOfw7h9IVx1MDAwZjhcdTAwMDRpXFx0wqotw7RxwptcXFxcw4PChUvCrcK3ScKfw5DDr8OwXHUwMDBmJ8Kpw6XCpsKcXFx2Z8KcXHUwMDEyXHUwMDExacKbwqjCl8KmWVHCtsOlUWZcXFwiXHUwMDFjw6NaXFxcXMO2fcOqY8K2OSPDsCfDrcO5wqdcdTAwMTfDpMK/XHUwMDBmYsKIXFxcIsO2wo9uSCVcdTAwMWHCicK5w4jCoy3DgUlnY8Kmw5vDkVx1MDAxMVx1MDAxZWDCqWsnw6bCuMO9XHUwMDFkZMOWw4jCiUjCosKmbcKkJsKOw5nDoSlNXFx0UzjDrsKGw5smXHUwMDFkw6/CsMOJw73Du1dcdTAwMTnDu2hcdTAwMWPDvcK8w5zCtj7DvsONwp3CuD1NwqllUznCpk7ChnVrLHc9fXLClytcdTAwMDFlwodGwqBadlx1MDAxOFx1MDAwZlx1MDAwZcO7KiFcdTAwMTRHWFxcXFzCscOVw7fCmnPDksOAwrB+wrrCtsK2wp9cdTAwMTBKMU7CozVpXcOmXFx2Llx1MDAwNsKMXHUwMDE5UcO0w7fCuMK+XHUwMDAzw7UrSHrChmpKP1x1MDAxM2zDiMKPKVTCo8KDw6DDtcK3cFnClDnDjEQzLcKTXHUwMDE0w5AzwqPChsOeXHUwMDBlw4zCrMOUb3VcdTAwMWHDosOuUMKAw7XCnCVbNcK1wr56XjVpw7VcdTAwMWVcXHTDnMK3Mlx1MDAxOVxcXFw2w59cdTAwMWXDusONwrzDlVx1MDAxMsOqwrRcdTAwMDXDgcOMwrAqw7PCo8K+w6lcXFxcKl5cXHRuS8K7UsKPN2vCvDHCo3PCncOfw5xvw4bCum7Du8K8YTBtPUpKw5stw6YudcOWwqPDh2tvXHUwMDBlwoY6XFxcXMODw6LDtFpcXFxcIFxcYsK5XHUwMDFhb8K7woB/w47Dh8OLX8OHI3fDtsOKXFxmSVx1MDAwMcOlwrwhTsOjdcOKb8KkwozDmsKQZTLChsK0R8OvXHUwMDA3XFxiLVx1MDAwNcKLwpDDm3HDo1x1MDAxNy5cdTAwMDU8bHB/w4rDkMKMQC85w7EhXHUwMDFlNcO+wp9cdTAwMDbCrMKHfUTCmVxcZmxcdTAwMTY4bsKHMcKSw5xHwoJ+LMKJwqvDh8Owwqt0wopzwotWXFxiw4vDmUDDjWs9TcOSK8O7XHUwMDBlwrZcdTAwMDViwrxcdTAwMDfDk1x1MDAwN0XClcOow5B6cUjCn3PCm1bCsjJVIcO5dMKMc3lSw6fCmms/w6jDj2pLw6gtwoXDvUtcdTAwMGbDtsORMsKuwr80TsOobMK3woF/RcOLQsO+wrzDhsOfPsKpw71UwqnCgMKnUsOsw4bCusOsM0xcdTAwMTTDlWfCm1rCucKCcUzCmcOzw5ZcXFxcZ27DisKGbMKna1x1MDAwMzhCw4o6wrRCw7FpXFx2w5PCnMKLVMKGMcODwrdcdTAwMTLDkEYvw5PCp8Ojw7g+XHUwMDE1M1x1MDAxN8OwUWPDvcK6N8KTw5Y2w7fCjUDCllx1MDAxYkbCkkPCvsO7esKbw6zDgsONNHPCvEVQfsKeXHUwMDFibFx1MDAxM8KtwrNbwqV5w5jDp8K1w7Yuw4M9SklTw6lkw5RqXHUwMDFkTFx1MDAxOMOLwqtFw4bCvH1XwpTCvSEgw6XCuMO0w6/DqMOPw69IwpV/XHUwMDEzf1x1MDAxMMKaZsKMXHUwMDFiwprCkkM/QlrCh8KYbsOgwo5cdTAwMTTDhFJew6zClzB7w4VcXFxcPU3CvlQxwo7Cl8Kbw57DjMOVXHUwMDE4XHUwMDBmwpvDmT1AbTbDvMO4L8K5XHUwMDE0XHUwMDEww5TDmHXDo0ZcdTAwMTRtUcO3XFxcXGbDpsKbVDJSacKxw7vDv8KYaDjCuW3ChDZqNsKeXFxiwoHDi8ONXFx0SsKRPsKjTHvDliTClFvDhcOWw4DDnSMwRV3CgWvDhMKGXHUwMDFlwpdEXHUwMDFhw6bCtlxcdsOlw45cXHY9TVx1MDAwNMKaw7cvbTLDtcKAcVx1MDAxOE4qw6dkMsOzXHUwMDE4wqc9QMKvwpXDgMO7QcOWeMOxXFx0ZMOTP1x1MDAxNcKgUEtcdTAwMTkqw6/Dl1x1MDAxME0hZcO5c8OXw4xpVcKzw5VcdTAwMGVvXHUwMDEwT8O3w4XDssK2w4t1WsOEwp3Ct2h1w6YpwqpYazLDicOnwpUqb8KMXHUwMDFhw6/CiHHCjMKNXHUwMDAyKMKvwphVLcOHamPDrcKuwoIrXFxmwoBMwo3DlcKhNcK5MGg+XHUwMDA1wrtcdTAwMDHCpMO5w5B2bFx1MDAwNsK1w6/CmiPDjcK5XHUwMDEww7fCv8KuKm/DrcKBw4DCkcKbwrHDvj1Kf8KjwrLDpMOnw7k5PU3DkFooalrDn8Klw5fDom3CusOWXHUwMDFmO8OZe1x1MDAxZsKFUDNcdTAwMTbCgW5Xw4JJwq/DgCd3RXrCumk/wpl8wqjDjWjDhVxcdlx1MDAxNsODJDZcdTAwMTnCkcKrwqNcdTAwMGbCh8O2wo7Dilx1MDAxNMOLwqxcdTAwMTHDiXPDqsOFRlx1MDAxZHnDnMKvXHUwMDE5S0jDp8KFXHUwMDFiOFxcYitcXFxcw4LDnk9Hw7vDlXDDlMKBN8OZworCtUfDk8KIw69cdTAwMDNww7jDvMOVYsK9aHE9SjHCrG9rXFxiXHUwMDBmw67Cq8O3O8KDw5HDg8OCT8OMaMOJbMKyScOmw5nCmMKrLkVfU8K3w4jDssKPLMKkN8KOw5/CjFx1MDAwN3NzwobDvFx1MDAxY0vCp8KwM1NrbsKOw7XCtsO9wp9VVcOMb8KDYMK4XHUwMDA1wrTDjHImVcOGWz84w7TDl1x1MDAxZVQ5NUBcdTAwMWRcdTAwMTM/w5lcdTAwMDTDvTDCsX1WwrXDq8KGw4BXNMOub8OWwrfCssKzwptbS8KwdsOzUsKtw7nDl8Oew4DChMKFVMK5w5FcdTAwMGU0wrJFwqbDnlx1MDAwNsOlwpdKclfCkcOJwo7Di0NTw6Zyw7h5wp9lUMKFVmhcdTAwMGXChHFmw5nCrXYwXFxcIlx1MDAxMmo9fVrDlVx1MDAxZVx1MDAxNcKew6LDmMOdXHUwMDE4L8KfRFx1MDAxMSzCqETDpsOZZ3HDkjrCtsOccFx1MDAwZivCmsOGIMOeeHt6wo1Kw7I7w55rw7dTKklOZsOAQMOlw6fDrlHCocKiwrNcdTAwMDbCs1BcXFwiXHUwMDFlU1PClTHCocKUw6dcXGLCmcOfbMKpwqrDmFPCr8OYWlx1MDAxNGJcXHTCjcKfLMK9XHUwMDE5wr40w6/CicKvOmnCtsKkw4wvwp7ClFxcZnbDoipiwp/CkMOSXHUwMDAzwpPCn2RcdTAwMTc4KV9cdTAwMWbDkcO9wpZhw6d+wq5cdTAwMTBxwoTCmmNST8OGXHUwMDFjwoAqw49cdTAwMTDDr1rCnMKtbD1KXFxcIlrDpsK7woTCsS7CvnLCnsK2wp8yw4TCsFx1MDAxZsOWZz1AL8KTwoQow7TCoMKVw482w4fClzfDpFDCuMKgw4A9TThLw592w5c0NFx1MDAxZsOkXFx0w7XCpFFcdTAwMDXCqzHDnsO7w5zDnm1VwqHDmz1KMmJCSsKiw4NcdTAwMTDChzrDt1owKnFDw5s1fmDCl8Kbw5/DicOxw6tcdTAwMWYxP8K2w4MnLlx1MDAxOTnDp8KMw5bDmVjCs8ORw7Mkw59cdTAwMDRCXFxcXMKnw5vDvsKjXFxcXCpcdTAwMDTCiMOZfn7CrsKIwqvCi1x1MDAxMTHDpsOsw5rCulx1MDAwNFx1MDAxMVx1MDAxOMObf0zDvsKWw63Dp8Khw7HDln7CqMKUa8O6w53CgMKjJ8KIWFx1MDAxNsK9T8KFw54tdsOBwosxbz1NesOjw5zCmjLCt1x1MDAwZcKtw7bDp8KRwr3CsFx1MDAxNj7CgSjDl8O4w4VoXHUwMDAxXHUwMDA1PUrCqUbCi3Epwo5cXGIlbsOVw4tXwoRcdTAwMDNlLsOTw57CoMK/wrDDk8OAwo1SRMOsIFxcZsOFLVx1MDAwNsOkXHUwMDA0PUDDj1dGw6LDmsOEw5F/UsKZw75cdTAwMTfCiFxcdMKMd3xcdTAwMTjCq8Ogw7Y9QMKwO1xcZsOyNcO3LnBQRcK4XHUwMDE5YMODwoxqw5PDnFTChH1qYcO+wrZcdTAwMTl4wrDCpcKUKlx1MDAxZcKTwoXClMOKwoxcdTAwMDTClXvChWtkw5fDsMKTw4czw59Rwp49SsOmw4/Ch8K6XFxiw5NcdTAwMTfCjMKjwqhyeT1NM8K4dMKLezXCgcOlTixcdTAwMWVYQMO2wo3Cj1x1MDAwNcKaXHUwMDFiIVfDgMKpTcK1eMKjwqglw4VPw6rDnsO1wpc+XFx2woJcdTAwMDPDvsKHLsOyXHUwMDFjwqHDn8OrWMOZXHUwMDExXHUwMDE2JEXDiz19b01MTSnDo8KJw78ow7w6w61cdTAwMGbDvUZcdTAwMDV7fl/DrMOhw6VCf8Ovwr55aXjCtMOxw6toSVx1MDAwNMOxVFx1MDAxZsKVScKoesOKw7TDsENew4TDn8K4XFxcIjLCgcOaO8KnbcKiw4/Cr2PCoW/DosKUXHUwMDBmw69cdTAwMDYlwqTDtVx1MDAwNVx1MDAxYVx1MDAxMl4+XFxmw7ZRw4xcdTAwMWTDvcKlw45cXFxcODomwoVcdTAwMTBRwrDDmFx1MDAwMcKoS8KZwpPClVxcYsO0Lk9cdTAwMDd9XHUwMDA0UsKDw43DrMO9woDCmV3CmMKcwrNsScK0LCfDsibCnsOMZiHDolx1MDAxZC9VXHUwMDA3N8OWwqFdXVx1MDAwNMKuVT7DucOUb2vClsO7w5tcdTAwMWHDgDdcdTAwMDPCh8Kow6rCoMKcXHUwMDA3wpzDsVx1MDAxY2HCg8KtSsOlwrxrw7gvwrHDp8OUXHUwMDE5XHUwMDAywp/CgE1EwptcdTAwMDHCicO5wrJswo3Cl2PDqi80Q8OLwqzDg8KBw7vChnXCj1DDqTp1OsKew4Vvw4XCp8OtwpfCpsOaZH3DiTrDksOWw7TCjcO+w7vDvlEyRcOWJG7CrWjDu8OicsOJSsKTXHUwMDFlwrPDsMOvJG7CrWjDq2lcdTAwMWYzXHUwMDFlwqXDgsKdXHUwMDE1aMOLZMKgw4nDusOmfMOBZ8OLwp0lVcKAXHUwMDFmwrPCgFx1MDAxZTPDmzzDumnCpcOBwrxawqVnw5cmXHUwMDEzwq9tKMKnRFx1MDAwNMOaXsOfc8OPwqfCmMKJwrbCpFx1MDAwMsKdwqjDp8O7Qn/CqcK6X3nCiG/Cs8ONw6rCpMO+XFx2w7o2wr/DuVJYwokkwpNOQ1PDhyjCq1x1MDAxZFvCqMOJXHUwMDBmYcKmantcdTAwMGXCjlx1MDAwNTRcdTAwMTPDh8OCw5kzW8OrwqLDtMOmwo3Dt8O0fSU9TcKHXHUwMDExIFx1MDAxMcOtVsKodsKEOH7CvGc6w7XCmMK0WTd3w5Frw7vDt8K/worCk1x1MDAwMlTCqSA1XFxcXHjDnsKwwpZwQlx1MDAxNCfCm0Vqw73Ci1x1MDAwM2TDucO6PMOwXHUwMDE1wqBcdTAwMDM3XHUwMDAyJ8Kew7XCpMO+woDCo3TChUYjwqzCsMKbw7wsXHUwMDAzw7g9QFxcYsKWwqdbw6RcdTAwMTnDrmXDr8Klw6FcdTAwMTnCrkY+cUldXHUwMDEwwp8jwrnDsS1cdTAwMDIkwoTDi8KSNVUqw4NwaWVcXGZxSsOsw6DCtsKqXHUwMDA1WU1swpfCrcKLw6PCqFx1MDAxM8K5w7xkwqBcdTAwMWXDuj1NXFxcXMK2RMKswqXDgsOEw63CrsOWXFxmwqdawpnCiFx1MDAwM8KWbcKXXHUwMDFha0HCgypcdTAwMDRcdTAwMDNcdTAwMWY0wrBdwrnDhjpcdTAwMWMhwrFcdTAwMDPDtcOkw6vCosObw6bDlX1lN1x1MDAxOcKWV8OfwrVcdTAwMTjDqD19w6HCtErConFcdTAwMWQjw4DClVx1MDAxZMKNXFxib33DtcK1XHUwMDAzw57Cl0Eww5bCssKQfMKTwqp/w4HDgMOfw4/DrMKodsKEw5HDsH/Dt8KVwovCsVx1MDAwZsOXXFxiwqR6w4dlw6N7XHUwMDFlLmV2wo1Jw5nDnHojXHUwMDA2w71cdTAwMTdkP1xcXCJcdTAwMDc4w5pRw6rCocOtwpBnw78/wpXDs8KKw5TDjMKnREXCnWh4RXrChcO3fsKaXHUwMDA0ScKsaHfDtcO+PMKmPlxcYsKYw4/DhVx1MDAxNMKdcsKuVsKsXHUwMDAzXHUwMDFlXHUwMDEwwqbCrsOYamPDvlx1MDAwNyTDolx1MDAxYUdcdTAwMDPCn2bCpcOSw5XDo1PDmHBRwrNyfmHCrMKiMXDCiVx1MDAwNcKMY8O9b2XDq0LDiyZ2YUrDtElcdTAwMTVgUMK9YsKtwqXCmFxcXFw9fX3DmEBfTcKVw54+wqLDvMKAT8OOf1Uxwo3CjMOlw73CssOXXHUwMDE3XHUwMDFjw4V3woLClS/ClcOTOMKyXHUwMDE5wrTDpsOAXHUwMDBmdMKMw6XCqsOlXHUwMDEwKFx1MDAwNMKuXHUwMDFmN0Z8fMKQXFx0XHUwMDA2XHUwMDE5ak1HKFx1MDAxZihcdTAwMDbDpmRqw7EmwoFZUMKOw5M/NcOJLsKew5/CrFx1MDAwZnLDjMO5X8KgaMKWwo/DnGbCmj19w4ZMXkLCnMOOwr7DlcKowq/DosOzeMKhw5smw6hcdTAwMWFDw6zClMKRwqY6Jy5PV1TCgC/DsMKfXHUwMDEzLVx1MDAxNlx1MDAwM8KOw5pHVXnDjsKvwq0+PUrCk3LCsHXCvC/CqDTCssKaXFxcXMKpw4rChMOSw5hIIMKcwrzCq8KAw4Vsw5bDlcKWwqhkw5xrw57Du1x1MDAxY2XCgsK4f8KZwoDCg8KWNz1Aw77DsMKGWEN0QCZ6wpDDtcOWXlbDt1x1MDAxYl9twpzCoVx1MDAxOGV4woNdUMK8OSfDi8KVcsKDwpZ9w5DCh1x1MDAxMCXDiEDDjWY2JXLDnH3CvVx1MDAwM8KFw5bCtMOrXHUwMDA1Zyskw5JcdTAwMTl1aFxcXFwmb8O5w5TCqDXDlMK2wpTDrsKAw6RBwqnDn0xcdTAwMTTChz9Hw57CmsKKwrwwbsOzwrg/Z1x1MDAwZVrCmsKCwoZ1w4jDpsK8QG45TyfDp8O2w40zw4xyXHUwMDAyPlx1MDAxYjZcdTAwMDTDh8K1Z33DtcKWwqxqWsK6wq3CsnZ7Z8OiwqLDg8O6w4zDp8OaXcKGw4hcXGJJwqDCoMOOJcOVw7/Cn8OSXFxiw5XDv8OFwpLCkcOQwp93w6NcdTAwMThvdlxcXFxcXFxcw6nDhcK/w7fDnVx1MDAxYVx1MDAxMThyPsK6wpHCsUAsw5BGKXJFQsO6w7HDu8K9d8K3wp8kasK2wrLCkEogXFxiO8Obw6pBwp7Cp1x1MDAxM1x1MDAxM1xcdlx1MDAwMcKjwo3CkkpcXHbCskLDvlJpXFxcInAgwrp5wpbChsOGwpZgXHUwMDFlQ03CpsKjw7/Dl0vCuMOcw65cdTAwMTRcdTAwMTPDnlx1MDAxYzPCuMKFwrbDkMORXHUwMDEywph3w6TCniPCncKJwpfCjknCvsKCwpc2S8KbSlx1MDAxM0N5OcOzwqtcXFwiwqzCkVx1MDAxYcOvJTnDlcOIa8Ksw7xdwovDpVxcdFx1MDAxOSo+w4PCm8Ofwrsyw4hswrPDp8KCKMKtw5Faw4DDjVkqJsOtWsO9woXDrCNAXHUwMDE4dD1Nw5ZcdTAwMWbCqMOfS8OlV8KDZ8Ohw4lcdTAwMWJBw63DpMKZbHg/PUpkw5xHwoTDnTLCncOJXHUwMDEyw5VcdTAwMTN7YcKyJsOdw4vCrMKMRcOBw7bCulx1MDAxMMKtY1x1MDAxNyZMQsOLwoPCucKkT8Ocwo5cdTAwMDI5w69cXGZPcMODPUDCuT1Aw6bCtsKTd8KWworDpcOtXHUwMDFlworDssKlRcOyXHUwMDAxw5/CscKyXcOjw4jDjMKEwol+NUDChMOSw7TDkWLDusKOwoNzQsKbw4bCmsO6w7jChGF+XHUwMDE4w7NcXGLDmsOjwqFZwoFZwo7DpFx1MDAxYsKBwodcdTAwMWXDjMOkw7vDvcO8wqFbwrdmw4/CiVx1MDAwNFx1MDAxMXPCqE/CmMKmW8OHw61ww419wqrDmy3CuMOxacO5wqIgw5B1w4nDrWYjZcOUXFx0w5JrQ1x1MDAxZMOtw6PCoXd8w4fCukXDvCBsXHUwMDEww4bDv8OmZFPDiVrDu8Kyw7DDkHRHwqhEXHUwMDExw4vDmcOTXHUwMDEywpfCjlx1MDAxNsKMwqk2w4TDhlxcZnEwwoYtXHUwMDEyMj19XHUwMDE4wpl6ak8kNn/Dgi/DnnRIw73ChMOMw7HCpVx1MDAwNFx1MDAwNcKRw6VDP8OJw47DrVx1MDAxNV0qwqzDulx1MDAwZT5WesOEw4FYRVxcXFzCuFx1MDAwZcODw5nCsF/Cu8KdQ8ORw7VdwonDmcO5wpfCl2ZcdTAwMWTDlyTChlx1MDAxNMOJXHUwMDFjw7ZcXHRRPUBSwpAzwp1uPUpjTmx7ZFx1MDAxN1x1MDAxZE0hRsO7XHUwMDFiW8Kaw6zDizNcdTAwMGY9QMObTXFcdTAwMTjCv8O8J8KCw7PDp1x1MDAxY8O2w7lvwo5cXFwiemPDhVjDhlx1MDAxZcKvwqXDo8O8c8KBaH7CicK7w4nCulxcYiHCh8OpXHUwMDE5wognwrFcdTAwMTh0JTZcdTAwMDXCkMObw4zDszZVw6t1w45gw4tGXHUwMDFkXHUwMDA2cHNcdTAwMWbCuMOjwo18dcO+XFx0w5FcXFxccDBwJ0ExcktcdTAwMDXDhcKyw4U4wqVOL8ODw6/Di1x1MDAxY8ODwpDClm/Dr8Ovw43CmMK3wqxZwqDCrkbCksK7wrNow6QuJcOAwqDCl8KCXHUwMDE1wo7Cij1Kwq7CuCrCrcOOM8OTVEJcdTAwMTnDkD1AXlLCmMO2wrJrwpl+w6nDpCvDkTnCs8KJwqBcdTAwMDY6wps9QH7CtHjDoTUxw45Dwr7ClsOcX17DvmpcdTAwMGXCk3hcdTAwMWbDtCXDh8OeXHUwMDE5w67Cm2fCqMKuwpxII8OMwrfDgkFcdTAwMWZcdTAwMDXCukzDlXzDpHLDlMObe0bCiVl9w69cXGZcdTAwMTbDkcOzLmdQw4jCpmtkwrcpcMO6wr0hw6diw5TCulx1MDAxMFxcdkHCnVx1MDAxN8KyYcKiw7d1woR+f8Kcw6Yrw6rCsVx1MDAxZTDDpsK6XHUwMDFmMFx1MDAxZcKow5VcXHTDuiVcdTAwMTZyw53CocOMV0NEPUrDtcKMLsKzw7FcXHTCvsOew4zDs8OVWEPDv8O3woV8wrhRwp1nS1x1MDAwNcOcXFxiwoUzXHUwMDE4w7xiQlx1MDAwZSbCoMOmXHUwMDFlXHUwMDFhwqDDl8KUMMKnK39MXcOMWU/ChsOhwr7Cm2JuwqZcXGZ5w7ktXHUwMDEwIMKFw4lpwrnCl0nDhcK8w7fCisKswqdcdTAwMTLDinHCgmZXXHUwMDE2XHUwMDAzPU0lXHUwMDFjwrFIwo1cdTAwMWZjw4d5RlxcdMOhXHUwMDE3w4vDscOewodHVylcdTAwMTB1R3BVw7xPwpTCkcKQwpNjwoDCssKiw5LCn1x1MDAxMlxcYsOlMsOHI8Ofwq92wpAvwqU4wrRcdTAwMTV6w7zDm8KgXHUwMDA0w5rCosOewovDgMOPw5RuSlx1MDAxNnHChm/DlErDk8Kra1x1MDAxY3zCjsOhwozDhTBcdTAwMTTDtMKgPMORSsKow6TCg2jDkWRvwr9ZVFx1MDAxZMKAwqPCh8Kjw4dcdTAwMGVCb1xcYkLDgG7Dp1TDu13Cv1x1MDAwMcKbXHUwMDBmw4I9SsKud8KBOFHCsV5Aw7JKSlhcdTAwMWFcXFxcw7bCjMO3JcKswoXDsXtcdTAwMDTDtzzDssKqXFxiwpN7wrnDs8KcTVN4w5hWw5PDpDRcdTAwMDXDg8OfwpLDi3g5wpA0WGTCtMOjwpvChMOfw55cdTAwMTdLXHUwMDEyw7ogX0jCpDbCjV07XHUwMDA3Yi7DinbCtsKBwoEvwrw3w4JcXHbCtMO/w4PDt8ORTHlcdTAwMTHDt8OJwqhkw4lsw57Cl8K0w47CocOlw6BMPX0lREnDvMOJwrlcdTAwMDbCiXbDojPDpVxcdllkXHUwMDFmOH7Cl8KSasOZwrXDh1x1MDAxZS/CmVx1MDAwZlx1MDAxZMKDLsKYwpxcdTAwMGY3w6jDn1PDrjPCvCXDlyBcdTAwMWJcdTAwMTjDqcK/JsOVwoEvX8KKIDvCkSHCu0HDpsKCW8OFKcKsWcOYwonDvsKlw6vDhVx1MDAwNMKCwqImUMKTw7VVXHUwMDE1w549QG83XHUwMDFmw7vDvTzDij7Ch8OLw4Jyw5/Cuic9TVx1MDAxNEjDp8OUaVx1MDAwNcOIP1x1MDAwM1x1MDAxNcOpw53CrMKDQntMwqHCl8K2XHUwMDA1w7HCp1x1MDAxOcKDJSXCp1x1MDAxMsKrwqcjcVx1MDAxNDjDmHN4wofCpmjCqmDCpGdtYlxcZsOSTkPDliHDlXfDosKORMOxX1xcdMKSw6lcdTAwMDVcdTAwMDFcdTAwMDEvwqDDpMK/wohcdTAwMDRcXHbCs8Orw7rCkGXCpMKFXHUwMDA0w75Fwqxew5A3XijCi1/CvmXCtMKxwo1cdTAwMTnDnlx1MDAxMsKzeUlcXHRhf3/CmFx1MDAxY8KuNMO4SMOlfjNFXHUwMDA0wpJhw7YowojCmsO7w7LDicO4w7FZXHUwMDFjNlx1MDAwNMOlwqLCjz1Kw5FcdTAwMTLCv8KEw5XDrcKlwqNcdTAwMDY5PU11T8O/eFxcYsOowpI4XFxcInHDm1x1MDAwMcK6wqXCuUzCs8KNw6PDmsKdw43Cv8KEwpLDpCfDh8K8XHUwMDBmw4/Ck8OBUGtcXGLDocOLb0TCj8OTwr/DhMOKw6FWwrjCuCsrwoBNw77DvC5VXFxcIsKHwoR5wq51w63CgEfClzhcXGZWNFfCizLDpFBBU8OSJ8KBwrlHwrvCgMOUXHUwMDFiw6tIacKyNW3DjGF+YnEjXFx2w6luXHUwMDE2YTsrwpRTwrbDunZBwoLCklfCl8KcKVN9wqXDkVx1MDAwM8KBN0J8TsKjw4bClGBww7pWXFxcXC/CojFoLFxcdFE3PsOSwo7Doj1AQ1x1MDAwZsOIXHUwMDFmwql7dEBswrl3wqTDribDtcKuWMK5wrx7R1xcXFw7U1x1MDAxNEJecFxcdFx1MDAxYsOTUsKRw6QnfcObNcK3XHUwMDFmecO/XHUwMDA2PU3Cm8K0eMOobcKVUMKcw7vCqn/DmznCuMOdwpFkwrXCscKSw5/DrsKhT3bCusKlw7/Cg3DCn8OQNi7CnMOKN8KjwpZ/w57DicOQScOyNcKPRsKJXHUwMDEww6/DnMOBwpB5wp1cdTAwMWLDtTXDtnzDn8KNw55cdTAwMGbCoMKQwrPChVjCg8KzTU5bwrDCgi/CjsKqXHUwMDA1aVx1MDAxOF7DsMKawrzDu8OAwrxPwoTChyZcdTAwMDXDojPDs8OSTlx1MDAxOMOOXHUwMDFhwr3DvEQtw67DgcKhPUDDlcKnwoJcdTAwMGXCt3PDpj1AZ8OvXHUwMDBlwo7DlcOPw5/ChljDmmLCiGTCqMKHWMO2w6JcdTAwMWLCn8OPXHUwMDE4w6PDicOzw4DCucOpwrHCo3dgSlx1MDAxNlx1MDAxNcKHdFx1MDAwZsK+w47CvMOvasOQw53CoMOgMWFpw4/Cl0UzeCXCksKjK8KMwp3DiiphwpvCtsKjd8OOwpDCnmxcdTAwMTfDqMOVw7FDw6PCpMOyXHUwMDFjLUw2XHUwMDFjLVx1MDAxZFx1MDAxY1x1MDAxZiE+wpY9TWbDs8KKw6jDpnbCqljDnDdcdTAwMTXCk8Ofw6JcdTAwMDYzUXdcdTAwMWPCpcKgw7JcdTAwMTbDh1IowpXDgWXDo8Kdwp5cdTAwMWbCm8KNwpzCqsOQYMK4wrVEwqZcXGJcdTAwMDbDhsKsw6ZcdTAwMGbDrVx1MDAwMsOoNcK7QEvDtX9lUFHDm8OuRmzDi8Ofwq1bw5fDgsKbw59UJnF/w4wgwolcdTAwMWPDs8KKwqTClT7Ch2XCp1x1MDAxNMO9b21Zw7nDqHt/wqvCpUjDvcKxXHUwMDA3dFx1MDAxYcKQecOJWcKiwobCp8OhfnDCnjp/w67CrsKDXHUwMDFmNMOdXHUwMDE2w67DlcKSYFx1MDAxNHfDlFBcdTAwMTLCqi7DkE9jw4ghXHUwMDA0fcK9w6XCqMOpwp5fwqJmw5tcdTAwMWLDq3I9TVxcZkvCkcOlfsOUesK/w7PCqDh2Y8KUw5DDv1x1MDAxYnnCpC3Co2/CgsKgw57DhcKNXFxiLyXDosKCYcOKw4Y9SsKvXHUwMDE0XHUwMDE4wrlcXFxcw63Dp1xcZlx1MDAwZcKjdcKmdnh1wpM1PUrDuUM5Zyt2wpfDqlx1MDAxN8Oyw79rdWUnw7nDtMOcRjnCpcO3w5ZgKD1NwrlnesOgwrPDrsKxwphhwq1+ZsOVw4zDr8OUwq1cdTAwMTTDrcO+wqJUdkHDvEPCr19cdTAwMWXDtVx1MDAxM1x1MDAxOXzCt8OLXHUwMDE0w5p4OsOEUHfCsMKUKcK+w6dww43CtcOhXHUwMDE0XHUwMDE1ZcKcw4bCjcOBwrnCgcO2w4JvZXHCiMOeXHUwMDFjNsKJYsKGZMKuXHUwMDAzXcO/JcO9QFx1MDAwNMOXwqtcdTAwMDfDvMK2RnM+L8KYXFxcIjbDm8OQwqRBwo3CnFxcXFzDsiPCjMK1w45cdTAwMTJgwovCuUQ9QMOrwr1rY8OQU3TCuMOcw4DDh8O0acOMTcKRwrpcdTAwMDNbw7dcdTAwMTPDgsKkwr9tw4XCm2rCpylcXHQnw43DkMOqwo3CtMKhYlx1MDAxND19OsOBXHUwMDBlbmI0ZsKRwoLCpMKTY3syNFvCvk4pXHUwMDEzXcOxw5NcdTAwMWTCosKAw7FAwojDi8KzRVhxw5XCg2/CnMO3wpt1YcO2VMOEecOowqVIZcKgXFxcIsK+wpTCkks8worCrnswwonDpMO0XHUwMDE5QMO4wrnCuFx1MDAxM8K9XFxmwpFcdTAwMTjCknNcdTAwMWMnwokjwqdcdTAwMDbCjnMqw6Ehe8OJwqrDhk0lZj1NwoPDi1F2wqrDk8KSeFx1MDAxYSlowp0sw6LDjMKifMOxWMOEwqvDuFx1MDAxNMOMwpNcdTAwMTBpeMO9cMO7Um/Ch17Cq8OlwrVcdTAwMWN3XFxcImPDjFx1MDAxOCx/dXdgw4/Cr8K/wqtTci1QL8KTwqzDrMOURsOdwozCksKcbkXCr8KMcVxcYsKzw5bCo1x1MDAxY3XDrsOLa8KYasKSwqfDnjFfwp/Cilx1MDAxOcOBXHUwMDAxYcOQwoJcdTAwMTXCisOew4tcdTAwMTPCgGrDgsO8XHUwMDE5w613wrrCp8KAXT1Nw7rCoVx1MDAwMsOMO0w/eC9yXHUwMDEydFxcXCJcdTAwMTNQXHUwMDFmwpTDt2hRwrleQcOQJMOmRDwgXHUwMDBmb1fCtmVcdTAwMWXCtlxcXCLCs1x1MDAxZcOhXHUwMDA2PF3Cg8OOLk9KwqHCmsO3w5lbfMKjw5zDjcKnd1x1MDAwN8KZPUrDl3zCh3/CsH99KFx1MDAwM1x1MDAxZMOMwodoecK3w5w4w5pcXHbDm8K5wrFcdTAwMGXCnnjCvC/CrkFGwoDCgk/CujHDmFx1MDAxYsOyTMKFwq/DgU1cdTAwMDXDjVrCnVAvw7DDjlxcXFxOXFx0fMO/bGNXbUzDq1x1MDAxYVx1MDAxYsKdcyrDksKTwpxtd0JYXHUwMDA0wpTCi8O5wpjDnsK4RGQ7w6l6wqUywrgrw4s9QFxcdFLDklXDksKewqTDjMOzPX1OwqLDssOzXHUwMDBlLFfDoT5Xw4dcXGLCoyPCpcOGw5hHXHUwMDEzw4p/XHUwMDExWT1Aw6TDn8O8wp9MR8K0YijDvMKBXHUwMDAxdFFcdTAwMDJ7fFx1MDAwNsOZaTRNwoRNXHUwMDAzwoJOw51Ew7YrJkF5YEjDs8KSSSM9QMOYw4PCllxcXFzCvMKLw4Rtw63Dn8Kgw5xWwrxcXHbDrsK2wpE9QFx1MDAwNMOzw5BNXHUwMDAzJVx1MDAxZVx1MDAxMcK8w5/CvcO3bsOcw4nDvEnDqmM9QHRgRcOzXHUwMDE4w55cdTAwMTfCp1x1MDAxN8KOwp3Cu1x1MDAxNjgnK8ODwpPDl8KOw4VNXHUwMDAzwrlcdTAwMTM5e8ODwpVPPX3Dv05TXFxiw5hpwqVcdTAwMDF4w6BXwrzDp3/CqcOYwodlQyDCpsOPwqLCvSgqwo3DnsKAw5xMwrxHw57ClH3CncK5wr3Dr8Kmw4HCvMKbwptcXFwiw4w8QsOzw7rCoFxcdsK7w5MzM8KrbcKswqw+XHUwMDE1dsOyw7BINlnDnV5ebMK1w5tcdTAwMTDDusKaR8OoXHUwMDEyw7LCmj/DqFxcXCLDqsKaP8OoXFxcIsOiwpo/w6hcXFwiw5rCmj/DqFxcXCLDmsKaP8OoXFxcIsOawqI9TXVFQMKQwrnCpFx1MDAxYsKLwptcdTAwMTd1RUDCpcKJXHUwMDA0w5rCqsKvXHUwMDE4w482wrVnwpPCgibDtcKgQGXCgsKwX1PCk8OJw5zDpMO1wq7CmsK6wpHCpC9cdTAwMWNcdTAwMTRcdTAwMWXCi27DrcKMTsK6wr5XVMO+J8KywqfCkcOpMcKrXHUwMDA0wqE+XHUwMDE5cj1AN1x1MDAxZkpxIcOew6NcdTAwMTl8cVxcXFwjeMKEwovDkMOoPU0uXHUwMDAyTlx1MDAwMXLDusKzLj1NwpVQXHUwMDEycMKswpbDty7CjcK7worCkMO3Lj1NwrvCisKYw7cuwr3Cu8KKw7XDhDPDtlx1MDAwNFlcdTAwMWEww5PDjnLDusK3LsOiKlXCqy/CpMKCwoswVMK6w7dMw4dcdTAwMWPCrFx1MDAwZUrCqMOQJsOEwrs9SnE9QHZqNsOVZVxcZsOEM2TCu8KKXHUwMDE5w4QzLibDisO4w6HCkMKsw5tyw5rCkcO3Lj1NwrvCilx1MDAwMcOEM1BNw6vCuF89fcOOwpTDpVx1MDAwZcKsaEfDv2BcdTAwMDLDkcKLZsOOeSVcdTAwMTnChMKnRFxcdGBcdTAwMGXDtcOqXHUwMDE2wpfDszNAX8KvK3TDtzlKQVx1MDAwN3TCvlpcdTAwMTJ1w6rCtcKFTcKVw6PCs1x1MDAxN8K2L1fDjU/CtE7CkcO/fVx1MDAxM0PDssOMwqTDicKVX8OwT8OKw4PCpz/Dq8O2dCdcdTAwMTdLw4HCn0Y5w7M+wrJaw509fcOWwpPCpcK5wpteQcO4woDDsFx1MDAxMsKQw4IzIWNcdTAwMGXDnTPCpTFcdTAwMDLCkcKHwrs+wpbDr1x1MDAxMcK1wrtcdTAwMTZAJcKAwrnCvlx1MDAxNTLDr8OSfsOjW0zDjTDCm1x1MDAxMm5cXGIvdjjDvsKqXFx2XHUwMDFjwrnDsH3CujQtwrx5wrxAwr04w47CksOnwp3Cm3FlwojDm8KWw4F5w79cdTAwMTHCkFx1MDAwN1gpw45oXHUwMDE5w4pfwo/CpcObQmMgw5nClT45aGFcdTAwMTBcdTAwMWRcdTAwMWVww7jDscKnXFxiwqnDuU7DnMKhw4VCwqtfw5DDjFx1MDAxZFx1MDAxMcOpwqnDqMOfw5RcdTAwMDfCrnvDrj5MwpXDnFx1MDAwNcK3V3FcdTAwMDRcdTAwMDbCgmc7w4nDncOdwpPCmV8gLmXDhW7DnsKwVcKpXHUwMDA3wqDDnsODRkAsdU3DiMOKw7QnLsKMw5rDicOqwrfCq8OARcOhw7tvwp/Dh1x1MDAwN8O8JcOtd8O3wpdcdTAwMTJcXHTDhitcdTAwMTjCm1x1MDAwZsOxQcOOaF3Cm1x1MDAxODlcdTAwMTNQQcOROT19ISbCmyrCh8OewpHClSrCtlx1MDAwNMKGXHUwMDAyPHLCsFx1MDAxOD19XHUwMDFiwqoow4hcXFxcNsOsKiVCw4hcdTAwMTPDqMOWUsOKwp7Cn2RIe2PDjsKUXHUwMDE2OsKUwrM8wrc1SVx1MDAxZC9cdTAwMDJhZXHCtcO3XFxibVx1MDAxNsOqw6PDucKPKMOlJjpAYlTCoMOSJsOVKFxcdilcdTAwMTNJKMO5wp5Sw5HCvVUvXHUwMDAyXHUwMDA2U8OZZ8Kuw51jelx1MDAxZXxkwp7DtMOnw6xZw6DCscOdXHUwMDAyw4c3XHUwMDBmw5XDqDnDki5cdTAwMDbCncKewqJFXHUwMDE5aGjCl1x1MDAwN8KNf3xcdTAwMTY3woB3wrhcdTAwMDLDsVvDmzDDnTHCjFx1MDAwN2R2USE9QMKNVlxcZl7DvVx1MDAxNMOcwohbwqrDk8KpwoJ9wrwqXHUwMDE1dmHDlMK6PX1cdTAwMWZCwqA1w7PDq3/CuXjDrsOWw5pcXGLCtTU+N3FjflrDhiHDk8KCw7XDonDDvVx1MDAwNsK5cMKIU8OVOMOQSsO7RFx1MDAxMnfDuH7Dm3E5RXYuw4PCtMOpw57DkcOqwqFTRMOcL8KXXHUwMDBlTDtQPX3DhznChVx1MDAwM3JcdTAwMDVcdTAwMDXDuFJcdTAwMDFSVz1AJlx1MDAwM8K1w4LDji/Dg2lcdTAwMDFkw67DrcOgPMKDcGnCvzwxXHUwMDE2bGQ1w68rw5RMwpNSw7fCosKLw67Clzxmw6LCisKCwprCvVxcYsOIw7fDrVx1MDAxYSjDr8KGXFxiwpXClMOZXHUwMDFhKCbDvsKeI8KpKcOTwr/Dp1x1MDAwNF1xw6rDjsKmwpRcdTAwMDRcdTAwMWHCqMOEwrxCV8K4Ul7Cg8OzwoIjM1x1MDAxNkbCjVx1MDAwZlEjw7UqZVrDmVx1MDAwN8OGZknDhsKnwoLDksOpw4JFTsO4w7srw7DDvVpicTQwV8O5XHUwMDBmVMK6w6hPwrtRfsOuwr3CuVZOUkxhTWHDqMOmwrNOwolcXGLCnsO9JsKLw7bCvTVFfSbCvTbCksK2RDHCq1x1MDAwN05qw4JiccKZw4LCuMOFwpzCnMK/O8OlwpnCrMK7wpHDiTddwp9cdTAwMWXDvcORXHUwMDFhwpjCnCthwoTCmULDn8KSwqw9Sn08w5dcXFwiwqdcXFxcWXHDlMKDwpBFwoV8ZsOQbVPDrsKlworCp8OcwqlcdTAwMTJBXHUwMDAzwpnDpMO4w4rDpMOqwqFcXFxcwqXCncKCwq1pw6DCqsOsMsKFwr3DusKUw4RcdTAwMDLDhMKuwrB+woXDgy7DrcOXw7dWw4kywqPDoMOowoBnQcK/asKEw4XChsKIw6/CqMKuwr9zwqhlw5/CvzNCT2bCjk/CisKxXHUwMDFlPX3DiUJsLFxcdMK9W8Opw7RcdTAwMTTDusOhWDtVw7k6ZMOwwpXDrMOkXsOMbMOzXFxiwovDpcK8QMKtwqbDrj1AT8OYL33CtMOWdVtcdTAwMTXDuy/DoMOFwpZPw7/DtMOSw6TDi1bCi8K+w5wkwo9bM1x1MDAwNcOCV8OnNmjCl1x1MDAxNMKXw73Chlx1MDAxMcOye1vCiMKDwqlAMHbCr0PCr1x1MDAwM3w7w7PClCfDgsK/ZzUyw6R+wq1cdTAwMDXDisKHwpzDkV4nwqYjdcKHMcK6w7XDuDw9TcOFXHUwMDBlw4FhSMOIWMOBWGPClsO4X1x1MDAxNVnDgl9Owo4kJ0V9bMOMOsOORUfDuMOhXHUwMDAzXHUwMDA1wqfDhybCo8O/XHUwMDFiWcKZZsOHXXVcdTAwMWElUcOjwr5Ew4Fhw4jDtMODw5dcXFwiJ8ONw4ZcdTAwMTPCtFxcdMKdIyxKwpBgw5ZPXHUwMDFlXHUwMDA2w7TCj8KywpnDgsOWd8OQwr1LwpBOOcO/w6LDpcOrPUBpXFx0XFxielx1MDAwNzhFwrLCmcO5XHUwMDFlwpnDuX7DocOtw7RcXHZcdTAwMDV2YsO/wpdcdTAwMTPDtcKmZVx1MDAxNVxcdD1Aw5bCvsKYwqXDmMKsbsOhJsO3wrHDqFx1MDAxY8OpesOHwqdcdTAwMTV1wqnCqMKww5LDnsOXXHUwMDBmcMO2XHUwMDFlXHUwMDE0Pis1w5TDkcKQJXnDtyRTd8OZw4xDOcO4woDCnlxcXFxMwpTDnMKyw73DocKPY8Oqw6RJw63Dl8KLw5XCkk9VQMKvODpVXHUwMDE2PUoqwrhrPU17wrLDhlx1MDAxYTVcdTAwMDQ9SnPDjmrDgj1KQsKTbGczwr7Dh8Kmw4R4wq1vwq/Cj8OXe8K5w5rCr8KXw5bDpz7CmMK0wptYWlx1MDAwZisqd0XDjMKSZSpcdTAwMDLDgsO3w7B6NcOMXHUwMDFlcEXCr8OAdVXCiMK7ccOZK3o9TVInwo/CncKUJS96w4BgfsODPU0sw7LCsMKCw4pcdTAwMTTClsOJwq/Dk8OywpDChcKcPMKFwp1cXGZvXFxcIlx1MDAwM3bCoT1KwpHCuFxcYsOqw7lWwqZ6JsO2KsOjw7fDucOeQFxcXFwuc8KkMMO2NMKFQkUmwoZMw5ZhXHUwMDFiwrDDjWY/XHUwMDA3wqxcdTAwMTPCjcOYw480w6HDgWfCncOQw7HCti0twrBcdTAwMTHDs8OrXHUwMDE4WkHDtsKcw5zDsVx1MDAxOcOPw7nDkGhbw6jDlHnCksKgWkrCpzzCgWHDkcOoSsKDXHUwMDAzIWBcdTAwMWZcdTAwMTnCl8OUXHUwMDE2IMOTJULCoMOMXFx0wqdORsKlw6x6XFx0M8KnwpPDv8Khw57Dq8O0w5FXwokjXHUwMDFjwp4nclhxwqvDjWx3w5nDnEXCt8KlQVx1MDAxOXnCpC7DmMKkXHUwMDA3woXCgcOhZMKxw4jDgC42wrlmZMKDwrh7Z8Kzb8KIw6DCoMKQw7c0wqjDuMKuw5/ClsKKUD19XHUwMDE1wojDv8KdJVx1MDAxOcKzZ1LCoytcdTAwMDfDvyHCl8KKw6DDnzZ3wpdcdTAwMDRcdTAwMTh3w5bCt1x1MDAxMMOjwprDnMKCJDtXM8OEw5BcdTAwMGVfw5dJPUAvwqPDvMOVw7VENMOww5XCr3ZcdTAwMTgjw453w6jCoFx1MDAxZFx1MDAxYsOew5PCo8KkXHUwMDFjwrLDmMKzScK2w7zCk8OWwqorwpVqXHUwMDExdMKuXHUwMDFhIVhaTV1KXHUwMDE0wrnCiMKywrcvw5hmM3xqwo9jwqkowpHDgsKSI8K+woRgwr9twrZqTFx1MDAwNFx1MDAxY8Oww44hXHUwMDBlw7QnesKLZGrCi8OAw53CrMOEIHtnR3HDgcKmPU1cdTAwMTVFOcOswpHDicKZw6fDpMOjw55aXHUwMDEyZEzCtsOkXHUwMDFhw7hcdTAwMWN6Nlx1MDAxY1x1MDAwZsK4azDCjW7DiMKPwqZaw77DucOMXHUwMDAzOSDCqXDDu8OBYcKycnPCrVx1MDAxYcK1w6PCrUjCtlx1MDAxMzTCuVs4d8KAIMKpwqbDpMKcOXd9w53Dr1bDrlF+XHUwMDEwXHUwMDFkw5RcdTAwMTPDnsOLwoFcdTAwMTLDqWtcdTAwMWXCk2bCo1xcYsOAPUo0wrLDiSpJwrcuwqJxwqdPw7dcdTAwMTjDhzvCncOcwrTCl0TDq0zDksO5wr1cdTAwMTF1Y1BcdTAwMTLDlMOMw5vDpVx1MDAxYsOoXHUwMDAxwo3Dg8OuXHUwMDE4w53DncKbw5HCr8O1OsOmXHUwMDE3wqPCrsKwXHUwMDAyw53CsTTCrMKywq3DjsK/w6zChcObXHUwMDExw6piwq1cdTAwMWZyXHUwMDFjwovDvsKOw6HDrMKTwqNkw7HDjcKHXznClkHCgm3Ct8OCw6jDiCZJXHUwMDFjw7/CvsO3c8Kgw4TDj8KZaMOTwrjDgmptXFxiw4nCkDzDkMOuaE/CpcOEMnPDjMKzOlx1MDAwM8KMw7Y9fVxcdj1KcW9mw6vCgcOowq3Dq3LDpcOTw7LCo1x1MDAxM8O1XFx0XFx2wqfDrsKXKMOqw7ZQwonDgsODwq9mfMOnXHUwMDFhZSTDlcKKwpY7w4zDv8OMw6fClibDgMKmccORwq3Dj1Ruw6bCulx1MDAxMFbCkcOzXFxcIibCulx1MDAxNUpfVsKlw4LCr0zDrnNrWVx1MDAxM3fCljdcdTAwMWPDjFxcYsOFbsKKw7LCmVx1MDAwNcOLw7tqXHUwMDAxP8K/NU3DqcOEwrNcXFwiwqxcdTAwMTBcdTAwMDfCvG1Uw4HCvsOqXHUwMDAzwpIxXHUwMDE2dz1Nw4LCqjJwOcOlXHUwMDEwXHUwMDEzNVx1MDAxMCbCocKINFx1MDAxY1x1MDAxMGhcdTAwMWFZYsKJXHUwMDA0wrVcdTAwMDFSRnHCrDvCq0bDksK2wo1cdTAwMWbCvcKCNVjConxcdTAwMTJHZlx1MDAwNsOTSXjDusO5wpbDuUdKbmxcdTAwMDXDicKlScKYYGU5worDosKZXHUwMDA1w41Mw73DsTt7w6zCiGNcXFwiwpk3wr1cdTAwMTRiw6Q+XsKyZTNcdTAwMWLDh8OkXHUwMDBlXFxiwo/DsXTCvcKDLSDCr1x1MDAwNcKXRjDCgcOJXHUwMDEzw4bCu09cXGbDo8K0wpx9wpzDuFx1MDAxYShRwqlcdTAwMTVcXHbCgcOXYsOdwozCom/CuMO3VcOkw69cdTAwMGXCr8ObwodcdTAwMTFNw4ZFO3LCqDbDmsKobsOqXHUwMDFjw47CgzfDrDTCl1x1MDAxOMOEW1fCg1x1MDAxYyvDisOlXHUwMDA1wqJRw5LClSzDkcKAP8KBw4XDgCRcdTAwMGXDjnrDk8OBw5gpw68oUcOuw7zCqMKvbcKFwonCpHZVS8OXXFx0w63Dg25cXHbDmnJVw7xXwqrCjMOWwpPCtcOJWMOdw4JawrdcdTAwMGbDrMOYwpJsUHknWsKewp87W3lzZsODwqJcXGLCgcOKw5XCjFx1MDAxMlx1MDAxZsO9LXLCocOjwpJtXHUwMDEyw5jDusOew6ZvwpJcXHbCnFtWw6jCoTbDlGRcdTAwMTdWQcOHw6p3w7BcXFwiecOiXHUwMDBmwpxbPFLDtcKywqbCrMKAwqBow5IhwoBcdTAwMTTChsK6w61zwoNcdTAwMTFMw5BAw4fDkMKGw65mw5LDvcOrwobDpMK7dcOhQkfDtm9cdTAwMTlFw7JPXFxcXMOXwp3Cs3Yxwp3Dq8KjwobDo8OKw5lEw7ZPXFxiwoBcdTAwMTE8w4M9QMOjbsOQw7hvSMOtXFxiw5dcdTAwMWLDjcKjwpNcdTAwMDfCt8Ocw5rCsXpQw63Cplx1MDAxOcKzOMOKTMKNOcKuwrHCtGDCt25CVkTCjsKXYsOGwo0nw63CgsK3w4hDJsOgLl5zXHUwMDBmdcKtw7PDjcKwXHUwMDFlOsK6w5NcdTAwMDfDkFx1MDAxZcO9b1x1MDAxY1xcdsORwrdcdTAwMGXDrcO5OlxcZsK+woLCg8OfwoVcdTAwMDFvbkhPw4NcdTAwMWZGaHxcdTAwMTJAIGw+wqRkXHUwMDAyw6JsNsKXW8OPw5k+wrzDsMOkwr/CpsKkw6PDgj1AwoE0wp/DhcO9XHUwMDFmw7XDr8KkwqdPwrvDjGTDt8OAwrV2wolTw4rCmFx1MDAwZjg4wrTCksKlNcO6aMK0wp/CuzXCksK6Iz7DkVPDgVx1MDAxZmxcXFwiXHUwMDBmXlx1MDAwZsKMXHUwMDE2wpN4fVjDssKbwpRaXHUwMDExw7xXwpAwwp1cdTAwMDPDmmTDgcOyw57DuE9cXFxcw4dFw7LCj0ZdWcOjwrZBasK3fsKJXsO3XHUwMDA1w5zDq8KGOiYkw6PDtsK7w5N4wodAcsKHbMOBw6s5XFx2XHUwMDFlwrZcXFxcwoDDq8OIwqtcdTAwMWHChcKcw7rCjMO+R8KbYsKWeWhmwq54wonCtDxDQEUnJsKdwpXCm8OWw4bCs8KhXHUwMDFjwq1NLT19wrlqXHUwMDE5w6tcdTAwMTHCtcKBQsK5w4bDkMO8OcKbw6QnwoHClsKGJzTDqcObKTTDqcObwqQvw7JbwqQvXFx2w7jCqC96Yi3Coy1+wphkXHUwMDA3U0zCqcK/XHUwMDE5MMOvLnnCncOMwoZhXHUwMDE0wo7Dp1x1MDAxYcO3JzR4XFxcXC8yNcOeL8OwWMKfw55cdTAwMTJcdTAwMTgqwp9cXHZcdTAwMTDDiihBXHUwMDExXHUwMDA3XHUwMDE0w6ZFXHUwMDExPU3DvyPDosO4UTFyw4ZDwpnCrUbDuMKsYMOaw7h3aMOSw4NcdTAwMDPDjsKBwo11Slx1MDAwZcO0UynDqHBxWMOnXHUwMDA0w6IwYMKCXFxiwqbDqT1AQWPCp8K0VU/Dl8KDwqxcdTAwMDPCnmrDlyvDpUZFPMKiw6dtIHpgXFx0wqojbVVcdTAwMGVXJsKiwpk6OnpcdTAwMTXDsm/CmirCmMOsw5N2aCMzw4hjw4t/w6EyJ8KZw5nCgnDCvHTDtcK7XFx0wqLDsVLCsm/DtsKdw6ZRwppcdTAwMTTDg8KBJVx1MDAxOCbDqcKCwq88JkpcXFwiw45sdcKXXHUwMDFjw4bCoCgswoUywrIrTzTCr1PCrMOEw6bDmcKFMcO3woJ3w4kuXFx0wr9Jwog3XHUwMDBlcsKkw49Sw6NWw4hjeMO8SnTCqHQoJcKiw6rCgcKDVkxJwonCl8Kqw6ZcdTAwMGViaUEkw47CmCzCiHzCkMKgw7rCgFx1MDAwN8O7eMK3RMKdw5MhXHUwMDExw78hwpZbeMKtTcKYb8O4wrxyTFx1MDAwMsOvdMObw7rCmsKWWcKCwpxcdTAwMDTDoMKVUcOtcVx1MDAwM8ONw6p3OMOCNcKrUzPDpsOzdMKudcK8w4zDtsOCesKEwposwqzDi8OJVMKOwoxcXFwiZEY+wprCs8OLw4dGOMOQUcKqwqTCt3pcdTAwMDJybMO7WXPCkcKFwrpjT1g9fcK1worDgUJcdTAwMTnDiFx1MDAwZsKXwotGPMKjPUDCqcOJwpctK8OcwrTDpkDDkMO3fEVqeU7CuMKFfDnCusO4wqPDs8KIwrvCkMKuw7nChcKhwq/DvcOZw6XCtsKGwqXDn8KFKlxcdG3CuzzClsO4XHUwMDBmw4fCnzl7LsKBYyhcXHQsw5NcdTAwMWJpwqRJw5BcdTAwMDRIcl4nS8OlQzpgKsOwwrZVO2dNwpLClj1NSGYuVcO1SXdcdTAwMWFyXHUwMDFjcVx1MDAxNWhUUGYnwrIsw55cdTAwMWNIw7BPw7vDp0FcXHRCwrnCmcONPUBcdTAwMWXCs8OcTcO+XFxcXFx1MDAxMzDCpMKhPUpcdTAwMDI4XTrDi8KywqE7XHUwMDBmwq98XHUwMDEzw6jDrkzCk8KLSVx1MDAwNl/Dsz5hdcO/wpDCuChAw4ZXZGxZwrTCvMKIw5zDgz7CvjvCq1jDtkBVYcKvScOMXHUwMDFiwrfDmcOpLjcxw7LDgFx1MDAxNUA7w6xXwrFlXHUwMDEyXHUwMDEyWMOGUlx1MDAxNXUswr5Tw6k0e8Kbw6whUsOJwqktw6JfXHUwMDEzbsOcMEjCsMOqNmBYdk3DtsOlwp7DpFx1MDAwMsKlesKIw4BcdTAwMTLDiFx1MDAwZsOAPUBmw6Z0XHUwMDFmw7ZkVcKiRXHCrC/CqcOEwp7ClUtQXHUwMDE0TD1NPUrCmmfCnTJcdTAwMDJaw7pFXHUwMDFmwr8/wrvDmlx1MDAwZlR/XFx0w4pBw6bCozpcdTAwMTXCs0xcXGbCvUzDhsKJWSlnw55cdTAwMGXCtsO2dMODwo8/w4DChVx1MDAwNH0two9cdTAwMTklwqZRwq7CtUkkwr9cdTAwMTR+wrRONcK9PX1ucsOneWDDki/CvUg7MVx1MDAxNVfCikgowojChVQ5WSPDt8OLclx1MDAwMcOeUlx1MDAwN2cnWcKreMKLwok1fMKOwpvCnlLCksO3RkdcdTAwMDJ5wqrDoMKhfsKZwrY7dsKBw7BcXGLDu37Di1nDnFx1MDAxYUY9fVxcZsOaOsONL8K3S1DDiivDlsK2wpp4wr1iw5Mlw6ddw73Dt8K3UcOgcjAsTnfCkMK3LsKiKsKywoRcdTAwMTbCgjrCnsOue8OXIHtaw4nCh8KwwprDt0TDmyzChmhcdTAwMWLCnGB2XHUwMDE0ZkZjw5fCl1x1MDAxOEbCgMOjTD1Kw7TDtsKaLGzDm1x1MDAxY0bDmMK/w5J4wpZ8XHUwMDEwXUTDoVxcXFzDhVx1MDAxZmzDhcO4w6w7wqHDjFpAw5bCmGlcdTAwMDcqwrfDi8KTccKmw4fCtkBRXHUwMDA1bcO3cHVcdTAwMTI8w7jCsMOgwrXCvG5cdTAwMDZxXFxcXMOrw4vCisO9wrLCr8ObXHUwMDFhfMKeWsOFwqpcXHbDsy/DkcOJwpkgOn5cdTAwMWVKw6DCqH/CoU7Ck0HDhcOmw77DoMK/TjvCunJOWcOgXHUwMDE0wpExw5bCgHc6UlxcZsKrd8O1M1x1MDAxMMKRw4jCrmXCtsK5wrLCsW7DtMKVfcOoXHUwMDBmwo7DpMOXw4FUw4nDlyPDplx1MDAwMcKeXHUwMDExR8OZw6nDnsOjMcKQwoXDqUzCrV/Dm8KzwrtRwo/Dql1cXFwiOGpUXHUwMDAxblTDk1xcYkFCbMO0ZMKcXHUwMDA2XHUwMDE2RktyfDDCnVRNXHUwMDEww4tyw7bCrcOBw4w3XHUwMDA1fj9swo/DrsOfwqs+wqJ0w45cXFxcwpjDsz1NPX3DiMOSw7RiesOcfsKEezXCtMKRw5bCrFx1MDAxY8K2w7N0w4jDgsKEIzFUwqbCjWjCocOJwpt5Plx1MDAxZlx1MDAwZsOnw5Y+SsKawovDm8KReUJcdTAwMWYrwoB/PiTDs8K0w4FXfSzCuMOkw5LDriPDg1VcdTAwMWPCj8OBLMKWOcOoVcOowr9cdTAwMTXCl8OUw4/Dj1TCssKQwoZww5czwoBnw4HDlMOUwog9SsOCeVx1MDAxY1x1MDAxN3fDtcOvPUB+X3rCi8OIw448w6BcdTAwMTEjw7NsScOMwo/DocOywonCoMK8w4HDjMOyZlx1MDAxM8KBwrPDiMKbdcOYw4TDu1x1MDAwN8KiU8KcZ1x1MDAwM8KZwp9RwpJcXHbCrcO4woHCmEbCqsOZYcKrwp7DrMOIb8Kfw5JKVndVXHUwMDFhZkJkXHUwMDE3aMOgKlx1MDAxNsKpw68lZcK7WMKqw7HDkTVEbMODXHUwMDEzw4xcdTAwMGV2wrFcdTAwMTHDqWwkP8O1dMKPwrcyw7zDsMOcwrtcdTAwMGVqwqLDtsOrwrxsU8OVwofDrVVvWcOOeVx1MDAwNcK/w6k8K3txwoXCn8OLwofClmvCjMKwwoB3wrHDgVlBwprDm1x1MDAxNMOIYsOEw7JFwo0gwqRcdTAwMDfComPCvMONWMKZw53ChsKCw7ZcdTAwMWRyO0xcdTAwMTHDtcKiw7HDnsKze1x1MDAwNMOvID/DnSx7XcKQXHUwMDAxXHUwMDAzblRcdTAwMDTCjMOrJmR9I1VcdTAwMTIzw6XCgMOKXVx1MDAwMsOcwpzDnFx1MDAwMsOkdsOHwpjDtcKhw5lqw59ow7ljw5/DhsOpwpbCr8KEXFxiw67Ds1x1MDAxMMKSamswVlx1MDAwZcOBw6Iww6VcdTAwMTTDlsOYwqdcdTAwMDJpXHUwMDFjw7XDvkzCmELDv8Kjw4XClcKOw5hAU8O+dMO7XHUwMDBlXcKUO2k1Nz43P8OsXcKAMFfDncOdXHUwMDA0PX09SsKVUlx1MDAwNVFcdTAwMWbClcKKwonDjsOZZMOQwoJcdTAwMWRcdTAwMWHDsMOeW8K5wrhUbsOWwqvCg2vDh141w5BcdTAwMDNcdTAwMDTCuzwnw5lCesO+UsO2XHUwMDFkXHUwMDE3wq/DgcO9XHUwMDBmXHUwMDA3wqzDg8Kow57CicOVw4TDtsK0wqcgw7LCmFhfUsOLw7FUbVvDlMKQXHUwMDA1UMO3wq4gJlx1MDAwNcOMw6/CtMK/w4ZcdTAwMTXCl8OUXHUwMDA0XHUwMDE3w49cdTAwMTRcdTAwMDRYXFx2SCF5XHUwMDA3MHnDsFx1MDAwN0FzwonDoWdAfiN7w7MrwpdcdTAwMTTDmcKhw5hKXHUwMDFhw5XDjEvCrcOKwp9cdTAwMTDDk1xcdMO3VcOMXHUwMDE4PU1uw5/CiMORPUBIwovCtXXCu07CtnfCqFx1MDAwMlx1MDAxZmPDl2DDjVx1MDAxY8KBwqLDgTRcdTAwMTY+w71YTcKhw6DDvTxbNzJ3woYhw70mYXRIdD19ZTrDn8KuwqzDk8KSM1x1MDAxZVx1MDAxZSTCpmFwwrpcdTAwMWbClMOgw6HCicKgwocnP3LCpn4pwpJ/J3rDgjd+acKSwoJ+w6nCunIqXHUwMDE2fldqT8OYw6TCqy/DucOnQ0E7wonDp17DmMOoVFrClMORw5XCkMOMO8O8aj19wo7Cq3fDvcO9wqskwrF8XFxiw5fDkDo1w5/DmGXDucKwbVxcXFxzXHUwMDEyLcO+wp1cdTAwMGVDw4bDssKmw6fCg8OxZkZFXHUwMDE0woHDvVx1MDAxND7ClMKwwqHDjiw2P8KBXHUwMDEwPX3DpFx1MDAxZjTCqsOFwp4kw7TCklxcXFw3w67Ch8OqZmzDv8KDT8OmVsOwXHUwMDA1XHUwMDBmw5LCicKewrR6woY3w6lcdTAwMDfDtcOaw4bDt1x1MDAxZcOpwpTDksKiwqPCtsOkwpfDsMOoRMK0w7PCulx1MDAxOD1Kw4tkTTbCsFTCi0jCrcOHOD1Nw4dcdTAwMTI9QMOUw61WwpVUwqfCt3rDjU7Ck1x1MDAxOMKLw47CiMOjw6zDqsO8wppcdTAwMDcseynCj1XCtmbCuX/DtzxcdTAwMDXCnVx1MDAxMMKuwpdcdTAwMWVIN8Olw5fCo8Oow4xcdTAwMDPCuj19wpDDuMKXPyVcdTAwMGU4ecK0w4RAWFx1MDAxZjpWwpxcXGLDmypcdTAwMTXDssO4JsK0P8OiwpjCiS1YwoHDi3tXwp5cdTAwMDRnwobDp27CgcOhXHUwMDEzXHUwMDE0ZjlcdTAwMTnDtMKhw73CsVx1MDAxZsKaw7bDoWbChnc1woVcdTAwMWPDgn9eV8Ouw45mw6stPlxcZsO8wqbDpcK1JcKUXFxcXFxcZkdlPU1HWzl2wprDgVx1MDAxNsKgw45sXHUwMDE5SzNZXHUwMDA2Q1nCtnPCjcOCwrjDl197XHUwMDA3w6nChMOhw73DjsK7wqRWWDHClMKhwqzDkVx1MDAwNjVcdTAwMWXCjcKHwonDqcOZwrR/ecKRXHUwMDE1PX1iScK8wrIsw7lOw6PDksKJw5ldwprCpFx1MDAxOV1cdTAwMTJlL2/ClcK3w4Ymw5JcdTAwMTfCjy7CnsOYwr4oPFx1MDAwNMO4KcOvwoFZw6HDhMOcUCPDnS7Dj8OzR8Kjw4DColNcdTAwMTdJwq3CjDXCh8KAXHUwMDE2w6QtLcOiwpfCr8OLw5pAwpUnTcKUbcOrfjnDsMOKUcKywo9Tw6xMwozDpnTDpSbCmmggwpJbXHUwMDE0w5/DtsOOQS7Dv8OOwrdcdTAwMWPDtzLDii3ChcKNTXDDlSbDvMKhXHUwMDE0w6U9fcOgXHUwMDEww6rDl8KMZsOgUmwwR8O3wqXCmzzDpT1Nw5RKw7PDuMKTw6PCtSnDg13CgMKSScOMwq1+NcOQaSMzK1x1MDAwZSHCpMOpw4pUwpVyw7LChjzClVbDuFF1w7JqbsOVMlx1MDAwZcOzw7zDmD1NwrRcdTAwMDXDr8OSV8O8c8KYXcO/w41sw43DlMKswrh0U8O7wptHXHUwMDFmw57Dg1lbVC/Du8ONXHUwMDE5c1YgXHUwMDA3XHUwMDAyXHUwMDEyOcOsT8ONXHUwMDEwwr9bXyDCpzDDvGbCvifCgsO+cV7CrsKeU1bDg1x1MDAwMlx1MDAxNj5XXHUwMDE4M1xcdGBcdTAwMTR6XFx2w4xewprCtVxcXCLCtkDDk8Oqw4IjwrbDrnHDgjpcdTAwMTjDunPCo8KwdCw+wr7Cs8O7wp48wr5nX1TDpsOHaMOeXFxcXMOWQlXCtVx1MDAwNMOCw7ZcdTAwMGbCumnDs8KYwrPDp8OZXHUwMDA2XHUwMDFjw4LCulx1MDAxOV3Dj8Kiw5/Cj8OEMsObJjzDpD19w4tmXHUwMDE2JMKqw5t7RMKOwp54O8OGw5HCg8OOYzLDij19wpZkw6xawotoYMK+wrPCnlx1MDAwMSB8wr3CnDhewrVcdTAwMTbCv8O8XHUwMDFlw63CocKzwoPDq8KqXHUwMDFiTFx1MDAxZsKcTsKsQjZ3wrxNbi3ClWTCrsOcXFx2XHUwMDFhRcKnwobCqjDCqy9Ow7Q+JVx1MDAwMcKHwrU4MzjDrlx1MDAxNj9cdTAwMTRMXHUwMDFmJMOlJGNrwpbDhMOIPUpvw4l1RcOGLcK4asOwMXA9fWJcdTAwMTEkw5E7PsOPwrzClcKsw4DCh1x1MDAxZsO1U8Kdw6F6WndcdTAwMTB2XHUwMDFlXFxiw4XDmSR6w6jDsVjCk8KLwrhbRcOnwrRwL8ORw4zDq01cdTAwMWR8aHPClcKEw4nDv8O3wqXDtcKywqLDpsKCXHUwMDE3NHtfw7TCv8OUwoLDiMKXw7rClsOmw5rCpsOAJ25gXHUwMDA3XHUwMDAxw6bDi8Kbw5ZcdTAwMDJcdTAwMGXCjG/DoXDDkGg1UsOuw6vCvGM5w6XCtsKVw51wN09cdTAwMTbCv8KoXHUwMDA3w6nDnjnDhsOLwoHDiMKVwqpSwpJcdTAwMTDChSjDs8O9wrPCgzV5ccO3wpXCo33Cmlx1MDAxNsK0Km7Dr8KLw4Y2wpd+f8KMdlHDrkZjw57CgMO6XFxcXER0bsO7wqLCgWdvPUA7Z8Ovw5jDv3BeKj9cdTAwMGZ1RX9Lwp5zTW7DhCNcdTAwMTYzwrtMPU1cdTAwMWXDk0pcdTAwMDTDhDxcdTAwMDNcXHRFXHUwMDAyw6dbccKVZExmw7LCvlTDvHF8VkvDkC3DjD19XFxiwox9w4pPVMKKwpdMScO/wr95w6DDhVx1MDAxNzFww4/Cs1x1MDAxMsKzw6xlw5pcdTAwMGZfVj5NVcKmwqN3V8Kmwr3CjjXDhGLCllYrw61Dw63DvMKYd8Kiw61yXHUwMDE3woErw6lcXFxcw5PConRcXGbCtVx1MDAwZTzDj8K6e8O3U8KLXHUwMDEwXHUwMDAzwqlcdTAwMTHDqHl4w5pUwp/CrVx1MDAxZH1cdTAwMGZxwqnDl3pQw4Niw5TDpU0nw6XDgnnCgMKiYcKXw57DjMKhOcOsw63DtMK0P3XDpD7DoitcdTAwMTjCjmdOwpfCrVx1MDAxNsK9w6FcdTAwMTnCgMKiwolSYjDDkDTCqX5Pw7zDssK+WXkqZTN8bsKnd1Avw48hMWsobcOHLsOiwrjCvsONU1xcXCIqw4XDnHE+clx1MDAxMsOsKMObXFx2wqY9Slx1MDAxZDBoKsOTwoZJwrpcdTAwMTBcdTAwMDV0JWzChUIjWsKTwotMwrx3wo9rw5BEw7LDslx1MDAxYsKBXHUwMDFlfUXClkxRZ8OjVGFrQ1x1MDAxNcOoNsKsw5ZRw7hfdlx1MDAwZsOVw7XDk8Oaw49cdTAwMTIgwpPDpm4jesOROcOawpHDtWvDosOMw7PCi3PDkVx1MDAwMSlxXjLDiMK1aUg4woR3ajbDjsKsesKaXHUwMDEyw5HChzTDk0bDjjfClMONXHUwMDAywoPCt1x1MDAwMSjCusOewrrCqsKAXsOEMMObw6HDtMKBQ8KPwpk1P8O3U1xcdsO2wqNcdTAwMTheXFxcXHRcdTAwMDbChsO2XFxiw5BcdTAwMDdcdTAwMWTCilx1MDAxY8KFwqnCilx1MDAxY8KFwrd5Y8K6woZcdTAwMGXCkcKVUcKpw5XCq8KXw5TDrsOgelx1MDAwMcOTWXJFXHUwMDEwwpXCt1x1MDAwMlx1MDAxYVxcdMKVNCVhw57Ct1x1MDAxZW1cXHQlwq07w4BUwoBcdTAwMTh9wrIhwrTCicOdwoBcdTAwMTFSwrA9TVx1MDAxY1x1MDAxNj9cXFwiwqjCj8OtwpBLwpNVwp5cdTAwMTYtSsKUasKMcFx1MDAwNcKVJjY9TWHCiVjDp0Qzw7Y0WMO3w4pcdTAwMTjCtMOiw7xRRCB7e8KfwpMtw5HDimTCrsOfwpbDgk/Cn0d0LXlcdTAwMWE7wowwd3Ajw7PCosK7wpnChMOHwo7CvlTDg8KdN2PDg1x1MDAxMsK4Z2FcdTAwMDE7wppcdTAwMTJcXFxcwqXColJMPU3Co8OMw7zCtVx1MDAwZVx1MDAxNj1KdzLDnUUvNsK/w4HDtsKow63DvEhKw6syUVx1MDAwNGopwoHCkVx1MDAxNsOiw47Cm8OqwoVMWDzCicOnw49mwp/Cv8OYw5VFLSHDjHUqw6XCicOzTyA1wp9UXHUwMDFhZsOYw7pPdlUmw6vDllx1MDAxOMOVPUohXHUwMDEzVMKAXHUwMDFmTcK0RXnCucO5w5DDscKvXHUwMDAyPUBTXHUwMDFiwqRcdTAwMWV/cntMMcKWZcOHwpxcXFxcwodcdTAwMTfDrn9DwrtcXFwifVx1MDAwZsOlV8K/c8OQSEzDuH3DqMKdf8OowqItwp90w6V/wpzDn8KFXHUwMDBmNVPCl8ORw4Z3woHDscOUwrzCi0ZEWFF9ODrCsm44KsKhwqB0MnDCp8Kfw6bDtCvDvD1NeMOjV8KHw4fDlsKcwrrCjsKNXHUwMDFhw5zCmsKHIMO5woYmwooxw785Sj1Awq3Cu8OjLU7DlMOCf8KtMDDDg2XDgFx1MDAxNsOkK8OPe8OUXFxmXHUwMDFkw59keHRcdTAwMWJSL8ObLsKUPUrCvMKgw5XCmVx1MDAwMsOfwobCnMOnwrs/w7zCkkFcdTAwMWXCgGnDvMOnw7bCplckLMOUw40uw6dnw7AwdVx1MDAxMsK8VFx1MDAwNErCncOVw73Dr8Klw6xqRmssw6Jsw7LCvXjDlMKEwq1ydMKSOFlFw4xJw4DDulxcXFx1U8K2wp/DlcKnw7ZcdTAwMDV6w7nDhivDosK8w4A/wpduw6E1XHUwMDFmfTHDh0XDq1x1MDAxMTkxNcOjcMKwwqJcdTAwMThbwofDnsO+w4Emwq5XwoLCni7Cp8ORY1x1MDAwMkBcdTAwMWRAwp9Kw7k3VcOjwrcpwoM7w5XDisOYwrzDkcO4PUrCvsORwqjCilx1MDAxMsKDw6LCocOCXHUwMDE5SFx1MDAxNS5ULWLDqyTDjsOLXHUwMDFjVUVKwr1cdTAwMTNcdTAwMTVcdTAwMGXDrXlcdTAwMWVFw71Uw549TcOjRVx1MDAwZlx1MDAxOcOiwrhcdTAwMTM9TSvDnSMlaC8vMjk7wqPCsFx1MDAwMiHDs8KAwrFsfsOYwoh7w6wjwrPDrsKRWcKBXFxmwpXCsMO4wpYyXcK6w6BNwp0hw7PCt1x1MDAxYcO+XHUwMDBmXHUwMDFic8OXJcKeXHUwMDAxwrPDicK3w7BOwogpw7bCsG3DpMOEw6bCgsKXwojCvsOPW3pDOcK/XHUwMDA2SMOyw6XCgMO1ZcKbwqxvUmnDkV7DpMKewqTCrcKKK8KtbmhJXHUwMDA0X1x1MDAxZcKPUsKMwpvCrVx1MDAxZMOGwoxcdTAwMThcdTAwMDNCU8K7XsK0YcKhXsKlwqVcdTAwMWbDksKHwoxcdTAwMWXCqEUybEQ8eMOFw4nCvGnCuMO3wq7Cu8KFXHUwMDAzw5/Cm3fCpWbDtCHDhmkxXHUwMDA3wpPDvsKFw4bClD1NwpNcdTAwMGXDrVJcdTAwMWJLw4E9fW/DsMOMw5XDnMKoTz5vXHUwMDEzZSjCqiV7NVx1MDAxNy3DsMOzXFxcIlx1MDAxOcO4wrHDs8OOXHUwMDExccK0XFx2w7VcXFwiTlx1MDAxNy3Dk1x1MDAxZE5cdTAwMGXCrsKew53DjSNfw5R4wrHCt1x1MDAxY8O+SMOBw7o2PsKAwog4w4EpwrfCtsKxwqFhw4hLw6pcXHZ6Y8K0XHUwMDE3wrZIP8OWwrFcdTAwMDbCu1x1MDAwZsOUwoZcdTAwMWNtw7Qyw5HDksOwW2U1wqNLw6xTwp9kw4TCtMOIcjHCnsKJwo7Dp8Kow6fCnEVYw4nCnsO/wr1cdTAwMTTDhn3Dg1x1MDAxNsOhZlx1MDAxMWDCpcKmw5TDmCE9SkdcdTAwMGXDpTzDl2vDgsKJwrA5wr/DqVxcdsOxfW1yw6TCo8KgVMKmw77CgF/DoMOJwr8mw7Ehw4lcdTAwMDVqTzXCnsKuISZLecOhLcKSw457wqhLJMOUdcOKwpTDvGh6w6JXw7gkwpRcdTAwMTRxwptbWFx1MDAwMsOJY8KPwp4xwotfIVxcXFzCp1x1MDAxM3ojVcOow5hDXFxmwo3Ci8O/w7zDnDvColDCuVxcXCLDgCzDiFx1MDAxOD1AcMK5wqwnwrY2cMOcwoxEw49hXHUwMDBlw6MpR8OTw6bCgFx1MDAxMybDucO9fSvDinxcdTAwMDdhRHQpWFXDhsO+wo40w71cdTAwMWHCqHHCilx1MDAxYcKOw5E4wrF7NMKvw41rwqrDvVxcYlxcdMOnwrrDkMKnIMKcZcKow7RqXFxcIsKhaD7CqsOdw4ZcdTAwMGXCm0Eow49cdTAwMDFiXHUwMDAyw4ggacOUwo3Co8Okw5hcdTAwMWTDpsO/YjzDuD1Nw6xbw7pQwoI9Si5cdTAwMWPDkl3CmcONW8KAwo7DiHnDm2Qzwo7ChWrCs3DCtCtic3/Cn8KGw4rDoHBcdTAwMDTDqyl1w77Cl2TCpsOOw7tcdTAwMTHCmcOlOsOcd2powotcdTAwMDPCgMKAYcOUwoVcdTAwMDHCsMKXw6nDi0PDgMKbwqpnwqM4MntzNsOlXFxmXHUwMDFmXFxcXMKySsKrw6p4wozDrcKaw6DDncKhZVxcXCJbwrjDnTQxwqVDwqDDv0pfw4jDgFx1MDAxMX4kXFxcIn1cdTAwMDVPJFI6aMOmXFxiMMK/Q21cdTAwMGbCmT1KOlx1MDAxMsKZwqJcdTAwMGU9fTQmXHUwMDE0JyVcdTAwMWLDsMKkXSBSXHUwMDA1w5lcdTAwMTdZfmtGZy3DnMONajFNTsKzwpTChsKkwpfCojnCnj1Awpctwr3DkWbCpU/DssOAPz1AwotqXHUwMDE3w7QvasOlM8OowqDCi1TDuy1Qwr59w6/CqjLCk0/DqsKFwovDvsKKXHUwMDAzQVhcdTAwMWMtw7LDiU1cdTAwMGbCmcOtwrLDg8KHwo3DgnjChsOLwpLCtMKcw71cdTAwMDdMaXs2LnjDmcKmU8KuTXNcdTAwMWXDiXbDilx1MDAxOV3DsMO3XHUwMDA2OnLDvC3CozXCsVx1MDAwZsKoXHUwMDBmRHbDhMObwrpqw61zw5fDk8OHXHUwMDAzXFxcXMODXFxcXMKJw6d4PsKwNMKka1xcYl3Dq8OQXHUwMDExNcKVw63CisOFTz19U8O9w5ZTKsOGwojCgMKuRcOuPlRQYcKQblNTXFxcIsKwXHUwMDE2V8KywpUgPUBuYcKNwoDDkFx1MDAxNsKKwpxewqrCjjPCuMOGNk3CusKywonChFx1MDAwZsOQw618TUnCkH3CrX5cdTAwMDbCn1NPwrlcXGbClMOsXmPCu8OZwr3CtX9RSkXChHpxM8ODwo3CukdDXFxcXDXDl8KVbMOWw4A9TTLCmcODw4HDhcOMNsO1w6rCp8O7PsO8wrNcdTAwMTLDhcOjU8K5RcKUXHUwMDBmMMOgak3CsEQ/wpQrw5BcdTAwMWTCn8Ocwr3DvHtGfVx1MDAwZcKXwpTCr8KRwpnClXg9TcKKw4gzw6PCr3A7WjdcdTAwMDXCl8K3wpc9QFx1MDAwMm/ChsKMw7s9Sj1KwpTCncKSwovDgHTCpUAqUmw9QF4vPX1cXGbDjsKIXFxiwrxIwq1Qw5rCvcOPRFx1MDAxYcK7PUBcdTAwMDcpw7BUasKzWcOyPX18wqFcdTAwMTLCt8ObwqFrXHUwMDA2w43DvsK1XHUwMDAzQMKwV8OJw7wwPG/CiE7CtsKhdsKdJFjCl8KoPsKSPMKlwotcdTAwMTDCusKtcFx1MDAxOcOUwoRkwqDCs8KcwoJDwr/CmHd4w4zClHQ0eTHDsVxcdD19w5IxQMKmXHUwMDBlwr1ZXU5cdTAwMTfDhSfCsVx1MDAwN1x1MDAxY8OGwqJEXcONUmddwp45KcK6w5xcdTAwMGbDvVx1MDAxNFx1MDAxZcOOXnFmKHQ+SUpKTsKMXHUwMDE3bMKvXHUwMDAzXHUwMDAxw6jCkcOIw7Iswp5AXHUwMDE2w7rDsMO0wpnDuy1Obylfw6nDncOew6l6wr3Cj8K+wqDDi8O0PU1MPUpKw5RQwoHCnsK0OsONOMKdwqvDh8OXwpLDimt5wqxcdTAwMTfDgVx1MDAwNFxcXCLDlcK7XHUwMDFjWcOLw6Y6wqh2VMOzw6ZcdTAwMDUhSHprIcK8wpY9TcO/w7dnwrNKUULDm15vwrDChsKrW3dcdTAwMWHCqVx1MDAwND19NFPDt8O8TMKbN1x1MDAxNcKXwrlgwozCocOpwqzCsX7DqyzDvTsmXkPComFgVFlrUXlQw4/Dq3jCsMKaan/ChcK0wpfDqHPDhFxcdsKRLTnDtsKra148bcORw5VQwr3Dj8OJXHUwMDEyb8K/MMOZPX10w649SsK1KMORaMOPw7PDksKTwrTCqcOdw6jDhcK5w7MtwrxnwrPDtMOMalLCncOzw7PCujjCosKYOHHDisOrXFxmMExcXGbDssO6wqrDu8K8XWp6XFxcXFx1MDAwZsKrwqAjdsKuw6Veb8ORYXIqXHUwMDFlwpoqI1NcXGLDusOYXFxiSiFjM8O+bG3Du3XDpMKkw7NUwrt7T1x1MDAwMXQ0w6xmw4t/XHUwMDFiPMOewoBcdTAwMTNPwoTCkMKpXHUwMDFhwoVcXGbCncOnXHUwMDFkwqXCk8KZwpNcdTAwMWVcXHTDrCDDpsKoNcO/aMOXW8K0YDF8eCV3e8OpcMKcPX3CoGvDksKvVlDCg1M9SizCmkLCvsO3XHUwMDEzw6/CrMKVwpx/XHUwMDAzw5d2wozCg8OgVcK6w7TCkj1AdMO7OsOMw4DCulx1MDAwNVXDilx1MDAwM0pDesKAXHUwMDBmwp3DsWvDjcKmeMO7wrfCmMObXFxiWMKlw7xywq/DtlxcZsOOwp/DqVxcZlxcdsK9w4o4M8OiwqfCqMOeezpcXGJcdTAwMDLCicOeXHUwMDBmTTHCo1dcXHbCpsKIdTo7b3VcdTAwMDZSKcOLXFxmWsKAJsKxw7rDgMOqP8K/XFx0Vlguw7JBYcOFdkJcdTAwMTE1wqTClXLDvMKiXFxmR8K7OsOrw5hBNn5Tw5bDr8O4elxcZj19T1x1MDAwMk7Cm8KRM8OBfjRBXFxmM8KyaGLDkFY8w7PClEE3QEJcdTAwMDRTw456w5fCqnrDj1x1MDAwMizCssOGK8KXw5RnPUDDk8KVXHUwMDE5woLDhFx1MDAxNjJUw5E8wqvCkjDDncOZYFx1MDAxN8OWw7LCs1x1MDAxMMOrw7XDo1x1MDAwNFx1MDAxNi/Dg1JIwotKPX3Cv2t+OMOLw6rDpFo9fTXCqMOow4vDo2TDpk5cdTAwMDd3bFxcZj1Aw4ByXHUwMDE0wqHDr31cdTAwMWFvw57Cq8OofMOYZsKmwo/DgTUow5gqXHUwMDAyw4BPwoh5XHUwMDE1VcKNWU3Dt8KlLlxcZsKfw5xNwrgkXWXDpnM3wqzDllx1MDAwNFrDnWJJw7DCmMOxZTImw5JcdTAwMDI3w44swoRsw5pOQWXDo27Dp1dKwpjCmcOew5pIdMK0dWdcdTAwMDTDq8OTw5jCtMK0WWtXw6cnUsKvw6bDsSxzesKkL8OAw57DgsK9w5Y8w51cXGJzZsK3f8KrTE5twopcdTAwMGbCkDU4wpDCo8OBdsKYwoonZMONwonDiMKBXHUwMDExJlx1MDAxOFx1MDAxYlxcYsOVw6xTXHUwMDE5w4rDrMKaXlnCgMOHYMOrw6FcXHZcXHbCjsKKbXrDuVx1MDAxMMKlw5lgZy7CvMODwopcXFwiX1x1MDAwNm7Dqlx1MDAwNlx1MDAwMlx1MDAxNkI1W8K6PX1gwo5GXHUwMDA3w6ZLwpQow7DCl8K1w6dZXsKbdzXDq8Ovwpopw6bCkzTCvcOBTlxcYsKZwqjDq8Oyw7teXHUwMDFhwqLChFvDt8KFw7NuR2nDlMOjw5HDr8OAw4rDgsOHwpl9wr9cdTAwMWNRXHUwMDFiwqtcdTAwMGXChzzDssKhwq86Nlx1MDAxYlx1MDAwZcKwbsOzwovCoMOHL0rCvcKzwrIswpFCK8Kbw6LCplx1MDAxYVx1MDAxNcKQwqnDilx1MDAxNWjCncKAw6Y4wrHDtcKxXFxmw7RaXHUwMDFlw6DCiT1Nw5PCuMOQworCjUbClcKmSMK6wqJiw55cdTAwMTnDu8OofkQsw5PCiFTCt8K9NcOxXHUwMDFhwqBcXHbDksOEw5kxY21Kw6bCuStKY8KGKF5mwotcdTAwMTRzUjDCvGZ4w58uXHUwMDFhw6g9fTnDgcORw6jDrMOWblx1MDAxNMOmQ8OcPU3DvsKVe8ObRUPCpcOBLlN9wpbCk8OPwpIhw6jDvcKUOElcdTAwMTnDjsKEwr7DiEDDkzBRwp15NMO+XFxiSCbCtcKxwpcmwqpAK1x1MDAxOMK5w5rCgXhcdTAwMDHDuFx1MDAxM3DDhm5cdTAwMWZ6wrZAw65VXHUwMDE2XcOew6XCu1xcZsOQeGl6wrZcdTAwMTlFw6RcdTAwMDdcdTAwMDLCnywgw7HDn8Khw6hCw7VYMcKxeVxcZsKAb1x1MDAxMFx1MDAwNsOjw7ctwpTCvHHDt1x1MDAwZk1PWsKONsK6P8KaLcOWw6XDoMKyJWLCrcK9SzvDrG3CusKqwrjCiDRjw5fCsMOow57CnTLChjlcdTAwMTI3NMOSXHUwMDFlwq7Dg8O/w7djw5pvblx1MDAxZMOgw6LDqcOEXHUwMDAzPUAjwq9zK1NcXFwiw4fCtlx1MDAxM8OiYcOow5lcdTAwMWLDmMKjwrfDmsOgwoLDny8nw5jCrFx1MDAwZcK9dsKPJcOowqfDhsOhw73Di8Odw70mw7TCicKNXFx0WcKnw6nCn8Opw5bCpMK8SMKZwq01woYrw6hcXFxcwrRjcmPCqMOKMsORZMK+Q8K3XFxcXFd8K1x1MDAxOSjDjMOgd1PDiMOhScKtXHUwMDA1ccOdOGYywqMlwqDDqMOJYVx1MDAxM8K0wrJFOsKMXHUwMDFkMztOSsKAXHUwMDE4wpZcdTAwMTfDssOaOMKTwprDoMOKwojDqsOaw6pHwr57w7Ruwq4xwqZcdTAwMWQqwpVpw5DDuDHCtMO7McKmfcK0wqVcdTAwMTJMdsO+N8Opwq7Drk4yUcKsXHUwMDFkwrHDgiFKJSPCh8KXRsKNXHUwMDE4wq9vw58gRzTDp8OAw5d9O8KCNMKFwq5kwrdFwoDCpMKEw6/CvcKTw6VcdTAwMTNcXFwiw5xpbV9VwpZcdTAwMTLDt1x1MDAxMsK2w57Cs8KDXHUwMDE1UGVoL8KVwoPCjlLCj8KsW8KjwodcdTAwMWVcdTAwMDVcdTAwMWM3I1x1MDAxYcOYw4tTJnDCt8O2wpdtwrLDjE1cdTAwMWU9QCpcdTAwMTjCtFx1MDAxOMKiXHUwMDAzesKAw6g0w69gw4JcdTAwMWLCgH9KwqbChcOGwrNTwobCkVx1MDAwZVFcXHbDnMKvRMOzWUgtw7haw6rCkWo2w55vw6XDl8OiXcOLKVxcdMKdw7LDhn7DhMOJw63DosObXHUwMDE0w6t7w5LCg8KWw75cdTAwMTDDrkVHQ3xcdTAwMWPCi3tiw5NVNkRcXGLCpMOnwrhyf8Kkw6fDt8OzZ2R1w6pcdTAwMTklPFxcXCJlwqnCqEzDu8OBwp3DvcO6XHUwMDE4XHUwMDBmw7HCi8OZwppcdTAwMDfDhFxcZn7DhVDDmX9cdTAwMDRcdTAwMDPCqXbDrkDDm1x1MDAwNcO+LsOFIMOgTMKpc8KLwqhmw7XDvC1qwq7CqMKtPUBcdTAwMGYtQjXDjjfCiTw9fcOLwr8qNlx1MDAxZsKxw6LDuVxcdsO/w7cxw5UtMMOVXHUwMDFlLcKkwqvDqCRcXHZPXHUwMDAzOMKiw5RXSsKXM8K7wpw9QDdcdTAwMDRKw4fCs08xw5/Cll1PfsKeXHUwMDAywrzCo1tEw6fDiVxcdFx1MDAwMsKEwqHDjMKdRjHCj8KpXHUwMDFhwo48YEbDj0PCjizCsMKewobCgkFdL0I+wqYow44+wojCoXJPw47Dnz1KwqXDslxcYjDDnMK2w7fCllM9SsO6esKLU1x1MDAxMHVGwrPCs3NKOzlcdTAwMTbCv2NGSsOeYcO0JDjCs8OzKCzDrsOrXHUwMDAydsOFMcK7wrJ9W8O9XFx2P0vDosKSfGYxw5nCtsOSccKPwo3CvsOAwofDiWrCljjCtkxcdTAwMTbCvMKjw6HDolx1MDAxMsO7L1x1MDAxNznCqj1Aw5Egw7XDgELDh8Orw4ZewoYlUyPDscO0w79vXmpMw59Tw5Asw6ZGw4jDhUw7w7/DijPCs8OAwqdowoJmw7bDn8Ksw7XDucO4PUAlwrR3fMKOw67CqMOKwo3Cj0V9MMOUUWBMI8OQwpYtw5PDkV/DvMKRXHUwMDFkw7BcdTAwMTPCjMK9w5hcdTAwMDdgKcOCw5bCssOQw47Cg8KMPUrDqMO5ScK/w4xcdTAwMTlcXGbCvcKsYTNcdTAwMDNtNUTCuj1AdcORJj9dw6bCpcOdw5pSw7XDj1xcdMOaTlvDsXh5TSQpw50hw4nCi3suw7VJWmRtXFxiwofCnMO4Y03CrMOKTlx1MDAwM8KTwrwuPz9remrCszxOMsK8T1ZSwqzDgsKdbFsxfsO2woPDg0DCnTA9fcKQw6/Dhj/DnUrDssOXw4jCh8O5YyklXFxiOSFcdTAwMTXCp8OIw7XChFx1MDAxOFx1MDAxNsKuw4hcdTAwMTjDlCTCn8KBwoHCocKfwp1Xw55LwrFPXFxcXC5rwoBfS0UzwrpCMTnDknDCi1x1MDAwM2tcdTAwMTJcXHZsw69cdTAwMWPDqcKVccKcwrPCjsK8V2Zqwr7DqSfDs8KsMMO6wo7CvTc7w6LCn3jDo8KmwrrDsn/DssOGVFx1MDAxM8Ojw6vCg8KMwpcqwpFVwovCkS9YJMKzwrbDscOsLUbDmXPCicKrVsKEw4PClsO0STLDnzVcdTAwMWHCsMKaMUDDnsKtXHUwMDE4dcOweMOSw5A9SsK6ZX/ClsOUdyDDosK7XHUwMDE2Jlx1MDAxYcKpwolqwrZTw5jCnXl8JVx1MDAxOUXCkljCh1rDpsOKXHUwMDFjXFxcIsOJXHUwMDA3IU/DqGVbJcKyXHUwMDE1woImw7fCt1RzwohvXHUwMDFjbFxcYiDDiVx1MDAwNnrCvMOWw6rCnVpcdTAwMDIyP8OpTl7CrsOicMOywrhswo52wrDDklHCnsO7woo5MMKYw5RCw6FcdTAwMWPCsz7DocO1Olx1MDAwMjXCjntSV8Kbw4bCjmYzfsOPY3jCvSsuwpFzw51yQFx1MDAxOFx1MDAwZmBKPFx1MDAxOWLDjllgwp9Udlx1MDAxZsOhw4TDrMKbQlx1MDAwMzHCgFx1MDAxNGnDncK0c2QuVsO8wozDoVJmUVx1MDAwM0dyasKgXHUwMDAyJMKhbMOmXHUwMDA1OsKDacOAbTrDg2F2wqo4wpxKXFx0w5pcdTAwMTnCt8K+w4nCslI8IcK/TcKAP8KbSDfDr8KFc8KaTcOfwo5cdTAwMDU5XHUwMDFjZMKbw6F/w6xLXHUwMDAzwqt8w4U+MsK1w6LChENgw5VKwoU9fcK1w4VcXHYpXHUwMDEwwrBdwqQpfXjCmEVZwptMwoY9SjbDsVvCh8O8I8OMKMKlwr3Dk0bCnsOXYsOXX1x1MDAwZcKAwqxBccOAPMKdwoHDpsK1w5QsXHUwMDEzXFxiwrrCq8KWL1x1MDAxOEPDj3PDusO+w4NcdTAwMTRxwrvDh8KUw6JcdTAwMWbCvsOyX1xcXFzCsnZcdTAwMDRjwpvDnMK8woXDsMOCVcOqwqxxwo7Cs37DgsKhwozDuFFcdTAwMTXDuMK8wofDnsOzXHUwMDE0w5JcdTAwMDbCmjVcdTAwMTHDiD1KYMOSwrpmT8O4wrZuw5vDr8Oqwp0tw4FDwrY1w5M8MMKsXHUwMDBmNVxcdk7CvMK2w4XCvcOnw4R2XHUwMDFmw61zw6kwRMKQw4zDsDzDgMOEwpTCnTYow6HDqTpDXHUwMDE5MVvCnFxcZj1Awq4zQMK6Ylx1MDAwMVEvw4DDk2R0wojDr29nwrR5IyZcdTAwMTHCvsOOXHUwMDE0w6VVwpc4JzrCjMORPG9cXGbClE3CsitcXGZgwr5Ow58+e8KXasOFw5RZwpFjw4U+wqrCj3XCoMObL2crw7k+XHUwMDExwp7CqkjCqkZcdTAwMTNwwpwhwrLCocKVwqxMwrNcXHQwVT1Nwp1Fw6DCssKBK1FINcOMwr3DmsKfSsKsw5TCvcKWIU7Du3zDs0NcdTAwMWIwfVRcdTAwMDZSMVx1MDAwM8OQwoHDjHcuP8OuXFx2w6tcdTAwMTPDlGLChU7DqsK0RcKJL8OGdFR2ZVx1MDAxMzjCk8KdR1h+O2bCv8O8SnrDkmVyw58yJsKsw79cXFwiT8KEw5g3wrR5XHUwMDEwXHUwMDAxPX3CucOjU8KhYcKbwrp1wqI4IMK4w5fDo1jDm8KKwp7Dt8KKwobDvMOCLcOjVsK2KcOrXHUwMDA0XHUwMDFlZFxcZsK3w6TCssKXL13DiWtDwopFVcKnwoxLXHUwMDAzw6zCpsKoXHUwMDAyXHUwMDFjdMO/NsKeRShcdTAwMTPCnF9Xw4bDul9cdTAwMDE9TVx1MDAxNlxcXFx9T8Ocw75DVlx1MDAxZMKNdj1AJFsww4nChMOPwptwPX3DvsOoXHUwMDBlwrzDk1xcYsKAwozCscKyf0vDg8KSaMKjOXMqVMKSwqN/w4JcdTAwMTPDrcK/PFx1MDAxZcK3woXDj1x1MDAxMMKpXFxcXMKVMVx1MDAxZMOicyhPXHUwMDA1UMK7wobCvMKHw6pcXHZcdTAwMTdcdTAwMWHCrcOmwodcdTAwMDF+w6gzw6RbTk/DmsOaw6NgNcOAw4lKZ3PCmFx1MDAxNVbCh1x1MDAxMlx1MDAwZcKaXHUwMDBmwqt6wpjDvMOHOnk2XFxiwpNwJsKLKcK5w51aw4t7IcKpwrbDqVxcXFzCrDh8wq1cdTAwMTlOYcOtw5/CnCvCi0VcdTAwMDNZwq09fTDDmnVBVsKHXFxmLlx1MDAwM8KTw5R1VsKVw7xMwqvDsMKdVil5TVFcdTAwMDPCmHXChlrDvHhcdTAwMTPCu0xcdTAwMTXCvVx1MDAxNlUyw7ZcdTAwMWbDomfDok5cdTAwMGbCrCA1w4DDtsK6w4J4wqt6Z8K9TMOEXHUwMDEzwrRHTsK8w6TDscOBdjZ7WlxcXCLDoXtcdTAwMWIpwrs+woPCgMKHPMO7w5R0wpYqXFxmT8Kvw5PCmCYpXFxiXHUwMDFhwrnDu1x1MDAwNsOQwolcXGbDusKBaVx1MDAwMsKAckVcdTAwMWHDlycpw7A5aMOzw47DjjZcdTAwMDZNwoZ4w4tQSsKVXHUwMDE0JsO1w45iwrB5w4xBwobClW/ClHF9JynCjMOCXFxcIlx1MDAxZsOrdMKvKC0ywrrDtVxcXFzCnj1KwotrwoLDuD19XHUwMDExVXfClFcrXHUwMDFlKmPCrcKIw6ZrQsKWf3LCgGlMXHUwMDE4aFx1MDAxOEhbXHUwMDAyTl9Tw7E0wp/DuFx1MDAwNFx1MDAxMFR6w7jCusKxw4NuwoxcXFwiwrtNw5LDkFxcdsKpw5tPTcKYw53DssKZw5rChT1KwqltXHUwMDFjSVvCrT1KXHUwMDE1KcOCa8KKw6TCm8KIwoNcXGZAwqtcdTAwMWbDqMOiwrpWw7zCmcKuw4gxwoPDrivClMKdfDXDrcOcJ8KOQWzDvFx1MDAwZSspw6JcdTAwMWROw6zCuMOFXHUwMDFjKsKPTTt4XHUwMDA2wpbCj0xWXHUwMDEzNsKJw6PCpsKMXHUwMDFmwrXCkUdEwrtTV1x1MDAwNkDDsFx1MDAxYcOtelx1MDAwNkrDssKRw4TDk8K7wox0eMKsw7zDrCx0wo7Dk0DCmEzDg8KiVGnDg8KhbsOQVVx1MDAxY8KmOcO+dcOMw7PCisODT23CklEhwrLCqcK9w4PDm8KGfsOzKcO4UMKsJ8O7c2ZEdlVawr7ClsK0ZsKvJlpMacOiwpPCoClAw7ZAw6FTXFxmW2NcdTAwMWLDllHCojpcdTAwMDZ0XHUwMDA2XHUwMDE3XHUwMDA2wrrCvWJNwoZcXFxcwoY2VMKhbkRcdTAwMWUpXHUwMDAzXHUwMDA0RGDDmU9cdTAwMTc2fsOUZ8KKw63CusOkfFxcXFzDiDfCkz19wqlew6HCsGZhw4vCtFx1MDAxNkdMwqgzw7ZcdTAwMTgkQcKSw6/Dt33Cq8KTPlx1MDAwZcOPwrzCik9cdTAwMWJMPMOKRiTChsOQPUrCm3PDglHCgyHCqsO1PU3CqUlRw4hDXFxmNCVcdTAwMTk9TU5cdTAwMTEpwrlRwopQw7spwqPCrMOFw4tcdTAwMWLDqXk2XHUwMDBmw7BwamnDr0hswqs9SsOdw4jCvsOjcsOFwpZcdTAwMDYsPUBgQVpcdTAwMWbDiVgww7bDs0zCp8OYwqnCu8OBwoYpwqzDliNKw6N2Jncpw6RQXHUwMDA2w47CgcOCw4NrJMO1XHUwMDA2woROKcKkRVx1MDAwNjTDtVx1MDAwZTLCvF0xw5lcXFxcw44rZ39fXFxmM049fUvCisOkw4BcdTAwMTnDs8Kdwo5cdTAwMDFHQsO4I1x1MDAxOcOmLlNcdTAwMThOXHUwMDE2XHUwMDAxw6pjw7BjMTrDosOvw67ChcKmw4VUwpzDpVx1MDAwZsK8XHUwMDEww67CrSbCrF8gw7bDl8OyVDdcdTAwMDZbw6HDtMOIw7/CgMO8w5XDkj5zw4jCqsKTwq5cdTAwMTDDhsOmwrLCvsOuwpXCjsKaPU3CmVxcZsKHP8OzXHUwMDE4woBcdTAwMDbDgkjCnsKxYsO5w47Ctlx1MDAxNDo6w5/CosKcw77DqcKHw43DrkfChjxcXFxcU8Kgw6HCuys1wrPDtS/CgMOCS8OXO8K+N2bDj8OuwroxwrkvcsOAfMK9McKtKzZYw7zChyvDoUFcdTAwMTNUPX1xUUPCs07DqcOKwod/fcKxw4FfwrdAw5lcXGbDuFx1MDAxZsKTw6vCiXEwwoXDqzUvw4VtwrtyfMKTwph9w5hKPMKSw67Clz19MsKww43CosOlWcOiLHXDn8K0LcKkw7I2aDxcdTAwMWQvVy1cdTAwMDIzwozDkUZhw5o5w59SU8OPXFxcInvCm1x1MDAxNmnDojDDhktILsKGwo5cXGbCp07Dl3JPw7jCj1x1MDAxOVhCV8O4XHUwMDA2PUDDj8KcworChDrDqsOCfH1ywrkkaTDDiVx1MDAwMnUuXHUwMDEzwrvCnSlcdTAwMTbCtSnCkcO4w7LCtnrDmsOcw6/Cg0vDtVx1MDAxZcOtwpBzKcKGwq/ChsK4wowpXcKxbcKmw63DqVx1MDAwN1x1MDAwNMOOw4o9TVXDj1Q5wr3DgMKrwo3DjsO5bcKQw5XCultdwpgjdsKYwrg+QcKzL8OHXHUwMDBlwqnCpSDCk8Kcw6pNwoBSUsO5LMKaSjVyw5TDhsKDw4sxw5/DpMOjQFx1MDAxM8K0wrpnZcOvXHUwMDE4LHLDgl1bL8OoXcOLSXDCoHpPwqhkw5xwNmFcdTAwMWLDtMOhPMO4RMOswoPDglTCjcKYbkDCmS7CuMKrXHUwMDA1O8OeXHUwMDAyQsO4wojCqsOdUCnDuMKsV1FcdTAwMGY9TVhcdTAwMDdzwpBcdTAwMDZtw79vTMKka35cdTAwMTBEbsKew45cdTAwMWTCl1HDh8KNXHUwMDEwcMOow4bDt1x1MDAwNsOjwq9cdTAwMTdyUcO6w7Z+NVBQbcOhwrfDksOOY1x1MDAxZcOyw67DpcOGwrNhwoZcXHbCrMOKw680U0jCjsKwwrPCrMOUa8KOXHUwMDEyfMOcw4Ytwr51P8KedWbDsDZcdTAwMTRPXHUwMDEzXFxmwq0owqzCnMKrXFxcXMODXHUwMDA1w6LCrcK5wrRgwq9ZOVLDmzdcdTAwMDJWwoxCwpotwoA9SlRcXGbCvFpeMX10w6tcdTAwMDbDq8O+wrBiwqbDisOvwptQwrvDjjphd8OAPU1KS8OHwo7DqFNDWy9RMXY1PUomwp5cdTAwMWPDkGBcdTAwMTDCoMKQw5o6Vn5+w6DCijPCvsOFwoU7OUd7QGLCqsKiwofCncKFXHUwMDFhw7nCmzc/wpLDgMODwr/CoiVWXFxmW8OdTVDCrcOXw4NNYcK1woHDtMO+OGRZPUDCqD/CjsOlflx1MDAxNcOXwrpZY0x7wpXDm0vCkcKPwpBXw6DCtU7DhcODwrx4w4pQJsOeXHUwMDEww4DDmFrCn8K+woLCosK6VC7DkcKCw4FdLmxcdTAwMDbDpz1Kw649fVx1MDAxOcOxU3FcdTAwMTDCvWpNMTAvXHUwMDAzw5HCvWV8T8Kkw7hHa1x1MDAwNTjDqMKEw7gsPU3CoHgvwrbCvUfCocOiI8Ouw67Ds1EtQ8OLw7XDtkZ3w5crSsKgw5Anw6rCsXZGY8KKw6DChcK1wofCpj1KXHUwMDAzPX1rUkU2w6/CtMOjc8Okw4XDoMKMXHUwMDAxw4g/w67DkirCq8KVw7l4w6YvNFxcdkXDoiDDrsKJw7rDqsO0wrU9fTtlw5nDok/Cu8OuYFfCjnnCnMKOdcOcw7FHw4M8w53Cv2XCrMKMwqpAcsKzIVx1MDAwNMOAXHUwMDAyK8OGdzI2Q1LDjzRcdTAwMTkve8K1T8KVwo9cdTAwMTRqw7Z6McKyXsOMw4vClMKqMlDCmFx1MDAxY8K+UMKmwoN4XFxcXMO9XHUwMDFiw43DtkbDr31nw7LDjnFcXFxcwoFrw6bDr8OWS3LDh8Oxw4NyXFxmwq85csKJSW7DjHPDpsKjOsORUcOIwog1w5diw4N6dcO6XHUwMDFkwpl3aVxcXFzDuMO4d1dQw63CmcO6NMKrwrMrw61Qw64mO1x1MDAxOcOnwpPDsj9+XHUwMDE2wqc9TcOEc1x1MDAxYsOQw6PDrsO8wqzDq8KJQsKtw7vCrsO0NcOATH5fXFxmw7AuKMOxw7pMXHUwMDA1wqXCnFx1MDAxNVx1MDAxY8Kaw6HCvEZtwqlqK8KMw449SjUsw5JqLidjwr3Cs8OCwoXDhnUsw4RzKkpcdTAwMGbCpWtUwq1cdTAwMTbChsO2XHUwMDEzPFx1MDAxYlx1MDAwN8K8f25cXHTDqnLCtcOCwofCjl9Kw4xCwop+asKZw5ByXFxmRUpIwolcdTAwMDLCuMK5bUzDoUfDnEteXHUwMDFlw65nbcOUSMOaw5PDrsKYwpt3XHUwMDFiQULDgjxZw4hGa8K6wr/Dk0bCuytawobCuFx1MDAwZcK8YsKPS8OBXHUwMDFhT8Ozw4/CoklCw5zCpy5bXHUwMDFkc8OhXHUwMDAxw4PChVx1MDAwMX/Dplx1MDAwNU5Ow4s1IcK6O0BVXXHDjMKDYHw/wqhMXFxmwplcXGbDhlkpw4hMXFxiXHUwMDA0wqjDunbCqlx1MDAxMMOrf8KFesKmw73CqMOaXFx2V1x1MDAxZSRrccOXw7XDq3VZfTjDi8KHJ8OqwrhcdTAwMDHCsULDk8KobkFrw79qSTDCrkXCvjNqwr8pw4/CjsKYa8OAwoLDv8KvXjJSa0TCoMOQw6BcdTAwMGbDmsKZwr/Dk8KXQ1x1MDAwNsKXb1x1MDAwNjJcdTAwMWFWw4bCrE7DrcOjwp9JwpZcXHbDpkbDhibCscKXXFxcXFpxXHUwMDEwbiY9fTg+d8OBXHUwMDFhRmrCl00ww583K1/CmsOfacKOOcOAwrRcdTAwMTJZwoAsw5LCtE4yw6FNb1FzwprCpVx1MDAwMyvCmsO3w5bDr1x1MDAxNcODdGYsw4ZwwrIxTjp7W0N8w4PCu8OzXHUwMDEyw4pcdTAwMTLDisOgw45gwq86ZHxPwrpywoHDmsOuX1xcdsO1w7jDvsKww5U3Tlx1MDAwNWbDrUXDlktqdsOBYlx1MDAwNlx1MDAwZSzDt1PDsjDDisO9OyZ6wqrCl1gzwoXDmHw9TcKELMOywrzDk8K3w4Mtw7vCgHJcdTAwMTJJYcKXw7HDsn7DgjhKwoLDgcO2w4fCmVxcXFxcdTAwMWQ9SsKaK33DjcOiwqzCrVhcdTAwMTTDhMOlJFx1MDAxZsO3XHUwMDE2wr9cdTAwMWXDjUxPNcOHw4PDpCTDq8KKesODw4PDkcKiwoE+QsOkS8KUXFx2b8KQN8KaM8K6wrdcdTAwMTRiZXvDhjjDicOOwo3CmVx1MDAxNHPDijXCmGt3fVx1MDAwMnsswrjCssKkN15cdTAwMWZUYVx1MDAxNTHCu8KMIMOQw5hcdTAwMGZcdTAwMTB4TMKdQcKbacKWSsKyw7LDvm/Cjlx1MDAwNMK5wrZvw4IgXcOdTMKIN8Kqw6HDncOTPX1cdTAwMDZcdTAwMTTCjlx1MDAxNHx7wpjCmDnCjS1cdTAwMWFcXFxcwqVpRE43XHUwMDAxw5Zye8OHaj1AwpDCrWpcdTAwMTggw5DCrcOwX8ODZCXDu1/Dv1x1MDAxYT5cdTAwMDZ+LSRsSEg+wph6OFvCs1xcZlx1MDAxMsKkwonDrsOrw7vCtGbCj3nDqMOQw4VjwrvDjsOyXHUwMDE1SjvCosKmJFI9SjzDo1jDtSfCmcKUeVx1MDAxZcOywpNkw5HCnsKaw6NAPClcXHTDjsOKXFxcXFx1MDAxZlrDn1TCsSxcdTAwMWVNw4NOwrTClHXDtMKXd8Oew7nDvsKkwrYrw74pLsKFwozCoTVbwrAowqHCr3HDjCc9QG7DkcKPJ25cdTAwMGUvbsK1w6M1QHrCiyhZXHUwMDEyw6/CmHTDgjxsw5pcdTAwMTkqwpwxwoc2XcOBW8KqOnB4TyQpw4lEKsOEVXo4w4LCtMKMTT1AdcO6LEV9McKaOcKaNGvDhWQmw5HCh03CvcOvKMOPN2wuwp1xwrhdwqHCvsOrwoHDjS1cdTAwMTDDjMOubVx1MDAxZFxcdMOoMcKTw7lcdTAwMGZ2R8KyXFxmLMOCalx1MDAxOWJ9wrVcdTAwMDV7w4ZFP003PX1hOcKtw55cdTAwMDPDusKJJlx1MDAxMcO6S8Ohw60wXHUwMDBmwobCnU/CgMKBXHUwMDFiw5zDvFxcZsOTwpPCjkPClcO4wqDDvMKqw6fChMO3wovDjcKAMsKqwr9cdTAwMDJZw7rCj0zCl0VGw4PDgkR1wrjDqsK5wpMxcMK0ZcKSwq0wVkJSW3h2XHUwMDFmw6JoVsKXXHUwMDE0eFYwXVx1MDAxMkDCrcKHw4w5WDFcdTAwMTJcXGZzVi7ChcKMT8OEw6TCu2hYwpFPPMK5XFxcXF7DoFx1MDAwNmhcdTAwMDIpNMO0XHUwMDAzSMOOwr/DkTF0L8OBwrspwrHDgcK1YcK4TVx1MDAxMDNDUcOYPsKrw4HCs1x1MDAwMsKFNcOOKcO9wq7Cm1x1MDAwN1tcXGZLPU1QWTp5PX3DosK5worDmXHDm3s4bTHCijDCvMKjwpxcdTAwMDbCk8KzXHUwMDFicTA9QMOjXHUwMDA3wpRjXFx0VENJPU1wwoTDv8KKwr5AXHUwMDE4XFx2UFprUW1mwp1ww7xcXHY9SkDCklx1MDAwZcKgVMKwwrDCt25lwpzChsKtR8OEacO2wr3DnMOLwqbDlT4ue1Q0XHUwMDFjXFxcXDojWcOPw67DgcK/PU1Tw70+eXjChHDCgMKrw4DCvGl8w5vDlMKOf3N0w7TCuzRcdTAwMDFmwrTCvMKtw4jDlTY6wpZcdTAwMTAzXHUwMDA1wqN0wrIlw40lXHUwMDEyaMOTw6l8wqnDj8KlXFx2RkbDrDlcdTAwMTPDqcOawpEofS/Dq2PChMK0w741PjdBTjkmIcKpXHUwMDFie8OJPsKGwqttwpzDhWJfXHUwMDFjw5nCucKwLil0XHUwMDFmdHMhIHIhw7LDsibCu1x1MDAxNyhNXHUwMDAxT1HDlVx1MDAxYVx1MDAxNcOpWVx1MDAxOMKtLVx1MDAxOMKYXHUwMDFjwqjCvC/Com40SFxcXCLCoS0hcMOyRsO2c0/Do0xDwr1cdTAwMTTCvSglQVx1MDAxY3BYwrLDnVx1MDAwNFEvwqMnJcKBcMOQwoHDoMOhccOYcXggwrlsIcOJWEhWaytTXHUwMDFhwo5cdTAwMGXCj1LCk2/Cozo9TUjDqMKKwrvDlCdcdTAwMThcdTAwMDVBwoUlwqZSX1TDk1nCq8KAJ8OlwrvDnMKbwpLCuMOmXHUwMDAxUXHDr3rCu8Knw7FSR8OUw5xcdTAwMTHDjlx1MDAxOFx1MDAwN8O6wrnCpzklfMOSw5fCp8KZJMKsXHUwMDEzwrpIL8OoP03DuHtcdTAwMTfCo1xcdm9Jw5TCvMOUXHUwMDEzw53Djlx1MDAwNsKSw5RhwoLDtMO/wpzDsjpvYsONeHdcdTAwMTNdw4/CkSHDl1x1MDAxN1t6V1x1MDAxZlxcXCLDsVx1MDAwM15Tw481aSXClsKKPUDDs8K3w6jDh8Knw6/DvjtcdTAwMTRcdTAwMTZcXHRcdTAwMTHDp1xcXFzDnFxcXFzChMO6d8Kuw6nCgcO2w6NdXFx0wqrCmcOEwr5oT3VnXHUwMDE3w6VcdTAwMDdcdTAwMDHDvVx1MDAxMXVvfVx1MDAxY8K6acKvw6jChcKnwot8eMKcLSNcdTAwMTE/KcOPIUx0IMOWXlx1MDAxZsOfXHUwMDE5bVxcdMOBaFN0wrnDnCxcdTAwMTRcdTAwMTZlXHUwMDA0w6HDnsKZwpnDiTXCj3N5w4DClMOBwoDCumdMJVx1MDAxOShPQ8OTwpHDvsOqPX3DjSpcdTAwMDYkXHUwMDAzIcOYXHUwMDE5woPCiTEmWTfDncOXwr3Dk8KXw75hdHLDgcO9d1x1MDAxZSMpwpJsXcOfw5dhwodUw5/DksKqdFx1MDAxMsOlXHUwMDFicUvCqUpcdTAwMWbCslx1MDAwNCBdacOlw5F5d1x1MDAxNFx1MDAwN1x1MDAwMcOBU8KXwqdpw49cdTAwMTDCnsKYSMOpw5HDmXjDpD1Kw53ChlxcXCLDhMOoVcO8w71ow5EuV1x1MDAxN2VZZ8Olw73CkFx1MDAxYcO0w6h0XHUwMDEzwq7DmcOlJMKZXHUwMDE4wr3Cv8KYJ2jDqybCksKJwrzDviTCiVXDnsKZXHUwMDFlX8O8XHUwMDE1w6U5MlLDvcOpUGl3XFxiw4NcdTAwMDZfY8KPw5zDt8KOw5Bzw4zCs8OBM1xcdFx1MDAwZcOYXHUwMDFiZD1NbsKNwp09TcKxcDXCtibCtmhDWF1cdTAwMWVcXFxcw6bClVrDr8KqwpnDmsKEXFx0wogpwqrDiMOBXFxiM8KHwplcdTAwMDdtZCfCnz1AwpPDlcKUwoHCksOnw7tGw4vDo3Ftf03ChSfCrMOEw5vChMOoXHUwMDE0Yz/Cl8K/wo5cdTAwMGbCh3TDqT/Cpz7DlS9BXFxcIsKmKHpcXGJWwq/CnVx1MDAxY3xcdTAwMWPCtsKGw5tcdTAwMTZow4PCocO8XHUwMDEww7zDu3zCtVx1MDAxMnV6bMOhw6hcdTAwMTbDqcKFwqRJIcKSIcK2XFxcIl3DnSV+XHUwMDAxXFx0XFx0wojDqTXCqUckI1x1MDAxZMKxw7HCucOcXHUwMDE5UcOpU8KmRSfCn1x1MDAxZsOBwqHDh8KIw4fCnWhpJVx1MDAwZVx1MDAxYsKTw7vDscO4OcONaFx1MDAxNsKlw5klwqhcdTAwMDTDpcO4w6FcdTAwMWLCmcKZw6ZDJFx1MDAxMMO2XHUwMDE1wqpcdTAwMDFcdTAwMTHCiDfCqcO/KFxcXFwjXHUwMDBmw7lBXHUwMDFkwohcdTAwMDLDqGIhwqbDvMKdXHUwMDFmXHUwMDExXHUwMDE2w53DhsKRw4DDuUhpwpfCokQpw74gXHUwMDEzw7nCuMKdRzdHw69Hwo1lw4I4XHUwMDA1OFx1MDAxNzjCqMKxfjHDv8ObacKzNFx1MDAxY8KaWj1AfE7CmsOOw7jCmcKIesOAP0k7TsKew59hw797e8OKw6hmw6fCoyhcXFwiXHUwMDE4d1VcdTAwMTF/w4F4c8K5SWVUXHUwMDAyw7HDvcOPw4nDn8ODwrvDmMOQw5RMecKAwrRkUnl7UcKrXHUwMDA0wqrDssOJwrbDhsOYZjJFfsKHw7vDunjDk1x1MDAxMcOBwrTDp8OIXFxcXCfDgcObJVx1MDAxZsO9NMKAcFx1MDAxOMOAXHUwMDFiwr0pw5fDlMKWXHUwMDA3wpUgecOodFx1MDAwNGBkwrTCp8OAaDBcdTAwMDfCh8KmwqExX8KyVsOOwpPDo0ltMSckXHUwMDE4aCbDpWzDmVx1MDAxZcKiwq1IwqfDhcOrw7zDqcOPw5J6K1x1MDAxOcOhwqDDqcKYwqPChcOIw6hew5l1wp3CjMOBwrZcdTAwMWXCmcKlwqdcdTAwMTTCtcKDwqrCvsO4wokhKMKpf8OOJcOeflx1MDAxN8OkN8KuYMOcaVx1MDAxNsOxw7TDusKpw6fCp1x1MDAwZsKkJCjCrsKiw7rDqV5QQifDjD7CvVx1MDAwZcKOPmjDkFx1MDAxZSkwXHUwMDFmwrzDnj5cdTAwMTnCp25cdTAwMWHDkUknw71cXGJTw5LChWVcdTAwMTV6w4fCq1xcdlx1MDAxOS/DnGk0w57CqcKhXHUwMDE1PsKmw4HDgChHwpFSXHUwMDFkfU/DviV1w4l2Q2LCisOXTcKewol1U1x1MDAwM1XDg8KSXHUwMDFmwqJcdTAwMWVcdTAwMTlcdTAwMTXDnUIjd8ONw7XCoVx1MDAxNsOZw5nDhFxcXFzCiy3DiMKVfMOtw45pw7UoXHUwMDE0QSXDhVx1MDAxOMO/SMKMw7xHwpEhwoc9QMOwwonDn8Kxw5DDpMK1XHUwMDA3ScKoXHUwMDE1YX9cdTAwMTB3w4LDlmrChMKIwrRcXGZcdTAwMWLDscKsXFxmfcO4asK/alx1MDAwZXnDu8OsZWbDncKkw7fCq8KVWX52XHUwMDA3bVHDgFlcXHTCp1x1MDAxYsOTwrDDp1xcdMOiU8KfRcK4wobCqcOPw5JcdTAwMTE8w4Z6w6bColx1MDAxMcKvUSQnwrBuecOTwofCpT1KXHUwMDE0fU9cdTAwMTdrw41Qd8KFwqc9Slx1MDAxNDU/w6fCqGjDu8KjXHUwMDFkw6DDh8Kjw5bDi8O1wrZ4WMKIw6LCt8KXXHUwMDAxYMKbQ8ODwoTDpsKmJVx1MDAwZlx1MDAxMcKEcMK4w6jCvcO0w4BcdTAwMTdiw73Ci2bCisKCbMOzw6bDt8Oxw5jDqcO+w7pFQmJowqkow4DCvTlcdTAwMWXDt8ODwoszwq81w6HDiMOkw5HCkVx1MDAxMDtCwr1lwqlcdTAwMWTDg1HChFx1MDAxMMOYw6szLzXCocOGwqPDlsKTXHUwMDBlXFxmScKHw5rCilx1MDAwNVx1MDAwM3FcdTAwMDRQw7jCqMKbL8K1PUpHw6TCkMOYw4sjXzcxWMKewpJDMHB3VMKFw6Qnw75nwqfDnWtoXFx2L1XDhMOYZl9aIcK3w7XDlsOUXFx0wp89TcOTw5DCqMKafFx1MDAxOFx1MDAxZX/CpVhmWsKhOsK4QmnDj8KoXHUwMDE5w7/DgWRwwpgzwo/DnWBcdTAwMTjDqSjDvFx1MDAwMlx1MDAwNMKNwobCi3/DrcOoNcOZw5/CtjDDilvCvVx1MDAxMcKXwpbCo8KWPUpGw4Rkw43CiynDg2XCmcK2w4bCsFDCv1dcXHTCnVx1MDAxOFxcdnFdwqVcXHZcdTAwMWFcdTAwMWJPXHUwMDFmw6XChMOJRDfCtMO0w4PDo8KUJcKzw6BcdTAwMTHDpMOwLU3DkFlcdTAwMDXCnFx1MDAxNlx1MDAxY3VVwpHDicKyw57DrMO/wqVZw6g0PX1cdTAwMWHCo1x1MDAwZVx1MDAxZMKDXFx2w50sw4lcdTAwMDHDjcOKLXHDqyx3wqheOcOrXHUwMDAzwpE0XFxmw7lMwq/DrWZ1XFxcIsKyXHUwMDE5T3HCslx1MDAxMcOswoXDisKiwrdZaCV2w4tzwovDl8OswpfDosKZX8KZZcKGwrXDgMKmOlk/w5hYwoFcdTAwMTQ+wrbCrlx1MDAxNVxcZsOew7LCpcKYVVx1MDAwNnpGw4xyXFxiwpzDiMKlwpw7wqYmPlJ/woPCv1AvwpnDqGHDiWZvw4g9QMKBw4LDjsOifTtcdTAwMWLDhD7DpMKiw73DomE/w6snwqbDj8KfdMKFXFxcIsK1PUrCp8OVS0HCssOhwoDCi8K6wqw1WcOJw5HDrcOnY8OJJcOWwrA9TcO9w7TCuMO0w73Conk9SsKyw6bDoTFcXGJtU0Z8wobDk8OiwrzCmVbDgjnCoSHDqsOjwpE0TT/DmlxcZjXDr0AoeSjCpsOyXHUwMDAxwpfCr1x1MDAxZMKawpDCusKsw5HCisOdSsKueVx1MDAxY1x1MDAxOcOswoUuXHUwMDExw7htKMKAVMOAVcKwXHUwMDFhXyPDuT7CkMOqXHUwMDE5UFxcXCLCtsKxJsKnfGYqIyfCgWB8wrhLwrRBPsKBXHUwMDFkwr49Slx1MDAwMUPCoiHCi8OyIzbCryd0YT4jw6ZjJlLDqMOCacOAw6bCuzTCm3TDl3TCuS/Dh8KsSMKvMCNQM8KhwrBVwoNVXHUwMDAzUsKyXFxcIsOILHzDjMKRNFx1MDAwNcKjScKiwqXCvlx1MDAwMVNfw7JRXHUwMDFkw60ueWLDmMOWwrDCplxcYjzChsKqITA1OFx1MDAxYVFrwqhpVUbCrUZ3woA4e8KoVcOpQVx1MDAxOMOGLcOjZsOtXHUwMDFiw43CgMKbwrbCvDVcdTAwMWFbwoI6VsOawq7DpsOGwoFSLCjCg1VDNUhcdTAwMWPCn8Kiwr3DomYlU1LCq1x1MDAwNsKlw4p+b2rCskEsw7nDuVxcdsKha1x1MDAwM8ORK1x1MDAxMcKZwp1Pw5/Crlx1MDAwNmLDq1x1MDAwM8OxwqzDh8K0aVxcdsOnXHUwMDA1S3fCknDCq2XDrVxcdkjCm0jDuFx1MDAxYVxcYlx1MDAxY1xcdMKsXHUwMDFlXsKrwpnDm8O0f8O0w7E+JMO1w7l6wpJcXHbCmVxcdlx1MDAxMVx1MDAxY8OZwq3CvlxcYlx1MDAxY8OxVMKYwqvCnsK3L1x1MDAwMcKrTcO7XHUwMDFhXHUwMDA2NsKvwoUlw4B+wo/DsMK5Q2dcXFxcfmJcdTAwMDLDvcOtwp/CqsOdw43Dp8OHw5fDn8OPw6MzfsOSwqbCk8OEXHUwMDE0JVx1MDAxYifDrVx1MDAwNcORIVjDncKlwqDDmcKJZMOdwqZ0dHbCgsK6IWoxNW13N8Kfb8KrVsOfwqk9QMOGT8O1w4HDmMKGw6hbXFx0wqlcdTAwMWU9Slx1MDAwMj1KXHUwMDBlwpvDm8OaXFxmw5rDqD1KX8OXdMKUwrFOaXV1wp11XHUwMDFhwpLDg8KxOcObRsKSw4jDiTxCOsOaUU9Kw6pcdTAwMDbCoXZqwq7CjyhcdTAwMDY/w53DocKBSWnCnMOhw5jDpMKVXHUwMDA1w7tcdTAwMDPCk1PDsysrJVx1MDAxOElnw6QnJVx1MDAwNz1Nw7HDocKpacKoJsOrw5bDviRNcVx1MDAxNVx1MDAxYzlcdTAwMDHDmcOCwoPCp1x1MDAxOcOywrtcdTAwMTfDhVx1MDAxOFx1MDAxN8OSw4knw6dcdTAwMWLDssO7XHUwMDE3w4VcdTAwMThow6Npw5XCpyjCsyVcdTAwMDXDqMO5w4fCg8OpwqdcdTAwMDXDlsKxOcKQwpnCpMKaXHUwMDEzwphcdTAwMDfDoMKNacK5w7jDuGkkPUpcdTAwMTLDllx1MDAwZVx1MDAwZcOEXHUwMDBlPlx1MDAxZMKqwqpcdTAwMGXCqsKXw4FJXHUwMDA3XFx0w6DCn8O/w7bDnsOqd2nCocO+w7fDmMOVw6kpworCoFxcdFxcdFxcYnnDtMO8worCk1x1MDAxZidcdTAwMTfDo8KZS2hcdTAwMTLCmEVWw61HJmY/w65RMWdJOMK5woA9SjhcXGJJwrLCgE0xw6llwqBOQsO1wrrCpWhew6/Cg8OzbVx1MDAxNlx1MDAwNHNtw6tRT1pcdTAwMTPDkMO1V1x1MDAwZcOkwqZJw7DDlcOuwp0xw5HDrFx1MDAxZsKsSMK7wq03S1x1MDAxMMKoRT1KJXBvwrLCrcKRPX1GwoZWOcKcIMOEMDHChcOcbWbDg8OeRcKnwqfCqXTCp1x1MDAwNy3CvMKhcjZowrRcdTAwMTQww418OMKywqbDqlxcYlxcZmjCgcOrw5Jaw49cXFwiwr7CkCnCjlx1MDAwNMODcXtjwqbCtFx1MDAxNC5tw7DCg8Kzw4xwK8KfLCNSfcO+LErCo0fClcOhS8KNwrxcdTAwMWTDkVlcXGLDmsOZw49cdTAwMTfDs8KRT2dlIUtcXHbCs2PDjMKjwpXCoEbDqSZcdTAwMWHCrTTDvsK/w6w7w5vCvVTCkMOYXHUwMDAywqRcdTAwMWVcdTAwMTTDvXjDqMOAw481REPDgcKHW8Khd31cdTAwMWTDv3FJw79ew5fChjHCuULDgXvChMOdwpbDvcK7w5VHw4fCpj99woEpw5pcXFwiw4bDlMKjN3fDt8KBSMKoesO6w5zCnFx1MDAxZkfDg8OCwoVbw5XCqFx1MDAwNSjCvVx1MDAwMVx1MDAxOVXDlMOCw6XDjTt7w4PCr8O9w4HClmfCpCPDqzF/N311wrnCu1vDg8KvXcKBXHUwMDE3YsKgXHUwMDBmXFx2ccKrw4vCrVx1MDAwMcO6wptcdTAwMTPDr8Ofw7VgSWLCnVx1MDAxZFx1MDAwM0Fjf8OdKFxcYsOtwoxddFx1MDAxNcKAYUhnXFx0KH7DisKLXHUwMDA2w7k9fcKYUsOTwofDu8KiXHUwMDE2w7wnwqHCtERwJ2fCrcOwUEHCgVlcdTAwMDPCplx1MDAxMiZcdTAwMDfDocKUZEAnZ2zCjVHCvz1AasKow5lmKMOSw5ZcdTAwMTBiMjdFw4HCu8KBw6fCpsOxwrPClcK5ZMOre8KRXHUwMDE1O15gw5/DksKYw7/CuFx1MDAxMMOVwrlpw5TClMKCZMKlOMK5dFnDlsKIw6BcdTAwMWZcdTAwMTLDjyVJPsO/wrZcdTAwMDbCrMOsUMOOf8O2wobDpFx1MDAxM8O6w69xSX82w4fDgsK7M8Kjf1x1MDAxZFx1MDAxNMOhR2LDvyBcdTAwMGXCvcKsw5zDm01dwozDrMKOw7smw5/DpXnDoGgjw5bCkGbCqkNDw4V7fsOnwppcdTAwMDdYIMO0w60hw7REw4DCuMOsXFx2W8ODT8OdwoBcdTAwMTfCrlx1MDAxZWlTw5TDhWLCpDnCucOzUsOHw5/ClMOxXHUwMDFiVcK5aFLDk8ODYjY0NnnDh1xcXFzCp1PCvilcXHZxX8KXNcKlw5k7PU3DncO1wpFcdTAwMDHCmWnCm8OXw419a8OvXHUwMDA2w69pZlPCmSRMwrrDsVx1MDAxZsK4w7l0w5TCoMKoS8K7wpvCvVVcdTAwMTXDgMKXZsKmXHUwMDE3XHUwMDEzQV9nw5XCq8KSwoLClnR7XHUwMDFmwqzCn8OlXHUwMDFiw5dcdTAwMDFEUC3CpsOtwr01wpBWwojDqVx1MDAxNVxcXCLCr1x1MDAwNcO5w6nDlMOFNjZCw4XChHpbwpVcdTAwMTPDsMOnTsKpw5RweMOsXFx2w7vCvcK0PUrCsGfCusKIw5HCtMOAwq/CtVpOXFxcXEvDpcOSwpRcdTAwMThcdTAwMTjCnSFpwrBSwpEzKGnCp0DDrVF1wopWwoLDisOSw47DokTDlMOoeMOrU1x1MDAxOG3DuMOJPMOWwrB0w7RCaMKFXFxcIsONfsKgw5PClkDDvlQ9QFRAw6xnw7AsQcKSMMOywp1cXGJ6wqdmXHUwMDBlwpEzeFLCv1XDiDzDglLCiMKwUSjDj3fDlGJcdTAwMWLDkcKvw7nClMOaRMKvwqxJdMOIw7pcdTAwMWVSU8K8wrTCkVbDpsK5fmZJwqJXesKnN8KBRcOOZMKxXFx0w6zCiTfCmU9cdTAwMTPCmEDChijDicKew6BcdTAwMWFXwr9ZbcKYcihmL2kjw4fCulxcdFx1MDAwMcKaw7ktw68xwrTDhS/DiT7CoTVcXFxcXsOBwpPCpj1KXHUwMDFiwr/DuMOrRcO0P8OfP8OHwr9gNXJcdTAwMGZYwqw0w7rCgsK6w7XDqcORXFx2w5BTw5lowobCl19Zdlx1MDAxYUTDtMK7w4pSXFxmwr1cdTAwMTRcdTAwMDTCgmrDmMO5XFx2w6VSMMKdw4ZcXFwiWcKBw67DhiPCoWZzw59AXFxiwo4swo9OXHUwMDBmw7PCrMOmwqI0wrxLwrlOw6lcdTAwMGbCtMOIwqxnw7TCpcK+wqFUw4TDqmdcdTAwMGXClFrDhlnCrsK+c1x1MDAwNFx1MDAwZSjCjsOoXFxcXFx1MDAxYcOZwoDCu8Kaw5c6XFxieXx+fE5cdTAwMTlAwqleI8OcVMOHVHB0UcK+w57DiztjL8O5w6TCqmYyXHUwMDExw43DijbDsHrCjC13wo3Ct8K/wrTDnFTDo3QzwrTCi8KsW3TDj3TDjnPDs8KvXFxcXMK6w5VXwqZPw7/DlcO0OcKqw5HCjMOYwpFrw7QxSsKHbE4xacOLJsOWw7DClcOrZ8OPw4fCtMKuKcK/esK8WsKSw5TDssKxXHUwMDBlw6zDhcKpwoVcdTAwMWbDoMKUacKSw7jClMKrwp3DuHTDvMK0w7xcdTAwMWF3XHUwMDBlRi/CmVx1MDAwMyxcdTAwMTPCoWzCk3Ndwp0qYkQwecK5wqrDuSw9SkzDu8OBw6/CmsOJwrjDhMOnNMKjYcKjRcOzw6HCglx1MDAxOFx1MDAwZcKFwqbCoF1mw4k2KcKZMDPDpMOqwr1Nw6JRwoHCncOJVnLCn8KwXHUwMDE0SsO/ecK0RHTCrlxcdMOrXHUwMDA2wqdOwolOwqFcdTAwMGVcdTAwMWTDgFxcdDMmTVx1MDAwNinDkTtcdTAwMGUpwqlcdTAwMDHCrMOLXHUwMDEzwr7CgcKpw4zDgMOKw4LDlW7Djj5QwqI2XHUwMDE5SmNPScOswq1jJmvDlHfDqsOLOlx1MDAwZlcmwrHCmsKpWiHCmMK8LMOjwq3DjnrDjiR2w5PCr8Klw4ViXHUwMDExKcKnwrViccKYw4TDiETDoT/DvMK+w5hUWcKBw7zCqsOwJMK9XFxmwpzDjzvDqsOtw7/DusKuw6HCqijDgVR3fsKgK8Kdw65ywrPCkkHDsy9rPsKjwoTDrikqw7cgwpDCok3Cu8OewoJMbsK9w69mRitkbVx1MDAxYcKAMyROLHhpLlx1MDAxM8ORU1x1MDAwN31cXFxcXFxmTm/ColVcdTAwMTBcXHTCj8OiTcK2bVx1MDAxMMKUYmDCq8KVXHUwMDBlVMOjTMO4XHUwMDEzUj/CuzTDu25Nw48vwqrCszHCusOlwoxcdTAwMGbChlrDtMKQwqpzw5DDs8KhXFxmacOnwpxcdTAwMWLDslxcdlx1MDAwNzfDlcKAPUBAXHUwMDBmXHUwMDBmwpDCkU9Pw7DCtzZCXHUwMDEyXFxmXHUwMDE2XHUwMDEyworClMKMw4rDuMOBw5AkKMOmwqnCn1x1MDAxNVxcZsODbcKFw6HClsKGaMOVVmVXwqTDrlx1MDAxYcOqS8OIwrhcdTAwMTDDpMKELGPCg0PCk8KUIcK8wp/CpSBfXHUwMDE3XHUwMDA0w57CoVx1MDAwMcODbVx1MDAxMXhINMKKJsOmwq01w7BuQcO4woZowplcdTAwMDfDpsKkw7Qhw5rDpz1Kw44+w4fDhizCl8Ojw4/CoybDkMK2wrDDjTHCuMO4eFx1MDAxYlx1MDAxYsKtw6DDiMOMd1x1MDAwNcKQw7nDr1XCuD1Aw5HDr1x1MDAxOXJcdTAwMDXCvMK8wrx8w7dcdTAwMWbCsH9/w5N7woNNXFxcXMK4w7h4w4dcdTAwMDLCoMKVXHUwMDE4XHUwMDE2w5DCv8OPw5PDgDzDmcKuw51cXFwiXHUwMDA1XsOKw6DDnsOSUsKfcsKMasKUwpvCi8KLdHrCjMO3w7ZfcTjDl8OGwofDvcOgXHUwMDE3IcOaXHUwMDEwI09Dw5Atw7I9SsOCw4TDvsK3IcOddcK5PUDDj1x1MDAwMU49QMOQR3Row6bDjVBjWkrDusO5w7nCpsOkw7nDgMK+KnXCksOPwpU9Slx1MDAwNVx1MDAwNlx1MDAwNsOZJD1Aw7nCsFx1MDAwM0NDe1PDsznDtMORPUA/w5DCgHnDk8OXdVxcdFvDs8OvwqZ9JVx1MDAwNiNxw4HDgcOOw4heQcOpw6lXwpVcdTAwMTJcdTAwMWLDhMOYw5/Cn1NcdTAwMDPDlTTDjVBAd8KuXHUwMDE4w4nDj8OPwonCqm8mw5DCvsKOw4LClMKLw6DCnz1Aw5jCvlx1MDAwZTJTw5NcdTAwMGXCtlxcZkzDtcOdw6TDulxcXCIhwqgxITrCkWXCnsKCwrU5KMKGIT5cdTAwMDU4XFx0eTlcXHY4KMOmYzxLw7nDh1x1MDAxM2ZAw5PDtkfCplxcYkHCjVZ1wrbCslx1MDAxMcKlwr1fPUo2wq5TMjjCrcOdw5DCmcOfw7ZUw7jCjsKiw4jDjDzDtUdcdTAwMDY4XHUwMDAxNyhqOMOAN2FtXHUwMDE3XHUwMDFhw7fDgMKuZMOiScKvwq1Jwp9rOMKtwpHCvXXDvSfChiZcXFxceMKrO8K7aVx1MDAwNsKneiNpwpE7L8K4MsKTXHUwMDFhw4TCtcKXMMKDdENowqbDgmJMN2dhSMOia8OOw5NCw7jCuHrDj3zDlsKhw7rCl8KKVcOewqvDkz1Aw5AzLMO8LMKFwqzCumDCnlx1MDAxOcKqXHUwMDA0wqrDssKJcXhpP3zDsMOpSXnCgDFcdTAwMTTDssKqW1x1MDAxZcOWwohSwqrCmsKuwr0nL1xcdFx1MDAxM1x1MDAxOElcdTAwMTlYMcOjXHUwMDAywoXChcOCw4NCQ0RcdTAwMTJcdTAwMTVcdTAwMTNcdTAwMTTCksKVwqvCl8OSw5DDlMOMw5bDjjLDh0UvwqPDjHpcdTAwMWHDolx1MDAwZVkgPMKlIcO6wr1/w7nCgMOpVChaXHUwMDFmJcK/w4jCq8O8X8Ksw4NEw7PCpFNwbXcnwpZgN1x1MDAxNCRcdTAwMWZcdTAwMWTDsSHCoWFYwofDpsKawqBcdTAwMDFcdTAwMTLDq0hcdTAwMTjCmCfDn3NcXFxcXHUwMDFjwr45wp/Co0PCn1x1MDAxMVx1MDAxZcOAXHUwMDFjXHUwMDE2w7tOw4dHZD7DnzXDksOCw5RcdTAwMWXDi1xcYl5cdTAwMWHDk8KBw77DoXFROWxcdTAwMTNlw4vCnsOzw75/wpnDtMODXFxcXFx1MDAwN1vCsGQzXHUwMDAxw5nDmHTCm8OPwphcdTAwMTnDkkY9TWrCn8OGwobCgUM5KCDCjsKFf8Kjw5rCmcOTXFxiXHUwMDE4XHUwMDE5wpnCmUfChGDDp2Jlwpt2w5ohKsKFfWc3P0/Dq8Kpw53Cp8ONXHUwMDE3XHUwMDA0XHUwMDBmXHUwMDFkV8Kxw6HDt3VFZMO6w7RqfcODWVFtwrRcdTAwMThWXFxcInBpw6PCosKiXHUwMDE1wrTCg8KPwr09fcOxwrg2wo5mwoYkXHUwMDAzwoLDgkJcdTAwMTLClMOTw5VUVVx1MDAxYz9cdTAwMGXDosKxeVx1MDAxNsOTw4l/wr49Slx1MDAxOcOKw7nDkWBBwrc8ZMKDaiw9SnLDtW9GVcO0wodcdTAwMWbDv38oOcK5w7jDj2XClClcXHRdw6FhXHUwMDBlwrE5wqBaw7/Cr0XCo8KaeMKEwrQkwqZmwqnDmsOLXHUwMDE0KVxcYsO9J1x1MDAxY27Cl8OOw5XDm8KwPMOmwoDCpsOQXHUwMDE1J1x1MDAxN8ONw5VVfcOtJzBcdTAwMDPDhVx1MDAxM8KVw5NTXHUwMDFiw5PDqcKHXHUwMDE5w5nCl1Q2XHUwMDE3wpnDisO0w4FBXFx0w71cdTAwMDFcdTAwMDVcdTAwMWYjS8KIwodew7DDvXRxwq9Vf8KJXHUwMDE5w4nDiUnDicKGXFxiw6nDjFbCm8OCw6XDl8K7w4A0e1x1MDAxZcKJOWF2XHUwMDFjw6FhfsKBXHUwMDBlwrtMa8OzwocuwpTCiVx1MDAwMsKnw797bVx1MDAxN8K+w5NRV8KVXHUwMDEwdlx1MDAxY8Oee1HDlcKrw6pUPU3Cv37DpWdcdTAwMWbDqHzCtSTCqE7CgmonwpjDmcOew4HDkcKoaVx1MDAwN2h0ecOAJFx1MDAxZFxcdsKGwq/DhcOkXsO/J1x1MDAxM1x1MDAxMFx1MDAwNMO7QFTDnH4hXHUwMDE1w7VcdTAwMDVUw7E4w7zCvcONwqRoXHUwMDA3Z8OkTl3DssKAwofCsFx1MDAxNCcgXHUwMDFlJsOAw7TCknk9fU/Ck1x1MDAxNFx1MDAxOcO5w6HDoThZw7g0XHUwMDEzw5HDrcKxw5bCn8KhaGMxwoHDpsO2flx1MDAwZjLDoMOow6nDqMKbwpp7IMOaKMKkwrQuecOnw6lpZ2TDncOTXFxcXD1AXHUwMDA1bMKHwqtcdTAwMWXCg8Kkw6XDqMOowpZlw5pSwqXDosOdwqtcXFxcO1xcXFzDllx1MDAxYyvDo8OVw4zChMKHw5I5f8OEw77CucONw6vCpsOUXHUwMDE1wqDCv8OnRsO/J8OWW8O0asKwJFx1MDAxZCDDvl5wfcKwXHUwMDE0KMO6w6RYw7NzN1x1MDAxNMOxw7jCpcKxw5DCsVx1MDAwMzMywpRcXHTCiMKGw4VLw75ORlx1MDAxNcKkwqXCl8Klwo/DjsK1OMOCJ8KnXHUwMDA3w4lcdTAwMThHwoXCvEPCksONeFx1MDAxY8O9XHUwMDFkXHUwMDE3XHUwMDAzL8Oyw4fCscObPFx1MDAxM0RcdTAwMWUmwqLCp8OHw6ZcdTAwMDdzeWrCqCAoKFxcXCI9SsO+w7DDtFx1MDAxYsK2wr8ww4HDpcOpXHUwMDA3wonDiMKHXHUwMDA3w6XCmlx1MDAxY3LCgcKNP2N8NcOWRcOuXHUwMDBmXHUwMDE4w5xFXHUwMDFmw5h0wrEkwptOwq55wp9cXHTDk8Ocwr3Dj8KkXFxiXm9cdTAwMTR0fcOnw4dBw5RmfsOOw5JcXGJcdTAwMTkhYHfDmlx1MDAxMMKtw4FcdTAwMWXDscOdXHUwMDEwXHUwMDE0Si3DsnBcdTAwMTnDuVx1MDAwMcOBXHUwMDAxw5DCpVx1MDAxMsK6dibCqMKpwqUpwrZbeETCrk3CqcOpZ2TDn8OgSsO6dMK7w5XCocKow6nClS1cdTAwMDfCoT1AXHUwMDEww6RcXFxcwqnDpWVJYFnDt1x1MDAxYcOhfk9ZwrHCtFx1MDAxNVx1MDAwNVx1MDAxZMK1wrrCocKhTU/Cg8KbwrcgXHUwMDFkXHUwMDA3wpfDrMKhMcKXaMOTw7HCisK/QsOyXHUwMDA3Xlx1MDAxNMKsQVx1MDAxZsKkw4RocsKgw6JMw7/Dv2jDtytcdTAwMGUgw5BTwrRcdTAwMGVcdTAwMTjDtVx1MDAwZlx1MDAxM0jDtHxKw5lxwoVRwoJSamfDu1x1MDAxZsOQwo/DhMOZOMOzw7DDicO5YWFOY8OUOlgmIyBcdTAwMGVcdTAwMDJcdTAwMWXDi8OawoA9fcOxw4rCgcOBRMO8Z8Kfw6MmXHUwMDFlKMKkXFx0w6jDqWTDjMOJwrDDosOcLmvDicKDw4Vdw67CvMKNN1x1MDAxMklcdTAwMWHCnMO5w7ZcdTAwMWJcdTAwMTgwLMKbX1x1MDAwNVx1MDAwNVx1MDAxZCPDu8OTwrDCrFxcdiBcdTAwMTTDhjwlaMKdQcOScsOzXHUwMDFjwr5fN1Ykw6MjwrBww5E/w7/CrMOiZy7CkVx1MDAxM8OpLSZtccK5eWRRelx1MDAwMV/Dm8KeXHUwMDE2XHUwMDE1XHUwMDE5YUzClGzChMOFw5zDgMOTZ8K2w7l3csO1w7TDs1UmZ8KSw7LDksObwptTKcOGIF5WwplOVyfCucOqw7XDl1xcZlx1MDAxNlx1MDAxNMK3eMOIw6jDvFx1MDAwNCPDl8KxYsO3w6Npw7hcdTAwMDU5wqnDrkV4w7hzRsKxKUMzSsKYcsKcw4jDosK2w7NnVMK8XHUwMDE1w67Ci3BcdTAwMThPw5jCkcKcw4lqXHUwMDFjNsO+w6pcdTAwMDYnw7rDjT1Nw4jCr8KIRiFGXHUwMDFlXHUwMDE4SjdcXHRcdTAwMTXDiMKsKsOJdW02wrAhwrfDiEDDp2nCm21wwqYrb8OXwotSw4kzNsKffMKww4tUacOswpvDh1x1MDAwMsOFwqjCnGJ+VsKBwq/Chlx1MDAxOMKSdHlxwrTDlFJVw7TCtMOcw709SsK7ZMKVw6fDgUpIwrA7TsOJw6nDrlx1MDAwNXknw4/CpMOPTlxcdFouw7rCgcKTLsKHcn3CtFx1MDAxNMKrwrBcdTAwMWLCqj/Colx1MDAwNUsye1x1MDAwMcKrw4zDuGpSdWlRwrTCpC0+NcOXXHUwMDFmYMOKOMO8wpQ5wqpcdTAwMTVqw4BqXFxmXHUwMDFiL1xcdF1RU8OrR8K1wqnCrUMpwqkkKcO9KVk8K1IrWitWK1ArVStQK8OdRMK6MDrDgnRaw6Zvw6vCqjtvQyorwqBSPX1cXFxcw4M/wrLCtm8rwqhSRUplSsOqOjMxw40qaS5dwr5Vw7pKSsKhSnnDisOrai7DocOuWlx1MDAxYS9Mw53CjMKxKi8rwq8qNy00L0QzPjA+OF4wUjTCkkZ6NsKDaklSOFLCq2JcXGLCqlAsw48sw48two8qwo8rdzDDtC/CrMO7dTRcdTAwMTQ7w5Qyw5Iuw5LCvsOCTWpMw4pUw4pcdTAwMTNqXcOyXHUwMDFhRnpHw7rClsOKw6NqXHUwMDFkwqtALFcwwoQ0w55GwpJPemfDukTDisOfalx1MDAxNcKrYCzClzBcdTAwMDQ0w75yw5Zfw4pQw4pcdTAwMDdqwqXCqyAtRy5kNsKePlx1MDAxMmJhfjDDlU0sw58qw4cwZHXCsMKdwqpYLMKHMMOkNMO+NMKeR1x1MDAxMlDDusKXw4plaiHCqkgqZyzCpCxcdTAwMWU+XHUwMDEyY8O6dcOKXHUwMDAxasKZwqtcXGItwqcuJDZcdTAwMWUvXHUwMDEyRcO6OUpCZcOPw6TCqigqXHUwMDFmwrwrfsOYRyojLWstcGs9fXVcdTAwMWLCqsOqOsKqwrNvSsKpSl9KN0pXSkdKZ0otSk1KPX1KXUp8K8KEK1x1MDAwMypcdTAwMDMrYypjLMOrVGzDvipKwoHDimtqw5rCqkJcdTAwMGYzLlx1MDAxNcOew6rDukvDsknDskHDsknCkjJ6Onoyw7paw4p6w4rCu2rCi2pcXHZqwo3CqsOMwqrDsCs7w4XCqGZ6RsOzw5FuUcKzXFxiO8OHTMKkbMKOeFx1MDAwZXDConhcXFwibsO0blxcYsOFL8OeQ1x1MDAxMlPDs2HDnmQ9fcKrw4TCqsOkwqpsKi7ClcKqwqgqwq9rdcOfQXI1ans4XHUwMDFlQMKSRsOewoDCgcKrwrAqcsKEwqrCpsOLwq9lNT40wqrDozHCvjhXwoJZw7p8KsO5KsKSXHUwMDFmw5gtw6vCrsKDw7QywoTDpsK1ak8qUHFcdTAwMTLCpcOmLsKEOcOKdHoxw4grw5poLEfCryhyRyrClmZcdTAwMWVrMCvDssO+wp5rwphqw6HDi8KKw7ckw4p9KsOiwr/CsMOKwr0qw6RDw7DDisOdKsOmVMKSw6LCkCpcXFwiXHUwMDEwbD1Nw588Klx1MDAwMjJcdTAwMDfDtcKQKlxcdsKXwpXCokDCqsOSMDZDwo45wpMsQlx1MDAxNUrDlFx1MDAxZVIqXHUwMDFjwo3CqcKiUV7CjjMqw7RcdTAwMWZYwrpBKsOQTSrDncOuN1x1MDAxYzI9Sl4swppAw6o0MVx1MDAwMSvDii3CqsODdcOLw4tcdTAwMTcvwrrDkC1yXHUwMDE5I2vCgy3DisO2Kn7CiSrClHVaXHUwMDFhwoxSXHUwMDFhLsOqZDjDqiTCoC5cdTAwMWHClD5cdTAwMWE2JFXCpSvDmsKLSsKyScK7w6rDvcObw6pcdTAwMDXCkj1KW8Kqw6AzamU7asKVMMOKwqfDhDLDnHIww4PCqmtcXGbDgzBcXFxcw4Quw5wsPUpILj1KWC49Slx1MDAxMMKsOsOxKsKawq8qwoZlKsOYSCrCgTPCqlU1w6rDjyvDosKKbHzDnCrChk8qw5hIKlx1MDAwMTjCqlUuPUrCuCs9Slx1MDAxMCzCmkHCrCxGLj1KaCw9Slx1MDAxY8KAw6plwoDDq8OlwoDDrWVFPUpcdTAwMDdcdTAwMTVKOSpcdTAwMDTCsypcdTAwMDRQKsKXQcKqYMKOUVx1MDAwZcKfQVx1MDAwZcKjOVx1MDAwZUcqw6VBwr5xXHUwMDE1MsK+XHUwMDEzQsK+XHUwMDE3LsK+O8OqwqQ/w6pkXHUwMDBlNsK+J0ZcdTAwMWEqwqrCpEDCqkTCpDfCosO9MGYswrogLHLDgVxcYi9cXGIrasOZwq1cXGY/wp4qeSvDhkErw4ZPwpnCqlx1MDAwMSrDtsOBKsO2XHUwMDFmw4dcXGbDpMK5w75nLsOdTy41w4rCrcOow4rCpcOfw4rCocO6d8OKJMKywrjCq2jDpzBnXHUwMDE0LFx1MDAwNzvCq8OIwqrDp3bDs8KtSFx1MDAxMsKrXHUwMDA2W8Oyw4Mww4PDqDBDw4DCqsOmw7IwS1fDrVxcdsKjPUrDo0hcdTAwMWHCgcK+M8OpwrVcXHZkXHUwMDFhw5E1XFxcIsO6w6ErXHUwMDE4wrHCnMOzbShcdTAwMWZcdTAwMDRcXHbCp3p7fmtPXHUwMDFhwoTDh8OQdCrDnjLCqlx1MDAxMkV3fcOfI8KKdVcqPU3CnVEmw6h2fcOZXFx0azE1JMOpw4wofH7Dv8KSU3TDqEJQOMOWwr/DjFx1MDAxYcKjWsOPw6h0e8OZwrfDjsOTwrzCi8O8PsOIVHfDn1x1MDAxNsK6w5DClEl1fcKkRFxcXFzCvlJuwrDClMOTwrzDi8KIScOBw4vDpMKoa2nCpMK6Vm9Bw7R8XHUwMDFjWsOlasOZccOAbMKowpx+w79WY1x1MDAxNFx1MDAxZldjw5TDrnbDiGxjWsOzLMKqf8OVw5NqXHUwMDEzd3zDiiTChD5SwoltSFx1MDAxZsOkw4Jxwp9cdTAwMDdcXHZ7THlof8OfwrB5w6vChj90WXVqXFx2w6UswrQ4fMOOwohJwoDDjnRGwr5Sw6bCiMKzwpTDu8KBw5DClMOBU33CpMO6w4M9fVd9wqtcXHTDlMO+XHUwMDE1XHUwMDFmw5R+w4HCrUTDv8KhbsK3w4xtw75TI8KxXHUwMDE0wr5cXGI+NzQzXsOTw5TDl8OEw75cdTAwMTVqV8OUXHUwMDBlw5dAwq9cdTAwMTDClX3DqEhkflx1MDAxNzVHdMKZM8KiZyxcdTAwMWbCisO8w6RIXHUwMDFmJMK6aMO/wr/CkWrCszBEfH/DqTdTI8K9cMK+XFxiwpbCjTTCuV3Di8KSXHUwMDAyTlx1MDAxM1/DtsKOWcKjwopwXFx2TVx1MDAxMH41KsObw6DDrMK8w7x1w5/DjG5cXHY9QH7CtcOpN1x1MDAxZlx1MDAwNFx1MDAwN8OAXHUwMDE0wpzDnMONJEZcdTAwMTZcXHbCqDF0XFxiw6NJw49cdTAwMTFcXHZyw4vCqih+f8KuPX1cdTAwMWZkw7fDg1TDk0Rqw4swQcO0QcOlw6wlMXzCpMO0wph+XFx0worCocO0YVx1MDAwNcKtwqTDp8Ozwr1cdTAwMTTCpFxcZm/Cs3bDpsOTw5ROS0/DqcK9w4tcdTAwMWXDpDrCr8KxJHxcdTAwMWXCpGlcdTAwMTRcdTAwMWZJwqnDlE7CkDLCr8KbSsO/woxFNlx1MDAwZjnDi1x1MDAxZcKiw61Se1x1MDAwZsKaw5TDj1HCvsKkwodowrxcdTAwMTTCvDjDjSRcdTAwMTDCt8OQwpLCvTJ0KMOqQnTCmW4+wq9owrjDj8OUQHB9w5nDp8KMw4smPU1Tw55QwrhcdTAwMWPCt3YqKFF7wqTCocK9w5PDqMKfU8K+XHUwMDE5XHUwMDBlXlx1MDAxNMOfXFx0TsOUw7VKwr08wp/CkcKbwp/Cn01cdTAwMTJTOVx1MDAxNG06OVx1MDAwZjVcdTAwMWZEOVx1MDAxNMOWcMOSwrXChMOKwpjCq8OTdcK+Rz1Kw4cxw4LDlyzDtn9rw63DsMKtcMOxwphKw4JcXHTCj17Dv8O8dH3Ct8O4WsOcw6g4NsKePX3DusOBXHUwMDA3w7w+WcKGwrDClFx1MDAwZcKtXHUwMDEzwqnCgcOAw5TClMOAw41cdTAwMTZ4w7J9w6bCoMOCwposXHUwMDA3wqJkc2pcdTAwMWJcdTAwMThVfMKgI8O0fsK/w5VUXHUwMDBmw5XDmXhfXHUwMDA0wpV8w6Z+wpfDlFx1MDAwZsOkWFx1MDAwZsOFwo9qXHUwMDFiw6bCt8OTcEldw5TDj1x1MDAwNsK8w4zCqVx1MDAwNHrCoGVHUlxcYnBRw5RcdTAwMTTCu1V/X8Orwq1cXGZcdTAwMDMzU2XDgidxwpk3w4zChFxcZm3Dk8Oww4bCmnLCnUZcdTAwMWVtPU0rw7HDkz5ZwpZcXFxcw79cdTAwMTLCgW4jw5g/e3/CvcKQfMKgXHUwMDA1QHzDplx1MDAwMsKkwrTDiMOfw4PDjFx1MDAwNyB6w6ZcdTAwMGU9TcK+w4dcdTAwMTjCo8OUVFx1MDAxY1BcdTAwMGbClcO7a194JXJcdTAwMWJ0KHpXwqZoXHUwMDE3XHUwMDE1w5dxXHUwMDFkw75cdTAwMTdcdTAwMTLDsC/DiMKew7XCs8OLXsKHSXVcdTAwMDVjecOQwqN/w71cdTAwMTLDlG/DtVx1MDAxMsOUXHUwMDFlR155w7psXHUwMDA1wr9cdTAwMDfDi1x1MDAxM33DiVx1MDAxMsOAw5HCnHzCt0dQfMOmXcOIfMOoNU3DjsKEbMKdw47CosKnwp3DjkTDocKZw4FcdTAwMWPCt8OmUn9PKcKAw7RcdTAwMTg2ecOEw6HDsmvDhFhES3fDgXbCu1x1MDAxMF9Ww4HDoCXDulbCh8K/KDwgbXvDgMKTXHUwMDBlwqXDslx1MDAxYTBRw7PDnlx1MDAxNsOJWT1NwoVcdTAwMDRWw63ChVx1MDAxYmvDkHvDv3LDoFx1MDAwZicywoNcdTAwMDTCo8OEw5ZcdTAwMDfCtW3DnGbCv8K5w5x/wrFXXHUwMDBmw5TCiMK2w4E9TcOXwoNLwpEhXHUwMDEww4BGwqd/wofDqMKPXHUwMDFlwpIjw7DDtMOvXHUwMDFjw6YzXHUwMDE3XHUwMDFjw6jCiVx1MDAxZj/ChCw8PsKiPU1FP0Qnw6hTXFxcIiBcXFxcw6bDlE/CncKiwqDDlDnCo8OmwoxxaMKnw5XCvHkhwpVcdTAwMTFcdTAwMWTCkGQ0XHUwMDE2ZMKVLn/Dg8O5LsOow5xowrTCt8ORPUBUXHUwMDFjw4TCksOPw4BVPX3Cv8KmXHUwMDE3w5lSXHUwMDFiw5g3fsKYZsOjwoBDw6ZcdTAwMWVUXHUwMDFlw6tcXFxcP8OlNcOJfsKiw4tzw5R/w61cdTAwMTnDlcKAw5/CsMOVXHUwMDFiw4jDnsOUXHUwMDAzf8K5esORWcOew5TDoVx1MDAxNjlcdTAwMDHCkkbCn8KJwq3DoVdzw70hXHUwMDFlwpHDt8OARz/ChMOmNn9cdTAwMTdwKMKQwpdcXHRPXFxiZH/ClMKhwp5cdTAwMTZcdTAwMTBcdTAwMGVcdTAwMTVcdTAwMWPCvsOfXHUwMDFlXHUwMDEyXHUwMDFmcVx1MDAxZVx1MDAxMsK7wpskZsKdw4jCq8OHXHUwMDBmS8Ktw5TDoj5tXFx0w7HCpHDCt1x1MDAwNVx1MDAwNcK2wqLDl8OdwrbChcOwLsOFXFxcIsKww6pcdTAwMTRcdTAwMWUxw5jDhGDDmMKFwpQ9QMOMw4HCinhcdTAwMDVlwoVcdTAwMDJnwr7DnFx1MDAwZTfDqMKRwoM/w6BcXHTClFvCk8OZa3F/w4rDuH7CrcKkXFxcXDA2csOPwqPCijFsXHUwMDA3XHUwMDE2MzBww7xVw4TChMOkwonCtFxcXFzCk8KrXHUwMDAzw7Rww5zDvsK4ZcKcw75NU1x1MDAxYUVcdTAwMThBekEpVH3DmMKnXHUwMDE0w77DtcKAR8O0wpPDqDtfworCrE9cdTAwMWZRw6hJw7/DrjjDjMOAw5khw4vDsMOjwrF8w7zCpcKNw5JrKMODPsOcQHvDqMO1w4B6w63CmFx1MDAxOMOOw7TDt1h6YEHCiXvCmcOfwqNcdTAwMWXDt0JRwqTDsMOxwptcdTAwMWVyXHUwMDE1ZGTClsKMXcKHw5kmwrU4w4dcdTAwMTdQwp9iw452w5TDjiPCrMO+w7BibVx1MDAxM1x1MDAwNcOlwrTDjj1Nw4ZIclHCji7Ds8OmKcKkbMOwUj1AwoVgw7Ipw4ZWwpnCgsK2wobDiMKLwrnDhn/ClMONJlx1MDAwZcORczTDo8OrJ8Kiwq09TcOPI0nDqcOnXHUwMDBmXFx0w6NcdTAwMDdLwoIjXHUwMDBlwrfDjCnCgVNcdTAwMGbCrMOJeFTDjMKxY8OUf8OVw7nDk8O3wqDCncO7wpJcXGLCoWpdw7/ClsOOw6DCh8Onwr7DmMKwwpnDhVxcYsKDXHUwMDE5w40wXHUwMDFkecOccDVcdTAwMGbDicODZkLCjcKTaCHCocK3XHUwMDBmw5lLLMOFw43ClSBcdTAwMDNnecOVXHUwMDEyw5HDj8OJPU3Dnj1Aw5vDuMKPw6dcdTAwMDdcdTAwMGZrODdcdTAwMTjDiD1Nw5dcdTAwMDTDpsKVwr3DgCPCrsOyw7kzXHUwMDAywqnCm8KJXHUwMDFhw67ClsOvw7pcdTAwMDfDkcKBwq9cdTAwMTdcdTAwMDc6QcKDJGNgw7DCm1x1MDAwZsK8wqLDh380UyHCqEfDtcOCwqjDpFMhw4pcXGJcdTAwMWRMwpZow6jDrDLClsK6wobDmi1AbEVcdTAwMDXClXd9PX0/w4/DksOhb8O8w77DtDfDnMO+SsOqw53CjcK4PFx1MDAxZlx1MDAxZcKvMMKPwqBcdTAwMDTCuiTColx1MDAwMsOAVMKCXHUwMDBla8K3NTjDj1x1MDAxNsOkfVPDlVxcdMKfwr5cdTAwMWEmK1TDtiRHw5/CgcONSSdcdTAwMTJwQ2c9TVx1MDAxNcKNJFxcZlx1MDAxMlt8cUfDiHXCk8KTw7jCuzh/wrLCusKTw7Nvw5zDqCfDrVx1MDAwZsOYWMKJTMOpwp44wrlcdTAwMTHCg8Kewq5JPMOfd3sgfMKxXHUwMDFjwqLCt3PClC3Clmxfw5lcdTAwMTnChcOWw73ClkfClsOaI8KOwqtzPU18woXDtcKlw5XDnVx1MDAxNsKoRkdcdTAwMTfCvsKfXFx2w7/Dilx1MDAxZsKFZsKvM8Oow5ttw4Q9QMOwwrliXFxcIsKTXHUwMDA2woLDp8Kjw5tzXHUwMDEzwrA/wr3CiXjDqcKHPUAxMGPDp8K3w5BcdTAwMTDCkXJ9wolEXHUwMDBlUsKOw4tyw58yw5/DkiPCsVbDkllnw4h+wonCgjZvwqHDucOQfjTDmH3Do1x1MDAwMsKvcMOVwrjDulc5w53Djn7ChD1Nw47CnVx1MDAxMV/Dslx1MDAxZcK/NFx1MDAwZlx1MDAxMm1cXHY0XHUwMDFkwoEhXHUwMDFhw6lOwrZ/cMKFXHUwMDExw5LDocKCw4fDv8ODacKbw4pcdTAwMWLDgVR3XHUwMDE1w6hpwoXDh1x1MDAxMsO/wojCrX88w7dtwpzClXjCuG3DncOQwo/Dn8K2wqfCiHfDrcKYwoE1w7fCosK+woRpN8O0IcK9P1x1MDAwZmVcXFxcwrLChFx1MDAxMsKJc8OTJ8KkbsO7wqvCo17Dp1LChHTCt2hMw6fCmsO6M8KDXFx0I8KFwovCvz1KwpXCtMKUJVx1MDAxNMO/QcOUw5bDvMORXHUwMDFmNcOXXHUwMDEyXFx2XHUwMDFjLUFgbi/Dk8OXXHUwMDAzQ1x1MDAxOcOlwo/Ci8K/b8OCYMKfQFx1MDAwNDzDh8ONQ8O+w7TDicKhw5PCtsOkwp/DnsO8w4PDqXxQXHUwMDFlUsKDw53CpXBmXHUwMDAxdsKRwr9cdTAwMDVFYFx1MDAxM8KYd3/DmsObXHUwMDE1VyFYZ1xcXCJkw7DDksOyw5LCmCFkw7HCtXdcdTAwMWR0w5PDpMKBwqTDnlx1MDAxMcOcM3xsXHUwMDE3w6VcXFxcMcK9wrTConnCl8O5w5PDg3M5Xlcyw4hcdTAwMTB7SD8/wrnCjcKgdX9cdTAwMDfDn8K7JX9na1x1MDAxM1x1MDAxN1xcdFAtw7tcdTAwMTYhwph/wrHCicOQXHUwMDEzcsOZwpjCk3tcdTAwMTZ9IMOGXsOtwoZcdTAwMTnDvcOswot/w684N8OYecKjO3XDq1DCncKxw6DDijnClldDw5rDk3zDi8ONXS5kXFxcXFdcdTAwMTnDrn1oVcOLXS7CkDRcdTAwMDHDqU5uw5dEUSBBw63CoMKRwq5kw6vCgE8nfVxcZnpMIcK7w6jDk1NcdTAwMDLDmMOUwqrCkUnDinTDmsK9w7LCn33DmsKNwqfDilx1MDAxZMOBLcKgw45XXHUwMDAywrtcdTAwMWJcdTAwMWHCpVDDnsKBwr/DusKrwrYxw4XDnsK9wp5MT8KYRVPCmMOIwqtWYsOKXHUwMDBlS8KHaGLDk8K+wovCrmrCvcO8w482wotcdTAwMWY/woXCmsOPwqV9TcOqw5VcdTAwMTjCpVx1MDAxYS9Pw6JrccK5RGAuwqM2w5pfYcO8flHCqFRcdTAwMThZZWNkwoxuwrrDmcOBw5XDjcK3w5PDqMOQwo7CsMKPwovCoFx1MDAxNFxcXCLDsnvDrSzCpzE5wpzDnF/Du3tLSFnDlMOMUlFXwpjChlxcXCLCssKKacKZYVFFfWdfb8OywoDCt8OSwqJ0wpRsw7ZCXHUwMDFiwoNlNU1Hf2jDp8OKwpjChMKDwpjDsMOuw6LDm8ONwrExJMKibMO0wpAkVFx1MDAxZcK0wq/DncOUdTVQw5FRw7BwwrhEXHUwMDE0WcKeST1KworDk3PCmcOSwolcXFxcwpnCsMOSTlldT2hkTF4yXFxiXHUwMDAxXFx0w4JcXGLDo8OjwovDrybDpFx1MDAxM1x1MDAwZsKvY8K9wrxRbsKvwrt2ZcKUwojCuibDh8KVY8KbwqLCicO9w6DCtzdVw4F+w49rXHUwMDE1IcK0PMOWwr/Cq1N0XHUwMDA2ccK/JcKSw6txQWQgwo4zPlx1MDAxYlxcdE7DrcOjSMONwrlFwqVTw45pXHUwMDFlw4QgW8KUwprCh8O8w6jDq8O8IMOcXFxiw7g5Z8OnOVpvXFxiwrBFRcOmw5nCqWdcdTAwMTUnw6FcdTAwMTDCtcKhJzh/w4vClsK9w6fDmiR+w4paJn/DnHrDl8KYw4TDmsKgXHUwMDE3woxcXHZcdTAwMGbCp8OFwq9cdTAwMDFcdTAwMDNNbFnCpm9Cw5slw5N6wp09QFnDi8Ocwr9mwp1cdTAwMTnDpWQ9fWHDqsKuc8OlPU3DqsO2wqRcdTAwMTjDq2LCuTjCjsOAw4JuWmJSwrvDg8KhWMKxXHUwMDAzw53ChsOuwrbCuMOTwo9cXGZ/XHUwMDEwXVXCiFjCjXRIXlpjw4nDoFrCoTfCoF3CqVxcZjldwpTDsVs9fcKSwp3Cq2PDpsOLwrdTw6DDqcOxVmMowr57NsKpw7FmKFxcXCLCv8K7w5Ulw63DmsOUfMOyTsKEOMKDw5hcdTAwMGbDjXvCucK/wrvCrcOgMFx1MDAxY0fDjMKtw5ZQQ8OKw6ZcdTAwMTNQXHUwMDEyXHUwMDA0wqY1XHUwMDFlwpTDmDfDtFnCnWpSXHUwMDA0M1x1MDAxM8KDw6XDjFx1MDAwMcK5XHUwMDA3w7rDtFx1MDAxM8KIw7J/wq1rwpFcdTAwMTFcXFwiw4zDjMO5K3JcdTAwMGU/wrbClsOcwrDDi8KVX03DusO1w4RaXHUwMDFlT10sw7dcdTAwMWTCsmxcdTAwMTPCmcOxw4tLw4zCgsO+XHUwMDA3XytcdTAwMGbCt3Vqw6VcdTAwMDFOw4vDgMKdPX17XHUwMDE1w5d+w47CoEtHXHUwMDA3woLDgcKrw5w9TcOcw7pSw4PDs1x1MDAxMiUmRlx1MDAxZXTClDTClEjDicKxdj1AXHUwMDExTcKmw58qb8OnUm7CpcKIQMOLXHUwMDBmYcK0w7tcdTAwMWRHT1LCmcO0fsKOwo19wrTCiMKJVG/ClVDCvsOLa8O5w7XDulx1MDAxNMKbXHUwMDBmw5IjfmPDlFvDk2rCucKdVMO6wrjDrT/Dklx1MDAxZsKlL8Ocw6A9fcOLw4RbTMOueD/Di8KPVW9cdTAwMTLDtGg7w7xmWWzCsMKhbsKSXHUwMDA0wp07wqRcdTAwMWVrwq44wqc9fcOLwoPDqW9cdTAwMTLDrEk7wpRcdTAwMTk/SyNoO1x1MDAwNDZcdTAwMWUww5JBwrLCqsOVLV7Dm8Kgw5DDrMKKXFxcXMOqUHXDry1WSmY+XHUwMDFlK8KAwqHCrTnCnirDmMOmw40uwpxcdTAwMTVMKmzCjcKLw74twqjChlx1MDAxZVx1MDAxMsKtwpFcdTAwMTErdyRVbMK1wqVKXHUwMDA3wpjCosOxecKiw7HCgTvCnCguXFx0wpk9SiFdYik6w5hcXHQ8w4vCtlVMXilew6ZcdTAwMTnDgjJfXHUwMDE5QMOLXHUwMDFkw4Vuw7IyXHUwMDFjwqbCnMK4Mlx1MDAxNzvCs8O6wrHChjtUdjzDi8KLO0zCvkdKbMK5wodvwpLCv8OjMsKXfj/Di1x1MDAxOFxcYjTDnlx1MDAxMMKHL8OEXHUwMDA1wojCq1jDoX7DisOyw4c/w5Ipw5w0PljDlGpcdTAwMTF8VXrDt8OyNMOew67DlyzCp2DDlmpVw45Uw7omXHUwMDAxXHUwMDBmXHUwMDEyXHUwMDEwXHUwMDBmwpzCvsOcw6VGL1hUcSMjXHUwMDBmXHUwMDEyw7XDgsKcwp7DrMOXRlx1MDAwNz1AWHFcXGJpw7XDulx1MDAwMcKFwo9cdTAwMTJcdTAwMTHDqFxcXFw+w5zDijbDp8O5Vm05wqzDtcK6wqvCj0PClCbChcK0wpRcdTAwMTnDgMOMLcKldcK7XHUwMDFkw5Z8w77CvXrCtMKeZnXDu17Cv3xOwqZjPy9Jw4XCtGDDtsOFwrRsPX1cXHbCosO6fsOebsKoVMKcw6jCgcKswrbDoMOBw4pcdTAwMTLDk09cdTAwMTLCl3Izw6TDisKFwqzDpMKIP8ONw7wtw6/Ckm5/W8O0NVdwXHUwMDE5wp7CtcO7w6hcdTAwMTFvXHUwMDEywpR9O1x1MDAxY1RUbMKHw5IyXHUwMDFiP8K0esKgwpVLw5zChMKAwrLDhsKMNcO7RsOdbFx1MDAwZSfDlCojwpZZasO1w500wrrDicKdK1x1MDAxYyfDhMK5w4BcdTAwMTbDuXHCrVx1MDAxZFx1MDAxZMK7JcOqwqZ+JVc5XHUwMDFmXHUwMDA1w4HCscOWwp1cdTAwMWN6w4vCjUjDvMKpYS/Ck8KYw4PCrMK8PX3DkErDqFxcdj5OXHUwMDA1w4jCtcOMXHUwMDEww63CisKFwppYXHUwMDE0XHUwMDE1w7Vrwo04XHUwMDExSsOTXHUwMDE2Rk7CkcODwq08XHUwMDE5d3DChFx1MDAxZFBNfcOpw7PDkiRxYGxcdTAwMDXDnHvCosKeYGRTw7JwX1HDnMO6XHUwMDEww7ZWwo7CjsOCwq9owonDtG4wT8ODwpLDp8KfUMOUw6bDg8KrwrjCtVxcXFzDulLCsTZcdTAwMGXDvWgzw7fDk8OGwq7Chlx1MDAxNlHDi2thw73Du1xcZsO8wp4+wpTCu8K4wrxZw4/Di8OlY8KTwpLDhcKgRMOkwqdmP8Ovw7HDkcOMworDg35ewqnClTTCnEfDhMKsXHUwMDA2aHZuw7VcdTAwMTF4bnsnUcOMw4zClcOzXHUwMDEyccKAXFxcXMOkw4/DgsK2w77CoU7Di8Onw6tzw4opwrNywp/ChEzDpMKYwr7CssOoR3Nqb1xcdjNSIMKNZlx1MDAwNH49fcK5cMOCw67DjcOCw63Cm1x1MDAxMlx1MDAxY8KyYsO+XHUwMDFhwpwsw6TCh2QrXHUwMDBmw5J3alx1MDAwM8KFw7DDjUXCiD1Nw7vDlMKVw5tcdTAwMTLChmxWRCFnMMKvw7/DrsOKwodkW8KSw7TDoMKSw57DsE1EXHUwMDFmw6laOFx1MDAwM27Ct23Dn1nDscOMwrvCo8KNwrvCskTCtcKeXHUwMDEwcEvCh8OnUl7Cl31OwrTCnsK0bsK1wrnCuGvCiCjCjcO6w5pVO1x1MDAxMsKmbi5cdTAwMDRcdTAwMWZaRsO7w7NcXHYyw6lFwrdcXGJcdTAwMTDCtnDDjMOJwovCksKEwpNCJFx1MDAwNGE0w594ScKvXHUwMDFlXHUwMDBmccOLRcKfTXvDocKKTsKEWsKhLsKEw4xmLFx1MDAxYlx1MDAxMMKxw4zCucO0w4vDssKhXFxiwppOw5VeRjfDiGc2Z39CwrDDpMKQNm/DvcOPwrBMe28yJMO+P8K2woRcdTAwMWTCrcK7XHUwMDBmXHUwMDExSlx1MDAxZVtXMlx1MDAwM2c1biHDjS07wp/CnTLDlElkLlx1MDAxN8KWM2pYSCvDssKTw4FpXHUwMDA0wopcXHbCuVx1MDAxMMOYXHUwMDFhbcOJPyfDusKvdMKJw44pXHUwMDA3McOndlx1MDAxYmvDoCE6wqRjPkvCrT19NsOkw7zCuWvDqcKANcO7RG9Lwox1w6d7XHUwMDE2w6XDq8OSwopcdTAwMTbCisOuaVx1MDAxMcKvwrbChsOnesO9woR5wp7Chj1KwrPCrMK0ZnpcdTAwMDJdwqHCnsKpw6JlwqTCqMOyN8KPw4LDpMOLJsOka8OSIcO1ak5JZzpXwpjCm29cdTAwMTXClsKHwrtcdTAwMWTCpkFcdTAwMGUhwo0qw6RFZyrCp8Orw7jCksOIw49dXHUwMDA0Z8O9M8K3I8O6SX/Ct1x1MDAxNsK5woYgY8OMwp53ccKOfVx1MDAwMjnCj1x1MDAwNsKbalx1MDAxOEg4wpIgNMKlwr4kXHUwMDA1OMKHwrPDnG3DsThcdTAwMDNMQVfChVx1MDAwZcOEwpHCrcKaw4VfwpTCocOecE/DncOWw7o9QMKBw4BSw6vDuTxfw5jDm2pcdTAwMGbDqcO3w7vCvcO7XHUwMDEww5LCn8ORQzTCv11tW8Kbw5BcdTAwMTIhwos9fcKOw4/ClMKsw4jDj0RNwpHClsKufsOfwrd6f8OQS8OUaMKPwqpcdTAwMWXCnzfCusKpw4Bow4x4XHUwMDEzw4tawpdnXHUwMDBlYHNBXHUwMDE3wpc9QGtXw5RkUl9zRcKXZsOSwq80XHUwMDBmw5/DusO9w5vDhFx1MDAxMm/DjTA8wp/DlcONJ23Dv3tcdTAwMGZUX1x1MDAxZSTDl1TCpD1Nw4vCtMOUwpV/w7pcdTAwMWJcdTAwMDXDtMKSw4jCr1xcXFwkw4XDjcKuXFxcIsOWTFx1MDAwNMO5woFuXHUwMDA3wrssXHUwMDFlwo4tSU/Cp1xcZsOLRHlINMOTwoBqZcOZw7PDjVx1MDAwN8OkXHUwMDFjUkx7OMO/XHUwMDE5wrpvw73DqcO1Sj/DizY8w7jCunBUwoHDj3rCt8OQPsKESW3DjcKuNz1KUcOiXFxiw7HClkcpw4F7wqhcdTAwMDXDrcOGw7Qlw63Dhlx1MDAxNVx1MDAxN8KMNsKUwqldV1TDqcOCwo3DtcKpWsKcUFxcdMODwpfDhcOpXFxcXDc4wonDgjnCpWhdNTHCp8KMQEYnw6rDplx1MDAxYsKow7nDlsOswpnDg3BcXHRhwrY9QFx1MDAxM8KBw7Y9fSnDgcK2w6zDg1x1MDAxMcO2bCnCkXZcdTAwMDPDkzhcdTAwMTDCrMO5PX3DkMOCwqfDrsO2QybCusK7ZcKcw4nCo1x1MDAwZsKkwrlcdTAwMTPDqSU4XHUwMDFkw67DmMOHXHUwMDEzXHUwMDA0wqLCtVNhw6TDs8KOWcOlw7jChnvCmMKNw4BcdTAwMDHChsKNwphcdTAwMWXCiMKLw7RcdTAwMWRZXVVcXHTCh8KOwpZcXGZZWsOgw6HDuVvClW3DuFxcXFzDncOEeV1Jw4Z5W1x1MDAxMWDDiMKOXHUwMDFlw55bXHUwMDFkw5TDoMODwptcdTAwMTZkw7jCpnNpw7DDolx1MDAwNmnDrMKmM2PDtmJHZ8OywqbDnGPDqmJXXHUwMDA1w7HCpsK/XFxiw7XColx1MDAxMFx1MDAxOMKQwo5IYVvCu23CoVxcXFx4wrHDoF01w7ZEw4PDk8Kdw6BcXFxcw4nCqcKYwpBow7HCmcKMw7RYwpfCisOAw6XDmMKRwqbCgMOZwo/DkMO0Xlorw4PDlcODXHUwMDFmYcKBWzXDp8KAXFxcXFx1MDAwNFx1MDAxNcOBXcO4XHUwMDFjw7XDgsORw4N1QsOlRcK1QsKrJWzDkMOgwqhow73DumHDgTN1w4TDrcKWYmHCtcKDwpLCgcOxw4LDuMOTwo9wwqfDhMOrw4LCucOUwpDDgFx1MDAxOcOHw7BcdTAwMTZ7w5nCjEjDqcOUwopEw6HDgFxcXFzDkX3CtUNRw4UsXHUwMDEww73DtcKGcMKQfWDCvcOBwrrDq8KiRcORW8KzIcK9w4NhdT19w4I9QHs9fULCp2s2wp1cdTAwMGZ2Plx1MDAxZMOUZsKsw7PCmjXCjcOwwqk0wo9cdTAwMWFcdTAwMTDDi8O2w4xcdTAwMDJKXHUwMDEww6jCpCrDnSbCrDnCncOXwobDsn7DpMKiW8OlwojDo1s9TcKBw6NcXFxcwp1tw4dDacO0wrtTXFx0wpHDsVxcXCJPwoVdNcOfVsOCXHUwMDE2wp1Qw7bCrWxtXHUwMDEww6jDn0jCvcO/w5jDr8OWw4LDi8O4w642fsKLwrhnPX1awrFBUlo7wrZWw51cdTAwMGVnw7fCnmQhNFx1MDAwZsKQJz5cdTAwMTBoJVbCnlx1MDAxZsKkVUbDo1x1MDAxYcODw5pcdTAwMWZcdTAwMWYtXFx2a1xcdsKXw4tcdTAwMWVcXGbClcOswr3DmcO5NcOpOMKYO8OYw4jCqXbCoiRcdTAwMDPCqMKLXHUwMDEww4pQwovCp1x1MDAxN0BcXHbDgsKlwpXCr8KVXHUwMDE3woE0VXRBM8KpwojDiFc+QsO4Oj1AXFxiUz19MEB4QMK4XHUwMDAxdj7DoFx1MDAxOcK3OkhHO05+wqdcdTAwMTlTwqbCg8O9eVx1MDAxMsKNwphMXHUwMDE2XHUwMDAxw5ZQXHUwMDA2QU9NZlxcXCImw43CocOmw7h3XHUwMDE5w6zDi3HDpi9cdTAwMGbClcOmwofCoHlcdTAwMWRcdTAwMTjCmENcdTAwMTMnXHUwMDAxfFxcdFx1MDAwNcKIXHUwMDBmXFxmPUrCv8KFMTlcdTAwMTjCiVxcYsKoXHUwMDFlcMKKXHUwMDE4XHUwMDFiR8K5w4lJXFx0XFxcXMOxXHUwMDEwbsK/XHUwMDA3XFxcIj19eT19XHUwMDE1eMOWwp1cXGLCnlxcZm1ZwqXCjCnDj8KlUWTDgMKnaVvCisOZwqZcdTAwMWTCjMKXw5dcdTAwMTBjw49cdTAwMTDDt0RHeMO3w7Arw6xcdTAwMTDDt8KFwrFgw5lcXHbCucKXKMOFY8Obw4PDp2DDjyPDh3jCj8Odw6vCr8OEXHUwMDEwwrlvwp3DhcKNwpfDgF5Rw5/DmcKUXHUwMDE4w5fCiFxcdMKWXHUwMDE3w6TDlyPCiMOxw5jCkMOfwqMxw4VZwqPDh8KSKCVcdTAwMTR+XHUwMDFkIG9Bw4VZMlx1MDAwNcOETVxcYsOeYTnCh1x1MDAxZcOSwqPDvT1KQcO3PU3CicOmwpXDiFxcXFxcdTAwMTF1XHUwMDFkTVx1MDAwMVxcdMO3w5VcdTAwMTgpwpdIwqd8wrRcdTAwMTd7w4HCjcKtUFx1MDAxY8KCw4HDrcK0XHUwMDE2Wy9/IMO7YjfCoMOvwqDClyDCh8OhSFx1MDAwNWDDvsKyN8KEwo/DtMK4wqLClcOraMKfw6HCi8OTRMKlwqDDtXdxIMOQXHUwMDEzKsKgwqQ9QGogPUp7wqHCoMOMXHUwMDE2worCoFx1MDAxYlLCsFx1MDAxZsOUIcKPw43CiTDDmsOHJ8KtXHUwMDAzw5jDjMKLwpYow7M7XHUwMDE2wqLCr8O7XHUwMDE2KMK7wo1cdTAwMDLDpsKPwo1cdTAwMDPDvznCjcKCwqVcdTAwMWRiPUBKX8K7w7dcdTAwMDRbwrtfI8OGw7Agwp3Ds8KOw4FcdTAwMGV5wpBNOHfCi1EnVMKKwpnDpMOBw5rCncK1w7RcdTAwMDLCj8KxbsKWw6vDvlTCoMKyXFxiwp4gXHUwMDEyXFx2wpTDoMKXdjdlXHUwMDFkwoVXJcKea0fCpVxcdMKbYMOFwp3CkzjDpVPCj0jDhVnDn8KqwqfDnMKQSyXDrMKNW8KFwp/CnTPCpVLClUPChU/DqcKswqfDoMKYT8Klw7HDncOIwrfDpcObw4RXw4PDvsOqwoRyw5fCjVHDlsKGw7nChGXCmcKOw7XDucKXwow9TcKNw6HDmlx1MDAwMcOowpbCj8O5w79ew5xrMGVcdTAwMDJ7w6XCocOcR8Kow6VcdTAwMDJJw6HCocOdXHUwMDFkw70gw5x3XHUwMDA3JVx1MDAwMsO6YzFcdTAwMDLClsONbcOWXHUwMDE0w5jDrcOWXcKdwr7Cl8OnwqTCtsKnQcKlwqzDhyDDqMODwod8wqzCgz19I0A9QMKMw7NTwqDDl1x1MDAxM0PCoFxcdsO4w51cdTAwMTbCmSFcdTAwMWRcdTAwMTbDt31BwoJcdTAwMWTDunVcdTAwMTbDnSDDtcOWcCZ/ID1Kw4XClVx1MDAxNlx1MDAwM8OGYD1AXHUwMDE5IcKfPUB7wp7CvcOHWMKlw4VcdTAwMWbDiVx1MDAwN8O4wpDDk1xcYsKPJcOAXHUwMDA2wo3DpcKeScOaPU3CgGnCjsK3dkjDncKrXHUwMDE1w4nDmmHDt8OJw5xXRcOJw5vDlMOAWcKCwqA9TXUgwrQjwpU9QMKNJ0XDgFxcXFzCo8OxwoTDmMKow7nCmMO6J8OyeMKHXHUwMDFjwrNcdTAwMDfDi8O8w7PDpMO4JMOsw5TDtcKmwo0tw7XDqcOdw5dpwqjDmlx1MDAwNcOdwqjDmyHCiCbCkMOxw7DCnsOdw6BcdTAwMDEpw5prwqvDp1x1MDAxNsOrwo3CqcKDXHUwMDFhwrtcXGY9TcKXPsKoe3E9TcKnwqh8XHUwMDAyXHUwMDE0wrk+SMOmwolEKcOGTsKtw63Dt8KPwptcXFwiZ8KDJsKNw6hGIDLCvsOxcGdcdTAwMWPCosOtwogvwqZowq/CsVx1MDAxMUJcdTAwMWHCm8KRVUnCqcOFWMOqwrVcdTAwMDc/XHUwMDFiXHUwMDFmwqHCtMKiXHUwMDExRE/ClmN0Q8KlcsOTPUphJX/DmsO1bn/DlsOVw5fCsMOBw4l9w63CpTTDv8KbwrzDnzBcXGLCn8KFLVnDlj1Aw650w5jChFx1MDAwMlx1MDAwZcOTQMOoWnlFVcKiXHUwMDE1PUpxwpnCnsKaXHUwMDFhfMKHRlx1MDAxNsOVwrFJwqjDusOtXFxcXFVcdTAwMWVcdTAwMWJzaS3Dllx1MDAxY8O7KsKhWF3DrnNocGJcdTAwMTfDlzsow6XDukLChcKjw4M9SsKxeXfDmm/Dh1NcdTAwMTjCoFxcXFzDrcKbXHUwMDE3wpDCosKew4Njw6jCj8KQwqvDicOJw53DqsOMNnXDpn/DrzTDsVx1MDAxOMOhw6zClUzDl8KbwoTDgV/DsFx1MDAxZmDCosOHw7pANcOIXHUwMDAyXFxmaMK7R1hhw5/DscO9eVx1MDAwNMKNw5/CojHClsO9XHUwMDExwqrDucOWXHUwMDEzwrFcXHQ2wqDDrsK1XHUwMDE4Y1xcZsO9wq8nwpvCs8KwPX1ow5pcdTAwMDUzXHUwMDExN8Kdw7DCscKJY8KNe8O/KsKmXHUwMDAzw6ovw5lmXHUwMDEywqxcXHTCt8Kaw6/Dt8OZwofDm8KkXHUwMDBmaiZwwpE6cMOlMcKLXHUwMDE3amHDhifDujc5w4NcXGbCuMKBw7XCpT1KXHUwMDA2w79IXFxcIsOWw51RwojCoMOwPX3DqcK0XHUwMDFjw6wlXFxiwqNcXHbDiMOcw6tcXFwiwr7DnGHDgMKIXHUwMDExwrfChcOGwq/DoiXDjjphwrfCjFx1MDAxYcKtUTbDiMOIwrdcdTAwMWFcdTAwMTBIwq7Cp8KQIz1KwppHwolcdTAwMDbDm8O7QcOpwppcdTAwMWPDrVx1MDAxYsOxJ8KawqLDimnCkFx1MDAwNSbCm23CniooI2Yqw4nDtEbCrMKPwqk2w6tRw7QsXHUwMDFiRVx1MDAxM0rChmFVMsOZezfDsMKAw7XCrMObw5NrMsOIw6FgLnnDoELCtMKFw6A2w69fwqDDrVx1MDAxYcKzR8OtwprCvD1Nwppmwp9cdTAwMDHCmlZcdTAwMGY+wrTDpcKhwq9cXGbDrihNw5rCkcO9MsKGXFx2WjzDpWDCuMOuwo3DlnFcXHbCgUVwXFx2QcOwwovCosO+w5RawpbDlV9EwpHDt0nCt8K3wqNcXHbColx1MDAxYcOewprCpsOkZUZJw4g8wqvDn1xcdG89SlFcdTAwMWLCjcOaJMOHW8Kiw7lcdTAwMWFywqbDok88XHUwMDA1w6JvwovClMKlPiBdRMK1acO2ScK1KcO8PU3CmsKbXFxiYmZcdTAwMTjDr2LDpktMRMKxw4fCs8OwU8OYW1xcXCJcdTAwMDMkQsKmwoRPQFx1MDAxZMO1wo1cdTAwMWJcXHbDocObXFxcIsOsw4JcdTAwMWLDgsKTQ8K5wp8ld8Oqe8O1UD1Kw5jDqDPDollXOMORwofCucOtw5jDiFx1MDAxYmLCm8KHZihQw4HCqsKJwpBQworDmUUzw6LDvVc7VcO+UVxcZsO0w6nCs8KiwoZsPMKIwp5kMyHDnXTDsMKAX8Ozw6JcXGZ/XFxcXMKgOcOGwrJxwpbDiMKyw7l0w5E9Sn8zU1xcXCJUw4XCrFFCw45cXGbDusOMfsOmXHUwMDE0cFQ4wpp2w63DrcKUw71cdTAwMWHDmMK4XmZcdTAwMDNdR8O5wojDgsK4wo9cXGLDkD1NwqXCkjxcdTAwMTBXw4XCrsOBw6bDicKudcKnXFxcXFx1MDAxYcKzT0PColx1MDAwNsOFNmbCnMKaUMKIYWE9fTnCpcK8wrNxZMKRXFx2w5DDtFZmw5tXNUHDgsKOPU1RwoNcdTAwMDPCoidcdTAwMWLClsKmwobCi1xcXFxcdTAwMThpwpBcXFxcKMOnwphcXFxcYFxcXCJaQ1nCn8O1w6vDk8K/Y8Kiw6vDr0bDlsOMw4jCtcKJwrfDtcOvRFx1MDAxNcKdXHUwMDFiXHUwMDFjXHUwMDAxw6NiXHUwMDAxwps0wohhwo80w6BoZi/DvcKpw5DCikFQOUnDk8O2w611eFx1MDAwZlxcdl3DvCNiTkpJw4XCgVx1MDAxMT1Ne8ORXHUwMDFkXHUwMDFiN8OkKsKZbS9cXFwicMKDK0jCn8OeKsOFJ1LDqm3DhjXCm1x1MDAxZMOObGbCnX1LXFxiXHUwMDFjw5I6wpXClUFcXHbCpcOLb1xcXCLCncKfO8K4ZMKIwq7Dv8OoPsKLTVx1MDAxNcKMZl/DpEJcdTAwMDXDuVXDsDhXw6/DoibChVtgw51Uw6tcdTAwMDTCu09iw6DDkC7CqWfCgsKsXHUwMDE5w6lSw6tcdTAwMTREfVx1MDAxYlTDicOTYlnClVTCiMOdwpxUPUBoZT9pI2Y/KT1AVcOvMyjDj8KCacOdPsOFWVPDr33CucOBwozDvcKRw4/CgnHDizbDsWTDgFxcdsO4w5pcXFxcwqbDncOKNsO1w5hWw61fw7HDtVx1MDAxYcOCccKPYlx1MDAxOcKZQ8KowozChsK4woFbXHUwMDBmwqI9TVxcXCLCnFx1MDAwNsKHwoTCuFx1MDAwMcOYVsOxwrU4wr89TcOFYcO0wptcXGbDkcKcwrbCoj9iXHUwMDA3w4wsaVx1MDAxZsOYw6rChcOxfj1Kwo3Cgz9cdTAwMDLCinAvw6jCgsKJwqvDuVx1MDAxNsOXw6p0XHUwMDExVVx1MDAxYcKwMT/CosOwXHUwMDExNMKmenTCrsKHw55uw6LDscKEwq5fZm7DolrCgsKuwpfDsMK0w5rCj8OUMsKRQcKyw5pcdTAwMTbCnjvCqF3CicKuXHUwMDFmwoDCtVx1MDAxYcO8w5dMRsOhecKuXHUwMDFkecKyXHUwMDFhw4fDnUxmPU3DhDLCgcOfwrVcdTAwMWHCr3FMZijCrzI1XFx0wrNcdTAwMWHDjsO5TCYmw4UyYSg8XFx2PU1cdTAwMDdcdTAwMWHChsOZMsOJIzXDscKnTFx1MDAwNjfCp8KJeVx1MDAxMiVgwqBrw4k/JMOmw7DDulxcdMOfwqJKbD1NWMK1esO1OzvCtFx1MDAwM1Jsw6DDnW/DslBxwq7DjHHCtTpISmzCjcK/b8OyXHUwMDE0N1x1MDAxZVx1MDAwNcKbL8K0wofChsKrWE7CgcOKwp5cdTAwMDE0XHUwMDBlXHUwMDA1woHCuHDCiFJxw7VcdTAwMTDCv03Dt8O7XHUwMDBmXHUwMDEyw5xkXHUwMDFlf1x1MDAwNcO0w7pcdTAwMTVcdTAwMDPCj1Jew4o2wqdcdTAwMThUb8KBwqHDgMOMw6HDm8OPw7LDicKJwrRIR8OCwrQ4w694b1x1MDAwMVx1MDAxM8OTw5Ipw5A8wp7Dt8OpLlx1MDAxN1x1MDAxNVJwOcORQMONXFx2XHUwMDE0w69ywpDClTvCvFx1MDAxYlbCrF41w7vCtcKybMKeXHUwMDE4wpsrJGPDmyo/w6bDtXErw4MjwpJcXGYlZsKeaV85wpfCpmQvw4dEZS/Co8KIw7dvZsK+wrUwXHUwMDE4w7Rrw7FcdTAwMWbCncO6w6RcdTAwMTTDs1x1MDAxMsOvJcKWXsKVfmDChMOmWTXDu1x1MDAxNMKDXHUwMDEywqDCoFB8w6XDgsKrOMOFwpDDisK1L8K9ejJcXFwiYGbCn8O9eyfDrl5ewqN5VGQgZS/Cv1tTXHUwMDEycsO/bl4jflxcXFxcdTAwMDRuT8ONwpJcdTAwMTlOw57Dmko7N1xcdMODwqpcdTAwMTDCn8Ouw43Cm1x1MDAxNFx1MDAxYsKSw4HCmUbChMOCZytzw5lGwrk+woTCjMO7w6TCgVvDksK/QcKtwoBcdTAwMDJxw41pw6s9TXrCmVx1MDAxY8KCw57DoEw0w6fChkTCs1x1MDAwNMOgwrlrc8O3O8KSJ8O/wppeXHUwMDExw6vCksKOXHUwMDFkZDY/wp7CuGxPw6lww4zCq2dNw7rCuMOpw4tcdTAwMTLDs1xcdFxcdlx1MDAxMsKAw7laXlx1MDAxMSF6w64pRMKscMOpN3A9fUkxw4vDilx1MDAxNcKrXHUwMDEyecO1On7Dp1Eqw6fChlx1MDAxN8K5dsKVJ8K6XHUwMDAxwo7CiV7CmsK2OcO8XHUwMDFhblx1MDAxMsOYaMKtwpDCoMKlTVx1MDAxNcOlwq3Du8KrJ8KIw7LCl8OYUVx1MDAwNMOHXHUwMDE2wqvDtsOnXHUwMDA2w7vCjE9hTiXCjkpUXHUwMDA1XHUwMDBmwrTDpHTCh8O6w57DiityecO3Q8OHw6RcdTAwMDVJwrNERnvCjsKMaT7Cllx1MDAxM8Kqw4zCiVx1MDAwMsOLL0XClsO7JTNgUsKBw7lEwoNcdTAwMDfDmm7DpmQ1wo7Dq8OCw43CrFnDkHLCkMONM8OkW1x1MDAwNELDp8OKwrbCusOaw7MqZ8K3w7xxYVNnw47DoXcxRzLDv3BcdTAwMDXDqcKSw4xcXGLDr0TCklxcdGrCn8KeXHUwMDBmw5BURMK/w5XCrCbCvsK+w7vDkMOXwrTDksO2ccKqw5hcXGJcXHbDi3/CgzRcdTAwMTJXV8K5w4TDgcOywqzCmXQwc0nCvGw/K15cXFxcXHUwMDA2XHUwMDAyw7HCjklcdTAwMTXCi8Okw5nCn1vDgWTCqFxcXFxZaMKpwo3DrMKkZEPCp8OjeXbCusO8wqXDkG1cdTAwMTc3XHUwMDFkez1NT33Djlx1MDAxYsK2w5N/wqfDrMKCNEhcXFxcwo3Dj1x1MDAxOVsgwofDocODd0nCmFrCgUnDn1xcXFzDpcOZwobCi3BJw6fDsj1KwrdcdTAwMTHDgsOpw515XcOkfXhcXFxcXHUwMDA0wrvDtzZcdTAwMGbCm8K2XHUwMDEzw7pjw7ZeKVx1MDAwMsO5w5bDqcOowrHCg8Okw43Cs1x1MDAwM1rCp2XDvWTCmFXCjcO9wqk9fcOdwrnChMO5wr7ChsKJw63DtsKCw6HCtMKjwrzDn8OGw4NcdTAwMTnDo8KuwoNRw6fCusO7w6lcXFxcw4HCu8KHZsK1w7NCwoXDtW5EwoBdwoFJwoFcXFxcwrF6U8ONwrRcdTAwMWTDgz1Nwq3DncODwrUxfcODesOxLsKQXHUwMDA2wrDCksOQeV3CrDPDhTvDtE7CpzXCjiw9TcKmQsOPwrXDiMO2T8KRwoHCkMOrw5zCqMO2wr7CmFXCkMKEw5Yzwp09TcKuWH3CksOKw7jCssK0LzbCp3XCsFvCtFx1MDAxNzt4eyRWw55lXHUwMDFifsOCwrzCoHVibCfDpnpcXHZcdTAwMDJ7XFx2wrvDosOHw6zClFx1MDAxM8Ofw6xvw4VBNFx1MDAwZi3DlcKvXHUwMDE0w4HDnMKufcKPw63CrzVDOVxcdsOQLE3Ci8O5wqBTXFx2w49cdTAwMTDCgFx1MDAxOXLCtX9cXGIzw7RLXFxiwpHDoUhJVsOGRMKjwrZBXFxcIlx1MDAwZsOiJMONw449fcONwpDCl2dcXHbClSNcdTAwMTLDrlx1MDAxZFx1MDAxYsOmwpA1woXDtVx1MDAxMMKPw4d2XHUwMDFkXHUwMDAxbT1Nw4RcXHR3w7fCmT1AwpnDksKXIFx1MDAxNcKHw7zCpkvCpG3CncO3w4tcdTAwMDfDt3vDlMO3w7dcdTAwMDTCk8OBw4RcdTAwMTXDhVx1MDAxOV7DicKAwqdcdTAwMDPDhsOIXHUwMDFhw5/Co1xcZlx1MDAxOMOoXHUwMDEww4tcdTAwMGbCnMKWw4TDgzxcdTAwMDXCp8KEwq0nw4LDlsO5IMOBW8KNwqHDmMOhwovDrcKvJ8KDw79lLVx1MDAwM0VcdTAwMDPCrVx1MDAwM0RDacKAwplvWsKFwoxhwrzCh8Kcwo42RWNOw4BcdTAwMDfDv8OEw7I9QG/Dj8OdXHUwMDE3OVHDncK/wpvCr8KWXHUwMDFiwr1cXFxcYMKMwoE/woVcdTAwMWbDqMOEXHUwMDFmw5rDg8OzeHPDgsO3woTDmMOEw7E4w6PDqMK6w6dUw6HCvlx1MDAwN1x1MDAxOcOfwqwnwr7Cg8O5XHUwMDEww5nCk8KKwq/CgT1Aw51owofDhVx1MDAwMmbDtcKXwpbClVx1MDAxMjhgw47CikHCpcKpw7/CiMOgw4Jnw6pEwp5GwpDCuVx1MDAxZkfCjcKxQ8ObXHUwMDE2wqPCuUA9QMKUXHUwMDFlQ2BQJ2bDhXrCm8Kzwp/CiMKiwr9nw5vDqMK3w48gXHUwMDA2wo7DqUbCmcKRwpXDuVxcYsKNS8KKwrfDl8OkOMOgXFxmw7fCkcKWPU3Dt8OBwpbCoVx1MDAwNUXDoCNcdTAwMWPCpSBcdTAwMDdcdTAwMTN5wpZcdTAwMWLDu1nClibDuFx1MDAxOVx1MDAxNsOUw7/DqcKCw63Cg1x1MDAwN1x1MDAxNsK9JsKIYMOVacKvw49cdTAwMDHDvVx1MDAwMnvCh0TDqcOUwrzDqydkwo/Cm8Khw5ZmSMKoaytFw6VcdTAwMWHCm1x1MDAxMFQrNsK5UlxcdsO2PsKPw5bCnXMvZSB9w61lXHUwMDExw5I9TS9cdTAwMTlfXHUwMDFhXHUwMDE3wopXwobDonNFXHUwMDExKMO/w6tRTVx1MDAxZsKawozCvWg4wr1cXFxcw67DncOwQsKLXFxiwoDCjcKmI8ORM8OoPMKKwrDCozXDt8KbXHUwMDAzLTXClsKTwpPCr8KlUcKDwo3Dk2dgXHUwMDAyI8OFV8OYSMKSwrnDpVx1MDAxZEZcdTAwMWEmw6cnWiRcdTAwMTLCslx1MDAwZsKXw4ZcdTAwMWFcdTAwMWQzw7jDosKXw7MqwqZcdTAwMTPCrDXDqD1AXHUwMDE3wrRcdTAwMTlcdTAwMDU5w6zCmcOww6RcXHbCicO/XHUwMDE4woLClMOhMcOAw6k9TcKzw4/CpcOnXHUwMDFhQX3CmVx1MDAwNlx1MDAxNFHDrsOVPENmw5w8XFx2w6FcdTAwMWZoYlx1MDAxN8OKWWjCocOvOcO9w7kmw5vDuMK5KlZXQcKyw7nCkjBcXHZyw53CisKmw7JLLmnCn0fCtMKZwqM4w63CncKvw61bOcKvXFxmKsKQLkA4SMKzZTHCt8Osw7snw63CmsKzXHUwMDBmwpJmfmFGwolcXGZvPUrCicOpTVx1MDAxYcOfw4HCjcKawpLChU7DuGM8wq9cdTAwMDdFw7BcXGbDv389TVx1MDAxYcOkw67CksO2XFxcIsOwPUosw43Cglx1MDAxNiVVQMKZw6JgSFlcdTAwMDNiK8KVQMOwwotcdTAwMWTDqsKiwqZ2TStcXHTCpcOGwqpvwoU9fcKbwo3CgDzCuEIqw6DDs1x1MDAwMcKOwpbDp8KhTDjDs3TDq1nDl31cdTAwMWJcdTAwMTlxw5PDosKce0RYN3LDscKZw6jDjz1Nw71cdTAwMTVQwovDr8KLQ1xcXCJcdTAwMGVcdTAwMDE2JsKiwqNQeCDDtMOsw41cdTAwMTjCkVxcdsKfb1x1MDAwM2LChsKnXFxcXHhcdTAwMDNoQ8KWwr5GXHUwMDA2wqJNMVxcdHjDtsOvW8OHw6NcdTAwMDLDlcKeNMO4wr/DuMOtw6ddXHUwMDFkXHUwMDFhwo1raMKAw4XCvcK5w4FcdTAwMWI0wppwwp8rw4hcXHR9wqrDk1PCilXDplLDrlx1MDAxMUzCtMOaXHUwMDE4w5NMw6bDmcKJW8KIw6bDjkJJXHUwMDE5VMOww6DDm09cXFwiXFxiXHUwMDFiPMKmf8KhVMOAw7TDhcK0dVh3w694UMOPXHUwMDAyXFxcXMOhPsK5Z8KDwrRZVMOAXFx2w6zDslxcXFxGw6HDkDZ5wqXChMKwZcO2w7XCm3tsYzjChH3CuHHDoMOBPU3Co8K0P8KCw7DDkSxcdTAwMTnDs8OTw6rCtURUwpo9TcOvNCY9TXUvWMO6O8KLZVk7woDCt0DCi8KxTDtYwohSw6zDqcOhwrNcdTAwMWEgwpA7w4hcXHRUw6zDhUnCtVx1MDAxYXHCksK5fcOowrXDmlx1MDAwNEliwrBgXFxcIkfDnsOpWcOrw5nDp1x1MDAwZsK/MmPCiD7Di8Ocwp9Mw55efcKudEZvw5JcXHRcdTAwMWQ0w57CocKYLzxiwoBKw758wrhwOVdxw6tBw7TCulx1MDAxNz1KXFxcXFx1MDAxZcKVbVPClFx1MDAxOMOFwrRUw63DqsKpw6XDjC5DXFx0VHBmXHUwMDAzwozDjlxcdnrCriwtNcO7w7jDsixeTGBJwqNuwqvCqV/CkjTDvMKaw7ZvwrA0Y8OSXFx2wphgXHUwMDA0XHUwMDA2wrrCr8Kmw4xde8KvSi3Cj1x1MDAxNnVxwqRNw73DusOcw5FTXHUwMDEywpUkbsOuw6ZzbMOdwo09fcO7w6XCnVx1MDAxYlLDtVA4woPCgcK2ccOgw4HCjcO6Nlx1MDAwZsKSPkhmQMKXVsK4bsOdXHUwMDAxcErDvVx1MDAxMMO7w5JcdTAwMWEkUsOeXHUwMDFiXFx2MsO+JsKiYsKkwprCkVLDvMOiOsK2w7TCoDHDjChcdTAwMWQswrrCmcOcScOkYMOqMcKnXFxcIlPCrsKgwpNaXHUwMDFjdVx1MDAxZG53w4RcdTAwMThyXHUwMDFmXHUwMDEyalx1MDAxYVx1MDAxZsOlSsOlwqF4csOVw7I7d1x1MDAxNsObccKtw5BcdTAwMDTDjFx1MDAxZsOHwoBcdTAwMTLChsOGL2TCo1xcYj5cdTAwMTfDnl9wwrfDvTbDusOXXHUwMDA1w6TCksOSw6Ngw5x5w71qwrXDocOUw4x3R3TDkn5twqpmwqc+esKZwrRWwqTCh1XCr0YtJcOCw4JcdTAwMDZYwpAjw6zCmcK2XHUwMDBmPUDCucO2wrrCp8OZQ1x1MDAxOSd5w4NcXHZcdTAwMDVJwqopXHUwMDE0YMKdw5vDnsK/wotNWVxcXFx5wpZ5XWPCiXlawrEhScKMKMKOXHUwMDE4wovDlMK2w6FdwrVYwpbCjlx1MDAxY1xcXFw9QFrDg1x1MDAxY8O1w4PDncOVQVpcdTAwMTFHwpBbcTl2wpHDuHnDiMO0w4LCj8KOW8KUw5tcdTAwMWLCtsOHwqliw73ClUTDssOCKFx1MDAxZcKKw5Z5ZVrDhcKQRF3CuGvClHZ+w4lewr3Dh1x1MDAxZXvCosOUI8KwXHUwMDFhw6hcdTAwMWM7XFx2PU3Dkl/DrGlVw5EzeVx1MDAxNkZTw4bCksOSWcKGw7PDqVx1MDAxMsKXw6nCn8OawqF1wpslW8OxwqpcdTAwMDY9fXvCocOIw4lCwojCj8O9w6Zuwo/CpsOdPUDDusOkXHUwMDEwwpLDo3fDt8KDw7FcdTAwMDPCkFx1MDAxZMOewqXDt00uXFx0w4XDicKxw7PDnXhVXlx1MDAwM8KJwqHDtlx1MDAwMsO3w5R4XHUwMDE2QMKJwplgwqN8MkVkVcK8w6fDpFjCs0fDv8K+w604XHUwMDAzwofDuFTCr8O5wopFWMO2wpDCv2ZAw5tcdTAwMTRcdTAwMTXCgcOaU8O8wpXCg2bCi13CpcKhXFx0OGDDp8KZWVx1MDAxNTrCmsKuw6fChcOzw5wgMcO5w5o5ZFjDm8OFw4/DmcOdbcK2XHUwMDE4w5ovwrjCuVx1MDAwMlnDmMO5XHUwMDAzbFx1MDAxMcOhXHUwMDE2c1x1MDAxZMO5XHUwMDE2woYoOcOgKMKfYcKlXcOAw6xIaMO8XFxcIsKrwrtGw5gpw4vCqsONw7k1XHUwMDFhw5lvw7RiwozDlkRIw4/DjcKzw5nDoMKUPU3Dh3/CpMOiw5fDiUs9QMOpwpjCtsOdw5zDt1x1MDAxYThDdcKmwqLDm1/DuGHDmsOtXHUwMDExXHUwMDE1R1x1MDAxYcKMw7coXFxcIlxcXCI2wpHClidcdTAwMDMvSUhfMsK5XHUwMDAzXHUwMDE4wrjDiSlcdTAwMWLDrm3CscKiPU1cdTAwMTZEMMOlwo1JZiVdXHUwMDFlPU3CnsKwPUosw6FKwqbCqcKiMsO4wrJIwrB/PU1sXHUwMDFiKFx1MDAxMsK7w4IzN8Otw5VcdTAwMDbDrFx1MDAxYsKoXHUwMDE3W8Kiw7TDsXLCpiBcdTAwMDLCgsOmw55MRMOhwqPDrlxcZsOuw6E9TcObw7HCrGJcdTAwMTY9TcOCwqp9eVBcXGbDv0vDs1xcXCJcdTAwMDTCr8KzXFxcIsOnWj9pXFx0w4DCsMOhXHUwMDFjUMKLw4VcXFwiNkbDm109fcOFwqbDtMOsfcOXUD1Nw5vDjcKdXHUwMDFhwrgmwobDhmTCkTRAw5fDtsOtw5lcdTAwMTVcdTAwMWRcdTAwMWLDvMOvL8Oiw4zDnDpZdVbCrGTDmkJlw7PCvz1KwrBcdTAwMWRPwoLDkcKMVMKIwozCgcK0wr9YwqvDl0nCgcKwwpnDqVfDrcOkXHUwMDEzXHUwMDBmw4LCo37CuMKnLFXDmlxcdsOQNMKmXHUwMDBmwpEvOMKPbsKiXHUwMDFmfjtow55twq7CgcKIQcKLKTlMwqYqWsOmL1x1MDAxYcOlLsOww5LCgMOZwqzCm1V1O1x1MDAxY8OCwoDCq8KkIcK/TcKew6I2XHUwMDAzw7lZb1xcdMOmw5DDjMKFw7HCtMK7w4R0OyRcdTAwMTPCiMKqwpg5w7RtNMOmwoZcdTAwMWXCj8KZYFx1MDAxNMKcw7huNcKUw7zCu8O9KD4+wqhiM39ZwrDCm8KsPUpcdTAwMWLCknIlYk7Dt25MwrHDtMO7wpJcXGbDhDvCksOsw5zDi1x1MDAxMnRwSsOEwo5cdTAwMTbCscOkwqAzwrvCucObUXzDtETCssKGwoBlw4tcdTAwMDTDhyBcdTAwMTLCp8KtP2wjw5BSw7XDuypPwoY9QGx0TX97XHUwMDA0e2jDtDrDssOMKMKdKFxcXFzCucKYwqfCj8OowqbCp8OvwrJcXGJcdTAwMDbCkcOgRsOow7DDtnZmw6/CtsKiwqnCusObwrnCksKOw6w9QMOYwpDCpMOZw7fCkcOcwoh4wo3DmMKHw7bCijxcdTAwMDHCsFvDuMONXHUwMDA2w4PDhUfCsMO2w4FbfHbCjMKEw5XDmsK2woRPw54mPX1WXlx1MDAwMsKeXHUwMDA2JcKFe1x1MDAwZVx1MDAxYsKOXFx2w4E9fcOxeVBfw5HCuFxcdFx1MDAwNMOWXHUwMDAzJsOawoMkwrksw4VRw5zCijHDqEDDnMOFRsOxw5w9QE3DkMOaXHUwMDE0XHUwMDEwX8KWw4dcdTAwMTbCjMKgwopcdTAwMTXChCDCoFx1MDAwM3g9QH9cdTAwMWJSw5XCicKkw4DCt2PCqcOHw6ckXHUwMDEzO2VcdTAwMTRcdTAwMWTChSAmw6NJXHUwMDE2wqzDjVohw5luOMKFw4RTXFxmw6PCpcO+wprCtMOfOGjCgMKPwrLCgcOew4LCi8OXw4E9QMKiXHUwMDEywqUxRsKjw71Dw7HDlkjCrsOROVx1MDAxYsOsw6fCgUNcdTAwMDZdw7pJw4lSM8OsXHUwMDBmXHUwMDFmw63Cmlx1MDAxZsO0wrtcdTAwMDJOWUbDmcOhwrPDrHPCscOMXHUwMDFiYz1NM1x1MDAwMmNoK8OVdnfDsMKhXXzDmybDinNcdTAwMDJcdTAwMGXCoFDCmEZgQ8Olw5nDssOvwrPDsVx1MDAxY1x1MDAxYcOvw6cvwoLDpcOMMileWMOrwpB1w5BsScOYPsK5XHUwMDE1WMOtXHUwMDA3XHUwMDE5w7TDm1x1MDAxY1x1MDAxODTDhklSw6xUwqVvXFxcIlx1MDAwNFE7KMO5w5RcdTAwMDQpQFx1MDAwMcOAJlx1MDAwM8Kbw4nDu1x1MDAxYVPDj2B7QcOSw7HCvlx1MDAxOcObwrfDnsKKL1fDqMKKMcORw7PCkT19wqZkU2jCl2pcdTAwMDUmXHUwMDExw7Qpw6fDjT7DmMK9OcOJXHUwMDEww70twpLCsDjDkHHDuynDmCZcXHRlZMKLIFsjWlx1MDAxYcKzw4w9TVx1MDAxMj5kwr0owqFcdTAwMGYpXFxiWyrDmMK9eUbCpsOQw7rDr8KeL2fDh8KWJMOmwrNARsK7w5vCvykpXHUwMDFjw7nCgG/DscO6w65cdTAwMDbDvFx1MDAwNMOww7hcXGLDi8OJwo3CqVHDkStYw5gtMcOjw6PDpcKlwqQ3IEBcXFxcMiMkIzE2MzY0w5zDv17DncKdSFx1MDAwZVNcdTAwMWVcdTAwMWJFPD5cXFxcwpZcXFwiwrJ7w43DsW7Ct8K1wrPDhzrDiWJbX2dNXWXCkXRre3PCk8KDb8OPw5fCuMK3w5XDocKpw7LDslx1MDAxYcOSw4IzM8OzU1x1MDAxM0PCvVx1MDAxZDR1w7RUw5TDkFx1MDAwMcO4w4jDocKaw7PDnMK/XHUwMDFmwpVhwpjCk1x1MDAwNsOjwpVcdTAwMTnCqDXDrSvDqE3DsE/Cj3ZTw5jDksOIY8KhXFx2w7zCv8KVYVx1MDAxOVx1MDAwMsKdPUrCklx1MDAxZMOzXHUwMDFkwoHCmVxcYsKnXFxcIlx1MDAxZVx1MDAwZsOFw7lpKMKSw4PCo8K3dsOyU8OZwoXDnMKQw7XDmG3Dt8ORWcOgXFxiwqUoKFx1MDAwNUlfNT5jw5PCniDCtMO3wqXCucOJw6c9QChcXFwiw7/DscKYZz19IcKLW1x1MDAxMy/Cv8OdQMOXwoTDqcKXXHUwMDAxwqvDjVx1MDAxNsKvw6BlwrnCicOoXHUwMDE5JsO7w5HClFx1MDAxM2VYw6XCnMOrXHUwMDA0w5DDjcKRwoRcdTAwMTlnwqUhw5/ChcKKYV7Dn8KcI3jCpidcdTAwMTPDgWjDiMOtw7JcdTAwMTbCg0XCucOfaCnDk8KSPX3Cvn7DpMKKw73Di8KdXHUwMDE3WcOoXHUwMDFlXHUwMDFjJMKvXHUwMDBmw7hcdTAwMDXCoMOcJ8Knw4kmwqrCksO7ZCZcdTAwMWHDgcOGwpXChsO3IMO1XHUwMDE5XHUwMDBlw4fDjHRcdTAwMTXCuVx1MDAwNiRSYVrDi8KYwoHChcORw5ZcdTAwMTHDjlx1MDAwZlHCicO1OMOIXHUwMDA2wppcdTAwMTPDhcOWwqVcdTAwMTRcXGY9TUfDnFxcYsOjXHUwMDE1w5knw4BcdTAwMWLDh8Okw6Vtw7DCicKeMlx1MDAxMMK1ckxeT8KpXHUwMDE1PUpcdTAwMTlcdTAwMTLDu8ONJSDCl8OVO8KEJ2VcdTAwMDMzwqnDl8OXw5dcdTAwMTHDuEfCiD1KwpF1XHUwMDE4wrpcdTAwMDbCn8Oew4/Dj1x1MDAwZlx1MDAxYVxcdsOHw53CpsOWw7NHwrzDpcKEw5nChsOjw7zDvMKcworDqMOJV8OjbcKcQSNNwqEkXHUwMDA0wrplTsKhwofDo8KiXHUwMDFiXFxmwrM9fcKlXHUwMDEwJFx1MDAwM3RcdTAwMTg9Sih4w4dkwp9cdTAwMGVyw73ClsKJRcKcwrFcdTAwMGXDmMK1XHUwMDExw7jDh2XCqMKmIUZpwoXDtMKhbU1XYsKUQXnDqzzDkl5cdTAwMDNDw43CvFx1MDAxNMOKwqZcdTAwMTLCn8OeOS89fcK6XHUwMDEzwqIkTsOXasOPKz7Cllx1MDAxM8ODw5p3XHUwMDA2dlx1MDAxNDc/Nn3CusKswovCk1cvZMK3w6gqw5XCtFx1MDAwZXrCl8K+XcOnKsKMwrBBwqrDmMK4w4whw7rDjcOSZ8K+VMOHbcOhw7vDpFpJXHUwMDEwWFx1MDAwZmvDmcOKZ8OSP8O+wpnClFbCp8KuSDV1wq5cdTAwMTPCrChcXGLDj8KPwooow7RDwoLDvMOVw4TDoMOOw5TDk0F+KsOnwrM4KsKWw7PDusOzXHUwMDFlQ8KEwrvDtMOOw5h6J1x1MDAxMmPCnmnClDhcdTAwMWbCq0R4XHUwMDE5w47CsX1lwotbw7J2JDTDl3NcdTAwMGZ9w6HDksKrXHUwMDFlPMKkSsOfwq4keG/DujFcdTAwMTIyXHUwMDE0KsOPc1x1MDAxMcO9w6HCkm3DlMK2wqRywqPDvcOVwpPCmcKUX8O/bcOvw7xRXHUwMDEywoJcdTAwMTQuwo8yfWZJbGJrLMOuXsOCw7t/WlnDoDTDjD19wqZcdTAwMTNcdTAwMWZaV8KeZ8OuQ07DuldeOVxcZl1YbMK2akfCisOlOMKMP2xcdTAwMTJwZC7CjFDCosKeZMKnwrvCgMKtw4MlXHUwMDAxK8K7NVx1MDAxMytawqkpNcO2J1xcdHXCsWsuwq9Ew4d1wonDkVx1MDAxZkrCoD1NSMO2PU3CiXPCpWw+cEFuLEbDj8Oxa2bCr0jCh2xcXHTDjcKPSyxcdTAwMGVWbkvDtsOKw5dKw4A9TU/Drj19wpbDkMKxan7CsFZnwrtodVVrZsOyf8Kyc8OCNX3DkFx1MDAxMWzClm5SVsKFQDRbRHTCnkDCp8K/PUDCrFx1MDAxMsK6XHUwMDA1OsOLw5rCvkguwptIaUo9QD1KSmcww4wxw55cdTAwMTIsJGDCly7Dm0zCuUrCiMKLN1fCrsOSwrnCiMKyZsKSw5DDsW0mwrA7VsKoIDIgfHTDjnjDq8K4wrvDvcKKf1x1MDAxZcKTw75dXHUwMDAywrjCli1WXFxcXMOnK2zDvDxcdTAwMTN9XsOJw4RuwofDjFx1MDAxNlx1MDAxM8KDw55nX8K1wqRxN8OPw6HDvW3Dk1x1MDAxN3rCoXfDjFnDu8OaXHUwMDEyRcKfwq3CnMOLQcO7WMO+TFx1MDAxNFVfw4RcXGJxwrnDkCB7XHUwMDE0ejFcdTAwMDfDilx1MDAxZsOTw5PDvsKnw7TCtcKIb8Kle8OVworCt8K+wpIkQkd3R8ONXHUwMDFlXHUwMDEzw5NcdTAwMWXCp8KEwrh0w4vDuHs9QMKeN8KXd8O/amLCmkrDp8KvOMOOw6B6wpx6w7XDh8ONwr/Dk8KWXHUwMDE0RMO/w4nDiHEhw5FcdTAwMTB7w4nDkjtcdTAwMWVYwqQuw5/CtXzDkMOdXHUwMDEzwpXDnmB/csOfw60swp7DtcKSYcKUQ1x1MDAxZsK9wrTDjjnDu8K7w75LdMOFWMOOXHUwMDA1wpPCjcOULFTCkcKwwpjDikPDlCvCjFx1MDAwZlDDulZnwqvCjFPCjcOSP0nDvcO8OsKXwp1ETGjDkMO9QDphXHUwMDFkRsKMYWDDvCg6K013UcO7w5HCkyvDrlxcYsKGwrBcXFwiwrlcdTAwMDPDni1uw7vDpsKxcsK4R1x1MDAxZVrCssKxO8O6Q1x1MDAxZcKPwoQtTMKbwphsXsOywoxcdTAwMDQ/wozClMOoa8KGw7HCqGRGw4zCjV5cdTAwMTJmJFDClypcdTAwMWYgLcKyN8OTw5ExbcKuw7dJwrJcdTAwMWNieMOxasOWwrYrwod0acOKXHUwMDBmS8OkXHUwMDExZm7DgsO+w7xgOsORXHUwMDFkRMKMb8Ogw7xrOsKbTXnDkcOsLMKeVDpcdTAwMTXDvTRcdTAwMWJQXHUwMDFkwpNRwrJcdTAwMDQjNsK7TcOlXHUwMDEzwrs6wqnDjWx5w5DChcKTR8KyJsOjLcO7UcO1wpPCocKyXFx2Iy/Cm07CsVx1MDAxM1LCssOww7vDi8K1XHUwMDEyZcOeM8OuK2fCq8KCwr7Dn17CrMKyw4howrJUw6vCnkbDrlx1MDAxMMOCw7pMJDPDg2twXHUwMDEww41/UMOrXkHChjrCo8KMIMKFO1xcZlx1MDAxMcOgw4lSw6NUbMOZw5nDg2Blwpc7S8OZM8K7w7fDpVx1MDAxZG5yPU1cdTAwMTXCtlx1MDAxMMOYa0zCjsOpwqXCh8OdJMOxNFx1MDAwZWRcdTAwMWLCosKdXHUwMDE5wrQ0TsONw7tcXGLCpsOsw50sXHUwMDBmR1x1MDAxOMKWSMO9woTCuMOgwpfCvcKPWcOtw77DiD1Nw4nDv8KDw5XCpcKPUj1AXHUwMDAzwr53N1dtacO8R1x1MDAwMz/CscOqLsOUIcKMwoPDt3zCnlx1MDAxNMKWOiVWwp9Uw6QkVMKsXHUwMDBmXHUwMDE3U2vDvShQw5pcXGJJwrV7w5JcXGbCjsOgXHUwMDA0w45Cw5fCgFPCjVxcdC9Aw4t5w73DlVx1MDAwM8OMw45sw67CnsO5woxcdTAwMDc0w6pcdTAwMDdhwpNLXHUwMDE1wobDgMK5wrBcXHTChMO4XHUwMDEwQFx1MDAxMcOLw5NcdTAwMTg3w5ZcdTAwMWXDjlNcdTAwMTJcdTAwMWFcXGZ3XHUwMDE2IXvDo1x1MDAxMsOuw4VcdTAwMTdcdTAwMTZyw7FGXHUwMDBlXHUwMDE1w6DDgV9cdTAwMTXDtXDCnlx1MDAwM8KLw6BcdTAwMWHChkDCrDDCrcOHWmc9fcKTwqdow7fDqEjCvsKrSEXChsKMwrdJw5HDjcK1w5LCt39ZdW3CtcOMXHUwMDA1XHUwMDAzwoVUw5NcdTAwMTLChcOwbWDCqVx1MDAwZm7DnmdcdTAwMTlDdVx1MDAxNU/DjVx1MDAwNlx1MDAwNmFcdTAwMTZcdTAwMDbCo8KzcsKoXFxmUT1Aw6BlSFx1MDAwM8K2XFxcIsO4w6jCtMKzbTUkwp/DncKhIMK5USbDrVR8w5vDsj1Kwq8+wohBQsK3wrR4w7NcXGbCsMOUw5tcdTAwMTJcdTAwMTFUL8KWw55pPD/CjzNcdTAwMWHCqjE7XHUwMDEyw6jDkVxcXFwoXHUwMDA2X0RcdTAwMTjCgcOtw4NUwotcdTAwMTI8PUDDqsO3ME3Cu8KYwrNgKMKXRsK0w5hkXHUwMDEyXFx2wqvCpMOtw7rDj2UwwqJQaS7Cp1Ndw7AmwpnCq8Oyw7zDqjbCicOpO8KqLCHCgz1KwonCtz1KXHUwMDE4XHUwMDFkw53DsMK1wrXCp8O6XHUwMDFkdcOgw6LDg8KLwrrDv8KawppDXHUwMDFlNnDDucO5ZMKMXHUwMDFkwqfDiMKyIMKaw7A1XFxmXHUwMDA2w7vDrjdYXFxcIsOFw7ZKLsKuXFx2QsOrYzZcdTAwMDE6XHUwMDA2wq1cXHbCiC7DucKKwqJAa0RCw7xswrpQwrDDnjvDpi3DrcOlOsOmPX3DrcOlO1x1MDAwZSttwog6XHUwMDBlM21cXGI6XHUwMDBlO23CiDtcdTAwMGVDbVxcYjvCvittwoM6wr4zw4xyw77DqsOXZURtwoM7wr5DbVx1MDAwMztcdTAwMWEqLVk6XHUwMDFhLi3CmTpcdTAwMWEyLcOZOlx1MDAxYcK2wq7Csks9SkswwohcXFxcw6p9NsOmwo/CqsOxQsKiw7cqw7lbXHUwMDFhw4grQ8KKwrovLVxcXFzDq0pFMMKOwq5rwoA2w7I2wq1cdTAwMTZCwrpLMMKDXFxcXEp9NsOcwo9qw7BCwo7Dt8Kqw7Zbw7LDiCtHw6rDijU2XHUwMDEyLjBcdTAwMDfCimpxw4rDpcOcwrMrw4fDq8OKZTZcdTAwMTI6MMKHwoxqw5FaXHUwMDEyQC1kwrBrXHUwMDAxQsO6YzbDpMOxwqo4wozDum8wwp48wq3CmFxcXFzDisONQsKewr8rw4fDr8OKw6U2XHUwMDEyWjDCh8KQasORW1x1MDAxMmAtZMK4a1x1MDAwMUPDusKjNsOkw7kqMFrCisKrK3bCisOqMC1Cw6vCqj9LwoowLcKgwq7Cqks2woI8LMOQWsKKdTJCw63Cql9Lwoo4LSDCrsKqazbCgj4sUFvCisO9RVrCtCvDlVxcYsKqwoN2Y8O5wq9cdTAwMDPCtsK/XHUwMDBlITNcdTAwMWPDhcKKw4HChlFcdTAwMDJPIT19XHUwMDE2wrxcdTAwMTEzwqBzwqQuw6VOwqfCrMKHXHUwMDFjaMKswodcdTAwMWPCqMKswofCvEnCrMKHwrxpwqzCh8K8wonCrMKHwrzCqcKswod8SMKswod8aMKswod8wojCrMKHfMKowqzCh8OsOcKswofDrEnCrMKHw6xZwqzCh8OsacKswofDrHnCrMKHw6zCicKswofDrMKZwqzCh8OswqnCrMKHTDnCrMKHTEnCrMKHTFnCrMKHTGnCrMKHTHnCrMKHTMKJwqzCh0zCmcKswodMwqnCrMKHw4w5LsOlbmkywqDCs8OoOlx1MDAxNjwnS1x1MDAwMk8kbsOadVx1MDAxZcK1worDgVx1MDAxMkXDq1jDu2nCrMKHw4zCuS7DpW5pM8KgY8KnL1x1MDAxNjwnT1x1MDAwMk8kdsOadVx1MDAxZcOFworDgVx1MDAxMmXDq1jDu8KpwqzCh8KsMcKswofCrDnCrMKHwqxBwqzCh8KsScKswofCrFHCrMKHwqxZwqzCh8KsYcKswoc4wqnCqsKHwqxxwqzCh8KsecKswofCrMKBwqzCh2xcdTAwMGXDgsOGTVx1MDAwMcOyZ1x1MDAwZcKIXHUwMDFjNsKjw4DDjmvDvEzCk8K8w57Ds2XDssOlw7Jlw7PDpXNIcsKIcsOIclxcYnJIc8KIc8OIc1xcYnNDcsKDcsODclx1MDAwM3JDc8KDc8ODc1x1MDAwMzM5MlkyeTLCmTLCuTLDmTLDuTJcdTAwMTkyOTNZM3kzwpkzwrkzw5kzw7kzXHUwMDE5wrM2wrJWwrJ2wrLClsKywrbCssOWwrLDtsKyXHUwMDE2wrI2wrNWwrN2wrPClsKzwrbCs8OWwrPDtsKzXHUwMDE2wrM4OsKHSmRrwp7CrVx1MDAxMjLDuz/DjF1uwqHCsjg7wodMZG/CnsK1XHUwMDEyQsO7X8OMwp1uIcKyODzCh05kc8Kewr1cdTAwMTJSw7t/w4zDnW7CocKzOD19wodQZHfCnsOFXHUwMDEyYsO7wp/DjFx1MDAxZG4hMzAyQDJQMmAycDLCgDLCkDLCoDLCsDLDgDLDkDLDoDLDsDI9QDJcdTAwMTAyIDIwM0AzUDNgM3AzwoAzwpAzwqDCi8O7w6HDt8K8XFx0RsOgM8OwTyHCnVx1MDAwMlHCn8KqTmfDmMKYSsKfwq5cdTAwMGXCp8KGXHUwMDA3a1x1MDAxNDpzwqjCrsK8JsKbwp83w5PCnU4jXHUwMDExXHUwMDE0THxRc8O0w7HDv3/DjsO4wrzCvsOJw5XDtXLDh1BcXHY5woFcdTAwMDHCu2R5w6xpw5hYTsKfw4zCrsOpwobCh3NcdTAwMTR2MynDo8Okwr7DvsOTPCPCmsKfV8OTwp1PXHUwMDFjPU1cdTAwMTTCjHxRdVx1MDAwZcO1w7/Dv8OOw7jDgMOyw4nDlcO1c8OHWMO7OcOYw5hRwp/DqG7CqcOiw6DCqsOeMzwnXFxmXHUwMDA0NMO8wpByXHUwMDFlwrnClXVyw4VMw7t5w5jDl0vCl8K4bsKpw6PDoMKyw55zPCdcdTAwMTBcdTAwMDRUw7zCkHNcdTAwMWXDicKVw7Vyw4VQw6sxXHUwMDAxPUDCu2B5wqxJw5hXTsKXw4wuwonChsKFc1x1MDAwNHYzKMOiw6DCvsOew5M8wqbCnMKXV8KTwp1PXFxcIlx1MDAwZlx1MDAwNMKMw7xQdVx1MDAxYcO3w5/Dv8OOw7fDgD1Kw4nClcO1c8OFWMOTScOiw6DDiMOeI8K8JMKtw50vwrJ3SsOTwoliwoXCq1x1MDAwMjbCvCTCscOdT8Kyd0vDk8OJYsKFwq1cdTAwMDJGwrwkwrXDnW/CsndMw5NcXHRiwoXCr1x1MDAwMlbCvCTCucOdwo/CsndNw5NJY8KFwrFcdTAwMDJmwrwkwr3DncKvwrJ3TsOTwoljwoXCs1x1MDAwMnbCvCTDgcOdw4/CsndPw5PDiWPChcK1XHUwMDAywobCvCTDhcOdw6/CsndQw5NcXHRjwoXCt1x1MDAwMsKWwrwkw4nDnVx1MDAwZsKyd1HCk0liwoXCuVx1MDAwMsKmwrwgwq3DnS/Cs3dSwpPCiWLChcK7XHUwMDAywrbCvCDCscOdT8Kzd1PCk8OJYsKFwr1cdTAwMDLDhsK8IMK1w51vwrN3VMKTXFx0YsKFwr9cdTAwMDLDlsK8IMK5w53Cj8Kzd1XCk0ljwoXDgVx1MDAwMsOmwrwgwr3DncKvwrN3VsKTwoljwoXDg1x1MDAwMsO2w77Cr8KawrImwqpcdTAwMWJAwpvCpXbDmD19NsK9JXPCpXfDiFFCUFx1MDAxMzs2wr1cdTAwMWUzwrDDsyUywrDDsyUzwrBzwqgywrBzKMKywqdqXHUwMDFjdVp2XHUwMDFjeVp2w7RtWnbDtHFadsO0dVp2w7R5WnZcXFwia1p2XFxcIm1adlxcXCJvWnZcXFwicVp2XFxcInNadlxcXCJ1WnZcXFwid1p2XFxcInladlx1MDAwZWtadlx1MDAwZW1adlx1MDAwZW9adlx1MDAwZXFadlx1MDAwZXNadlx1MDAwZXVadlx1MDAwZXdadlx1MDAwZXladlx1MDAxZcKrworDglx1MDAxMjHDq1rDu0HCrMKLw4xpLsOtbsOJMsKwwrPCqDs2PX3Cp01CUCRxXHUwMDE2acOMwrkuw61uaTPCsMKzw6g8Nj19J09CUCR2WnZcdTAwMWXDhcKKw4JcdTAwMTJlw6taw7vCqcKswovCrDHCrMKLwqw5wqzCi8KsQcKswovCrEnCrMKLwqxRwqzCi8KsWcKswovCrGHCrMKLwqxpwqzCi8KsccKswovCrHnCrMKLwqzCgcKswovCrMKJwrhOIF7CocK3XHUwMDA2TcObw6HDo8KRc0Q8wqXDhnXDhcOmbcKMw5nCnVx1MDAxOVDCo8K6XHUwMDAyXHUwMDFkwoZcXGJySE8gaMOBwqF8MHPCqcKqVUVTw43DjsOpw6rCv8OHXHUwMDFhasO8w4k9SsKibcKiTlx1MDAxM8KZwprDpk1mwr5cdTAwMWVxYlxcYjxIdSRVRlx1MDAxOcKzNk4nQ3hgbnDCvCg4UWVMbXPCqcKywr1XwrvDm8OOw6nDrsOzw4hcdTAwMTLCqsOOacOvXHUwMDEzMMO7O3PCqcK1w71Hw4xtwrwoQsORwoVuw7FOJ194IcKyOHQkwp3DhsKYPEfCv1x1MDAxZSFiXHUwMDA3T2RWXHUwMDEzOcKcw6R3wp7ChsO8wolcdTAwMGXCnsOJwopqw7zDiVx1MDAwZcOaa1pMXHUwMDEzwpnCnFx1MDAwMktCwrxcdTAwMWVxY8KWO8K2cyTDlUYgMjBPJ8KDw4vDjsKpw7XCi8K/wopAwoBywq3DqsK6Lz1Kw618wq9vw7PCnMOqwp3DvzBrTMONw6rDgcOfMcOmwoNcXFxcw75qXHUwMDFhXVcrecK9UD8qwojDjXc9SmHDnMOOTMOqPU3CnirCpng0wr4xXFxcIsOhwoDCqsKxdcOBNDDCmcO/YFx1MDAxYcKBXHUwMDAzfMKNw6vDvcKfLsKmwofCtDrCj8K/M0jDjlU6wp9fRsKmdGXDq8OVw77CucK0L8Kpw74zXHUwMDFhcsO7w5rCnHIswqLCq8KEwoovPMKJXHUwMDFhNcOXMcO5wrpDw5YwfC8ow4rDkTrDpV8yJmd1w6s9TcONL1XCsT7CqsOJXHUwMDExYMOWalxcXFwwZmkxw6shw63CrX9ww7zDq3HCnjvCgMKwMivDmXtNXFxcIsK3XHUwMDE2wopcdTAwMGbCumRcdTAwMWFAw6fCrz9Nwq49SjfChC0oSk3CgsKPw45Gw6ZqwrnCisOfwrxcdTAwMWI9SkHClDDDucK6Plx1MDAwZixIw4dvPUrDvXvCsSfDkcOQwqpRXHUwMDExMC5uwrcwXFx0w7hoXHUwMDFhXHUwMDE4w7J7wpg9SsKhwoMww4hBwpdUOsOmUsKFw6rCucKMd2/CrDFcdTAwMTA6XFxcIsKKXFxcIsOaeilOXHUwMDFhw7/ChsKsXHUwMDBmXFxcIsKxwqwhwpBlXFxcIsKZXHUwMDE2wotjKMKDPUrDn8KjMVvCkDbCosKPRMOqWcKNNsO7wo8/PUrCt8Kjdlx1MDAxZsORUMKqwqnCsC85wrdew5bCvMK8LsKIwrvDvcOaXHUwMDA0wrRpXFxcInNgwqzDkcOuLMKAaMODOCjCu1x1MDAxMTrDkVx1MDAxMDgowrlcdTAwMGY9SivDu8Krf3zCtMOqXHUwMDE5wpsxwoDChcKzLHnDssKLXHUwMDFhwq8ywopvwr82XHUwMDFhw4PChsKwwr/Cg8KwwqtBwo8xXFxcIntGworCv8K+XHUwMDAzPUpnwqM5w5XDokpcdTAwMWHCuMOWLynCsjPDlsOSTCzDmcOyPX3CgsODTzgmTkJmT8OaPit/YcKdUMKDwrwtw6JcdTAwMTQ2I3pcdTAwMGbCrMKpw6JcdTAwMWHDiTlhwpLCq8KGZlbDlWzDrMKpw5BcdTAwMDfDji/Cn3zDpMKaeVrCksKuLMKSwqsxXHUwMDEya0RcdTAwMDbCmTXDhFtAwp5tME5jOsKOw4M2w5zDny5cdTAwMTNwwqrCpl9rw5ArSsO/wqZyeTnCjkQsfFx1MDAwZsKrTmdrw4BcdTAwMTNKwoVlwrpcdTAwMThiwrrDmVZywo06w7LCjUzDssOxNE5eMMKOw44vwpxDLMK8UyrDk1x1MDAxMsKtwobCsMKswo5cXFwiSjdZwrrDsU7CusK5Z3JSRMKOTjFGwp8tw4jDkCrCucOXwqvDtcK7w6rCkcKXPUrCl0rCmsOhOnTCjirDpkcwXHUwMDA2PypxMS15XcKqw7E4w6pcdTAwMGZCPUrDnWbCmsOvR1xcXCLCvDTCpsOcK3hvK8OZSlxcZkHDokYxwqZQO8KxXcKRVMKiwr1Pw5TCjmvCtcOzw6TCrCkzwrjChMKnRcOifTNbwrHCrmUlPUrDscKGXHUwMDFhw5VcdTAwMTRsw7PDh1xcdsOkVFx1MDAxYcOsQMOiw4sqRlovSMKiw6o9fXRcdTAwMDbDgDUtSk9fUsOXR8K+w4Exwo9ewq18wqRsw5TDtHpwwpVSw49Gwr7DtkLDtFx1MDAxMDDCj8O/wrDDvCDCsVx1MDAxY3RtXHUwMDE4NkrCqcOYwrrCiTfDssObLVx1MDAwZcKDKiPDnsKqw4Y4MHjCnVxcXFxcdTAwMWVAw5k9TcONw7JvYcKcY8Omw794NcKcIGpuTlx1MDAwZXpcdTAwMWPCocO3wrHDjFgqRytcdTAwMDQ4w54rwpI/w7osw4pjasOVwqvDgCtXLMOEUSPDpy7Ckj1AKVx1MDAwNm3CqMOZwrrChsO5I8KpwrzCmVx1MDAwNUfChFx1MDAxYX9UwoJcdTAwMGXChVx1MDAwZsKBXHUwMDEzwoVcdTAwMTN9w7MqI37DsMK4wrJHQ2VMwqTCjsOowofDiFx1MDAxNz5cdTAwMDXClCfClCfCr8KUXHUwMDE1PyFcdTAwMWEhNMKeIWXDucKcw5XCn8OVSH49TVvDrcOnXHUwMDA0w6fChGJPWsKoXHUwMDEyXHUwMDAywovCjcONwrDCuFx1MDAxZMK1XHUwMDFieUjDhlx1MDAxM3zClmXDv1TDq8KLwq51XFxcIsKywrLDmsObw61MwrFwL2/CscK2SWTCqMKSw4BcdTAwMTc+w7UsXHUwMDFkLFx1MDAxZCPClDXDv0HCk8KWelx1MDAwNsO2XFx0UVxcdFbDsVRcdTAwMTZcdTAwMGZcdTAwMTNcdTAwMTbCncO1bVPCqMKzbcK8wrDCuDXCtDPCs0NbWMKcfsOWXFx0wqLDicK+w6vDk1xcYsKTXFxiLy11JcO3w5zDgsKLwrzCikdcdTAwMTRSwrZIXHUwMDE5w4fCmMOJwovDgVx1MDAxN8OCwpnDh8KVw4fCjcKHw5DCicKXWn3CjcK4wpDDp1x1MDAxY8KEw78wXHUwMDFmXHUwMDE3dMKlI8OxP3jDtFx1MDAxN1x1MDAxMMOXXHUwMDBmwpVcdTAwMTdFw4ZHPmPClnZuwqLCtlxcdFx1MDAwMsK6w5I9Slx1MDAwMsKLwrPDq1x1MDAxM8KIQ8KYwqMtw5HDolx1MDAxMcKifsOjwoBcdTAwMDVYXcOFwo3CvsKSO8KUwpnCiTxcdTAwMTnDgVx1MDAxM1pcdTAwMDPDoMOKwonDk8KTw5vCj8K7w4PDssOWw7DCpsOgPUDCjMOHP8OEN8Kkw5VcdTAwMWXDocKSX8OTSHtkw6zCicOQXsKFb8KlScOEXFxcXMKewp5uwqJcdTAwMTZcdTAwMTJ+UGhiXFxiwqnCjHJwwprDmMKlXFx2w6pcdTAwMWPCq8KvLTVcdTAwMDbClTHDvlx1MDAwM8OWW8KHwpLCvsKKQDTCtcK9w49qdXBAZ8OdXHUwMDEwwoRew5RQLcOrXHUwMDFjXHUwMDAywrLDtMKrwrPChcKXw61Dw5xqXHUwMDA2XHUwMDFmJcOeworDhsKswrzDlMKww4DCuMOYw6jCq8OLwrvDm8Kzw5PDk8ODw6PDoy92w47Dm0zDlWPCs8OBwoPCrcK/wp/CnDRcdTAwMWNMPHxcdTAwMWTDosKtPUrCszPDs8O+w7LDvsO+wprClFx1MDAxZSpBwrliXFx0XFx2wqjCjWw9TcKswqZtcMKywqlxwrYgXHUwMDFmSVAoXHUwMDE3wqU9SitXwoJcXGbCnVx1MDAwMsOSb1DCpVx1MDAxYV5cXGJnwpXCqcOPwrHCr1xcXFxEQ0PCkcKfIMKvPUBcdTAwMTLDtcK4NFxcXFxoXHUwMDFje8OrwoTDj1x1MDAxZMOMwqPCpSVWw5HCrsO1w61GwrxcdTAwMTU/MVx1MDAwN8OWw6NkwqrDqcKYw4jCocKdXHUwMDFkcsK5w4YxwpTDrcO5w4nClTVgXHUwMDE4woJmw47Dm8Khw55cdTAwMTnDuFDDl2LCrWfDocKMeFfChUjCg1plwpxcdTAwMWUvYcOnc0zCscOlXHUwMDAzwoXCvlx1MDAxNMK9w75+w419X8KnwrZ0YMK4wqnCgmjDn8KewpfDuMO/wr4zI0fCsVbCgG5cdTAwMTfCosOgwqRcXGJcdTAwMDZcdTAwMWY1Z0HDrllcdTAwMWZowpNdwqUgw43CgVx1MDAxZHEpXHUwMDAzZlx1MDAxN1x1MDAwZsOVXHUwMDBlw4TDm1s4XHUwMDE2XHUwMDExw6rCocOxXHUwMDA2XFxmRTnCgcK/w5FcdTAwMTfDmcKgwp7ClMKcwp8ow75cXFwieMOlwpPDvcKia1x1MDAxMMOkL8KDWMOhwpbCnMOow58nwrdcdTAwMDZcdTAwMWRSwo7Cglx1MDAxOMOnXFx2MMKYXHUwMDExKcOyJ2TCl8KYwqQ9Slx1MDAwNHzCi8OrT1x1MDAwNXTDmcOZwpVcdTAwMDEmI0PCoibDssOJWcKFdCTDqCnCjsOIJMOpXHUwMDE5wqXDo1x1MDAxNFx1MDAxNMKzYcK4wpdcdTAwMGZJwrTCnMKUMMOIw7Y0wpw9QEVQTVx1MDAwNj/Coz1Awp3CsVx1MDAwNl5FbS3CqcK1w51sw5QpPsO9QCU9QF9cdTAwMWTDvsK1VXHClMOZXFx0w4zCksOKwqcmw5TCs8OwJcKDXHUwMDFlw5DDicOtwo7DtVx1MDAwNT4+WMKHw6fDklLDqcKNwqNcdTAwMWLDiG3Cu8KPXHUwMDEzNcOewpxJw7nDp39cdTAwMWE9SsO7XFxmwrbDtsK9w41RScKmw4/DgFJcdTAwMWbDkVcvMcOYw4fDijpdSyTCpMOje350JsOtXHUwMDFhTlx1MDAxMSTDusKFwrjDu0t0LMOnwqrCjVx1MDAwNMKhwqfDgMOJXHUwMDA1w6bDvVx1MDAxZWtcdTAwMWPDoMOYwojDhcO3TWTCiMOXScOgwpFnXHUwMDE4wpPCtGnCmF9cdTAwMDVcXGbDusOMwo/DuSBjY17Dt8KEXFx2w4Bjw7nCgcO/wpMkecOPecOfXFx0w7Bhw5g2XHUwMDFhc8KFw51Qw6/Ci8KrwqdcdTAwMTPDpU/DmcK3OMKewrbDjDTCiMO+woPDpcOnwo8wKSRiYsKNw7nDoWPCr8Ojw6nDsMK2wpxcdTAwMTPCqEAkXHUwMDE3wpnChlx1MDAxMcKzwp3CmWjDgMOJRMKaw4PCk8OXwpNcdTAwMTnDpWbDp1x1MDAxMMOyXHUwMDE3wqtcdTAwMWZPXHUwMDAxaWDCpWfCtsKIIVx1MDAxMVx1MDAxOMOROMOvXHUwMDFlwpvDp8KBw51UScO2wrXCoWlhXFxcXFx1MDAwM8KPw4PDrMO+Q8OdWcKAw65gw7fDtMKlw6nCkcKCe8OOwrzDtsOyw5HDlMKRwrHCo8Oiw78uw7jCoTJcdTAwMWPDhX90w680fcKEw7DDqFx1MDAxYcODYFDCpsOmwqnCgsOtwopNVWVcdTAwMTXCscKQw4fDvlx1MDAwNMKoa3A9fcKWJ2xcdTAwMWZcdTAwMDbCqMK2w6RcdTAwMTXDvMOZw5pIw7/CkW45w6DCmFx1MDAwMcK8wojCoiPDgMKmXHUwMDFhw7FcdTAwMGYmw6jDuHJcdTAwMGZcdTAwMTjCn8KUw5TDi8O3wpfDhHVcdTAwMTRBXHUwMDE1woPDvsK2YHzCuMKeJMKcwp5cdTAwMDLDkUlcdTAwMWLCg3fDqVx1MDAxOVx1MDAwZcKOIFx1MDAwNlrCn8KiYHtcXFwiXHUwMDE4w78zwq3DsCEsw6PDnsO5wrHCuFx1MDAwNVx1MDAwNsOLw6HDpsOkwqPDocKcXHUwMDFkPU3Ds8KVwrxcdTAwMTl5w6TClMKbXHUwMDEwe1x1MDAwNcOdwr1cXFxcaVx1MDAwMcKJXHUwMDA3KWgowozDr8KGw5AjXFxmwqzDqMONw5TCsXhGXHUwMDAyw6TDjcKmw7nCsGnCiMOlw57CiCdcdTAwMDPCqFx1MDAwZlx1MDAwZcK7w5fDj8K5dGDDiMK1wqHDlcO5VynDn8KgwoXDtsKrb1DCqy/DtVx1MDAxZcOfwofCkGAzw6jDt8OzwqFcdTAwMDZ9wp9cdTAwMDRjwqHDsMO0L8Odw7Ahw4llwpZcdTAwMDbDmUc0O2jCsVjCuERcdTAwMWPClFxcYsKyw5nCqXA4wp/CosOOQsOeJFx1MDAwZX/CqcOdXHUwMDFjwpPDj8O1XFxmJ29NLcOTU8Opwo3ChDTCpS9fwpNtw5/CrVxcXFxBZcO1TsKCZMOIw4dcXFwiwqDCgsOnXHUwMDA0wq7DssKSw5dcdTAwMDRGZ8KHXHUwMDExw5bDpcKwwq3CrsKVw4/DkMODeMK6wrXCu108wqZawqLDkjzDoMKPw5slw5U9TcONwofDu0RfwpDCkMKPw4VcdTAwMDFcdTAwMDbDoFx1MDAwZsOAwojCgU13w4nDqVx1MDAwMcKcwrZcXFwiwqPDtcOYw67DpFx1MDAxYlx1MDAxNsOfw6vCk1dkcDjCgT1Ae1x1MDAxOVjClkjDv8O+w5hIw4TCoz1NwpzCsMO9wr3DnMOseTnChFjDmcKpwohcdTAwMDJIKcKkwqHDkcOvZVx1MDAwN8K5w7loQ1/CmVx1MDAxOFx1MDAwNsOoWCPCpcKIwrd3XHUwMDAxw4MkwoHDp8OmXFxiTcKfwpZxw7NcdTAwMDbDvsKdwojCv8KXOSh+XFx0w4jCp8KMf1xcZsOcXHUwMDFjwrA9TcKlw4LDr8K0d8Knw7Uhw5RcdTAwMThcdTAwMDNXw5HCvsOlPU3Cs8Ktw7XDgF7DocKZRcOcfDjDhsOiwonChMKabsKkw6ZcdTAwMDXDqy1ow6nDssKcwpDDvsOtQMOnRVQ3wolcdTAwMDFcdTAwMDfCtsKlacOPw7vDtsKccmvCscKaI0BcdTAwMDYowpzClG/DlSXCkik9SsKDXHUwMDFkw5DCr8K3RylcdTAwMTLDgsKnwr9cXHbDsFxcdMKpPF3ChcKXYEBCwqdcdTAwMTnCk8OCwpZVw5bClz1Aw5I5fcKXwrc4aMKPUsOlwpvDucOzXcOxPMK5R1VCwr18w4TCg8Klw7rDnCBxJMO1MEVcXHTDpcKkw5U9QFx1MDAxMnvDq00sXFx0wqVXw5QnJFx1MDAxMHfDgVx1MDAxYcOzajl1w49cdTAwMDHDk8OXw4zDq8KFXHUwMDA0w4XDllx1MDAwN2DDhMKgKWQgw7/CmMKFwoJcdTAwMGbCuVx1MDAxZT1Kw7tcdTAwMWTCn8KUUcKww6FhRsOYw5ZVYkVFw4bDk8K9wolcdTAwMWHCqCXDoC3CicK1dVxcdFx1MDAxNVx1MDAxYsOhXHUwMDA0fcKhSW/DnsKow5DDgcOgNcKZwoY8wrh+QMKCw5hDw75cdTAwMWXDvyPCl1x1MDAxMCXCkcKIw5jDvsKswoHCiVx1MDAxZibCgMO5wpNZXHUwMDFhM8KXXHUwMDA3w6TCglx1MDAwN1x1MDAxYyDDssOFbCPDvnnDscK4R8KhXHUwMDA0w4LDgMOAPX3DlsKpworCmVx1MDAwMsKvwpXDlzfCp1x1MDAxNMO0w5/CuFfCi8ODwptwNTRcdTAwMTA4w7k2XHUwMDFlwofDuj7DoVx1MDAwMilcdTAwMTXCq8ORwpXCh8OFwobCicKwUMO0wqLDuFPCl8KpwqHCncOrUGFcdTAwMWbDpGzCjVFcdTAwMGbDtcORaFx1MDAxM1x1MDAxMsOTXHUwMDE3XHUwMDE3w7PDosOEXHUwMDFkXHUwMDFjXHUwMDEywovCjyXCo0PDl8OYw5txQFx1MDAwNlx1MDAxN8OJRj1Aw7w9fSF1UcKWw6TDhVx1MDAxY1x1MDAxZXtcdTAwMTNZw6nDtlx1MDAwMz1Awo1cdTAwMWLDnVx1MDAwN3/DvcKIw7EowobCgcKaw7Urw5XDpMOlU3QxXFxmSMKGWTJcdTAwMGVzXHUwMDAzYcK/aMKowqnDisKbw73DvMO8wrBcXGbCssOuXFx2ZS7Cn3bDu8OPL0lQb8OpdmJ+XFx0w53CqVxcZkPDh8OAw43DnMO0RMORdcKFVnfCuFx1MDAwNyfCo1x1MDAwZsOPwpXDn8OUw4/Cp8OOwrHCiMO9JUHCoTnCosOkXHUwMDAxw7A3wqVJQsOiwpzDi3FcdTAwMDfDmMO6w5gvwo83woV0wr8nfD19ScOAw55Gw7JcdTAwMDd2X8KXVsK2NcOmw6jDp0t4w6TDl8KNw6tqb8Odw6TCgXlUPMOBcj1Nw7xqwrHCk2fCqcKoI8Opw57DnV5+wrgjJ3LDkcKYXHUwMDA0w7DDpVx1MDAxNsKuw67DgMO2w6NswqU9TcOaSFx1MDAwMVVVXHUwMDE4w7jDg0DDisOhwp7Dvlx1MDAxY8OqNFx1MDAxZMKLw5/Dk8OHLcOkw6DDhylcdTAwMTLDm8KBwrVzwrd4wqfDoMOvKT1Kw48kXTRcdTAwMDTDu8K5XHUwMDE4w4nCv8KfXHUwMDA1w5DCocOwwpPClMO8w5vCuHrChlx1MDAwNMOfYMO9fCc9TcOIw4EsXlx1MDAwNSnDu8OMw5LCk8KRwqbDlEljw6PCtl/Cnlx1MDAxNVp5XHUwMDE2w6RcdTAwMWTCocKNwrHDlsKNwrnDilx1MDAxMsK1esKnXHUwMDFkZ8KUw5PDmMKWw7XDhnVcdTAwMTc3w5NxXFxcIsKbP8K9wpzDtiDCuFxcdFx1MDAwM8ObN1BcdTAwMTklIcKYw5bCssKgwoxpY8KXcsKewpzDtVx1MDAwM8OFXHUwMDFkclTClVx1MDAxOcODYMOHwoDDq1x1MDAxNcO1w7RcdTAwMTTCrcKew63DpMKsw7hWXHUwMDEywoIkw4tTw789QGPDncOMJcOjXHUwMDE1w7zDg1x1MDAxMlx1MDAxNcOGXHUwMDEyS8KdJsOdwoDCsHA9TcOLXHUwMDE0wqXDmVjDpcOjw7fDjsOTw4rCjMKJXHUwMDE4wqvDvlxcXCI3XHUwMDE5XHUwMDExw5LCgVx1MDAwMllnUz19OydcdTAwMTVcdTAwMTh8wqlVw6vDj8KXe8KhLsKlwpFcdTAwMWXDo8OjwqPCgibCnMKkXHUwMDAxw6NcdTAwMTfDtsK0wqhcdTAwMTPCucKwcFx1MDAxNMOSw4HDucKUQVx1MDAxNkjCgVx1MDAwMVx1MDAxYsKScMKaw4HDtMOXLcOBeFU+XHUwMDA2fsKlwopcdTAwMTnCu04pXFxiwpbCmSPDvHlfXHUwMDE1TcKob3Y7QsKEXHUwMDE5w6ROJcOnXHUwMDEwXHUwMDAxw57CusKSw6EkJMOkXHUwMDFlw4bDocKNw6DDjznCoMKUXFx0w4xcXFwidzFpYDfCuFx1MDAwMlx1MDAwM31BwoTCm1xcYsOTKMOQw6vDkcKTXHUwMDFlwq/Dp1x1MDAxM8Kjw4RjY1x1MDAxNcOdwr9cdTAwMWLDnMKnw5fChSw8QMKuw6RfwrFvw6bCgsOEwqPCncKGcsO9w49cdTAwMDPDlcOow4TCny/DpMKkYsKiwrEoXFxcXFx1MDAxNsOCXHUwMDFkXHUwMDEzw4RcdTAwMTV3XHUwMDAzPX3DicO/N8Odw6l4dcKpXFxiXFx0acKRasOZwovDp8OpXHUwMDAzw43CkzXCjWDCsMKYw5N3wrbDssK5OsKMw6PDg2fChcKYw5fClVt1WcONZsK4XHUwMDE5wrjDpcKjW8OZXFx2wrwrw5ltw6BcXHTCl13DrcOpwpw/w6lcdTAwMTBcdTAwMDbDscOJUGbDv1x1MDAxZFxcXCJQw6bClcKQIMOTIHzDonU9SsO3w5TCijnDrW11w6TCjsK9wq3DoMKmw7zDmHknwp/CkMKpwp54w7NcdTAwMGUkXHUwMDFlR1HDuHbDpUFZwoVZw7pZwrdcdTAwMWFowqFWXHUwMDFlwr09QMO1V8OVWcKEwozCglx1MDAwZjfDgDZcdTAwMDLCo8OBwoBIw6HCgcOkXHUwMDE4ccOkwr5cXHbDqG4jwqQ9TcKNwpxcdTAwMTRcdTAwMTnCmcO0Vjc8w7LCpE7DiX/DsEHCtn5cdTAwMDbCriN0wqVBXHUwMDE4fsOewpZcXHTDtFx1MDAwNWJ/w47CimnCicOFXFx0wo7Cm3fCusKdwovDgMO7w5lcdTAwMGXDu8KwPzUxRcKhM8OJw4XCjnjCp8ONKcOoXHUwMDA3XHUwMDAzSsO7wozDhlxcYsO1I3/DpMOrZXHClMOefMO1w78twqkmf8KXQ8KRw5dAwotcdTAwMTbDksKjwp1cXHQ5w5dcdTAwMTLDisO/ZMK5XFxiMcKSwqFWw7osNVx1MDAxOMOUXHUwMDAxw5HCtcOFZsO8UcOAwqMgw4JBwqPDgcO4XHUwMDA1VybChMKkOD9cdTAwMDZbwpBcdTAwMTjCqMKZRT5hwoDCi8KKwqV9wqzChULCp8O+J3Y9SmhBKcKhwr3ChlnDg3I5Mlx1MDAwNynDqsKjw6tcdTAwMDLDnz1AZFxcdMKtwpZEXHUwMDEyKMKAwqR3aVdcdTAwMTHDplx1MDAxNV89fS7ChMODeFx1MDAwNWlcdTAwMDbChj1Awo7Cs8OvYFx1MDAxOcKSwoXDkS/DvVx1MDAxNsOgdsKmXHUwMDE5worCoMO7w78ow6pmOVHCgVx1MDAxZMK4KMOxXHUwMDE4w75cdTAwMWY9fcOAwrBjw4hewp1SNsOEJcOXXHUwMDEywoRcdTAwMWLDlMKswrrChcKoIzlBwrFcdTAwMGXDsMOKwq9jYVgnw4hcXFxcUMOvXlx1MDAxOSHCunnDr8OMw6HCmE9pNz1NdMKdIcO+eMKnXHUwMDFiwpXCuFJTUMOMXFxmXHUwMDA3WMKLwoPDgMO+w7VcdTAwMWNnwplcdTAwMDHCkcOiOVPDg8OuXHUwMDE4e3dcdTAwMWRew6bCusOoXVx1MDAxMMKew5DDrVnCrcOWN3x9UMKFXHUwMDE3XHUwMDA0w4hnwp3CmFx1MDAxY24/w509fcOzX8OhwpjDkcO6w690w5N1wrrChsOMw7BcXGbDsXPDlXw4UULCh8OERsKZw6TDgTNcdTAwMDfClFx1MDAxZcKUwqIpYVx1MDAxZHFeMG7Ct1x1MDAxZcOAwrhHwqTCpsKhXHUwMDFmWsOBXHUwMDEywrlLMcKpODQ9QMOnJ8OxwqnCl8Kzwq/DiSDDhsOLaDV3QSPDtMOOw5g2w4LCqFx1MDAwM8KhMsOJw5s3w4TDpcOSXcKafsOzwqt7wqHCmMKRwrB3WsK/N8OpYVx1MDAxMcO7XHUwMDEyXFx2w4FcdTAwMDXDjVjDkVRxJFd0wrdiw7U9SlvCk3DDoz19aFx1MDAxOcKXwrZ1M2JjKFx1MDAxM0VcdTAwMDdcdTAwMDImXHUwMDA3RD1Nw6hzwolIZVx1MDAxZlx1MDAxMcKwXHUwMDEyXFxiXHUwMDEyw5Nbwr8owrtJXHUwMDBlacO5JWJ5KVx1MDAxZsKRXFxiS1x1MDAxZcKTXHUwMDFmw4HCq1x1MDAxOTfDsMKpwqLDocKSXHUwMDA1wrZhwoRcXFxcPU1cXHRIw5vCgyY2w7dIICZ6wq8jw70rYcOkZWBXJ1x1MDAxY8O8w6zDvVx1MDAxOMOvIFVow5lGPU3CgcOmXHUwMDE4w4YnXHUwMDFhdcK7wrd2XHUwMDExXFx0RcKDwol1VDjCqCU9SsOzKMO2woLDhFx1MDAxY1x1MDAxNcKDw6bDtMK5wrPCgVx1MDAxOMKmw6lcdTAwMWHCg8OZwpnDjsKpw7VcXHTCncKxw6BcdTAwMWZcXFwiXHUwMDE0XHUwMDExXHUwMDFlXFxiRMKJJGUmw7XDsMOYJVxcXFzDgSjCtlxcdMOQXFxiR8Kpw70pw7jClXvCp8KlIMOWw5nDoVxcYsKEXHUwMDA1XFx0WHVawpUlwp3Dn1x1MDAxNSQ+wrkvYcKpVjPDqFsgwprDt8OnUTA9fVx1MDAxOHDCqMKcw6nCqVx1MDAwN1x1MDAxOVx1MDAxZMKtKlx1MDAwM0HCuXlhwqRpQ0RlXHUwMDEww7vDv8O4w6M5fzdYwojChMKowoJcdTAwMTfDnMObwolcdTAwMWLDr8K/w4k9QMKHesKWXHUwMDA2wpvCn8OgwpZcXGI/w5N4J8KVXcKMecOfXHUwMDA0wrQ+w7lcdTAwMTbDqMKjXHUwMDE1w5bDn8KfXHUwMDFkI1x1MDAxZsOdUMOIRcKiXyVcdTAwMWUowq5tw5HDpsOAZmNcdTAwMDNcdTAwMTZLXFx0XFxmwr3CgsOoXHUwMDE0JsOfw7dcdTAwMWZNMMKJwoPCo8Kbw6NcdTAwMTDCtFx1MDAwMmDCvV85w7TDuMOZSMKHw6HDlVxcdsOgf1xcdlx1MDAwNMKMw6NNdSTDoMOxWVfCtj1NVylcdTAwMWNcdTAwMTckw5xcdTAwMGUtIUFpXHUwMDAxwr/ChF5cdTAwMTPCjcOwwqzCucOoJUFkwpkpf8KlwoLDuMOTwrAjQMKCwqdew5jCi3BpXHUwMDA3w4/Cv2U4wq7CgMODJcKEeFxcdCbDm8KRw4TDrF/DgcOkI8KzXHUwMDE5wpDDtFfDiWjDlcKUwprDtsKWw7fDnHtcdTAwMWRAw6HDt8OGw5nCmVx1MDAxZsKeXHUwMDE4w4Rkw7ljXHUwMDE1w6jDkMOXw6HDg8OawpFcdTAwMDfDmEchYFx1MDAwMsOzw71FeVxcXCJcdTAwMWHDoTYowprCjVx1MDAxNWjDpz1Nw4UxR3ZcdTAwMDTDnsKMwoPDvcKYPX3DmcKswofDtcKEN8Khw5RPw4fCk8OUw6DCllx1MDAwN1BnfcORwpvCgMKjw684w49cdTAwMTXChcOgw6HCo2dlO8Ofw7bDlSPCm3xiSFx1MDAwMWTDhcOnXFxcXMOdXHUwMDFjXFxcIlrDtcObw7F4wodJwprCjnIjXHUwMDA1w43CmVBcdTAwMDJcdTAwMTbDhSbDn8KZKVUjwo/CpT19wqDCtlx1MDAwMlx1MDAxZCfDrcK6wq3Co2jClTjCnkkmwqjDksKGw5lJwoPDrMK+ZMOmVFx1MDAxNVxcdmfChSc9fVx1MDAwMyXCtFxcZsKPwrEpUlx1MDAwNVx1MDAwMcOowoxcdTAwMDfDrVx1MDAwZcO5UV0oeF1cdTAwMGXDmcKiXHUwMDAxw79Wf8KVwp/CnXlcdTAwMTHCusKOJV9Vf8KYw4PDtmJcXFxcwozDtMOiIEjCg8O5wq7CvsOew4FFR1/CqcKTSFjCm8OCVMOVZlx1MDAxNlx1MDAxNFx1MDAwNMOOXHUwMDBmwoU8w4jDuMKAJV1RdD5cdTAwMWPDsSfDrMO3wo9cdTAwMTlFOSh/YMKgwoTCpk3CkcO3wrXCp1x1MDAxMVx1MDAwZlx1MDAxNcOcwqHCoDPDkEJOw49cdTAwMTZUw6LDmMKgXHUwMDE3w77DmlxcXFxcdTAwMWZZwqvCmVxcdC9ow5bCoMOdw7coQMOjIMKlw63Dllx1MDAxOcKmw63Cjyg1wpzCsWTDhMO1XHUwMDAzw5lkwrxcdTAwMWJcdTAwMWTDucKNwpPCt1xcditcdTAwMDPDl1x1MDAxMGlcdTAwMWbCoFnDt8O2w7klw6VcdTAwMTJcdTAwMTFcdTAwMGU6wq8kJ2DDsWhcdTAwMDbChsKKwoTDj1xcXFxkw41cdTAwMDFcdTAwMTJcdTAwMGbDgS9Xw50nwonDmSHDqGHDlWbDtHBLw4vDjcKjwoxcdTAwMWRmP1x1MDAxZnHDiHVvXHUwMDFlXHUwMDAywplkWWjDkXlcdTAwMWbDksKkw4pePUDDt2HDqMKkZsKow6BcXGbDh8O/JsKqXHUwMDE0XHUwMDBmw6lXwofCv8OAKEjDnWo9TSRdwqjCr8O8w4ZNw6bDlsOrXHUwMDEww7PCpXFnwqbDv1x1MDAxZWTCmsKgwphcdTAwMDchSF9QwqVcXHbDv2LCr1hcdTAwMDVhwrXDgMKmw5lbwqfDqMKOw6rDm8Kjw6vDuyvCtDtJSVHDtsOGw4jDkyfCkD1Kw7nDvMKracOFXHUwMDBmw5fCp8KXUMKfZVdfwoTDn2xPUVx1MDAxYVx1MDAwNcOBw5nDuytDwpXClVx1MDAxNlx1MDAxOcOnwqPDn8OwwqnCsMKBwrnDv8OxUcOtwprDj8Oewr/DvMOZw45vw7XCgVxcdsOYwp5cdTAwMDfCt03DqD/CsnbCp8OPdsOAacOCwqbCpH3CpSHCisK3XFx2w7XCicOBKVx1MDAxN8OSw6fCvmZhwpAnVMK/SsKXVMObw6jCosOJPUDDicKAXHUwMDA1wozDhcKHTX55XHUwMDEzXHUwMDA3VGFYdFxcdsKBw4ZcdTAwMTZzXHUwMDA3w5ptXHUwMDE0T8KVw6LCjMKQXFxmPiVow5PDncKlQGfDgClcdTAwMWRcdTAwMTPDtMOIwq5cdTAwMTPDlMK5wpnCqMO5cznCg8OjfVx1MDAxNMOaw6vDiMKtwrjCr8ODOT1Aw7zCtMODw5zDg8KXdHNcXFxcwq3CuMKfw4/DqcOnX8O2w6JYXHUwMDEzwqRcXGJCL8ORWUtcXFwiPUpcdTAwMTTDj1x1MDAwMVx1MDAwZlxcdClywoN9wo3CkU7CpsOfwo8lPUBcdTAwMDN9w7nCklx1MDAxZlx1MDAxMlx1MDAxMcO3wonConhhwoE9TShcdTAwMTghP8KcVz1NwqJTwq/DkcK9wrlcdTAwMTPClsKAwrbChcKxPMOQwonDhcOVJ8OmbsORPsOTw6lcdTAwMTfDnFx1MDAwMsOGw6HDjlx1MDAxOcKcw7VcdTAwMWTDn8KPW1x1MDAxZCbCg8O/w5nCi8OmwoPClVx1MDAxMcOQwqTDpiNcdTAwMDLDoMKLw7DCqj1Nw5tcdTAwMWPCuMK0XHUwMDExUMKnc8O2YcKEwqIlfXhcdTAwMTLCq8ODw6RcdTAwMDXDjsO/NVx1MDAxY8OdPUBzwpNcXGIhw4TCpsKLXHUwMDE5w4PCucOhXHUwMDBlUH5Uw47Cp1xcXCLCvyDDjsKaw7/CqznDj1TDrcKNw4hQWEI+w5jDv2NcdTAwMTfCjMKbw6nDoVx1MDAxOFx1MDAwN8O4PX3DhMOAwqnCmmBcdTAwMTPDgn1lwo1cdTAwMTjDksKBw7nCiUg2VcODw4PCuFghXHUwMDFiwpDCsFfDpCfCpsOhXHUwMDE0w6/CsmtcdTAwMGbChMKIw58mwqzDo3DDk8K3TU03wrgpw6h8w4LDpMOWwqzDgGHCpcK7I8KKw5Iow5FcdTAwMWTDp8K/w703QMOlwqZZw59cdTAwMDbDoMKcXHUwMDE1wrrClcKJJsOocMOWwpjCgidcdTAwMTQnwonCscOcRMKdw4nCk1xcXFzDtllcdTAwMDdcdTAwMWXCkVXDoUV5XHUwMDE1XHUwMDE5w4ZhS8OiXHUwMDEzcXvDiSXCtEc1KcKJwofDh8KPdsKGwovDjcKuwrXDpW3DoXpcdTAwMDZcdTAwMDfCh0BAVVx1MDAxOMOPelx1MDAwNsKHwrXDpVx1MDAwNVxcZsOvw4vDosOlw57CgsKbwpHDu0DCsUzCtWU+w5FcdTAwMDIvwphcdTAwMTjDgcOFXHUwMDE5TnlcXFxcwpHDuFx1MDAwZSbCpsKpw6fDgzNnQ8OLTzUsUmxcXHTDiidcdTAwMWTDoMOFdURQwpTDjHzCocOhO1x1MDAxMUvCtcOnw5bCm8KAw7VOaz1Kwo44w6FmKD1Kw6PCqcKgw6Q7w7jDhMOXwqTDlMOuWlx1MDAxY1dcdTAwMWJKKkTDinU+w5fDtcKDwqRRRsO0w4PDnMKgZsK0wqnDmcOXXHUwMDEzc8O4w6HCs1NAPUrCkcK8L8KnwrFcdTAwMTDDk0PCjsKIw67DucK4w71JwoFcdTAwMThtw6LDk1x1MDAxYsKyw4poKMKfa8OuwpHDnU/ClGXDvMOWXHUwMDBmwqpcXFwiRcOQwr09fcOyw5pBwrvCjHhcdTAwMDVcdTAwMTDDi8OXwo45wrRQPEzCjEDCocOYIcOFSmXDmlxcdsO1wr9TJsKIwpDDncOfw7hcXHYmXHUwMDFjwp0rwpHDjVJcdTAwMDZlw4JMJWgxKsKLXFx2wqbCtsK1McO7KsOcwp/Cv8OYwoPCjVx1MDAxOVtcdTAwMTjDlsK1wrVpVMKDw77DrVx1MDAwNXxcdTAwMTbCosOyaih4w6M9fcKpwr5Fw6AoJFx1MDAwMcK8w6hiXHUwMDBmwovDoUVgw6nDrVx1MDAwZcKdLMKGw6pzwqjCrkFcdTAwMDHDkkrCsMOkwqHDmFxcdnVPXHUwMDFjw4VCNTbCg8OMM8OMw67DvnzDqnzCmlx1MDAxYS9jXHUwMDEwXHUwMDEww5d/w6TDrMKbZ2jDvcOwR0zDvEgywpbDosKzdmbCnmjCv3pcdTAwMWTDgjtEbMKMwq7DpsKrd8OJTcK5wp7CuMO1wrZcdTAwMDTCtMK4I2Viw7rClD9cdTAwMWPDoMKlMlHDncOiwolVWMKww6AqwqDDicKTacKDwobDgj1NRzfCsTFUwrR6ecOiZ1lCwqXCqmxcdTAwMGbChUhdwovCjsO+w65kJnt5w6/CgcOTQ3F8w7TCo8KrREJdYnTCnXXDo0k9TSgzJsKPw7hcdTAwMWTDtmszfsKjwoXCgz1Aw6bCtD1Kw6TDicK2wothwo/CssO7XFxmw75wwqvCkjfDrVPCvcOqXHUwMDE0w7bCnsOwejk9TcK8wp/CgVDCoGM9TcO9wqBAwrHDgCzDlsOQKsKAw7U9QFxcdsOAw5hUwoZcdTAwMTjCvMKGR1x1MDAxY8KSwrNcdTAwMDbDlC3Dj2drM8KXw7hQwpQ3XHUwMDE5TMKOJ8KYwqQxXHUwMDFmwrLDuGtzwp/DuMKGwoNMwoTCmmPDnlxcZsOaw45+woLDnCB1R3/DpcOKaEYuwpvDtMKeesKDwpzCnlxcXFzCk8OiwozCo8KjYypyw5XDnMOtXHUwMDBmWsOSdifCh8K4w4hcXHZrNcOIXHUwMDE0w63CtjNVw5BcXFwiwrLDqsO2bk/CoT1AfFxcXCLDhsKvXHUwMDEwXHUwMDA0TMKVw6HDtlx1MDAwMsOPLMKFwoHDhUTDsMOlw7p/wpXCrHvDg0jCgmrCqTvDgCjDmVx1MDAwMsOtTFx1MDAwN2dcdTAwMTJcXHYyXHUwMDEywrR5w4Qgw7h5LVx1MDAxZsKZXFx0wqxcdTAwMDfCp8K2fCnCq8KQwpkoYFx1MDAwM8KGTsOsXHUwMDEwXHUwMDExwo1cdTAwMGXDlFvCk1xcXFxhWzTChsO7w6nDml8yaMKQIzQxwo1pfMO3w7XDhcKBw4Ytwp/CksOIw6BfwpdXwr9qd8KFNjTCuVx1MDAwMTLDvMK8wojDsFx1MDAxY0JxOlx1MDAwN8KDw61Uw79Gw4HDmsKkw73ChcKSUcK1w6fCllx1MDAxM8O/MMKVe1x1MDAxMS3DpMKZw4LDjcK3PU3DrnjDmS/DqMKfw4vDn8OIwonChsKOXHUwMDFiI8KYw7LCs8OTXHUwMDAywoFcdTAwMThnw6TCllxcdGXDnsOOa2FcdTAwMDVcdTAwMWXCgsKSwolcdTAwMTZxXHUwMDA1wqzCisKMwrkyw63Dh8O1PX3DpcKUPU05wojDmFFcdTAwMGVcdTAwMTjDrMKXwrJzQkZwXHUwMDEzwrzDr8Otw5tjdsO/w6vDncOMw4vCsFZcdTAwMWZcdTAwMTXCoMOQXsKcwojDh8OPVlx1MDAxOMKBw5daw6g0wqZcdTAwMTDCuDLDoz1NQFVWwo89QMOTLGvCu8OgXFx0w6FswpLDkj7DqWjCgF3CkGHDv0x1w7HCtGLDsjnDgDlcdTAwMTQ8w71cdTAwMGbDlMKoXHUwMDBlLFx1MDAwMcKBwqFGwqBcdTAwMThacsOANEF8P8OjYMKMw792MsKDXHUwMDEwwrF/wqAnw7rDjVLCk8OwXHUwMDExwrM9QGPCk2jDulbCkMK9KiNcdTAwMTB9VcKaPU1LJ8Ovw7Zgw6YpwqpcXFxcwp7Cuj98w51nPX1JwqzDqnTDnMKrwpY7T3k9QMKww67CtsKlI8KGwovDkMOGwpBrwqrCsl8rw6VGfsK0wr/CvjzCplx1MDAxMlx1MDAxYcKoPX10RcOXwppcdTAwMWYqw63CniHDhzbCr1RQw7vDiMOfOcKLasKqVkzCucKFXVXClMOYNFx1MDAxMcKSwptddsKUdj7Ct8Ocw7XCtzo9fVxcXFzDhMKOX0I0XHUwMDAxZ8OTScKFw6Y2w7LCsitILCDDo8K0LMOuw5MnWsKSQlxcXCI9QDtcdTAwMWXDu0bCtsO/w6/CmUrCvFx1MDAxM8OYf8Ocwr1wwotcdTAwMGZ2wrHDujzCjcKZXHUwMDAzXHUwMDA0w4BVPUAgw713XHUwMDAyUGNVw53CgMOiw7HDm8OUI1lcdTAwMGbDozNAwqs8PUAlXHUwMDA1dH7DqHRcdTAwMDRhw5E2RMKfw7HCksO7O1DDoMKrXHUwMDA3QcKnU27DiC/Dg1x1MDAxNMKgO0jDj8KVUcOYeiE5w7DCrCnDskfDqFx1MDAxNsOMw4U3w4VcdTAwMDPCgjDDhlx1MDAxZiRcdTAwMTVcXFwiQWQ9TVx1MDAwNMOuT1x1MDAxNsKXXHUwMDE5wpBcdTAwMGZkwrPCq8OnXHUwMDE5XHUwMDEzw6xiP1xcdsKvwrrDpXbComvDiXBSXFxcXEBVw4PDkcOww61RXHUwMDEyTz1AwqTCtsOQwo/CkMKEw59cdTAwMDNcdTAwMTDDuVx1MDAwZlxcdsKow7U4w4LDmMOoe0dHwoQkfcO7w4liPmrClU/Dn8OtbijChcKDXFxcIsO4wqrDiMONSMKuw6QxSMOfXHUwMDA1XHUwMDE2w7tcdTAwMTNpUcOGw7fCqX5cdTAwMTPCs07Dk3pow7DCiMOJw4FwPFxcXCJywqtcdTAwMTRcXFwiw6ZdOMKrwoLCjS5cdTAwMTVcdTAwMWY6wpN3QCvCmiTCjFkgwo8hwpg1woBqw7FIXHUwMDE0w55Fw5nDvTFIQlx1MDAxZVx1MDAxOXnCs37Cok0qSFbClWbDo8OgwpMmO1x1MDAxOFx1MDAwMsKWw5HDiVdTXHUwMDExa8KHYMKMNcO3XHUwMDEww4BnXHUwMDE2eFx1MDAwMlFcXFxcaCZBXHUwMDBlJMKVacOew77CscOUUU/ClcKtdcKPw73DvFxcXCJKw4pwXHUwMDBma8OVw5TDq3PDhsKqw7jCj8Krw7bDo1FcdTAwMTLCjMO3XHUwMDAzwpphXHUwMDA3woBcdTAwMDfDi8OrwpgkXHUwMDFmwp9IwrZtwoZPwq01w7x5f8KXKXB5wptqfEjDhm3CpFx1MDAwZcOlw4dcdTAwMDLDqWZjw6s1w5Y1wrtcXGbDgMKjSz1AwolCw6hcXGZcdTAwMTTDlcKQNXQzw57Dl8Otwq1cdTAwMTRKwo7DrcOvXHUwMDFmw4bCnz9DNsKuXHUwMDE1w5rCn3BRwrZcdTAwMGbCpWHClFxcdjPDgcKIwoPDocKdI8O1wqvCtXstUsKNwpExeMKHwrXDkcOxPMKaVVN0difDjlx1MDAwNFx1MDAxNMOlXHUwMDEwRFxcYlx1MDAxMcOCwpgvXHUwMDFmwphcXGI9SsOccVx1MDAwNVx1MDAxZMK6WsONw49GwoDCpDNOd0RFXFxmP3hmwrjCjHtLw7DCm8K8N8OFcFx1MDAxNjtxSnzCrcOIXsKUw5DCnmfCiFx1MDAxMk7CrsOewpRuRsKPwpDChTooXFx2a8K3w4DDkMK3wrszw41OwolcdTAwMDJfwpTCu21Zw6tcdTAwMDPDjUkvw79cdTAwMWYyYcOyYsKDXHUwMDFlw4ltZcKfw4zDjMODXHUwMDAzw6jDgsOMw4lcdTAwMWJRSMKfw4zDuU5cXFxcw4s1wqdcdTAwMTA5w73CscOow5jDp3NUQj1NwpdcdTAwMWPCkMKxw5DDkk56L8OGXHUwMDBlVcKYXFx2w41lwoxkw5Mkwrp4wrvDuMO0w6xJw4/DvcK7wo1vIcKzb1xcdsO+fcO1e1x1MDAxMm1Jw6nDo8KWw5vDrlx1MDAxNWhcdTAwMDTCjjZgPU3Dj8OIPsKOMMOOw7DCmMOuwp5Qwq3ClVbDkMO5XHUwMDFkwr9Rw6bCqVx1MDAxYcOXw61fwr1cdTAwMDfCgCY3YcOEw6TDmVx1MDAxYsO8Y8OCJW7DnyfDjkpcXHRxwrHDq1/Ctlx1MDAxZiBcdTAwMTHCtMOlelx1MDAxOcK+K8Ojw5h0QlDDn8KIX2vDj1x1MDAwNlYpXHUwMDFlwrFxw5RgXcKEPU1odXZ5L8KpYTfCmMKRwqdcdTAwMGZWw4vCq8Ojd1xcYj1Ne8KFwrQ+UmjCncOxaUl2XHUwMDFkw4lcdTAwMWHCmnTDo8O7XFxcIsOmW0HCrsOOU33CrE1vP8KmRUd+XHUwMDBlw4PCicKfwoJETMOiw5rClsKwXHUwMDBmwotPwqghPDJnJ8KmwrHDocKzw5E0IMObw7tXw5pcdTAwMDLCusKJwrzDtcK+aMKBZ2HCj8OsMMKFw6vDi8OrI8Kjw73CpMKpe0FcdTAwMDNmwrfDrMO1wqTDsnHDsFxcdMKJw47Dm1x1MDAwN2Mtw6whXSQlNsOrw4TCiMOWwqTDs3ApwoB9w43DuMKuasKefT1Awql3McKQXHUwMDA2woFwXHUwMDAxXHUwMDE5XHUwMDFlf8KFQcOhP8Kyw6HCncKpQcK2woHCksOrL8ONYG7CuGPCoVx1MDAwZcO3KFXChcOiNVQmw6XDoEnDsMK6w4EywrDCk0/DtFx1MDAxY3ZfeHrCt8Kww7Y5PU1cdTAwMDHDuWrDmy7CpcO8U8OvUVx1MDAxNC5CwrnDlmbDvj1AalDCtVx1MDAwMSx0IynCmmjCtMKiOMKjdcOjw5ZDwrjDg8OOUyjDmsOZw7/ChsKAw5ouPsKrw67DusKDXiNTaFx1MDAxNMKKNWg9SnBcdTAwMGXCscK8XHUwMDBmw6DCikrDuVHDo0zDhsOwwrvDusO7wrnDhVvDqMODYzxcdTAwMWLDonPCkMKBXHUwMDAzWsKMesKcT8OOYMOheT1KTMK/XHUwMDAyLVx1MDAxY8KULzxJPX1cXGJcXGY2w6pkS8Kgw5rDi8OKw4/Cmlx1MDAxMcKzwo3CgFhSw71gw5PClFx1MDAxM8KRWsKmwp41LsOjwoHCoTPCosKvV8O/XHUwMDAzZ8KIN0XDuEjCk8KYwopcdTAwMWbDnEjDvcO3QVxcdETChsOYwobDoklhw7g9QMO+wrZZwq/CqcOBSMKndDHCoMO5L8OPblI9fUfCscKEw6rDglHCvFvCvVx1MDAxMFx1MDAxYVx1MDAxYsOjw5/DicOiwos9QDhcdTAwMDTCr8K/wp7CtGfDgMORXHUwMDE0Xlx1MDAxMcOMwr3Cnn97TcO0w55cdTAwMTRcXFxcw5thw6PDmsKVT8KBZMK7w5HCr8KCw4HDsFx1MDAwN8Kpw4I2w4Q9QFx1MDAxZkJ7XHUwMDEywqVcdTAwMWTCpipuJkxoZSfDrcOnw4EgwqLCgsOkwqBcXGJcdTAwMDHCisOjXHUwMDAzw4DCt8Onw4E+RMKRw5fCgsKbwpfCi8KAXHUwMDE1XHUwMDE5clx1MDAxYzfDs8OBUcO2w6s9SsKSOsOKPUApUXHDlCdcdTAwMTnCuHZcdTAwMWPDqFxcXFw2wrBdSWTCt39cdTAwMTHCpWfDs8Orw6HDmDBfXHUwMDA2f8OOwp0sw4syMMOWOVx1MDAxZcKefl1ZfTjCmcKaVmlTfXjCgMKRwp1fXFx0KGTCmcO5PMKCw4lDwpslwo/DscKDw7zCr8KKw6DDpVx1MDAxN1dcdTAwMWFcdTAwMGZEw7nCiMOiw5lMXHUwMDFmwpLDkMOhVcOJworDinI4w6gkNsKrXHUwMDE5V1x1MDAwNF7Dl8OJwphcdTAwMTBcdTAwMTLDn1x1MDAxZCDCnDh3XHUwMDAzW1x1MDAwN0nCuVHCj1rDicOSXHUwMDA2XHUwMDFiVFXCj3Vmc8KwQjInNsKqw7NCV8OJVsOec8OmwrLDlsOlwq9ww7LCh1nDo8OqW8KBY8OOR8OawpsxXHUwMDFmXHUwMDBlXHUwMDA2wrnCjlx1MDAxZsKPZcONSCzCkMKmM8Oxw4rCtsO8TsOAwoVQJsONXHUwMDA2JsKhwrZcdTAwMTjDjj1NW1x1MDAxMcOXw63Ds1/CssKmYsK8XHUwMDBlXHUwMDExZn5cdTAwMThcXGZqw6XCq1x1MDAxMEnDscOQw59KwqHCijrCvVx1MDAxOFx1MDAxNlx1MDAwMsOld2DCjMK+wpI5XHUwMDFmNy53PUBdZULDjVx1MDAxOMODw4VcdTAwMDTDsyDDhFFcdTAwMTbCkDIqwpBcdTAwMWPDhUDDkcOPwpNOw79Fw5grLmkxZybDoSbDosKew79cdTAwMDfDp8OmLVPDu8KBw6dcdTAwMTHDkGU/wq92w73CosKkKSTDp3vCqVx1MDAxNlx1MDAwN3BOXHUwMDA3TsOWWMK3WsO6w4xYwqzDhsOOwrJOXHUwMDFiw5XDusOCTz1AI8K9woTDo0JcdTAwMTjCucKmw5rCrFx1MDAxNMKgciHDoXXCg8O+w7Jmwq8vwo/Colx1MDAxOW/Cg8KAwrhowqNPw5bDhi7CtXfCrnnCjcO7wooowp1cdTAwMTBgw5k8a8KEw7tiwqZcdTAwMDUywoFaXHUwMDA1wopYacOiw64rwqnCi1xcXFxew53Cr8OAwr3Du1x1MDAxNVx1MDAwNDVcdTAwMWTDhU5zM8KEwo7DgcKdZFBiw7Nowo7DqnnCu8K1XHUwMDE2wrglXHUwMDE4wplbw4bCjVx1MDAxYlxcYirChMOPXHUwMDE4w4bDs0dcXGJcdTAwMTA8wpbDucKPw63DsULDiHDCoF1cdTAwMTQ/NXDCqsKjIEdMXHUwMDEwXHUwMDFhwqHCnMOxwo5gwrjCoWfCsMOaw6Nswp/Com3DoMK5fcKNUsKZwqXCtFx1MDAxZcOfKcK8wr5uw5bDo8OIOMOMXFxiw5nDnsOoecK0w6bDjsKRwqDDjkDCusOOw53Doy/CszFcdTAwMTlcXFxcOsK2WE9GwrxqwpjCqcOUR8KwXHUwMDE5NmnDhsO+wrDCt8Kpwrwnw55UdCTCuHbDuiU+fcK3I8OjQMKNw7DDiGNSwrLDrFx1MDAxNsKiwrzDr09WXHUwMDA2XFxcIi3DusOZa33CvVxcdmhvwocracKGXHUwMDEyw6fDuCE9Slx1MDAxZsOSw4zCrUknw6vDs8KlJMKzOUdiwqN8ScOkwpTCg8OaPU1GXHUwMDEzwodXwrbDrlJcdTAwMTPDv8KYw4DCmE9cXGbDjUXDtTJcdTAwMWRxw4TDh1htw6rDrVx1MDAxMkldXHUwMDFjwp7CsmhBLMO5XHUwMDBlccOXXHUwMDA0Z8KGXFxmwpfDl8KyMcOTwr7Ct13DhVx1MDAxZntxw5lcdTAwMTdcdTAwMTTCo8KSwqdAwrfDl1x1MDAwNMKAwrssw5XDhH7DsMOdw5vDtMOyXFxmVkh/XHUwMDBlwrJZw6DCnsKGNMO0V3FpwqXCpUDCjMKaw6FcdTAwMGXCgyhTR0Anw4RcdTAwMTNeSkhvw4LCqnvCk1vDgMO8wrjCv8ObOlx1MDAwNcKOwqzDhsOdw7Qnw6vCinvDn3DDk0jCm8O3QVx1MDAxZsKzw609QMOiw75ZXHUwMDE2SjZYX1xcXCLDgWzDizonw6FJXHUwMDE0KMOpwodfwrMud8KrwrTDmMOJw6zDqEF0ScKZRkLDsMKhZGRcdTAwMDdcdTAwMTbCtMK0wrVcXHZGw5XDvXVcdTAwMTHCp8KPw4vCvDfCvMKca8OWwqXCssODw7V3woh2wrUwwpLDn8KmXHUwMDFkw7HDpMOUSMOmw4xcdTAwMTXDlsOzw51cdTAwMWVZXHUwMDE5NcOaXHUwMDE5I2TDi1x1MDAxMcKPd8OUwqpVw4zClMKXwpUuXHUwMDFiwrBcdTAwMTE3wr/Ck8OFw7rDusOIeMKlw4koXHUwMDE1XFx2ZsOMw4/Dplx1MDAxN1HCtsOkwofDoz9mw49cdTAwMDJEw43Cq8KUwq5Zw6BbwqVyIUHDl8OTXHUwMDAyMMOncFx1MDAxZMKmSFJtbMO2w6XDhcKqV1x1MDAwZsOQXFxmdmZcdTAwMTDDkMKdc8K9OiMgJMKOw5QnwrHCucOewpsuwrx0XHUwMDFkw4lcdTAwMDfDmVLDqlx1MDAxMFx1MDAwM8KYwqcvwoVoeFx1MDAxZlt2w6pqw4hcXHRRXHUwMDFiwqTDi8OjVMKEwpVcXFxcSiBQTlx1MDAxMTLDj8KDwr1fw6zCnsOTwpZTwoLCt1XChm81w4/CrVZhXHUwMDA0w6DDk3DDlC/DizwjwoLDgcOOwp0hw4zDunZcdTAwMWPCpzHChsO2fmlZXHUwMDE3wqPDr8OIwoY+XHUwMDA3XHUwMDFjwpVcdTAwMTPDlsOEw65cdTAwMTTDgsOrwqjCksKxw6lawqU3w6rDsGnDvMK0wpldN8Oww5rDjMOMT1x1MDAwN8OVXHUwMDFmXHUwMDAxYsK5XHUwMDAxwp7Dr8Ocd1x1MDAwNcKnw4xAZsKswq7DlsOXXHUwMDA0wpXDu1dcdTAwMGV5w4h4fMK1bsK9w6hcdTAwMDMkwovCuMOnw55cdTAwMWbDsSRHOMOeY8KuXHUwMDBmwpjDnsOsWj1KwpxcdTAwMWVcdTAwMWUvNnXChsOjXHUwMDEzwq7Cs8KLw51nwqnCiC3DjsOtw7DDq8KQwrUxXzxcdTAwMGbCk8OAwojCl8OOwo7DqDTDsFx1MDAwNVx1MDAxZMO0wqpewr1Sw6NxOsOOW8OGZ8OCd0rDhMO/XHUwMDBmw6JcdTAwMTbCssKEXHUwMDEzw63Cnlx1MDAxM8OPXFx2U8KEwqZzwpPDvjVCw5lKwpV2w6DDsMOxw6/DtUfClMK6wqPDlnxXXHUwMDBlwqBkwqfDjHrCnV5iwrInLyk9TcKqwpVcdTAwMDHDiVnDm8OLbcOCw4HDscKPV8O/w4hbw75fwpJ3wqXCpMKrVlx1MDAxOEhmw43DmGEzXHUwMDEwXHUwMDE3PjBcdTAwMTfCvcKELmrChcOLwpxMXHUwMDE5woVcdTAwMWLDn8KYX8KBbMOeWiBZdcO5w7JDesO0Jj44w47DqMOxw7XCu8OkwpBIw5HCn8Koelx1MDAxOMKvfMKAw5tbZ8OMw6V2w719w73CvMKIwq4kwrRPwoJOblM4alx1MDAwZcOPwrc/LF3CpCvDlXk+wqEufivDo1xcZsKvwpVHO0jDisOXwoPCvCw+XFxmwpjCgsOfwo9yXHUwMDFiXj1KV3zDhlx1MDAxNsOBV8K9PUpEc8KoSXnChVx1MDAxNcOww4xbwrhcdTAwMDdYw6DCj3RcXGZcdTAwMDLDmjcqPU1FwrA7w5rCuMKlw59/fcOlXHUwMDFkw7rCi05GacOIw67ClMOkNnPDlcKhXFx2w4YjXFxmw73ChWVpw7lpwp/DlcK+a8O9TD1NXFxcXMOywoPDs3dVXFx0McKnwoszw5zDklbDmEchwqjClFxcXFzDu1x1MDAwMcOIf8OXXHUwMDA1w5TCicOfw4vDvjvDo8O3worCrXbDmFxcZsOLwo/CtkbDl1x1MDAwMcO0fcOETMKJw4dbXHUwMDE4w73CkMOrw6bCvFx1MDAxOMK9w4A+w7PDrCM5XHUwMDA2QMKkdsOuZsOTXHUwMDAxXHUwMDE3IMOtwrMwa8KadMK5NWd8w4k3wrrDvVx1MDAxOT1KX1x1MDAxOTPCocOdw7LDhUV0f8KPPsK2wo0gKsOsw6XCksKhwoFcdTAwMDZcdTAwMGbDo8Kmw4zDuS0pRV/DqC/Ci8K0M8KAw4k5S1PDu8KnwpPDpFTCkMOnw5pmXFx2wpZtwqXDnsO5w5U9SmvCkcOnasOUw5zCmWRcdTAwMDd8w4nDrDdzw6Now6hcdTAwMWLDpsK3w7bDjVZjwr5Cw6HCjcKJecOYPsK8w7BdXFx0XHUwMDAzwrtcXHY5bFJmw71ZwqbDrMKywrLDmETDvsKKw6N0XHUwMDExw4JKfGnDnDFPwphtMMOfLsKXw5w6N0xHccKtXHUwMDEzw4PCmMO4XHUwMDEww5FjwoNnPU3Cllx1MDAwZl13wrR9LyNXw5zDnGXDlMOIwoVYw7nCk8OAey7CmMKnw74wXHUwMDAyXlxcYsOKw4nCiVx1MDAxNMOSw48qw4TDvFx1MDAwZUQ5w59rw6I9QMKJw6lfwprCtlx1MDAwN8OSWE17w4nCsFxcdkxjw7zDuFknXHUwMDFjN1x1MDAxNT1KdHpaeMKuw67Cglx1MDAxYlTCplxcXCLCuzRKw4bCnsOnw4Vsw4nDuMKPwojDpmlcdTAwMDVww75VwpVgwqPCmD1AXHUwMDE0Tk/Cl1xcXCJcXGLDhFx1MDAxMMKTI8Oow4E4PU3DgFx1MDAxN1x1MDAxMsOBw4DDtWzCmFNCw7kxwo98wrtcdTAwMWFqYsOmwonDuGzCpCZCRMK3w5VcdTAwMDYkXHUwMDA1J8KjwqfDmCxHwo3DscOBXHUwMDA0wqpPWT4odcOJw6/CmMO1w6XCqzA5ZsKNw4gkwrPCiCXDrcKcwrRKwoTDocKqL8ORw6nClcKtacKDasKDwoVcXFxcL8K4wpZzw5p2w7Fjw69/w748csKBwojDnsKFbsOfKU5rw7TDtsOgwqLDi8ORwo1cXFxcdcOzwpbCr2LDnMObecK9XFxmwrbDiG5cdTAwMDPCinTDs2XDlVx1MDAxYsKCw6TDi1x1MDAwZcKAd8KowpXDscOSwp44PUA9fVx1MDAxOVx1MDAwZnfDmMOvWkTCqMOpYVHDhcOVZMKfwqtMd1xcYsKkwoPCsUs9Slx1MDAxOUd0w4kyw6DDmmPDmXtAwrlfw79cXGLCmcOHdyk8esK5wrXDvcOXXcK7NMOqXHUwMDEwwoFTwrJ5w7VcdTAwMWFcdTAwMTFcdTAwMTJcdTAwMTdNw4TCjMOtRsKawqDDg0LDhWdtw6rCm1nDvcKbc8OAdFJcdTAwMGZQw58hTcKAUsO2wpkxJkVew6LCjcKpKcOCJUElXcOXw7pcdTAwMTLDh8OZwoNDwotswrfClV1OPX3CiMKwccKfwqjDuUjDlUdXw5JcXHTDksKmK1xcYkTDvcKKw6bDmzBowqh0wpshXT1Awottw7tsScO+K8Orw5bCv8OtWsKGXHUwMDFkw5jCt0Btw5pTMsKmwpRtX8KDwrdcdTAwMDNXwpYkXHUwMDA1w7pcXGZcXHbCtD1Kw5/DiUU7wqFEXFxcIsOswrXCqFx1MDAxZmrDkcODw5rCklx1MDAwZXIwXHUwMDFkKcOlw7ggXFxcXFFcdTAwMWbDlmnDhSguLGfDn8KIXFx2asKoXFxiw5gqw7/CkMOrw4zDu8OJw4DDplxcYsKLwqJtQMKkKsKmXFx2b8OpwqIqQ8KWw7tcdTAwMTPCtsKMPUo1WSQjw5nDucKbwqDDmlfDvMKVRk/DlD19XFxcIsOswrXCqFx1MDAxYmLDvCHCq8KKXHUwMDA1XHUwMDFhwoHCiFx1MDAxZcKpw6jCrcKUw6nDq8OML8OqOsK6XHUwMDE2w6fCkFx1MDAwM8OANcKrWcOmXHUwMDEyQcOZOGQ2wo7CkcOewqRcdTAwMGZvw5nCn8Ouw6hcdTAwMWMpwp1ZecO8w7/DqsOVeMOTwrkww6hcdTAwMWHCqVxcYsOWwpBPWlx1MDAxM1x1MDAxNMOjw5kkw4NBJ1xcdFx1MDAxOSnDs8KtwpTDncKLw7s9SjbDvX8oMVwiKSk7dmFyICQsbSxILEkscSxSLGs9e2E6e2I6ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGguY29zKHQpfSxhOmZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLmV4cCh0KX0sYzpmdW5jdGlvbih0LGYsdil7cC5jb3B5V2l0aGluKHQsZixmK3YpfSxkOmZ1bmN0aW9uKHQpe3AubGVuZ3RoLGZ1bmN0aW9uKHQpe3Rocm93XCJPT01cIn0oKX19fTtXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShPLndhc20saykudGhlbigoZnVuY3Rpb24odCl7dmFyIGYsdj10Lmluc3RhbmNlLmV4cG9ydHM7JD12LmcsbT12LmgsSD12LmksST12LmoscT12LmssUj12Lmwsdi5tLGY9di5lLmJ1ZmZlcixuZXcgSW50OEFycmF5KGYpLG5ldyBJbnQxNkFycmF5KGYpLG5ldyBJbnQzMkFycmF5KGYpLHA9bmV3IFVpbnQ4QXJyYXkoZiksbmV3IFVpbnQxNkFycmF5KGYpLG5ldyBVaW50MzJBcnJheShmKSxRPW5ldyBGbG9hdDMyQXJyYXkoZiksbmV3IEZsb2F0NjRBcnJheShmKSxmdW5jdGlvbih0KXt0LmYoKX0odiksZygpfSkpO2NvbnN0IFQ9bmV3IFByb21pc2UoKHQ9PntnPXR9KSksWT0odCxmKT0+e2NvbnN0IHY9bmV3IEZsb2F0MzJBcnJheShmKTtsZXQgYj0wO2Zvcihjb25zdCBNIG9mIHQpdi5zZXQoTSxiKSxiKz1NLmxlbmd0aDtyZXR1cm4gdn07Y2xhc3MgWntjb25zdHJ1Y3Rvcih0LGYpe3RoaXMuY2hhbm5lbERhdGE9dCx0aGlzLnNhbXBsZXNEZWNvZGVkPWYsdGhpcy5zYW1wbGVSYXRlPTQ4ZTN9fWNsYXNzIE57Y29uc3RydWN0b3IodCl7dGhpcy5yZWFkeT1ULHRoaXMub25EZWNvZGU9dC5vbkRlY29kZSx0aGlzLm9uRGVjb2RlQWxsPXQub25EZWNvZGVBbGx9cCh0KXtjb25zdCBmPUkoRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKnQpO3JldHVybltmLG5ldyBGbG9hdDMyQXJyYXkoUS5idWZmZXIsZix0KV19ZGVjb2RlKHQpe2lmKCEodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKXRocm93IEVycm9yKFwiRGF0YSB0byBkZWNvZGUgbXVzdCBiZSBVaW50OEFycmF5XCIpO3RoaXMuT3x8KHRoaXMuTz1IKCkpO2xldCBmLHYsYixNLEoscixlLGE9W10sbj1bXSxpPTA7dHJ5e2NvbnN0IG89MTE1MjA7W3YsYl09dGhpcy5wKG8pLFtNLEpdPXRoaXMucChvLzIpLFtyLGVdPXRoaXMucChvLzIpO2xldCBzLHU9NjU1MzYsYz0wO2NvbnN0IGg9dC5ieXRlTGVuZ3RoO2ZvcihmPUkodC5CWVRFU19QRVJfRUxFTUVOVCp1KTtjPGg7KXtpZihzPU1hdGgubWluKHUsaC1jKSxwLnNldCh0LnN1YmFycmF5KGMsYytzKSxmKSxjKz1zLCEkKHRoaXMuTyxmLHMpKXRocm93IEVycm9yKFwiQ291bGQgbm90IGVucXVldWUgYnl0ZXMgZm9yIGRlY29kaW5nLiAgWW91IG1heSBhbHNvIGhhdmUgaW52YWxpZCBPZ2cgT3B1cyBmaWxlLlwiKTtsZXQgYjtmb3IoOyhiPW0odGhpcy5PLHYsbyxNLHIpKT4wOyl7Y29uc3QgdD1KLnNsaWNlKDAsYiksZj1lLnNsaWNlKDAsYik7dGhpcy5vbkRlY29kZSYmdGhpcy5vbkRlY29kZShuZXcgWihbdCxmXSxiKSksdGhpcy5vbkRlY29kZUFsbCYmKGEucHVzaCh0KSxuLnB1c2goZiksaSs9Yil9aWYoYjwwKXRocm93IEVycm9yKGBsaWJvcHVzZmlsZSAke2J9OiAke3tbLTFdOlwiQSByZXF1ZXN0IGRpZCBub3Qgc3VjY2VlZC5cIixbLTNdOlwiVGhlcmUgd2FzIGEgaG9sZSBpbiB0aGUgcGFnZSBzZXF1ZW5jZSBudW1iZXJzIChlLmcuLCBhIHBhZ2Ugd2FzIGNvcnJ1cHQgb3IgbWlzc2luZykuXCIsWy0xMjhdOlwiQW4gdW5kZXJseWluZyByZWFkLCBzZWVrLCBvciB0ZWxsIG9wZXJhdGlvbiBmYWlsZWQgd2hlbiBpdCBzaG91bGQgaGF2ZSBzdWNjZWVkZWQuXCIsWy0xMjldOlwiQSBOVUxMIHBvaW50ZXIgd2FzIHBhc3NlZCB3aGVyZSBvbmUgd2FzIHVuZXhwZWN0ZWQsIG9yIGFuIGludGVybmFsIG1lbW9yeSBhbGxvY2F0aW9uIGZhaWxlZCwgb3IgYW4gaW50ZXJuYWwgbGlicmFyeSBlcnJvciB3YXMgZW5jb3VudGVyZWQuXCIsWy0xMzBdOlwiVGhlIHN0cmVhbSB1c2VkIGEgZmVhdHVyZSB0aGF0IGlzIG5vdCBpbXBsZW1lbnRlZCwgc3VjaCBhcyBhbiB1bnN1cHBvcnRlZCBjaGFubmVsIGZhbWlseS5cIixbLTEzMV06XCJPbmUgb3IgbW9yZSBwYXJhbWV0ZXJzIHRvIGEgZnVuY3Rpb24gd2VyZSBpbnZhbGlkLlwiLFstMTMyXTonQSBwdXJwb3J0ZWQgT2dnIE9wdXMgc3RyZWFtIGRpZCBub3QgYmVnaW4gd2l0aCBhbiBPZ2cgcGFnZSwgYSBwdXJwb3J0ZWQgaGVhZGVyIHBhY2tldCBkaWQgbm90IHN0YXJ0IHdpdGggb25lIG9mIHRoZSByZXF1aXJlZCBzdHJpbmdzLCBcIk9wdXNIZWFkXCIgb3IgXCJPcHVzVGFnc1wiLCBvciBhIGxpbmsgaW4gYSBjaGFpbmVkIGZpbGUgd2FzIGVuY291bnRlcmVkIHRoYXQgZGlkIG5vdCBjb250YWluIGFueSBsb2dpY2FsIE9wdXMgc3RyZWFtcy4nLFstMTMzXTpcIkEgcmVxdWlyZWQgaGVhZGVyIHBhY2tldCB3YXMgbm90IHByb3Blcmx5IGZvcm1hdHRlZCwgY29udGFpbmVkIGlsbGVnYWwgdmFsdWVzLCBvciB3YXMgbWlzc2luZyBhbHRvZ2V0aGVyLlwiLFstMTM0XTpcIlRoZSBJRCBoZWFkZXIgY29udGFpbmVkIGFuIHVucmVjb2duaXplZCB2ZXJzaW9uIG51bWJlci5cIixbLTEzNl06XCJBbiBhdWRpbyBwYWNrZXQgZmFpbGVkIHRvIGRlY29kZSBwcm9wZXJseS4gVGhpcyBpcyB1c3VhbGx5IGNhdXNlZCBieSBhIG11bHRpc3RyZWFtIE9nZyBwYWNrZXQgd2hlcmUgdGhlIGR1cmF0aW9ucyBvZiB0aGUgaW5kaXZpZHVhbCBPcHVzIHBhY2tldHMgY29udGFpbmVkIGluIGl0IGFyZSBub3QgYWxsIHRoZSBzYW1lLlwiLFstMTM3XTpcIldlIGZhaWxlZCB0byBmaW5kIGRhdGEgd2UgaGFkIHNlZW4gYmVmb3JlLCBvciB0aGUgYml0c3RyZWFtIHN0cnVjdHVyZSB3YXMgc3VmZmljaWVudGx5IG1hbGZvcm1lZCB0aGF0IHNlZWtpbmcgdG8gdGhlIHRhcmdldCBkZXN0aW5hdGlvbiB3YXMgaW1wb3NzaWJsZS5cIixbLTEzOF06XCJBbiBvcGVyYXRpb24gdGhhdCByZXF1aXJlcyBzZWVraW5nIHdhcyByZXF1ZXN0ZWQgb24gYW4gdW5zZWVrYWJsZSBzdHJlYW0uXCIsWy0xMzldOlwiVGhlIGZpcnN0IG9yIGxhc3QgZ3JhbnVsZSBwb3NpdGlvbiBvZiBhIGxpbmsgZmFpbGVkIGJhc2ljIHZhbGlkaXR5IGNoZWNrcy5cIn1bYl18fFwiVW5rbm93biBFcnJvclwifWApfXRoaXMub25EZWNvZGVBbGwmJmkmJnRoaXMub25EZWNvZGVBbGwobmV3IFooW1koYSxpKSxZKG4saSldLGkpKX1jYXRjaChvKXt0aHJvdyBvfWZpbmFsbHl7UihmKSxSKHYpLFIoTSksUihyKX19ZnJlZSgpe3RoaXMuTyYmcSh0aGlzLk8pfX1PLk9nZ09wdXNEZWNvZGVyPU4sXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbCYmZXhwb3J0cyYmKG1vZHVsZS5leHBvcnRzLk9nZ09wdXNEZWNvZGVyPU4pfSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2dnLW9wdXMtZGVjb2Rlci5taW4uanMubWFwIiwiY29uc3QgeyBFdmVudFRhcmdldCwgZGVmaW5lRXZlbnRBdHRyaWJ1dGUgfSA9IHJlcXVpcmUoJ2V2ZW50LXRhcmdldC1zaGltJyk7XG5jb25zdCB7IGRldGVjdCB9ID0gcmVxdWlyZSgnZGV0ZWN0LWJyb3dzZXInKTtcbmNvbnN0IGJyb3dzZXIgPSBkZXRlY3QoKTtcblxuY29uc3QgQXVkaW9Db250ZXh0ID0gZ2xvYmFsLkF1ZGlvQ29udGV4dCB8fCBnbG9iYWwud2Via2l0QXVkaW9Db250ZXh0O1xuY29uc3QgQlVGRkVSX1NJWkUgPSA0MDk2O1xuXG4vKipcbiAqIFJlZmVyZW5jZTogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL21lZGlhY2FwdHVyZS1yZWNvcmQvI21lZGlhcmVjb3JkZXItYXBpXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICovXG5jbGFzcyBPcHVzTWVkaWFSZWNvcmRlciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBlbmNvZGVyIHdlYiB3b3JrZXJcbiAgICogQG5hbWUgd29ya2VyRmFjdG9yeVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMge3dvcmtlcn0gQW4gaW5zdGFuY2Ugb2YgLi9lbmNvZGVyV29ya2VyLmpzIHdlYiB3b3JrZXIuXG4gICAqL1xuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW0gLSBUaGUgTWVkaWFTdHJlYW0gdG8gYmUgcmVjb3JkZWQuIFRoaXMgd2lsbFxuICAgKiAgICAgICAgICBiZSB0aGUgdmFsdWUgb2YgdGhlIHN0cmVhbSBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSB7TWVkaWFSZWNvcmRlck9wdGlvbnN9IFtvcHRpb25zXSAtIEEgZGljdGlvbmFyeSBvZiBvcHRpb25zIHRvIGZvclxuICAgKiAgICAgICAgICB0aGUgVUEgaW5zdHJ1Y3RpbmcgaG93IHRoZSByZWNvcmRpbmcgd2lsbCB0YWtlIHBhcnQuXG4gICAqICAgICAgICAgIG9wdGlvbnMubWltZVR5cGUsIGlmIHByZXNlbnQsIHdpbGwgYmVjb21lIHRoZSB2YWx1ZSBvZiBtaW1lVHlwZVxuICAgKiAgICAgICAgICBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbd29ya2VyT3B0aW9uc10gVGhpcyBpcyBhIE5PTi1TVEFOREFSRCBvcHRpb25zIHRvXG4gICAqICAgICAgICAgIGNvbmZpZ3VyZSBob3cgdG8gaW1wb3J0IHRoZSB3ZWIgd29ya2VyIC53YXNtIGNvbXBpbGVkIGJpbmFyaWVzXG4gICAqICAgICAgICAgIHVzZWQgZm9yIGVuY29kaW5nLlxuICAgKiBAcGFyYW0ge3dvcmtlckZhY3Rvcnl9IFt3b3JrZXJPcHRpb25zLmVuY29kZXJXb3JrZXJGYWN0b3J5XSBBIGZhY3RvcnlcbiAgICogICAgICAgICAgZnVuY3Rpb24gdGhhdCBjcmVhdGUgYSB3ZWIgd29ya2VyIGluc3RhbmNlIG9mIC4vZW5jb2Rlcldvcmtlci5qc1xuICAgKiAgICAgICAgICBhbmQgcmV0dXJucyBpdC4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFdvcmtlcignLi9lbmNvZGVyV29ya2VyLnVtZC5qcycpfVxuICAgKiAgICAgICAgICBpcyB1c2VkIGJ5IGRlZmF1bHQuIFRoaXMgaXMgTk9OLVNUQU5EQVJELlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3dvcmtlck9wdGlvbnMuT2dnT3B1c0VuY29kZXJXYXNtUGF0aF1cbiAgICogICAgICAgICAgUGF0aCBvZiAuL09nZ09wdXNFbmNvZGVyLndhc20gd2hpY2ggaXMgdXNlZCBmb3IgT0dHIE9wdXMgZW5jb2RpbmdcbiAgICogICAgICAgICAgYnkgdGhlIGVuY29kZXIgd29ya2VyLiBUaGlzIGlzIE5PTi1TVEFOREFSRC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt3b3JrZXJPcHRpb25zLldlYk1PcHVzRW5jb2Rlcldhc21QYXRoXVxuICAgKiAgICAgICAgICBQYXRoIG9mIC4vV2ViTU9wdXNFbmNvZGVyLndhc20gd2hpY2ggaXMgdXNlZCBmb3IgV2ViTSBPcHVzIGVuY29kaW5nXG4gICAqICAgICAgICAgIGJ5IHRoZSBlbmNvZGVyIHdvcmtlci4gVGhpcyBpcyBOT04tU1RBTkRBUkQuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc3RyZWFtLCBvcHRpb25zID0ge30sIHdvcmtlck9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbWltZVR5cGUsIGF1ZGlvQml0c1BlclNlY29uZCwgdmlkZW9CaXRzUGVyU2Vjb25kLCBiaXRzUGVyU2Vjb25kIH0gPSBvcHRpb25zOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgLy8gTk9OLVNUQU5EQVJEIG9wdGlvbnNcbiAgICBjb25zdCB7IGVuY29kZXJXb3JrZXJGYWN0b3J5LCBPZ2dPcHVzRW5jb2Rlcldhc21QYXRoLCBXZWJNT3B1c0VuY29kZXJXYXNtUGF0aCB9ID0gd29ya2VyT3B0aW9ucztcblxuICAgIHN1cGVyKCk7XG4gICAgLy8gQXR0cmlidXRlcyBmb3IgdGhlIHNwZWNpZmljYXRpb24gY29uZm9ybWFuY2UuIFRoZXNlIGhhdmUgdGhlaXIgb3duIGdldHRlcnMuXG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3N0YXRlID0gJ2luYWN0aXZlJztcbiAgICB0aGlzLl9taW1lVHlwZSA9IG1pbWVUeXBlIHx8ICcnO1xuICAgIHRoaXMuX2F1ZGlvQml0c1BlclNlY29uZCA9IGF1ZGlvQml0c1BlclNlY29uZCB8fCBiaXRzUGVyU2Vjb25kO1xuICAgIC8qKiBAdHlwZSB7J2luYWN0aXZlJ3wncmVhZHlUb0luaXQnfCdlbmNvZGluZyd8J2Nsb3NlZCd9ICovXG4gICAgdGhpcy53b3JrZXJTdGF0ZSA9ICdpbmFjdGl2ZSc7XG5cbiAgICAvLyBQYXJzZSBNSU1FIFR5cGVcbiAgICBpZiAoIU9wdXNNZWRpYVJlY29yZGVyLmlzVHlwZVN1cHBvcnRlZCh0aGlzLl9taW1lVHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnRzLCBhIE1JTUUgVHlwZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIHN3aXRjaCAoT3B1c01lZGlhUmVjb3JkZXIuX3BhcnNlVHlwZSh0aGlzLl9taW1lVHlwZSkuc3VidHlwZSkge1xuICAgICAgY2FzZSAnd2F2ZSc6XG4gICAgICBjYXNlICd3YXYnOlxuICAgICAgICB0aGlzLl9taW1lVHlwZSA9ICdhdWRpby93YXZlJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3dlYm0nOlxuICAgICAgICB0aGlzLl9taW1lVHlwZSA9ICdhdWRpby93ZWJtJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29nZyc6XG4gICAgICAgIHRoaXMuX21pbWVUeXBlID0gJ2F1ZGlvL29nZyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBTZWxlY3QgYSB0eXBlIGRlcGVuZGluZyBvbiBPUy5cbiAgICAgICAgc3dpdGNoIChicm93c2VyICYmIGJyb3dzZXIubmFtZSkge1xuICAgICAgICAgIGNhc2UgJ2Nocm9tZSc6XG4gICAgICAgICAgICB0aGlzLl9taW1lVHlwZSA9ICdhdWRpby93ZWJtJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZmlyZWZveCc6XG4gICAgICAgICAgICB0aGlzLl9taW1lVHlwZSA9ICdhdWRpby9vZ2cnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdlZGdlJzpcbiAgICAgICAgICAgIHRoaXMuX21pbWVUeXBlID0gJ2F1ZGlvL3dlYm0nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdpb3MnOlxuICAgICAgICAgIGNhc2UgJ3NhZmFyaSc6XG4gICAgICAgICAgICB0aGlzLl9taW1lVHlwZSA9ICdhdWRpby93YXZlJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuX21pbWVUeXBlID0gJ2F1ZGlvL3dlYm0nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5fbWltZVR5cGUpIHtcbiAgICAgIGNhc2UgJ2F1ZGlvL3dhdmUnOlxuICAgICAgICB0aGlzLl93YXNtUGF0aCA9ICcnOyAvLyB3YXNtIGlzIG5vdCB1c2VkXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhdWRpby93ZWJtJzpcbiAgICAgICAgdGhpcy5fd2FzbVBhdGggPSBXZWJNT3B1c0VuY29kZXJXYXNtUGF0aCB8fCAnJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2F1ZGlvL29nZyc6XG4gICAgICAgIHRoaXMuX3dhc21QYXRoID0gT2dnT3B1c0VuY29kZXJXYXNtUGF0aCB8fCAnJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgRXJyb3I6IFVuZXhwZWN0ZWQgTUlNRSBUeXBlOiAke3RoaXMuX21pbWVUeXBlfWApO1xuICAgIH1cblxuICAgIC8vIEdldCBjdXJyZW50IGRpcmVjdG9yeSBmb3Igd29ya2VyXG4gICAgbGV0IHdvcmtlckRpciA9ICcnO1xuICAgIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgICB3b3JrZXJEaXIgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcbiAgICB9IGVsc2UgaWYgKHNlbGYubG9jYXRpb24pIHtcbiAgICAgIHdvcmtlckRpciA9IHNlbGYubG9jYXRpb24uaHJlZjtcbiAgICB9XG4gICAgd29ya2VyRGlyID0gd29ya2VyRGlyLnN1YnN0cigwLCB3b3JrZXJEaXIubGFzdEluZGV4T2YoJy8nKSkgK1xuICAgICAgICAgICAgICAgICcvZW5jb2Rlcldvcmtlci51bWQuanMnO1xuICAgIC8vIElmIHdvcmtlciBmdW5jdGlvbiBpcyBpbXBvcnRlZCB2aWEgPHNjcmlwdD4gdGFnLCBtYWtlIGl0IGJsb2IgdG8gZ2V0IFVSTC5cbiAgICBpZiAodHlwZW9mIE9wdXNNZWRpYVJlY29yZGVyLmVuY29kZXJXb3JrZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtlckRpciA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2AoJHtPcHVzTWVkaWFSZWNvcmRlci5lbmNvZGVyV29ya2VyfSkoKWBdKSk7XG4gICAgfVxuXG4gICAgLy8gU3Bhd24gYSBlbmNvZGVyIHdvcmtlclxuICAgIHRoaXMuX3dvcmtlckZhY3RvcnkgPSB0eXBlb2YgZW5jb2RlcldvcmtlckZhY3RvcnkgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVuY29kZXJXb3JrZXJGYWN0b3J5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfID0+IG5ldyBXb3JrZXIod29ya2VyRGlyKTtcbiAgICB0aGlzLl9zcGF3bldvcmtlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBNZWRpYVN0cmVhbSBbR0VUVVNFUk1FRElBXSB0byBiZSByZWNvcmRlZC5cbiAgICogQHJldHVybiB7TWVkaWFTdHJlYW19XG4gICAqL1xuICBnZXQgc3RyZWFtICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBNSU1FIHR5cGUgW1JGQzIwNDZdIHRoYXQgaGFzIGJlZW4gc2VsZWN0ZWQgYXMgdGhlIGNvbnRhaW5lciBmb3JcbiAgICogcmVjb3JkaW5nLiBUaGlzIGVudHJ5IGluY2x1ZGVzIGFsbCB0aGUgcGFyYW1ldGVycyB0byB0aGUgYmFzZVxuICAgKiBtaW1lVHlwZS4gVGhlIFVBIHNob3VsZCBiZSBhYmxlIHRvIHBsYXkgYmFjayBhbnkgb2YgdGhlIE1JTUUgdHlwZXNcbiAgICogaXQgc3VwcG9ydHMgZm9yIHJlY29yZGluZy4gRm9yIGV4YW1wbGUsIGl0IHNob3VsZCBiZSBhYmxlIHRvIGRpc3BsYXlcbiAgICogYSB2aWRlbyByZWNvcmRpbmcgaW4gdGhlIEhUTUwgPHZpZGVvPiB0YWcuIFRoZSBkZWZhdWx0IHZhbHVlIGZvclxuICAgKiB0aGlzIHByb3BlcnR5IGlzIHBsYXRmb3JtLXNwZWNpZmljLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbWltZVR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9taW1lVHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgT3B1c01lZGlhUmVjb3JkZXIgb2JqZWN0LiBXaGVuIHRoZSBPcHVzTWVkaWFSZWNvcmRlclxuICAgKiBpcyBjcmVhdGVkLCB0aGUgVUEgTVVTVCBzZXQgdGhpcyBhdHRyaWJ1dGUgdG8gaW5hY3RpdmUuXG4gICAqIEByZXR1cm4ge1wiaW5hY3RpdmVcInxcInJlY29yZGluZ1wifFwicGF1c2VkXCJ9XG4gICAqL1xuICBnZXQgc3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIFZpZGVvIGVuY29kaW5nLiBVbnN1cHBvcnRlZC5cbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0IHZpZGVvQml0c1BlclNlY29uZCAoKSB7XG4gICAgLy8gVmlkZW8gZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBBdWRpbyBlbmNvZGluZyB0YXJnZXQgYml0IHJhdGUgdGhhdCB3YXMgcGFzc2VkIHRvXG4gICAqIHRoZSBQbGF0Zm9ybSAocG90ZW50aWFsbHkgdHJ1bmNhdGVkLCByb3VuZGVkLCBldGMpLCBvciB0aGUgY2FsY3VsYXRlZCBvbmVcbiAgICogaWYgdGhlIHVzZXIgaGFzIHNwZWNpZmllZCBiaXRzUGVyU2Vjb25kLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0IGF1ZGlvQml0c1BlclNlY29uZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1ZGlvQml0c1BlclNlY29uZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHdvcmtlclxuICAgKi9cbiAgX3NwYXduV29ya2VyICgpIHtcbiAgICB0aGlzLndvcmtlciA9IHRoaXMuX3dvcmtlckZhY3RvcnkoKTtcbiAgICB0aGlzLndvcmtlci5vbm1lc3NhZ2UgPSAoZSkgPT4gdGhpcy5fb25tZXNzYWdlRnJvbVdvcmtlcihlKTtcbiAgICB0aGlzLndvcmtlci5vbmVycm9yID0gKGUpID0+IHRoaXMuX29uZXJyb3JGcm9tV29ya2VyKGUpO1xuXG4gICAgdGhpcy5fcG9zdE1lc3NhZ2VUb1dvcmtlcignbG9hZEVuY29kZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBtaW1lVHlwZTogdGhpcy5fbWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc21QYXRoOiB0aGlzLl93YXNtUGF0aCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3N0IG1lc3NhZ2UgdG8gdGhlIGVuY29kZXIgd2ViIHdvcmtlci5cbiAgICogQHBhcmFtIHtcImluaXRcInxcInB1c2hJbnB1dERhdGFcInxcImdldEVuY29kZWREYXRhXCJ8XCJkb25lXCJ9IGNvbW1hbmQgLSBUeXBlIG9mIG1lc3NhZ2UgdG8gc2VuZCB0byB0aGUgd29ya2VyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtZXNzYWdlIC0gUGF5bG9hZCB0byB0aGUgd29ya2VyXG4gICAqL1xuICBfcG9zdE1lc3NhZ2VUb1dvcmtlciAoY29tbWFuZCwgbWVzc2FnZSA9IHt9KSB7XG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICBjYXNlICdsb2FkRW5jb2Rlcic6XG4gICAgICAgIGxldCB7IG1pbWVUeXBlLCB3YXNtUGF0aCB9ID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoeyBjb21tYW5kLCBtaW1lVHlwZSwgd2FzbVBhdGggfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgd29ya2VyXG4gICAgICAgIGxldCB7IHNhbXBsZVJhdGUsIGNoYW5uZWxDb3VudCwgYml0c1BlclNlY29uZCB9ID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoeyBjb21tYW5kLCBzYW1wbGVSYXRlLCBjaGFubmVsQ291bnQsIGJpdHNQZXJTZWNvbmQgfSk7XG4gICAgICAgIHRoaXMud29ya2VyU3RhdGUgPSAnZW5jb2RpbmcnO1xuXG4gICAgICAgIC8vIFN0YXJ0IHN0cmVhbWluZ1xuICAgICAgICB0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMucHJvY2Vzc29yKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3IuY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICBsZXQgZXZlbnRUb1B1c2ggPSBuZXcgZ2xvYmFsLkV2ZW50KCdzdGFydCcpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnRUb1B1c2gpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncHVzaElucHV0RGF0YSc6XG4gICAgICAgIC8vIFBhc3MgaW5wdXQgYXVkaW8gYnVmZmVyIHRvIHRoZSBlbmNvZGVyIHRvIGVuY29kZS5cbiAgICAgICAgLy8gVGhlIHdvcmtlciBNQVkgdHJpZ2dlciAnZW5jb2RlZERhdGEnLlxuICAgICAgICBsZXQgeyBjaGFubmVsQnVmZmVycywgbGVuZ3RoLCBkdXJhdGlvbiB9ID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGNvbW1hbmQsIGNoYW5uZWxCdWZmZXJzLCBsZW5ndGgsIGR1cmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZ2V0RW5jb2RlZERhdGEnOlxuICAgICAgICAvLyBSZXF1ZXN0IGVuY29kZWQgcmVzdWx0LlxuICAgICAgICAvLyBFeHBlY3RlZCAnZW5jb2RlZERhdGEnIGV2ZW50IGZyb20gdGhlIHdvcmtlclxuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7IGNvbW1hbmQgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgLy8gVGVsbCBlbmNvZGVyIGZpbmFsbGl6ZSB0aGUgam9iIGFuZCBkZXN0b3J5IGl0c2VsZi5cbiAgICAgICAgLy8gRXhwZWN0ZWQgJ2xhc3RFbmNvZGVkRGF0YScgZXZlbnQgZnJvbSB0aGUgd29ya2VyLlxuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7IGNvbW1hbmQgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBUaGlzIGlzIGFuIGVycm9yIGNhc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBFcnJvcjogSW5jb3JyZWN0IHBvc3RNZXNzYWdlIHJlcXVlc3RlZC4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogb25tZXNzYWdlKCkgY2FsbGJhY2sgZnJvbSB0aGUgd29ya2VyLlxuICAgKiBAcGFyYW0ge21lc3NhZ2V9IGV2ZW50IC0gbWVzc2FnZSBmcm9tIHRoZSB3b3JrZXJcbiAgICovXG4gIF9vbm1lc3NhZ2VGcm9tV29ya2VyIChldmVudCkge1xuICAgIGNvbnN0IHsgY29tbWFuZCwgYnVmZmVycyB9ID0gZXZlbnQuZGF0YTtcbiAgICBsZXQgZXZlbnRUb1B1c2g7XG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICBjYXNlICdyZWFkeVRvSW5pdCc6XG4gICAgICAgIGNvbnN0IHsgc2FtcGxlUmF0ZSwgY2hhbm5lbENvdW50IH0gPSB0aGlzO1xuICAgICAgICB0aGlzLndvcmtlclN0YXRlID0gJ3JlYWR5VG9Jbml0JztcblxuICAgICAgICAvLyBJZiBzdGFydCgpIGlzIGFscmVhZHkgY2FsbGVkIGluaXRpYWxpemUgd29ya2VyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAncmVjb3JkaW5nJykge1xuICAgICAgICAgIHRoaXMuX3Bvc3RNZXNzYWdlVG9Xb3JrZXIoJ2luaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzYW1wbGVSYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdHNQZXJTZWNvbmQ6IHRoaXMuYXVkaW9CaXRzUGVyU2Vjb25kfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2VuY29kZWREYXRhJzpcbiAgICAgIGNhc2UgJ2xhc3RFbmNvZGVkRGF0YSc6XG4gICAgICAgIGxldCBkYXRhID0gbmV3IEJsb2IoYnVmZmVycywgeyd0eXBlJzogdGhpcy5fbWltZVR5cGV9KTtcbiAgICAgICAgZXZlbnRUb1B1c2ggPSBuZXcgZ2xvYmFsLkV2ZW50KCdkYXRhYXZhaWxhYmxlJyk7XG4gICAgICAgIGV2ZW50VG9QdXNoLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnRUb1B1c2gpO1xuXG4gICAgICAgIC8vIERldGVjdCBvZiBzdG9wKCkgY2FsbGVkIGJlZm9yZVxuICAgICAgICBpZiAoY29tbWFuZCA9PT0gJ2xhc3RFbmNvZGVkRGF0YScpIHtcbiAgICAgICAgICBldmVudFRvUHVzaCA9IG5ldyBnbG9iYWwuRXZlbnQoJ3N0b3AnKTtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnRUb1B1c2gpO1xuXG4gICAgICAgICAgdGhpcy53b3JrZXJTdGF0ZSA9ICdjbG9zZWQnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhazsgLy8gSWdub3JlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIG9uZXJyb3IoKSBjYWxsYmFjayBmcm9tIHRoZSB3b3JrZXIuXG4gICAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXJyb3IgLSBlcnJvciBvYmplY3QgZnJvbSB0aGUgd29ya2VyXG4gICAqL1xuICBfb25lcnJvckZyb21Xb3JrZXIgKGVycm9yKSB7XG4gICAgLy8gU3RvcCBzdHJlYW0gZmlyc3RcbiAgICB0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5wcm9jZXNzb3IuZGlzY29ubmVjdCgpO1xuXG4gICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgdGhpcy53b3JrZXJTdGF0ZSA9ICdjbG9zZWQnO1xuXG4gICAgLy8gU2VuZCBtZXNzYWdlIHRvIGhvc3RcbiAgICBsZXQgbWVzc2FnZSA9IFtcbiAgICAgICdGaWxlTmFtZTogJyArIGVycm9yLmZpbGVuYW1lLFxuICAgICAgJ0xpbmVOdW1iZXI6ICcgKyBlcnJvci5saW5lbm8sXG4gICAgICAnTWVzc2FnZTogJyArIGVycm9yLm1lc3NhZ2VcbiAgICBdLmpvaW4oJyAtICcpO1xuICAgIGxldCBlcnJvclRvUHVzaCA9IG5ldyBnbG9iYWwuRXZlbnQoJ2Vycm9yJyk7XG4gICAgZXJyb3JUb1B1c2gubmFtZSA9ICdVbmtub3duRXJyb3InO1xuICAgIGVycm9yVG9QdXNoLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvclRvUHVzaCk7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlIG9uYXVkaW9wcm9jZXNzKCkgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc2xpY2UgLSBJbiBzZWNvbmRzLiBPcHVzTWVkaWFSZWNvcmRlciBzaG91bGQgcmVxdWVzdCBkYXRhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSB0aGUgd29ya2VyIGV2ZXJ5IHRpbWVzbGljZSBzZWNvbmRzLlxuICAgKi9cbiAgX2VuYWJsZUF1ZGlvUHJvY2Vzc0NhbGxiYWNrICh0aW1lc2xpY2UpIHtcbiAgICAvLyBwYXNzIGZyYW1lIGJ1ZmZlcnMgdG8gdGhlIHdvcmtlclxuICAgIGxldCBlbGFwc2VkVGltZSA9IDA7XG4gICAgdGhpcy5wcm9jZXNzb3Iub25hdWRpb3Byb2Nlc3MgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgeyBpbnB1dEJ1ZmZlciwgcGxheWJhY2tUaW1lIH0gPSBlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBjb25zdCB7IHNhbXBsZVJhdGUsIGxlbmd0aCwgZHVyYXRpb24sIG51bWJlck9mQ2hhbm5lbHMgfSA9IGlucHV0QnVmZmVyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgIC8vIENyZWF0ZSBjaGFubmVsIGJ1ZmZlcnMgdG8gcGFzcyB0byB0aGUgd29ya2VyXG4gICAgICBjb25zdCBjaGFubmVsQnVmZmVycyA9IG5ldyBBcnJheShudW1iZXJPZkNoYW5uZWxzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDaGFubmVsczsgaSsrKSB7XG4gICAgICAgIGNoYW5uZWxCdWZmZXJzW2ldID0gaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhc3MgZGF0YSB0byB0aGUgd29ya2VyXG4gICAgICBjb25zdCBtZXNzYWdlID0geyBjaGFubmVsQnVmZmVycywgbGVuZ3RoLCBkdXJhdGlvbiB9O1xuICAgICAgdGhpcy5fcG9zdE1lc3NhZ2VUb1dvcmtlcigncHVzaElucHV0RGF0YScsIG1lc3NhZ2UpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGltZVxuICAgICAgZWxhcHNlZFRpbWUgKz0gZHVyYXRpb247XG4gICAgICBpZiAoZWxhcHNlZFRpbWUgPj0gdGltZXNsaWNlKSB7XG4gICAgICAgIHRoaXMuX3Bvc3RNZXNzYWdlVG9Xb3JrZXIoJ2dldEVuY29kZWREYXRhJyk7XG4gICAgICAgIGVsYXBzZWRUaW1lID0gMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJlZ2lucyByZWNvcmRpbmcgbWVkaWE7IHRoaXMgbWV0aG9kIGNhbiBvcHRpb25hbGx5IGJlIHBhc3NlZCBhIHRpbWVzbGljZVxuICAgKiBhcmd1bWVudCB3aXRoIGEgdmFsdWUgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXNsaWNlIC0gSWYgdGhpcyBpcyBzcGVjaWZpZWQsIHRoZSBtZWRpYSB3aWxsIGJlIGNhcHR1cmVkXG4gICAqICAgICAgICBpbiBzZXBhcmF0ZSBjaHVua3Mgb2YgdGhhdCBkdXJhdGlvbiwgcmF0aGVyIHRoYW4gdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICogICAgICAgIG9mIHJlY29yZGluZyB0aGUgbWVkaWEgaW4gYSBzaW5nbGUgbGFyZ2UgY2h1bmsuIEluIG90aGVyIHdvcmRzLCBhblxuICAgKiAgICAgICAgdW5kZWZpbmVkIHZhbHVlIG9mIHRpbWVzbGljZSB3aWxsIGJlIHVuZGVyc3Rvb2QgYXMgdGhlIGxhcmdlc3QgbG9uZyB2YWx1ZS5cbiAgICovXG4gIHN0YXJ0ICh0aW1lc2xpY2UgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSAnaW5hY3RpdmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogSU5WQUxJRF9TVEFURV9FUlIsIHN0YXRlIG11c3QgYmUgaW5hY3RpdmUuJyk7XG4gICAgfVxuICAgIGlmICh0aW1lc2xpY2UgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50cywgdGltZXNsaWNlIHNob3VsZCBiZSAwIG9yIGhpZ2hlci4nKTtcbiAgICB9XG4gICAgdGltZXNsaWNlIC89IDEwMDA7IC8vIENvbnZlcnQgbWlsbGlzZWNvbmRzIHRvIHNlY29uZHNcblxuICAgIC8vIENoZWNrIHdvcmtlciBpcyBjbG9zZWQgKHVzdWFsbHkgYnkgc3RvcCgpKSBhbmQgaW5pdC5cbiAgICBpZiAodGhpcy53b3JrZXJTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRoaXMuX3NwYXduV29ya2VyKCk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGNoYW5uZWwgY291bnQgYW5kIHNhbXBsaW5nIHJhdGVcbiAgICAvLyBjaGFubmVsQ291bnQ6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9tZWRpYWNhcHR1cmUtc3RyZWFtcy8jbWVkaWEtdHJhY2stc2V0dGluZ3NcbiAgICAvLyBzYW1wbGVSYXRlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmFzZUF1ZGlvQ29udGV4dC9zYW1wbGVSYXRlXG4gICAgdGhpcy5jb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgIGxldCB0cmFja3MgPSB0aGlzLnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICAgIGlmICghdHJhY2tzWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogVW5rb3duRXJyb3IsIG1lZGlhIHRyYWNrIG5vdCBmb3VuZC4nKTtcbiAgICB9XG4gICAgdGhpcy5jaGFubmVsQ291bnQgPSB0cmFja3NbMF0uZ2V0U2V0dGluZ3MoKS5jaGFubmVsQ291bnQgfHwgMTtcbiAgICB0aGlzLnNhbXBsZVJhdGUgPSB0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZTtcblxuICAgIC8qKiBAdHlwZSB7TWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGV9ICovXG4gICAgdGhpcy5zb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UodGhpcy5zdHJlYW0pO1xuICAgIC8qKiBAdHlwZSB7U2NyaXB0UHJvY2Vzc29yTm9kZX0gKi9cbiAgICB0aGlzLnByb2Nlc3NvciA9IHRoaXMuY29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoQlVGRkVSX1NJWkUsIHRoaXMuY2hhbm5lbENvdW50LCB0aGlzLmNoYW5uZWxDb3VudCk7XG5cbiAgICAvLyBTdGFydCByZWNvcmRpbmdcbiAgICB0aGlzLl9zdGF0ZSA9ICdyZWNvcmRpbmcnO1xuICAgIHRoaXMuX2VuYWJsZUF1ZGlvUHJvY2Vzc0NhbGxiYWNrKHRpbWVzbGljZSk7XG5cbiAgICAvLyBJZiB0aGUgd29ya2VyIGlzIGFscmVhZHkgbG9hZGVkIHRoZW4gc3RhcnRcbiAgICBpZiAodGhpcy53b3JrZXJTdGF0ZSA9PT0gJ3JlYWR5VG9Jbml0Jykge1xuICAgICAgY29uc3QgeyBzYW1wbGVSYXRlLCBjaGFubmVsQ291bnQgfSA9IHRoaXM7XG4gICAgICB0aGlzLl9wb3N0TWVzc2FnZVRvV29ya2VyKCdpbml0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzYW1wbGVSYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzUGVyU2Vjb25kOiB0aGlzLmF1ZGlvQml0c1BlclNlY29uZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgcmVjb3JkaW5nLCBhdCB3aGljaCBwb2ludCBhIGRhdGFhdmFpbGFibGUgZXZlbnQgY29udGFpbmluZ1xuICAgKiB0aGUgZmluYWwgQmxvYiBvZiBzYXZlZCBkYXRhIGlzIGZpcmVkLiBObyBtb3JlIHJlY29yZGluZyBvY2N1cnMuXG4gICAqL1xuICBzdG9wICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2luYWN0aXZlJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdET01FeGNlcHRpb246IElOVkFMSURfU1RBVEVfRVJSLCBzdGF0ZSBtdXN0IE5PVCBiZSBpbmFjdGl2ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBTdG9wIHN0cmVhbSBmaXJzdFxuICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnByb2Nlc3Nvci5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5jb250ZXh0LmNsb3NlKCk7XG5cbiAgICAvLyBTdG9wIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIGF0IF9vbm1lc3NhZ2VGcm9tV29ya2VyKCksXG4gICAgdGhpcy5fcG9zdE1lc3NhZ2VUb1dvcmtlcignZG9uZScpO1xuXG4gICAgdGhpcy5fc3RhdGUgPSAnaW5hY3RpdmUnO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlcyB0aGUgcmVjb3JkaW5nIG9mIG1lZGlhLlxuICAgKi9cbiAgcGF1c2UgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAnaW5hY3RpdmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogSU5WQUxJRF9TVEFURV9FUlIsIHN0YXRlIG11c3QgTk9UIGJlIGluYWN0aXZlLicpO1xuICAgIH1cblxuICAgIC8vIFN0b3Agc3RyZWFtIGZpcnN0XG4gICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMucHJvY2Vzc29yLmRpc2Nvbm5lY3QoKTtcblxuICAgIGxldCBldmVudCA9IG5ldyBnbG9iYWwuRXZlbnQoJ3BhdXNlJyk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB0aGlzLl9zdGF0ZSA9ICdwYXVzZWQnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZXMgcmVjb3JkaW5nIG9mIG1lZGlhIGFmdGVyIGhhdmluZyBiZWVuIHBhdXNlZC5cbiAgICovXG4gIHJlc3VtZSAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICdpbmFjdGl2ZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRE9NRXhjZXB0aW9uOiBJTlZBTElEX1NUQVRFX0VSUiwgc3RhdGUgbXVzdCBOT1QgYmUgaW5hY3RpdmUuJyk7XG4gICAgfVxuXG4gICAgLy8gUmVzdGFydCBzdHJlYW1pbmcgZGF0YVxuICAgIHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5wcm9jZXNzb3IpO1xuICAgIHRoaXMucHJvY2Vzc29yLmNvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblxuICAgIGxldCBldmVudCA9IG5ldyBnbG9iYWwuRXZlbnQoJ3Jlc3VtZScpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgdGhpcy5fc3RhdGUgPSAncmVjb3JkaW5nJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhIEJsb2IgY29udGFpbmluZyB0aGUgc2F2ZWQgZGF0YSByZWNlaXZlZCB0aHVzIGZhciAob3Igc2luY2VcbiAgICogdGhlIGxhc3QgdGltZSByZXF1ZXN0RGF0YSgpIHdhcyBjYWxsZWQuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsXG4gICAqIHJlY29yZGluZyBjb250aW51ZXMsIGJ1dCBpbiBhIG5ldyBCbG9iLlxuICAgKi9cbiAgcmVxdWVzdERhdGEgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSAnaW5hY3RpdmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RPTUV4Y2VwdGlvbjogSU5WQUxJRF9TVEFURV9FUlIsIHN0YXRlIG11c3QgTk9UIGJlIGluYWN0aXZlLicpO1xuICAgIH1cblxuICAgIC8vIGRhdGFhdmFpbGFibGUgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZCBhdCBfb25tZXNzYWdlRnJvbVdvcmtlcigpXG4gICAgdGhpcy5fcG9zdE1lc3NhZ2VUb1dvcmtlcignZ2V0RW5jb2RlZERhdGEnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgQm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBnaXZlbiBNSU1FIHR5cGUgaXMgc3VwcG9ydGVkXG4gICAqIGJ5IHRoZSBjdXJyZW50IHVzZXIgYWdlbnQgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVR5cGUgLSBBIE1JTUUgVHlwZSwgaW5jbHVkaW5nIHBhcmFtZXRlcnMgd2hlbiBuZWVkZWQsXG4gICAqICAgICAgICAgIHNwZWNpZnlpbmcgYSBjb250YWluZXIgYW5kL29yIGNvZGVjIGZvcm1hdHMgZm9yIHJlY29yZGluZy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1R5cGVTdXBwb3J0ZWQgKG1pbWVUeXBlKSB7XG4gICAgLy8gU2VlOiBodHRwczovL3czYy5naXRodWIuaW8vbWVkaWFjYXB0dXJlLXJlY29yZC8jZG9tLW1lZGlhcmVjb3JkZXItaXN0eXBlc3VwcG9ydGVkXG5cbiAgICAvLyAxLiBJZiBlbXB0eSBzdHJpbmcsIHJldHVybiB0cnVlLlxuICAgIGlmICh0eXBlb2YgbWltZVR5cGUgPT09ICdzdHJpbmcnICYmICFtaW1lVHlwZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB2YXIge3R5cGUsIHN1YnR5cGUsIGNvZGVjfSA9IE9wdXNNZWRpYVJlY29yZGVyLl9wYXJzZVR5cGUobWltZVR5cGUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyAyLiBJZiBub3QgYSB2YWxpZCBzdHJpbmcsIHJldHVybiBmYWxzZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgIT09ICdhdWRpbycgfHxcbiAgICAgICEoc3VidHlwZSA9PT0gJ29nZycgfHwgc3VidHlwZSA9PT0gJ3dlYm0nIHx8XG4gICAgICAgIHN1YnR5cGUgPT09ICd3YXZlJyB8fCBzdWJ0eXBlID09PSAnd2F2JykpIHtcbiAgICAgIC8vIDMsNC4gSWYgdHlwZSBhbmQgc3VidHlwZSBhcmUgdW5zdXBwb3J0ZWQgdGhlIHJldHVybiBmYWxzZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gNS4gSWYgY29kZWMgaXMgdW5zdXBwb3J0ZWQgdGhlbiByZXR1cm4gZmFsc2UuXG4gICAgLy8gNi4gSWYgdGhlIHNwZWNpZmllZCBjb21iaW5hdGlvbiBvZiBhbGwgaXMgbm90IHN1cHBvcnRlZCB0aGFuIHJldHVybiBmYWxzZS5cbiAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgIGNhc2UgJ29nZyc6XG4gICAgICAgIGlmIChjb2RlYyAhPT0gJ29wdXMnICYmIGNvZGVjKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2VibSc6XG4gICAgICAgIGlmIChjb2RlYyAhPT0gJ29wdXMnICYmIGNvZGVjKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2F2ZSc6XG4gICAgICBjYXNlICd3YXYnOlxuICAgICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHNpZ25lZCAxNiBiaXRzXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIDcuIHJldHVybiB0cnVlLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIE1JTUUuIEEgaGVscGVyIGZ1bmN0aW9uIGZvciBpc1R5cGVTdXBwb3J0ZWQoKSBhbmQgZXRjLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWltZVR5cGUgLSB0eXBlVHlwZSAtIEEgTUlNRSBUeXBlLCBpbmNsdWRpbmcgcGFyYW1ldGVycyB3aGVuIG5lZWRlZCxcbiAgICogICAgICAgICAgc3BlY2lmeWluZyBhIGNvbnRhaW5lciBhbmQvb3IgY29kZWMgZm9ybWF0cyBmb3IgcmVjb3JkaW5nLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSAtIEFuIG9iamVjdCB3aXRoIHR5cGUsIHN1YnR5cGUsIGNvZGVjIGF0dHJpYnV0ZXNcbiAgICogICAgICAgICAgaWYgcGFyc2VkIGNvcnJlY3RseS4gbnVsbCBpcyByZXR1cm5lZCBpZiBwYXJzaW5nIGZhaWxlZC5cbiAgICogICAgICAgICAgSWYgbWltZVR5cGUgaXMgYW4gZW1wdHkgc3RyaW5nIHRoZW4gcmV0dXJuIGFuIG9iamVjdCB3aXRoIGF0dHJpYnV0ZXNcbiAgICogICAgICAgICAgYXJlIGVtcHR5IHN0cmluZ3NcbiAgICovXG4gIHN0YXRpYyBfcGFyc2VUeXBlIChtaW1lVHlwZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZWdleCA9IC9eKFxcdyspXFwvKFxcdyspKDtcXHMqY29kZWNzPShcXHcrKSk/JC87XG4gICAgICB2YXIgWywgdHlwZSwgc3VidHlwZSwgLCBjb2RlY10gPSBtaW1lVHlwZS5tYXRjaChyZWdleCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICh0eXBlb2YgbWltZVR5cGUgPT09ICdzdHJpbmcnICYmICFtaW1lVHlwZSkge1xuICAgICAgICByZXR1cm4ge3R5cGU6ICcnLCBzdWJ0eXBlOiAnJywgY29kZWM6ICcnfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge3R5cGUsIHN1YnR5cGUsIGNvZGVjfTtcbiAgfVxufVxuXG4vLyBFdmVudEhhbmRsZXIgYXR0cmlidXRlcy5cbi8vIFRoaXMgY29kZSBpcyBhIG5vbi1zdGFuZGFyZCBFdmVudFRhcmdldCBidXQgcmVxdWlyZWQgYnkgZXZlbnQtdGFyZ2V0LXNoaW0uXG5bXG4gICdzdGFydCcsIC8vIENhbGxlZCB0byBoYW5kbGUgdGhlIHtAbGluayBNZWRpYVJlY29yZGVyI3N0YXJ0fSBldmVudC5cbiAgJ3N0b3AnLCAvLyBDYWxsZWQgdG8gaGFuZGxlIHRoZSBzdG9wIGV2ZW50LlxuICAnZGF0YWF2YWlsYWJsZScsIC8qIENhbGxlZCB0byBoYW5kbGUgdGhlIGRhdGFhdmFpbGFibGUgZXZlbnQuIFRoZSBCbG9iIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRlZCBkYXRhIGlzIGNvbnRhaW5lZCBpbiB0aGlzIGV2ZW50IGFuZCBjYW4gYmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc2VkIHZpYSBpdHMgZGF0YSBhdHRyaWJ1dGUuICovXG4gICdwYXVzZScsIC8vIENhbGxlZCB0byBoYW5kbGUgdGhlIHBhdXNlIGV2ZW50LlxuICAncmVzdW1lJywgLy8gQ2FsbGVkIHRvIGhhbmRsZSB0aGUgcmVzdW1lIGV2ZW50LlxuICAnZXJyb3InIC8vIENhbGxlZCB0byBoYW5kbGUgYSBNZWRpYVJlY29yZGVyRXJyb3JFdmVudC5cbl0uZm9yRWFjaChuYW1lID0+IGRlZmluZUV2ZW50QXR0cmlidXRlKE9wdXNNZWRpYVJlY29yZGVyLnByb3RvdHlwZSwgbmFtZSkpO1xuXG4vLyBNUyBFZGdlIHNwZWNpZmljIG1vbmtleSBwYXRjaGluZzpcbi8vIG9uYXVkaW9wcm9jZXNzIGNhbGxiYWNrIGNhbm5vdCBiZSB0cmlnZ2VyZWQgbW9yZSB0aGFuIHR3aWNlIHdoZW4gcG9zdE1lc3NhZ2Vcbi8vIHVzZXMgdGhlIHNlY29uZGUgdHJhbnNmZXIgYXJndW1lbnQuIFNvIGRpc2FibGUgdGhlIHRyYW5zZmVyIGFyZ3VtZW50IG9ubHkgaW4gRWRnZS5cbmlmIChicm93c2VyICYmIGJyb3dzZXIubmFtZSA9PT0gJ2VkZ2UnKSB7XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9yaWdpbmFsID0gV29ya2VyLnByb3RvdHlwZS5wb3N0TWVzc2FnZTtcbiAgICBXb3JrZXIucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHRyYW5zZmVyID0gbnVsbCkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgW21lc3NhZ2VdKTtcbiAgICB9O1xuICB9KSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9wdXNNZWRpYVJlY29yZGVyO1xuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFnZUJ1cztcbmluaGVyaXRzKFBhZ2VCdXMsIEV2ZW50RW1pdHRlcik7XG5cbnZhciBlbWl0ID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xudmFyIG9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcbnZhciBvbmNlID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlO1xuXG5mdW5jdGlvbiBQYWdlQnVzIChvcHRzKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhZ2VCdXMpKSByZXR1cm4gbmV3IFBhZ2VCdXMob3B0cyk7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIG9wdHMgPSB7IGtleTogb3B0cyB9O1xuICAgIHRoaXMuX2tleSA9IG9wdHMua2V5IHx8ICdwYWdlLWJ1cyc7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeShbXSkpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmIChldi5rZXkgPT09IHNlbGYuX2tleSkge1xuICAgICAgICAgICAgdHJ5IHsgdmFyIHZhbHVlID0gSlNPTi5wYXJzZShldi5uZXdWYWx1ZSkgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikgeyByZXR1cm4gfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSBlbWl0LmFwcGx5KHNlbGYsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5cblBhZ2VCdXMucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLl9rZXksIEpTT04uc3RyaW5naWZ5KGFyZ3MpKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG4iLCIvKiEgcXVldWUtbWljcm90YXNrLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5sZXQgcHJvbWlzZVxuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJ1xuICA/IHF1ZXVlTWljcm90YXNrLmJpbmQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpXG4gIC8vIHJldXNlIHJlc29sdmVkIHByb21pc2UsIGFuZCBhbGxvY2F0ZSBpdCBsYXppbHlcbiAgOiBjYiA9PiAocHJvbWlzZSB8fCAocHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpKSlcbiAgICAudGhlbihjYilcbiAgICAuY2F0Y2goZXJyID0+IHNldFRpbWVvdXQoKCkgPT4geyB0aHJvdyBlcnIgfSwgMCkpXG4iLCIndXNlIHN0cmljdCdcblxuLy8gbGltaXQgb2YgQ3J5cHRvLmdldFJhbmRvbVZhbHVlcygpXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3J5cHRvL2dldFJhbmRvbVZhbHVlc1xudmFyIE1BWF9CWVRFUyA9IDY1NTM2XG5cbi8vIE5vZGUgc3VwcG9ydHMgcmVxdWVzdGluZyB1cCB0byB0aGlzIG51bWJlciBvZiBieXRlc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9pbnRlcm5hbC9jcnlwdG8vcmFuZG9tLmpzI0w0OFxudmFyIE1BWF9VSU5UMzIgPSA0Mjk0OTY3Mjk1XG5cbmZ1bmN0aW9uIG9sZEJyb3dzZXIgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIuXFxuVXNlIENocm9tZSwgRmlyZWZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMScpXG59XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNyeXB0byA9IGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvXG5cbmlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbUJ5dGVzXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IG9sZEJyb3dzZXJcbn1cblxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMgKHNpemUsIGNiKSB7XG4gIC8vIHBoYW50b21qcyBuZWVkcyB0byB0aHJvd1xuICBpZiAoc2l6ZSA+IE1BWF9VSU5UMzIpIHRocm93IG5ldyBSYW5nZUVycm9yKCdyZXF1ZXN0ZWQgdG9vIG1hbnkgcmFuZG9tIGJ5dGVzJylcblxuICB2YXIgYnl0ZXMgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSlcblxuICBpZiAoc2l6ZSA+IDApIHsgIC8vIGdldFJhbmRvbVZhbHVlcyBmYWlscyBvbiBJRSBpZiBzaXplID09IDBcbiAgICBpZiAoc2l6ZSA+IE1BWF9CWVRFUykgeyAvLyB0aGlzIGlzIHRoZSBtYXggYnl0ZXMgY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgLy8gY2FuIGRvIGF0IG9uY2Ugc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgZm9yICh2YXIgZ2VuZXJhdGVkID0gMDsgZ2VuZXJhdGVkIDwgc2l6ZTsgZ2VuZXJhdGVkICs9IE1BWF9CWVRFUykge1xuICAgICAgICAvLyBidWZmZXIuc2xpY2UgYXV0b21hdGljYWxseSBjaGVja3MgaWYgdGhlIGVuZCBpcyBwYXN0IHRoZSBlbmQgb2ZcbiAgICAgICAgLy8gdGhlIGJ1ZmZlciBzbyB3ZSBkb24ndCBoYXZlIHRvIGhlcmVcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcy5zbGljZShnZW5lcmF0ZWQsIGdlbmVyYXRlZCArIE1BWF9CWVRFUykpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKG51bGwsIGJ5dGVzKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBjb2RlcyA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICBpZiAoIUJhc2UpIHtcbiAgICBCYXNlID0gRXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIE5vZGVFcnJvciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9CYXNlKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTm9kZUVycm9yLCBfQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBOb2RlRXJyb3IoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgcmV0dXJuIF9CYXNlLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkgfHwgdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTm9kZUVycm9yO1xuICB9KEJhc2UpO1xuXG4gIE5vZGVFcnJvci5wcm90b3R5cGUubmFtZSA9IEJhc2UubmFtZTtcbiAgTm9kZUVycm9yLnByb3RvdHlwZS5jb2RlID0gY29kZTtcbiAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC44LjAvbGliL2ludGVybmFsL2Vycm9ycy5qc1xuXG5cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdLCBcIiBvciBcIikuY29uY2F0KGV4cGVjdGVkWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KFN0cmluZyhleHBlY3RlZCkpO1xuICB9XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXG5cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5cblxuZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcbiAgfVxufVxuXG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX09QVF9WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gJ1RoZSB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCInICsgbmFtZSArICdcIic7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG4gIHZhciBkZXRlcm1pbmVyO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cblxuICB2YXIgbXNnO1xuXG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gXCJUaGUgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gXCJUaGUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgXCIpLmNvbmNhdCh0eXBlLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9XG5cbiAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdCh0eXBlb2YgYWN0dWFsKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YnLCAnc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ1RoZSAnICsgbmFtZSArICcgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnLCAnUHJlbWF0dXJlIGNsb3NlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fREVTVFJPWUVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdDYW5ub3QgY2FsbCAnICsgbmFtZSArICcgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0NBTk5PVF9QSVBFJywgJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnLCAnd3JpdGUgYWZ0ZXIgZW5kJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fTlVMTF9WQUxVRVMnLCAnTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfVU5LTk9XTl9FTkNPRElORycsIGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuICdVbmtub3duIGVuY29kaW5nOiAnICsgYXJnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCcsICdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xubW9kdWxlLmV4cG9ydHMuY29kZXMgPSBjb2RlcztcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cbid1c2Ugc3RyaWN0Jztcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcblxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gQWxsb3cgdGhlIGtleXMgYXJyYXkgdG8gYmUgR0MnZWQuXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuXG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcblxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIElmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLCB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuOyAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuXG4gIHByb2Nlc3MubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIEVFbGlzdGVuZXJDb3VudChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBkZWJ1ZztcblxuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QnKTtcblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVDsgLy8gTGF6eSBsb2FkZWQgdG8gaW1wcm92ZSB0aGUgc3RhcnR1cCBwZXJmb3JtYW5jZS5cblxuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTsgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcblxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB0aGlzLnBhdXNlZCA9IHRydWU7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG5cbiAgdGhpcy5hd2FpdERyYWluID0gMDsgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3lcblxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsgLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cblxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59OyAvLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuXG4gICAgaWYgKGVyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCgpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRigpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IC8vIFdlIGNhbiBwdXNoIG1vcmUgZGF0YSBpZiB3ZSBhcmUgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmsuXG4gIC8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lIG1vcmUgYnl0ZXMuXG4gIC8vIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsIHN1Y2ggYXMgdGhlIHJlcGwuXG5cblxuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cblxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcblxuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKTtcbiAgfVxuXG4gIHJldHVybiBlcjtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyOyAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7IC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG5cbiAgdmFyIHAgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5oZWFkO1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIHdoaWxlIChwICE9PSBudWxsKSB7XG4gICAgY29udGVudCArPSBkZWNvZGVyLndyaXRlKHAuZGF0YSk7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG5cbiAgaWYgKGNvbnRlbnQgIT09ICcnKSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5wdXNoKGNvbnRlbnQpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xuICByZXR1cm4gdGhpcztcbn07IC8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxR0JcblxuXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5cbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIC8vIFRPRE8ocm9uYWcpOiBUaHJvdyBFUlJfVkFMVUVfT1VUX09GX1JBTkdFLlxuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cblxuICByZXR1cm4gbjtcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcblxuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfSAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cblxuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOyAvLyBEb24ndCBoYXZlIGVub3VnaFxuXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn0gLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoKHN0YXRlLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayA6IHN0YXRlLmxlbmd0aCA+IDApIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuXG5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpOyAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9IC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cblxuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7IC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG5cbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuXG4gICAgc3RhdGUuc3luYyA9IGZhbHNlOyAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cblxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cblxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcblxuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnN5bmMpIHtcbiAgICAvLyBpZiB3ZSBhcmUgc3luYywgd2FpdCB1bnRpbCBuZXh0IHRpY2sgdG8gZW1pdCB0aGUgZGF0YS5cbiAgICAvLyBPdGhlcndpc2Ugd2UgcmlzayBlbWl0dGluZyBkYXRhIGluIHRoZSBmbG93KClcbiAgICAvLyB0aGUgcmVhZGFibGUgY29kZSB0cmlnZ2VycyBkdXJpbmcgYSByZWFkKCkgY2FsbFxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfVxuICB9XG59IC8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5uZWVkUmVhZGFibGUsIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSk7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuXG4gIGlmICghc3RhdGUuZGVzdHJveWVkICYmIChzdGF0ZS5sZW5ndGggfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIH0gLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuXG5cbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBmbG93KHN0cmVhbSk7XG59IC8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuXG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHRoZSBzdHJlYW0gaGFzIGNhbGxlZCB0aGUgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBfcmVhZCgpXG4gIC8vICAgbWV0aG9kLCBidXQgdGhleSBhcmUgcHJvY2Vzc2luZyB0aGUgY2FsbCBhc3luY2hyb25vdXNseSBhbmQgaGF2ZSBfbm90X1xuICAvLyAgIGNhbGxlZCBwdXNoKCkgd2l0aCBuZXcgZGF0YS4gSW4gdGhpcyBjYXNlIHdlIHNraXAgcGVyZm9ybWluZyBtb3JlXG4gIC8vICAgcmVhZCgpcy4gVGhlIGV4ZWN1dGlvbiBlbmRzIGluIHRoaXMgbWV0aG9kIGFnYWluIGFmdGVyIHRoZSBfcmVhZCgpIGVuZHNcbiAgLy8gICB1cCBjYWxsaW5nIHB1c2goKSB3aXRoIG1vcmUgZGF0YS5cbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn0gLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcblxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH0gLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG5cblxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7IC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgY2xlYW5lZFVwID0gdHJ1ZTsgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBkZWJ1ZygnZGVzdC53cml0ZScsIHJldCk7XG5cbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cblxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9IC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG5cblxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBlcnJvck9yRGVzdHJveShkZXN0LCBlcik7XG4gIH0gLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuXG5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpOyAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH0gLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cblxuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7IC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gcGlwZU9uRHJhaW5GdW5jdGlvblJlc3VsdCgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07IC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7IC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlczsgLy8gZ290IGEgbWF0Y2guXG5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuXG5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07IC8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5cblxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7IC8vIFRyeSBzdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcblxuICAgIGlmIChzdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKTtcblxuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgaWYgKHN0YXRlLnJlc3VtZVNjaGVkdWxlZCAmJiAhc3RhdGUucGF1c2VkKSB7XG4gICAgLy8gZmxvd2luZyBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZSBub3csIG90aGVyd2lzZVxuICAgIC8vIHRoZSB1cGNvbWluZyByZXN1bWUgd2lsbCBub3QgZmxvdy5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsgLy8gY3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWVcbiAgfSBlbHNlIGlmIChzZWxmLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICBzZWxmLnJlc3VtZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn0gLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpOyAvLyB3ZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpXG5cbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuXG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnBhdXNlZCA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHtcbiAgICA7XG4gIH1cbn0gLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOyAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcblxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcblxuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTsgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cblxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9IC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cblxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH0gLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cblxuXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG5cbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUZsb3dpbmcnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IHN0YXRlO1xuICAgIH1cbiAgfVxufSk7IC8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZScsIHN0YXRlLmVuZEVtaXR0ZWQpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7IC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgIC8vIGlmIHRoZSB3cml0YWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuXG4gICAgICBpZiAoIXdTdGF0ZSB8fCB3U3RhdGUuYXV0b0Rlc3Ryb3kgJiYgd1N0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbShSZWFkYWJsZSwgaXRlcmFibGUsIG9wdHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HLFxuICAgIEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMDtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcbiAgY2IoZXIpO1xuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07IC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH0gLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuXG5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59OyAvLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3RyYW5zZm9ybSgpJykpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcblxuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07IC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG5cbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7IC8vIFRPRE8oQnJpZGdlQVIpOiBXcml0ZSBhIHRlc3QgZm9yIHRoZXNlIHR3byBlcnJvciBjYXNlc1xuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wKCk7XG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcoKTtcbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuLyogPHJlcGxhY2VtZW50PiAqL1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59IC8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5cblxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0NBTk5PVF9QSVBFLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gICAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXG4gICAgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCxcbiAgICBFUlJfVU5LTk9XTl9FTkNPRElORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9VTktOT1dOX0VOQ09ESU5HO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcbiAgLy8gZS5nLiBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSB2cy4gb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUsIGV0Yy5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcblxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7IC8vIGRyYWluIGV2ZW50IGZsYWcuXG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTsgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcblxuICB0aGlzLmVuZGluZyA9IGZhbHNlOyAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG5cbiAgdGhpcy5lbmRlZCA9IGZhbHNlOyAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcblxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cblxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG5cbiAgdGhpcy5sZW5ndGggPSAwOyAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlOyAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG5cbiAgdGhpcy5jb3JrZWQgPSAwOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOyAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG5cbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG5cblxuICB0aGlzLndyaXRlY2IgPSBudWxsOyAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG5cbiAgdGhpcy5wZW5kaW5nY2IgPSAwOyAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG5cbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZmluaXNoJyAoYW5kIHBvdGVudGlhbGx5ICdlbmQnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7IC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuXG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTsgLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG5cblxudmFyIHJlYWxIYXNJbnN0YW5jZTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gcmVhbEhhc0luc3RhbmNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7IC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICBpZiAoIWlzRHVwbGV4ICYmICFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeS5cblxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59IC8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cblxuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUoKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7IC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG5cbiAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbn0gLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuXG5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciBlcjtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlciddLCBjaHVuayk7XG4gIH1cblxuICBpZiAoZXIpIHtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuICBpZiAoc3RhdGUuZW5kaW5nKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cblxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pOyAvLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7IC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLmRlc3Ryb3llZCkgc3RhdGUub253cml0ZShuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3dyaXRlJykpO2Vsc2UgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcblxuICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTtcbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpIHx8IHN0cmVhbS5kZXN0cm95ZWQ7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufSAvLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cblxuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59IC8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5cblxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7IC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG5cbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07IC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7IC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfSAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG5cblxuICBpZiAoIXN0YXRlLmVuZGluZykgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nICYmICFzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcblxuICAgICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgICAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAgICAgICBpZiAoIXJTdGF0ZSB8fCByU3RhdGUuYXV0b0Rlc3Ryb3kgJiYgclN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuXG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzcy5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcblxuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfSAvLyByZXVzZSB0aGUgZnJlZSBjb3JrUmVxLlxuXG5cbiAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgZmluaXNoZWQgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcblxudmFyIGtMYXN0UmVzb2x2ZSA9IFN5bWJvbCgnbGFzdFJlc29sdmUnKTtcbnZhciBrTGFzdFJlamVjdCA9IFN5bWJvbCgnbGFzdFJlamVjdCcpO1xudmFyIGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcbnZhciBrRW5kZWQgPSBTeW1ib2woJ2VuZGVkJyk7XG52YXIga0xhc3RQcm9taXNlID0gU3ltYm9sKCdsYXN0UHJvbWlzZScpO1xudmFyIGtIYW5kbGVQcm9taXNlID0gU3ltYm9sKCdoYW5kbGVQcm9taXNlJyk7XG52YXIga1N0cmVhbSA9IFN5bWJvbCgnc3RyZWFtJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZG9uZTogZG9uZVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWFkQW5kUmVzb2x2ZShpdGVyKSB7XG4gIHZhciByZXNvbHZlID0gaXRlcltrTGFzdFJlc29sdmVdO1xuXG4gIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgdmFyIGRhdGEgPSBpdGVyW2tTdHJlYW1dLnJlYWQoKTsgLy8gd2UgZGVmZXIgaWYgZGF0YSBpcyBudWxsXG4gICAgLy8gd2UgY2FuIGJlIGV4cGVjdGluZyBlaXRoZXIgJ2VuZCcgb3JcbiAgICAvLyAnZXJyb3InXG5cbiAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgaXRlcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25SZWFkYWJsZShpdGVyKSB7XG4gIC8vIHdlIHdhaXQgZm9yIHRoZSBuZXh0IHRpY2ssIGJlY2F1c2UgaXQgbWlnaHRcbiAgLy8gZW1pdCBhbiBlcnJvciB3aXRoIHByb2Nlc3MubmV4dFRpY2tcbiAgcHJvY2Vzcy5uZXh0VGljayhyZWFkQW5kUmVzb2x2ZSwgaXRlcik7XG59XG5cbmZ1bmN0aW9uIHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCBpdGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGFzdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXRlcltrRW5kZWRdKSB7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpdGVyW2tIYW5kbGVQcm9taXNlXShyZXNvbHZlLCByZWplY3QpO1xuICAgIH0sIHJlamVjdCk7XG4gIH07XG59XG5cbnZhciBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uICgpIHt9KTtcbnZhciBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YoKF9PYmplY3Qkc2V0UHJvdG90eXBlTyA9IHtcbiAgZ2V0IHN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpc1trU3RyZWFtXTtcbiAgfSxcblxuICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGRldGVjdGVkIGFuIGVycm9yIGluIHRoZSBtZWFud2hpbGVcbiAgICAvLyByZWplY3Qgc3RyYWlnaHQgYXdheVxuICAgIHZhciBlcnJvciA9IHRoaXNba0Vycm9yXTtcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRW5kZWRdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba1N0cmVhbV0uZGVzdHJveWVkKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGRlZmVyIHZpYSBuZXh0VGljayBiZWNhdXNlIGlmIC5kZXN0cm95KGVycikgaXNcbiAgICAgIC8vIGNhbGxlZCwgdGhlIGVycm9yIHdpbGwgYmUgZW1pdHRlZCB2aWEgbmV4dFRpY2ssIGFuZFxuICAgICAgLy8gd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IHRoZXJlIGlzIG5vIGVycm9yIGxpbmdlcmluZyBhcm91bmRcbiAgICAgIC8vIHdhaXRpbmcgdG8gYmUgZW1pdHRlZC5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpc1trRXJyb3JdKSB7XG4gICAgICAgICAgICByZWplY3QoX3RoaXNba0Vycm9yXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSAvLyBpZiB3ZSBoYXZlIG11bHRpcGxlIG5leHQoKSBjYWxsc1xuICAgIC8vIHdlIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIFByb21pc2UgdG8gZmluaXNoXG4gICAgLy8gdGhpcyBsb2dpYyBpcyBvcHRpbWl6ZWQgdG8gc3VwcG9ydCBmb3IgYXdhaXQgbG9vcHMsXG4gICAgLy8gd2hlcmUgbmV4dCgpIGlzIG9ubHkgY2FsbGVkIG9uY2UgYXQgYSB0aW1lXG5cblxuICAgIHZhciBsYXN0UHJvbWlzZSA9IHRoaXNba0xhc3RQcm9taXNlXTtcbiAgICB2YXIgcHJvbWlzZTtcblxuICAgIGlmIChsYXN0UHJvbWlzZSkge1xuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhc3QgcGF0aCBuZWVkZWQgdG8gc3VwcG9ydCBtdWx0aXBsZSB0aGlzLnB1c2goKVxuICAgICAgLy8gd2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBuZXh0KCkgcXVldWVcbiAgICAgIHZhciBkYXRhID0gdGhpc1trU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2UodGhpc1trSGFuZGxlUHJvbWlzZV0pO1xuICAgIH1cblxuICAgIHRoaXNba0xhc3RQcm9taXNlXSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn0sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFwicmV0dXJuXCIsIGZ1bmN0aW9uIF9yZXR1cm4oKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIC8vIGRlc3Ryb3koZXJyLCBjYikgaXMgYSBwcml2YXRlIEFQSVxuICAvLyB3ZSBjYW4gZ3VhcmFudGVlIHdlIGhhdmUgdGhhdCBoZXJlLCBiZWNhdXNlIHdlIGNvbnRyb2wgdGhlXG4gIC8vIFJlYWRhYmxlIGNsYXNzIHRoaXMgaXMgYXR0YWNoZWQgdG9cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBfdGhpczJba1N0cmVhbV0uZGVzdHJveShudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9KTtcbiAgfSk7XG59KSwgX09iamVjdCRzZXRQcm90b3R5cGVPKSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG5cbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtKSB7XG4gIHZhciBfT2JqZWN0JGNyZWF0ZTtcblxuICB2YXIgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgKF9PYmplY3QkY3JlYXRlID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga1N0cmVhbSwge1xuICAgIHZhbHVlOiBzdHJlYW0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZXNvbHZlLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZWplY3QsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRXJyb3IsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRW5kZWQsIHtcbiAgICB2YWx1ZTogc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0hhbmRsZVByb21pc2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZGF0YSA9IGl0ZXJhdG9yW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSByZXNvbHZlO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSByZWplY3Q7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX09iamVjdCRjcmVhdGUpKTtcbiAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gIGZpbmlzaGVkKHN0cmVhbSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScpIHtcbiAgICAgIHZhciByZWplY3QgPSBpdGVyYXRvcltrTGFzdFJlamVjdF07IC8vIHJlamVjdCBpZiB3ZSBhcmUgd2FpdGluZyBmb3IgZGF0YSBpbiB0aGUgUHJvbWlzZVxuICAgICAgLy8gcmV0dXJuZWQgYnkgbmV4dCgpIGFuZCBzdG9yZSB0aGUgZXJyb3JcblxuICAgICAgaWYgKHJlamVjdCAhPT0gbnVsbCkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRvcltrRXJyb3JdID0gZXJyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlID0gaXRlcmF0b3Jba0xhc3RSZXNvbHZlXTtcblxuICAgIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpdGVyYXRvcltrRW5kZWRdID0gdHJ1ZTtcbiAgfSk7XG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBvblJlYWRhYmxlLmJpbmQobnVsbCwgaXRlcmF0b3IpKTtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgICBCdWZmZXIgPSBfcmVxdWlyZS5CdWZmZXI7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xuXG52YXIgY3VzdG9tID0gaW5zcGVjdCAmJiBpbnNwZWN0LmN1c3RvbSB8fCAnaW5zcGVjdCc7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbChzcmMsIHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQnVmZmVyTGlzdCwgW3tcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogdGhpcy5oZWFkXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgLS10aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiam9pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25jYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBvciBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25zdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN1bWUobiwgaGFzU3RyaW5ncykge1xuICAgICAgdmFyIHJldDtcblxuICAgICAgaWYgKG4gPCB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gYHNsaWNlYCBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgICAgcmV0ID0gdGhpcy5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgICAgIHRoaXMuaGVhZC5kYXRhID0gdGhpcy5oZWFkLmRhdGEuc2xpY2Uobik7XG4gICAgICB9IGVsc2UgaWYgKG4gPT09IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBGaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2guXG4gICAgICAgIHJldCA9IHRoaXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlci5cbiAgICAgICAgcmV0ID0gaGFzU3RyaW5ncyA/IHRoaXMuX2dldFN0cmluZyhuKSA6IHRoaXMuX2dldEJ1ZmZlcihuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RyaW5nKG4pIHtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgdmFyIHJldCA9IHAuZGF0YTtcbiAgICAgIG4gLT0gcmV0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCdWZmZXIobikge1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgcC5kYXRhLmNvcHkocmV0KTtcbiAgICAgIG4gLT0gcC5kYXRhLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICAgICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBNYWtlIHN1cmUgdGhlIGxpbmtlZCBsaXN0IG9ubHkgc2hvd3MgdGhlIG1pbmltYWwgbmVjZXNzYXJ5IGluZm9ybWF0aW9uLlxuXG4gIH0sIHtcbiAgICBrZXk6IGN1c3RvbSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoXywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAvLyBPbmx5IGluc3BlY3Qgb25lIGxldmVsLlxuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgLy8gSXQgc2hvdWxkIG5vdCByZWN1cnNlLlxuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpOyIsIid1c2Ugc3RyaWN0JzsgLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH0gLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuXG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZU5UKHNlbGYsIGVycikge1xuICBlbWl0RXJyb3JOVChzZWxmLCBlcnIpO1xuICBlbWl0Q2xvc2VOVChzZWxmKTtcbn1cblxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xuICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZSAmJiAhc2VsZi5fd3JpdGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgaWYgKHNlbGYuX3JlYWRhYmxlU3RhdGUgJiYgIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5mdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycikge1xuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxuICAvLyBpbiB0aGUgc2FtZSB0aWNrLCBzbyBjaGFuZ2luZyB0aGlzIGlzIHNlbXZlciBtYWpvci5cbiAgLy8gRm9yIG5vdyB3aGVuIHlvdSBvcHQtaW4gdG8gYXV0b0Rlc3Ryb3kgd2UgYWxsb3dcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXG4gIC8vIHNlbXZlciBtYWpvciB1cGRhdGUgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgZGVmYXVsdCB0byB0aGlzLlxuICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICBpZiAoclN0YXRlICYmIHJTdGF0ZS5hdXRvRGVzdHJveSB8fCB3U3RhdGUgJiYgd1N0YXRlLmF1dG9EZXN0cm95KSBzdHJlYW0uZGVzdHJveShlcnIpO2Vsc2Ugc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95LFxuICBlcnJvck9yRGVzdHJveTogZXJyb3JPckRlc3Ryb3lcbn07IiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9lbmQtb2Ytc3RyZWFtIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTtcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGVvcyhzdHJlYW0sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpO1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICB2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZTtcbiAgdmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCBvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGU7XG5cbiAgdmFyIG9ubGVnYWN5ZmluaXNoID0gZnVuY3Rpb24gb25sZWdhY3lmaW5pc2goKSB7XG4gICAgaWYgKCFzdHJlYW0ud3JpdGFibGUpIG9uZmluaXNoKCk7XG4gIH07XG5cbiAgdmFyIHdyaXRhYmxlRW5kZWQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkO1xuXG4gIHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgd3JpdGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciByZWFkYWJsZUVuZGVkID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkO1xuXG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgcmVhZGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgfTtcblxuICB2YXIgb25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgdmFyIGVycjtcblxuICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgaWYgKHdyaXRhYmxlICYmICF3cml0YWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSB8fCAhc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uIG9ucmVxdWVzdCgpIHtcbiAgICBzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIH07XG5cbiAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO2Vsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlKSB7XG4gICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICBzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICB9XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG4gIHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICBpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW9zOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWRhYmxlLmZyb20gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3NlcicpXG59O1xuIiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9wdW1wIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW9zO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7XG5cbmZ1bmN0aW9uIG5vb3AoZXJyKSB7XG4gIC8vIFJldGhyb3cgdGhlIGVycm9yIGlmIGl0IGV4aXN0cyB0byBhdm9pZCBzd2FsbG93aW5nIGl0XG4gIGlmIChlcnIpIHRocm93IGVycjtcbn1cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChlb3MgPT09IHVuZGVmaW5lZCkgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG4gIGVvcyhzdHJlYW0sIHtcbiAgICByZWFkYWJsZTogcmVhZGluZyxcbiAgICB3cml0YWJsZTogd3JpdGluZ1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjbG9zZWQpIHJldHVybjtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTsgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnRcblxuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpO1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpO1xuICAgIGNhbGxiYWNrKGVyciB8fCBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3BpcGUnKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGwoZm4pIHtcbiAgZm4oKTtcbn1cblxuZnVuY3Rpb24gcGlwZShmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS5waXBlKHRvKTtcbn1cblxuZnVuY3Rpb24gcG9wQ2FsbGJhY2soc3RyZWFtcykge1xuICBpZiAoIXN0cmVhbXMubGVuZ3RoKSByZXR1cm4gbm9vcDtcbiAgaWYgKHR5cGVvZiBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gIT09ICdmdW5jdGlvbicpIHJldHVybiBub29wO1xuICByZXR1cm4gc3RyZWFtcy5wb3AoKTtcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0cmVhbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgY2FsbGJhY2sgPSBwb3BDYWxsYmFjayhzdHJlYW1zKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpIHN0cmVhbXMgPSBzdHJlYW1zWzBdO1xuXG4gIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnc3RyZWFtcycpO1xuICB9XG5cbiAgdmFyIGVycm9yO1xuICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7XG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxO1xuICAgIHZhciB3cml0aW5nID0gaSA+IDA7XG4gICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm47XG4gICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9JTlZBTElEX09QVF9WQUxVRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9JTlZBTElEX09QVF9WQUxVRTtcblxuZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkge1xuICByZXR1cm4gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrICE9IG51bGwgPyBvcHRpb25zLmhpZ2hXYXRlck1hcmsgOiBpc0R1cGxleCA/IG9wdGlvbnNbZHVwbGV4S2V5XSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hXYXRlck1hcmsoc3RhdGUsIG9wdGlvbnMsIGR1cGxleEtleSwgaXNEdXBsZXgpIHtcbiAgdmFyIGh3bSA9IGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpO1xuXG4gIGlmIChod20gIT0gbnVsbCkge1xuICAgIGlmICghKGlzRmluaXRlKGh3bSkgJiYgTWF0aC5mbG9vcihod20pID09PSBod20pIHx8IGh3bSA8IDApIHtcbiAgICAgIHZhciBuYW1lID0gaXNEdXBsZXggPyBkdXBsZXhLZXkgOiAnaGlnaFdhdGVyTWFyayc7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfT1BUX1ZBTFVFKG5hbWUsIGh3bSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaHdtKTtcbiAgfSAvLyBEZWZhdWx0IHZhbHVlXG5cblxuICByZXR1cm4gc3RhdGUub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0SGlnaFdhdGVyTWFyazogZ2V0SGlnaFdhdGVyTWFya1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5leHBvcnRzLmZpbmlzaGVkID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJyk7XG5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpO1xuIiwiLyohIHJ1bi13YXRlcmZhbGwuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbm1vZHVsZS5leHBvcnRzID0gcnVuV2F0ZXJmYWxsXG5cbmZ1bmN0aW9uIHJ1bldhdGVyZmFsbCAodGFza3MsIGNiKSB7XG4gIHZhciBjdXJyZW50ID0gMFxuICB2YXIgaXNTeW5jID0gdHJ1ZVxuXG4gIGZ1bmN0aW9uIGRvbmUgKGVyciwgYXJncykge1xuICAgIGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICBhcmdzID0gYXJncyA/IFtdLmNvbmNhdChlcnIsIGFyZ3MpIDogW2Vycl1cbiAgICAgIGlmIChjYikgY2IuYXBwbHkodW5kZWZpbmVkLCBhcmdzKVxuICAgIH1cbiAgICBpZiAoaXNTeW5jKSBwcm9jZXNzLm5leHRUaWNrKGVuZClcbiAgICBlbHNlIGVuZCgpXG4gIH1cblxuICBmdW5jdGlvbiBlYWNoIChlcnIpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICBpZiAoKytjdXJyZW50ID49IHRhc2tzLmxlbmd0aCB8fCBlcnIpIHtcbiAgICAgIGRvbmUoZXJyLCBhcmdzKVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXNrc1tjdXJyZW50XS5hcHBseSh1bmRlZmluZWQsIFtdLmNvbmNhdChhcmdzLCBlYWNoKSlcbiAgICB9XG4gIH1cblxuICBpZiAodGFza3MubGVuZ3RoKSB7XG4gICAgdGFza3NbMF0oZWFjaClcbiAgfSBlbHNlIHtcbiAgICBkb25lKG51bGwpXG4gIH1cblxuICBpc1N5bmMgPSBmYWxzZVxufVxuIiwiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIiAvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gU0RQIGhlbHBlcnMuXG52YXIgU0RQVXRpbHMgPSB7fTtcblxuLy8gR2VuZXJhdGUgYW4gYWxwaGFudW1lcmljIGlkZW50aWZpZXIgZm9yIGNuYW1lIG9yIG1pZHMuXG4vLyBUT0RPOiB1c2UgVVVJRHMgaW5zdGVhZD8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuU0RQVXRpbHMuZ2VuZXJhdGVJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgMTApO1xufTtcblxuLy8gVGhlIFJUQ1AgQ05BTUUgdXNlZCBieSBhbGwgcGVlcmNvbm5lY3Rpb25zIGZyb20gdGhlIHNhbWUgSlMuXG5TRFBVdGlscy5sb2NhbENOYW1lID0gU0RQVXRpbHMuZ2VuZXJhdGVJZGVudGlmaWVyKCk7XG5cbi8vIFNwbGl0cyBTRFAgaW50byBsaW5lcywgZGVhbGluZyB3aXRoIGJvdGggQ1JMRiBhbmQgTEYuXG5TRFBVdGlscy5zcGxpdExpbmVzID0gZnVuY3Rpb24oYmxvYikge1xuICByZXR1cm4gYmxvYi50cmltKCkuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUudHJpbSgpO1xuICB9KTtcbn07XG4vLyBTcGxpdHMgU0RQIGludG8gc2Vzc2lvbnBhcnQgYW5kIG1lZGlhc2VjdGlvbnMuIEVuc3VyZXMgQ1JMRi5cblNEUFV0aWxzLnNwbGl0U2VjdGlvbnMgPSBmdW5jdGlvbihibG9iKSB7XG4gIHZhciBwYXJ0cyA9IGJsb2Iuc3BsaXQoJ1xcbm09Jyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24ocGFydCwgaW5kZXgpIHtcbiAgICByZXR1cm4gKGluZGV4ID4gMCA/ICdtPScgKyBwYXJ0IDogcGFydCkudHJpbSgpICsgJ1xcclxcbic7XG4gIH0pO1xufTtcblxuLy8gUmV0dXJucyBsaW5lcyB0aGF0IHN0YXJ0IHdpdGggYSBjZXJ0YWluIHByZWZpeC5cblNEUFV0aWxzLm1hdGNoUHJlZml4ID0gZnVuY3Rpb24oYmxvYiwgcHJlZml4KSB7XG4gIHJldHVybiBTRFBVdGlscy5zcGxpdExpbmVzKGJsb2IpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUuaW5kZXhPZihwcmVmaXgpID09PSAwO1xuICB9KTtcbn07XG5cbi8vIFBhcnNlcyBhbiBJQ0UgY2FuZGlkYXRlIGxpbmUuIFNhbXBsZSBpbnB1dDpcbi8vIGNhbmRpZGF0ZTo3MDI3ODYzNTAgMiB1ZHAgNDE4MTk5MDIgOC44LjguOCA2MDc2OSB0eXAgcmVsYXkgcmFkZHIgOC44LjguOFxuLy8gcnBvcnQgNTU5OTZcIlxuU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cztcbiAgLy8gUGFyc2UgYm90aCB2YXJpYW50cy5cbiAgaWYgKGxpbmUuaW5kZXhPZignYT1jYW5kaWRhdGU6JykgPT09IDApIHtcbiAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEyKS5zcGxpdCgnICcpO1xuICB9IGVsc2Uge1xuICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTApLnNwbGl0KCcgJyk7XG4gIH1cblxuICB2YXIgY2FuZGlkYXRlID0ge1xuICAgIGZvdW5kYXRpb246IHBhcnRzWzBdLFxuICAgIGNvbXBvbmVudDogcGFydHNbMV0sXG4gICAgcHJvdG9jb2w6IHBhcnRzWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgcHJpb3JpdHk6IHBhcnNlSW50KHBhcnRzWzNdLCAxMCksXG4gICAgaXA6IHBhcnRzWzRdLFxuICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzVdLCAxMCksXG4gICAgLy8gc2tpcCBwYXJ0c1s2XSA9PSAndHlwJ1xuICAgIHR5cGU6IHBhcnRzWzddXG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDg7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHN3aXRjaCAocGFydHNbaV0pIHtcbiAgICAgIGNhc2UgJ3JhZGRyJzpcbiAgICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jwb3J0JzpcbiAgICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0ID0gcGFyc2VJbnQocGFydHNbaSArIDFdLCAxMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGNwdHlwZSc6XG4gICAgICAgIGNhbmRpZGF0ZS50Y3BUeXBlID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIGV4dGVuc2lvbiBoYW5kbGluZywgaW4gcGFydGljdWxhciB1ZnJhZ1xuICAgICAgICBjYW5kaWRhdGVbcGFydHNbaV1dID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn07XG5cbi8vIFRyYW5zbGF0ZXMgYSBjYW5kaWRhdGUgb2JqZWN0IGludG8gU0RQIGNhbmRpZGF0ZSBhdHRyaWJ1dGUuXG5TRFBVdGlscy53cml0ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGNhbmRpZGF0ZSkge1xuICB2YXIgc2RwID0gW107XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5mb3VuZGF0aW9uKTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLmNvbXBvbmVudCk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcm90b2NvbC50b1VwcGVyQ2FzZSgpKTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLnByaW9yaXR5KTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLmlwKTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLnBvcnQpO1xuXG4gIHZhciB0eXBlID0gY2FuZGlkYXRlLnR5cGU7XG4gIHNkcC5wdXNoKCd0eXAnKTtcbiAgc2RwLnB1c2godHlwZSk7XG4gIGlmICh0eXBlICE9PSAnaG9zdCcgJiYgY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzICYmXG4gICAgICBjYW5kaWRhdGUucmVsYXRlZFBvcnQpIHtcbiAgICBzZHAucHVzaCgncmFkZHInKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MpOyAvLyB3YXM6IHJlbEFkZHJcbiAgICBzZHAucHVzaCgncnBvcnQnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZFBvcnQpOyAvLyB3YXM6IHJlbFBvcnRcbiAgfVxuICBpZiAoY2FuZGlkYXRlLnRjcFR5cGUgJiYgY2FuZGlkYXRlLnByb3RvY29sLnRvTG93ZXJDYXNlKCkgPT09ICd0Y3AnKSB7XG4gICAgc2RwLnB1c2goJ3RjcHR5cGUnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUudGNwVHlwZSk7XG4gIH1cbiAgcmV0dXJuICdjYW5kaWRhdGU6JyArIHNkcC5qb2luKCcgJyk7XG59O1xuXG4vLyBQYXJzZXMgYW4gaWNlLW9wdGlvbnMgbGluZSwgcmV0dXJucyBhbiBhcnJheSBvZiBvcHRpb24gdGFncy5cbi8vIGE9aWNlLW9wdGlvbnM6Zm9vIGJhclxuU0RQVXRpbHMucGFyc2VJY2VPcHRpb25zID0gZnVuY3Rpb24obGluZSkge1xuICByZXR1cm4gbGluZS5zdWJzdHIoMTQpLnNwbGl0KCcgJyk7XG59XG5cbi8vIFBhcnNlcyBhbiBydHBtYXAgbGluZSwgcmV0dXJucyBSVENSdHBDb2RkZWNQYXJhbWV0ZXJzLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXJ0cG1hcDoxMTEgb3B1cy80ODAwMC8yXG5TRFBVdGlscy5wYXJzZVJ0cE1hcCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIoOSkuc3BsaXQoJyAnKTtcbiAgdmFyIHBhcnNlZCA9IHtcbiAgICBwYXlsb2FkVHlwZTogcGFyc2VJbnQocGFydHMuc2hpZnQoKSwgMTApIC8vIHdhczogaWRcbiAgfTtcblxuICBwYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCcvJyk7XG5cbiAgcGFyc2VkLm5hbWUgPSBwYXJ0c1swXTtcbiAgcGFyc2VkLmNsb2NrUmF0ZSA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7IC8vIHdhczogY2xvY2tyYXRlXG4gIC8vIHdhczogY2hhbm5lbHNcbiAgcGFyc2VkLm51bUNoYW5uZWxzID0gcGFydHMubGVuZ3RoID09PSAzID8gcGFyc2VJbnQocGFydHNbMl0sIDEwKSA6IDE7XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBHZW5lcmF0ZSBhbiBhPXJ0cG1hcCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yXG4vLyBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0cE1hcCA9IGZ1bmN0aW9uKGNvZGVjKSB7XG4gIHZhciBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gIH1cbiAgcmV0dXJuICdhPXJ0cG1hcDonICsgcHQgKyAnICcgKyBjb2RlYy5uYW1lICsgJy8nICsgY29kZWMuY2xvY2tSYXRlICtcbiAgICAgIChjb2RlYy5udW1DaGFubmVscyAhPT0gMSA/ICcvJyArIGNvZGVjLm51bUNoYW5uZWxzIDogJycpICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgYW4gYT1leHRtYXAgbGluZSAoaGVhZGVyZXh0ZW5zaW9uIGZyb20gUkZDIDUyODUpLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbi8vIGE9ZXh0bWFwOjIvc2VuZG9ubHkgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuU0RQVXRpbHMucGFyc2VFeHRtYXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDkpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgaWQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgZGlyZWN0aW9uOiBwYXJ0c1swXS5pbmRleE9mKCcvJykgPiAwID8gcGFydHNbMF0uc3BsaXQoJy8nKVsxXSA6ICdzZW5kcmVjdicsXG4gICAgdXJpOiBwYXJ0c1sxXVxuICB9O1xufTtcblxuLy8gR2VuZXJhdGVzIGE9ZXh0bWFwIGxpbmUgZnJvbSBSVENSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzIG9yXG4vLyBSVENSdHBIZWFkZXJFeHRlbnNpb24uXG5TRFBVdGlscy53cml0ZUV4dG1hcCA9IGZ1bmN0aW9uKGhlYWRlckV4dGVuc2lvbikge1xuICByZXR1cm4gJ2E9ZXh0bWFwOicgKyAoaGVhZGVyRXh0ZW5zaW9uLmlkIHx8IGhlYWRlckV4dGVuc2lvbi5wcmVmZXJyZWRJZCkgK1xuICAgICAgKGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gJiYgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2J1xuICAgICAgICAgID8gJy8nICsgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvblxuICAgICAgICAgIDogJycpICtcbiAgICAgICcgJyArIGhlYWRlckV4dGVuc2lvbi51cmkgKyAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyBhbiBmdG1wIGxpbmUsIHJldHVybnMgZGljdGlvbmFyeS4gU2FtcGxlIGlucHV0OlxuLy8gYT1mbXRwOjk2IHZicj1vbjtjbmc9b25cbi8vIEFsc28gZGVhbHMgd2l0aCB2YnI9b247IGNuZz1vblxuU0RQVXRpbHMucGFyc2VGbXRwID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrdjtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnOycpO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAga3YgPSBwYXJ0c1tqXS50cmltKCkuc3BsaXQoJz0nKTtcbiAgICBwYXJzZWRba3ZbMF0udHJpbSgpXSA9IGt2WzFdO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBHZW5lcmF0ZXMgYW4gYT1mdG1wIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVGbXRwID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgdmFyIGxpbmUgPSAnJztcbiAgdmFyIHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBpZiAoY29kZWMucGFyYW1ldGVycyAmJiBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5sZW5ndGgpIHtcbiAgICB2YXIgcGFyYW1zID0gW107XG4gICAgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgcGFyYW1zLnB1c2gocGFyYW0gKyAnPScgKyBjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgfSk7XG4gICAgbGluZSArPSAnYT1mbXRwOicgKyBwdCArICcgJyArIHBhcmFtcy5qb2luKCc7JykgKyAnXFxyXFxuJztcbiAgfVxuICByZXR1cm4gbGluZTtcbn07XG5cbi8vIFBhcnNlcyBhbiBydGNwLWZiIGxpbmUsIHJldHVybnMgUlRDUFJ0Y3BGZWVkYmFjayBvYmplY3QuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcblNEUFV0aWxzLnBhcnNlUnRjcEZiID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cihsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogcGFydHMuc2hpZnQoKSxcbiAgICBwYXJhbWV0ZXI6IHBhcnRzLmpvaW4oJyAnKVxuICB9O1xufTtcbi8vIEdlbmVyYXRlIGE9cnRjcC1mYiBsaW5lcyBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0Y3BGYiA9IGZ1bmN0aW9uKGNvZGVjKSB7XG4gIHZhciBsaW5lcyA9ICcnO1xuICB2YXIgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGlmIChjb2RlYy5ydGNwRmVlZGJhY2sgJiYgY29kZWMucnRjcEZlZWRiYWNrLmxlbmd0aCkge1xuICAgIC8vIEZJWE1FOiBzcGVjaWFsIGhhbmRsaW5nIGZvciB0cnItaW50P1xuICAgIGNvZGVjLnJ0Y3BGZWVkYmFjay5mb3JFYWNoKGZ1bmN0aW9uKGZiKSB7XG4gICAgICBsaW5lcyArPSAnYT1ydGNwLWZiOicgKyBwdCArICcgJyArIGZiLnR5cGUgK1xuICAgICAgKGZiLnBhcmFtZXRlciAmJiBmYi5wYXJhbWV0ZXIubGVuZ3RoID8gJyAnICsgZmIucGFyYW1ldGVyIDogJycpICtcbiAgICAgICAgICAnXFxyXFxuJztcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbGluZXM7XG59O1xuXG4vLyBQYXJzZXMgYW4gUkZDIDU1NzYgc3NyYyBtZWRpYSBhdHRyaWJ1dGUuIFNhbXBsZSBpbnB1dDpcbi8vIGE9c3NyYzozNzM1OTI4NTU5IGNuYW1lOnNvbWV0aGluZ1xuU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBzcCA9IGxpbmUuaW5kZXhPZignICcpO1xuICB2YXIgcGFydHMgPSB7XG4gICAgc3NyYzogcGFyc2VJbnQobGluZS5zdWJzdHIoNywgc3AgLSA3KSwgMTApXG4gIH07XG4gIHZhciBjb2xvbiA9IGxpbmUuaW5kZXhPZignOicsIHNwKTtcbiAgaWYgKGNvbG9uID4gLTEpIHtcbiAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cihzcCArIDEsIGNvbG9uIC0gc3AgLSAxKTtcbiAgICBwYXJ0cy52YWx1ZSA9IGxpbmUuc3Vic3RyKGNvbG9uICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHIoc3AgKyAxKTtcbiAgfVxuICByZXR1cm4gcGFydHM7XG59O1xuXG4vLyBFeHRyYWN0cyB0aGUgTUlEIChSRkMgNTg4OCkgZnJvbSBhIG1lZGlhIHNlY3Rpb24uXG4vLyByZXR1cm5zIHRoZSBNSUQgb3IgdW5kZWZpbmVkIGlmIG5vIG1pZCBsaW5lIHdhcyBmb3VuZC5cblNEUFV0aWxzLmdldE1pZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgbWlkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1taWQ6JylbMF07XG4gIGlmIChtaWQpIHtcbiAgICByZXR1cm4gbWlkLnN1YnN0cig2KTtcbiAgfVxufVxuXG5TRFBVdGlscy5wYXJzZUZpbmdlcnByaW50ID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cigxNCkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBhbGdvcml0aG06IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCksIC8vIGFsZ29yaXRobSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBFZGdlLlxuICAgIHZhbHVlOiBwYXJ0c1sxXVxuICB9O1xufTtcblxuLy8gRXh0cmFjdHMgRFRMUyBwYXJhbWV0ZXJzIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4vLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcbi8vICAgZ2V0IHRoZSBmaW5nZXJwcmludCBsaW5lIGFzIGlucHV0LiBTZWUgYWxzbyBnZXRJY2VQYXJhbWV0ZXJzLlxuU0RQVXRpbHMuZ2V0RHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICAgJ2E9ZmluZ2VycHJpbnQ6Jyk7XG4gIC8vIE5vdGU6IGE9c2V0dXAgbGluZSBpcyBpZ25vcmVkIHNpbmNlIHdlIHVzZSB0aGUgJ2F1dG8nIHJvbGUuXG4gIC8vIE5vdGUyOiAnYWxnb3JpdGhtJyBpcyBub3QgY2FzZSBzZW5zaXRpdmUgZXhjZXB0IGluIEVkZ2UuXG4gIHJldHVybiB7XG4gICAgcm9sZTogJ2F1dG8nLFxuICAgIGZpbmdlcnByaW50czogbGluZXMubWFwKFNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQpXG4gIH07XG59O1xuXG4vLyBTZXJpYWxpemVzIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG5TRFBVdGlscy53cml0ZUR0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zLCBzZXR1cFR5cGUpIHtcbiAgdmFyIHNkcCA9ICdhPXNldHVwOicgKyBzZXR1cFR5cGUgKyAnXFxyXFxuJztcbiAgcGFyYW1zLmZpbmdlcnByaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGZwKSB7XG4gICAgc2RwICs9ICdhPWZpbmdlcnByaW50OicgKyBmcC5hbGdvcml0aG0gKyAnICcgKyBmcC52YWx1ZSArICdcXHJcXG4nO1xuICB9KTtcbiAgcmV0dXJuIHNkcDtcbn07XG4vLyBQYXJzZXMgSUNFIGluZm9ybWF0aW9uIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4vLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcbi8vICAgZ2V0IHRoZSBpY2UtdWZyYWcgYW5kIGljZS1wd2QgbGluZXMgYXMgaW5wdXQuXG5TRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIC8vIFNlYXJjaCBpbiBzZXNzaW9uIHBhcnQsIHRvby5cbiAgbGluZXMgPSBsaW5lcy5jb25jYXQoU0RQVXRpbHMuc3BsaXRMaW5lcyhzZXNzaW9ucGFydCkpO1xuICB2YXIgaWNlUGFyYW1ldGVycyA9IHtcbiAgICB1c2VybmFtZUZyYWdtZW50OiBsaW5lcy5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgcmV0dXJuIGxpbmUuaW5kZXhPZignYT1pY2UtdWZyYWc6JykgPT09IDA7XG4gICAgfSlbMF0uc3Vic3RyKDEyKSxcbiAgICBwYXNzd29yZDogbGluZXMuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHJldHVybiBsaW5lLmluZGV4T2YoJ2E9aWNlLXB3ZDonKSA9PT0gMDtcbiAgICB9KVswXS5zdWJzdHIoMTApXG4gIH07XG4gIHJldHVybiBpY2VQYXJhbWV0ZXJzO1xufTtcblxuLy8gU2VyaWFsaXplcyBJQ0UgcGFyYW1ldGVycyB0byBTRFAuXG5TRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgcmV0dXJuICdhPWljZS11ZnJhZzonICsgcGFyYW1zLnVzZXJuYW1lRnJhZ21lbnQgKyAnXFxyXFxuJyArXG4gICAgICAnYT1pY2UtcHdkOicgKyBwYXJhbXMucGFzc3dvcmQgKyAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgUlRDUnRwUGFyYW1ldGVycy5cblNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgZGVzY3JpcHRpb24gPSB7XG4gICAgY29kZWNzOiBbXSxcbiAgICBoZWFkZXJFeHRlbnNpb25zOiBbXSxcbiAgICBmZWNNZWNoYW5pc21zOiBbXSxcbiAgICBydGNwOiBbXVxuICB9O1xuICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIHZhciBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gIGZvciAodmFyIGkgPSAzOyBpIDwgbWxpbmUubGVuZ3RoOyBpKyspIHsgLy8gZmluZCBhbGwgY29kZWNzIGZyb20gbWxpbmVbMy4uXVxuICAgIHZhciBwdCA9IG1saW5lW2ldO1xuICAgIHZhciBydHBtYXBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICAgIG1lZGlhU2VjdGlvbiwgJ2E9cnRwbWFwOicgKyBwdCArICcgJylbMF07XG4gICAgaWYgKHJ0cG1hcGxpbmUpIHtcbiAgICAgIHZhciBjb2RlYyA9IFNEUFV0aWxzLnBhcnNlUnRwTWFwKHJ0cG1hcGxpbmUpO1xuICAgICAgdmFyIGZtdHBzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICAgICAgbWVkaWFTZWN0aW9uLCAnYT1mbXRwOicgKyBwdCArICcgJyk7XG4gICAgICAvLyBPbmx5IHRoZSBmaXJzdCBhPWZtdHA6PHB0PiBpcyBjb25zaWRlcmVkLlxuICAgICAgY29kZWMucGFyYW1ldGVycyA9IGZtdHBzLmxlbmd0aCA/IFNEUFV0aWxzLnBhcnNlRm10cChmbXRwc1swXSkgOiB7fTtcbiAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICAgIG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjonICsgcHQgKyAnICcpXG4gICAgICAgIC5tYXAoU0RQVXRpbHMucGFyc2VSdGNwRmIpO1xuICAgICAgZGVzY3JpcHRpb24uY29kZWNzLnB1c2goY29kZWMpO1xuICAgICAgLy8gcGFyc2UgRkVDIG1lY2hhbmlzbXMgZnJvbSBydHBtYXAgbGluZXMuXG4gICAgICBzd2l0Y2ggKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdSRUQnOlxuICAgICAgICBjYXNlICdVTFBGRUMnOlxuICAgICAgICAgIGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMucHVzaChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyBvbmx5IFJFRCBhbmQgVUxQRkVDIGFyZSByZWNvZ25pemVkIGFzIEZFQyBtZWNoYW5pc21zLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPWV4dG1hcDonKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICBkZXNjcmlwdGlvbi5oZWFkZXJFeHRlbnNpb25zLnB1c2goU0RQVXRpbHMucGFyc2VFeHRtYXAobGluZSkpO1xuICB9KTtcbiAgLy8gRklYTUU6IHBhcnNlIHJ0Y3AuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn07XG5cbi8vIEdlbmVyYXRlcyBwYXJ0cyBvZiB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gZGVzY3JpYmluZyB0aGUgY2FwYWJpbGl0aWVzIC9cbi8vIHBhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24oa2luZCwgY2Fwcykge1xuICB2YXIgc2RwID0gJyc7XG5cbiAgLy8gQnVpbGQgdGhlIG1saW5lLlxuICBzZHAgKz0gJ209JyArIGtpbmQgKyAnICc7XG4gIHNkcCArPSBjYXBzLmNvZGVjcy5sZW5ndGggPiAwID8gJzknIDogJzAnOyAvLyByZWplY3QgaWYgbm8gY29kZWNzLlxuICBzZHAgKz0gJyBVRFAvVExTL1JUUC9TQVZQRiAnO1xuICBzZHAgKz0gY2Fwcy5jb2RlY3MubWFwKGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xuICB9KS5qb2luKCcgJykgKyAnXFxyXFxuJztcblxuICBzZHAgKz0gJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xuICBzZHAgKz0gJ2E9cnRjcDo5IElOIElQNCAwLjAuMC4wXFxyXFxuJztcblxuICAvLyBBZGQgYT1ydHBtYXAgbGluZXMgZm9yIGVhY2ggY29kZWMuIEFsc28gZm10cCBhbmQgcnRjcC1mYi5cbiAgY2Fwcy5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjb2RlYykge1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0cE1hcChjb2RlYyk7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRm10cChjb2RlYyk7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRjcEZiKGNvZGVjKTtcbiAgfSk7XG4gIHZhciBtYXhwdGltZSA9IDA7XG4gIGNhcHMuY29kZWNzLmZvckVhY2goZnVuY3Rpb24oY29kZWMpIHtcbiAgICBpZiAoY29kZWMubWF4cHRpbWUgPiBtYXhwdGltZSkge1xuICAgICAgbWF4cHRpbWUgPSBjb2RlYy5tYXhwdGltZTtcbiAgICB9XG4gIH0pO1xuICBpZiAobWF4cHRpbWUgPiAwKSB7XG4gICAgc2RwICs9ICdhPW1heHB0aW1lOicgKyBtYXhwdGltZSArICdcXHJcXG4nO1xuICB9XG4gIHNkcCArPSAnYT1ydGNwLW11eFxcclxcbic7XG5cbiAgY2Fwcy5oZWFkZXJFeHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24oZXh0ZW5zaW9uKSB7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRXh0bWFwKGV4dGVuc2lvbik7XG4gIH0pO1xuICAvLyBGSVhNRTogd3JpdGUgZmVjTWVjaGFuaXNtcy5cbiAgcmV0dXJuIHNkcDtcbn07XG5cbi8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgYW4gYXJyYXkgb2Zcbi8vIFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVycy5cblNEUFV0aWxzLnBhcnNlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBlbmNvZGluZ1BhcmFtZXRlcnMgPSBbXTtcbiAgdmFyIGRlc2NyaXB0aW9uID0gU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG4gIHZhciBoYXNSZWQgPSBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLmluZGV4T2YoJ1JFRCcpICE9PSAtMTtcbiAgdmFyIGhhc1VscGZlYyA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignVUxQRkVDJykgIT09IC0xO1xuXG4gIC8vIGZpbHRlciBhPXNzcmM6Li4uIGNuYW1lOiwgaWdub3JlIFBsYW5CLW1zaWRcbiAgdmFyIHNzcmNzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpXG4gIC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgIHJldHVybiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKTtcbiAgfSlcbiAgLmZpbHRlcihmdW5jdGlvbihwYXJ0cykge1xuICAgIHJldHVybiBwYXJ0cy5hdHRyaWJ1dGUgPT09ICdjbmFtZSc7XG4gIH0pO1xuICB2YXIgcHJpbWFyeVNzcmMgPSBzc3Jjcy5sZW5ndGggPiAwICYmIHNzcmNzWzBdLnNzcmM7XG4gIHZhciBzZWNvbmRhcnlTc3JjO1xuXG4gIHZhciBmbG93cyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYy1ncm91cDpGSUQnKVxuICAubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCcgJyk7XG4gICAgcGFydHMuc2hpZnQoKTtcbiAgICByZXR1cm4gcGFydHMubWFwKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChwYXJ0LCAxMCk7XG4gICAgfSk7XG4gIH0pO1xuICBpZiAoZmxvd3MubGVuZ3RoID4gMCAmJiBmbG93c1swXS5sZW5ndGggPiAxICYmIGZsb3dzWzBdWzBdID09PSBwcmltYXJ5U3NyYykge1xuICAgIHNlY29uZGFyeVNzcmMgPSBmbG93c1swXVsxXTtcbiAgfVxuXG4gIGRlc2NyaXB0aW9uLmNvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgaWYgKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1JUWCcgJiYgY29kZWMucGFyYW1ldGVycy5hcHQpIHtcbiAgICAgIHZhciBlbmNQYXJhbSA9IHtcbiAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgICAgIGNvZGVjUGF5bG9hZFR5cGU6IHBhcnNlSW50KGNvZGVjLnBhcmFtZXRlcnMuYXB0LCAxMCksXG4gICAgICAgIHJ0eDoge1xuICAgICAgICAgIHNzcmM6IHNlY29uZGFyeVNzcmNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgIGlmIChoYXNSZWQpIHtcbiAgICAgICAgZW5jUGFyYW0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVuY1BhcmFtKSk7XG4gICAgICAgIGVuY1BhcmFtLmZlYyA9IHtcbiAgICAgICAgICBzc3JjOiBzZWNvbmRhcnlTc3JjLFxuICAgICAgICAgIG1lY2hhbmlzbTogaGFzVWxwZmVjID8gJ3JlZCt1bHBmZWMnIDogJ3JlZCdcbiAgICAgICAgfTtcbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChlbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoID09PSAwICYmIHByaW1hcnlTc3JjKSB7XG4gICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goe1xuICAgICAgc3NyYzogcHJpbWFyeVNzcmNcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHdlIHN1cHBvcnQgYm90aCBiPUFTIGFuZCBiPVRJQVMgYnV0IGludGVycHJldCBBUyBhcyBUSUFTLlxuICB2YXIgYmFuZHdpZHRoID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYj0nKTtcbiAgaWYgKGJhbmR3aWR0aC5sZW5ndGgpIHtcbiAgICBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9VElBUzonKSA9PT0gMCkge1xuICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cig3KSwgMTApO1xuICAgIH0gZWxzZSBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9QVM6JykgPT09IDApIHtcbiAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHIoNSksIDEwKTtcbiAgICB9XG4gICAgZW5jb2RpbmdQYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICBwYXJhbXMubWF4Qml0cmF0ZSA9IGJhbmR3aWR0aDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZW5jb2RpbmdQYXJhbWV0ZXJzO1xufTtcblxuLy8gcGFyc2VzIGh0dHA6Ly9kcmFmdC5vcnRjLm9yZy8jcnRjcnRjcHBhcmFtZXRlcnMqXG5TRFBVdGlscy5wYXJzZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBydGNwUGFyYW1ldGVycyA9IHt9O1xuXG4gIHZhciBjbmFtZTtcbiAgLy8gR2V0cyB0aGUgZmlyc3QgU1NSQy4gTm90ZSB0aGF0IHdpdGggUlRYIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlXG4gIC8vIFNTUkNzLlxuICB2YXIgcmVtb3RlU3NyYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgICAgLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHJldHVybiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJztcbiAgICAgIH0pWzBdO1xuICBpZiAocmVtb3RlU3NyYykge1xuICAgIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lID0gcmVtb3RlU3NyYy52YWx1ZTtcbiAgICBydGNwUGFyYW1ldGVycy5zc3JjID0gcmVtb3RlU3NyYy5zc3JjO1xuICB9XG5cbiAgLy8gRWRnZSB1c2VzIHRoZSBjb21wb3VuZCBhdHRyaWJ1dGUgaW5zdGVhZCBvZiByZWR1Y2VkU2l6ZVxuICAvLyBjb21wb3VuZCBpcyAhcmVkdWNlZFNpemVcbiAgdmFyIHJzaXplID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLXJzaXplJyk7XG4gIHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplID0gcnNpemUubGVuZ3RoID4gMDtcbiAgcnRjcFBhcmFtZXRlcnMuY29tcG91bmQgPSByc2l6ZS5sZW5ndGggPT09IDA7XG5cbiAgLy8gcGFyc2VzIHRoZSBydGNwLW11eCBhdHRy0ZZidXRlLlxuICAvLyBOb3RlIHRoYXQgRWRnZSBkb2VzIG5vdCBzdXBwb3J0IHVubXV4ZWQgUlRDUC5cbiAgdmFyIG11eCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1tdXgnKTtcbiAgcnRjcFBhcmFtZXRlcnMubXV4ID0gbXV4Lmxlbmd0aCA+IDA7XG5cbiAgcmV0dXJuIHJ0Y3BQYXJhbWV0ZXJzO1xufTtcblxuLy8gcGFyc2VzIGVpdGhlciBhPW1zaWQ6IG9yIGE9c3NyYzouLi4gbXNpZCBsaW5lcyBhbmQgcmV0dXJuc1xuLy8gdGhlIGlkIG9mIHRoZSBNZWRpYVN0cmVhbSBhbmQgTWVkaWFTdHJlYW1UcmFjay5cblNEUFV0aWxzLnBhcnNlTXNpZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgcGFydHM7XG4gIHZhciBzcGVjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1tc2lkOicpO1xuICBpZiAoc3BlYy5sZW5ndGggPT09IDEpIHtcbiAgICBwYXJ0cyA9IHNwZWNbMF0uc3Vic3RyKDcpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtzdHJlYW06IHBhcnRzWzBdLCB0cmFjazogcGFydHNbMV19O1xuICB9XG4gIHZhciBwbGFuQiA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICByZXR1cm4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSk7XG4gIH0pXG4gIC5maWx0ZXIoZnVuY3Rpb24ocGFydHMpIHtcbiAgICByZXR1cm4gcGFydHMuYXR0cmlidXRlID09PSAnbXNpZCc7XG4gIH0pO1xuICBpZiAocGxhbkIubGVuZ3RoID4gMCkge1xuICAgIHBhcnRzID0gcGxhbkJbMF0udmFsdWUuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge3N0cmVhbTogcGFydHNbMF0sIHRyYWNrOiBwYXJ0c1sxXX07XG4gIH1cbn07XG5cblNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIEZJWE1FOiBzZXNzLWlkIHNob3VsZCBiZSBhbiBOVFAgdGltZXN0YW1wLlxuICByZXR1cm4gJ3Y9MFxcclxcbicgK1xuICAgICAgJ289dGhpc2lzYWRhcHRlcm9ydGMgODE2OTYzOTkxNTY0Njk0MzEzNyAyIElOIElQNCAxMjcuMC4wLjFcXHJcXG4nICtcbiAgICAgICdzPS1cXHJcXG4nICtcbiAgICAgICd0PTAgMFxcclxcbic7XG59O1xuXG5TRFBVdGlscy53cml0ZU1lZGlhU2VjdGlvbiA9IGZ1bmN0aW9uKHRyYW5zY2VpdmVyLCBjYXBzLCB0eXBlLCBzdHJlYW0pIHtcbiAgdmFyIHNkcCA9IFNEUFV0aWxzLndyaXRlUnRwRGVzY3JpcHRpb24odHJhbnNjZWl2ZXIua2luZCwgY2Fwcyk7XG5cbiAgLy8gTWFwIElDRSBwYXJhbWV0ZXJzICh1ZnJhZywgcHdkKSB0byBTRFAuXG4gIHNkcCArPSBTRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMoXG4gICAgICB0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5nZXRMb2NhbFBhcmFtZXRlcnMoKSk7XG5cbiAgLy8gTWFwIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG4gIHNkcCArPSBTRFBVdGlscy53cml0ZUR0bHNQYXJhbWV0ZXJzKFxuICAgICAgdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydC5nZXRMb2NhbFBhcmFtZXRlcnMoKSxcbiAgICAgIHR5cGUgPT09ICdvZmZlcicgPyAnYWN0cGFzcycgOiAnYWN0aXZlJyk7XG5cbiAgc2RwICs9ICdhPW1pZDonICsgdHJhbnNjZWl2ZXIubWlkICsgJ1xcclxcbic7XG5cbiAgaWYgKHRyYW5zY2VpdmVyLmRpcmVjdGlvbikge1xuICAgIHNkcCArPSAnYT0nICsgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uICsgJ1xcclxcbic7XG4gIH0gZWxzZSBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyICYmIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyKSB7XG4gICAgc2RwICs9ICdhPXNlbmRyZWN2XFxyXFxuJztcbiAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIpIHtcbiAgICBzZHAgKz0gJ2E9c2VuZG9ubHlcXHJcXG4nO1xuICB9IGVsc2UgaWYgKHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyKSB7XG4gICAgc2RwICs9ICdhPXJlY3Zvbmx5XFxyXFxuJztcbiAgfSBlbHNlIHtcbiAgICBzZHAgKz0gJ2E9aW5hY3RpdmVcXHJcXG4nO1xuICB9XG5cbiAgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlcikge1xuICAgIC8vIHNwZWMuXG4gICAgdmFyIG1zaWQgPSAnbXNpZDonICsgc3RyZWFtLmlkICsgJyAnICtcbiAgICAgICAgdHJhbnNjZWl2ZXIucnRwU2VuZGVyLnRyYWNrLmlkICsgJ1xcclxcbic7XG4gICAgc2RwICs9ICdhPScgKyBtc2lkO1xuXG4gICAgLy8gZm9yIENocm9tZS5cbiAgICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjICtcbiAgICAgICAgJyAnICsgbXNpZDtcbiAgICBpZiAodHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHgpIHtcbiAgICAgIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eC5zc3JjICtcbiAgICAgICAgICAnICcgKyBtc2lkO1xuICAgICAgc2RwICs9ICdhPXNzcmMtZ3JvdXA6RklEICcgK1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYyArICcgJyArXG4gICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHguc3NyYyArXG4gICAgICAgICAgJ1xcclxcbic7XG4gICAgfVxuICB9XG4gIC8vIEZJWE1FOiB0aGlzIHNob3VsZCBiZSB3cml0dGVuIGJ5IHdyaXRlUnRwRGVzY3JpcHRpb24uXG4gIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmMgK1xuICAgICAgJyBjbmFtZTonICsgU0RQVXRpbHMubG9jYWxDTmFtZSArICdcXHJcXG4nO1xuICBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyICYmIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4KSB7XG4gICAgc2RwICs9ICdhPXNzcmM6JyArIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4LnNzcmMgK1xuICAgICAgICAnIGNuYW1lOicgKyBTRFBVdGlscy5sb2NhbENOYW1lICsgJ1xcclxcbic7XG4gIH1cbiAgcmV0dXJuIHNkcDtcbn07XG5cbi8vIEdldHMgdGhlIGRpcmVjdGlvbiBmcm9tIHRoZSBtZWRpYVNlY3Rpb24gb3IgdGhlIHNlc3Npb25wYXJ0LlxuU0RQVXRpbHMuZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICAvLyBMb29rIGZvciBzZW5kcmVjdiwgc2VuZG9ubHksIHJlY3Zvbmx5LCBpbmFjdGl2ZSwgZGVmYXVsdCB0byBzZW5kcmVjdi5cbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3dpdGNoIChsaW5lc1tpXSkge1xuICAgICAgY2FzZSAnYT1zZW5kcmVjdic6XG4gICAgICBjYXNlICdhPXNlbmRvbmx5JzpcbiAgICAgIGNhc2UgJ2E9cmVjdm9ubHknOlxuICAgICAgY2FzZSAnYT1pbmFjdGl2ZSc6XG4gICAgICAgIHJldHVybiBsaW5lc1tpXS5zdWJzdHIoMik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBGSVhNRTogV2hhdCBzaG91bGQgaGFwcGVuIGhlcmU/XG4gICAgfVxuICB9XG4gIGlmIChzZXNzaW9ucGFydCkge1xuICAgIHJldHVybiBTRFBVdGlscy5nZXREaXJlY3Rpb24oc2Vzc2lvbnBhcnQpO1xuICB9XG4gIHJldHVybiAnc2VuZHJlY3YnO1xufTtcblxuU0RQVXRpbHMuZ2V0S2luZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIHZhciBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gIHJldHVybiBtbGluZVswXS5zdWJzdHIoMik7XG59O1xuXG5TRFBVdGlscy5pc1JlamVjdGVkID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHJldHVybiBtZWRpYVNlY3Rpb24uc3BsaXQoJyAnLCAyKVsxXSA9PT0gJzAnO1xufTtcblxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxubW9kdWxlLmV4cG9ydHMgPSBTRFBVdGlscztcbiIsIi8qKlxuICogQ3JlYXRlZCBieSBTYW11ZWwgb24gNi80LzIwMTYuXG4gKiBTaW1wbGUgd3JhcHBlciBmdW5jdGlvbnMgdG8gcHJvZHVjZSBzaG9ydGVyIFVVSURzIGZvciBjb29raWVzLCBtYXliZSBldmVyeXRoaW5nP1xuICovXG5cbmNvbnN0IHsgdjQ6IHV1aWR2NCB9ID0gcmVxdWlyZSgndXVpZCcpO1xuY29uc3QgYW55QmFzZSA9IHJlcXVpcmUoJ2FueS1iYXNlJyk7XG5cbmNvbnN0IGZsaWNrckJhc2U1OCA9ICcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJztcbmNvbnN0IGNvb2tpZUJhc2U5MCA9IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVohIyQlJicoKSorLS4vOjw9Pj9AW11eX2B7fH1+XCI7XG5cbmNvbnN0IGJhc2VPcHRpb25zID0ge1xuICBjb25zaXN0ZW50TGVuZ3RoOiB0cnVlLFxufTtcblxuLy8gQSBkZWZhdWx0IGdlbmVyYXRvciwgaW5zdGFudGlhdGVkIG9ubHkgaWYgdXNlZC5cbmxldCB0b0ZsaWNrcjtcblxuLyoqXG4gKiBUYWtlcyBhIFVVSUQsIHN0cmlwcyB0aGUgZGFzaGVzLCBhbmQgdHJhbnNsYXRlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBsb25nSWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nKX0gdHJhbnNsYXRvclxuICogQHBhcmFtIHtPYmplY3R9IFtwYWRkaW5nUGFyYW1zXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3Qgc2hvcnRlblVVSUQgPSAobG9uZ0lkLCB0cmFuc2xhdG9yLCBwYWRkaW5nUGFyYW1zKSA9PiB7XG4gIGNvbnN0IHRyYW5zbGF0ZWQgPSB0cmFuc2xhdG9yKGxvbmdJZC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJycpKTtcblxuICBpZiAoIXBhZGRpbmdQYXJhbXMgfHwgIXBhZGRpbmdQYXJhbXMuY29uc2lzdGVudExlbmd0aCkgcmV0dXJuIHRyYW5zbGF0ZWQ7XG5cbiAgcmV0dXJuIHRyYW5zbGF0ZWQucGFkU3RhcnQoXG4gICAgcGFkZGluZ1BhcmFtcy5zaG9ydElkTGVuZ3RoLFxuICAgIHBhZGRpbmdQYXJhbXMucGFkZGluZ0NoYXIsXG4gICk7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBiYWNrIHRvIGhleCBhbmQgdHVybiBiYWNrIGludG8gVVVJRCBmb3JtYXQsIHdpdGggZGFzaGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hvcnRJZFxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpfSB0cmFuc2xhdG9yXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBlbmxhcmdlVVVJRCA9IChzaG9ydElkLCB0cmFuc2xhdG9yKSA9PiB7XG4gIGNvbnN0IHV1MSA9IHRyYW5zbGF0b3Ioc2hvcnRJZCkucGFkU3RhcnQoMzIsICcwJyk7XG5cbiAgLy8gSm9pbiB0aGUgemVybyBwYWRkaW5nIGFuZCB0aGUgVVVJRCBhbmQgdGhlbiBzbGljZSBpdCB1cCB3aXRoIG1hdGNoXG4gIGNvbnN0IG0gPSB1dTEubWF0Y2goLyhcXHd7OH0pKFxcd3s0fSkoXFx3ezR9KShcXHd7NH0pKFxcd3sxMn0pLyk7XG5cbiAgLy8gQWNjdW11bGF0ZSB0aGUgbWF0Y2hlcyBhbmQgam9pbiB0aGVtLlxuICByZXR1cm4gW21bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV1dLmpvaW4oJy0nKTtcbn07XG5cbi8vIENhbGN1bGF0ZSBsZW5ndGggZm9yIHRoZSBzaG9ydGVuZWQgSURcbmNvbnN0IGdldFNob3J0SWRMZW5ndGggPSAoYWxwaGFiZXRMZW5ndGgpID0+IChcbiAgTWF0aC5jZWlsKE1hdGgubG9nKDIgKiogMTI4KSAvIE1hdGgubG9nKGFscGhhYmV0TGVuZ3RoKSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICgoKSA9PiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9BbHBoYWJldCAtIERlZmF1bHRzIHRvIGZsaWNrckJhc2U1OCBpZiBub3QgcHJvdmlkZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKlxuICAgKiBAcmV0dXJucyB7e25ldzogKGZ1bmN0aW9uKCkpLFxuICAgKiAgdXVpZDogKGZ1bmN0aW9uKCkpLFxuICAgKiAgZnJvbVVVSUQ6IChmdW5jdGlvbihzdHJpbmcpKSxcbiAgICogIHRvVVVJRDogKGZ1bmN0aW9uKHN0cmluZykpLFxuICAgKiAgYWxwaGFiZXQ6IChzdHJpbmcpfX1cbiAgICovXG4gIGNvbnN0IG1ha2VDb252ZXJ0b3IgPSAodG9BbHBoYWJldCwgb3B0aW9ucykgPT4ge1xuICAgIC8vIERlZmF1bHQgdG8gRmxpY2tyIDU4XG4gICAgY29uc3QgdXNlQWxwaGFiZXQgPSB0b0FscGhhYmV0IHx8IGZsaWNrckJhc2U1ODtcblxuICAgIC8vIERlZmF1bHQgdG8gYmFzZU9wdGlvbnNcbiAgICBjb25zdCBzZWxlY3RlZE9wdGlvbnMgPSB7IC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG5cbiAgICAvLyBDaGVjayBhbHBoYWJldCBmb3IgZHVwbGljYXRlIGVudHJpZXNcbiAgICBpZiAoWy4uLm5ldyBTZXQoQXJyYXkuZnJvbSh1c2VBbHBoYWJldCkpXS5sZW5ndGggIT09IHVzZUFscGhhYmV0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvdmlkZWQgQWxwaGFiZXQgaGFzIGR1cGxpY2F0ZSBjaGFyYWN0ZXJzIHJlc3VsdGluZyBpbiB1bnJlbGlhYmxlIHJlc3VsdHMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaG9ydElkTGVuZ3RoID0gZ2V0U2hvcnRJZExlbmd0aCh1c2VBbHBoYWJldC5sZW5ndGgpO1xuXG4gICAgLy8gUGFkZGluZyBQYXJhbXNcbiAgICBjb25zdCBwYWRkaW5nUGFyYW1zID0ge1xuICAgICAgc2hvcnRJZExlbmd0aCxcbiAgICAgIGNvbnNpc3RlbnRMZW5ndGg6IHNlbGVjdGVkT3B0aW9ucy5jb25zaXN0ZW50TGVuZ3RoLFxuICAgICAgcGFkZGluZ0NoYXI6IHVzZUFscGhhYmV0WzBdLFxuICAgIH07XG5cbiAgICAvLyBVVUlEcyBhcmUgaW4gaGV4LCBzbyB3ZSB0cmFuc2xhdGUgdG8gYW5kIGZyb20uXG4gICAgY29uc3QgZnJvbUhleCA9IGFueUJhc2UoYW55QmFzZS5IRVgsIHVzZUFscGhhYmV0KTtcbiAgICBjb25zdCB0b0hleCA9IGFueUJhc2UodXNlQWxwaGFiZXQsIGFueUJhc2UuSEVYKTtcbiAgICBjb25zdCBnZW5lcmF0ZSA9ICgpID0+IHNob3J0ZW5VVUlEKHV1aWR2NCgpLCBmcm9tSGV4LCBwYWRkaW5nUGFyYW1zKTtcblxuICAgIGNvbnN0IHRyYW5zbGF0b3IgPSB7XG4gICAgICBuZXc6IGdlbmVyYXRlLFxuICAgICAgZ2VuZXJhdGUsXG4gICAgICB1dWlkOiB1dWlkdjQsXG4gICAgICBmcm9tVVVJRDogKHV1aWQpID0+IHNob3J0ZW5VVUlEKHV1aWQsIGZyb21IZXgsIHBhZGRpbmdQYXJhbXMpLFxuICAgICAgdG9VVUlEOiAoc2hvcnRVdWlkKSA9PiBlbmxhcmdlVVVJRChzaG9ydFV1aWQsIHRvSGV4KSxcbiAgICAgIGFscGhhYmV0OiB1c2VBbHBoYWJldCxcbiAgICAgIG1heExlbmd0aDogc2hvcnRJZExlbmd0aCxcbiAgICB9O1xuXG4gICAgT2JqZWN0LmZyZWV6ZSh0cmFuc2xhdG9yKTtcblxuICAgIHJldHVybiB0cmFuc2xhdG9yO1xuICB9O1xuXG4gIC8vIEV4cG9zZSB0aGUgY29uc3RhbnRzIGZvciBvdGhlciBwdXJwb3Nlcy5cbiAgbWFrZUNvbnZlcnRvci5jb25zdGFudHMgPSB7XG4gICAgZmxpY2tyQmFzZTU4LFxuICAgIGNvb2tpZUJhc2U5MCxcbiAgfTtcblxuICAvLyBFeHBvc2UgdGhlIGdlbmVyaWMgdjQgVVVJRCBnZW5lcmF0b3IgZm9yIGNvbnZlbmllbmNlXG4gIG1ha2VDb252ZXJ0b3IudXVpZCA9IHV1aWR2NDtcblxuICAvLyBQcm92aWRlIGEgZ2VuZXJpYyBnZW5lcmF0b3JcbiAgbWFrZUNvbnZlcnRvci5nZW5lcmF0ZSA9ICgpID0+IHtcbiAgICBpZiAoIXRvRmxpY2tyKSB7XG4gICAgICAvLyBHZW5lcmF0ZSBvbiBmaXJzdCB1c2U7XG4gICAgICB0b0ZsaWNrciA9IG1ha2VDb252ZXJ0b3IoZmxpY2tyQmFzZTU4KS5nZW5lcmF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRvRmxpY2tyKCk7XG4gIH07XG5cbiAgcmV0dXJuIG1ha2VDb252ZXJ0b3I7XG59KSgpO1xuIiwidmFyIGVzcyA9IHJlcXVpcmUoJ2V2ZW50LXNvdXJjZS1zdHJlYW0nKVxudmFyIG5ldHMgPSByZXF1aXJlKCduZXRzJylcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIGFwcCkge1xuICBpZiAoIXVybCkgdGhyb3cgbmV3IEVycm9yKCdzaWduYWxodWIgdXJsIHJlcXVpcmVkJylcbiAgaWYgKCFhcHApIHRocm93IG5ldyBFcnJvcignYXBwIG5hbWUgcmVxdWlyZWQgYXMgMm5kIGFyZ3VtZW50JylcbiAgdmFyIHRoYXQgPSB7fVxuXG4gIGlmICh1cmwuaW5kZXhPZignOi8vJykgPT09IC0xKSB1cmwgPSAnaHR0cDovLycgKyB1cmxcblxuICB0aGF0LnN1YnNjcmliZSA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgcmV0dXJuIGVzcyh1cmwgKyAnL3YxLycgKyBhcHAgKyAnLycgKyBjaGFubmVsLCB7anNvbjogdHJ1ZX0pXG4gIH1cblxuICB0aGF0LmJyb2FkY2FzdCA9IGZ1bmN0aW9uIChjaGFubmVsLCBtZXNzYWdlLCBjYikge1xuICAgIGlmICghY2IpIGNiID0gbm9vcFxuICAgIG5ldHMoe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBqc29uOiBtZXNzYWdlLFxuICAgICAgdXJsOiB1cmwgKyAnL3YxLycgKyBhcHAgKyAnLycgKyBjaGFubmVsXG4gICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlICE9PSAyMDApIHJldHVybiBjYihuZXcgRXJyb3IoJ0JhZCBzdGF0dXM6ICcgKyByZXMuc3RhdHVzQ29kZSkpXG4gICAgICBjYigpXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG4iLCJ2YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICB2YXIgZXMgPSBuZXcgRXZlbnRTb3VyY2UodXJsKVxuICB2YXIgcnMgPSBuZXcgc3RyZWFtLlJlYWRhYmxlKHtvYmplY3RNb2RlOnRydWV9KVxuXG4gIHZhciBqc29uID0gISFvcHRzLmpzb25cbiAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChqc29uKSByZXR1cm4gSlNPTi5wYXJzZShkYXRhKVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBycy5fcmVhZCA9IGZ1bmN0aW9uKCkge31cblxuICBlcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgcnMucHVzaChkZWNvZGUoZS5kYXRhKSlcbiAgfVxuXG4gIGVzLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAocnMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkgcnMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cblxuICB2YXIgZGVzdHJveWVkID0gZmFsc2VcbiAgcnMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVyblxuICAgIGRlc3Ryb3llZCA9IHRydWVcbiAgICBlcy5jbG9zZSgpXG4gICAgcGFyc2UuZW1pdCgnY2xvc2UnKVxuICB9XG5cbiAgcmV0dXJuIHJzXG59IiwidmFyIHJlcSA9IHJlcXVpcmUoJ3JlcXVlc3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5ldHNcblxuZnVuY3Rpb24gTmV0cyAob3B0cywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykgb3B0cyA9IHsgdXJpOiBvcHRzIH1cblxuICAvLyBpbiBub2RlLCBpZiBlbmNvZGluZyA9PT0gbnVsbCB0aGVuIHJlc3BvbnNlIHdpbGwgYmUgYSBCdWZmZXIuIHdlIHdhbnQgdGhpcyB0byBiZSB0aGUgZGVmYXVsdFxuICBpZiAoIW9wdHMuaGFzT3duUHJvcGVydHkoJ2VuY29kaW5nJykpIG9wdHMuZW5jb2RpbmcgPSBudWxsXG5cbiAgLy8gaW4gYnJvd3Nlciwgd2Ugc2hvdWxkIGJ5IGRlZmF1bHQgY29udmVydCB0aGUgYXJyYXlidWZmZXIgaW50byBhIEJ1ZmZlclxuICBpZiAocHJvY2Vzcy5icm93c2VyICYmICFvcHRzLmhhc093blByb3BlcnR5KCdqc29uJykgJiYgb3B0cy5lbmNvZGluZyA9PT0gbnVsbCkge1xuICAgIG9wdHMucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICAgIHZhciBvcmlnaW5hbENiID0gY2JcbiAgICBjYiA9IGJ1ZmZlcmlmeVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyaWZ5IChlcnIsIHJlc3AsIGJvZHkpIHtcbiAgICBpZiAoYm9keSkgYm9keSA9IG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkoYm9keSkpXG4gICAgb3JpZ2luYWxDYihlcnIsIHJlc3AsIGJvZHkpXG4gIH1cblxuICByZXR1cm4gcmVxKG9wdHMsIGNiKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgd2luZG93ID0gcmVxdWlyZShcImdsb2JhbC93aW5kb3dcIilcbnZhciBvbmNlID0gcmVxdWlyZShcIm9uY2VcIilcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKFwicGFyc2UtaGVhZGVyc1wiKVxuXG5cbnZhciBYSFIgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgbm9vcFxudmFyIFhEUiA9IFwid2l0aENyZWRlbnRpYWxzXCIgaW4gKG5ldyBYSFIoKSkgPyBYSFIgOiB3aW5kb3cuWERvbWFpblJlcXVlc3RcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVYSFJcblxuZnVuY3Rpb24gY3JlYXRlWEhSKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBsb2FkRnVuYygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICAvLyBDaHJvbWUgd2l0aCByZXF1ZXN0VHlwZT1ibG9iIHRocm93cyBlcnJvcnMgYXJyb3VuZCB3aGVuIGV2ZW4gdGVzdGluZyBhY2Nlc3MgdG8gcmVzcG9uc2VUZXh0XG4gICAgICAgIHZhciBib2R5ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVxuICAgICAgICB9IGVsc2UgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09IFwidGV4dFwiIHx8ICF4aHIucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlVGV4dCB8fCB4aHIucmVzcG9uc2VYTUxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0pzb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9keVxuICAgIH1cbiAgICBcbiAgICB2YXIgZmFpbHVyZVJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAwLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHVybDogdXJpLFxuICAgICAgICAgICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgICAgICAgICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGVycm9yRnVuYyhldnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgaWYoIShldnQgaW5zdGFuY2VvZiBFcnJvcikpe1xuICAgICAgICAgICAgZXZ0ID0gbmV3IEVycm9yKFwiXCIgKyAoZXZ0IHx8IFwidW5rbm93blwiKSApXG4gICAgICAgIH1cbiAgICAgICAgZXZ0LnN0YXR1c0NvZGUgPSAwXG4gICAgICAgIGNhbGxiYWNrKGV2dCwgZmFpbHVyZVJlc3BvbnNlKVxuICAgIH1cblxuICAgIC8vIHdpbGwgbG9hZCB0aGUgZGF0YSAmIHByb2Nlc3MgdGhlIHJlc3BvbnNlIGluIGEgc3BlY2lhbCByZXNwb25zZSBvYmplY3RcbiAgICBmdW5jdGlvbiBsb2FkRnVuYygpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgXG4gICAgICAgIHZhciBzdGF0dXMgPSAoeGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXMpXG4gICAgICAgIHZhciByZXNwb25zZSA9IGZhaWx1cmVSZXNwb25zZVxuICAgICAgICB2YXIgZXJyID0gbnVsbFxuICAgICAgICBcbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gMCl7XG4gICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiBnZXRCb2R5KCksXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHVybDogdXJpLFxuICAgICAgICAgICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycyl7IC8vcmVtZW1iZXIgeGhyIGNhbiBpbiBmYWN0IGJlIFhEUiBmb3IgQ09SUyBpbiBJRVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKFwiSW50ZXJuYWwgWE1MSHR0cFJlcXVlc3QgRXJyb3JcIilcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCByZXNwb25zZS5ib2R5KVxuICAgICAgICBcbiAgICB9XG4gICAgXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHVyaTogb3B0aW9ucyB9XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjayBhcmd1bWVudCBtaXNzaW5nXCIpXG4gICAgfVxuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaylcblxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociB8fCBudWxsXG5cbiAgICBpZiAoIXhocikge1xuICAgICAgICBpZiAob3B0aW9ucy5jb3JzIHx8IG9wdGlvbnMudXNlWERSKSB7XG4gICAgICAgICAgICB4aHIgPSBuZXcgWERSKClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB4aHIgPSBuZXcgWEhSKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlcbiAgICB2YXIgdXJpID0geGhyLnVybCA9IG9wdGlvbnMudXJpIHx8IG9wdGlvbnMudXJsXG4gICAgdmFyIG1ldGhvZCA9IHhoci5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiXG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5kYXRhXG4gICAgdmFyIGhlYWRlcnMgPSB4aHIuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgIHZhciBzeW5jID0gISFvcHRpb25zLnN5bmNcbiAgICB2YXIgaXNKc29uID0gZmFsc2VcbiAgICB2YXIgdGltZW91dFRpbWVyXG5cbiAgICBpZiAoXCJqc29uXCIgaW4gb3B0aW9ucykge1xuICAgICAgICBpc0pzb24gPSB0cnVlXG4gICAgICAgIGhlYWRlcnNbXCJBY2NlcHRcIl0gfHwgKGhlYWRlcnNbXCJBY2NlcHRcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZVxuICAgIHhoci5vbmxvYWQgPSBsb2FkRnVuY1xuICAgIHhoci5vbmVycm9yID0gZXJyb3JGdW5jXG4gICAgLy8gSUU5IG11c3QgaGF2ZSBvbnByb2dyZXNzIGJlIHNldCB0byBhIHVuaXF1ZSBmdW5jdGlvbi5cbiAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSUUgbXVzdCBkaWVcbiAgICB9XG4gICAgeGhyLm9udGltZW91dCA9IGVycm9yRnVuY1xuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJpLCAhc3luYylcbiAgICAvL2hhcyB0byBiZSBhZnRlciBvcGVuXG4gICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0aW9ucy53aXRoQ3JlZGVudGlhbHNcbiAgICBcbiAgICAvLyBDYW5ub3Qgc2V0IHRpbWVvdXQgd2l0aCBzeW5jIHJlcXVlc3RcbiAgICAvLyBub3Qgc2V0dGluZyB0aW1lb3V0IG9uIHRoZSB4aHIgb2JqZWN0LCBiZWNhdXNlIG9mIG9sZCB3ZWJraXRzIGV0Yy4gbm90IGhhbmRsaW5nIHRoYXQgY29ycmVjdGx5XG4gICAgLy8gYm90aCBucG0ncyByZXF1ZXN0IGFuZCBqcXVlcnkgMS54IHVzZSB0aGlzIGtpbmQgb2YgdGltZW91dCwgc28gdGhpcyBpcyBiZWluZyBjb25zaXN0ZW50XG4gICAgaWYgKCFzeW5jICYmIG9wdGlvbnMudGltZW91dCA+IDAgKSB7XG4gICAgICAgIHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHhoci5hYm9ydChcInRpbWVvdXRcIik7XG4gICAgICAgIH0sIG9wdGlvbnMudGltZW91dCsyICk7XG4gICAgfVxuXG4gICAgaWYgKHhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgIGZvcihrZXkgaW4gaGVhZGVycyl7XG4gICAgICAgICAgICBpZihoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIGFuIFhEb21haW5SZXF1ZXN0IG9iamVjdFwiKVxuICAgIH1cblxuICAgIGlmIChcInJlc3BvbnNlVHlwZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlXG4gICAgfVxuICAgIFxuICAgIGlmIChcImJlZm9yZVNlbmRcIiBpbiBvcHRpb25zICYmIFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTZW5kID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kKHhocilcbiAgICB9XG5cbiAgICB4aHIuc2VuZChib2R5KVxuXG4gICAgcmV0dXJuIHhoclxuXG5cbn1cblxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsImlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgIG1vZHVsZS5leHBvcnRzID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7fTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gb25jZVxuXG5vbmNlLnByb3RvID0gb25jZShmdW5jdGlvbiAoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25jZSh0aGlzKVxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm5cbiAgICBjYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaFxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbmZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzXG4gICAgfVxuICAgIFxuICAgIGlmICh0b1N0cmluZy5jYWxsKGxpc3QpID09PSAnW29iamVjdCBBcnJheV0nKVxuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZSBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxuICAgIGVsc2VcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbn1cblxuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgYXJyYXlbaV0sIGksIGFycmF5KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoU3RyaW5nKHN0cmluZywgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggdGhpbmcgYXMgYSBzcGFyc2Ugc3RyaW5nLlxuICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZylcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hPYmplY3Qob2JqZWN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqZWN0W2tdLCBrLCBvYmplY3QpXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb25cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChmbikge1xuICB2YXIgc3RyaW5nID0gdG9TdHJpbmcuY2FsbChmbilcbiAgcmV0dXJuIHN0cmluZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fFxuICAgICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgc3RyaW5nICE9PSAnW29iamVjdCBSZWdFeHBdJykgfHxcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgLy8gSUU4IGFuZCBiZWxvd1xuICAgICAoZm4gPT09IHdpbmRvdy5zZXRUaW1lb3V0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmFsZXJ0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmNvbmZpcm0gfHxcbiAgICAgIGZuID09PSB3aW5kb3cucHJvbXB0KSlcbn07XG4iLCJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG5cbmV4cG9ydHMubGVmdCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJyk7XG59O1xuXG5leHBvcnRzLnJpZ2h0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn07XG4iLCJ2YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0nKVxuICAsIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpXG4gICwgaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBpZiAoIWhlYWRlcnMpXG4gICAgcmV0dXJuIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgZm9yRWFjaChcbiAgICAgIHRyaW0oaGVhZGVycykuc3BsaXQoJ1xcbicpXG4gICAgLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6JylcbiAgICAgICAgICAsIGtleSA9IHRyaW0ocm93LnNsaWNlKDAsIGluZGV4KSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICwgdmFsdWUgPSB0cmltKHJvdy5zbGljZShpbmRleCArIDEpKVxuXG4gICAgICAgIGlmICh0eXBlb2YocmVzdWx0W2tleV0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBbIHJlc3VsdFtrZXldLCB2YWx1ZSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgKVxuXG4gIHJldHVybiByZXN1bHRcbn0iLCIvKiEgc2ltcGxlLXBlZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc2ltcGxlLXBlZXInKVxuY29uc3QgZ2V0QnJvd3NlclJUQyA9IHJlcXVpcmUoJ2dldC1icm93c2VyLXJ0YycpXG5jb25zdCByYW5kb21ieXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJylcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5jb25zdCBxdWV1ZU1pY3JvdGFzayA9IHJlcXVpcmUoJ3F1ZXVlLW1pY3JvdGFzaycpIC8vIFRPRE86IHJlbW92ZSB3aGVuIE5vZGUgMTAgaXMgbm90IHN1cHBvcnRlZFxuY29uc3QgZXJyQ29kZSA9IHJlcXVpcmUoJ2Vyci1jb2RlJylcbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuXG5jb25zdCBNQVhfQlVGRkVSRURfQU1PVU5UID0gNjQgKiAxMDI0XG5jb25zdCBJQ0VDT01QTEVURV9USU1FT1VUID0gNSAqIDEwMDBcbmNvbnN0IENIQU5ORUxfQ0xPU0lOR19USU1FT1VUID0gNSAqIDEwMDBcblxuLy8gSEFDSzogRmlsdGVyIHRyaWNrbGUgbGluZXMgd2hlbiB0cmlja2xlIGlzIGRpc2FibGVkICMzNTRcbmZ1bmN0aW9uIGZpbHRlclRyaWNrbGUgKHNkcCkge1xuICByZXR1cm4gc2RwLnJlcGxhY2UoL2E9aWNlLW9wdGlvbnM6dHJpY2tsZVxcc1xcbi9nLCAnJylcbn1cblxuZnVuY3Rpb24gd2FybiAobWVzc2FnZSkge1xuICBjb25zb2xlLndhcm4obWVzc2FnZSlcbn1cblxuLyoqXG4gKiBXZWJSVEMgcGVlciBjb25uZWN0aW9uLiBTYW1lIEFQSSBhcyBub2RlIGNvcmUgYG5ldC5Tb2NrZXRgLCBwbHVzIGEgZmV3IGV4dHJhIG1ldGhvZHMuXG4gKiBEdXBsZXggc3RyZWFtLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuY2xhc3MgUGVlciBleHRlbmRzIHN0cmVhbS5EdXBsZXgge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGFsbG93SGFsZk9wZW46IGZhbHNlXG4gICAgfSwgb3B0cylcblxuICAgIHN1cGVyKG9wdHMpXG5cbiAgICB0aGlzLl9pZCA9IHJhbmRvbWJ5dGVzKDQpLnRvU3RyaW5nKCdoZXgnKS5zbGljZSgwLCA3KVxuICAgIHRoaXMuX2RlYnVnKCduZXcgcGVlciAlbycsIG9wdHMpXG5cbiAgICB0aGlzLmNoYW5uZWxOYW1lID0gb3B0cy5pbml0aWF0b3JcbiAgICAgID8gb3B0cy5jaGFubmVsTmFtZSB8fCByYW5kb21ieXRlcygyMCkudG9TdHJpbmcoJ2hleCcpXG4gICAgICA6IG51bGxcblxuICAgIHRoaXMuaW5pdGlhdG9yID0gb3B0cy5pbml0aWF0b3IgfHwgZmFsc2VcbiAgICB0aGlzLmNoYW5uZWxDb25maWcgPSBvcHRzLmNoYW5uZWxDb25maWcgfHwgUGVlci5jaGFubmVsQ29uZmlnXG4gICAgdGhpcy5jaGFubmVsTmVnb3RpYXRlZCA9IHRoaXMuY2hhbm5lbENvbmZpZy5uZWdvdGlhdGVkXG4gICAgdGhpcy5jb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBQZWVyLmNvbmZpZywgb3B0cy5jb25maWcpXG4gICAgdGhpcy5vZmZlck9wdGlvbnMgPSBvcHRzLm9mZmVyT3B0aW9ucyB8fCB7fVxuICAgIHRoaXMuYW5zd2VyT3B0aW9ucyA9IG9wdHMuYW5zd2VyT3B0aW9ucyB8fCB7fVxuICAgIHRoaXMuc2RwVHJhbnNmb3JtID0gb3B0cy5zZHBUcmFuc2Zvcm0gfHwgKHNkcCA9PiBzZHApXG4gICAgdGhpcy5zdHJlYW1zID0gb3B0cy5zdHJlYW1zIHx8IChvcHRzLnN0cmVhbSA/IFtvcHRzLnN0cmVhbV0gOiBbXSkgLy8gc3VwcG9ydCBvbGQgXCJzdHJlYW1cIiBvcHRpb25cbiAgICB0aGlzLnRyaWNrbGUgPSBvcHRzLnRyaWNrbGUgIT09IHVuZGVmaW5lZCA/IG9wdHMudHJpY2tsZSA6IHRydWVcbiAgICB0aGlzLmFsbG93SGFsZlRyaWNrbGUgPSBvcHRzLmFsbG93SGFsZlRyaWNrbGUgIT09IHVuZGVmaW5lZCA/IG9wdHMuYWxsb3dIYWxmVHJpY2tsZSA6IGZhbHNlXG4gICAgdGhpcy5pY2VDb21wbGV0ZVRpbWVvdXQgPSBvcHRzLmljZUNvbXBsZXRlVGltZW91dCB8fCBJQ0VDT01QTEVURV9USU1FT1VUXG5cbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG4gICAgdGhpcy5kZXN0cm95aW5nID0gZmFsc2VcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZVxuXG4gICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gdW5kZWZpbmVkXG4gICAgdGhpcy5yZW1vdGVGYW1pbHkgPSB1bmRlZmluZWRcbiAgICB0aGlzLnJlbW90ZVBvcnQgPSB1bmRlZmluZWRcbiAgICB0aGlzLmxvY2FsQWRkcmVzcyA9IHVuZGVmaW5lZFxuICAgIHRoaXMubG9jYWxGYW1pbHkgPSB1bmRlZmluZWRcbiAgICB0aGlzLmxvY2FsUG9ydCA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5fd3J0YyA9IChvcHRzLndydGMgJiYgdHlwZW9mIG9wdHMud3J0YyA9PT0gJ29iamVjdCcpXG4gICAgICA/IG9wdHMud3J0Y1xuICAgICAgOiBnZXRCcm93c2VyUlRDKClcblxuICAgIGlmICghdGhpcy5fd3J0Yykge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdObyBXZWJSVEMgc3VwcG9ydDogU3BlY2lmeSBgb3B0cy53cnRjYCBvcHRpb24gaW4gdGhpcyBlbnZpcm9ubWVudCcpLCAnRVJSX1dFQlJUQ19TVVBQT1JUJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdObyBXZWJSVEMgc3VwcG9ydDogTm90IGEgc3VwcG9ydGVkIGJyb3dzZXInKSwgJ0VSUl9XRUJSVENfU1VQUE9SVCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcGNSZWFkeSA9IGZhbHNlXG4gICAgdGhpcy5fY2hhbm5lbFJlYWR5ID0gZmFsc2VcbiAgICB0aGlzLl9pY2VDb21wbGV0ZSA9IGZhbHNlIC8vIGljZSBjYW5kaWRhdGUgdHJpY2tsZSBkb25lIChnb3QgbnVsbCBjYW5kaWRhdGUpXG4gICAgdGhpcy5faWNlQ29tcGxldGVUaW1lciA9IG51bGwgLy8gc2VuZCBhbiBvZmZlci9hbnN3ZXIgYW55d2F5IGFmdGVyIHNvbWUgdGltZW91dFxuICAgIHRoaXMuX2NoYW5uZWwgPSBudWxsXG4gICAgdGhpcy5fcGVuZGluZ0NhbmRpZGF0ZXMgPSBbXVxuXG4gICAgdGhpcy5faXNOZWdvdGlhdGluZyA9IGZhbHNlIC8vIGlzIHRoaXMgcGVlciB3YWl0aW5nIGZvciBuZWdvdGlhdGlvbiB0byBjb21wbGV0ZT9cbiAgICB0aGlzLl9maXJzdE5lZ290aWF0aW9uID0gdHJ1ZVxuICAgIHRoaXMuX2JhdGNoZWROZWdvdGlhdGlvbiA9IGZhbHNlIC8vIGJhdGNoIHN5bmNocm9ub3VzIG5lZ290aWF0aW9uc1xuICAgIHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uID0gZmFsc2UgLy8gaXMgdGhlcmUgYSBxdWV1ZWQgbmVnb3RpYXRpb24gcmVxdWVzdD9cbiAgICB0aGlzLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUgPSBbXVxuICAgIHRoaXMuX3NlbmRlck1hcCA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX2Nsb3NpbmdJbnRlcnZhbCA9IG51bGxcblxuICAgIHRoaXMuX3JlbW90ZVRyYWNrcyA9IFtdXG4gICAgdGhpcy5fcmVtb3RlU3RyZWFtcyA9IFtdXG5cbiAgICB0aGlzLl9jaHVuayA9IG51bGxcbiAgICB0aGlzLl9jYiA9IG51bGxcbiAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGxcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9wYyA9IG5ldyAodGhpcy5fd3J0Yy5SVENQZWVyQ29ubmVjdGlvbikodGhpcy5jb25maWcpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfUENfQ09OU1RSVUNUT1InKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFdlIHByZWZlciBmZWF0dXJlIGRldGVjdGlvbiB3aGVuZXZlciBwb3NzaWJsZSwgYnV0IHNvbWV0aW1lcyB0aGF0J3Mgbm90XG4gICAgLy8gcG9zc2libGUgZm9yIGNlcnRhaW4gaW1wbGVtZW50YXRpb25zLlxuICAgIHRoaXMuX2lzUmVhY3ROYXRpdmVXZWJydGMgPSB0eXBlb2YgdGhpcy5fcGMuX3BlZXJDb25uZWN0aW9uSWQgPT09ICdudW1iZXInXG5cbiAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uSWNlU3RhdGVDaGFuZ2UoKVxuICAgIH1cbiAgICB0aGlzLl9wYy5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25JY2VTdGF0ZUNoYW5nZSgpXG4gICAgfVxuICAgIHRoaXMuX3BjLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2UoKVxuICAgIH1cbiAgICB0aGlzLl9wYy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25TaWduYWxpbmdTdGF0ZUNoYW5nZSgpXG4gICAgfVxuICAgIHRoaXMuX3BjLm9uaWNlY2FuZGlkYXRlID0gZXZlbnQgPT4ge1xuICAgICAgdGhpcy5fb25JY2VDYW5kaWRhdGUoZXZlbnQpXG4gICAgfVxuXG4gICAgLy8gSEFDSzogRml4IGZvciBvZGQgRmlyZWZveCBiZWhhdmlvciwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL3NpbXBsZS1wZWVyL3B1bGwvNzgzXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9wYy5wZWVySWRlbnRpdHkgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLl9wYy5wZWVySWRlbnRpdHkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX1BDX1BFRVJfSURFTlRJVFknKSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gT3RoZXIgc3BlYyBldmVudHMsIHVudXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uOlxuICAgIC8vIC0gb25jb25uZWN0aW9uc3RhdGVjaGFuZ2VcbiAgICAvLyAtIG9uaWNlY2FuZGlkYXRlZXJyb3JcbiAgICAvLyAtIG9uZmluZ2VycHJpbnRmYWlsdXJlXG4gICAgLy8gLSBvbm5lZ290aWF0aW9ubmVlZGVkXG5cbiAgICBpZiAodGhpcy5pbml0aWF0b3IgfHwgdGhpcy5jaGFubmVsTmVnb3RpYXRlZCkge1xuICAgICAgdGhpcy5fc2V0dXBEYXRhKHtcbiAgICAgICAgY2hhbm5lbDogdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwodGhpcy5jaGFubmVsTmFtZSwgdGhpcy5jaGFubmVsQ29uZmlnKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGMub25kYXRhY2hhbm5lbCA9IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fc2V0dXBEYXRhKGV2ZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cmVhbXMpIHtcbiAgICAgIHRoaXMuc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiB7XG4gICAgICAgIHRoaXMuYWRkU3RyZWFtKHN0cmVhbSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMuX3BjLm9udHJhY2sgPSBldmVudCA9PiB7XG4gICAgICB0aGlzLl9vblRyYWNrKGV2ZW50KVxuICAgIH1cblxuICAgIHRoaXMuX2RlYnVnKCdpbml0aWFsIG5lZ290aWF0aW9uJylcbiAgICB0aGlzLl9uZWVkc05lZ290aWF0aW9uKClcblxuICAgIHRoaXMuX29uRmluaXNoQm91bmQgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkZpbmlzaCgpXG4gICAgfVxuICAgIHRoaXMub25jZSgnZmluaXNoJywgdGhpcy5fb25GaW5pc2hCb3VuZClcbiAgfVxuXG4gIGdldCBidWZmZXJTaXplICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2NoYW5uZWwgJiYgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudCkgfHwgMFxuICB9XG5cbiAgLy8gSEFDSzogaXQncyBwb3NzaWJsZSBjaGFubmVsLnJlYWR5U3RhdGUgaXMgXCJjbG9zaW5nXCIgYmVmb3JlIHBlZXIuZGVzdHJveSgpIGZpcmVzXG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTg4Mjc0M1xuICBnZXQgY29ubmVjdGVkICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2Nvbm5lY3RlZCAmJiB0aGlzLl9jaGFubmVsLnJlYWR5U3RhdGUgPT09ICdvcGVuJylcbiAgfVxuXG4gIGFkZHJlc3MgKCkge1xuICAgIHJldHVybiB7IHBvcnQ6IHRoaXMubG9jYWxQb3J0LCBmYW1pbHk6IHRoaXMubG9jYWxGYW1pbHksIGFkZHJlc3M6IHRoaXMubG9jYWxBZGRyZXNzIH1cbiAgfVxuXG4gIHNpZ25hbCAoZGF0YSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCBzaWduYWwgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgZGF0YSA9IHt9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RlYnVnKCdzaWduYWwoKScpXG5cbiAgICBpZiAoZGF0YS5yZW5lZ290aWF0ZSAmJiB0aGlzLmluaXRpYXRvcikge1xuICAgICAgdGhpcy5fZGVidWcoJ2dvdCByZXF1ZXN0IHRvIHJlbmVnb3RpYXRlJylcbiAgICAgIHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKVxuICAgIH1cbiAgICBpZiAoZGF0YS50cmFuc2NlaXZlclJlcXVlc3QgJiYgdGhpcy5pbml0aWF0b3IpIHtcbiAgICAgIHRoaXMuX2RlYnVnKCdnb3QgcmVxdWVzdCBmb3IgdHJhbnNjZWl2ZXInKVxuICAgICAgdGhpcy5hZGRUcmFuc2NlaXZlcihkYXRhLnRyYW5zY2VpdmVyUmVxdWVzdC5raW5kLCBkYXRhLnRyYW5zY2VpdmVyUmVxdWVzdC5pbml0KVxuICAgIH1cbiAgICBpZiAoZGF0YS5jYW5kaWRhdGUpIHtcbiAgICAgIGlmICh0aGlzLl9wYy5yZW1vdGVEZXNjcmlwdGlvbiAmJiB0aGlzLl9wYy5yZW1vdGVEZXNjcmlwdGlvbi50eXBlKSB7XG4gICAgICAgIHRoaXMuX2FkZEljZUNhbmRpZGF0ZShkYXRhLmNhbmRpZGF0ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDYW5kaWRhdGVzLnB1c2goZGF0YS5jYW5kaWRhdGUpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLnNkcCkge1xuICAgICAgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24obmV3ICh0aGlzLl93cnRjLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoZGF0YSkpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgICAgICAgdGhpcy5fcGVuZGluZ0NhbmRpZGF0ZXMuZm9yRWFjaChjYW5kaWRhdGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIHRoaXMuX3BlbmRpbmdDYW5kaWRhdGVzID0gW11cblxuICAgICAgICAgIGlmICh0aGlzLl9wYy5yZW1vdGVEZXNjcmlwdGlvbi50eXBlID09PSAnb2ZmZXInKSB0aGlzLl9jcmVhdGVBbnN3ZXIoKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfU0VUX1JFTU9URV9ERVNDUklQVElPTicpKVxuICAgICAgICB9KVxuICAgIH1cbiAgICBpZiAoIWRhdGEuc2RwICYmICFkYXRhLmNhbmRpZGF0ZSAmJiAhZGF0YS5yZW5lZ290aWF0ZSAmJiAhZGF0YS50cmFuc2NlaXZlclJlcXVlc3QpIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKG5ldyBFcnJvcignc2lnbmFsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBzaWduYWwgZGF0YScpLCAnRVJSX1NJR05BTElORycpKVxuICAgIH1cbiAgfVxuXG4gIF9hZGRJY2VDYW5kaWRhdGUgKGNhbmRpZGF0ZSkge1xuICAgIGNvbnN0IGljZUNhbmRpZGF0ZU9iaiA9IG5ldyB0aGlzLl93cnRjLlJUQ0ljZUNhbmRpZGF0ZShjYW5kaWRhdGUpXG4gICAgdGhpcy5fcGMuYWRkSWNlQ2FuZGlkYXRlKGljZUNhbmRpZGF0ZU9iailcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpZiAoIWljZUNhbmRpZGF0ZU9iai5hZGRyZXNzIHx8IGljZUNhbmRpZGF0ZU9iai5hZGRyZXNzLmVuZHNXaXRoKCcubG9jYWwnKSkge1xuICAgICAgICAgIHdhcm4oJ0lnbm9yaW5nIHVuc3VwcG9ydGVkIElDRSBjYW5kaWRhdGUuJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfQUREX0lDRV9DQU5ESURBVEUnKSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIHRleHQvYmluYXJ5IGRhdGEgdG8gdGhlIHJlbW90ZSBwZWVyLlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld3xBcnJheUJ1ZmZlcnxCdWZmZXJ8c3RyaW5nfEJsb2J9IGNodW5rXG4gICAqL1xuICBzZW5kIChjaHVuaykge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCBzZW5kIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICB0aGlzLl9jaGFubmVsLnNlbmQoY2h1bmspXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgVHJhbnNjZWl2ZXIgdG8gdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBraW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbml0XG4gICAqL1xuICBhZGRUcmFuc2NlaXZlciAoa2luZCwgaW5pdCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCBhZGRUcmFuc2NlaXZlciBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgdGhpcy5fZGVidWcoJ2FkZFRyYW5zY2VpdmVyKCknKVxuXG4gICAgaWYgKHRoaXMuaW5pdGlhdG9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9wYy5hZGRUcmFuc2NlaXZlcihraW5kLCBpbml0KVxuICAgICAgICB0aGlzLl9uZWVkc05lZ290aWF0aW9uKClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfQUREX1RSQU5TQ0VJVkVSJykpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdCgnc2lnbmFsJywgeyAvLyByZXF1ZXN0IGluaXRpYXRvciB0byByZW5lZ290aWF0ZVxuICAgICAgICB0eXBlOiAndHJhbnNjZWl2ZXJSZXF1ZXN0JyxcbiAgICAgICAgdHJhbnNjZWl2ZXJSZXF1ZXN0OiB7IGtpbmQsIGluaXQgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgTWVkaWFTdHJlYW0gdG8gdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbVxuICAgKi9cbiAgYWRkU3RyZWFtIChzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgYWRkU3RyZWFtIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICB0aGlzLl9kZWJ1ZygnYWRkU3RyZWFtKCknKVxuXG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgdGhpcy5hZGRUcmFjayh0cmFjaywgc3RyZWFtKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgTWVkaWFTdHJlYW1UcmFjayB0byB0aGUgY29ubmVjdGlvbi5cbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbVRyYWNrfSB0cmFja1xuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAgICovXG4gIGFkZFRyYWNrICh0cmFjaywgc3RyZWFtKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IGFkZFRyYWNrIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICB0aGlzLl9kZWJ1ZygnYWRkVHJhY2soKScpXG5cbiAgICBjb25zdCBzdWJtYXAgPSB0aGlzLl9zZW5kZXJNYXAuZ2V0KHRyYWNrKSB8fCBuZXcgTWFwKCkgLy8gbmVzdGVkIE1hcHMgbWFwIFt0cmFjaywgc3RyZWFtXSB0byBzZW5kZXJcbiAgICBsZXQgc2VuZGVyID0gc3VibWFwLmdldChzdHJlYW0pXG4gICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgIHNlbmRlciA9IHRoaXMuX3BjLmFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pXG4gICAgICBzdWJtYXAuc2V0KHN0cmVhbSwgc2VuZGVyKVxuICAgICAgdGhpcy5fc2VuZGVyTWFwLnNldCh0cmFjaywgc3VibWFwKVxuICAgICAgdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpXG4gICAgfSBlbHNlIGlmIChzZW5kZXIucmVtb3ZlZCkge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ1RyYWNrIGhhcyBiZWVuIHJlbW92ZWQuIFlvdSBzaG91bGQgZW5hYmxlL2Rpc2FibGUgdHJhY2tzIHRoYXQgeW91IHdhbnQgdG8gcmUtYWRkLicpLCAnRVJSX1NFTkRFUl9SRU1PVkVEJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ1RyYWNrIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gdGhhdCBzdHJlYW0uJyksICdFUlJfU0VOREVSX0FMUkVBRFlfQURERUQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIGEgTWVkaWFTdHJlYW1UcmFjayBieSBhbm90aGVyIGluIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtVHJhY2t9IG9sZFRyYWNrXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gbmV3VHJhY2tcbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gICAqL1xuICByZXBsYWNlVHJhY2sgKG9sZFRyYWNrLCBuZXdUcmFjaywgc3RyZWFtKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWluZykgcmV0dXJuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IHJlcGxhY2VUcmFjayBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgdGhpcy5fZGVidWcoJ3JlcGxhY2VUcmFjaygpJylcblxuICAgIGNvbnN0IHN1Ym1hcCA9IHRoaXMuX3NlbmRlck1hcC5nZXQob2xkVHJhY2spXG4gICAgY29uc3Qgc2VuZGVyID0gc3VibWFwID8gc3VibWFwLmdldChzdHJlYW0pIDogbnVsbFxuICAgIGlmICghc2VuZGVyKSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignQ2Fubm90IHJlcGxhY2UgdHJhY2sgdGhhdCB3YXMgbmV2ZXIgYWRkZWQuJyksICdFUlJfVFJBQ0tfTk9UX0FEREVEJylcbiAgICB9XG4gICAgaWYgKG5ld1RyYWNrKSB0aGlzLl9zZW5kZXJNYXAuc2V0KG5ld1RyYWNrLCBzdWJtYXApXG5cbiAgICBpZiAoc2VuZGVyLnJlcGxhY2VUcmFjayAhPSBudWxsKSB7XG4gICAgICBzZW5kZXIucmVwbGFjZVRyYWNrKG5ld1RyYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShuZXcgRXJyb3IoJ3JlcGxhY2VUcmFjayBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpLCAnRVJSX1VOU1VQUE9SVEVEX1JFUExBQ0VUUkFDSycpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBNZWRpYVN0cmVhbVRyYWNrIGZyb20gdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1UcmFja30gdHJhY2tcbiAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gICAqL1xuICByZW1vdmVUcmFjayAodHJhY2ssIHN0cmVhbSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCByZW1vdmVUcmFjayBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZCcpLCAnRVJSX0RFU1RST1lFRCcpXG4gICAgdGhpcy5fZGVidWcoJ3JlbW92ZVNlbmRlcigpJylcblxuICAgIGNvbnN0IHN1Ym1hcCA9IHRoaXMuX3NlbmRlck1hcC5nZXQodHJhY2spXG4gICAgY29uc3Qgc2VuZGVyID0gc3VibWFwID8gc3VibWFwLmdldChzdHJlYW0pIDogbnVsbFxuICAgIGlmICghc2VuZGVyKSB7XG4gICAgICB0aHJvdyBlcnJDb2RlKG5ldyBFcnJvcignQ2Fubm90IHJlbW92ZSB0cmFjayB0aGF0IHdhcyBuZXZlciBhZGRlZC4nKSwgJ0VSUl9UUkFDS19OT1RfQURERUQnKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgc2VuZGVyLnJlbW92ZWQgPSB0cnVlXG4gICAgICB0aGlzLl9wYy5yZW1vdmVUcmFjayhzZW5kZXIpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLm5hbWUgPT09ICdOU19FUlJPUl9VTkVYUEVDVEVEJykge1xuICAgICAgICB0aGlzLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUucHVzaChzZW5kZXIpIC8vIEhBQ0s6IEZpcmVmb3ggbXVzdCB3YWl0IHVudGlsIChzaWduYWxpbmdTdGF0ZSA9PT0gc3RhYmxlKSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTMzODc0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfUkVNT1ZFX1RSQUNLJykpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIE1lZGlhU3RyZWFtIGZyb20gdGhlIGNvbm5lY3Rpb24uXG4gICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IHN0cmVhbVxuICAgKi9cbiAgcmVtb3ZlU3RyZWFtIChzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5kZXN0cm95aW5nKSByZXR1cm5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IGVyckNvZGUobmV3IEVycm9yKCdjYW5ub3QgcmVtb3ZlU3RyZWFtIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREVTVFJPWUVEJylcbiAgICB0aGlzLl9kZWJ1ZygncmVtb3ZlU2VuZGVycygpJylcblxuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlVHJhY2sodHJhY2ssIHN0cmVhbSlcbiAgICB9KVxuICB9XG5cbiAgX25lZWRzTmVnb3RpYXRpb24gKCkge1xuICAgIHRoaXMuX2RlYnVnKCdfbmVlZHNOZWdvdGlhdGlvbicpXG4gICAgaWYgKHRoaXMuX2JhdGNoZWROZWdvdGlhdGlvbikgcmV0dXJuIC8vIGJhdGNoIHN5bmNocm9ub3VzIHJlbmVnb3RpYXRpb25zXG4gICAgdGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9uID0gdHJ1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIHRoaXMuX2JhdGNoZWROZWdvdGlhdGlvbiA9IGZhbHNlXG4gICAgICBpZiAodGhpcy5pbml0aWF0b3IgfHwgIXRoaXMuX2ZpcnN0TmVnb3RpYXRpb24pIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3N0YXJ0aW5nIGJhdGNoZWQgbmVnb3RpYXRpb24nKVxuICAgICAgICB0aGlzLm5lZ290aWF0ZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kZWJ1Zygnbm9uLWluaXRpYXRvciBpbml0aWFsIG5lZ290aWF0aW9uIHJlcXVlc3QgZGlzY2FyZGVkJylcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZpcnN0TmVnb3RpYXRpb24gPSBmYWxzZVxuICAgIH0pXG4gIH1cblxuICBuZWdvdGlhdGUgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgdGhyb3cgZXJyQ29kZShuZXcgRXJyb3IoJ2Nhbm5vdCBuZWdvdGlhdGUgYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWQnKSwgJ0VSUl9ERVNUUk9ZRUQnKVxuXG4gICAgaWYgKHRoaXMuaW5pdGlhdG9yKSB7XG4gICAgICBpZiAodGhpcy5faXNOZWdvdGlhdGluZykge1xuICAgICAgICB0aGlzLl9xdWV1ZWROZWdvdGlhdGlvbiA9IHRydWVcbiAgICAgICAgdGhpcy5fZGVidWcoJ2FscmVhZHkgbmVnb3RpYXRpbmcsIHF1ZXVlaW5nJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdzdGFydCBuZWdvdGlhdGlvbicpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyAvLyBIQUNLOiBDaHJvbWUgY3Jhc2hlcyBpZiB3ZSBpbW1lZGlhdGVseSBjYWxsIGNyZWF0ZU9mZmVyXG4gICAgICAgICAgdGhpcy5fY3JlYXRlT2ZmZXIoKVxuICAgICAgICB9LCAwKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5faXNOZWdvdGlhdGluZykge1xuICAgICAgICB0aGlzLl9xdWV1ZWROZWdvdGlhdGlvbiA9IHRydWVcbiAgICAgICAgdGhpcy5fZGVidWcoJ2FscmVhZHkgbmVnb3RpYXRpbmcsIHF1ZXVlaW5nJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdyZXF1ZXN0aW5nIG5lZ290aWF0aW9uIGZyb20gaW5pdGlhdG9yJylcbiAgICAgICAgdGhpcy5lbWl0KCdzaWduYWwnLCB7IC8vIHJlcXVlc3QgaW5pdGlhdG9yIHRvIHJlbmVnb3RpYXRlXG4gICAgICAgICAgdHlwZTogJ3JlbmVnb3RpYXRlJyxcbiAgICAgICAgICByZW5lZ290aWF0ZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pc05lZ290aWF0aW5nID0gdHJ1ZVxuICB9XG5cbiAgLy8gVE9ETzogRGVsZXRlIHRoaXMgbWV0aG9kIG9uY2UgcmVhZGFibGUtc3RyZWFtIGlzIHVwZGF0ZWQgdG8gY29udGFpbiBhIGRlZmF1bHRcbiAgLy8gaW1wbGVtZW50YXRpb24gb2YgZGVzdHJveSgpIHRoYXQgYXV0b21hdGljYWxseSBjYWxscyBfZGVzdHJveSgpXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9yZWFkYWJsZS1zdHJlYW0vaXNzdWVzLzI4M1xuICBkZXN0cm95IChlcnIpIHtcbiAgICB0aGlzLl9kZXN0cm95KGVyciwgKCkgPT4ge30pXG4gIH1cblxuICBfZGVzdHJveSAoZXJyLCBjYikge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCB8fCB0aGlzLmRlc3Ryb3lpbmcpIHJldHVyblxuICAgIHRoaXMuZGVzdHJveWluZyA9IHRydWVcblxuICAgIHRoaXMuX2RlYnVnKCdkZXN0cm95aW5nIChlcnJvcjogJXMpJywgZXJyICYmIChlcnIubWVzc2FnZSB8fCBlcnIpKVxuXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4geyAvLyBhbGxvdyBldmVudHMgY29uY3VycmVudCB3aXRoIHRoZSBjYWxsIHRvIF9kZXN0cm95KCkgdG8gZmlyZSAoc2VlICM2OTIpXG4gICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWVcbiAgICAgIHRoaXMuZGVzdHJveWluZyA9IGZhbHNlXG5cbiAgICAgIHRoaXMuX2RlYnVnKCdkZXN0cm95IChlcnJvcjogJXMpJywgZXJyICYmIChlcnIubWVzc2FnZSB8fCBlcnIpKVxuXG4gICAgICB0aGlzLnJlYWRhYmxlID0gdGhpcy53cml0YWJsZSA9IGZhbHNlXG5cbiAgICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgdGhpcy5wdXNoKG51bGwpXG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHRoaXMuZW5kKClcblxuICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2VcbiAgICAgIHRoaXMuX3BjUmVhZHkgPSBmYWxzZVxuICAgICAgdGhpcy5fY2hhbm5lbFJlYWR5ID0gZmFsc2VcbiAgICAgIHRoaXMuX3JlbW90ZVRyYWNrcyA9IG51bGxcbiAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMgPSBudWxsXG4gICAgICB0aGlzLl9zZW5kZXJNYXAgPSBudWxsXG5cbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2xvc2luZ0ludGVydmFsKVxuICAgICAgdGhpcy5fY2xvc2luZ0ludGVydmFsID0gbnVsbFxuXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKVxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsXG4gICAgICB0aGlzLl9jaHVuayA9IG51bGxcbiAgICAgIHRoaXMuX2NiID0gbnVsbFxuXG4gICAgICBpZiAodGhpcy5fb25GaW5pc2hCb3VuZCkgdGhpcy5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgdGhpcy5fb25GaW5pc2hCb3VuZClcbiAgICAgIHRoaXMuX29uRmluaXNoQm91bmQgPSBudWxsXG5cbiAgICAgIGlmICh0aGlzLl9jaGFubmVsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5fY2hhbm5lbC5jbG9zZSgpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgICAgICAvLyBhbGxvdyBldmVudHMgY29uY3VycmVudCB3aXRoIGRlc3RydWN0aW9uIHRvIGJlIGhhbmRsZWRcbiAgICAgICAgdGhpcy5fY2hhbm5lbC5vbm1lc3NhZ2UgPSBudWxsXG4gICAgICAgIHRoaXMuX2NoYW5uZWwub25vcGVuID0gbnVsbFxuICAgICAgICB0aGlzLl9jaGFubmVsLm9uY2xvc2UgPSBudWxsXG4gICAgICAgIHRoaXMuX2NoYW5uZWwub25lcnJvciA9IG51bGxcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuX3BjLmNsb3NlKClcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgICAgIC8vIGFsbG93IGV2ZW50cyBjb25jdXJyZW50IHdpdGggZGVzdHJ1Y3Rpb24gdG8gYmUgaGFuZGxlZFxuICAgICAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGxcbiAgICAgICAgdGhpcy5fcGMub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9IG51bGxcbiAgICAgICAgdGhpcy5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IG51bGxcbiAgICAgICAgdGhpcy5fcGMub25pY2VjYW5kaWRhdGUgPSBudWxsXG4gICAgICAgIHRoaXMuX3BjLm9udHJhY2sgPSBudWxsXG4gICAgICAgIHRoaXMuX3BjLm9uZGF0YWNoYW5uZWwgPSBudWxsXG4gICAgICB9XG4gICAgICB0aGlzLl9wYyA9IG51bGxcbiAgICAgIHRoaXMuX2NoYW5uZWwgPSBudWxsXG5cbiAgICAgIGlmIChlcnIpIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICAgIGNiKClcbiAgICB9KVxuICB9XG5cbiAgX3NldHVwRGF0YSAoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmNoYW5uZWwpIHtcbiAgICAgIC8vIEluIHNvbWUgc2l0dWF0aW9ucyBgcGMuY3JlYXRlRGF0YUNoYW5uZWwoKWAgcmV0dXJucyBgdW5kZWZpbmVkYCAoaW4gd3J0YyksXG4gICAgICAvLyB3aGljaCBpcyBpbnZhbGlkIGJlaGF2aW9yLiBIYW5kbGUgaXQgZ3JhY2VmdWxseS5cbiAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9zaW1wbGUtcGVlci9pc3N1ZXMvMTYzXG4gICAgICByZXR1cm4gdGhpcy5kZXN0cm95KGVyckNvZGUobmV3IEVycm9yKCdEYXRhIGNoYW5uZWwgZXZlbnQgaXMgbWlzc2luZyBgY2hhbm5lbGAgcHJvcGVydHknKSwgJ0VSUl9EQVRBX0NIQU5ORUwnKSlcbiAgICB9XG5cbiAgICB0aGlzLl9jaGFubmVsID0gZXZlbnQuY2hhbm5lbFxuICAgIHRoaXMuX2NoYW5uZWwuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcblxuICAgIGlmICh0eXBlb2YgdGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPSBNQVhfQlVGRkVSRURfQU1PVU5UXG4gICAgfVxuXG4gICAgdGhpcy5jaGFubmVsTmFtZSA9IHRoaXMuX2NoYW5uZWwubGFiZWxcblxuICAgIHRoaXMuX2NoYW5uZWwub25tZXNzYWdlID0gZXZlbnQgPT4ge1xuICAgICAgdGhpcy5fb25DaGFubmVsTWVzc2FnZShldmVudClcbiAgICB9XG4gICAgdGhpcy5fY2hhbm5lbC5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gKCkgPT4ge1xuICAgICAgdGhpcy5fb25DaGFubmVsQnVmZmVyZWRBbW91bnRMb3coKVxuICAgIH1cbiAgICB0aGlzLl9jaGFubmVsLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIHRoaXMuX29uQ2hhbm5lbE9wZW4oKVxuICAgIH1cbiAgICB0aGlzLl9jaGFubmVsLm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9vbkNoYW5uZWxDbG9zZSgpXG4gICAgfVxuICAgIHRoaXMuX2NoYW5uZWwub25lcnJvciA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IGV2ZW50LmVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgPyBldmVudC5lcnJvclxuICAgICAgICA6IG5ldyBFcnJvcihgRGF0YWNoYW5uZWwgZXJyb3I6ICR7ZXZlbnQubWVzc2FnZX0gJHtldmVudC5maWxlbmFtZX06JHtldmVudC5saW5lbm99OiR7ZXZlbnQuY29sbm99YClcbiAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9EQVRBX0NIQU5ORUwnKSlcbiAgICB9XG5cbiAgICAvLyBIQUNLOiBDaHJvbWUgd2lsbCBzb21ldGltZXMgZ2V0IHN0dWNrIGluIHJlYWR5U3RhdGUgXCJjbG9zaW5nXCIsIGxldCdzIGNoZWNrIGZvciB0aGlzIGNvbmRpdGlvblxuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTg4Mjc0M1xuICAgIGxldCBpc0Nsb3NpbmcgPSBmYWxzZVxuICAgIHRoaXMuX2Nsb3NpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHsgLy8gTm8gXCJvbmNsb3NpbmdcIiBldmVudFxuICAgICAgaWYgKHRoaXMuX2NoYW5uZWwgJiYgdGhpcy5fY2hhbm5lbC5yZWFkeVN0YXRlID09PSAnY2xvc2luZycpIHtcbiAgICAgICAgaWYgKGlzQ2xvc2luZykgdGhpcy5fb25DaGFubmVsQ2xvc2UoKSAvLyBjbG9zaW5nIHRpbWVkIG91dDogZXF1aXZhbGVudCB0byBvbmNsb3NlIGZpcmluZ1xuICAgICAgICBpc0Nsb3NpbmcgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0Nsb3NpbmcgPSBmYWxzZVxuICAgICAgfVxuICAgIH0sIENIQU5ORUxfQ0xPU0lOR19USU1FT1VUKVxuICB9XG5cbiAgX3JlYWQgKCkge31cblxuICBfd3JpdGUgKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVybiBjYihlcnJDb2RlKG5ldyBFcnJvcignY2Fubm90IHdyaXRlIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkJyksICdFUlJfREFUQV9DSEFOTkVMJykpXG5cbiAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNlbmQoY2h1bmspXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9EQVRBX0NIQU5ORUwnKSlcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50ID4gTUFYX0JVRkZFUkVEX0FNT1VOVCkge1xuICAgICAgICB0aGlzLl9kZWJ1Zygnc3RhcnQgYmFja3ByZXNzdXJlOiBidWZmZXJlZEFtb3VudCAlZCcsIHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQpXG4gICAgICAgIHRoaXMuX2NiID0gY2JcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKG51bGwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RlYnVnKCd3cml0ZSBiZWZvcmUgY29ubmVjdCcpXG4gICAgICB0aGlzLl9jaHVuayA9IGNodW5rXG4gICAgICB0aGlzLl9jYiA9IGNiXG4gICAgfVxuICB9XG5cbiAgLy8gV2hlbiBzdHJlYW0gZmluaXNoZXMgd3JpdGluZywgY2xvc2Ugc29ja2V0LiBIYWxmIG9wZW4gY29ubmVjdGlvbnMgYXJlIG5vdFxuICAvLyBzdXBwb3J0ZWQuXG4gIF9vbkZpbmlzaCAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgIC8vIFdhaXQgYSBiaXQgYmVmb3JlIGRlc3Ryb3lpbmcgc28gdGhlIHNvY2tldCBmbHVzaGVzLlxuICAgIC8vIFRPRE86IGlzIHRoZXJlIGEgbW9yZSByZWxpYWJsZSB3YXkgdG8gYWNjb21wbGlzaCB0aGlzP1xuICAgIGNvbnN0IGRlc3Ryb3lTb29uID0gKCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmRlc3Ryb3koKSwgMTAwMClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICBkZXN0cm95U29vbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25jZSgnY29ubmVjdCcsIGRlc3Ryb3lTb29uKVxuICAgIH1cbiAgfVxuXG4gIF9zdGFydEljZUNvbXBsZXRlVGltZW91dCAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICBpZiAodGhpcy5faWNlQ29tcGxldGVUaW1lcikgcmV0dXJuXG4gICAgdGhpcy5fZGVidWcoJ3N0YXJ0ZWQgaWNlQ29tcGxldGUgdGltZW91dCcpXG4gICAgdGhpcy5faWNlQ29tcGxldGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9pY2VDb21wbGV0ZSkge1xuICAgICAgICB0aGlzLl9pY2VDb21wbGV0ZSA9IHRydWVcbiAgICAgICAgdGhpcy5fZGVidWcoJ2ljZUNvbXBsZXRlIHRpbWVvdXQgY29tcGxldGVkJylcbiAgICAgICAgdGhpcy5lbWl0KCdpY2VUaW1lb3V0JylcbiAgICAgICAgdGhpcy5lbWl0KCdfaWNlQ29tcGxldGUnKVxuICAgICAgfVxuICAgIH0sIHRoaXMuaWNlQ29tcGxldGVUaW1lb3V0KVxuICB9XG5cbiAgX2NyZWF0ZU9mZmVyICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgdGhpcy5fcGMuY3JlYXRlT2ZmZXIodGhpcy5vZmZlck9wdGlvbnMpXG4gICAgICAudGhlbihvZmZlciA9PiB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICAgIGlmICghdGhpcy50cmlja2xlICYmICF0aGlzLmFsbG93SGFsZlRyaWNrbGUpIG9mZmVyLnNkcCA9IGZpbHRlclRyaWNrbGUob2ZmZXIuc2RwKVxuICAgICAgICBvZmZlci5zZHAgPSB0aGlzLnNkcFRyYW5zZm9ybShvZmZlci5zZHApXG5cbiAgICAgICAgY29uc3Qgc2VuZE9mZmVyID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbiB8fCBvZmZlclxuICAgICAgICAgIHRoaXMuX2RlYnVnKCdzaWduYWwnKVxuICAgICAgICAgIHRoaXMuZW1pdCgnc2lnbmFsJywge1xuICAgICAgICAgICAgdHlwZTogc2lnbmFsLnR5cGUsXG4gICAgICAgICAgICBzZHA6IHNpZ25hbC5zZHBcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb25TdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2RlYnVnKCdjcmVhdGVPZmZlciBzdWNjZXNzJylcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgICAgIGlmICh0aGlzLnRyaWNrbGUgfHwgdGhpcy5faWNlQ29tcGxldGUpIHNlbmRPZmZlcigpXG4gICAgICAgICAgZWxzZSB0aGlzLm9uY2UoJ19pY2VDb21wbGV0ZScsIHNlbmRPZmZlcikgLy8gd2FpdCBmb3IgY2FuZGlkYXRlc1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb25FcnJvciA9IGVyciA9PiB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX1NFVF9MT0NBTF9ERVNDUklQVElPTicpKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcilcbiAgICAgICAgICAudGhlbihvblN1Y2Nlc3MpXG4gICAgICAgICAgLmNhdGNoKG9uRXJyb3IpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKGVyciwgJ0VSUl9DUkVBVEVfT0ZGRVInKSlcbiAgICAgIH0pXG4gIH1cblxuICBfcmVxdWVzdE1pc3NpbmdUcmFuc2NlaXZlcnMgKCkge1xuICAgIGlmICh0aGlzLl9wYy5nZXRUcmFuc2NlaXZlcnMpIHtcbiAgICAgIHRoaXMuX3BjLmdldFRyYW5zY2VpdmVycygpLmZvckVhY2godHJhbnNjZWl2ZXIgPT4ge1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyLm1pZCAmJiB0cmFuc2NlaXZlci5zZW5kZXIudHJhY2sgJiYgIXRyYW5zY2VpdmVyLnJlcXVlc3RlZCkge1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnJlcXVlc3RlZCA9IHRydWUgLy8gSEFDSzogU2FmYXJpIHJldHVybnMgbmVnb3RpYXRlZCB0cmFuc2NlaXZlcnMgd2l0aCBhIG51bGwgbWlkXG4gICAgICAgICAgdGhpcy5hZGRUcmFuc2NlaXZlcih0cmFuc2NlaXZlci5zZW5kZXIudHJhY2sua2luZClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQW5zd2VyICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKHRoaXMuYW5zd2VyT3B0aW9ucylcbiAgICAgIC50aGVuKGFuc3dlciA9PiB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgICAgIGlmICghdGhpcy50cmlja2xlICYmICF0aGlzLmFsbG93SGFsZlRyaWNrbGUpIGFuc3dlci5zZHAgPSBmaWx0ZXJUcmlja2xlKGFuc3dlci5zZHApXG4gICAgICAgIGFuc3dlci5zZHAgPSB0aGlzLnNkcFRyYW5zZm9ybShhbnN3ZXIuc2RwKVxuXG4gICAgICAgIGNvbnN0IHNlbmRBbnN3ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICAgICAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uIHx8IGFuc3dlclxuICAgICAgICAgIHRoaXMuX2RlYnVnKCdzaWduYWwnKVxuICAgICAgICAgIHRoaXMuZW1pdCgnc2lnbmFsJywge1xuICAgICAgICAgICAgdHlwZTogc2lnbmFsLnR5cGUsXG4gICAgICAgICAgICBzZHA6IHNpZ25hbC5zZHBcbiAgICAgICAgICB9KVxuICAgICAgICAgIGlmICghdGhpcy5pbml0aWF0b3IpIHRoaXMuX3JlcXVlc3RNaXNzaW5nVHJhbnNjZWl2ZXJzKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9uU3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgICAgICAgIGlmICh0aGlzLnRyaWNrbGUgfHwgdGhpcy5faWNlQ29tcGxldGUpIHNlbmRBbnN3ZXIoKVxuICAgICAgICAgIGVsc2UgdGhpcy5vbmNlKCdfaWNlQ29tcGxldGUnLCBzZW5kQW5zd2VyKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb25FcnJvciA9IGVyciA9PiB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUoZXJyLCAnRVJSX1NFVF9MT0NBTF9ERVNDUklQVElPTicpKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpXG4gICAgICAgICAgLnRoZW4ob25TdWNjZXNzKVxuICAgICAgICAgIC5jYXRjaChvbkVycm9yKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfQ1JFQVRFX0FOU1dFUicpKVxuICAgICAgfSlcbiAgfVxuXG4gIF9vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICBpZiAodGhpcy5fcGMuY29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgdGhpcy5kZXN0cm95KGVyckNvZGUobmV3IEVycm9yKCdDb25uZWN0aW9uIGZhaWxlZC4nKSwgJ0VSUl9DT05ORUNUSU9OX0ZBSUxVUkUnKSlcbiAgICB9XG4gIH1cblxuICBfb25JY2VTdGF0ZUNoYW5nZSAoKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICBjb25zdCBpY2VDb25uZWN0aW9uU3RhdGUgPSB0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGVcbiAgICBjb25zdCBpY2VHYXRoZXJpbmdTdGF0ZSA9IHRoaXMuX3BjLmljZUdhdGhlcmluZ1N0YXRlXG5cbiAgICB0aGlzLl9kZWJ1ZyhcbiAgICAgICdpY2VTdGF0ZUNoYW5nZSAoY29ubmVjdGlvbjogJXMpIChnYXRoZXJpbmc6ICVzKScsXG4gICAgICBpY2VDb25uZWN0aW9uU3RhdGUsXG4gICAgICBpY2VHYXRoZXJpbmdTdGF0ZVxuICAgIClcbiAgICB0aGlzLmVtaXQoJ2ljZVN0YXRlQ2hhbmdlJywgaWNlQ29ubmVjdGlvblN0YXRlLCBpY2VHYXRoZXJpbmdTdGF0ZSlcblxuICAgIGlmIChpY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnIHx8IGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgIHRoaXMuX3BjUmVhZHkgPSB0cnVlXG4gICAgICB0aGlzLl9tYXliZVJlYWR5KClcbiAgICB9XG4gICAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKG5ldyBFcnJvcignSWNlIGNvbm5lY3Rpb24gZmFpbGVkLicpLCAnRVJSX0lDRV9DT05ORUNUSU9OX0ZBSUxVUkUnKSlcbiAgICB9XG4gICAgaWYgKGljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRoaXMuZGVzdHJveShlcnJDb2RlKG5ldyBFcnJvcignSWNlIGNvbm5lY3Rpb24gY2xvc2VkLicpLCAnRVJSX0lDRV9DT05ORUNUSU9OX0NMT1NFRCcpKVxuICAgIH1cbiAgfVxuXG4gIGdldFN0YXRzIChjYikge1xuICAgIC8vIHN0YXRyZXBvcnRzIGNhbiBjb21lIHdpdGggYSB2YWx1ZSBhcnJheSBpbnN0ZWFkIG9mIHByb3BlcnRpZXNcbiAgICBjb25zdCBmbGF0dGVuVmFsdWVzID0gcmVwb3J0ID0+IHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmVwb3J0LnZhbHVlcykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgcmVwb3J0LnZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHJlcG9ydCwgdmFsdWUpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwb3J0XG4gICAgfVxuXG4gICAgLy8gUHJvbWlzZS1iYXNlZCBnZXRTdGF0cygpIChzdGFuZGFyZClcbiAgICBpZiAodGhpcy5fcGMuZ2V0U3RhdHMubGVuZ3RoID09PSAwIHx8IHRoaXMuX2lzUmVhY3ROYXRpdmVXZWJydGMpIHtcbiAgICAgIHRoaXMuX3BjLmdldFN0YXRzKClcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICBjb25zdCByZXBvcnRzID0gW11cbiAgICAgICAgICByZXMuZm9yRWFjaChyZXBvcnQgPT4ge1xuICAgICAgICAgICAgcmVwb3J0cy5wdXNoKGZsYXR0ZW5WYWx1ZXMocmVwb3J0KSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIGNiKG51bGwsIHJlcG9ydHMpXG4gICAgICAgIH0sIGVyciA9PiBjYihlcnIpKVxuXG4gICAgLy8gU2luZ2xlLXBhcmFtZXRlciBjYWxsYmFjay1iYXNlZCBnZXRTdGF0cygpIChub24tc3RhbmRhcmQpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9wYy5nZXRTdGF0cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9wYy5nZXRTdGF0cyhyZXMgPT4ge1xuICAgICAgICAvLyBJZiB3ZSBkZXN0cm95IGNvbm5lY3Rpb24gaW4gYGNvbm5lY3RgIGNhbGxiYWNrIHRoaXMgY29kZSBtaWdodCBoYXBwZW4gdG8gcnVuIHdoZW4gYWN0dWFsIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBjbG9zZWRcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgICAgICBjb25zdCByZXBvcnRzID0gW11cbiAgICAgICAgcmVzLnJlc3VsdCgpLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICAgICAgICBjb25zdCByZXBvcnQgPSB7fVxuICAgICAgICAgIHJlc3VsdC5uYW1lcygpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICByZXBvcnRbbmFtZV0gPSByZXN1bHQuc3RhdChuYW1lKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmVwb3J0LmlkID0gcmVzdWx0LmlkXG4gICAgICAgICAgcmVwb3J0LnR5cGUgPSByZXN1bHQudHlwZVxuICAgICAgICAgIHJlcG9ydC50aW1lc3RhbXAgPSByZXN1bHQudGltZXN0YW1wXG4gICAgICAgICAgcmVwb3J0cy5wdXNoKGZsYXR0ZW5WYWx1ZXMocmVwb3J0KSlcbiAgICAgICAgfSlcbiAgICAgICAgY2IobnVsbCwgcmVwb3J0cylcbiAgICAgIH0sIGVyciA9PiBjYihlcnIpKVxuXG4gICAgLy8gVW5rbm93biBicm93c2VyLCBza2lwIGdldFN0YXRzKCkgc2luY2UgaXQncyBhbnlvbmUncyBndWVzcyB3aGljaCBzdHlsZSBvZlxuICAgIC8vIGdldFN0YXRzKCkgdGhleSBpbXBsZW1lbnQuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKG51bGwsIFtdKVxuICAgIH1cbiAgfVxuXG4gIF9tYXliZVJlYWR5ICgpIHtcbiAgICB0aGlzLl9kZWJ1ZygnbWF5YmVSZWFkeSBwYyAlcyBjaGFubmVsICVzJywgdGhpcy5fcGNSZWFkeSwgdGhpcy5fY2hhbm5lbFJlYWR5KVxuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQgfHwgdGhpcy5fY29ubmVjdGluZyB8fCAhdGhpcy5fcGNSZWFkeSB8fCAhdGhpcy5fY2hhbm5lbFJlYWR5KSByZXR1cm5cblxuICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSB0cnVlXG5cbiAgICAvLyBIQUNLOiBXZSBjYW4ndCByZWx5IG9uIG9yZGVyIGhlcmUsIGZvciBkZXRhaWxzIHNlZSBodHRwczovL2dpdGh1Yi5jb20vanMtcGxhdGZvcm0vbm9kZS13ZWJydGMvaXNzdWVzLzMzOVxuICAgIGNvbnN0IGZpbmRDYW5kaWRhdGVQYWlyID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgICAgdGhpcy5nZXRTdGF0cygoZXJyLCBpdGVtcykgPT4ge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgICAgIC8vIFRyZWF0IGdldFN0YXRzIGVycm9yIGFzIG5vbi1mYXRhbC4gSXQncyBub3QgZXNzZW50aWFsLlxuICAgICAgICBpZiAoZXJyKSBpdGVtcyA9IFtdXG5cbiAgICAgICAgY29uc3QgcmVtb3RlQ2FuZGlkYXRlcyA9IHt9XG4gICAgICAgIGNvbnN0IGxvY2FsQ2FuZGlkYXRlcyA9IHt9XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZVBhaXJzID0ge31cbiAgICAgICAgbGV0IGZvdW5kU2VsZWN0ZWRDYW5kaWRhdGVQYWlyID0gZmFsc2VcblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgIC8vIFRPRE86IE9uY2UgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdGhlIGh5cGhlbmF0ZWQgc3RhdHMgcmVwb3J0IHR5cGVzLCByZW1vdmVcbiAgICAgICAgICAvLyB0aGUgbm9uLWh5cGVuYXRlZCBvbmVzXG4gICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ3JlbW90ZWNhbmRpZGF0ZScgfHwgaXRlbS50eXBlID09PSAncmVtb3RlLWNhbmRpZGF0ZScpIHtcbiAgICAgICAgICAgIHJlbW90ZUNhbmRpZGF0ZXNbaXRlbS5pZF0gPSBpdGVtXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdsb2NhbGNhbmRpZGF0ZScgfHwgaXRlbS50eXBlID09PSAnbG9jYWwtY2FuZGlkYXRlJykge1xuICAgICAgICAgICAgbG9jYWxDYW5kaWRhdGVzW2l0ZW0uaWRdID0gaXRlbVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnY2FuZGlkYXRlcGFpcicgfHwgaXRlbS50eXBlID09PSAnY2FuZGlkYXRlLXBhaXInKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGVQYWlyc1tpdGVtLmlkXSA9IGl0ZW1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3Qgc2V0U2VsZWN0ZWRDYW5kaWRhdGVQYWlyID0gc2VsZWN0ZWRDYW5kaWRhdGVQYWlyID0+IHtcbiAgICAgICAgICBmb3VuZFNlbGVjdGVkQ2FuZGlkYXRlUGFpciA9IHRydWVcblxuICAgICAgICAgIGxldCBsb2NhbCA9IGxvY2FsQ2FuZGlkYXRlc1tzZWxlY3RlZENhbmRpZGF0ZVBhaXIubG9jYWxDYW5kaWRhdGVJZF1cblxuICAgICAgICAgIGlmIChsb2NhbCAmJiAobG9jYWwuaXAgfHwgbG9jYWwuYWRkcmVzcykpIHtcbiAgICAgICAgICAgIC8vIFNwZWNcbiAgICAgICAgICAgIHRoaXMubG9jYWxBZGRyZXNzID0gbG9jYWwuaXAgfHwgbG9jYWwuYWRkcmVzc1xuICAgICAgICAgICAgdGhpcy5sb2NhbFBvcnQgPSBOdW1iZXIobG9jYWwucG9ydClcbiAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsICYmIGxvY2FsLmlwQWRkcmVzcykge1xuICAgICAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBsb2NhbC5pcEFkZHJlc3NcbiAgICAgICAgICAgIHRoaXMubG9jYWxQb3J0ID0gTnVtYmVyKGxvY2FsLnBvcnROdW1iZXIpXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLmdvb2dMb2NhbEFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBvbmNlIENocm9tZSA1OCBpcyByZWxlYXNlZFxuICAgICAgICAgICAgbG9jYWwgPSBzZWxlY3RlZENhbmRpZGF0ZVBhaXIuZ29vZ0xvY2FsQWRkcmVzcy5zcGxpdCgnOicpXG4gICAgICAgICAgICB0aGlzLmxvY2FsQWRkcmVzcyA9IGxvY2FsWzBdXG4gICAgICAgICAgICB0aGlzLmxvY2FsUG9ydCA9IE51bWJlcihsb2NhbFsxXSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMubG9jYWxBZGRyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsRmFtaWx5ID0gdGhpcy5sb2NhbEFkZHJlc3MuaW5jbHVkZXMoJzonKSA/ICdJUHY2JyA6ICdJUHY0J1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCByZW1vdGUgPSByZW1vdGVDYW5kaWRhdGVzW3NlbGVjdGVkQ2FuZGlkYXRlUGFpci5yZW1vdGVDYW5kaWRhdGVJZF1cblxuICAgICAgICAgIGlmIChyZW1vdGUgJiYgKHJlbW90ZS5pcCB8fCByZW1vdGUuYWRkcmVzcykpIHtcbiAgICAgICAgICAgIC8vIFNwZWNcbiAgICAgICAgICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHJlbW90ZS5pcCB8fCByZW1vdGUuYWRkcmVzc1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVQb3J0ID0gTnVtYmVyKHJlbW90ZS5wb3J0KVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVtb3RlICYmIHJlbW90ZS5pcEFkZHJlc3MpIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3hcbiAgICAgICAgICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHJlbW90ZS5pcEFkZHJlc3NcbiAgICAgICAgICAgIHRoaXMucmVtb3RlUG9ydCA9IE51bWJlcihyZW1vdGUucG9ydE51bWJlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RlZENhbmRpZGF0ZVBhaXIuZ29vZ1JlbW90ZUFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBvbmNlIENocm9tZSA1OCBpcyByZWxlYXNlZFxuICAgICAgICAgICAgcmVtb3RlID0gc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLmdvb2dSZW1vdGVBZGRyZXNzLnNwbGl0KCc6JylcbiAgICAgICAgICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHJlbW90ZVswXVxuICAgICAgICAgICAgdGhpcy5yZW1vdGVQb3J0ID0gTnVtYmVyKHJlbW90ZVsxXSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMucmVtb3RlQWRkcmVzcykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVGYW1pbHkgPSB0aGlzLnJlbW90ZUFkZHJlc3MuaW5jbHVkZXMoJzonKSA/ICdJUHY2JyA6ICdJUHY0J1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICAgICAgJ2Nvbm5lY3QgbG9jYWw6ICVzOiVzIHJlbW90ZTogJXM6JXMnLFxuICAgICAgICAgICAgdGhpcy5sb2NhbEFkZHJlc3MsXG4gICAgICAgICAgICB0aGlzLmxvY2FsUG9ydCxcbiAgICAgICAgICAgIHRoaXMucmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgIHRoaXMucmVtb3RlUG9ydFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgLy8gU3BlYy1jb21wbGlhbnRcbiAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAndHJhbnNwb3J0JyAmJiBpdGVtLnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZENhbmRpZGF0ZVBhaXIoY2FuZGlkYXRlUGFpcnNbaXRlbS5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZF0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gT2xkIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChpdGVtLnR5cGUgPT09ICdnb29nQ2FuZGlkYXRlUGFpcicgJiYgaXRlbS5nb29nQWN0aXZlQ29ubmVjdGlvbiA9PT0gJ3RydWUnKSB8fFxuICAgICAgICAgICAgKChpdGVtLnR5cGUgPT09ICdjYW5kaWRhdGVwYWlyJyB8fCBpdGVtLnR5cGUgPT09ICdjYW5kaWRhdGUtcGFpcicpICYmIGl0ZW0uc2VsZWN0ZWQpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZENhbmRpZGF0ZVBhaXIoaXRlbSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gSWdub3JlIGNhbmRpZGF0ZSBwYWlyIHNlbGVjdGlvbiBpbiBicm93c2VycyBsaWtlIFNhZmFyaSAxMSB0aGF0IGRvIG5vdCBoYXZlIGFueSBsb2NhbCBvciByZW1vdGUgY2FuZGlkYXRlc1xuICAgICAgICAvLyBCdXQgd2FpdCB1bnRpbCBhdCBsZWFzdCAxIGNhbmRpZGF0ZSBwYWlyIGlzIGF2YWlsYWJsZVxuICAgICAgICBpZiAoIWZvdW5kU2VsZWN0ZWRDYW5kaWRhdGVQYWlyICYmICghT2JqZWN0LmtleXMoY2FuZGlkYXRlUGFpcnMpLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhsb2NhbENhbmRpZGF0ZXMpLmxlbmd0aCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZpbmRDYW5kaWRhdGVQYWlyLCAxMDApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlXG4gICAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NodW5rKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc2VuZCh0aGlzLl9jaHVuaylcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koZXJyQ29kZShlcnIsICdFUlJfREFUQV9DSEFOTkVMJykpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2NodW5rID0gbnVsbFxuICAgICAgICAgIHRoaXMuX2RlYnVnKCdzZW50IGNodW5rIGZyb20gXCJ3cml0ZSBiZWZvcmUgY29ubmVjdFwiJylcblxuICAgICAgICAgIGNvbnN0IGNiID0gdGhpcy5fY2JcbiAgICAgICAgICB0aGlzLl9jYiA9IG51bGxcbiAgICAgICAgICBjYihudWxsKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYGJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkYCBhbmQgJ29uYnVmZmVyZWRhbW91bnRsb3cnIGFyZSB1bnN1cHBvcnRlZCxcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gdXNpbmcgc2V0SW50ZXJ2YWwgdG8gaW1wbGVtZW50IGJhY2twcmVzc3VyZS5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5fb25JbnRlcnZhbCgpLCAxNTApXG4gICAgICAgICAgaWYgKHRoaXMuX2ludGVydmFsLnVucmVmKSB0aGlzLl9pbnRlcnZhbC51bnJlZigpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kZWJ1ZygnY29ubmVjdCcpXG4gICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcpXG4gICAgICB9KVxuICAgIH1cbiAgICBmaW5kQ2FuZGlkYXRlUGFpcigpXG4gIH1cblxuICBfb25JbnRlcnZhbCAoKSB7XG4gICAgaWYgKCF0aGlzLl9jYiB8fCAhdGhpcy5fY2hhbm5lbCB8fCB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50ID4gTUFYX0JVRkZFUkVEX0FNT1VOVCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuX29uQ2hhbm5lbEJ1ZmZlcmVkQW1vdW50TG93KClcbiAgfVxuXG4gIF9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuXG4gICAgaWYgKHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykge1xuICAgICAgdGhpcy5faXNOZWdvdGlhdGluZyA9IGZhbHNlXG5cbiAgICAgIC8vIEhBQ0s6IEZpcmVmb3ggZG9lc24ndCB5ZXQgc3VwcG9ydCByZW1vdmluZyB0cmFja3Mgd2hlbiBzaWduYWxpbmdTdGF0ZSAhPT0gJ3N0YWJsZSdcbiAgICAgIHRoaXMuX2RlYnVnKCdmbHVzaGluZyBzZW5kZXIgcXVldWUnLCB0aGlzLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUpXG4gICAgICB0aGlzLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUuZm9yRWFjaChzZW5kZXIgPT4ge1xuICAgICAgICB0aGlzLl9wYy5yZW1vdmVUcmFjayhzZW5kZXIpXG4gICAgICAgIHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uID0gdHJ1ZVxuICAgICAgfSlcbiAgICAgIHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZSA9IFtdXG5cbiAgICAgIGlmICh0aGlzLl9xdWV1ZWROZWdvdGlhdGlvbikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnZmx1c2hpbmcgbmVnb3RpYXRpb24gcXVldWUnKVxuICAgICAgICB0aGlzLl9xdWV1ZWROZWdvdGlhdGlvbiA9IGZhbHNlXG4gICAgICAgIHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKSAvLyBuZWdvdGlhdGUgYWdhaW5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCduZWdvdGlhdGVkJylcbiAgICAgICAgdGhpcy5lbWl0KCduZWdvdGlhdGVkJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9kZWJ1Zygnc2lnbmFsaW5nU3RhdGVDaGFuZ2UgJXMnLCB0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSlcbiAgICB0aGlzLmVtaXQoJ3NpZ25hbGluZ1N0YXRlQ2hhbmdlJywgdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUpXG4gIH1cblxuICBfb25JY2VDYW5kaWRhdGUgKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgICBpZiAoZXZlbnQuY2FuZGlkYXRlICYmIHRoaXMudHJpY2tsZSkge1xuICAgICAgdGhpcy5lbWl0KCdzaWduYWwnLCB7XG4gICAgICAgIHR5cGU6ICdjYW5kaWRhdGUnLFxuICAgICAgICBjYW5kaWRhdGU6IHtcbiAgICAgICAgICBjYW5kaWRhdGU6IGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUsXG4gICAgICAgICAgc2RwTUxpbmVJbmRleDogZXZlbnQuY2FuZGlkYXRlLnNkcE1MaW5lSW5kZXgsXG4gICAgICAgICAgc2RwTWlkOiBldmVudC5jYW5kaWRhdGUuc2RwTWlkXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICghZXZlbnQuY2FuZGlkYXRlICYmICF0aGlzLl9pY2VDb21wbGV0ZSkge1xuICAgICAgdGhpcy5faWNlQ29tcGxldGUgPSB0cnVlXG4gICAgICB0aGlzLmVtaXQoJ19pY2VDb21wbGV0ZScpXG4gICAgfVxuICAgIC8vIGFzIHNvb24gYXMgd2UndmUgcmVjZWl2ZWQgb25lIHZhbGlkIGNhbmRpZGF0ZSBzdGFydCB0aW1lb3V0XG4gICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSkge1xuICAgICAgdGhpcy5fc3RhcnRJY2VDb21wbGV0ZVRpbWVvdXQoKVxuICAgIH1cbiAgfVxuXG4gIF9vbkNoYW5uZWxNZXNzYWdlIChldmVudCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgbGV0IGRhdGEgPSBldmVudC5kYXRhXG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpXG4gICAgdGhpcy5wdXNoKGRhdGEpXG4gIH1cblxuICBfb25DaGFubmVsQnVmZmVyZWRBbW91bnRMb3cgKCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCB8fCAhdGhpcy5fY2IpIHJldHVyblxuICAgIHRoaXMuX2RlYnVnKCdlbmRpbmcgYmFja3ByZXNzdXJlOiBidWZmZXJlZEFtb3VudCAlZCcsIHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnQpXG4gICAgY29uc3QgY2IgPSB0aGlzLl9jYlxuICAgIHRoaXMuX2NiID0gbnVsbFxuICAgIGNiKG51bGwpXG4gIH1cblxuICBfb25DaGFubmVsT3BlbiAoKSB7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCB8fCB0aGlzLmRlc3Ryb3llZCkgcmV0dXJuXG4gICAgdGhpcy5fZGVidWcoJ29uIGNoYW5uZWwgb3BlbicpXG4gICAgdGhpcy5fY2hhbm5lbFJlYWR5ID0gdHJ1ZVxuICAgIHRoaXMuX21heWJlUmVhZHkoKVxuICB9XG5cbiAgX29uQ2hhbm5lbENsb3NlICgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVyblxuICAgIHRoaXMuX2RlYnVnKCdvbiBjaGFubmVsIGNsb3NlJylcbiAgICB0aGlzLmRlc3Ryb3koKVxuICB9XG5cbiAgX29uVHJhY2sgKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cblxuICAgIGV2ZW50LnN0cmVhbXMuZm9yRWFjaChldmVudFN0cmVhbSA9PiB7XG4gICAgICB0aGlzLl9kZWJ1Zygnb24gdHJhY2snKVxuICAgICAgdGhpcy5lbWl0KCd0cmFjaycsIGV2ZW50LnRyYWNrLCBldmVudFN0cmVhbSlcblxuICAgICAgdGhpcy5fcmVtb3RlVHJhY2tzLnB1c2goe1xuICAgICAgICB0cmFjazogZXZlbnQudHJhY2ssXG4gICAgICAgIHN0cmVhbTogZXZlbnRTdHJlYW1cbiAgICAgIH0pXG5cbiAgICAgIGlmICh0aGlzLl9yZW1vdGVTdHJlYW1zLnNvbWUocmVtb3RlU3RyZWFtID0+IHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZVN0cmVhbS5pZCA9PT0gZXZlbnRTdHJlYW0uaWRcbiAgICAgIH0pKSByZXR1cm4gLy8gT25seSBmaXJlIG9uZSAnc3RyZWFtJyBldmVudCwgZXZlbiB0aG91Z2ggdGhlcmUgbWF5IGJlIG11bHRpcGxlIHRyYWNrcyBwZXIgc3RyZWFtXG5cbiAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMucHVzaChldmVudFN0cmVhbSlcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ29uIHN0cmVhbScpXG4gICAgICAgIHRoaXMuZW1pdCgnc3RyZWFtJywgZXZlbnRTdHJlYW0pIC8vIGVuc3VyZSBhbGwgdHJhY2tzIGhhdmUgYmVlbiBhZGRlZFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgX2RlYnVnICgpIHtcbiAgICBjb25zdCBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgYXJnc1swXSA9ICdbJyArIHRoaXMuX2lkICsgJ10gJyArIGFyZ3NbMF1cbiAgICBkZWJ1Zy5hcHBseShudWxsLCBhcmdzKVxuICB9XG59XG5cblBlZXIuV0VCUlRDX1NVUFBPUlQgPSAhIWdldEJyb3dzZXJSVEMoKVxuXG4vKipcbiAqIEV4cG9zZSBwZWVyIGFuZCBkYXRhIGNoYW5uZWwgY29uZmlnIGZvciBvdmVycmlkaW5nIGFsbCBQZWVyXG4gKiBpbnN0YW5jZXMuIE90aGVyd2lzZSwganVzdCBzZXQgb3B0cy5jb25maWcgb3Igb3B0cy5jaGFubmVsQ29uZmlnXG4gKiB3aGVuIGNvbnN0cnVjdGluZyBhIFBlZXIuXG4gKi9cblBlZXIuY29uZmlnID0ge1xuICBpY2VTZXJ2ZXJzOiBbXG4gICAge1xuICAgICAgdXJsczogW1xuICAgICAgICAnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMicsXG4gICAgICAgICdzdHVuOmdsb2JhbC5zdHVuLnR3aWxpby5jb206MzQ3OCdcbiAgICAgIF1cbiAgICB9XG4gIF0sXG4gIHNkcFNlbWFudGljczogJ3VuaWZpZWQtcGxhbidcbn1cblxuUGVlci5jaGFubmVsQ29uZmlnID0ge31cblxubW9kdWxlLmV4cG9ydHMgPSBQZWVyXG4iLCJ2YXIgZW5naW5lID0gcmVxdWlyZSgnLi4vc3JjL3N0b3JlLWVuZ2luZScpXG5cbnZhciBzdG9yYWdlcyA9IHJlcXVpcmUoJy4uL3N0b3JhZ2VzL2FsbCcpXG52YXIgcGx1Z2lucyA9IFtyZXF1aXJlKCcuLi9wbHVnaW5zL2pzb24yJyldXG5cbm1vZHVsZS5leHBvcnRzID0gZW5naW5lLmNyZWF0ZVN0b3JlKHN0b3JhZ2VzLCBwbHVnaW5zKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBqc29uMlBsdWdpblxuXG5mdW5jdGlvbiBqc29uMlBsdWdpbigpIHtcblx0cmVxdWlyZSgnLi9saWIvanNvbjInKVxuXHRyZXR1cm4ge31cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cbi8vICBqc29uMi5qc1xuLy8gIDIwMTYtMTAtMjhcbi8vICBQdWJsaWMgRG9tYWluLlxuLy8gIE5PIFdBUlJBTlRZIEVYUFJFU1NFRCBPUiBJTVBMSUVELiBVU0UgQVQgWU9VUiBPV04gUklTSy5cbi8vICBTZWUgaHR0cDovL3d3dy5KU09OLm9yZy9qcy5odG1sXG4vLyAgVGhpcyBjb2RlIHNob3VsZCBiZSBtaW5pZmllZCBiZWZvcmUgZGVwbG95bWVudC5cbi8vICBTZWUgaHR0cDovL2phdmFzY3JpcHQuY3JvY2tmb3JkLmNvbS9qc21pbi5odG1sXG5cbi8vICBVU0UgWU9VUiBPV04gQ09QWS4gSVQgSVMgRVhUUkVNRUxZIFVOV0lTRSBUTyBMT0FEIENPREUgRlJPTSBTRVJWRVJTIFlPVSBET1xuLy8gIE5PVCBDT05UUk9MLlxuXG4vLyAgVGhpcyBmaWxlIGNyZWF0ZXMgYSBnbG9iYWwgSlNPTiBvYmplY3QgY29udGFpbmluZyB0d28gbWV0aG9kczogc3RyaW5naWZ5XG4vLyAgYW5kIHBhcnNlLiBUaGlzIGZpbGUgcHJvdmlkZXMgdGhlIEVTNSBKU09OIGNhcGFiaWxpdHkgdG8gRVMzIHN5c3RlbXMuXG4vLyAgSWYgYSBwcm9qZWN0IG1pZ2h0IHJ1biBvbiBJRTggb3IgZWFybGllciwgdGhlbiB0aGlzIGZpbGUgc2hvdWxkIGJlIGluY2x1ZGVkLlxuLy8gIFRoaXMgZmlsZSBkb2VzIG5vdGhpbmcgb24gRVM1IHN5c3RlbXMuXG5cbi8vICAgICAgSlNPTi5zdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSlcbi8vICAgICAgICAgIHZhbHVlICAgICAgIGFueSBKYXZhU2NyaXB0IHZhbHVlLCB1c3VhbGx5IGFuIG9iamVjdCBvciBhcnJheS5cbi8vICAgICAgICAgIHJlcGxhY2VyICAgIGFuIG9wdGlvbmFsIHBhcmFtZXRlciB0aGF0IGRldGVybWluZXMgaG93IG9iamVjdFxuLy8gICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIGFyZSBzdHJpbmdpZmllZCBmb3Igb2JqZWN0cy4gSXQgY2FuIGJlIGFcbi8vICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4vLyAgICAgICAgICBzcGFjZSAgICAgICBhbiBvcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4vLyAgICAgICAgICAgICAgICAgICAgICBvZiBuZXN0ZWQgc3RydWN0dXJlcy4gSWYgaXQgaXMgb21pdHRlZCwgdGhlIHRleHQgd2lsbFxuLy8gICAgICAgICAgICAgICAgICAgICAgYmUgcGFja2VkIHdpdGhvdXQgZXh0cmEgd2hpdGVzcGFjZS4gSWYgaXQgaXMgYSBudW1iZXIsXG4vLyAgICAgICAgICAgICAgICAgICAgICBpdCB3aWxsIHNwZWNpZnkgdGhlIG51bWJlciBvZiBzcGFjZXMgdG8gaW5kZW50IGF0IGVhY2hcbi8vICAgICAgICAgICAgICAgICAgICAgIGxldmVsLiBJZiBpdCBpcyBhIHN0cmluZyAoc3VjaCBhcyBcIlxcdFwiIG9yIFwiJm5ic3A7XCIpLFxuLy8gICAgICAgICAgICAgICAgICAgICAgaXQgY29udGFpbnMgdGhlIGNoYXJhY3RlcnMgdXNlZCB0byBpbmRlbnQgYXQgZWFjaCBsZXZlbC5cbi8vICAgICAgICAgIFRoaXMgbWV0aG9kIHByb2R1Y2VzIGEgSlNPTiB0ZXh0IGZyb20gYSBKYXZhU2NyaXB0IHZhbHVlLlxuLy8gICAgICAgICAgV2hlbiBhbiBvYmplY3QgdmFsdWUgaXMgZm91bmQsIGlmIHRoZSBvYmplY3QgY29udGFpbnMgYSB0b0pTT05cbi8vICAgICAgICAgIG1ldGhvZCwgaXRzIHRvSlNPTiBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYW5kIHRoZSByZXN1bHQgd2lsbCBiZVxuLy8gICAgICAgICAgc3RyaW5naWZpZWQuIEEgdG9KU09OIG1ldGhvZCBkb2VzIG5vdCBzZXJpYWxpemU6IGl0IHJldHVybnMgdGhlXG4vLyAgICAgICAgICB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgbmFtZS92YWx1ZSBwYWlyIHRoYXQgc2hvdWxkIGJlIHNlcmlhbGl6ZWQsXG4vLyAgICAgICAgICBvciB1bmRlZmluZWQgaWYgbm90aGluZyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIHRvSlNPTiBtZXRob2Rcbi8vICAgICAgICAgIHdpbGwgYmUgcGFzc2VkIHRoZSBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSB2YWx1ZSwgYW5kIHRoaXMgd2lsbCBiZVxuLy8gICAgICAgICAgYm91bmQgdG8gdGhlIHZhbHVlLlxuXG4vLyAgICAgICAgICBGb3IgZXhhbXBsZSwgdGhpcyB3b3VsZCBzZXJpYWxpemUgRGF0ZXMgYXMgSVNPIHN0cmluZ3MuXG5cbi8vICAgICAgICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG4vLyAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGYobikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgLy8gRm9ybWF0IGludGVnZXJzIHRvIGhhdmUgYXQgbGVhc3QgdHdvIGRpZ2l0cy5cbi8vICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobiA8IDEwKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgID8gXCIwXCIgKyBuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuO1xuLy8gICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFVUQ0Z1bGxZZWFyKCkgICArIFwiLVwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTW9udGgoKSArIDEpICsgXCItXCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENEYXRlKCkpICAgICAgKyBcIlRcIiArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ0hvdXJzKCkpICAgICArIFwiOlwiICtcbi8vICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDTWludXRlcygpKSAgICsgXCI6XCIgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENTZWNvbmRzKCkpICAgKyBcIlpcIjtcbi8vICAgICAgICAgICAgICB9O1xuXG4vLyAgICAgICAgICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWwgcmVwbGFjZXIgbWV0aG9kLiBJdCB3aWxsIGJlIHBhc3NlZCB0aGVcbi8vICAgICAgICAgIGtleSBhbmQgdmFsdWUgb2YgZWFjaCBtZW1iZXIsIHdpdGggdGhpcyBib3VuZCB0byB0aGUgY29udGFpbmluZ1xuLy8gICAgICAgICAgb2JqZWN0LiBUaGUgdmFsdWUgdGhhdCBpcyByZXR1cm5lZCBmcm9tIHlvdXIgbWV0aG9kIHdpbGwgYmVcbi8vICAgICAgICAgIHNlcmlhbGl6ZWQuIElmIHlvdXIgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLCB0aGVuIHRoZSBtZW1iZXIgd2lsbFxuLy8gICAgICAgICAgYmUgZXhjbHVkZWQgZnJvbSB0aGUgc2VyaWFsaXphdGlvbi5cblxuLy8gICAgICAgICAgSWYgdGhlIHJlcGxhY2VyIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLCB0aGVuIGl0IHdpbGwgYmVcbi8vICAgICAgICAgIHVzZWQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHNlcmlhbGl6ZWQuIEl0IGZpbHRlcnMgdGhlIHJlc3VsdHNcbi8vICAgICAgICAgIHN1Y2ggdGhhdCBvbmx5IG1lbWJlcnMgd2l0aCBrZXlzIGxpc3RlZCBpbiB0aGUgcmVwbGFjZXIgYXJyYXkgYXJlXG4vLyAgICAgICAgICBzdHJpbmdpZmllZC5cblxuLy8gICAgICAgICAgVmFsdWVzIHRoYXQgZG8gbm90IGhhdmUgSlNPTiByZXByZXNlbnRhdGlvbnMsIHN1Y2ggYXMgdW5kZWZpbmVkIG9yXG4vLyAgICAgICAgICBmdW5jdGlvbnMsIHdpbGwgbm90IGJlIHNlcmlhbGl6ZWQuIFN1Y2ggdmFsdWVzIGluIG9iamVjdHMgd2lsbCBiZVxuLy8gICAgICAgICAgZHJvcHBlZDsgaW4gYXJyYXlzIHRoZXkgd2lsbCBiZSByZXBsYWNlZCB3aXRoIG51bGwuIFlvdSBjYW4gdXNlXG4vLyAgICAgICAgICBhIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIHJlcGxhY2UgdGhvc2Ugd2l0aCBKU09OIHZhbHVlcy5cblxuLy8gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodW5kZWZpbmVkKSByZXR1cm5zIHVuZGVmaW5lZC5cblxuLy8gICAgICAgICAgVGhlIG9wdGlvbmFsIHNwYWNlIHBhcmFtZXRlciBwcm9kdWNlcyBhIHN0cmluZ2lmaWNhdGlvbiBvZiB0aGVcbi8vICAgICAgICAgIHZhbHVlIHRoYXQgaXMgZmlsbGVkIHdpdGggbGluZSBicmVha3MgYW5kIGluZGVudGF0aW9uIHRvIG1ha2UgaXRcbi8vICAgICAgICAgIGVhc2llciB0byByZWFkLlxuXG4vLyAgICAgICAgICBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbm9uLWVtcHR5IHN0cmluZywgdGhlbiB0aGF0IHN0cmluZyB3aWxsXG4vLyAgICAgICAgICBiZSB1c2VkIGZvciBpbmRlbnRhdGlvbi4gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgdGhlblxuLy8gICAgICAgICAgdGhlIGluZGVudGF0aW9uIHdpbGwgYmUgdGhhdCBtYW55IHNwYWNlcy5cblxuLy8gICAgICAgICAgRXhhbXBsZTpcblxuLy8gICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtcImVcIiwge3BsdXJpYnVzOiBcInVudW1cIn1dKTtcbi8vICAgICAgICAgIC8vIHRleHQgaXMgJ1tcImVcIix7XCJwbHVyaWJ1c1wiOlwidW51bVwifV0nXG5cbi8vICAgICAgICAgIHRleHQgPSBKU09OLnN0cmluZ2lmeShbXCJlXCIsIHtwbHVyaWJ1czogXCJ1bnVtXCJ9XSwgbnVsbCwgXCJcXHRcIik7XG4vLyAgICAgICAgICAvLyB0ZXh0IGlzICdbXFxuXFx0XCJlXCIsXFxuXFx0e1xcblxcdFxcdFwicGx1cmlidXNcIjogXCJ1bnVtXCJcXG5cXHR9XFxuXSdcblxuLy8gICAgICAgICAgdGV4dCA9IEpTT04uc3RyaW5naWZ5KFtuZXcgRGF0ZSgpXSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbi8vICAgICAgICAgICAgICByZXR1cm4gdGhpc1trZXldIGluc3RhbmNlb2YgRGF0ZVxuLy8gICAgICAgICAgICAgICAgICA/IFwiRGF0ZShcIiArIHRoaXNba2V5XSArIFwiKVwiXG4vLyAgICAgICAgICAgICAgICAgIDogdmFsdWU7XG4vLyAgICAgICAgICB9KTtcbi8vICAgICAgICAgIC8vIHRleHQgaXMgJ1tcIkRhdGUoLS0tY3VycmVudCB0aW1lLS0tKVwiXSdcblxuLy8gICAgICBKU09OLnBhcnNlKHRleHQsIHJldml2ZXIpXG4vLyAgICAgICAgICBUaGlzIG1ldGhvZCBwYXJzZXMgYSBKU09OIHRleHQgdG8gcHJvZHVjZSBhbiBvYmplY3Qgb3IgYXJyYXkuXG4vLyAgICAgICAgICBJdCBjYW4gdGhyb3cgYSBTeW50YXhFcnJvciBleGNlcHRpb24uXG5cbi8vICAgICAgICAgIFRoZSBvcHRpb25hbCByZXZpdmVyIHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGZpbHRlciBhbmRcbi8vICAgICAgICAgIHRyYW5zZm9ybSB0aGUgcmVzdWx0cy4gSXQgcmVjZWl2ZXMgZWFjaCBvZiB0aGUga2V5cyBhbmQgdmFsdWVzLFxuLy8gICAgICAgICAgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbi8vICAgICAgICAgIElmIGl0IHJldHVybnMgd2hhdCBpdCByZWNlaXZlZCwgdGhlbiB0aGUgc3RydWN0dXJlIGlzIG5vdCBtb2RpZmllZC5cbi8vICAgICAgICAgIElmIGl0IHJldHVybnMgdW5kZWZpbmVkIHRoZW4gdGhlIG1lbWJlciBpcyBkZWxldGVkLlxuXG4vLyAgICAgICAgICBFeGFtcGxlOlxuXG4vLyAgICAgICAgICAvLyBQYXJzZSB0aGUgdGV4dC4gVmFsdWVzIHRoYXQgbG9vayBsaWtlIElTTyBkYXRlIHN0cmluZ3Mgd2lsbFxuLy8gICAgICAgICAgLy8gYmUgY29udmVydGVkIHRvIERhdGUgb2JqZWN0cy5cblxuLy8gICAgICAgICAgbXlEYXRhID0gSlNPTi5wYXJzZSh0ZXh0LCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuLy8gICAgICAgICAgICAgIHZhciBhO1xuLy8gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbi8vICAgICAgICAgICAgICAgICAgYSA9XG4vLyAgIC9eKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSlUKFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSg/OlxcLlxcZCopPylaJC8uZXhlYyh2YWx1ZSk7XG4vLyAgICAgICAgICAgICAgICAgIGlmIChhKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoK2FbMV0sICthWzJdIC0gMSwgK2FbM10sICthWzRdLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICthWzVdLCArYVs2XSkpO1xuLy8gICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbi8vICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICBteURhdGEgPSBKU09OLnBhcnNlKCdbXCJEYXRlKDA5LzA5LzIwMDEpXCJdJywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbi8vICAgICAgICAgICAgICB2YXIgZDtcbi8vICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4vLyAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCA1KSA9PT0gXCJEYXRlKFwiICYmXG4vLyAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgtMSkgPT09IFwiKVwiKSB7XG4vLyAgICAgICAgICAgICAgICAgIGQgPSBuZXcgRGF0ZSh2YWx1ZS5zbGljZSg1LCAtMSkpO1xuLy8gICAgICAgICAgICAgICAgICBpZiAoZCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4vLyAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuLy8gICAgICAgICAgfSk7XG5cbi8vICBUaGlzIGlzIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLiBZb3UgYXJlIGZyZWUgdG8gY29weSwgbW9kaWZ5LCBvclxuLy8gIHJlZGlzdHJpYnV0ZS5cblxuLypqc2xpbnRcbiAgICBldmFsLCBmb3IsIHRoaXNcbiovXG5cbi8qcHJvcGVydHlcbiAgICBKU09OLCBhcHBseSwgY2FsbCwgY2hhckNvZGVBdCwgZ2V0VVRDRGF0ZSwgZ2V0VVRDRnVsbFllYXIsIGdldFVUQ0hvdXJzLFxuICAgIGdldFVUQ01pbnV0ZXMsIGdldFVUQ01vbnRoLCBnZXRVVENTZWNvbmRzLCBoYXNPd25Qcm9wZXJ0eSwgam9pbixcbiAgICBsYXN0SW5kZXgsIGxlbmd0aCwgcGFyc2UsIHByb3RvdHlwZSwgcHVzaCwgcmVwbGFjZSwgc2xpY2UsIHN0cmluZ2lmeSxcbiAgICB0ZXN0LCB0b0pTT04sIHRvU3RyaW5nLCB2YWx1ZU9mXG4qL1xuXG5cbi8vIENyZWF0ZSBhIEpTT04gb2JqZWN0IG9ubHkgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuIFdlIGNyZWF0ZSB0aGVcbi8vIG1ldGhvZHMgaW4gYSBjbG9zdXJlIHRvIGF2b2lkIGNyZWF0aW5nIGdsb2JhbCB2YXJpYWJsZXMuXG5cbmlmICh0eXBlb2YgSlNPTiAhPT0gXCJvYmplY3RcIikge1xuICAgIEpTT04gPSB7fTtcbn1cblxuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciByeF9vbmUgPSAvXltcXF0sOnt9XFxzXSokLztcbiAgICB2YXIgcnhfdHdvID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZztcbiAgICB2YXIgcnhfdGhyZWUgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XG4gICAgdmFyIHJ4X2ZvdXIgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG4gICAgdmFyIHJ4X2VzY2FwYWJsZSA9IC9bXFxcXFwiXFx1MDAwMC1cXHUwMDFmXFx1MDA3Zi1cXHUwMDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2c7XG4gICAgdmFyIHJ4X2Rhbmdlcm91cyA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nO1xuXG4gICAgZnVuY3Rpb24gZihuKSB7XG4gICAgICAgIC8vIEZvcm1hdCBpbnRlZ2VycyB0byBoYXZlIGF0IGxlYXN0IHR3byBkaWdpdHMuXG4gICAgICAgIHJldHVybiBuIDwgMTBcbiAgICAgICAgICAgID8gXCIwXCIgKyBuXG4gICAgICAgICAgICA6IG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGhpc192YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgRGF0ZS5wcm90b3R5cGUudG9KU09OICE9PSBcImZ1bmN0aW9uXCIpIHtcblxuICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh0aGlzLnZhbHVlT2YoKSlcbiAgICAgICAgICAgICAgICA/IHRoaXMuZ2V0VVRDRnVsbFllYXIoKSArIFwiLVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNb250aCgpICsgMSkgKyBcIi1cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBmKHRoaXMuZ2V0VVRDRGF0ZSgpKSArIFwiVFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENIb3VycygpKSArIFwiOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYodGhpcy5nZXRVVENNaW51dGVzKCkpICsgXCI6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZih0aGlzLmdldFVUQ1NlY29uZHMoKSkgKyBcIlpcIlxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICBCb29sZWFuLnByb3RvdHlwZS50b0pTT04gPSB0aGlzX3ZhbHVlO1xuICAgICAgICBOdW1iZXIucHJvdG90eXBlLnRvSlNPTiA9IHRoaXNfdmFsdWU7XG4gICAgICAgIFN0cmluZy5wcm90b3R5cGUudG9KU09OID0gdGhpc192YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgZ2FwO1xuICAgIHZhciBpbmRlbnQ7XG4gICAgdmFyIG1ldGE7XG4gICAgdmFyIHJlcDtcblxuXG4gICAgZnVuY3Rpb24gcXVvdGUoc3RyaW5nKSB7XG5cbi8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbi8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG4vLyBPdGhlcndpc2Ugd2UgbXVzdCBhbHNvIHJlcGxhY2UgdGhlIG9mZmVuZGluZyBjaGFyYWN0ZXJzIHdpdGggc2FmZSBlc2NhcGVcbi8vIHNlcXVlbmNlcy5cblxuICAgICAgICByeF9lc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHJ4X2VzY2FwYWJsZS50ZXN0KHN0cmluZylcbiAgICAgICAgICAgID8gXCJcXFwiXCIgKyBzdHJpbmcucmVwbGFjZShyeF9lc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICA/IGNcbiAgICAgICAgICAgICAgICAgICAgOiBcIlxcXFx1XCIgKyAoXCIwMDAwXCIgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgICAgICB9KSArIFwiXFxcIlwiXG4gICAgICAgICAgICA6IFwiXFxcIlwiICsgc3RyaW5nICsgXCJcXFwiXCI7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcblxuLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuXG4gICAgICAgIHZhciBpOyAgICAgICAgICAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICB2YXIgazsgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgIHZhciB2OyAgICAgICAgICAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICB2YXIgbWluZCA9IGdhcDtcbiAgICAgICAgdmFyIHBhcnRpYWw7XG4gICAgICAgIHZhciB2YWx1ZSA9IGhvbGRlcltrZXldO1xuXG4vLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cblxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgICAgICB9XG5cbi8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFsdWUgPSByZXAuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG5cbi8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cblxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuXG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcblxuLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICA/IFN0cmluZyh2YWx1ZSlcbiAgICAgICAgICAgICAgICA6IFwibnVsbFwiO1xuXG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG5cbi8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVsbCwgY29udmVydCBpdCB0byBhIHN0cmluZy4gTm90ZTpcbi8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgXCJudWxsXCIuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbi8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuXG4vLyBJZiB0aGUgdHlwZSBpcyBcIm9iamVjdFwiLCB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggYW4gb2JqZWN0IG9yIGFuIGFycmF5IG9yXG4vLyBudWxsLlxuXG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcblxuLy8gRHVlIHRvIGEgc3BlY2lmaWNhdGlvbiBibHVuZGVyIGluIEVDTUFTY3JpcHQsIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsXG4vLyBzbyB3YXRjaCBvdXQgZm9yIHRoYXQgY2FzZS5cblxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICAgIH1cblxuLy8gTWFrZSBhbiBhcnJheSB0byBob2xkIHRoZSBwYXJ0aWFsIHJlc3VsdHMgb2Ygc3RyaW5naWZ5aW5nIHRoaXMgb2JqZWN0IHZhbHVlLlxuXG4gICAgICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuXG4vLyBJcyB0aGUgdmFsdWUgYW4gYXJyYXk/XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cbi8vIFRoZSB2YWx1ZSBpcyBhbiBhcnJheS4gU3RyaW5naWZ5IGV2ZXJ5IGVsZW1lbnQuIFVzZSBudWxsIGFzIGEgcGxhY2Vob2xkZXJcbi8vIGZvciBub24tSlNPTiB2YWx1ZXMuXG5cbiAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8IFwibnVsbFwiO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZCB3cmFwIHRoZW0gaW5cbi8vIGJyYWNrZXRzLlxuXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgICAgID8gXCJbXVwiXG4gICAgICAgICAgICAgICAgICAgIDogZ2FwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiW1xcblwiICsgZ2FwICsgcGFydGlhbC5qb2luKFwiLFxcblwiICsgZ2FwKSArIFwiXFxuXCIgKyBtaW5kICsgXCJdXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJbXCIgKyBwYXJ0aWFsLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlIHN0cmluZ2lmaWVkLlxuXG4gICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcFtpXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgayA9IHJlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIjogXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCI6XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4vLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cblxuICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiOiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjpcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG5cbiAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgID8gXCJ7fVwiXG4gICAgICAgICAgICAgICAgOiBnYXBcbiAgICAgICAgICAgICAgICAgICAgPyBcIntcXG5cIiArIGdhcCArIHBhcnRpYWwuam9pbihcIixcXG5cIiArIGdhcCkgKyBcIlxcblwiICsgbWluZCArIFwifVwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJ7XCIgKyBwYXJ0aWFsLmpvaW4oXCIsXCIpICsgXCJ9XCI7XG4gICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICB9XG5cbi8vIElmIHRoZSBKU09OIG9iamVjdCBkb2VzIG5vdCB5ZXQgaGF2ZSBhIHN0cmluZ2lmeSBtZXRob2QsIGdpdmUgaXQgb25lLlxuXG4gICAgaWYgKHR5cGVvZiBKU09OLnN0cmluZ2lmeSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG1ldGEgPSB7ICAgIC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICAgICBcIlxcYlwiOiBcIlxcXFxiXCIsXG4gICAgICAgICAgICBcIlxcdFwiOiBcIlxcXFx0XCIsXG4gICAgICAgICAgICBcIlxcblwiOiBcIlxcXFxuXCIsXG4gICAgICAgICAgICBcIlxcZlwiOiBcIlxcXFxmXCIsXG4gICAgICAgICAgICBcIlxcclwiOiBcIlxcXFxyXCIsXG4gICAgICAgICAgICBcIlxcXCJcIjogXCJcXFxcXFxcIlwiLFxuICAgICAgICAgICAgXCJcXFxcXCI6IFwiXFxcXFxcXFxcIlxuICAgICAgICB9O1xuICAgICAgICBKU09OLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG5cbi8vIFRoZSBzdHJpbmdpZnkgbWV0aG9kIHRha2VzIGEgdmFsdWUgYW5kIGFuIG9wdGlvbmFsIHJlcGxhY2VyLCBhbmQgYW4gb3B0aW9uYWxcbi8vIHNwYWNlIHBhcmFtZXRlciwgYW5kIHJldHVybnMgYSBKU09OIHRleHQuIFRoZSByZXBsYWNlciBjYW4gYmUgYSBmdW5jdGlvblxuLy8gdGhhdCBjYW4gcmVwbGFjZSB2YWx1ZXMsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCB3aWxsIHNlbGVjdCB0aGUga2V5cy5cbi8vIEEgZGVmYXVsdCByZXBsYWNlciBtZXRob2QgY2FuIGJlIHByb3ZpZGVkLiBVc2Ugb2YgdGhlIHNwYWNlIHBhcmFtZXRlciBjYW5cbi8vIHByb2R1Y2UgdGV4dCB0aGF0IGlzIG1vcmUgZWFzaWx5IHJlYWRhYmxlLlxuXG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGdhcCA9IFwiXCI7XG4gICAgICAgICAgICBpbmRlbnQgPSBcIlwiO1xuXG4vLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCBtYWtlIGFuIGluZGVudCBzdHJpbmcgY29udGFpbmluZyB0aGF0XG4vLyBtYW55IHNwYWNlcy5cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSBcIiBcIjtcbiAgICAgICAgICAgICAgICB9XG5cbi8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5kZW50IHN0cmluZy5cblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpbmRlbnQgPSBzcGFjZTtcbiAgICAgICAgICAgIH1cblxuLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxuLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cblxuICAgICAgICAgICAgcmVwID0gcmVwbGFjZXI7XG4gICAgICAgICAgICBpZiAocmVwbGFjZXIgJiYgdHlwZW9mIHJlcGxhY2VyICE9PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiByZXBsYWNlciAhPT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVwbGFjZXIubGVuZ3RoICE9PSBcIm51bWJlclwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpTT04uc3RyaW5naWZ5XCIpO1xuICAgICAgICAgICAgfVxuXG4vLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mIFwiXCIuXG4vLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuXG4gICAgICAgICAgICByZXR1cm4gc3RyKFwiXCIsIHtcIlwiOiB2YWx1ZX0pO1xuICAgICAgICB9O1xuICAgIH1cblxuXG4vLyBJZiB0aGUgSlNPTiBvYmplY3QgZG9lcyBub3QgeWV0IGhhdmUgYSBwYXJzZSBtZXRob2QsIGdpdmUgaXQgb25lLlxuXG4gICAgaWYgKHR5cGVvZiBKU09OLnBhcnNlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgSlNPTi5wYXJzZSA9IGZ1bmN0aW9uICh0ZXh0LCByZXZpdmVyKSB7XG5cbi8vIFRoZSBwYXJzZSBtZXRob2QgdGFrZXMgYSB0ZXh0IGFuZCBhbiBvcHRpb25hbCByZXZpdmVyIGZ1bmN0aW9uLCBhbmQgcmV0dXJuc1xuLy8gYSBKYXZhU2NyaXB0IHZhbHVlIGlmIHRoZSB0ZXh0IGlzIGEgdmFsaWQgSlNPTiB0ZXh0LlxuXG4gICAgICAgICAgICB2YXIgajtcblxuICAgICAgICAgICAgZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuXG4vLyBUaGUgd2FsayBtZXRob2QgaXMgdXNlZCB0byByZWN1cnNpdmVseSB3YWxrIHRoZSByZXN1bHRpbmcgc3RydWN0dXJlIHNvXG4vLyB0aGF0IG1vZGlmaWNhdGlvbnMgY2FuIGJlIG1hZGUuXG5cbiAgICAgICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgICAgICB2YXIgdjtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gd2Fsayh2YWx1ZSwgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV2aXZlci5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cblxuLy8gUGFyc2luZyBoYXBwZW5zIGluIGZvdXIgc3RhZ2VzLiBJbiB0aGUgZmlyc3Qgc3RhZ2UsIHdlIHJlcGxhY2UgY2VydGFpblxuLy8gVW5pY29kZSBjaGFyYWN0ZXJzIHdpdGggZXNjYXBlIHNlcXVlbmNlcy4gSmF2YVNjcmlwdCBoYW5kbGVzIG1hbnkgY2hhcmFjdGVyc1xuLy8gaW5jb3JyZWN0bHksIGVpdGhlciBzaWxlbnRseSBkZWxldGluZyB0aGVtLCBvciB0cmVhdGluZyB0aGVtIGFzIGxpbmUgZW5kaW5ncy5cblxuICAgICAgICAgICAgdGV4dCA9IFN0cmluZyh0ZXh0KTtcbiAgICAgICAgICAgIHJ4X2Rhbmdlcm91cy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKHJ4X2Rhbmdlcm91cy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyeF9kYW5nZXJvdXMsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIjAwMDBcIiArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuLy8gSW4gdGhlIHNlY29uZCBzdGFnZSwgd2UgcnVuIHRoZSB0ZXh0IGFnYWluc3QgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IGxvb2tcbi8vIGZvciBub24tSlNPTiBwYXR0ZXJucy4gV2UgYXJlIGVzcGVjaWFsbHkgY29uY2VybmVkIHdpdGggXCIoKVwiIGFuZCBcIm5ld1wiXG4vLyBiZWNhdXNlIHRoZXkgY2FuIGNhdXNlIGludm9jYXRpb24sIGFuZCBcIj1cIiBiZWNhdXNlIGl0IGNhbiBjYXVzZSBtdXRhdGlvbi5cbi8vIEJ1dCBqdXN0IHRvIGJlIHNhZmUsIHdlIHdhbnQgdG8gcmVqZWN0IGFsbCB1bmV4cGVjdGVkIGZvcm1zLlxuXG4vLyBXZSBzcGxpdCB0aGUgc2Vjb25kIHN0YWdlIGludG8gNCByZWdleHAgb3BlcmF0aW9ucyBpbiBvcmRlciB0byB3b3JrIGFyb3VuZFxuLy8gY3JpcHBsaW5nIGluZWZmaWNpZW5jaWVzIGluIElFJ3MgYW5kIFNhZmFyaSdzIHJlZ2V4cCBlbmdpbmVzLiBGaXJzdCB3ZVxuLy8gcmVwbGFjZSB0aGUgSlNPTiBiYWNrc2xhc2ggcGFpcnMgd2l0aCBcIkBcIiAoYSBub24tSlNPTiBjaGFyYWN0ZXIpLiBTZWNvbmQsIHdlXG4vLyByZXBsYWNlIGFsbCBzaW1wbGUgdmFsdWUgdG9rZW5zIHdpdGggXCJdXCIgY2hhcmFjdGVycy4gVGhpcmQsIHdlIGRlbGV0ZSBhbGxcbi8vIG9wZW4gYnJhY2tldHMgdGhhdCBmb2xsb3cgYSBjb2xvbiBvciBjb21tYSBvciB0aGF0IGJlZ2luIHRoZSB0ZXh0LiBGaW5hbGx5LFxuLy8gd2UgbG9vayB0byBzZWUgdGhhdCB0aGUgcmVtYWluaW5nIGNoYXJhY3RlcnMgYXJlIG9ubHkgd2hpdGVzcGFjZSBvciBcIl1cIiBvclxuLy8gXCIsXCIgb3IgXCI6XCIgb3IgXCJ7XCIgb3IgXCJ9XCIuIElmIHRoYXQgaXMgc28sIHRoZW4gdGhlIHRleHQgaXMgc2FmZSBmb3IgZXZhbC5cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHJ4X29uZS50ZXN0KFxuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShyeF90d28sIFwiQFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UocnhfdGhyZWUsIFwiXVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UocnhfZm91ciwgXCJcIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcblxuLy8gSW4gdGhlIHRoaXJkIHN0YWdlIHdlIHVzZSB0aGUgZXZhbCBmdW5jdGlvbiB0byBjb21waWxlIHRoZSB0ZXh0IGludG8gYVxuLy8gSmF2YVNjcmlwdCBzdHJ1Y3R1cmUuIFRoZSBcIntcIiBvcGVyYXRvciBpcyBzdWJqZWN0IHRvIGEgc3ludGFjdGljIGFtYmlndWl0eVxuLy8gaW4gSmF2YVNjcmlwdDogaXQgY2FuIGJlZ2luIGEgYmxvY2sgb3IgYW4gb2JqZWN0IGxpdGVyYWwuIFdlIHdyYXAgdGhlIHRleHRcbi8vIGluIHBhcmVucyB0byBlbGltaW5hdGUgdGhlIGFtYmlndWl0eS5cblxuICAgICAgICAgICAgICAgIGogPSBldmFsKFwiKFwiICsgdGV4dCArIFwiKVwiKTtcblxuLy8gSW4gdGhlIG9wdGlvbmFsIGZvdXJ0aCBzdGFnZSwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSwgcGFzc2luZ1xuLy8gZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gYSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZSB0cmFuc2Zvcm1hdGlvbi5cblxuICAgICAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHJldml2ZXIgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgPyB3YWxrKHtcIlwiOiBqfSwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgOiBqO1xuICAgICAgICAgICAgfVxuXG4vLyBJZiB0aGUgdGV4dCBpcyBub3QgSlNPTiBwYXJzZWFibGUsIHRoZW4gYSBTeW50YXhFcnJvciBpcyB0aHJvd24uXG5cbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkpTT04ucGFyc2VcIik7XG4gICAgICAgIH07XG4gICAgfVxufSgpKTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG52YXIgc2xpY2UgPSB1dGlsLnNsaWNlXG52YXIgcGx1Y2sgPSB1dGlsLnBsdWNrXG52YXIgZWFjaCA9IHV0aWwuZWFjaFxudmFyIGJpbmQgPSB1dGlsLmJpbmRcbnZhciBjcmVhdGUgPSB1dGlsLmNyZWF0ZVxudmFyIGlzTGlzdCA9IHV0aWwuaXNMaXN0XG52YXIgaXNGdW5jdGlvbiA9IHV0aWwuaXNGdW5jdGlvblxudmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y3JlYXRlU3RvcmU6IGNyZWF0ZVN0b3JlXG59XG5cbnZhciBzdG9yZUFQSSA9IHtcblx0dmVyc2lvbjogJzIuMC4xMicsXG5cdGVuYWJsZWQ6IGZhbHNlLFxuXHRcblx0Ly8gZ2V0IHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBrZXkuIElmIHRoYXQgdmFsdWVcblx0Ly8gaXMgdW5kZWZpbmVkLCBpdCByZXR1cm5zIG9wdGlvbmFsRGVmYXVsdFZhbHVlIGluc3RlYWQuXG5cdGdldDogZnVuY3Rpb24oa2V5LCBvcHRpb25hbERlZmF1bHRWYWx1ZSkge1xuXHRcdHZhciBkYXRhID0gdGhpcy5zdG9yYWdlLnJlYWQodGhpcy5fbmFtZXNwYWNlUHJlZml4ICsga2V5KVxuXHRcdHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZShkYXRhLCBvcHRpb25hbERlZmF1bHRWYWx1ZSlcblx0fSxcblxuXHQvLyBzZXQgd2lsbCBzdG9yZSB0aGUgZ2l2ZW4gdmFsdWUgYXQga2V5IGFuZCByZXR1cm5zIHZhbHVlLlxuXHQvLyBDYWxsaW5nIHNldCB3aXRoIHZhbHVlID09PSB1bmRlZmluZWQgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIHJlbW92ZS5cblx0c2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLnJlbW92ZShrZXkpXG5cdFx0fVxuXHRcdHRoaXMuc3RvcmFnZS53cml0ZSh0aGlzLl9uYW1lc3BhY2VQcmVmaXggKyBrZXksIHRoaXMuX3NlcmlhbGl6ZSh2YWx1ZSkpXG5cdFx0cmV0dXJuIHZhbHVlXG5cdH0sXG5cblx0Ly8gcmVtb3ZlIGRlbGV0ZXMgdGhlIGtleSBhbmQgdmFsdWUgc3RvcmVkIGF0IHRoZSBnaXZlbiBrZXkuXG5cdHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG5cdFx0dGhpcy5zdG9yYWdlLnJlbW92ZSh0aGlzLl9uYW1lc3BhY2VQcmVmaXggKyBrZXkpXG5cdH0sXG5cblx0Ly8gZWFjaCB3aWxsIGNhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2gga2V5LXZhbHVlIHBhaXJcblx0Ly8gaW4gdGhpcyBzdG9yZS5cblx0ZWFjaDogZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHR2YXIgc2VsZiA9IHRoaXNcblx0XHR0aGlzLnN0b3JhZ2UuZWFjaChmdW5jdGlvbih2YWwsIG5hbWVzcGFjZWRLZXkpIHtcblx0XHRcdGNhbGxiYWNrLmNhbGwoc2VsZiwgc2VsZi5fZGVzZXJpYWxpemUodmFsKSwgKG5hbWVzcGFjZWRLZXkgfHwgJycpLnJlcGxhY2Uoc2VsZi5fbmFtZXNwYWNlUmVnZXhwLCAnJykpXG5cdFx0fSlcblx0fSxcblxuXHQvLyBjbGVhckFsbCB3aWxsIHJlbW92ZSBhbGwgdGhlIHN0b3JlZCBrZXktdmFsdWUgcGFpcnMgaW4gdGhpcyBzdG9yZS5cblx0Y2xlYXJBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RvcmFnZS5jbGVhckFsbCgpXG5cdH0sXG5cblx0Ly8gYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5IHRoYXQgY2FuJ3QgbGl2ZSBpbiBwbHVnaW5zXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdC8vIGhhc05hbWVzcGFjZSByZXR1cm5zIHRydWUgaWYgdGhpcyBzdG9yZSBpbnN0YW5jZSBoYXMgdGhlIGdpdmVuIG5hbWVzcGFjZS5cblx0aGFzTmFtZXNwYWNlOiBmdW5jdGlvbihuYW1lc3BhY2UpIHtcblx0XHRyZXR1cm4gKHRoaXMuX25hbWVzcGFjZVByZWZpeCA9PSAnX19zdG9yZWpzXycrbmFtZXNwYWNlKydfJylcblx0fSxcblxuXHQvLyBjcmVhdGVTdG9yZSBjcmVhdGVzIGEgc3RvcmUuanMgaW5zdGFuY2Ugd2l0aCB0aGUgZmlyc3Rcblx0Ly8gZnVuY3Rpb25pbmcgc3RvcmFnZSBpbiB0aGUgbGlzdCBvZiBzdG9yYWdlIGNhbmRpZGF0ZXMsXG5cdC8vIGFuZCBhcHBsaWVzIHRoZSB0aGUgZ2l2ZW4gbWl4aW5zIHRvIHRoZSBpbnN0YW5jZS5cblx0Y3JlYXRlU3RvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBjcmVhdGVTdG9yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG5cdH0sXG5cdFxuXHRhZGRQbHVnaW46IGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdHRoaXMuX2FkZFBsdWdpbihwbHVnaW4pXG5cdH0sXG5cdFxuXHRuYW1lc3BhY2U6IGZ1bmN0aW9uKG5hbWVzcGFjZSkge1xuXHRcdHJldHVybiBjcmVhdGVTdG9yZSh0aGlzLnN0b3JhZ2UsIHRoaXMucGx1Z2lucywgbmFtZXNwYWNlKVxuXHR9XG59XG5cbmZ1bmN0aW9uIF93YXJuKCkge1xuXHR2YXIgX2NvbnNvbGUgPSAodHlwZW9mIGNvbnNvbGUgPT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogY29uc29sZSlcblx0aWYgKCFfY29uc29sZSkgeyByZXR1cm4gfVxuXHR2YXIgZm4gPSAoX2NvbnNvbGUud2FybiA/IF9jb25zb2xlLndhcm4gOiBfY29uc29sZS5sb2cpXG5cdGZuLmFwcGx5KF9jb25zb2xlLCBhcmd1bWVudHMpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHN0b3JhZ2VzLCBwbHVnaW5zLCBuYW1lc3BhY2UpIHtcblx0aWYgKCFuYW1lc3BhY2UpIHtcblx0XHRuYW1lc3BhY2UgPSAnJ1xuXHR9XG5cdGlmIChzdG9yYWdlcyAmJiAhaXNMaXN0KHN0b3JhZ2VzKSkge1xuXHRcdHN0b3JhZ2VzID0gW3N0b3JhZ2VzXVxuXHR9XG5cdGlmIChwbHVnaW5zICYmICFpc0xpc3QocGx1Z2lucykpIHtcblx0XHRwbHVnaW5zID0gW3BsdWdpbnNdXG5cdH1cblxuXHR2YXIgbmFtZXNwYWNlUHJlZml4ID0gKG5hbWVzcGFjZSA/ICdfX3N0b3JlanNfJytuYW1lc3BhY2UrJ18nIDogJycpXG5cdHZhciBuYW1lc3BhY2VSZWdleHAgPSAobmFtZXNwYWNlID8gbmV3IFJlZ0V4cCgnXicrbmFtZXNwYWNlUHJlZml4KSA6IG51bGwpXG5cdHZhciBsZWdhbE5hbWVzcGFjZXMgPSAvXlthLXpBLVowLTlfXFwtXSokLyAvLyBhbHBoYS1udW1lcmljICsgdW5kZXJzY29yZSBhbmQgZGFzaFxuXHRpZiAoIWxlZ2FsTmFtZXNwYWNlcy50ZXN0KG5hbWVzcGFjZSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ3N0b3JlLmpzIG5hbWVzcGFjZXMgY2FuIG9ubHkgaGF2ZSBhbHBoYW51bWVyaWNzICsgdW5kZXJzY29yZXMgYW5kIGRhc2hlcycpXG5cdH1cblx0XG5cdHZhciBfcHJpdmF0ZVN0b3JlUHJvcHMgPSB7XG5cdFx0X25hbWVzcGFjZVByZWZpeDogbmFtZXNwYWNlUHJlZml4LFxuXHRcdF9uYW1lc3BhY2VSZWdleHA6IG5hbWVzcGFjZVJlZ2V4cCxcblxuXHRcdF90ZXN0U3RvcmFnZTogZnVuY3Rpb24oc3RvcmFnZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHRlc3RTdHIgPSAnX19zdG9yZWpzX190ZXN0X18nXG5cdFx0XHRcdHN0b3JhZ2Uud3JpdGUodGVzdFN0ciwgdGVzdFN0cilcblx0XHRcdFx0dmFyIG9rID0gKHN0b3JhZ2UucmVhZCh0ZXN0U3RyKSA9PT0gdGVzdFN0cilcblx0XHRcdFx0c3RvcmFnZS5yZW1vdmUodGVzdFN0cilcblx0XHRcdFx0cmV0dXJuIG9rXG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9hc3NpZ25QbHVnaW5GblByb3A6IGZ1bmN0aW9uKHBsdWdpbkZuUHJvcCwgcHJvcE5hbWUpIHtcblx0XHRcdHZhciBvbGRGbiA9IHRoaXNbcHJvcE5hbWVdXG5cdFx0XHR0aGlzW3Byb3BOYW1lXSA9IGZ1bmN0aW9uIHBsdWdpbkZuKCkge1xuXHRcdFx0XHR2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMClcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzXG5cblx0XHRcdFx0Ly8gc3VwZXJfZm4gY2FsbHMgdGhlIG9sZCBmdW5jdGlvbiB3aGljaCB3YXMgb3ZlcndyaXR0ZW4gYnlcblx0XHRcdFx0Ly8gdGhpcyBtaXhpbi5cblx0XHRcdFx0ZnVuY3Rpb24gc3VwZXJfZm4oKSB7XG5cdFx0XHRcdFx0aWYgKCFvbGRGbikgeyByZXR1cm4gfVxuXHRcdFx0XHRcdGVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihhcmcsIGkpIHtcblx0XHRcdFx0XHRcdGFyZ3NbaV0gPSBhcmdcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdHJldHVybiBvbGRGbi5hcHBseShzZWxmLCBhcmdzKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2l2ZSBtaXhpbmcgZnVuY3Rpb24gYWNjZXNzIHRvIHN1cGVyX2ZuIGJ5IHByZWZpeGluZyBhbGwgbWl4aW4gZnVuY3Rpb25cblx0XHRcdFx0Ly8gYXJndW1lbnRzIHdpdGggc3VwZXJfZm4uXG5cdFx0XHRcdHZhciBuZXdGbkFyZ3MgPSBbc3VwZXJfZm5dLmNvbmNhdChhcmdzKVxuXG5cdFx0XHRcdHJldHVybiBwbHVnaW5GblByb3AuYXBwbHkoc2VsZiwgbmV3Rm5BcmdzKVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfc2VyaWFsaXplOiBmdW5jdGlvbihvYmopIHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopXG5cdFx0fSxcblxuXHRcdF9kZXNlcmlhbGl6ZTogZnVuY3Rpb24oc3RyVmFsLCBkZWZhdWx0VmFsKSB7XG5cdFx0XHRpZiAoIXN0clZhbCkgeyByZXR1cm4gZGVmYXVsdFZhbCB9XG5cdFx0XHQvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IGEgcmF3IHN0cmluZyB2YWx1ZSBoYXMgYmVlbiBwcmV2aW91c2x5IHN0b3JlZFxuXHRcdFx0Ly8gaW4gYSBzdG9yYWdlIHdpdGhvdXQgdXNpbmcgc3RvcmUuanMsIG1lYW5pbmcgaXQgd2lsbCBiZSBhIHJhd1xuXHRcdFx0Ly8gc3RyaW5nIHZhbHVlIGluc3RlYWQgb2YgYSBKU09OIHNlcmlhbGl6ZWQgc3RyaW5nLiBCeSBkZWZhdWx0aW5nXG5cdFx0XHQvLyB0byB0aGUgcmF3IHN0cmluZyB2YWx1ZSBpbiBjYXNlIG9mIGEgSlNPTiBwYXJzZSBlcnJvciwgd2UgYWxsb3dcblx0XHRcdC8vIGZvciBwYXN0IHN0b3JlZCB2YWx1ZXMgdG8gYmUgZm9yd2FyZHMtY29tcGF0aWJsZSB3aXRoIHN0b3JlLmpzXG5cdFx0XHR2YXIgdmFsID0gJydcblx0XHRcdHRyeSB7IHZhbCA9IEpTT04ucGFyc2Uoc3RyVmFsKSB9XG5cdFx0XHRjYXRjaChlKSB7IHZhbCA9IHN0clZhbCB9XG5cblx0XHRcdHJldHVybiAodmFsICE9PSB1bmRlZmluZWQgPyB2YWwgOiBkZWZhdWx0VmFsKVxuXHRcdH0sXG5cdFx0XG5cdFx0X2FkZFN0b3JhZ2U6IGZ1bmN0aW9uKHN0b3JhZ2UpIHtcblx0XHRcdGlmICh0aGlzLmVuYWJsZWQpIHsgcmV0dXJuIH1cblx0XHRcdGlmICh0aGlzLl90ZXN0U3RvcmFnZShzdG9yYWdlKSkge1xuXHRcdFx0XHR0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlXG5cdFx0XHRcdHRoaXMuZW5hYmxlZCA9IHRydWVcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2FkZFBsdWdpbjogZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXNcblxuXHRcdFx0Ly8gSWYgdGhlIHBsdWdpbiBpcyBhbiBhcnJheSwgdGhlbiBhZGQgYWxsIHBsdWdpbnMgaW4gdGhlIGFycmF5LlxuXHRcdFx0Ly8gVGhpcyBhbGxvd3MgZm9yIGEgcGx1Z2luIHRvIGRlcGVuZCBvbiBvdGhlciBwbHVnaW5zLlxuXHRcdFx0aWYgKGlzTGlzdChwbHVnaW4pKSB7XG5cdFx0XHRcdGVhY2gocGx1Z2luLCBmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdFx0XHRzZWxmLl9hZGRQbHVnaW4ocGx1Z2luKVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiBhbGwgcGx1Z2lucyB3ZSd2ZSBzZWVuIHNvIGZhciwgc28gdGhhdCB3ZVxuXHRcdFx0Ly8gZG9uJ3QgYWRkIGFueSBvZiB0aGVtIHR3aWNlLlxuXHRcdFx0dmFyIHNlZW5QbHVnaW4gPSBwbHVjayh0aGlzLnBsdWdpbnMsIGZ1bmN0aW9uKHNlZW5QbHVnaW4pIHtcblx0XHRcdFx0cmV0dXJuIChwbHVnaW4gPT09IHNlZW5QbHVnaW4pXG5cdFx0XHR9KVxuXHRcdFx0aWYgKHNlZW5QbHVnaW4pIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBsdWdpbnMucHVzaChwbHVnaW4pXG5cblx0XHRcdC8vIENoZWNrIHRoYXQgdGhlIHBsdWdpbiBpcyBwcm9wZXJseSBmb3JtZWRcblx0XHRcdGlmICghaXNGdW5jdGlvbihwbHVnaW4pKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignUGx1Z2lucyBtdXN0IGJlIGZ1bmN0aW9uIHZhbHVlcyB0aGF0IHJldHVybiBvYmplY3RzJylcblx0XHRcdH1cblxuXHRcdFx0dmFyIHBsdWdpblByb3BlcnRpZXMgPSBwbHVnaW4uY2FsbCh0aGlzKVxuXHRcdFx0aWYgKCFpc09iamVjdChwbHVnaW5Qcm9wZXJ0aWVzKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BsdWdpbnMgbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9mIGZ1bmN0aW9uIHByb3BlcnRpZXMnKVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdGhlIHBsdWdpbiBmdW5jdGlvbiBwcm9wZXJ0aWVzIHRvIHRoaXMgc3RvcmUgaW5zdGFuY2UuXG5cdFx0XHRlYWNoKHBsdWdpblByb3BlcnRpZXMsIGZ1bmN0aW9uKHBsdWdpbkZuUHJvcCwgcHJvcE5hbWUpIHtcblx0XHRcdFx0aWYgKCFpc0Z1bmN0aW9uKHBsdWdpbkZuUHJvcCkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0JhZCBwbHVnaW4gcHJvcGVydHk6ICcrcHJvcE5hbWUrJyBmcm9tIHBsdWdpbiAnK3BsdWdpbi5uYW1lKycuIFBsdWdpbnMgc2hvdWxkIG9ubHkgcmV0dXJuIGZ1bmN0aW9ucy4nKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuX2Fzc2lnblBsdWdpbkZuUHJvcChwbHVnaW5GblByb3AsIHByb3BOYW1lKVxuXHRcdFx0fSlcblx0XHR9LFxuXHRcdFxuXHRcdC8vIFB1dCBkZXByZWNhdGVkIHByb3BlcnRpZXMgaW4gdGhlIHByaXZhdGUgQVBJLCBzbyBhcyB0byBub3QgZXhwb3NlIGl0IHRvIGFjY2lkZW50aWFsXG5cdFx0Ly8gZGlzY292ZXJ5IHRocm91Z2ggaW5zcGVjdGlvbiBvZiB0aGUgc3RvcmUgb2JqZWN0LlxuXHRcdFxuXHRcdC8vIERlcHJlY2F0ZWQ6IGFkZFN0b3JhZ2Vcblx0XHRhZGRTdG9yYWdlOiBmdW5jdGlvbihzdG9yYWdlKSB7XG5cdFx0XHRfd2Fybignc3RvcmUuYWRkU3RvcmFnZShzdG9yYWdlKSBpcyBkZXByZWNhdGVkLiBVc2UgY3JlYXRlU3RvcmUoW3N0b3JhZ2VzXSknKVxuXHRcdFx0dGhpcy5fYWRkU3RvcmFnZShzdG9yYWdlKVxuXHRcdH1cblx0fVxuXG5cdHZhciBzdG9yZSA9IGNyZWF0ZShfcHJpdmF0ZVN0b3JlUHJvcHMsIHN0b3JlQVBJLCB7XG5cdFx0cGx1Z2luczogW11cblx0fSlcblx0c3RvcmUucmF3ID0ge31cblx0ZWFjaChzdG9yZSwgZnVuY3Rpb24ocHJvcCwgcHJvcE5hbWUpIHtcblx0XHRpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuXHRcdFx0c3RvcmUucmF3W3Byb3BOYW1lXSA9IGJpbmQoc3RvcmUsIHByb3ApXHRcdFx0XG5cdFx0fVxuXHR9KVxuXHRlYWNoKHN0b3JhZ2VzLCBmdW5jdGlvbihzdG9yYWdlKSB7XG5cdFx0c3RvcmUuX2FkZFN0b3JhZ2Uoc3RvcmFnZSlcblx0fSlcblx0ZWFjaChwbHVnaW5zLCBmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRzdG9yZS5fYWRkUGx1Z2luKHBsdWdpbilcblx0fSlcblx0cmV0dXJuIHN0b3JlXG59XG4iLCJ2YXIgYXNzaWduID0gbWFrZV9hc3NpZ24oKVxudmFyIGNyZWF0ZSA9IG1ha2VfY3JlYXRlKClcbnZhciB0cmltID0gbWFrZV90cmltKClcbnZhciBHbG9iYWwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRhc3NpZ246IGFzc2lnbixcblx0Y3JlYXRlOiBjcmVhdGUsXG5cdHRyaW06IHRyaW0sXG5cdGJpbmQ6IGJpbmQsXG5cdHNsaWNlOiBzbGljZSxcblx0ZWFjaDogZWFjaCxcblx0bWFwOiBtYXAsXG5cdHBsdWNrOiBwbHVjayxcblx0aXNMaXN0OiBpc0xpc3QsXG5cdGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG5cdGlzT2JqZWN0OiBpc09iamVjdCxcblx0R2xvYmFsOiBHbG9iYWxcbn1cblxuZnVuY3Rpb24gbWFrZV9hc3NpZ24oKSB7XG5cdGlmIChPYmplY3QuYXNzaWduKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ25cblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2hpbUFzc2lnbihvYmosIHByb3BzMSwgcHJvcHMyLCBldGMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGVhY2goT2JqZWN0KGFyZ3VtZW50c1tpXSksIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cdFx0XHRcdFx0b2JqW2tleV0gPSB2YWxcblx0XHRcdFx0fSlcblx0XHRcdH1cdFx0XHRcblx0XHRcdHJldHVybiBvYmpcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbWFrZV9jcmVhdGUoKSB7XG5cdGlmIChPYmplY3QuY3JlYXRlKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZShvYmosIGFzc2lnblByb3BzMSwgYXNzaWduUHJvcHMyLCBldGMpIHtcblx0XHRcdHZhciBhc3NpZ25BcmdzTGlzdCA9IHNsaWNlKGFyZ3VtZW50cywgMSlcblx0XHRcdHJldHVybiBhc3NpZ24uYXBwbHkodGhpcywgW09iamVjdC5jcmVhdGUob2JqKV0uY29uY2F0KGFzc2lnbkFyZ3NMaXN0KSlcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0ZnVuY3Rpb24gRigpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW5uZXItZGVjbGFyYXRpb25zXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZShvYmosIGFzc2lnblByb3BzMSwgYXNzaWduUHJvcHMyLCBldGMpIHtcblx0XHRcdHZhciBhc3NpZ25BcmdzTGlzdCA9IHNsaWNlKGFyZ3VtZW50cywgMSlcblx0XHRcdEYucHJvdG90eXBlID0gb2JqXG5cdFx0XHRyZXR1cm4gYXNzaWduLmFwcGx5KHRoaXMsIFtuZXcgRigpXS5jb25jYXQoYXNzaWduQXJnc0xpc3QpKVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBtYWtlX3RyaW0oKSB7XG5cdGlmIChTdHJpbmcucHJvdG90eXBlLnRyaW0pIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gdHJpbShzdHIpIHtcblx0XHRcdHJldHVybiBTdHJpbmcucHJvdG90eXBlLnRyaW0uY2FsbChzdHIpXG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBmdW5jdGlvbiB0cmltKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGJpbmQob2JqLCBmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KG9iaiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSlcblx0fVxufVxuXG5mdW5jdGlvbiBzbGljZShhcnIsIGluZGV4KSB7XG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIsIGluZGV4IHx8IDApXG59XG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBmbikge1xuXHRwbHVjayhvYmosIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cdFx0Zm4odmFsLCBrZXkpXG5cdFx0cmV0dXJuIGZhbHNlXG5cdH0pXG59XG5cbmZ1bmN0aW9uIG1hcChvYmosIGZuKSB7XG5cdHZhciByZXMgPSAoaXNMaXN0KG9iaikgPyBbXSA6IHt9KVxuXHRwbHVjayhvYmosIGZ1bmN0aW9uKHYsIGspIHtcblx0XHRyZXNba10gPSBmbih2LCBrKVxuXHRcdHJldHVybiBmYWxzZVxuXHR9KVxuXHRyZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHBsdWNrKG9iaiwgZm4pIHtcblx0aWYgKGlzTGlzdChvYmopKSB7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPG9iai5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGZuKG9ialtpXSwgaSkpIHtcblx0XHRcdFx0cmV0dXJuIG9ialtpXVxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdFx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0aWYgKGZuKG9ialtrZXldLCBrZXkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9ialtrZXldXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gaXNMaXN0KHZhbCkge1xuXHRyZXR1cm4gKHZhbCAhPSBudWxsICYmIHR5cGVvZiB2YWwgIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsLmxlbmd0aCA9PSAnbnVtYmVyJylcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcblx0cmV0dXJuIHZhbCAmJiB7fS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG5cdHJldHVybiB2YWwgJiYge30udG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBbXG5cdC8vIExpc3RlZCBpbiBvcmRlciBvZiB1c2FnZSBwcmVmZXJlbmNlXG5cdHJlcXVpcmUoJy4vbG9jYWxTdG9yYWdlJyksXG5cdHJlcXVpcmUoJy4vb2xkRkYtZ2xvYmFsU3RvcmFnZScpLFxuXHRyZXF1aXJlKCcuL29sZElFLXVzZXJEYXRhU3RvcmFnZScpLFxuXHRyZXF1aXJlKCcuL2Nvb2tpZVN0b3JhZ2UnKSxcblx0cmVxdWlyZSgnLi9zZXNzaW9uU3RvcmFnZScpLFxuXHRyZXF1aXJlKCcuL21lbW9yeVN0b3JhZ2UnKVxuXVxuIiwiLy8gY29va2llU3RvcmFnZSBpcyB1c2VmdWwgU2FmYXJpIHByaXZhdGUgYnJvd3NlciBtb2RlLCB3aGVyZSBsb2NhbFN0b3JhZ2Vcbi8vIGRvZXNuJ3Qgd29yayBidXQgY29va2llcyBkby4gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBhZG9wdGVkIGZyb21cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdG9yYWdlL0xvY2FsU3RvcmFnZVxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxudmFyIHRyaW0gPSB1dGlsLnRyaW1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6ICdjb29raWVTdG9yYWdlJyxcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlLFxuXHRlYWNoOiBlYWNoLFxuXHRyZW1vdmU6IHJlbW92ZSxcblx0Y2xlYXJBbGw6IGNsZWFyQWxsLFxufVxuXG52YXIgZG9jID0gR2xvYmFsLmRvY3VtZW50XG5cbmZ1bmN0aW9uIHJlYWQoa2V5KSB7XG5cdGlmICgha2V5IHx8ICFfaGFzKGtleSkpIHsgcmV0dXJuIG51bGwgfVxuXHR2YXIgcmVnZXhwU3RyID0gXCIoPzpefC4qO1xcXFxzKilcIiArXG5cdFx0ZXNjYXBlKGtleSkucmVwbGFjZSgvW1xcLVxcLlxcK1xcKl0vZywgXCJcXFxcJCZcIikgK1xuXHRcdFwiXFxcXHMqXFxcXD1cXFxccyooKD86W147XSg/ITspKSpbXjtdPykuKlwiXG5cdHJldHVybiB1bmVzY2FwZShkb2MuY29va2llLnJlcGxhY2UobmV3IFJlZ0V4cChyZWdleHBTdHIpLCBcIiQxXCIpKVxufVxuXG5mdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG5cdHZhciBjb29raWVzID0gZG9jLmNvb2tpZS5zcGxpdCgvOyA/L2cpXG5cdGZvciAodmFyIGkgPSBjb29raWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0aWYgKCF0cmltKGNvb2tpZXNbaV0pKSB7XG5cdFx0XHRjb250aW51ZVxuXHRcdH1cblx0XHR2YXIga3ZwID0gY29va2llc1tpXS5zcGxpdCgnPScpXG5cdFx0dmFyIGtleSA9IHVuZXNjYXBlKGt2cFswXSlcblx0XHR2YXIgdmFsID0gdW5lc2NhcGUoa3ZwWzFdKVxuXHRcdGNhbGxiYWNrKHZhbCwga2V5KVxuXHR9XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgZGF0YSkge1xuXHRpZigha2V5KSB7IHJldHVybiB9XG5cdGRvYy5jb29raWUgPSBlc2NhcGUoa2V5KSArIFwiPVwiICsgZXNjYXBlKGRhdGEpICsgXCI7IGV4cGlyZXM9VHVlLCAxOSBKYW4gMjAzOCAwMzoxNDowNyBHTVQ7IHBhdGg9L1wiXG59XG5cbmZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcblx0aWYgKCFrZXkgfHwgIV9oYXMoa2V5KSkge1xuXHRcdHJldHVyblxuXHR9XG5cdGRvYy5jb29raWUgPSBlc2NhcGUoa2V5KSArIFwiPTsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIEdNVDsgcGF0aD0vXCJcbn1cblxuZnVuY3Rpb24gY2xlYXJBbGwoKSB7XG5cdGVhY2goZnVuY3Rpb24oXywga2V5KSB7XG5cdFx0cmVtb3ZlKGtleSlcblx0fSlcbn1cblxuZnVuY3Rpb24gX2hhcyhrZXkpIHtcblx0cmV0dXJuIChuZXcgUmVnRXhwKFwiKD86Xnw7XFxcXHMqKVwiICsgZXNjYXBlKGtleSkucmVwbGFjZSgvW1xcLVxcLlxcK1xcKl0vZywgXCJcXFxcJCZcIikgKyBcIlxcXFxzKlxcXFw9XCIpKS50ZXN0KGRvYy5jb29raWUpXG59XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ2xvY2FsU3RvcmFnZScsXG5cdHJlYWQ6IHJlYWQsXG5cdHdyaXRlOiB3cml0ZSxcblx0ZWFjaDogZWFjaCxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGNsZWFyQWxsOiBjbGVhckFsbCxcbn1cblxuZnVuY3Rpb24gbG9jYWxTdG9yYWdlKCkge1xuXHRyZXR1cm4gR2xvYmFsLmxvY2FsU3RvcmFnZVxufVxuXG5mdW5jdGlvbiByZWFkKGtleSkge1xuXHRyZXR1cm4gbG9jYWxTdG9yYWdlKCkuZ2V0SXRlbShrZXkpXG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgZGF0YSkge1xuXHRyZXR1cm4gbG9jYWxTdG9yYWdlKCkuc2V0SXRlbShrZXksIGRhdGEpXG59XG5cbmZ1bmN0aW9uIGVhY2goZm4pIHtcblx0Zm9yICh2YXIgaSA9IGxvY2FsU3RvcmFnZSgpLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0dmFyIGtleSA9IGxvY2FsU3RvcmFnZSgpLmtleShpKVxuXHRcdGZuKHJlYWQoa2V5KSwga2V5KVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcblx0cmV0dXJuIGxvY2FsU3RvcmFnZSgpLnJlbW92ZUl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0cmV0dXJuIGxvY2FsU3RvcmFnZSgpLmNsZWFyKClcbn1cbiIsIi8vIG1lbW9yeVN0b3JhZ2UgaXMgYSB1c2VmdWwgbGFzdCBmYWxsYmFjayB0byBlbnN1cmUgdGhhdCB0aGUgc3RvcmVcbi8vIGlzIGZ1bmN0aW9ucyAobWVhbmluZyBzdG9yZS5nZXQoKSwgc3RvcmUuc2V0KCksIGV0YyB3aWxsIGFsbCBmdW5jdGlvbikuXG4vLyBIb3dldmVyLCBzdG9yZWQgdmFsdWVzIHdpbGwgbm90IHBlcnNpc3Qgd2hlbiB0aGUgYnJvd3NlciBuYXZpZ2F0ZXMgdG9cbi8vIGEgbmV3IHBhZ2Ugb3IgcmVsb2FkcyB0aGUgY3VycmVudCBwYWdlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ21lbW9yeVN0b3JhZ2UnLFxuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGUsXG5cdGVhY2g6IGVhY2gsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRjbGVhckFsbDogY2xlYXJBbGwsXG59XG5cbnZhciBtZW1vcnlTdG9yYWdlID0ge31cblxuZnVuY3Rpb24gcmVhZChrZXkpIHtcblx0cmV0dXJuIG1lbW9yeVN0b3JhZ2Vba2V5XVxufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIGRhdGEpIHtcblx0bWVtb3J5U3RvcmFnZVtrZXldID0gZGF0YVxufVxuXG5mdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG5cdGZvciAodmFyIGtleSBpbiBtZW1vcnlTdG9yYWdlKSB7XG5cdFx0aWYgKG1lbW9yeVN0b3JhZ2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0Y2FsbGJhY2sobWVtb3J5U3RvcmFnZVtrZXldLCBrZXkpXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcblx0ZGVsZXRlIG1lbW9yeVN0b3JhZ2Vba2V5XVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbChrZXkpIHtcblx0bWVtb3J5U3RvcmFnZSA9IHt9XG59XG4iLCIvLyBvbGRGRi1nbG9iYWxTdG9yYWdlIHByb3ZpZGVzIHN0b3JhZ2UgZm9yIEZpcmVmb3hcbi8vIHZlcnNpb25zIDYgYW5kIDcsIHdoZXJlIG5vIGxvY2FsU3RvcmFnZSwgZXRjXG4vLyBpcyBhdmFpbGFibGUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKVxudmFyIEdsb2JhbCA9IHV0aWwuR2xvYmFsXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRuYW1lOiAnb2xkRkYtZ2xvYmFsU3RvcmFnZScsXG5cdHJlYWQ6IHJlYWQsXG5cdHdyaXRlOiB3cml0ZSxcblx0ZWFjaDogZWFjaCxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGNsZWFyQWxsOiBjbGVhckFsbCxcbn1cblxudmFyIGdsb2JhbFN0b3JhZ2UgPSBHbG9iYWwuZ2xvYmFsU3RvcmFnZVxuXG5mdW5jdGlvbiByZWFkKGtleSkge1xuXHRyZXR1cm4gZ2xvYmFsU3RvcmFnZVtrZXldXG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgZGF0YSkge1xuXHRnbG9iYWxTdG9yYWdlW2tleV0gPSBkYXRhXG59XG5cbmZ1bmN0aW9uIGVhY2goZm4pIHtcblx0Zm9yICh2YXIgaSA9IGdsb2JhbFN0b3JhZ2UubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHR2YXIga2V5ID0gZ2xvYmFsU3RvcmFnZS5rZXkoaSlcblx0XHRmbihnbG9iYWxTdG9yYWdlW2tleV0sIGtleSlcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdHJldHVybiBnbG9iYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxufVxuXG5mdW5jdGlvbiBjbGVhckFsbCgpIHtcblx0ZWFjaChmdW5jdGlvbihrZXksIF8pIHtcblx0XHRkZWxldGUgZ2xvYmFsU3RvcmFnZVtrZXldXG5cdH0pXG59XG4iLCIvLyBvbGRJRS11c2VyRGF0YVN0b3JhZ2UgcHJvdmlkZXMgc3RvcmFnZSBmb3IgSW50ZXJuZXQgRXhwbG9yZXJcbi8vIHZlcnNpb25zIDYgYW5kIDcsIHdoZXJlIG5vIGxvY2FsU3RvcmFnZSwgc2Vzc2lvblN0b3JhZ2UsIGV0Y1xuLy8gaXMgYXZhaWxhYmxlLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJylcbnZhciBHbG9iYWwgPSB1dGlsLkdsb2JhbFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0bmFtZTogJ29sZElFLXVzZXJEYXRhU3RvcmFnZScsXG5cdHdyaXRlOiB3cml0ZSxcblx0cmVhZDogcmVhZCxcblx0ZWFjaDogZWFjaCxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGNsZWFyQWxsOiBjbGVhckFsbCxcbn1cblxudmFyIHN0b3JhZ2VOYW1lID0gJ3N0b3JlanMnXG52YXIgZG9jID0gR2xvYmFsLmRvY3VtZW50XG52YXIgX3dpdGhTdG9yYWdlRWwgPSBfbWFrZUlFU3RvcmFnZUVsRnVuY3Rpb24oKVxudmFyIGRpc2FibGUgPSAoR2xvYmFsLm5hdmlnYXRvciA/IEdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50IDogJycpLm1hdGNoKC8gKE1TSUUgOHxNU0lFIDl8TVNJRSAxMClcXC4vKSAvLyBNU0lFIDkueCwgTVNJRSAxMC54XG5cbmZ1bmN0aW9uIHdyaXRlKHVuZml4ZWRLZXksIGRhdGEpIHtcblx0aWYgKGRpc2FibGUpIHsgcmV0dXJuIH1cblx0dmFyIGZpeGVkS2V5ID0gZml4S2V5KHVuZml4ZWRLZXkpXG5cdF93aXRoU3RvcmFnZUVsKGZ1bmN0aW9uKHN0b3JhZ2VFbCkge1xuXHRcdHN0b3JhZ2VFbC5zZXRBdHRyaWJ1dGUoZml4ZWRLZXksIGRhdGEpXG5cdFx0c3RvcmFnZUVsLnNhdmUoc3RvcmFnZU5hbWUpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIHJlYWQodW5maXhlZEtleSkge1xuXHRpZiAoZGlzYWJsZSkgeyByZXR1cm4gfVxuXHR2YXIgZml4ZWRLZXkgPSBmaXhLZXkodW5maXhlZEtleSlcblx0dmFyIHJlcyA9IG51bGxcblx0X3dpdGhTdG9yYWdlRWwoZnVuY3Rpb24oc3RvcmFnZUVsKSB7XG5cdFx0cmVzID0gc3RvcmFnZUVsLmdldEF0dHJpYnV0ZShmaXhlZEtleSlcblx0fSlcblx0cmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG5cdF93aXRoU3RvcmFnZUVsKGZ1bmN0aW9uKHN0b3JhZ2VFbCkge1xuXHRcdHZhciBhdHRyaWJ1dGVzID0gc3RvcmFnZUVsLlhNTERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRyaWJ1dGVzXG5cdFx0Zm9yICh2YXIgaT1hdHRyaWJ1dGVzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciBhdHRyID0gYXR0cmlidXRlc1tpXVxuXHRcdFx0Y2FsbGJhY2soc3RvcmFnZUVsLmdldEF0dHJpYnV0ZShhdHRyLm5hbWUpLCBhdHRyLm5hbWUpXG5cdFx0fVxuXHR9KVxufVxuXG5mdW5jdGlvbiByZW1vdmUodW5maXhlZEtleSkge1xuXHR2YXIgZml4ZWRLZXkgPSBmaXhLZXkodW5maXhlZEtleSlcblx0X3dpdGhTdG9yYWdlRWwoZnVuY3Rpb24oc3RvcmFnZUVsKSB7XG5cdFx0c3RvcmFnZUVsLnJlbW92ZUF0dHJpYnV0ZShmaXhlZEtleSlcblx0XHRzdG9yYWdlRWwuc2F2ZShzdG9yYWdlTmFtZSlcblx0fSlcbn1cblxuZnVuY3Rpb24gY2xlYXJBbGwoKSB7XG5cdF93aXRoU3RvcmFnZUVsKGZ1bmN0aW9uKHN0b3JhZ2VFbCkge1xuXHRcdHZhciBhdHRyaWJ1dGVzID0gc3RvcmFnZUVsLlhNTERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRyaWJ1dGVzXG5cdFx0c3RvcmFnZUVsLmxvYWQoc3RvcmFnZU5hbWUpXG5cdFx0Zm9yICh2YXIgaT1hdHRyaWJ1dGVzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHN0b3JhZ2VFbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlc1tpXS5uYW1lKVxuXHRcdH1cblx0XHRzdG9yYWdlRWwuc2F2ZShzdG9yYWdlTmFtZSlcblx0fSlcbn1cblxuLy8gSGVscGVyc1xuLy8vLy8vLy8vL1xuXG4vLyBJbiBJRTcsIGtleXMgY2Fubm90IHN0YXJ0IHdpdGggYSBkaWdpdCBvciBjb250YWluIGNlcnRhaW4gY2hhcnMuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcmN1c3dlc3Rpbi9zdG9yZS5qcy9pc3N1ZXMvNDBcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFyY3Vzd2VzdGluL3N0b3JlLmpzL2lzc3Vlcy84M1xudmFyIGZvcmJpZGRlbkNoYXJzUmVnZXggPSBuZXcgUmVnRXhwKFwiWyFcXFwiIyQlJicoKSorLC9cXFxcXFxcXDo7PD0+P0BbXFxcXF1eYHt8fX5dXCIsIFwiZ1wiKVxuZnVuY3Rpb24gZml4S2V5KGtleSkge1xuXHRyZXR1cm4ga2V5LnJlcGxhY2UoL15cXGQvLCAnX19fJCYnKS5yZXBsYWNlKGZvcmJpZGRlbkNoYXJzUmVnZXgsICdfX18nKVxufVxuXG5mdW5jdGlvbiBfbWFrZUlFU3RvcmFnZUVsRnVuY3Rpb24oKSB7XG5cdGlmICghZG9jIHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50LmFkZEJlaGF2aW9yKSB7XG5cdFx0cmV0dXJuIG51bGxcblx0fVxuXHR2YXIgc2NyaXB0VGFnID0gJ3NjcmlwdCcsXG5cdFx0c3RvcmFnZU93bmVyLFxuXHRcdHN0b3JhZ2VDb250YWluZXIsXG5cdFx0c3RvcmFnZUVsXG5cblx0Ly8gU2luY2UgI3VzZXJEYXRhIHN0b3JhZ2UgYXBwbGllcyBvbmx5IHRvIHNwZWNpZmljIHBhdGhzLCB3ZSBuZWVkIHRvXG5cdC8vIHNvbWVob3cgbGluayBvdXIgZGF0YSB0byBhIHNwZWNpZmljIHBhdGguICBXZSBjaG9vc2UgL2Zhdmljb24uaWNvXG5cdC8vIGFzIGEgcHJldHR5IHNhZmUgb3B0aW9uLCBzaW5jZSBhbGwgYnJvd3NlcnMgYWxyZWFkeSBtYWtlIGEgcmVxdWVzdCB0b1xuXHQvLyB0aGlzIFVSTCBhbnl3YXkgYW5kIGJlaW5nIGEgNDA0IHdpbGwgbm90IGh1cnQgdXMgaGVyZS4gIFdlIHdyYXAgYW5cblx0Ly8gaWZyYW1lIHBvaW50aW5nIHRvIHRoZSBmYXZpY29uIGluIGFuIEFjdGl2ZVhPYmplY3QoaHRtbGZpbGUpIG9iamVjdFxuXHQvLyAoc2VlOiBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvYWE3NTI1NzQodj1WUy44NSkuYXNweClcblx0Ly8gc2luY2UgdGhlIGlmcmFtZSBhY2Nlc3MgcnVsZXMgYXBwZWFyIHRvIGFsbG93IGRpcmVjdCBhY2Nlc3MgYW5kXG5cdC8vIG1hbmlwdWxhdGlvbiBvZiB0aGUgZG9jdW1lbnQgZWxlbWVudCwgZXZlbiBmb3IgYSA0MDQgcGFnZS4gIFRoaXNcblx0Ly8gZG9jdW1lbnQgY2FuIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBkb2N1bWVudCAod2hpY2ggd291bGRcblx0Ly8gaGF2ZSBiZWVuIGxpbWl0ZWQgdG8gdGhlIGN1cnJlbnQgcGF0aCkgdG8gcGVyZm9ybSAjdXNlckRhdGEgc3RvcmFnZS5cblx0dHJ5IHtcblx0XHQvKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAqL1xuXHRcdHN0b3JhZ2VDb250YWluZXIgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKVxuXHRcdHN0b3JhZ2VDb250YWluZXIub3BlbigpXG5cdFx0c3RvcmFnZUNvbnRhaW5lci53cml0ZSgnPCcrc2NyaXB0VGFnKyc+ZG9jdW1lbnQudz13aW5kb3c8Lycrc2NyaXB0VGFnKyc+PGlmcmFtZSBzcmM9XCIvZmF2aWNvbi5pY29cIj48L2lmcmFtZT4nKVxuXHRcdHN0b3JhZ2VDb250YWluZXIuY2xvc2UoKVxuXHRcdHN0b3JhZ2VPd25lciA9IHN0b3JhZ2VDb250YWluZXIudy5mcmFtZXNbMF0uZG9jdW1lbnRcblx0XHRzdG9yYWdlRWwgPSBzdG9yYWdlT3duZXIuY3JlYXRlRWxlbWVudCgnZGl2Jylcblx0fSBjYXRjaChlKSB7XG5cdFx0Ly8gc29tZWhvdyBBY3RpdmVYT2JqZWN0IGluc3RhbnRpYXRpb24gZmFpbGVkIChwZXJoYXBzIHNvbWUgc3BlY2lhbFxuXHRcdC8vIHNlY3VyaXR5IHNldHRpbmdzIG9yIG90aGVyd3NlKSwgZmFsbCBiYWNrIHRvIHBlci1wYXRoIHN0b3JhZ2Vcblx0XHRzdG9yYWdlRWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jylcblx0XHRzdG9yYWdlT3duZXIgPSBkb2MuYm9keVxuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHN0b3JlRnVuY3Rpb24pIHtcblx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuXHRcdGFyZ3MudW5zaGlmdChzdG9yYWdlRWwpXG5cdFx0Ly8gU2VlIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMTA4MSh2PVZTLjg1KS5hc3B4XG5cdFx0Ly8gYW5kIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMTQyNCh2PVZTLjg1KS5hc3B4XG5cdFx0c3RvcmFnZU93bmVyLmFwcGVuZENoaWxkKHN0b3JhZ2VFbClcblx0XHRzdG9yYWdlRWwuYWRkQmVoYXZpb3IoJyNkZWZhdWx0I3VzZXJEYXRhJylcblx0XHRzdG9yYWdlRWwubG9hZChzdG9yYWdlTmFtZSlcblx0XHRzdG9yZUZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpXG5cdFx0c3RvcmFnZU93bmVyLnJlbW92ZUNoaWxkKHN0b3JhZ2VFbClcblx0XHRyZXR1cm5cblx0fVxufVxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi9zcmMvdXRpbCcpXG52YXIgR2xvYmFsID0gdXRpbC5HbG9iYWxcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdG5hbWU6ICdzZXNzaW9uU3RvcmFnZScsXG5cdHJlYWQ6IHJlYWQsXG5cdHdyaXRlOiB3cml0ZSxcblx0ZWFjaDogZWFjaCxcblx0cmVtb3ZlOiByZW1vdmUsXG5cdGNsZWFyQWxsOiBjbGVhckFsbFxufVxuXG5mdW5jdGlvbiBzZXNzaW9uU3RvcmFnZSgpIHtcblx0cmV0dXJuIEdsb2JhbC5zZXNzaW9uU3RvcmFnZVxufVxuXG5mdW5jdGlvbiByZWFkKGtleSkge1xuXHRyZXR1cm4gc2Vzc2lvblN0b3JhZ2UoKS5nZXRJdGVtKGtleSlcbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBkYXRhKSB7XG5cdHJldHVybiBzZXNzaW9uU3RvcmFnZSgpLnNldEl0ZW0oa2V5LCBkYXRhKVxufVxuXG5mdW5jdGlvbiBlYWNoKGZuKSB7XG5cdGZvciAodmFyIGkgPSBzZXNzaW9uU3RvcmFnZSgpLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0dmFyIGtleSA9IHNlc3Npb25TdG9yYWdlKCkua2V5KGkpXG5cdFx0Zm4ocmVhZChrZXkpLCBrZXkpXG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuXHRyZXR1cm4gc2Vzc2lvblN0b3JhZ2UoKS5yZW1vdmVJdGVtKGtleSlcbn1cblxuZnVuY3Rpb24gY2xlYXJBbGwoKSB7XG5cdHJldHVybiBzZXNzaW9uU3RvcmFnZSgpLmNsZWFyKClcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbmZvckVhY2gob2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pXG4gICAgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59KTtcblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpXG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3MubmV4dFRpY2sodGhpcy5lbmQuYmluZCh0aGlzKSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuaWYgKCFFRS5saXN0ZW5lckNvdW50KSBFRS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogMTYgKiAxMDI0O1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gZmFsc2U7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIEluIHN0cmVhbXMgdGhhdCBuZXZlciBoYXZlIGFueSBkYXRhLCBhbmQgZG8gcHVzaChudWxsKSByaWdodCBhd2F5LFxuICAvLyB0aGUgY29uc3VtZXIgY2FuIG1pc3MgdGhlICdlbmQnIGV2ZW50IGlmIHRoZXkgZG8gc29tZSBJL08gYmVmb3JlXG4gIC8vIGNvbnN1bWluZyB0aGUgc3RyZWFtLiAgU28sIHdlIGRvbid0IGVtaXQoJ2VuZCcpIHVudGlsIHNvbWUgcmVhZGluZ1xuICAvLyBoYXBwZW5zLlxuICB0aGlzLmNhbGxlZFJlYWQgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjdWFzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuXG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKVxuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKVxuICAgICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZylcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKVxuICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuXG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICAoc3RhdGUubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKG4gPT09IG51bGwgfHwgaXNOYU4obikpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5jYWxsZWRSZWFkID0gdHJ1ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgdmFyIHJldDtcblxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgcmV0ID0gbnVsbDtcblxuICAgIC8vIEluIGNhc2VzIHdoZXJlIHRoZSBkZWNvZGVyIGRpZCBub3QgcmVjZWl2ZSBlbm91Z2ggZGF0YVxuICAgIC8vIHRvIHByb2R1Y2UgYSBmdWxsIGNodW5rLCB0aGVuIGltbWVkaWF0ZWx5IHJlY2VpdmVkIGFuXG4gICAgLy8gRU9GLCBzdGF0ZS5idWZmZXIgd2lsbCBjb250YWluIFs8QnVmZmVyID4sIDxCdWZmZXIgMDAgLi4uPl0uXG4gICAgLy8gaG93TXVjaFRvUmVhZCB3aWxsIHNlZSB0aGlzIGFuZCBjb2VyY2UgdGhlIGFtb3VudCB0b1xuICAgIC8vIHJlYWQgdG8gemVybyAoYmVjYXVzZSBpdCdzIGxvb2tpbmcgYXQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAvLyBmaXJzdCA8QnVmZmVyID4gaW4gc3RhdGUuYnVmZmVyKSwgYW5kIHdlJ2xsIGVuZCB1cCBoZXJlLlxuICAgIC8vXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gdmlhIHN0YXRlLmRlY29kZXIgLS0gbm8gb3RoZXIgdmVudWVcbiAgICAvLyBleGlzdHMgZm9yIHB1c2hpbmcgYSB6ZXJvLWxlbmd0aCBjaHVuayBpbnRvIHN0YXRlLmJ1ZmZlclxuICAgIC8vIGFuZCB0cmlnZ2VyaW5nIHRoaXMgYmVoYXZpb3IuIEluIHRoaXMgY2FzZSwgd2UgcmV0dXJuIG91clxuICAgIC8vIHJlbWFpbmluZyBkYXRhIGFuZCBlbmQgdGhlIHN0cmVhbSwgaWYgYXBwcm9wcmlhdGUuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA+IDAgJiYgc3RhdGUuZGVjb2Rlcikge1xuICAgICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICAgICAgc3RhdGUubGVuZ3RoIC09IHJldC5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoIC0gbiA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIGRvUmVhZCA9IHRydWU7XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZylcbiAgICBkb1JlYWQgPSBmYWxzZTtcblxuICBpZiAoZG9SZWFkKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBjYWxsZWQgaXRzIGNhbGxiYWNrIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgXG4gIC8vIHdpbGwgYmUgZmFsc2UsIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2VcbiAgLy8gY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZylcbiAgICBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuXG4gIGlmIChuID4gMClcbiAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gIGVsc2VcbiAgICByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyBJZiB3ZSBoYXBwZW5lZCB0byByZWFkKCkgZXhhY3RseSB0aGUgcmVtYWluaW5nIGFtb3VudCBpbiB0aGVcbiAgLy8gYnVmZmVyLCBhbmQgdGhlIEVPRiBoYXMgYmVlbiBzZWVuIGF0IHRoaXMgcG9pbnQsIHRoZW4gbWFrZSBzdXJlXG4gIC8vIHRoYXQgd2UgZW1pdCAnZW5kJyBvbiB0aGUgdmVyeSBuZXh0IHRpY2suXG4gIGlmIChzdGF0ZS5lbmRlZCAmJiAhc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAnc3RyaW5nJyAhPT0gdHlwZW9mIGNodW5rICYmXG4gICAgICBjaHVuayAhPT0gbnVsbCAmJlxuICAgICAgY2h1bmsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQgYW5kIHdlIGhhdmUgc29tZSBkYXRhIGxlZnQsIHRoZW4gZW1pdFxuICAvLyAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICBlbHNlXG4gICAgZW5kUmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSlcbiAgICByZXR1cm47XG5cbiAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLnN5bmMpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9KTtcbiAgZWxzZVxuICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICAgIGVsc2VcbiAgICAgIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZClcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtcbiAgZWxzZVxuICAgIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGlmIChyZWFkYWJsZSAhPT0gc3JjKSByZXR1cm47XG4gICAgY2xlYW51cCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pXG4gICAgICBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcbiAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgLy8gVGhpcyBpcyBhIGJydXRhbGx5IHVnbHkgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlclxuICAvLyBpcyBhdHRhY2hlZCBiZWZvcmUgYW55IHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLlxuICBpZiAoIWRlc3QuX2V2ZW50cyB8fCAhZGVzdC5fZXZlbnRzLmVycm9yKVxuICAgIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGVsc2UgaWYgKGlzQXJyYXkoZGVzdC5fZXZlbnRzLmVycm9yKSlcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IudW5zaGlmdChvbmVycm9yKTtcbiAgZWxzZVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvciA9IFtvbmVycm9yLCBkZXN0Ll9ldmVudHMuZXJyb3JdO1xuXG5cblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gdGhlIGhhbmRsZXIgdGhhdCB3YWl0cyBmb3IgcmVhZGFibGUgZXZlbnRzIGFmdGVyIGFsbFxuICAgIC8vIHRoZSBkYXRhIGdldHMgc3Vja2VkIG91dCBpbiBmbG93LlxuICAgIC8vIFRoaXMgd291bGQgYmUgZWFzaWVyIHRvIGZvbGxvdyB3aXRoIGEgLm9uY2UoKSBoYW5kbGVyXG4gICAgLy8gaW4gZmxvdygpLCBidXQgdGhhdCBpcyB0b28gc2xvdy5cbiAgICB0aGlzLm9uKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcblxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlc3QgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDApXG4gICAgICBmbG93KHNyYyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZsb3coc3JjKSB7XG4gIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIGNodW5rO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcblxuICBmdW5jdGlvbiB3cml0ZShkZXN0LCBpLCBsaXN0KSB7XG4gICAgdmFyIHdyaXR0ZW4gPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHdyaXR0ZW4pIHtcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoc3RhdGUucGlwZXNDb3VudCAmJiBudWxsICE9PSAoY2h1bmsgPSBzcmMucmVhZCgpKSkge1xuXG4gICAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgICB3cml0ZShzdGF0ZS5waXBlcywgMCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgZm9yRWFjaChzdGF0ZS5waXBlcywgd3JpdGUpO1xuXG4gICAgc3JjLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG5cbiAgICAvLyBpZiBhbnlvbmUgbmVlZHMgYSBkcmFpbiwgdGhlbiB3ZSBoYXZlIHRvIHdhaXQgZm9yIHRoYXQuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPiAwKVxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaWYgZXZlcnkgZGVzdGluYXRpb24gd2FzIHVucGlwZWQsIGVpdGhlciBiZWZvcmUgZW50ZXJpbmcgdGhpc1xuICAvLyBmdW5jdGlvbiwgb3IgaW4gdGhlIHdoaWxlIGxvb3AsIHRoZW4gc3RvcCBmbG93aW5nLlxuICAvL1xuICAvLyBOQjogVGhpcyBpcyBhIHByZXR0eSByYXJlIGVkZ2UgY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICAvLyBpZiB0aGVyZSB3ZXJlIGRhdGEgZXZlbnQgbGlzdGVuZXJzIGFkZGVkLCB0aGVuIHN3aXRjaCB0byBvbGQgbW9kZS5cbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykgPiAwKVxuICAgICAgZW1pdERhdGFFdmVudHMoc3JjKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50LCBubyBvbmUgbmVlZGVkIGEgZHJhaW4sIHNvIHdlIGp1c3QgcmFuIG91dCBvZiBkYXRhXG4gIC8vIG9uIHRoZSBuZXh0IHJlYWRhYmxlIGV2ZW50LCBzdGFydCBpdCBvdmVyIGFnYWluLlxuICBzdGF0ZS5yYW5PdXQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBwaXBlT25SZWFkYWJsZSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUucmFuT3V0KSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yYW5PdXQgPSBmYWxzZTtcbiAgICBmbG93KHRoaXMpO1xuICB9XG59XG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcylcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KVxuICAgICAgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgcGlwZU9uUmVhZGFibGUpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdClcbiAgICAgIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3JlYWRhYmxlJywgcGlwZU9uUmVhZGFibGUpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpID09PSAtMSlcbiAgICByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZylcbiAgICBlbWl0RGF0YUV2ZW50cyh0aGlzKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpcy5yZWFkYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHRoaXMucmVhZCgwKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgZW1pdERhdGFFdmVudHModGhpcyk7XG4gIHRoaXMucmVhZCgwKTtcbiAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBlbWl0RGF0YUV2ZW50cyh0aGlzLCB0cnVlKTtcbiAgdGhpcy5lbWl0KCdwYXVzZScpO1xufTtcblxuZnVuY3Rpb24gZW1pdERhdGFFdmVudHMoc3RyZWFtLCBzdGFydFBhdXNlZCkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL3JlYWRhYmxlLXN0cmVhbS9pc3N1ZXMvMTZcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzd2l0Y2ggdG8gb2xkIG1vZGUgbm93LicpO1xuICB9XG5cbiAgdmFyIHBhdXNlZCA9IHN0YXJ0UGF1c2VkIHx8IGZhbHNlO1xuICB2YXIgcmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBjb252ZXJ0IHRvIGFuIG9sZC1zdHlsZSBzdHJlYW0uXG4gIHN0cmVhbS5yZWFkYWJsZSA9IHRydWU7XG4gIHN0cmVhbS5waXBlID0gU3RyZWFtLnByb3RvdHlwZS5waXBlO1xuICBzdHJlYW0ub24gPSBzdHJlYW0uYWRkTGlzdGVuZXIgPSBTdHJlYW0ucHJvdG90eXBlLm9uO1xuXG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBmdW5jdGlvbigpIHtcbiAgICByZWFkYWJsZSA9IHRydWU7XG5cbiAgICB2YXIgYztcbiAgICB3aGlsZSAoIXBhdXNlZCAmJiAobnVsbCAhPT0gKGMgPSBzdHJlYW0ucmVhZCgpKSkpXG4gICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGMpO1xuXG4gICAgaWYgKGMgPT09IG51bGwpIHtcbiAgICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdHJlYW0uX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHN0cmVhbS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9O1xuXG4gIHN0cmVhbS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICBpZiAocmVhZGFibGUpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIHRoaXMucmVhZCgwKTtcbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xuICB9O1xuXG4gIC8vIG5vdyBtYWtlIGl0IHN0YXJ0LCBqdXN0IGluIGNhc2UgaXQgaGFkbid0IGFscmVhZHkuXG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpXG4gICAgICAgIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKVxuICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIC8vaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKVxuICAgICAgcmV0dXJuO1xuICAgIGVsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgdGhpc1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgfX0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5jYWxsZWRSZWFkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLl9mbHVzaClcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IDE2ICogMTAyNDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjdWFzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBjaHVuayAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgdmFyIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IGZ1bmN0aW9uKCkge307XG5cbiAgaWYgKHN0YXRlLmVuZGVkKVxuICAgIHdyaXRlQWZ0ZXJFbmQodGhpcywgc3RhdGUsIGNiKTtcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSlcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpXG4gICAgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZylcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgaWYgKHN5bmMpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgZWxzZVxuICAgIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcilcbiAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtcbiAgZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZClcbiAgICBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIGNiKCk7XG4gIGlmIChmaW5pc2hlZClcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspIHtcbiAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgYysrO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBpZiAoYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgc3RhdGUuYnVmZmVyID0gc3RhdGUuYnVmZmVyLnNsaWNlKGMpO1xuICBlbHNlXG4gICAgc3RhdGUuYnVmZmVyLmxlbmd0aCA9IDA7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3VuZGVmaW5lZCcgJiYgY2h1bmsgIT09IG51bGwpXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmVuZGluZyAmJlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAgICFzdGF0ZS53cml0aW5nKTtcbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZClcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IpO1xuICAgIGVsc2VcbiAgICAgIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0nKVxuICAsIGluaGVyaXRzICA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xuICAsIHh0ZW5kICAgICA9IHJlcXVpcmUoJ3h0ZW5kJylcblxuZnVuY3Rpb24gRGVzdHJveWFibGVUcmFuc2Zvcm0ob3B0cykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRzKVxuICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZVxufVxuXG5pbmhlcml0cyhEZXN0cm95YWJsZVRyYW5zZm9ybSwgVHJhbnNmb3JtKVxuXG5EZXN0cm95YWJsZVRyYW5zZm9ybS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZVxuICBcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgaWYgKGVycilcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgc2VsZi5lbWl0KCdjbG9zZScpXG4gIH0pXG59XG5cbi8vIGEgbm9vcCBfdHJhbnNmb3JtIGZ1bmN0aW9uXG5mdW5jdGlvbiBub29wIChjaHVuaywgZW5jLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhudWxsLCBjaHVuaylcbn1cblxuXG4vLyBjcmVhdGUgYSBuZXcgZXhwb3J0IGZ1bmN0aW9uLCB1c2VkIGJ5IGJvdGggdGhlIG1haW4gZXhwb3J0IGFuZFxuLy8gdGhlIC5jdG9yIGV4cG9ydCwgY29udGFpbnMgY29tbW9uIGxvZ2ljIGZvciBkZWFsaW5nIHdpdGggYXJndW1lbnRzXG5mdW5jdGlvbiB0aHJvdWdoMiAoY29uc3RydWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmbHVzaCAgICAgPSB0cmFuc2Zvcm1cbiAgICAgIHRyYW5zZm9ybSA9IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgICA9IHt9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gIT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRyYW5zZm9ybSA9IG5vb3BcblxuICAgIGlmICh0eXBlb2YgZmx1c2ggIT0gJ2Z1bmN0aW9uJylcbiAgICAgIGZsdXNoID0gbnVsbFxuXG4gICAgcmV0dXJuIGNvbnN0cnVjdChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKVxuICB9XG59XG5cblxuLy8gbWFpbiBleHBvcnQsIGp1c3QgbWFrZSBtZSBhIHRyYW5zZm9ybSBzdHJlYW0hXG5tb2R1bGUuZXhwb3J0cyA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIHZhciB0MiA9IG5ldyBEZXN0cm95YWJsZVRyYW5zZm9ybShvcHRpb25zKVxuXG4gIHQyLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgdDIuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gdDJcbn0pXG5cblxuLy8gbWFrZSBtZSBhIHJldXNhYmxlIHByb3RvdHlwZSB0aGF0IEkgY2FuIGBuZXdgLCBvciBpbXBsaWNpdGx5IGBuZXdgXG4vLyB3aXRoIGEgY29uc3RydWN0b3IgY2FsbFxubW9kdWxlLmV4cG9ydHMuY3RvciA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIGZ1bmN0aW9uIFRocm91Z2gyIChvdmVycmlkZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUaHJvdWdoMikpXG4gICAgICByZXR1cm4gbmV3IFRocm91Z2gyKG92ZXJyaWRlKVxuXG4gICAgdGhpcy5vcHRpb25zID0geHRlbmQob3B0aW9ucywgb3ZlcnJpZGUpXG5cbiAgICBEZXN0cm95YWJsZVRyYW5zZm9ybS5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIGluaGVyaXRzKFRocm91Z2gyLCBEZXN0cm95YWJsZVRyYW5zZm9ybSlcblxuICBUaHJvdWdoMi5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICBUaHJvdWdoMi5wcm90b3R5cGUuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gVGhyb3VnaDJcbn0pXG5cblxubW9kdWxlLmV4cG9ydHMub2JqID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgdmFyIHQyID0gbmV3IERlc3Ryb3lhYmxlVHJhbnNmb3JtKHh0ZW5kKHsgb2JqZWN0TW9kZTogdHJ1ZSwgaGlnaFdhdGVyTWFyazogMTYgfSwgb3B0aW9ucykpXG5cbiAgdDIuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICB0Mi5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiB0MlxufSlcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYnVmKSB7XG5cdC8vIElmIHRoZSBidWZmZXIgaXMgYmFja2VkIGJ5IGEgVWludDhBcnJheSwgYSBmYXN0ZXIgdmVyc2lvbiB3aWxsIHdvcmtcblx0aWYgKGJ1ZiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcblx0XHQvLyBJZiB0aGUgYnVmZmVyIGlzbid0IGEgc3ViYXJyYXksIHJldHVybiB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlclxuXHRcdGlmIChidWYuYnl0ZU9mZnNldCA9PT0gMCAmJiBidWYuYnl0ZUxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gYnVmLmJ1ZmZlclxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGJ1Zi5idWZmZXIuc2xpY2UgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIGdldCBhIHByb3BlciBjb3B5XG5cdFx0XHRyZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aClcblx0XHR9XG5cdH1cblxuXHRpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcblx0XHQvLyBUaGlzIGlzIHRoZSBzbG93IHZlcnNpb24gdGhhdCB3aWxsIHdvcmsgd2l0aCBhbnkgQnVmZmVyXG5cdFx0Ly8gaW1wbGVtZW50YXRpb24gKGV2ZW4gaW4gb2xkIGJyb3dzZXJzKVxuXHRcdHZhciBhcnJheUNvcHkgPSBuZXcgVWludDhBcnJheShidWYubGVuZ3RoKVxuXHRcdHZhciBsZW4gPSBidWYubGVuZ3RoXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0YXJyYXlDb3B5W2ldID0gYnVmW2ldXG5cdFx0fVxuXHRcdHJldHVybiBhcnJheUNvcHkuYnVmZmVyXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcblx0fVxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2MVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInYzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92Mi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInY0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92My5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInY1XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92NC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5JTFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfbmlsLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdmVyc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbGlkYXRlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92YWxpZGF0ZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3BhcnNlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3YxLmpzXCIpKTtcblxudmFyIF92MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjMuanNcIikpO1xuXG52YXIgX3YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92NC5qc1wiKSk7XG5cbnZhciBfdjQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Y1LmpzXCIpKTtcblxudmFyIF9uaWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL25pbC5qc1wiKSk7XG5cbnZhciBfdmVyc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmVyc2lvbi5qc1wiKSk7XG5cbnZhciBfdmFsaWRhdGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRlLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbnZhciBfcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLypcbiAqIEJyb3dzZXItY29tcGF0aWJsZSBKYXZhU2NyaXB0IE1ENVxuICpcbiAqIE1vZGlmaWNhdGlvbiBvZiBKYXZhU2NyaXB0IE1ENVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb25cbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KG1zZy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzW2ldID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kNVRvSGV4RW5jb2RlZEFycmF5KHdvcmRzVG9NZDUoYnl0ZXNUb1dvcmRzKGJ5dGVzKSwgYnl0ZXMubGVuZ3RoICogOCkpO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhbiBhcnJheSBvZiBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gbWQ1VG9IZXhFbmNvZGVkQXJyYXkoaW5wdXQpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGNvbnN0IGxlbmd0aDMyID0gaW5wdXQubGVuZ3RoICogMzI7XG4gIGNvbnN0IGhleFRhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDMyOyBpICs9IDgpIHtcbiAgICBjb25zdCB4ID0gaW5wdXRbaSA+PiA1XSA+Pj4gaSAlIDMyICYgMHhmZjtcbiAgICBjb25zdCBoZXggPSBwYXJzZUludChoZXhUYWIuY2hhckF0KHggPj4+IDQgJiAweDBmKSArIGhleFRhYi5jaGFyQXQoeCAmIDB4MGYpLCAxNik7XG4gICAgb3V0cHV0LnB1c2goaGV4KTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBvdXRwdXQgbGVuZ3RoIHdpdGggcGFkZGluZyBhbmQgYml0IGxlbmd0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0T3V0cHV0TGVuZ3RoKGlucHV0TGVuZ3RoOCkge1xuICByZXR1cm4gKGlucHV0TGVuZ3RoOCArIDY0ID4+PiA5IDw8IDQpICsgMTQgKyAxO1xufVxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cblxuXG5mdW5jdGlvbiB3b3Jkc1RvTWQ1KHgsIGxlbikge1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8IGxlbiAlIDMyO1xuICB4W2dldE91dHB1dExlbmd0aChsZW4pIC0gMV0gPSBsZW47XG4gIGxldCBhID0gMTczMjU4NDE5MztcbiAgbGV0IGIgPSAtMjcxNzMzODc5O1xuICBsZXQgYyA9IC0xNzMyNTg0MTk0O1xuICBsZXQgZCA9IDI3MTczMzg3ODtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgY29uc3Qgb2xkYSA9IGE7XG4gICAgY29uc3Qgb2xkYiA9IGI7XG4gICAgY29uc3Qgb2xkYyA9IGM7XG4gICAgY29uc3Qgb2xkZCA9IGQ7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE0LCA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgNF0sIDExLCAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDQsIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgNl0sIDIzLCA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuICAgIGEgPSBzYWZlQWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlQWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlQWRkKGQsIG9sZGQpO1xuICB9XG5cbiAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IGJ5dGVzIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5cblxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzKGlucHV0KSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsZW5ndGg4ID0gaW5wdXQubGVuZ3RoICogODtcbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQzMkFycmF5KGdldE91dHB1dExlbmd0aChsZW5ndGg4KSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg4OyBpICs9IDgpIHtcbiAgICBvdXRwdXRbaSA+PiA1XSB8PSAoaW5wdXRbaSAvIDhdICYgMHhmZikgPDwgaSAlIDMyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5cblxuZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gIGNvbnN0IGxzdyA9ICh4ICYgMHhmZmZmKSArICh5ICYgMHhmZmZmKTtcbiAgY29uc3QgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiBtc3cgPDwgMTYgfCBsc3cgJiAweGZmZmY7XG59XG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5cblxuZnVuY3Rpb24gYml0Um90YXRlTGVmdChudW0sIGNudCkge1xuICByZXR1cm4gbnVtIDw8IGNudCB8IG51bSA+Pj4gMzIgLSBjbnQ7XG59XG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNWNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpO1xufVxuXG5mdW5jdGlvbiBtZDVmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGMgfCB+YiAmIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGQgfCBjICYgfmQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGMgXiAoYiB8IH5kKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IG1kNTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9kZWZhdWx0ID0gJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghKDAsIF92YWxpZGF0ZS5kZWZhdWx0KSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICBsZXQgdjtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0O1xuICBhcnJbMV0gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbM10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzRdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDksIDEzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzVdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls2XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4O1xuICBhcnJbN10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XG4gIGFycls5XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTFdID0gdiAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzEyXSA9IHYgPj4+IDI0ICYgMHhmZjtcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzE0XSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbMTVdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBhcnI7XG59XG5cbnZhciBfZGVmYXVsdCA9IHBhcnNlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2RlZmF1bHQgPSAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJuZztcbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxubGV0IGdldFJhbmRvbVZhbHVlcztcbmNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuXG5mdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbiAgICAvLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbi8vIEFkYXB0ZWQgZnJvbSBDaHJpcyBWZW5lc3MnIFNIQTEgY29kZSBhdFxuLy8gaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9zaGExLmh0bWxcbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4geCAmIHkgXiB+eCAmIHo7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHggJiB5IF4geCAmIHogXiB5ICYgejtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gIH1cbn1cblxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XG4gIHJldHVybiB4IDw8IG4gfCB4ID4+PiAzMiAtIG47XG59XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgY29uc3QgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcbiAgY29uc3QgSCA9IFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXTtcblxuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlcy5wdXNoKG1zZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgLy8gQ29udmVydCBBcnJheS1saWtlIHRvIEFycmF5XG4gICAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XG4gIH1cblxuICBieXRlcy5wdXNoKDB4ODApO1xuICBjb25zdCBsID0gYnl0ZXMubGVuZ3RoIC8gNCArIDI7XG4gIGNvbnN0IE4gPSBNYXRoLmNlaWwobCAvIDE2KTtcbiAgY29uc3QgTSA9IG5ldyBBcnJheShOKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50MzJBcnJheSgxNik7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIGFycltqXSA9IGJ5dGVzW2kgKiA2NCArIGogKiA0XSA8PCAyNCB8IGJ5dGVzW2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYgfCBieXRlc1tpICogNjQgKyBqICogNCArIDJdIDw8IDggfCBieXRlc1tpICogNjQgKyBqICogNCArIDNdO1xuICAgIH1cblxuICAgIE1baV0gPSBhcnI7XG4gIH1cblxuICBNW04gLSAxXVsxNF0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4IC8gTWF0aC5wb3coMiwgMzIpO1xuICBNW04gLSAxXVsxNF0gPSBNYXRoLmZsb29yKE1bTiAtIDFdWzE0XSk7XG4gIE1bTiAtIDFdWzE1XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggJiAweGZmZmZmZmZmO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgKytpKSB7XG4gICAgY29uc3QgVyA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG5cbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDE2OyArK3QpIHtcbiAgICAgIFdbdF0gPSBNW2ldW3RdO1xuICAgIH1cblxuICAgIGZvciAobGV0IHQgPSAxNjsgdCA8IDgwOyArK3QpIHtcbiAgICAgIFdbdF0gPSBST1RMKFdbdCAtIDNdIF4gV1t0IC0gOF0gXiBXW3QgLSAxNF0gXiBXW3QgLSAxNl0sIDEpO1xuICAgIH1cblxuICAgIGxldCBhID0gSFswXTtcbiAgICBsZXQgYiA9IEhbMV07XG4gICAgbGV0IGMgPSBIWzJdO1xuICAgIGxldCBkID0gSFszXTtcbiAgICBsZXQgZSA9IEhbNF07XG5cbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDgwOyArK3QpIHtcbiAgICAgIGNvbnN0IHMgPSBNYXRoLmZsb29yKHQgLyAyMCk7XG4gICAgICBjb25zdCBUID0gUk9UTChhLCA1KSArIGYocywgYiwgYywgZCkgKyBlICsgS1tzXSArIFdbdF0gPj4+IDA7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IFJPVEwoYiwgMzApID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gVDtcbiAgICB9XG5cbiAgICBIWzBdID0gSFswXSArIGEgPj4+IDA7XG4gICAgSFsxXSA9IEhbMV0gKyBiID4+PiAwO1xuICAgIEhbMl0gPSBIWzJdICsgYyA+Pj4gMDtcbiAgICBIWzNdID0gSFszXSArIGQgPj4+IDA7XG4gICAgSFs0XSA9IEhbNF0gKyBlID4+PiAwO1xuICB9XG5cbiAgcmV0dXJuIFtIWzBdID4+IDI0ICYgMHhmZiwgSFswXSA+PiAxNiAmIDB4ZmYsIEhbMF0gPj4gOCAmIDB4ZmYsIEhbMF0gJiAweGZmLCBIWzFdID4+IDI0ICYgMHhmZiwgSFsxXSA+PiAxNiAmIDB4ZmYsIEhbMV0gPj4gOCAmIDB4ZmYsIEhbMV0gJiAweGZmLCBIWzJdID4+IDI0ICYgMHhmZiwgSFsyXSA+PiAxNiAmIDB4ZmYsIEhbMl0gPj4gOCAmIDB4ZmYsIEhbMl0gJiAweGZmLCBIWzNdID4+IDI0ICYgMHhmZiwgSFszXSA+PiAxNiAmIDB4ZmYsIEhbM10gPj4gOCAmIDB4ZmYsIEhbM10gJiAweGZmLCBIWzRdID4+IDI0ICYgMHhmZiwgSFs0XSA+PiAxNiAmIDB4ZmYsIEhbNF0gPj4gOCAmIDB4ZmYsIEhbNF0gJiAweGZmXTtcbn1cblxudmFyIF9kZWZhdWx0ID0gc2hhMTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIGNvbnN0IHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbnZhciBfZGVmYXVsdCA9IHN0cmluZ2lmeTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcbmxldCBfbm9kZUlkO1xuXG5sZXQgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBsZXQgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICBjb25zdCBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgbGV0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICBsZXQgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICBjb25zdCBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIGNvbnN0IHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgKDAsIF9zdHJpbmdpZnkuZGVmYXVsdCkoYik7XG59XG5cbnZhciBfZGVmYXVsdCA9IHYxO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjM1LmpzXCIpKTtcblxudmFyIF9tZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbWQ1LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgdjMgPSAoMCwgX3YuZGVmYXVsdCkoJ3YzJywgMHgzMCwgX21kLmRlZmF1bHQpO1xudmFyIF9kZWZhdWx0ID0gdjM7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuZXhwb3J0cy5VUkwgPSBleHBvcnRzLkROUyA9IHZvaWQgMDtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbnZhciBfcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIGNvbnN0IGJ5dGVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuY29uc3QgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnRzLkROUyA9IEROUztcbmNvbnN0IFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0cy5VUkwgPSBVUkw7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gKDAsIF9wYXJzZS5kZWZhdWx0KShuYW1lc3BhY2UpO1xuICAgIH1cblxuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfSAvLyBDb21wdXRlIGhhc2ggb2YgbmFtZXNwYWNlIGFuZCB2YWx1ZSwgUGVyIDQuM1xuICAgIC8vIEZ1dHVyZTogVXNlIHNwcmVhZCBzeW50YXggd2hlbiBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcywgZS5nLiBgYnl0ZXMgPVxuICAgIC8vIGhhc2hmdW5jKFsuLi5uYW1lc3BhY2UsIC4uLiB2YWx1ZV0pYFxuXG5cbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gICAgaWYgKGJ1Zikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9zdHJpbmdpZnkuZGVmYXVsdCkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9zdHJpbmdpZnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0cmluZ2lmeS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiAoMCwgX3N0cmluZ2lmeS5kZWZhdWx0KShybmRzKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdjQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92MzUuanNcIikpO1xuXG52YXIgX3NoYSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2hhMS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IHY1ID0gKDAsIF92LmRlZmF1bHQpKCd2NScsIDB4NTAsIF9zaGEuZGVmYXVsdCk7XG52YXIgX2RlZmF1bHQgPSB2NTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlZ2V4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZWdleC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBfcmVnZXguZGVmYXVsdC50ZXN0KHV1aWQpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2YWxpZGF0ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0ZS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHZlcnNpb24odXVpZCkge1xuICBpZiAoISgwLCBfdmFsaWRhdGUuZGVmYXVsdCkodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc3Vic3RyKDE0LCAxKSwgMTYpO1xufVxuXG52YXIgX2RlZmF1bHQgPSB2ZXJzaW9uO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4gLyogZXNsaW50LWVudiBub2RlICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gU2hpbW1pbmcgc3RhcnRzIGhlcmUuXG4oZnVuY3Rpb24oKSB7XG4gIC8vIFV0aWxzLlxuICB2YXIgbG9nZ2luZyA9IHJlcXVpcmUoJy4vdXRpbHMnKS5sb2c7XG4gIHZhciBicm93c2VyRGV0YWlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKS5icm93c2VyRGV0YWlscztcbiAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgbW9kdWxlLmV4cG9ydHMuYnJvd3NlckRldGFpbHMgPSBicm93c2VyRGV0YWlscztcbiAgbW9kdWxlLmV4cG9ydHMuZXh0cmFjdFZlcnNpb24gPSByZXF1aXJlKCcuL3V0aWxzJykuZXh0cmFjdFZlcnNpb247XG4gIG1vZHVsZS5leHBvcnRzLmRpc2FibGVMb2cgPSByZXF1aXJlKCcuL3V0aWxzJykuZGlzYWJsZUxvZztcblxuICAvLyBVbmNvbW1lbnQgdGhlIGxpbmUgYmVsb3cgaWYgeW91IHdhbnQgbG9nZ2luZyB0byBvY2N1ciwgaW5jbHVkaW5nIGxvZ2dpbmdcbiAgLy8gZm9yIHRoZSBzd2l0Y2ggc3RhdGVtZW50IGJlbG93LiBDYW4gYWxzbyBiZSB0dXJuZWQgb24gaW4gdGhlIGJyb3dzZXIgdmlhXG4gIC8vIGFkYXB0ZXIuZGlzYWJsZUxvZyhmYWxzZSksIGJ1dCB0aGVuIGxvZ2dpbmcgZnJvbSB0aGUgc3dpdGNoIHN0YXRlbWVudCBiZWxvd1xuICAvLyB3aWxsIG5vdCBhcHBlYXIuXG4gIC8vIHJlcXVpcmUoJy4vdXRpbHMnKS5kaXNhYmxlTG9nKGZhbHNlKTtcblxuICAvLyBCcm93c2VyIHNoaW1zLlxuICB2YXIgY2hyb21lU2hpbSA9IHJlcXVpcmUoJy4vY2hyb21lL2Nocm9tZV9zaGltJykgfHwgbnVsbDtcbiAgdmFyIGVkZ2VTaGltID0gcmVxdWlyZSgnLi9lZGdlL2VkZ2Vfc2hpbScpIHx8IG51bGw7XG4gIHZhciBmaXJlZm94U2hpbSA9IHJlcXVpcmUoJy4vZmlyZWZveC9maXJlZm94X3NoaW0nKSB8fCBudWxsO1xuICB2YXIgc2FmYXJpU2hpbSA9IHJlcXVpcmUoJy4vc2FmYXJpL3NhZmFyaV9zaGltJykgfHwgbnVsbDtcblxuICAvLyBTaGltIGJyb3dzZXIgaWYgZm91bmQuXG4gIHN3aXRjaCAoYnJvd3NlckRldGFpbHMuYnJvd3Nlcikge1xuICAgIGNhc2UgJ29wZXJhJzogLy8gZmFsbHRocm91Z2ggYXMgaXQgdXNlcyBjaHJvbWUgc2hpbXNcbiAgICBjYXNlICdjaHJvbWUnOlxuICAgICAgaWYgKCFjaHJvbWVTaGltIHx8ICFjaHJvbWVTaGltLnNoaW1QZWVyQ29ubmVjdGlvbikge1xuICAgICAgICBsb2dnaW5nKCdDaHJvbWUgc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgY2hyb21lLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIG1vZHVsZS5leHBvcnRzLmJyb3dzZXJTaGltID0gY2hyb21lU2hpbTtcblxuICAgICAgY2hyb21lU2hpbS5zaGltR2V0VXNlck1lZGlhKCk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1NZWRpYVN0cmVhbSgpO1xuICAgICAgY2hyb21lU2hpbS5zaGltU291cmNlT2JqZWN0KCk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1QZWVyQ29ubmVjdGlvbigpO1xuICAgICAgY2hyb21lU2hpbS5zaGltT25UcmFjaygpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZmlyZWZveCc6XG4gICAgICBpZiAoIWZpcmVmb3hTaGltIHx8ICFmaXJlZm94U2hpbS5zaGltUGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgbG9nZ2luZygnRmlyZWZveCBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBmaXJlZm94LicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIG1vZHVsZS5leHBvcnRzLmJyb3dzZXJTaGltID0gZmlyZWZveFNoaW07XG5cbiAgICAgIGZpcmVmb3hTaGltLnNoaW1HZXRVc2VyTWVkaWEoKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1Tb3VyY2VPYmplY3QoKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1QZWVyQ29ubmVjdGlvbigpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbU9uVHJhY2soKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VkZ2UnOlxuICAgICAgaWYgKCFlZGdlU2hpbSB8fCAhZWRnZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgIGxvZ2dpbmcoJ01TIGVkZ2Ugc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgZWRnZS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBtb2R1bGUuZXhwb3J0cy5icm93c2VyU2hpbSA9IGVkZ2VTaGltO1xuXG4gICAgICBlZGdlU2hpbS5zaGltR2V0VXNlck1lZGlhKCk7XG4gICAgICBlZGdlU2hpbS5zaGltUGVlckNvbm5lY3Rpb24oKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NhZmFyaSc6XG4gICAgICBpZiAoIXNhZmFyaVNoaW0pIHtcbiAgICAgICAgbG9nZ2luZygnU2FmYXJpIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIHNhZmFyaS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBtb2R1bGUuZXhwb3J0cy5icm93c2VyU2hpbSA9IHNhZmFyaVNoaW07XG5cbiAgICAgIHNhZmFyaVNoaW0uc2hpbUdldFVzZXJNZWRpYSgpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGxvZ2dpbmcoJ1Vuc3VwcG9ydGVkIGJyb3dzZXIhJyk7XG4gIH1cbn0pKCk7XG4iLCJcbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuIC8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGxvZ2dpbmcgPSByZXF1aXJlKCcuLi91dGlscy5qcycpLmxvZztcbnZhciBicm93c2VyRGV0YWlscyA9IHJlcXVpcmUoJy4uL3V0aWxzLmpzJykuYnJvd3NlckRldGFpbHM7XG5cbnZhciBjaHJvbWVTaGltID0ge1xuICBzaGltTWVkaWFTdHJlYW06IGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5NZWRpYVN0cmVhbSA9IHdpbmRvdy5NZWRpYVN0cmVhbSB8fCB3aW5kb3cud2Via2l0TWVkaWFTdHJlYW07XG4gIH0sXG5cbiAgc2hpbU9uVHJhY2s6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnb250cmFjaycgaW5cbiAgICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb250cmFjaycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb250cmFjaztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIGlmICh0aGlzLl9vbnRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29udHJhY2twb2x5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2sgPSBmKTtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29udHJhY2twb2x5ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy8gb25hZGRzdHJlYW0gZG9lcyBub3QgZmlyZSB3aGVuIGEgdHJhY2sgaXMgYWRkZWQgdG8gYW4gZXhpc3RpbmdcbiAgICAgICAgICAgIC8vIHN0cmVhbS4gQnV0IHN0cmVhbS5vbmFkZHRyYWNrIGlzIGltcGxlbWVudGVkIHNvIHdlIHVzZSB0aGF0LlxuICAgICAgICAgICAgZS5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCBmdW5jdGlvbih0ZSkge1xuICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgICAgIGV2ZW50LnRyYWNrID0gdGUudHJhY2s7XG4gICAgICAgICAgICAgIGV2ZW50LnJlY2VpdmVyID0ge3RyYWNrOiB0ZS50cmFja307XG4gICAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSB7dHJhY2s6IHRyYWNrfTtcbiAgICAgICAgICAgICAgZXZlbnQuc3RyZWFtcyA9IFtlLnN0cmVhbV07XG4gICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBzaGltU291cmNlT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh3aW5kb3cuSFRNTE1lZGlhRWxlbWVudCAmJlxuICAgICAgICAhKCdzcmNPYmplY3QnIGluIHdpbmRvdy5IVE1MTWVkaWFFbGVtZW50LnByb3RvdHlwZSkpIHtcbiAgICAgICAgLy8gU2hpbSB0aGUgc3JjT2JqZWN0IHByb3BlcnR5LCBvbmNlLCB3aGVuIEhUTUxNZWRpYUVsZW1lbnQgaXMgZm91bmQuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuSFRNTE1lZGlhRWxlbWVudC5wcm90b3R5cGUsICdzcmNPYmplY3QnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zcmNPYmplY3Q7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgLy8gVXNlIF9zcmNPYmplY3QgYXMgYSBwcml2YXRlIHByb3BlcnR5IGZvciB0aGlzIHNoaW1cbiAgICAgICAgICAgIHRoaXMuX3NyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNyYykge1xuICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMuc3JjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgICAgdGhpcy5zcmMgPSAnJztcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSk7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlY3JlYXRlIHRoZSBibG9iIHVybCB3aGVuIGEgdHJhY2sgaXMgYWRkZWQgb3JcbiAgICAgICAgICAgIC8vIHJlbW92ZWQuIERvaW5nIGl0IG1hbnVhbGx5IHNpbmNlIHdlIHdhbnQgdG8gYXZvaWQgYSByZWN1cnNpb24uXG4gICAgICAgICAgICBzdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGYuc3JjKSB7XG4gICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChzZWxmLnNyYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VsZi5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoc2VsZi5zcmMpIHtcbiAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHNlbGYuc3JjKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZWxmLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHNoaW1QZWVyQ29ubmVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgLy8gVGhlIFJUQ1BlZXJDb25uZWN0aW9uIG9iamVjdC5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSBmdW5jdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cykge1xuICAgICAgLy8gVHJhbnNsYXRlIGljZVRyYW5zcG9ydFBvbGljeSB0byBpY2VUcmFuc3BvcnRzLFxuICAgICAgLy8gc2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NDg2OVxuICAgICAgbG9nZ2luZygnUGVlckNvbm5lY3Rpb24nKTtcbiAgICAgIGlmIChwY0NvbmZpZyAmJiBwY0NvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3kpIHtcbiAgICAgICAgcGNDb25maWcuaWNlVHJhbnNwb3J0cyA9IHBjQ29uZmlnLmljZVRyYW5zcG9ydFBvbGljeTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBjID0gbmV3IHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKTtcbiAgICAgIHZhciBvcmlnR2V0U3RhdHMgPSBwYy5nZXRTdGF0cy5iaW5kKHBjKTtcbiAgICAgIHBjLmdldFN0YXRzID0gZnVuY3Rpb24oc2VsZWN0b3IsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAgIC8vIElmIHNlbGVjdG9yIGlzIGEgZnVuY3Rpb24gdGhlbiB3ZSBhcmUgaW4gdGhlIG9sZCBzdHlsZSBzdGF0cyBzbyBqdXN0XG4gICAgICAgIC8vIHBhc3MgYmFjayB0aGUgb3JpZ2luYWwgZ2V0U3RhdHMgZm9ybWF0IHRvIGF2b2lkIGJyZWFraW5nIG9sZCB1c2Vycy5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMoc2VsZWN0b3IsIHN1Y2Nlc3NDYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZml4Q2hyb21lU3RhdHNfID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICB2YXIgc3RhbmRhcmRSZXBvcnQgPSB7fTtcbiAgICAgICAgICB2YXIgcmVwb3J0cyA9IHJlc3BvbnNlLnJlc3VsdCgpO1xuICAgICAgICAgIHJlcG9ydHMuZm9yRWFjaChmdW5jdGlvbihyZXBvcnQpIHtcbiAgICAgICAgICAgIHZhciBzdGFuZGFyZFN0YXRzID0ge1xuICAgICAgICAgICAgICBpZDogcmVwb3J0LmlkLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IHJlcG9ydC50aW1lc3RhbXAsXG4gICAgICAgICAgICAgIHR5cGU6IHJlcG9ydC50eXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVwb3J0Lm5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgIHN0YW5kYXJkU3RhdHNbbmFtZV0gPSByZXBvcnQuc3RhdChuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhbmRhcmRSZXBvcnRbc3RhbmRhcmRTdGF0cy5pZF0gPSBzdGFuZGFyZFN0YXRzO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHN0YW5kYXJkUmVwb3J0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNoaW0gZ2V0U3RhdHMgd2l0aCBtYXBsaWtlIHN1cHBvcnRcbiAgICAgICAgdmFyIG1ha2VNYXBTdGF0cyA9IGZ1bmN0aW9uKHN0YXRzLCBsZWdhY3lTdGF0cykge1xuICAgICAgICAgIHZhciBtYXAgPSBuZXcgTWFwKE9iamVjdC5rZXlzKHN0YXRzKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm5ba2V5LCBzdGF0c1trZXldXTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgbGVnYWN5U3RhdHMgPSBsZWdhY3lTdGF0cyB8fCBzdGF0cztcbiAgICAgICAgICBPYmplY3Qua2V5cyhsZWdhY3lTdGF0cykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIG1hcFtrZXldID0gbGVnYWN5U3RhdHNba2V5XTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICB2YXIgc3VjY2Vzc0NhbGxiYWNrV3JhcHBlcl8gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgYXJnc1sxXShtYWtlTWFwU3RhdHMoZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSkpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIFtzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXyxcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzBdXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcm9taXNlLXN1cHBvcnRcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvcmlnR2V0U3RhdHMuYXBwbHkoc2VsZiwgW1xuICAgICAgICAgICAgICBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobWFrZU1hcFN0YXRzKGZpeENocm9tZVN0YXRzXyhyZXNwb25zZSkpKTtcbiAgICAgICAgICAgICAgfSwgcmVqZWN0XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGxlZ2FjeSBjaHJvbWUgc3RhdHMgb25seSBvbiBsZWdhY3kgYWNjZXNzIG9mIHN0YXRzIG9ialxuICAgICAgICAgICAgb3JpZ0dldFN0YXRzLmFwcGx5KHNlbGYsIFtcbiAgICAgICAgICAgICAgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG1ha2VNYXBTdGF0cyhmaXhDaHJvbWVTdGF0c18ocmVzcG9uc2UpLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5yZXN1bHQoKSkpO1xuICAgICAgICAgICAgICB9LCByZWplY3RdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBwYztcbiAgICB9O1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgPSB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG5cbiAgICAvLyB3cmFwIHN0YXRpYyBtZXRob2RzLiBDdXJyZW50bHkganVzdCBnZW5lcmF0ZUNlcnRpZmljYXRlLlxuICAgIGlmICh3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5nZW5lcmF0ZUNlcnRpZmljYXRlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLCAnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2Via2l0UlRDUGVlckNvbm5lY3Rpb24uZ2VuZXJhdGVDZXJ0aWZpY2F0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgWydjcmVhdGVPZmZlcicsICdjcmVhdGVBbnN3ZXInXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgdmFyIG5hdGl2ZU1ldGhvZCA9IHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgd2Via2l0UlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEgfHwgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBuYXRpdmVNZXRob2QuYXBwbHkoc2VsZiwgW3Jlc29sdmUsIHJlamVjdCwgb3B0c10pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgcHJvbWlzZSBzdXBwb3J0IC0tIG5hdGl2ZWx5IGF2YWlsYWJsZSBpbiBDaHJvbWUgNTFcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUxKSB7XG4gICAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ11cbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVNZXRob2QgPSB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgICAgICAgIHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlTWV0aG9kLmFwcGx5KHNlbGYsIFthcmdzWzBdLCByZXNvbHZlLCByZWplY3RdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFyZ3NbMV0uYXBwbHkobnVsbCwgW10pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICAgICAgYXJnc1syXS5hcHBseShudWxsLCBbZXJyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2hpbSBpbXBsaWNpdCBjcmVhdGlvbiBvZiBSVENTZXNzaW9uRGVzY3JpcHRpb24vUlRDSWNlQ2FuZGlkYXRlXG4gICAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJywgJ2FkZEljZUNhbmRpZGF0ZSddXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgIHZhciBuYXRpdmVNZXRob2QgPSB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgICAgICB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3ICgobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJykgP1xuICAgICAgICAgICAgICAgIFJUQ0ljZUNhbmRpZGF0ZSA6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgIC8vIHN1cHBvcnQgZm9yIGFkZEljZUNhbmRpZGF0ZShudWxsIG9yIHVuZGVmaW5lZClcbiAgICB2YXIgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlID1cbiAgICAgICAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcbiAgICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzWzFdKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzFdLmFwcGx5KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVBZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59O1xuXG5cbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcy5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaGltTWVkaWFTdHJlYW06IGNocm9tZVNoaW0uc2hpbU1lZGlhU3RyZWFtLFxuICBzaGltT25UcmFjazogY2hyb21lU2hpbS5zaGltT25UcmFjayxcbiAgc2hpbVNvdXJjZU9iamVjdDogY2hyb21lU2hpbS5zaGltU291cmNlT2JqZWN0LFxuICBzaGltUGVlckNvbm5lY3Rpb246IGNocm9tZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uLFxuICBzaGltR2V0VXNlck1lZGlhOiByZXF1aXJlKCcuL2dldHVzZXJtZWRpYScpXG59O1xuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4gLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG52YXIgbG9nZ2luZyA9IHJlcXVpcmUoJy4uL3V0aWxzLmpzJykubG9nO1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29uc3RyYWludHNUb0Nocm9tZV8gPSBmdW5jdGlvbihjKSB7XG4gICAgaWYgKHR5cGVvZiBjICE9PSAnb2JqZWN0JyB8fCBjLm1hbmRhdG9yeSB8fCBjLm9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgdmFyIGNjID0ge307XG4gICAgT2JqZWN0LmtleXMoYykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZXF1aXJlJyB8fCBrZXkgPT09ICdhZHZhbmNlZCcgfHwga2V5ID09PSAnbWVkaWFTb3VyY2UnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByID0gKHR5cGVvZiBjW2tleV0gPT09ICdvYmplY3QnKSA/IGNba2V5XSA6IHtpZGVhbDogY1trZXldfTtcbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHIubWluID0gci5tYXggPSByLmV4YWN0O1xuICAgICAgfVxuICAgICAgdmFyIG9sZG5hbWVfID0gZnVuY3Rpb24ocHJlZml4LCBuYW1lKSB7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChuYW1lID09PSAnZGV2aWNlSWQnKSA/ICdzb3VyY2VJZCcgOiBuYW1lO1xuICAgICAgfTtcbiAgICAgIGlmIChyLmlkZWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2Mub3B0aW9uYWwgPSBjYy5vcHRpb25hbCB8fCBbXTtcbiAgICAgICAgdmFyIG9jID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygci5pZGVhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWluJywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICAgIG9jID0ge307XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJ21heCcsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnJywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgIGNjLm1hbmRhdG9yeVtvbGRuYW1lXygnJywga2V5KV0gPSByLmV4YWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWydtaW4nLCAnbWF4J10uZm9yRWFjaChmdW5jdGlvbihtaXgpIHtcbiAgICAgICAgICBpZiAoclttaXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNjLm1hbmRhdG9yeSA9IGNjLm1hbmRhdG9yeSB8fCB7fTtcbiAgICAgICAgICAgIGNjLm1hbmRhdG9yeVtvbGRuYW1lXyhtaXgsIGtleSldID0gclttaXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGMuYWR2YW5jZWQpIHtcbiAgICAgIGNjLm9wdGlvbmFsID0gKGNjLm9wdGlvbmFsIHx8IFtdKS5jb25jYXQoYy5hZHZhbmNlZCk7XG4gICAgfVxuICAgIHJldHVybiBjYztcbiAgfTtcblxuICB2YXIgc2hpbUNvbnN0cmFpbnRzXyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBmdW5jKSB7XG4gICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgaWYgKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLmF1ZGlvKSB7XG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLmF1ZGlvKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzICYmIHR5cGVvZiBjb25zdHJhaW50cy52aWRlbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIFNoaW0gZmFjaW5nTW9kZSBmb3IgbW9iaWxlLCB3aGVyZSBpdCBkZWZhdWx0cyB0byBcInVzZXJcIi5cbiAgICAgIHZhciBmYWNlID0gY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgIGZhY2UgPSBmYWNlICYmICgodHlwZW9mIGZhY2UgPT09ICdvYmplY3QnKSA/IGZhY2UgOiB7aWRlYWw6IGZhY2V9KTtcblxuICAgICAgaWYgKChmYWNlICYmIChmYWNlLmV4YWN0ID09PSAndXNlcicgfHwgZmFjZS5leGFjdCA9PT0gJ2Vudmlyb25tZW50JyB8fFxuICAgICAgICAgICAgICAgICAgICBmYWNlLmlkZWFsID09PSAndXNlcicgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50JykpICYmXG4gICAgICAgICAgIShuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzICYmXG4gICAgICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuZmFjaW5nTW9kZSkpIHtcbiAgICAgICAgZGVsZXRlIGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XG4gICAgICAgIGlmIChmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8IGZhY2UuaWRlYWwgPT09ICdlbnZpcm9ubWVudCcpIHtcbiAgICAgICAgICAvLyBMb29rIGZvciBcImJhY2tcIiBpbiBsYWJlbCwgb3IgdXNlIGxhc3QgY2FtICh0eXBpY2FsbHkgYmFjayBjYW0pLlxuICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGRldmljZXMpIHtcbiAgICAgICAgICAgIGRldmljZXMgPSBkZXZpY2VzLmZpbHRlcihmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkLmtpbmQgPT09ICd2aWRlb2lucHV0JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGJhY2sgPSBkZXZpY2VzLmZpbmQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2JhY2snKSAhPT0gLTE7XG4gICAgICAgICAgICB9KSB8fCAoZGV2aWNlcy5sZW5ndGggJiYgZGV2aWNlc1tkZXZpY2VzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIGlmIChiYWNrKSB7XG4gICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLmRldmljZUlkID0gZmFjZS5leGFjdCA/IHtleGFjdDogYmFjay5kZXZpY2VJZH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aWRlYWw6IGJhY2suZGV2aWNlSWR9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy52aWRlbyk7XG4gICAgICAgICAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICB9XG4gICAgbG9nZ2luZygnY2hyb21lOiAnICsgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gIH07XG5cbiAgdmFyIHNoaW1FcnJvcl8gPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHtcbiAgICAgICAgUGVybWlzc2lvbkRlbmllZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgQ29uc3RyYWludE5vdFNhdGlzZmllZEVycm9yOiAnT3ZlcmNvbnN0cmFpbmVkRXJyb3InXG4gICAgICB9W2UubmFtZV0gfHwgZS5uYW1lLFxuICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgY29uc3RyYWludDogZS5jb25zdHJhaW50TmFtZSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICh0aGlzLm1lc3NhZ2UgJiYgJzogJykgKyB0aGlzLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZ2V0VXNlck1lZGlhXyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICBzaGltQ29uc3RyYWludHNfKGNvbnN0cmFpbnRzLCBmdW5jdGlvbihjKSB7XG4gICAgICBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhKGMsIG9uU3VjY2VzcywgZnVuY3Rpb24oZSkge1xuICAgICAgICBvbkVycm9yKHNoaW1FcnJvcl8oZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGdldFVzZXJNZWRpYV87XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGdldFVzZXJNZWRpYSBhcyBhIFByb21pc2UuXG4gIHZhciBnZXRVc2VyTWVkaWFQcm9taXNlXyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYShjb25zdHJhaW50cywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfTtcblxuICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzID0ge1xuICAgICAgZ2V0VXNlck1lZGlhOiBnZXRVc2VyTWVkaWFQcm9taXNlXyxcbiAgICAgIGVudW1lcmF0ZURldmljZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIHZhciBraW5kcyA9IHthdWRpbzogJ2F1ZGlvaW5wdXQnLCB2aWRlbzogJ3ZpZGVvaW5wdXQnfTtcbiAgICAgICAgICByZXR1cm4gTWVkaWFTdHJlYW1UcmFjay5nZXRTb3VyY2VzKGZ1bmN0aW9uKGRldmljZXMpIHtcbiAgICAgICAgICAgIHJlc29sdmUoZGV2aWNlcy5tYXAoZnVuY3Rpb24oZGV2aWNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7bGFiZWw6IGRldmljZS5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICBraW5kOiBraW5kc1tkZXZpY2Uua2luZF0sXG4gICAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQ6IGRldmljZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBncm91cElkOiAnJ307XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBBIHNoaW0gZm9yIGdldFVzZXJNZWRpYSBtZXRob2Qgb24gdGhlIG1lZGlhRGV2aWNlcyBvYmplY3QuXG4gIC8vIFRPRE8oS2FwdGVuSmFuc3NvbikgcmVtb3ZlIG9uY2UgaW1wbGVtZW50ZWQgaW4gQ2hyb21lIHN0YWJsZS5cbiAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24oY29uc3RyYWludHMpIHtcbiAgICAgIHJldHVybiBnZXRVc2VyTWVkaWFQcm9taXNlXyhjb25zdHJhaW50cyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFdmVuIHRob3VnaCBDaHJvbWUgNDUgaGFzIG5hdmlnYXRvci5tZWRpYURldmljZXMgYW5kIGEgZ2V0VXNlck1lZGlhXG4gICAgLy8gZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFByb21pc2UsIGl0IGRvZXMgbm90IGFjY2VwdCBzcGVjLXN0eWxlXG4gICAgLy8gY29uc3RyYWludHMuXG4gICAgdmFyIG9yaWdHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5cbiAgICAgICAgYmluZChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uKGNzKSB7XG4gICAgICByZXR1cm4gc2hpbUNvbnN0cmFpbnRzXyhjcywgZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gb3JpZ0dldFVzZXJNZWRpYShjKS50aGVuKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIGlmIChjLmF1ZGlvICYmICFzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggfHxcbiAgICAgICAgICAgICAgYy52aWRlbyAmJiAhc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJycsICdOb3RGb3VuZEVycm9yJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICAgIH0sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoc2hpbUVycm9yXyhlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIER1bW15IGRldmljZWNoYW5nZSBldmVudCBtZXRob2RzLlxuICAvLyBUT0RPKEthcHRlbkphbnNzb24pIHJlbW92ZSBvbmNlIGltcGxlbWVudGVkIGluIENocm9tZSBzdGFibGUuXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5hZGRFdmVudExpc3RlbmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgbG9nZ2luZygnRHVtbXkgbWVkaWFEZXZpY2VzLmFkZEV2ZW50TGlzdGVuZXIgY2FsbGVkLicpO1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBsb2dnaW5nKCdEdW1teSBtZWRpYURldmljZXMucmVtb3ZlRXZlbnRMaXN0ZW5lciBjYWxsZWQuJyk7XG4gICAgfTtcbiAgfVxufTtcbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuIC8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU0RQVXRpbHMgPSByZXF1aXJlKCdzZHAnKTtcbnZhciBicm93c2VyRGV0YWlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuYnJvd3NlckRldGFpbHM7XG5cbnZhciBlZGdlU2hpbSA9IHtcbiAgc2hpbVBlZXJDb25uZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICBpZiAod2luZG93LlJUQ0ljZUdhdGhlcmVyKSB7XG4gICAgICAvLyBPUlRDIGRlZmluZXMgYW4gUlRDSWNlQ2FuZGlkYXRlIG9iamVjdCBidXQgbm8gY29uc3RydWN0b3IuXG4gICAgICAvLyBOb3QgaW1wbGVtZW50ZWQgaW4gRWRnZS5cbiAgICAgIGlmICghd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSkge1xuICAgICAgICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gT1JUQyBkb2VzIG5vdCBoYXZlIGEgc2Vzc2lvbiBkZXNjcmlwdGlvbiBvYmplY3QgYnV0XG4gICAgICAvLyBvdGhlciBicm93c2VycyAoaS5lLiBDaHJvbWUpIHRoYXQgd2lsbCBzdXBwb3J0IGJvdGggUEMgYW5kIE9SVENcbiAgICAgIC8vIGluIHRoZSBmdXR1cmUgbWlnaHQgaGF2ZSB0aGlzIGRlZmluZWQgYWxyZWFkeS5cbiAgICAgIGlmICghd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikge1xuICAgICAgICB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uID0gZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gdGhpcyBhZGRzIGFuIGFkZGl0aW9uYWwgZXZlbnQgbGlzdGVuZXIgdG8gTWVkaWFTdHJhY2tUcmFjayB0aGF0IHNpZ25hbHNcbiAgICAgIC8vIHdoZW4gYSB0cmFja3MgZW5hYmxlZCBwcm9wZXJ0eSB3YXMgY2hhbmdlZC5cbiAgICAgIHZhciBvcmlnTVNURW5hYmxlZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUsICdlbmFibGVkJyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUsICdlbmFibGVkJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgb3JpZ01TVEVuYWJsZWQuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgIHZhciBldiA9IG5ldyBFdmVudCgnZW5hYmxlZCcpO1xuICAgICAgICAgIGV2LmVuYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgdmFyIF9ldmVudFRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIFsnYWRkRXZlbnRMaXN0ZW5lcicsICdyZW1vdmVFdmVudExpc3RlbmVyJywgJ2Rpc3BhdGNoRXZlbnQnXVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgc2VsZlttZXRob2RdID0gX2V2ZW50VGFyZ2V0W21ldGhvZF0uYmluZChfZXZlbnRUYXJnZXQpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICB0aGlzLm9uaWNlY2FuZGlkYXRlID0gbnVsbDtcbiAgICAgIHRoaXMub25hZGRzdHJlYW0gPSBudWxsO1xuICAgICAgdGhpcy5vbnRyYWNrID0gbnVsbDtcbiAgICAgIHRoaXMub25yZW1vdmVzdHJlYW0gPSBudWxsO1xuICAgICAgdGhpcy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgdGhpcy5vbm5lZ290aWF0aW9ubmVlZGVkID0gbnVsbDtcbiAgICAgIHRoaXMub25kYXRhY2hhbm5lbCA9IG51bGw7XG5cbiAgICAgIHRoaXMubG9jYWxTdHJlYW1zID0gW107XG4gICAgICB0aGlzLnJlbW90ZVN0cmVhbXMgPSBbXTtcbiAgICAgIHRoaXMuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmxvY2FsU3RyZWFtcztcbiAgICAgIH07XG4gICAgICB0aGlzLmdldFJlbW90ZVN0cmVhbXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucmVtb3RlU3RyZWFtcztcbiAgICAgIH07XG5cbiAgICAgIHRoaXMubG9jYWxEZXNjcmlwdGlvbiA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICB0eXBlOiAnJyxcbiAgICAgICAgc2RwOiAnJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJlbW90ZURlc2NyaXB0aW9uID0gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgIHR5cGU6ICcnLFxuICAgICAgICBzZHA6ICcnXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGUgPSAnc3RhYmxlJztcbiAgICAgIHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlID0gJ25ldyc7XG4gICAgICB0aGlzLmljZUdhdGhlcmluZ1N0YXRlID0gJ25ldyc7XG5cbiAgICAgIHRoaXMuaWNlT3B0aW9ucyA9IHtcbiAgICAgICAgZ2F0aGVyUG9saWN5OiAnYWxsJyxcbiAgICAgICAgaWNlU2VydmVyczogW11cbiAgICAgIH07XG4gICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3kpIHtcbiAgICAgICAgc3dpdGNoIChjb25maWcuaWNlVHJhbnNwb3J0UG9saWN5KSB7XG4gICAgICAgICAgY2FzZSAnYWxsJzpcbiAgICAgICAgICBjYXNlICdyZWxheSc6XG4gICAgICAgICAgICB0aGlzLmljZU9wdGlvbnMuZ2F0aGVyUG9saWN5ID0gY29uZmlnLmljZVRyYW5zcG9ydFBvbGljeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgLy8gRklYTUU6IHJlbW92ZSBvbmNlIGltcGxlbWVudGF0aW9uIGFuZCBzcGVjIGhhdmUgYWRkZWQgdGhpcy5cbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ljZVRyYW5zcG9ydFBvbGljeSBcIm5vbmVcIiBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIGRvbid0IHNldCBpY2VUcmFuc3BvcnRQb2xpY3kuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy51c2luZ0J1bmRsZSA9IGNvbmZpZyAmJiBjb25maWcuYnVuZGxlUG9saWN5ID09PSAnbWF4LWJ1bmRsZSc7XG5cbiAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLmljZVNlcnZlcnMpIHtcbiAgICAgICAgLy8gRWRnZSBkb2VzIG5vdCBsaWtlXG4gICAgICAgIC8vIDEpIHN0dW46XG4gICAgICAgIC8vIDIpIHR1cm46IHRoYXQgZG9lcyBub3QgaGF2ZSBhbGwgb2YgdHVybjpob3N0OnBvcnQ/dHJhbnNwb3J0PXVkcFxuICAgICAgICAvLyAzKSB0dXJuOiB3aXRoIGlwdjYgYWRkcmVzc2VzXG4gICAgICAgIHZhciBpY2VTZXJ2ZXJzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25maWcuaWNlU2VydmVycykpO1xuICAgICAgICB0aGlzLmljZU9wdGlvbnMuaWNlU2VydmVycyA9IGljZVNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uKHNlcnZlcikge1xuICAgICAgICAgIGlmIChzZXJ2ZXIgJiYgc2VydmVyLnVybHMpIHtcbiAgICAgICAgICAgIHZhciB1cmxzID0gc2VydmVyLnVybHM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVybHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHVybHMgPSBbdXJsc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmxzID0gdXJscy5maWx0ZXIoZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICAgIHJldHVybiAodXJsLmluZGV4T2YoJ3R1cm46JykgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgIHVybC5pbmRleE9mKCd0cmFuc3BvcnQ9dWRwJykgIT09IC0xICYmXG4gICAgICAgICAgICAgICAgICB1cmwuaW5kZXhPZigndHVybjpbJykgPT09IC0xKSB8fFxuICAgICAgICAgICAgICAgICAgKHVybC5pbmRleE9mKCdzdHVuOicpID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gMTQzOTMpO1xuICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICByZXR1cm4gISF1cmxzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuXG4gICAgICAvLyBwZXItdHJhY2sgaWNlR2F0aGVycywgaWNlVHJhbnNwb3J0cywgZHRsc1RyYW5zcG9ydHMsIHJ0cFNlbmRlcnMsIC4uLlxuICAgICAgLy8gZXZlcnl0aGluZyB0aGF0IGlzIG5lZWRlZCB0byBkZXNjcmliZSBhIFNEUCBtLWxpbmUuXG4gICAgICB0aGlzLnRyYW5zY2VpdmVycyA9IFtdO1xuXG4gICAgICAvLyBzaW5jZSB0aGUgaWNlR2F0aGVyZXIgaXMgY3VycmVudGx5IGNyZWF0ZWQgaW4gY3JlYXRlT2ZmZXIgYnV0IHdlXG4gICAgICAvLyBtdXN0IG5vdCBlbWl0IGNhbmRpZGF0ZXMgdW50aWwgYWZ0ZXIgc2V0TG9jYWxEZXNjcmlwdGlvbiB3ZSBidWZmZXJcbiAgICAgIC8vIHRoZW0gaW4gdGhpcyBhcnJheS5cbiAgICAgIHRoaXMuX2xvY2FsSWNlQ2FuZGlkYXRlc0J1ZmZlciA9IFtdO1xuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9lbWl0QnVmZmVyZWRDYW5kaWRhdGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKHNlbGYubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgLy8gRklYTUU6IG5lZWQgdG8gYXBwbHkgaWNlIGNhbmRpZGF0ZXMgaW4gYSB3YXkgd2hpY2ggaXMgYXN5bmMgYnV0XG4gICAgICAvLyBpbi1vcmRlclxuICAgICAgdGhpcy5fbG9jYWxJY2VDYW5kaWRhdGVzQnVmZmVyLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGVuZCA9ICFldmVudC5jYW5kaWRhdGUgfHwgT2JqZWN0LmtleXMoZXZlbnQuY2FuZGlkYXRlKS5sZW5ndGggPT09IDA7XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHNlY3Rpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoc2VjdGlvbnNbal0uaW5kZXhPZignXFxyXFxuYT1lbmQtb2YtY2FuZGlkYXRlc1xcclxcbicpID09PSAtMSkge1xuICAgICAgICAgICAgICBzZWN0aW9uc1tqXSArPSAnYT1lbmQtb2YtY2FuZGlkYXRlc1xcclxcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUuaW5kZXhPZigndHlwIGVuZE9mQ2FuZGlkYXRlcycpXG4gICAgICAgICAgICA9PT0gLTEpIHtcbiAgICAgICAgICBzZWN0aW9uc1tldmVudC5jYW5kaWRhdGUuc2RwTUxpbmVJbmRleCArIDFdICs9XG4gICAgICAgICAgICAgICdhPScgKyBldmVudC5jYW5kaWRhdGUuY2FuZGlkYXRlICsgJ1xcclxcbic7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5sb2NhbERlc2NyaXB0aW9uLnNkcCA9IHNlY3Rpb25zLmpvaW4oJycpO1xuICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICBpZiAoc2VsZi5vbmljZWNhbmRpZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNlbGYub25pY2VjYW5kaWRhdGUoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXZlbnQuY2FuZGlkYXRlICYmIHNlbGYuaWNlR2F0aGVyaW5nU3RhdGUgIT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICB2YXIgY29tcGxldGUgPSBzZWxmLnRyYW5zY2VpdmVycy5ldmVyeShmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyICYmXG4gICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIuc3RhdGUgPT09ICdjb21wbGV0ZWQnO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgc2VsZi5pY2VHYXRoZXJpbmdTdGF0ZSA9ICdjb21wbGV0ZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2xvY2FsSWNlQ2FuZGlkYXRlc0J1ZmZlciA9IFtdO1xuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAvLyBDbG9uZSBpcyBuZWNlc3NhcnkgZm9yIGxvY2FsIGRlbW9zIG1vc3RseSwgYXR0YWNoaW5nIGRpcmVjdGx5XG4gICAgICAvLyB0byB0d28gZGlmZmVyZW50IHNlbmRlcnMgZG9lcyBub3Qgd29yayAoYnVpbGQgMTA1NDcpLlxuICAgICAgdmFyIGNsb25lZFN0cmVhbSA9IHN0cmVhbS5jbG9uZSgpO1xuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odHJhY2ssIGlkeCkge1xuICAgICAgICB2YXIgY2xvbmVkVHJhY2sgPSBjbG9uZWRTdHJlYW0uZ2V0VHJhY2tzKClbaWR4XTtcbiAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5hYmxlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgY2xvbmVkVHJhY2suZW5hYmxlZCA9IGV2ZW50LmVuYWJsZWQ7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmxvY2FsU3RyZWFtcy5wdXNoKGNsb25lZFN0cmVhbSk7XG4gICAgICB0aGlzLl9tYXliZUZpcmVOZWdvdGlhdGlvbk5lZWRlZCgpO1xuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgdmFyIGlkeCA9IHRoaXMubG9jYWxTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKTtcbiAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICB0aGlzLmxvY2FsU3RyZWFtcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgdGhpcy5fbWF5YmVGaXJlTmVnb3RpYXRpb25OZWVkZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2NlaXZlcnMuZmlsdGVyKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiAhIXRyYW5zY2VpdmVyLnJ0cFNlbmRlcjtcbiAgICAgIH0pXG4gICAgICAubWFwKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5ydHBTZW5kZXI7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zY2VpdmVycy5maWx0ZXIoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuICEhdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXI7XG4gICAgICB9KVxuICAgICAgLm1hcChmdW5jdGlvbih0cmFuc2NlaXZlcikge1xuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXI7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRGV0ZXJtaW5lcyB0aGUgaW50ZXJzZWN0aW9uIG9mIGxvY2FsIGFuZCByZW1vdGUgY2FwYWJpbGl0aWVzLlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX2dldENvbW1vbkNhcGFiaWxpdGllcyA9XG4gICAgICAgIGZ1bmN0aW9uKGxvY2FsQ2FwYWJpbGl0aWVzLCByZW1vdGVDYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgICB2YXIgY29tbW9uQ2FwYWJpbGl0aWVzID0ge1xuICAgICAgICAgICAgY29kZWNzOiBbXSxcbiAgICAgICAgICAgIGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuICAgICAgICAgICAgZmVjTWVjaGFuaXNtczogW11cbiAgICAgICAgICB9O1xuICAgICAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzLmNvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uKGxDb2RlYykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdGVDYXBhYmlsaXRpZXMuY29kZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciByQ29kZWMgPSByZW1vdGVDYXBhYmlsaXRpZXMuY29kZWNzW2ldO1xuICAgICAgICAgICAgICBpZiAobENvZGVjLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gckNvZGVjLm5hbWUudG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgICAgICAgbENvZGVjLmNsb2NrUmF0ZSA9PT0gckNvZGVjLmNsb2NrUmF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBjaGFubmVscyBpcyB0aGUgaGlnaGVzdCBjb21tb24gbnVtYmVyIG9mIGNoYW5uZWxzXG4gICAgICAgICAgICAgICAgckNvZGVjLm51bUNoYW5uZWxzID0gTWF0aC5taW4obENvZGVjLm51bUNoYW5uZWxzLFxuICAgICAgICAgICAgICAgICAgICByQ29kZWMubnVtQ2hhbm5lbHMpO1xuICAgICAgICAgICAgICAgIC8vIHB1c2ggckNvZGVjIHNvIHdlIHJlcGx5IHdpdGggb2ZmZXJlciBwYXlsb2FkIHR5cGVcbiAgICAgICAgICAgICAgICBjb21tb25DYXBhYmlsaXRpZXMuY29kZWNzLnB1c2gockNvZGVjKTtcblxuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSBjb21tb24gZmVlZGJhY2sgbWVjaGFuaXNtc1xuICAgICAgICAgICAgICAgIHJDb2RlYy5ydGNwRmVlZGJhY2sgPSByQ29kZWMucnRjcEZlZWRiYWNrLmZpbHRlcihmdW5jdGlvbihmYikge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsQ29kZWMucnRjcEZlZWRiYWNrLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsQ29kZWMucnRjcEZlZWRiYWNrW2pdLnR5cGUgPT09IGZiLnR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGxDb2RlYy5ydGNwRmVlZGJhY2tbal0ucGFyYW1ldGVyID09PSBmYi5wYXJhbWV0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBhbHNvIG5lZWQgdG8gZGV0ZXJtaW5lIC5wYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgLy8gIHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BlbnBlZXIvb3J0Yy9pc3N1ZXMvNTY5XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obEhlYWRlckV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtb3RlQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgckhlYWRlckV4dGVuc2lvbiA9IHJlbW90ZUNhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKGxIZWFkZXJFeHRlbnNpb24udXJpID09PSBySGVhZGVyRXh0ZW5zaW9uLnVyaSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tb25DYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKHJIZWFkZXJFeHRlbnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gRklYTUU6IGZlY01lY2hhbmlzbXNcbiAgICAgICAgICByZXR1cm4gY29tbW9uQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9O1xuXG4gICAgLy8gQ3JlYXRlIElDRSBnYXRoZXJlciwgSUNFIHRyYW5zcG9ydCBhbmQgRFRMUyB0cmFuc3BvcnQuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fY3JlYXRlSWNlQW5kRHRsc1RyYW5zcG9ydHMgPVxuICAgICAgICBmdW5jdGlvbihtaWQsIHNkcE1MaW5lSW5kZXgpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgdmFyIGljZUdhdGhlcmVyID0gbmV3IFJUQ0ljZUdhdGhlcmVyKHNlbGYuaWNlT3B0aW9ucyk7XG4gICAgICAgICAgdmFyIGljZVRyYW5zcG9ydCA9IG5ldyBSVENJY2VUcmFuc3BvcnQoaWNlR2F0aGVyZXIpO1xuICAgICAgICAgIGljZUdhdGhlcmVyLm9ubG9jYWxjYW5kaWRhdGUgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnaWNlY2FuZGlkYXRlJyk7XG4gICAgICAgICAgICBldmVudC5jYW5kaWRhdGUgPSB7c2RwTWlkOiBtaWQsIHNkcE1MaW5lSW5kZXg6IHNkcE1MaW5lSW5kZXh9O1xuXG4gICAgICAgICAgICB2YXIgY2FuZCA9IGV2dC5jYW5kaWRhdGU7XG4gICAgICAgICAgICB2YXIgZW5kID0gIWNhbmQgfHwgT2JqZWN0LmtleXMoY2FuZCkubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgLy8gRWRnZSBlbWl0cyBhbiBlbXB0eSBvYmplY3QgZm9yIFJUQ0ljZUNhbmRpZGF0ZUNvbXBsZXRl4oClXG4gICAgICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICAgIC8vIHBvbHlmaWxsIHNpbmNlIFJUQ0ljZUdhdGhlcmVyLnN0YXRlIGlzIG5vdCBpbXBsZW1lbnRlZCBpblxuICAgICAgICAgICAgICAvLyBFZGdlIDEwNTQ3IHlldC5cbiAgICAgICAgICAgICAgaWYgKGljZUdhdGhlcmVyLnN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpY2VHYXRoZXJlci5zdGF0ZSA9ICdjb21wbGV0ZWQnO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gRW1pdCBhIGNhbmRpZGF0ZSB3aXRoIHR5cGUgZW5kT2ZDYW5kaWRhdGVzIHRvIG1ha2UgdGhlIHNhbXBsZXNcbiAgICAgICAgICAgICAgLy8gd29yay4gRWRnZSByZXF1aXJlcyBhZGRJY2VDYW5kaWRhdGUgd2l0aCB0aGlzIGVtcHR5IGNhbmRpZGF0ZVxuICAgICAgICAgICAgICAvLyB0byBzdGFydCBjaGVja2luZy4gVGhlIHJlYWwgc29sdXRpb24gaXMgdG8gc2lnbmFsXG4gICAgICAgICAgICAgIC8vIGVuZC1vZi1jYW5kaWRhdGVzIHRvIHRoZSBvdGhlciBzaWRlIHdoZW4gZ2V0dGluZyB0aGUgbnVsbFxuICAgICAgICAgICAgICAvLyBjYW5kaWRhdGUgYnV0IHNvbWUgYXBwcyAobGlrZSB0aGUgc2FtcGxlcykgZG9uJ3QgZG8gdGhhdC5cbiAgICAgICAgICAgICAgZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSA9XG4gICAgICAgICAgICAgICAgICAnY2FuZGlkYXRlOjEgMSB1ZHAgMSAwLjAuMC4wIDkgdHlwIGVuZE9mQ2FuZGlkYXRlcyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSVENJY2VDYW5kaWRhdGUgZG9lc24ndCBoYXZlIGEgY29tcG9uZW50LCBuZWVkcyB0byBiZSBhZGRlZFxuICAgICAgICAgICAgICBjYW5kLmNvbXBvbmVudCA9IGljZVRyYW5zcG9ydC5jb21wb25lbnQgPT09ICdSVENQJyA/IDIgOiAxO1xuICAgICAgICAgICAgICBldmVudC5jYW5kaWRhdGUuY2FuZGlkYXRlID0gU0RQVXRpbHMud3JpdGVDYW5kaWRhdGUoY2FuZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsb2NhbCBkZXNjcmlwdGlvbi5cbiAgICAgICAgICAgIHZhciBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoc2VsZi5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQuY2FuZGlkYXRlLmNhbmRpZGF0ZS5pbmRleE9mKCd0eXAgZW5kT2ZDYW5kaWRhdGVzJylcbiAgICAgICAgICAgICAgICA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgc2VjdGlvbnNbZXZlbnQuY2FuZGlkYXRlLnNkcE1MaW5lSW5kZXggKyAxXSArPVxuICAgICAgICAgICAgICAgICAgJ2E9JyArIGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUgKyAnXFxyXFxuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlY3Rpb25zW2V2ZW50LmNhbmRpZGF0ZS5zZHBNTGluZUluZGV4ICsgMV0gKz1cbiAgICAgICAgICAgICAgICAgICdhPWVuZC1vZi1jYW5kaWRhdGVzXFxyXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYubG9jYWxEZXNjcmlwdGlvbi5zZHAgPSBzZWN0aW9ucy5qb2luKCcnKTtcblxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlID0gc2VsZi50cmFuc2NlaXZlcnMuZXZlcnkoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyICYmXG4gICAgICAgICAgICAgICAgICB0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5zdGF0ZSA9PT0gJ2NvbXBsZXRlZCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRW1pdCBjYW5kaWRhdGUgaWYgbG9jYWxEZXNjcmlwdGlvbiBpcyBzZXQuXG4gICAgICAgICAgICAvLyBBbHNvIGVtaXRzIG51bGwgY2FuZGlkYXRlIHdoZW4gYWxsIGdhdGhlcmVycyBhcmUgY29tcGxldGUuXG4gICAgICAgICAgICBzd2l0Y2ggKHNlbGYuaWNlR2F0aGVyaW5nU3RhdGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnbmV3JzpcbiAgICAgICAgICAgICAgICBzZWxmLl9sb2NhbEljZUNhbmRpZGF0ZXNCdWZmZXIucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCAmJiBjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgc2VsZi5fbG9jYWxJY2VDYW5kaWRhdGVzQnVmZmVyLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgbmV3IEV2ZW50KCdpY2VjYW5kaWRhdGUnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdnYXRoZXJpbmcnOlxuICAgICAgICAgICAgICAgIHNlbGYuX2VtaXRCdWZmZXJlZENhbmRpZGF0ZXMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm9uaWNlY2FuZGlkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLm9uaWNlY2FuZGlkYXRlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpY2VjYW5kaWRhdGUnKSk7XG4gICAgICAgICAgICAgICAgICBpZiAoc2VsZi5vbmljZWNhbmRpZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uaWNlY2FuZGlkYXRlKG5ldyBFdmVudCgnaWNlY2FuZGlkYXRlJykpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc2VsZi5pY2VHYXRoZXJpbmdTdGF0ZSA9ICdjb21wbGV0ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5vdCBoYXBwZW4uLi4gY3VycmVudGx5IVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OiAvLyBuby1vcC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGljZVRyYW5zcG9ydC5vbmljZXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl91cGRhdGVDb25uZWN0aW9uU3RhdGUoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGR0bHNUcmFuc3BvcnQgPSBuZXcgUlRDRHRsc1RyYW5zcG9ydChpY2VUcmFuc3BvcnQpO1xuICAgICAgICAgIGR0bHNUcmFuc3BvcnQub25kdGxzc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX3VwZGF0ZUNvbm5lY3Rpb25TdGF0ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZHRsc1RyYW5zcG9ydC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBvbmVycm9yIGRvZXMgbm90IHNldCBzdGF0ZSB0byBmYWlsZWQgYnkgaXRzZWxmLlxuICAgICAgICAgICAgZHRsc1RyYW5zcG9ydC5zdGF0ZSA9ICdmYWlsZWQnO1xuICAgICAgICAgICAgc2VsZi5fdXBkYXRlQ29ubmVjdGlvblN0YXRlKCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpY2VHYXRoZXJlcjogaWNlR2F0aGVyZXIsXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnQ6IGljZVRyYW5zcG9ydCxcbiAgICAgICAgICAgIGR0bHNUcmFuc3BvcnQ6IGR0bHNUcmFuc3BvcnRcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgLy8gU3RhcnQgdGhlIFJUUCBTZW5kZXIgYW5kIFJlY2VpdmVyIGZvciBhIHRyYW5zY2VpdmVyLlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3RyYW5zY2VpdmUgPSBmdW5jdGlvbih0cmFuc2NlaXZlcixcbiAgICAgICAgc2VuZCwgcmVjdikge1xuICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuX2dldENvbW1vbkNhcGFiaWxpdGllcyh0cmFuc2NlaXZlci5sb2NhbENhcGFiaWxpdGllcyxcbiAgICAgICAgICB0cmFuc2NlaXZlci5yZW1vdGVDYXBhYmlsaXRpZXMpO1xuICAgICAgaWYgKHNlbmQgJiYgdHJhbnNjZWl2ZXIucnRwU2VuZGVyKSB7XG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgICAgICBwYXJhbXMucnRjcCA9IHtcbiAgICAgICAgICBjbmFtZTogU0RQVXRpbHMubG9jYWxDTmFtZVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHJhbnNjZWl2ZXIucmVjdkVuY29kaW5nUGFyYW1ldGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBwYXJhbXMucnRjcC5zc3JjID0gdHJhbnNjZWl2ZXIucmVjdkVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zY2VpdmVyLnJ0cFNlbmRlci5zZW5kKHBhcmFtcyk7XG4gICAgICB9XG4gICAgICBpZiAocmVjdiAmJiB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcikge1xuICAgICAgICAvLyByZW1vdmUgUlRYIGZpZWxkIGluIEVkZ2UgMTQ5NDJcbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyLmtpbmQgPT09ICd2aWRlbydcbiAgICAgICAgICAgICYmIHRyYW5zY2VpdmVyLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnMpIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci5yZWN2RW5jb2RpbmdQYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgZGVsZXRlIHAucnR4O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSB0cmFuc2NlaXZlci5yZWN2RW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgICAgICBwYXJhbXMucnRjcCA9IHtcbiAgICAgICAgICBjbmFtZTogdHJhbnNjZWl2ZXIuY25hbWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgcGFyYW1zLnJ0Y3Auc3NyYyA9IHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYztcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2NlaXZlci5ydHBSZWNlaXZlci5yZWNlaXZlKHBhcmFtcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9XG4gICAgICAgIGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHZhciBzZWN0aW9ucztcbiAgICAgICAgICB2YXIgc2Vzc2lvbnBhcnQ7XG4gICAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBXaGF0IHdhcyB0aGUgcHVycG9zZSBvZiB0aGlzIGVtcHR5IGlmIHN0YXRlbWVudD9cbiAgICAgICAgICAgIC8vIGlmICghdGhpcy5fcGVuZGluZ09mZmVyKSB7XG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdPZmZlcikge1xuICAgICAgICAgICAgICAvLyBWRVJZIGxpbWl0ZWQgc3VwcG9ydCBmb3IgU0RQIG11bmdpbmcuIExpbWl0ZWQgdG86XG4gICAgICAgICAgICAgIC8vICogY2hhbmdpbmcgdGhlIG9yZGVyIG9mIGNvZGVjc1xuICAgICAgICAgICAgICBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgICAgICAgc2Vzc2lvbnBhcnQgPSBzZWN0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgICAgICBzZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2RwTUxpbmVJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBjYXBzID0gU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgc2VsZi5fcGVuZGluZ09mZmVyW3NkcE1MaW5lSW5kZXhdLmxvY2FsQ2FwYWJpbGl0aWVzID0gY2FwcztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMudHJhbnNjZWl2ZXJzID0gdGhpcy5fcGVuZGluZ09mZmVyO1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ09mZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhzZWxmLnJlbW90ZURlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgICAgICBzZXNzaW9ucGFydCA9IHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgaXNJY2VMaXRlID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoc2Vzc2lvbnBhcnQsXG4gICAgICAgICAgICAgICAgJ2E9aWNlLWxpdGUnKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgc2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNkcE1MaW5lSW5kZXgpIHtcbiAgICAgICAgICAgICAgdmFyIHRyYW5zY2VpdmVyID0gc2VsZi50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF07XG4gICAgICAgICAgICAgIHZhciBpY2VHYXRoZXJlciA9IHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyO1xuICAgICAgICAgICAgICB2YXIgaWNlVHJhbnNwb3J0ID0gdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0O1xuICAgICAgICAgICAgICB2YXIgZHRsc1RyYW5zcG9ydCA9IHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQ7XG4gICAgICAgICAgICAgIHZhciBsb2NhbENhcGFiaWxpdGllcyA9IHRyYW5zY2VpdmVyLmxvY2FsQ2FwYWJpbGl0aWVzO1xuICAgICAgICAgICAgICB2YXIgcmVtb3RlQ2FwYWJpbGl0aWVzID0gdHJhbnNjZWl2ZXIucmVtb3RlQ2FwYWJpbGl0aWVzO1xuXG4gICAgICAgICAgICAgIHZhciByZWplY3RlZCA9IG1lZGlhU2VjdGlvbi5zcGxpdCgnXFxuJywgMSlbMF1cbiAgICAgICAgICAgICAgICAgIC5zcGxpdCgnICcsIDIpWzFdID09PSAnMCc7XG5cbiAgICAgICAgICAgICAgaWYgKCFyZWplY3RlZCAmJiAhdHJhbnNjZWl2ZXIuaXNEYXRhY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIHZhciByZW1vdGVJY2VQYXJhbWV0ZXJzID0gU0RQVXRpbHMuZ2V0SWNlUGFyYW1ldGVycyhcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzSWNlTGl0ZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNhbmRzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1jYW5kaWRhdGU6JylcbiAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oY2FuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoY2FuZCk7XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihjYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5kLmNvbXBvbmVudCA9PT0gJzEnO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAvLyBpY2UtbGl0ZSBvbmx5IGluY2x1ZGVzIGhvc3QgY2FuZGlkYXRlcyBpbiB0aGUgU0RQIHNvIHdlIGNhblxuICAgICAgICAgICAgICAgICAgLy8gdXNlIHNldFJlbW90ZUNhbmRpZGF0ZXMgKHdoaWNoIGltcGxpZXMgYW5cbiAgICAgICAgICAgICAgICAgIC8vIFJUQ0ljZUNhbmRpZGF0ZUNvbXBsZXRlKVxuICAgICAgICAgICAgICAgICAgaWYgKGNhbmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpY2VUcmFuc3BvcnQuc2V0UmVtb3RlQ2FuZGlkYXRlcyhjYW5kcyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZW1vdGVEdGxzUGFyYW1ldGVycyA9IFNEUFV0aWxzLmdldER0bHNQYXJhbWV0ZXJzKFxuICAgICAgICAgICAgICAgICAgICBtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJY2VMaXRlKSB7XG4gICAgICAgICAgICAgICAgICByZW1vdGVEdGxzUGFyYW1ldGVycy5yb2xlID0gJ3NlcnZlcic7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnVuZGxlIHx8IHNkcE1MaW5lSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGljZVRyYW5zcG9ydC5zdGFydChpY2VHYXRoZXJlciwgcmVtb3RlSWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgICBpc0ljZUxpdGUgPyAnY29udHJvbGxpbmcnIDogJ2NvbnRyb2xsZWQnKTtcbiAgICAgICAgICAgICAgICAgIGR0bHNUcmFuc3BvcnQuc3RhcnQocmVtb3RlRHRsc1BhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gb2YgY2FwYWJpbGl0aWVzLlxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBzZWxmLl9nZXRDb21tb25DYXBhYmlsaXRpZXMobG9jYWxDYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUNhcGFiaWxpdGllcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdGFydCB0aGUgUlRDUnRwU2VuZGVyLiBUaGUgUlRDUnRwUmVjZWl2ZXIgZm9yIHRoaXNcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2NlaXZlciBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQgaW4gc2V0UmVtb3RlRGVzY3JpcHRpb24uXG4gICAgICAgICAgICAgICAgc2VsZi5fdHJhbnNjZWl2ZSh0cmFuc2NlaXZlcixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNvZGVjcy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubG9jYWxEZXNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICAgICAgICBzZHA6IGRlc2NyaXB0aW9uLnNkcFxuICAgICAgICAgIH07XG4gICAgICAgICAgc3dpdGNoIChkZXNjcmlwdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdvZmZlcic6XG4gICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlKCdoYXZlLWxvY2FsLW9mZmVyJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYW5zd2VyJzpcbiAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2lnbmFsaW5nU3RhdGUoJ3N0YWJsZScpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Vuc3VwcG9ydGVkIHR5cGUgXCInICsgZGVzY3JpcHRpb24udHlwZSArXG4gICAgICAgICAgICAgICAgICAnXCInKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBhIHN1Y2Nlc3MgY2FsbGJhY2sgd2FzIHByb3ZpZGVkLCBlbWl0IElDRSBjYW5kaWRhdGVzIGFmdGVyIGl0XG4gICAgICAgICAgLy8gaGFzIGJlZW4gZXhlY3V0ZWQuIE90aGVyd2lzZSwgZW1pdCBjYWxsYmFjayBhZnRlciB0aGUgUHJvbWlzZSBpc1xuICAgICAgICAgIC8vIHJlc29sdmVkLlxuICAgICAgICAgIHZhciBoYXNDYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nO1xuICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGNiID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgIGlmIChzZWxmLmljZUdhdGhlcmluZ1N0YXRlID09PSAnbmV3Jykge1xuICAgICAgICAgICAgICAgIHNlbGYuaWNlR2F0aGVyaW5nU3RhdGUgPSAnZ2F0aGVyaW5nJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZWxmLl9lbWl0QnVmZmVyZWRDYW5kaWRhdGVzKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxmLmljZUdhdGhlcmluZ1N0YXRlID09PSAnbmV3Jykge1xuICAgICAgICAgICAgICAgIHNlbGYuaWNlR2F0aGVyaW5nU3RhdGUgPSAnZ2F0aGVyaW5nJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBVc3VhbGx5IGNhbmRpZGF0ZXMgd2lsbCBiZSBlbWl0dGVkIGVhcmxpZXIuXG4gICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHNlbGYuX2VtaXRCdWZmZXJlZENhbmRpZGF0ZXMuYmluZChzZWxmKSwgNTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPVxuICAgICAgICBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICB2YXIgc3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgICAgdmFyIHJlY2VpdmVyTGlzdCA9IFtdO1xuICAgICAgICAgIHZhciBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgICB2YXIgc2Vzc2lvbnBhcnQgPSBzZWN0aW9ucy5zaGlmdCgpO1xuICAgICAgICAgIHZhciBpc0ljZUxpdGUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChzZXNzaW9ucGFydCxcbiAgICAgICAgICAgICAgJ2E9aWNlLWxpdGUnKS5sZW5ndGggPiAwO1xuICAgICAgICAgIHRoaXMudXNpbmdCdW5kbGUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChzZXNzaW9ucGFydCxcbiAgICAgICAgICAgICAgJ2E9Z3JvdXA6QlVORExFICcpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgc2VjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNkcE1MaW5lSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgICAgICAgICAgIHZhciBtbGluZSA9IGxpbmVzWzBdLnN1YnN0cigyKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgdmFyIGtpbmQgPSBtbGluZVswXTtcbiAgICAgICAgICAgIHZhciByZWplY3RlZCA9IG1saW5lWzFdID09PSAnMCc7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gU0RQVXRpbHMuZ2V0RGlyZWN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpO1xuXG4gICAgICAgICAgICB2YXIgbWlkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1taWQ6Jyk7XG4gICAgICAgICAgICBpZiAobWlkLmxlbmd0aCkge1xuICAgICAgICAgICAgICBtaWQgPSBtaWRbMF0uc3Vic3RyKDYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWlkID0gU0RQVXRpbHMuZ2VuZXJhdGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlamVjdCBkYXRhY2hhbm5lbHMgd2hpY2ggYXJlIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gJ2FwcGxpY2F0aW9uJyAmJiBtbGluZVsyXSA9PT0gJ0RUTFMvU0NUUCcpIHtcbiAgICAgICAgICAgICAgc2VsZi50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgbWlkOiBtaWQsXG4gICAgICAgICAgICAgICAgaXNEYXRhY2hhbm5lbDogdHJ1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0cmFuc2NlaXZlcjtcbiAgICAgICAgICAgIHZhciBpY2VHYXRoZXJlcjtcbiAgICAgICAgICAgIHZhciBpY2VUcmFuc3BvcnQ7XG4gICAgICAgICAgICB2YXIgZHRsc1RyYW5zcG9ydDtcbiAgICAgICAgICAgIHZhciBydHBTZW5kZXI7XG4gICAgICAgICAgICB2YXIgcnRwUmVjZWl2ZXI7XG4gICAgICAgICAgICB2YXIgc2VuZEVuY29kaW5nUGFyYW1ldGVycztcbiAgICAgICAgICAgIHZhciByZWN2RW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgdmFyIGxvY2FsQ2FwYWJpbGl0aWVzO1xuXG4gICAgICAgICAgICB2YXIgdHJhY2s7XG4gICAgICAgICAgICAvLyBGSVhNRTogZW5zdXJlIHRoZSBtZWRpYVNlY3Rpb24gaGFzIHJ0Y3AtbXV4IHNldC5cbiAgICAgICAgICAgIHZhciByZW1vdGVDYXBhYmlsaXRpZXMgPSBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcbiAgICAgICAgICAgIHZhciByZW1vdGVJY2VQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgdmFyIHJlbW90ZUR0bHNQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgaWYgKCFyZWplY3RlZCkge1xuICAgICAgICAgICAgICByZW1vdGVJY2VQYXJhbWV0ZXJzID0gU0RQVXRpbHMuZ2V0SWNlUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24sXG4gICAgICAgICAgICAgICAgICBzZXNzaW9ucGFydCk7XG4gICAgICAgICAgICAgIHJlbW90ZUR0bHNQYXJhbWV0ZXJzID0gU0RQVXRpbHMuZ2V0RHRsc1BhcmFtZXRlcnMobWVkaWFTZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgc2Vzc2lvbnBhcnQpO1xuICAgICAgICAgICAgICByZW1vdGVEdGxzUGFyYW1ldGVycy5yb2xlID0gJ2NsaWVudCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWN2RW5jb2RpbmdQYXJhbWV0ZXJzID1cbiAgICAgICAgICAgICAgICBTRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuXG4gICAgICAgICAgICB2YXIgY25hbWU7XG4gICAgICAgICAgICAvLyBHZXRzIHRoZSBmaXJzdCBTU1JDLiBOb3RlIHRoYXQgd2l0aCBSVFggdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGVcbiAgICAgICAgICAgIC8vIFNTUkNzLlxuICAgICAgICAgICAgdmFyIHJlbW90ZVNzcmMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJztcbiAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgIGlmIChyZW1vdGVTc3JjKSB7XG4gICAgICAgICAgICAgIGNuYW1lID0gcmVtb3RlU3NyYy52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGlzQ29tcGxldGUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sXG4gICAgICAgICAgICAgICAgJ2E9ZW5kLW9mLWNhbmRpZGF0ZXMnLCBzZXNzaW9ucGFydCkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHZhciBjYW5kcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9Y2FuZGlkYXRlOicpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihjYW5kKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoY2FuZCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGNhbmQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5kLmNvbXBvbmVudCA9PT0gJzEnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicgJiYgIXJlamVjdGVkKSB7XG4gICAgICAgICAgICAgIHZhciB0cmFuc3BvcnRzID0gc2VsZi51c2luZ0J1bmRsZSAmJiBzZHBNTGluZUluZGV4ID4gMCA/IHtcbiAgICAgICAgICAgICAgICBpY2VHYXRoZXJlcjogc2VsZi50cmFuc2NlaXZlcnNbMF0uaWNlR2F0aGVyZXIsXG4gICAgICAgICAgICAgICAgaWNlVHJhbnNwb3J0OiBzZWxmLnRyYW5zY2VpdmVyc1swXS5pY2VUcmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgZHRsc1RyYW5zcG9ydDogc2VsZi50cmFuc2NlaXZlcnNbMF0uZHRsc1RyYW5zcG9ydFxuICAgICAgICAgICAgICB9IDogc2VsZi5fY3JlYXRlSWNlQW5kRHRsc1RyYW5zcG9ydHMobWlkLCBzZHBNTGluZUluZGV4KTtcblxuICAgICAgICAgICAgICBpZiAoaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydHMuaWNlVHJhbnNwb3J0LnNldFJlbW90ZUNhbmRpZGF0ZXMoY2FuZHMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXMgPSBSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMoa2luZCk7XG5cbiAgICAgICAgICAgICAgLy8gZmlsdGVyIFJUWCB1bnRpbCBhZGRpdGlvbmFsIHN0dWZmIG5lZWRlZCBmb3IgUlRYIGlzIGltcGxlbWVudGVkXG4gICAgICAgICAgICAgIC8vIGluIGFkYXB0ZXIuanNcbiAgICAgICAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXMuY29kZWNzID0gbG9jYWxDYXBhYmlsaXRpZXMuY29kZWNzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2RlYy5uYW1lICE9PSAncnR4JztcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHNlbmRFbmNvZGluZ1BhcmFtZXRlcnMgPSBbe1xuICAgICAgICAgICAgICAgIHNzcmM6ICgyICogc2RwTUxpbmVJbmRleCArIDIpICogMTAwMVxuICAgICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgICBydHBSZWNlaXZlciA9IG5ldyBSVENSdHBSZWNlaXZlcih0cmFuc3BvcnRzLmR0bHNUcmFuc3BvcnQsIGtpbmQpO1xuXG4gICAgICAgICAgICAgIHRyYWNrID0gcnRwUmVjZWl2ZXIudHJhY2s7XG4gICAgICAgICAgICAgIHJlY2VpdmVyTGlzdC5wdXNoKFt0cmFjaywgcnRwUmVjZWl2ZXJdKTtcbiAgICAgICAgICAgICAgLy8gRklYTUU6IG5vdCBjb3JyZWN0IHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIHN0cmVhbXMgYnV0IHRoYXQgaXNcbiAgICAgICAgICAgICAgLy8gbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgaW4gdGhpcyBzaGltLlxuICAgICAgICAgICAgICBzdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXG4gICAgICAgICAgICAgIC8vIEZJWE1FOiBsb29rIGF0IGRpcmVjdGlvbi5cbiAgICAgICAgICAgICAgaWYgKHNlbGYubG9jYWxTdHJlYW1zLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgIHNlbGYubG9jYWxTdHJlYW1zWzBdLmdldFRyYWNrcygpLmxlbmd0aCA+PSBzZHBNTGluZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsVHJhY2s7XG4gICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgICAgIGxvY2FsVHJhY2sgPSBzZWxmLmxvY2FsU3RyZWFtc1swXS5nZXRBdWRpb1RyYWNrcygpWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICAgICAgbG9jYWxUcmFjayA9IHNlbGYubG9jYWxTdHJlYW1zWzBdLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsb2NhbFRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICBydHBTZW5kZXIgPSBuZXcgUlRDUnRwU2VuZGVyKGxvY2FsVHJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0cy5kdGxzVHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZWxmLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICBpY2VHYXRoZXJlcjogdHJhbnNwb3J0cy5pY2VHYXRoZXJlcixcbiAgICAgICAgICAgICAgICBpY2VUcmFuc3BvcnQ6IHRyYW5zcG9ydHMuaWNlVHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgIGR0bHNUcmFuc3BvcnQ6IHRyYW5zcG9ydHMuZHRsc1RyYW5zcG9ydCxcbiAgICAgICAgICAgICAgICBsb2NhbENhcGFiaWxpdGllczogbG9jYWxDYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICAgICAgcmVtb3RlQ2FwYWJpbGl0aWVzOiByZW1vdGVDYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICAgICAgcnRwU2VuZGVyOiBydHBTZW5kZXIsXG4gICAgICAgICAgICAgICAgcnRwUmVjZWl2ZXI6IHJ0cFJlY2VpdmVyLFxuICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgICAgICAgbWlkOiBtaWQsXG4gICAgICAgICAgICAgICAgY25hbWU6IGNuYW1lLFxuICAgICAgICAgICAgICAgIHNlbmRFbmNvZGluZ1BhcmFtZXRlcnM6IHNlbmRFbmNvZGluZ1BhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcmVjdkVuY29kaW5nUGFyYW1ldGVyczogcmVjdkVuY29kaW5nUGFyYW1ldGVyc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAvLyBTdGFydCB0aGUgUlRDUnRwUmVjZWl2ZXIgbm93LiBUaGUgUlRQU2VuZGVyIGlzIHN0YXJ0ZWQgaW5cbiAgICAgICAgICAgICAgLy8gc2V0TG9jYWxEZXNjcmlwdGlvbi5cbiAgICAgICAgICAgICAgc2VsZi5fdHJhbnNjZWl2ZShzZWxmLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XSxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnIHx8IGRpcmVjdGlvbiA9PT0gJ3NlbmRvbmx5Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICdhbnN3ZXInICYmICFyZWplY3RlZCkge1xuICAgICAgICAgICAgICB0cmFuc2NlaXZlciA9IHNlbGYudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdO1xuICAgICAgICAgICAgICBpY2VHYXRoZXJlciA9IHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyO1xuICAgICAgICAgICAgICBpY2VUcmFuc3BvcnQgPSB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQ7XG4gICAgICAgICAgICAgIGR0bHNUcmFuc3BvcnQgPSB0cmFuc2NlaXZlci5kdGxzVHJhbnNwb3J0O1xuICAgICAgICAgICAgICBydHBTZW5kZXIgPSB0cmFuc2NlaXZlci5ydHBTZW5kZXI7XG4gICAgICAgICAgICAgIHJ0cFJlY2VpdmVyID0gdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXI7XG4gICAgICAgICAgICAgIHNlbmRFbmNvZGluZ1BhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICBsb2NhbENhcGFiaWxpdGllcyA9IHRyYW5zY2VpdmVyLmxvY2FsQ2FwYWJpbGl0aWVzO1xuXG4gICAgICAgICAgICAgIHNlbGYudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnMgPVxuICAgICAgICAgICAgICAgICAgcmVjdkVuY29kaW5nUGFyYW1ldGVycztcbiAgICAgICAgICAgICAgc2VsZi50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0ucmVtb3RlQ2FwYWJpbGl0aWVzID1cbiAgICAgICAgICAgICAgICAgIHJlbW90ZUNhcGFiaWxpdGllcztcbiAgICAgICAgICAgICAgc2VsZi50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uY25hbWUgPSBjbmFtZTtcblxuICAgICAgICAgICAgICBpZiAoKGlzSWNlTGl0ZSB8fCBpc0NvbXBsZXRlKSAmJiBjYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpY2VUcmFuc3BvcnQuc2V0UmVtb3RlQ2FuZGlkYXRlcyhjYW5kcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFzZWxmLnVzaW5nQnVuZGxlIHx8IHNkcE1MaW5lSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpY2VUcmFuc3BvcnQuc3RhcnQoaWNlR2F0aGVyZXIsIHJlbW90ZUljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICdjb250cm9sbGluZycpO1xuICAgICAgICAgICAgICAgIGR0bHNUcmFuc3BvcnQuc3RhcnQocmVtb3RlRHRsc1BhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2VsZi5fdHJhbnNjZWl2ZSh0cmFuc2NlaXZlcixcbiAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2JyB8fCBkaXJlY3Rpb24gPT09ICdyZWN2b25seScsXG4gICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09ICdzZW5kcmVjdicgfHwgZGlyZWN0aW9uID09PSAnc2VuZG9ubHknKTtcblxuICAgICAgICAgICAgICBpZiAocnRwUmVjZWl2ZXIgJiZcbiAgICAgICAgICAgICAgICAgIChkaXJlY3Rpb24gPT09ICdzZW5kcmVjdicgfHwgZGlyZWN0aW9uID09PSAnc2VuZG9ubHknKSkge1xuICAgICAgICAgICAgICAgIHRyYWNrID0gcnRwUmVjZWl2ZXIudHJhY2s7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXJMaXN0LnB1c2goW3RyYWNrLCBydHBSZWNlaXZlcl0pO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IGFjdHVhbGx5IHRoZSByZWNlaXZlciBzaG91bGQgYmUgY3JlYXRlZCBsYXRlci5cbiAgICAgICAgICAgICAgICBkZWxldGUgdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMucmVtb3RlRGVzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxuICAgICAgICAgICAgc2RwOiBkZXNjcmlwdGlvbi5zZHBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHN3aXRjaCAoZGVzY3JpcHRpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnb2ZmZXInOlxuICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTaWduYWxpbmdTdGF0ZSgnaGF2ZS1yZW1vdGUtb2ZmZXInKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbnN3ZXInOlxuICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTaWduYWxpbmdTdGF0ZSgnc3RhYmxlJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgdHlwZSBcIicgKyBkZXNjcmlwdGlvbi50eXBlICtcbiAgICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCkge1xuICAgICAgICAgICAgc2VsZi5yZW1vdGVTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHN0cmVhbScpO1xuICAgICAgICAgICAgICBldmVudC5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICAgIGlmIChzZWxmLm9uYWRkc3RyZWFtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLm9uYWRkc3RyZWFtKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlY2VpdmVyTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSBpdGVtWzBdO1xuICAgICAgICAgICAgICAgIHZhciByZWNlaXZlciA9IGl0ZW1bMV07XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrRXZlbnQgPSBuZXcgRXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgICAgICAgdHJhY2tFdmVudC50cmFjayA9IHRyYWNrO1xuICAgICAgICAgICAgICAgIHRyYWNrRXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgICAgICB0cmFja0V2ZW50LnN0cmVhbXMgPSBbc3RyZWFtXTtcbiAgICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm9udHJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9udHJhY2sodHJhY2tFdmVudCk7XG4gICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChhcmd1bWVudHNbMV0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRyYW5zY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIC8qIG5vdCB5ZXRcbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICBpZiAodHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydCkge1xuICAgICAgICAgIHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIpIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci5ydHBTZW5kZXIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5ydHBSZWNlaXZlcikge1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBGSVhNRTogY2xlYW4gdXAgdHJhY2tzLCBsb2NhbCBzdHJlYW1zLCByZW1vdGUgc3RyZWFtcywgZXRjXG4gICAgICB0aGlzLl91cGRhdGVTaWduYWxpbmdTdGF0ZSgnY2xvc2VkJyk7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgc2lnbmFsaW5nIHN0YXRlLlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlID1cbiAgICAgICAgZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgICB0aGlzLnNpZ25hbGluZ1N0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdzaWduYWxpbmdzdGF0ZWNoYW5nZScpO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgaWYgKHRoaXMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB0byBmaXJlIHRoZSBuZWdvdGlhdGlvbm5lZWRlZCBldmVudC5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9tYXliZUZpcmVOZWdvdGlhdGlvbk5lZWRlZCA9XG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIEZpcmUgYXdheSAoZm9yIG5vdykuXG4gICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCduZWdvdGlhdGlvbm5lZWRlZCcpO1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgaWYgKHRoaXMub25uZWdvdGlhdGlvbm5lZWRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vbm5lZ290aWF0aW9ubmVlZGVkKGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAvLyBVcGRhdGUgdGhlIGNvbm5lY3Rpb24gc3RhdGUuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fdXBkYXRlQ29ubmVjdGlvblN0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgbmV3U3RhdGU7XG4gICAgICB2YXIgc3RhdGVzID0ge1xuICAgICAgICAnbmV3JzogMCxcbiAgICAgICAgY2xvc2VkOiAwLFxuICAgICAgICBjb25uZWN0aW5nOiAwLFxuICAgICAgICBjaGVja2luZzogMCxcbiAgICAgICAgY29ubmVjdGVkOiAwLFxuICAgICAgICBjb21wbGV0ZWQ6IDAsXG4gICAgICAgIGZhaWxlZDogMFxuICAgICAgfTtcbiAgICAgIHRoaXMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgc3RhdGVzW3RyYW5zY2VpdmVyLmljZVRyYW5zcG9ydC5zdGF0ZV0rKztcbiAgICAgICAgc3RhdGVzW3RyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQuc3RhdGVdKys7XG4gICAgICB9KTtcbiAgICAgIC8vIElDRVRyYW5zcG9ydC5jb21wbGV0ZWQgYW5kIGNvbm5lY3RlZCBhcmUgdGhlIHNhbWUgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgIHN0YXRlcy5jb25uZWN0ZWQgKz0gc3RhdGVzLmNvbXBsZXRlZDtcblxuICAgICAgbmV3U3RhdGUgPSAnbmV3JztcbiAgICAgIGlmIChzdGF0ZXMuZmFpbGVkID4gMCkge1xuICAgICAgICBuZXdTdGF0ZSA9ICdmYWlsZWQnO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZXMuY29ubmVjdGluZyA+IDAgfHwgc3RhdGVzLmNoZWNraW5nID4gMCkge1xuICAgICAgICBuZXdTdGF0ZSA9ICdjb25uZWN0aW5nJztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGVzLmRpc2Nvbm5lY3RlZCA+IDApIHtcbiAgICAgICAgbmV3U3RhdGUgPSAnZGlzY29ubmVjdGVkJztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGVzLm5ldyA+IDApIHtcbiAgICAgICAgbmV3U3RhdGUgPSAnbmV3JztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGVzLmNvbm5lY3RlZCA+IDAgfHwgc3RhdGVzLmNvbXBsZXRlZCA+IDApIHtcbiAgICAgICAgbmV3U3RhdGUgPSAnY29ubmVjdGVkJztcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld1N0YXRlICE9PSBzZWxmLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICBzZWxmLmljZUNvbm5lY3Rpb25TdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nT2ZmZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVPZmZlciBjYWxsZWQgd2hpbGUgdGhlcmUgaXMgYSBwZW5kaW5nIG9mZmVyLicpO1xuICAgICAgfVxuICAgICAgdmFyIG9mZmVyT3B0aW9ucztcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2ZmZXJPcHRpb25zID0gYXJndW1lbnRzWzBdO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIG9mZmVyT3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYWNrcyA9IFtdO1xuICAgICAgdmFyIG51bUF1ZGlvVHJhY2tzID0gMDtcbiAgICAgIHZhciBudW1WaWRlb1RyYWNrcyA9IDA7XG4gICAgICAvLyBEZWZhdWx0IHRvIHNlbmRyZWN2LlxuICAgICAgaWYgKHRoaXMubG9jYWxTdHJlYW1zLmxlbmd0aCkge1xuICAgICAgICBudW1BdWRpb1RyYWNrcyA9IHRoaXMubG9jYWxTdHJlYW1zWzBdLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoO1xuICAgICAgICBudW1WaWRlb1RyYWNrcyA9IHRoaXMubG9jYWxTdHJlYW1zWzBdLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgLy8gRGV0ZXJtaW5lIG51bWJlciBvZiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzIHdlIG5lZWQgdG8gc2VuZC9yZWN2LlxuICAgICAgaWYgKG9mZmVyT3B0aW9ucykge1xuICAgICAgICAvLyBSZWplY3QgQ2hyb21lIGxlZ2FjeSBjb25zdHJhaW50cy5cbiAgICAgICAgaWYgKG9mZmVyT3B0aW9ucy5tYW5kYXRvcnkgfHwgb2ZmZXJPcHRpb25zLm9wdGlvbmFsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgJ0xlZ2FjeSBtYW5kYXRvcnkvb3B0aW9uYWwgY29uc3RyYWludHMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bUF1ZGlvVHJhY2tzID0gb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1WaWRlb1RyYWNrcyA9IG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sb2NhbFN0cmVhbXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIFB1c2ggbG9jYWwgc3RyZWFtcy5cbiAgICAgICAgdGhpcy5sb2NhbFN0cmVhbXNbMF0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgICAgIHRyYWNrcy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6IHRyYWNrLmtpbmQsXG4gICAgICAgICAgICB0cmFjazogdHJhY2ssXG4gICAgICAgICAgICB3YW50UmVjZWl2ZTogdHJhY2sua2luZCA9PT0gJ2F1ZGlvJyA/XG4gICAgICAgICAgICAgICAgbnVtQXVkaW9UcmFja3MgPiAwIDogbnVtVmlkZW9UcmFja3MgPiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIG51bUF1ZGlvVHJhY2tzLS07XG4gICAgICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBudW1WaWRlb1RyYWNrcy0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBDcmVhdGUgTS1saW5lcyBmb3IgcmVjdm9ubHkgc3RyZWFtcy5cbiAgICAgIHdoaWxlIChudW1BdWRpb1RyYWNrcyA+IDAgfHwgbnVtVmlkZW9UcmFja3MgPiAwKSB7XG4gICAgICAgIGlmIChudW1BdWRpb1RyYWNrcyA+IDApIHtcbiAgICAgICAgICB0cmFja3MucHVzaCh7XG4gICAgICAgICAgICBraW5kOiAnYXVkaW8nLFxuICAgICAgICAgICAgd2FudFJlY2VpdmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBudW1BdWRpb1RyYWNrcy0tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW1WaWRlb1RyYWNrcyA+IDApIHtcbiAgICAgICAgICB0cmFja3MucHVzaCh7XG4gICAgICAgICAgICBraW5kOiAndmlkZW8nLFxuICAgICAgICAgICAgd2FudFJlY2VpdmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBudW1WaWRlb1RyYWNrcy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzZHAgPSBTRFBVdGlscy53cml0ZVNlc3Npb25Cb2lsZXJwbGF0ZSgpO1xuICAgICAgdmFyIHRyYW5zY2VpdmVycyA9IFtdO1xuICAgICAgdHJhY2tzLmZvckVhY2goZnVuY3Rpb24obWxpbmUsIHNkcE1MaW5lSW5kZXgpIHtcbiAgICAgICAgLy8gRm9yIGVhY2ggdHJhY2ssIGNyZWF0ZSBhbiBpY2UgZ2F0aGVyZXIsIGljZSB0cmFuc3BvcnQsXG4gICAgICAgIC8vIGR0bHMgdHJhbnNwb3J0LCBwb3RlbnRpYWxseSBydHBzZW5kZXIgYW5kIHJ0cHJlY2VpdmVyLlxuICAgICAgICB2YXIgdHJhY2sgPSBtbGluZS50cmFjaztcbiAgICAgICAgdmFyIGtpbmQgPSBtbGluZS5raW5kO1xuICAgICAgICB2YXIgbWlkID0gU0RQVXRpbHMuZ2VuZXJhdGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgdmFyIHRyYW5zcG9ydHMgPSBzZWxmLnVzaW5nQnVuZGxlICYmIHNkcE1MaW5lSW5kZXggPiAwID8ge1xuICAgICAgICAgIGljZUdhdGhlcmVyOiB0cmFuc2NlaXZlcnNbMF0uaWNlR2F0aGVyZXIsXG4gICAgICAgICAgaWNlVHJhbnNwb3J0OiB0cmFuc2NlaXZlcnNbMF0uaWNlVHJhbnNwb3J0LFxuICAgICAgICAgIGR0bHNUcmFuc3BvcnQ6IHRyYW5zY2VpdmVyc1swXS5kdGxzVHJhbnNwb3J0XG4gICAgICAgIH0gOiBzZWxmLl9jcmVhdGVJY2VBbmREdGxzVHJhbnNwb3J0cyhtaWQsIHNkcE1MaW5lSW5kZXgpO1xuXG4gICAgICAgIHZhciBsb2NhbENhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoa2luZCk7XG4gICAgICAgIC8vIGZpbHRlciBSVFggdW50aWwgYWRkaXRpb25hbCBzdHVmZiBuZWVkZWQgZm9yIFJUWCBpcyBpbXBsZW1lbnRlZFxuICAgICAgICAvLyBpbiBhZGFwdGVyLmpzXG4gICAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzLmNvZGVjcyA9IGxvY2FsQ2FwYWJpbGl0aWVzLmNvZGVjcy5maWx0ZXIoXG4gICAgICAgICAgICBmdW5jdGlvbihjb2RlYykge1xuICAgICAgICAgICAgICByZXR1cm4gY29kZWMubmFtZSAhPT0gJ3J0eCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXMuY29kZWNzLmZvckVhY2goZnVuY3Rpb24oY29kZWMpIHtcbiAgICAgICAgICAvLyB3b3JrIGFyb3VuZCBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NjU1MlxuICAgICAgICAgIC8vIGJ5IGFkZGluZyBsZXZlbC1hc3ltbWV0cnktYWxsb3dlZD0xXG4gICAgICAgICAgaWYgKGNvZGVjLm5hbWUgPT09ICdIMjY0JyAmJlxuICAgICAgICAgICAgICBjb2RlYy5wYXJhbWV0ZXJzWydsZXZlbC1hc3ltbWV0cnktYWxsb3dlZCddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvZGVjLnBhcmFtZXRlcnNbJ2xldmVsLWFzeW1tZXRyeS1hbGxvd2VkJ10gPSAnMSc7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcnRwU2VuZGVyO1xuICAgICAgICB2YXIgcnRwUmVjZWl2ZXI7XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUgYW4gc3NyYyBub3csIHRvIGJlIHVzZWQgbGF0ZXIgaW4gcnRwU2VuZGVyLnNlbmRcbiAgICAgICAgdmFyIHNlbmRFbmNvZGluZ1BhcmFtZXRlcnMgPSBbe1xuICAgICAgICAgIHNzcmM6ICgyICogc2RwTUxpbmVJbmRleCArIDEpICogMTAwMVxuICAgICAgICB9XTtcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgcnRwU2VuZGVyID0gbmV3IFJUQ1J0cFNlbmRlcih0cmFjaywgdHJhbnNwb3J0cy5kdGxzVHJhbnNwb3J0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtbGluZS53YW50UmVjZWl2ZSkge1xuICAgICAgICAgIHJ0cFJlY2VpdmVyID0gbmV3IFJUQ1J0cFJlY2VpdmVyKHRyYW5zcG9ydHMuZHRsc1RyYW5zcG9ydCwga2luZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0gPSB7XG4gICAgICAgICAgaWNlR2F0aGVyZXI6IHRyYW5zcG9ydHMuaWNlR2F0aGVyZXIsXG4gICAgICAgICAgaWNlVHJhbnNwb3J0OiB0cmFuc3BvcnRzLmljZVRyYW5zcG9ydCxcbiAgICAgICAgICBkdGxzVHJhbnNwb3J0OiB0cmFuc3BvcnRzLmR0bHNUcmFuc3BvcnQsXG4gICAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXM6IGxvY2FsQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgIHJlbW90ZUNhcGFiaWxpdGllczogbnVsbCxcbiAgICAgICAgICBydHBTZW5kZXI6IHJ0cFNlbmRlcixcbiAgICAgICAgICBydHBSZWNlaXZlcjogcnRwUmVjZWl2ZXIsXG4gICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICBtaWQ6IG1pZCxcbiAgICAgICAgICBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzOiBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzLFxuICAgICAgICAgIHJlY3ZFbmNvZGluZ1BhcmFtZXRlcnM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMudXNpbmdCdW5kbGUpIHtcbiAgICAgICAgc2RwICs9ICdhPWdyb3VwOkJVTkRMRSAnICsgdHJhbnNjZWl2ZXJzLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgcmV0dXJuIHQubWlkO1xuICAgICAgICB9KS5qb2luKCcgJykgKyAnXFxyXFxuJztcbiAgICAgIH1cbiAgICAgIHRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKG1saW5lLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICAgIHZhciB0cmFuc2NlaXZlciA9IHRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XTtcbiAgICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLFxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXMsICdvZmZlcicsIHNlbGYubG9jYWxTdHJlYW1zWzBdKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9wZW5kaW5nT2ZmZXIgPSB0cmFuc2NlaXZlcnM7XG4gICAgICB2YXIgZGVzYyA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICB0eXBlOiAnb2ZmZXInLFxuICAgICAgICBzZHA6IHNkcFxuICAgICAgfSk7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGFyZ3VtZW50c1swXSwgMCwgZGVzYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRlc2MpO1xuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB2YXIgc2RwID0gU0RQVXRpbHMud3JpdGVTZXNzaW9uQm9pbGVycGxhdGUoKTtcbiAgICAgIGlmICh0aGlzLnVzaW5nQnVuZGxlKSB7XG4gICAgICAgIHNkcCArPSAnYT1ncm91cDpCVU5ETEUgJyArIHRoaXMudHJhbnNjZWl2ZXJzLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgcmV0dXJuIHQubWlkO1xuICAgICAgICB9KS5qb2luKCcgJykgKyAnXFxyXFxuJztcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHRyYW5zY2VpdmVyLmlzRGF0YWNoYW5uZWwpIHtcbiAgICAgICAgICBzZHAgKz0gJ209YXBwbGljYXRpb24gMCBEVExTL1NDVFAgNTAwMFxcclxcbicgK1xuICAgICAgICAgICAgICAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicgK1xuICAgICAgICAgICAgICAnYT1taWQ6JyArIHRyYW5zY2VpdmVyLm1pZCArICdcXHJcXG4nO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgaW50ZXJzZWN0aW9uIG9mIGNhcGFiaWxpdGllcy5cbiAgICAgICAgdmFyIGNvbW1vbkNhcGFiaWxpdGllcyA9IHNlbGYuX2dldENvbW1vbkNhcGFiaWxpdGllcyhcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLmxvY2FsQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgdHJhbnNjZWl2ZXIucmVtb3RlQ2FwYWJpbGl0aWVzKTtcblxuICAgICAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIsIGNvbW1vbkNhcGFiaWxpdGllcyxcbiAgICAgICAgICAgICdhbnN3ZXInLCBzZWxmLmxvY2FsU3RyZWFtc1swXSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGRlc2MgPSBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgdHlwZTogJ2Fuc3dlcicsXG4gICAgICAgIHNkcDogc2RwXG4gICAgICB9KTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoYXJndW1lbnRzWzBdLCAwLCBkZXNjKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzYyk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24oY2FuZGlkYXRlKSB7XG4gICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICB0aGlzLnRyYW5zY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LmFkZFJlbW90ZUNhbmRpZGF0ZSh7fSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1MaW5lSW5kZXggPSBjYW5kaWRhdGUuc2RwTUxpbmVJbmRleDtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZS5zZHBNaWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHJhbnNjZWl2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2NlaXZlcnNbaV0ubWlkID09PSBjYW5kaWRhdGUuc2RwTWlkKSB7XG4gICAgICAgICAgICAgIG1MaW5lSW5kZXggPSBpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYW5zY2VpdmVyID0gdGhpcy50cmFuc2NlaXZlcnNbbUxpbmVJbmRleF07XG4gICAgICAgIGlmICh0cmFuc2NlaXZlcikge1xuICAgICAgICAgIHZhciBjYW5kID0gT2JqZWN0LmtleXMoY2FuZGlkYXRlLmNhbmRpZGF0ZSkubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgIFNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlKGNhbmRpZGF0ZS5jYW5kaWRhdGUpIDoge307XG4gICAgICAgICAgLy8gSWdub3JlIENocm9tZSdzIGludmFsaWQgY2FuZGlkYXRlcyBzaW5jZSBFZGdlIGRvZXMgbm90IGxpa2UgdGhlbS5cbiAgICAgICAgICBpZiAoY2FuZC5wcm90b2NvbCA9PT0gJ3RjcCcgJiYgKGNhbmQucG9ydCA9PT0gMCB8fCBjYW5kLnBvcnQgPT09IDkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElnbm9yZSBSVENQIGNhbmRpZGF0ZXMsIHdlIGFzc3VtZSBSVENQLU1VWC5cbiAgICAgICAgICBpZiAoY2FuZC5jb21wb25lbnQgIT09ICcxJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBIGRpcnR5IGhhY2sgdG8gbWFrZSBzYW1wbGVzIHdvcmsuXG4gICAgICAgICAgaWYgKGNhbmQudHlwZSA9PT0gJ2VuZE9mQ2FuZGlkYXRlcycpIHtcbiAgICAgICAgICAgIGNhbmQgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LmFkZFJlbW90ZUNhbmRpZGF0ZShjYW5kKTtcblxuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgcmVtb3RlRGVzY3JpcHRpb24uXG4gICAgICAgICAgdmFyIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyh0aGlzLnJlbW90ZURlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgICAgc2VjdGlvbnNbbUxpbmVJbmRleCArIDFdICs9IChjYW5kLnR5cGUgPyBjYW5kaWRhdGUuY2FuZGlkYXRlLnRyaW0oKVxuICAgICAgICAgICAgICA6ICdhPWVuZC1vZi1jYW5kaWRhdGVzJykgKyAnXFxyXFxuJztcbiAgICAgICAgICB0aGlzLnJlbW90ZURlc2NyaXB0aW9uLnNkcCA9IHNlY3Rpb25zLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChhcmd1bWVudHNbMV0sIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgIHRoaXMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgWydydHBTZW5kZXInLCAncnRwUmVjZWl2ZXInLCAnaWNlR2F0aGVyZXInLCAnaWNlVHJhbnNwb3J0JyxcbiAgICAgICAgICAgICdkdGxzVHJhbnNwb3J0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgaWYgKHRyYW5zY2VpdmVyW21ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRyYW5zY2VpdmVyW21ldGhvZF0uZ2V0U3RhdHMoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgY2IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgYXJndW1lbnRzWzFdO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgLy8gc2hpbSBnZXRTdGF0cyB3aXRoIG1hcGxpa2Ugc3VwcG9ydFxuICAgICAgICB2YXIgcmVzdWx0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgcmVzLmZvckVhY2goZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0cy5zZXQoaWQsIHJlc3VsdFtpZF0pO1xuICAgICAgICAgICAgICByZXN1bHRzW2lkXSA9IHJlc3VsdFtpZF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNiLCAwLCByZXN1bHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59O1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hpbVBlZXJDb25uZWN0aW9uOiBlZGdlU2hpbS5zaGltUGVlckNvbm5lY3Rpb24sXG4gIHNoaW1HZXRVc2VyTWVkaWE6IHJlcXVpcmUoJy4vZ2V0dXNlcm1lZGlhJylcbn07XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbiAvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNoaW1FcnJvcl8gPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHtQZXJtaXNzaW9uRGVuaWVkRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InfVtlLm5hbWVdIHx8IGUubmFtZSxcbiAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgIGNvbnN0cmFpbnQ6IGUuY29uc3RyYWludCxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIGdldFVzZXJNZWRpYSBlcnJvciBzaGltLlxuICB2YXIgb3JpZ0dldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLlxuICAgICAgYmluZChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKTtcbiAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIG9yaWdHZXRVc2VyTWVkaWEoYykuY2F0Y2goZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHNoaW1FcnJvcl8oZSkpO1xuICAgIH0pO1xuICB9O1xufTtcbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuIC8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlckRldGFpbHMgPSByZXF1aXJlKCcuLi91dGlscycpLmJyb3dzZXJEZXRhaWxzO1xuXG52YXIgZmlyZWZveFNoaW0gPSB7XG4gIHNoaW1PblRyYWNrOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICEoJ29udHJhY2snIGluXG4gICAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ29udHJhY2snLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29udHJhY2s7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZikge1xuICAgICAgICAgIGlmICh0aGlzLl9vbnRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29udHJhY2twb2x5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2sgPSBmKTtcbiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29udHJhY2twb2x5ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgICAgIGV2ZW50LnRyYWNrID0gdHJhY2s7XG4gICAgICAgICAgICAgIGV2ZW50LnJlY2VpdmVyID0ge3RyYWNrOiB0cmFja307XG4gICAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgc2hpbVNvdXJjZU9iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgLy8gRmlyZWZveCBoYXMgc3VwcG9ydGVkIG1velNyY09iamVjdCBzaW5jZSBGRjIyLCB1bnByZWZpeGVkIGluIDQyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHdpbmRvdy5IVE1MTWVkaWFFbGVtZW50ICYmXG4gICAgICAgICEoJ3NyY09iamVjdCcgaW4gd2luZG93LkhUTUxNZWRpYUVsZW1lbnQucHJvdG90eXBlKSkge1xuICAgICAgICAvLyBTaGltIHRoZSBzcmNPYmplY3QgcHJvcGVydHksIG9uY2UsIHdoZW4gSFRNTE1lZGlhRWxlbWVudCBpcyBmb3VuZC5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5IVE1MTWVkaWFFbGVtZW50LnByb3RvdHlwZSwgJ3NyY09iamVjdCcsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW96U3JjT2JqZWN0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMubW96U3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHNoaW1QZWVyQ29ubmVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8XG4gICAgICAgIHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICAgIHJldHVybjsgLy8gcHJvYmFibHkgbWVkaWEucGVlcmNvbm5lY3Rpb24uZW5hYmxlZD1mYWxzZSBpbiBhYm91dDpjb25maWdcbiAgICB9XG4gICAgLy8gVGhlIFJUQ1BlZXJDb25uZWN0aW9uIG9iamVjdC5cbiAgICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gZnVuY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpIHtcbiAgICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCAzOCkge1xuICAgICAgICAgIC8vIC51cmxzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gRkYgPCAzOC5cbiAgICAgICAgICAvLyBjcmVhdGUgUlRDSWNlU2VydmVycyB3aXRoIGEgc2luZ2xlIHVybC5cbiAgICAgICAgICBpZiAocGNDb25maWcgJiYgcGNDb25maWcuaWNlU2VydmVycykge1xuICAgICAgICAgICAgdmFyIG5ld0ljZVNlcnZlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGNDb25maWcuaWNlU2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgc2VydmVyID0gcGNDb25maWcuaWNlU2VydmVyc1tpXTtcbiAgICAgICAgICAgICAgaWYgKHNlcnZlci5oYXNPd25Qcm9wZXJ0eSgndXJscycpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXJ2ZXIudXJscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgdmFyIG5ld1NlcnZlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzZXJ2ZXIudXJsc1tqXVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXIudXJsc1tqXS5pbmRleE9mKCd0dXJuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VydmVyLnVzZXJuYW1lID0gc2VydmVyLnVzZXJuYW1lO1xuICAgICAgICAgICAgICAgICAgICBuZXdTZXJ2ZXIuY3JlZGVudGlhbCA9IHNlcnZlci5jcmVkZW50aWFsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbmV3SWNlU2VydmVycy5wdXNoKG5ld1NlcnZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGNDb25maWcuaWNlU2VydmVycyA9IG5ld0ljZVNlcnZlcnM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgbW96UlRDUGVlckNvbm5lY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgPSBtb3pSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG5cbiAgICAgIC8vIHdyYXAgc3RhdGljIG1ldGhvZHMuIEN1cnJlbnRseSBqdXN0IGdlbmVyYXRlQ2VydGlmaWNhdGUuXG4gICAgICBpZiAobW96UlRDUGVlckNvbm5lY3Rpb24uZ2VuZXJhdGVDZXJ0aWZpY2F0ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLCAnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1velJUQ1BlZXJDb25uZWN0aW9uLmdlbmVyYXRlQ2VydGlmaWNhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IG1velJUQ1Nlc3Npb25EZXNjcmlwdGlvbjtcbiAgICAgIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgPSBtb3pSVENJY2VDYW5kaWRhdGU7XG4gICAgfVxuXG4gICAgLy8gc2hpbSBhd2F5IG5lZWQgZm9yIG9ic29sZXRlIFJUQ0ljZUNhbmRpZGF0ZS9SVENTZXNzaW9uRGVzY3JpcHRpb24uXG4gICAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJywgJ2FkZEljZUNhbmRpZGF0ZSddXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgIHZhciBuYXRpdmVNZXRob2QgPSBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgICAgICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3ICgobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJykgP1xuICAgICAgICAgICAgICAgIFJUQ0ljZUNhbmRpZGF0ZSA6IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgIC8vIHN1cHBvcnQgZm9yIGFkZEljZUNhbmRpZGF0ZShudWxsIG9yIHVuZGVmaW5lZClcbiAgICB2YXIgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlID1cbiAgICAgICAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcbiAgICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzWzFdKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzFdLmFwcGx5KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVBZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA0OCkge1xuICAgICAgLy8gc2hpbSBnZXRTdGF0cyB3aXRoIG1hcGxpa2Ugc3VwcG9ydFxuICAgICAgdmFyIG1ha2VNYXBTdGF0cyA9IGZ1bmN0aW9uKHN0YXRzKSB7XG4gICAgICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0YXRzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIG1hcC5zZXQoa2V5LCBzdGF0c1trZXldKTtcbiAgICAgICAgICBtYXBba2V5XSA9IHN0YXRzW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfTtcblxuICAgICAgdmFyIG5hdGl2ZUdldFN0YXRzID0gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICAgICAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24oc2VsZWN0b3IsIG9uU3VjYywgb25FcnIpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUdldFN0YXRzLmFwcGx5KHRoaXMsIFtzZWxlY3RvciB8fCBudWxsXSlcbiAgICAgICAgICAudGhlbihmdW5jdGlvbihzdGF0cykge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VNYXBTdGF0cyhzdGF0cyk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihvblN1Y2MsIG9uRXJyKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2hpbU9uVHJhY2s6IGZpcmVmb3hTaGltLnNoaW1PblRyYWNrLFxuICBzaGltU291cmNlT2JqZWN0OiBmaXJlZm94U2hpbS5zaGltU291cmNlT2JqZWN0LFxuICBzaGltUGVlckNvbm5lY3Rpb246IGZpcmVmb3hTaGltLnNoaW1QZWVyQ29ubmVjdGlvbixcbiAgc2hpbUdldFVzZXJNZWRpYTogcmVxdWlyZSgnLi9nZXR1c2VybWVkaWEnKVxufTtcbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuIC8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbG9nZ2luZyA9IHJlcXVpcmUoJy4uL3V0aWxzJykubG9nO1xudmFyIGJyb3dzZXJEZXRhaWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5icm93c2VyRGV0YWlscztcblxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNoaW1FcnJvcl8gPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHtcbiAgICAgICAgU2VjdXJpdHlFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIFBlcm1pc3Npb25EZW5pZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcidcbiAgICAgIH1bZS5uYW1lXSB8fCBlLm5hbWUsXG4gICAgICBtZXNzYWdlOiB7XG4gICAgICAgICdUaGUgb3BlcmF0aW9uIGlzIGluc2VjdXJlLic6ICdUaGUgcmVxdWVzdCBpcyBub3QgYWxsb3dlZCBieSB0aGUgJyArXG4gICAgICAgICd1c2VyIGFnZW50IG9yIHRoZSBwbGF0Zm9ybSBpbiB0aGUgY3VycmVudCBjb250ZXh0LidcbiAgICAgIH1bZS5tZXNzYWdlXSB8fCBlLm1lc3NhZ2UsXG4gICAgICBjb25zdHJhaW50OiBlLmNvbnN0cmFpbnQsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAodGhpcy5tZXNzYWdlICYmICc6ICcpICsgdGhpcy5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gZ2V0VXNlck1lZGlhIGNvbnN0cmFpbnRzIHNoaW0uXG4gIHZhciBnZXRVc2VyTWVkaWFfID0gZnVuY3Rpb24oY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIHZhciBjb25zdHJhaW50c1RvRkYzN18gPSBmdW5jdGlvbihjKSB7XG4gICAgICBpZiAodHlwZW9mIGMgIT09ICdvYmplY3QnIHx8IGMucmVxdWlyZSkge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICAgIHZhciByZXF1aXJlID0gW107XG4gICAgICBPYmplY3Qua2V5cyhjKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09PSAncmVxdWlyZScgfHwga2V5ID09PSAnYWR2YW5jZWQnIHx8IGtleSA9PT0gJ21lZGlhU291cmNlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IGNba2V5XSA9ICh0eXBlb2YgY1trZXldID09PSAnb2JqZWN0JykgP1xuICAgICAgICAgICAgY1trZXldIDoge2lkZWFsOiBjW2tleV19O1xuICAgICAgICBpZiAoci5taW4gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgci5tYXggIT09IHVuZGVmaW5lZCB8fCByLmV4YWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXF1aXJlLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByLmV4YWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgci4gbWluID0gci5tYXggPSByLmV4YWN0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjW2tleV0gPSByLmV4YWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgci5leGFjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoci5pZGVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYy5hZHZhbmNlZCA9IGMuYWR2YW5jZWQgfHwgW107XG4gICAgICAgICAgdmFyIG9jID0ge307XG4gICAgICAgICAgaWYgKHR5cGVvZiByLmlkZWFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgb2Nba2V5XSA9IHttaW46IHIuaWRlYWwsIG1heDogci5pZGVhbH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9jW2tleV0gPSByLmlkZWFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjLmFkdmFuY2VkLnB1c2gob2MpO1xuICAgICAgICAgIGRlbGV0ZSByLmlkZWFsO1xuICAgICAgICAgIGlmICghT2JqZWN0LmtleXMocikubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWxldGUgY1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocmVxdWlyZS5sZW5ndGgpIHtcbiAgICAgICAgYy5yZXF1aXJlID0gcmVxdWlyZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH07XG4gICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCAzOCkge1xuICAgICAgbG9nZ2luZygnc3BlYzogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICBpZiAoY29uc3RyYWludHMuYXVkaW8pIHtcbiAgICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBjb25zdHJhaW50c1RvRkYzN18oY29uc3RyYWludHMuYXVkaW8pO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnN0cmFpbnRzLnZpZGVvKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0ZGMzdfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2ZmMzc6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIH1cbiAgICByZXR1cm4gbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYShjb25zdHJhaW50cywgb25TdWNjZXNzLCBmdW5jdGlvbihlKSB7XG4gICAgICBvbkVycm9yKHNoaW1FcnJvcl8oZSkpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBnZXRVc2VyTWVkaWEgYXMgYSBQcm9taXNlLlxuICB2YXIgZ2V0VXNlck1lZGlhUHJvbWlzZV8gPSBmdW5jdGlvbihjb25zdHJhaW50cykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGdldFVzZXJNZWRpYV8oY29uc3RyYWludHMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gU2hpbSBmb3IgbWVkaWFEZXZpY2VzIG9uIG9sZGVyIHZlcnNpb25zLlxuICBpZiAoIW5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzID0ge2dldFVzZXJNZWRpYTogZ2V0VXNlck1lZGlhUHJvbWlzZV8sXG4gICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHsgfSxcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkgeyB9XG4gICAgfTtcbiAgfVxuICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMgPVxuICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgIHZhciBpbmZvcyA9IFtcbiAgICAgICAgICAgIHtraW5kOiAnYXVkaW9pbnB1dCcsIGRldmljZUlkOiAnZGVmYXVsdCcsIGxhYmVsOiAnJywgZ3JvdXBJZDogJyd9LFxuICAgICAgICAgICAge2tpbmQ6ICd2aWRlb2lucHV0JywgZGV2aWNlSWQ6ICdkZWZhdWx0JywgbGFiZWw6ICcnLCBncm91cElkOiAnJ31cbiAgICAgICAgICBdO1xuICAgICAgICAgIHJlc29sdmUoaW5mb3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA0MSkge1xuICAgIC8vIFdvcmsgYXJvdW5kIGh0dHA6Ly9idWd6aWwubGEvMTE2OTY2NVxuICAgIHZhciBvcmdFbnVtZXJhdGVEZXZpY2VzID1cbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzLmJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gb3JnRW51bWVyYXRlRGV2aWNlcygpLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJykge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDQ5KSB7XG4gICAgdmFyIG9yaWdHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5cbiAgICAgICAgYmluZChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBvcmlnR2V0VXNlck1lZGlhKGMpLnRoZW4oZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIC8vIFdvcmsgYXJvdW5kIGh0dHBzOi8vYnVnemlsLmxhLzgwMjMyNlxuICAgICAgICBpZiAoYy5hdWRpbyAmJiAhc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoIHx8XG4gICAgICAgICAgICBjLnZpZGVvICYmICFzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvYmplY3QgY2FuIG5vdCBiZSBmb3VuZCBoZXJlLicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTm90Rm91bmRFcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChzaGltRXJyb3JfKGUpKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDQ0KSB7XG4gICAgICByZXR1cm4gZ2V0VXNlck1lZGlhXyhjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZSBGaXJlZm94IDQ0KydzIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2l0aCB1bnByZWZpeGVkIHZlcnNpb24uXG4gICAgY29uc29sZS53YXJuKCduYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIGhhcyBiZWVuIHJlcGxhY2VkIGJ5ICcgK1xuICAgICAgICAgICAgICAgICAnbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEnKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICB9O1xufTtcbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIHNhZmFyaVNoaW0gPSB7XG4gIC8vIFRPRE86IERyQWxleCwgc2hvdWxkIGJlIGhlcmUsIGRvdWJsZSBjaGVjayBhZ2FpbnN0IExheW91dFRlc3RzXG4gIC8vIHNoaW1PblRyYWNrOiBmdW5jdGlvbigpIHsgfSxcblxuICAvLyBUT0RPOiBvbmNlIHRoZSBiYWNrLWVuZCBmb3IgdGhlIG1hYyBwb3J0IGlzIGRvbmUsIGFkZC5cbiAgLy8gVE9ETzogY2hlY2sgZm9yIHdlYmtpdEdUSytcbiAgLy8gc2hpbVBlZXJDb25uZWN0aW9uOiBmdW5jdGlvbigpIHsgfSxcblxuICBzaGltR2V0VXNlck1lZGlhOiBmdW5jdGlvbigpIHtcbiAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYTtcbiAgfVxufTtcblxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNoaW1HZXRVc2VyTWVkaWE6IHNhZmFyaVNoaW0uc2hpbUdldFVzZXJNZWRpYVxuICAvLyBUT0RPXG4gIC8vIHNoaW1PblRyYWNrOiBzYWZhcmlTaGltLnNoaW1PblRyYWNrLFxuICAvLyBzaGltUGVlckNvbm5lY3Rpb246IHNhZmFyaVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uXG59O1xuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4gLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsb2dEaXNhYmxlZF8gPSB0cnVlO1xuXG4vLyBVdGlsaXR5IG1ldGhvZHMuXG52YXIgdXRpbHMgPSB7XG4gIGRpc2FibGVMb2c6IGZ1bmN0aW9uKGJvb2wpIHtcbiAgICBpZiAodHlwZW9mIGJvb2wgIT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignQXJndW1lbnQgdHlwZTogJyArIHR5cGVvZiBib29sICtcbiAgICAgICAgICAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcbiAgICB9XG4gICAgbG9nRGlzYWJsZWRfID0gYm9vbDtcbiAgICByZXR1cm4gKGJvb2wpID8gJ2FkYXB0ZXIuanMgbG9nZ2luZyBkaXNhYmxlZCcgOlxuICAgICAgICAnYWRhcHRlci5qcyBsb2dnaW5nIGVuYWJsZWQnO1xuICB9LFxuXG4gIGxvZzogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAobG9nRGlzYWJsZWRfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGJyb3dzZXIgdmVyc2lvbiBvdXQgb2YgdGhlIHByb3ZpZGVkIHVzZXIgYWdlbnQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHVhc3RyaW5nIHVzZXJBZ2VudCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gZXhwciBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCBhcyBtYXRjaCBjcml0ZXJpYS5cbiAgICogQHBhcmFtIHshbnVtYmVyfSBwb3MgcG9zaXRpb24gaW4gdGhlIHZlcnNpb24gc3RyaW5nIHRvIGJlIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHshbnVtYmVyfSBicm93c2VyIHZlcnNpb24uXG4gICAqL1xuICBleHRyYWN0VmVyc2lvbjogZnVuY3Rpb24odWFzdHJpbmcsIGV4cHIsIHBvcykge1xuICAgIHZhciBtYXRjaCA9IHVhc3RyaW5nLm1hdGNoKGV4cHIpO1xuICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPj0gcG9zICYmIHBhcnNlSW50KG1hdGNoW3Bvc10sIDEwKTtcbiAgfSxcblxuICAvKipcbiAgICogQnJvd3NlciBkZXRlY3Rvci5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSByZXN1bHQgY29udGFpbmluZyBicm93c2VyIGFuZCB2ZXJzaW9uXG4gICAqICAgICBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgZGV0ZWN0QnJvd3NlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gUmV0dXJuZWQgcmVzdWx0IG9iamVjdC5cbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgcmVzdWx0LmJyb3dzZXIgPSBudWxsO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gbnVsbDtcblxuICAgIC8vIEZhaWwgZWFybHkgaWYgaXQncyBub3QgYSBicm93c2VyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cubmF2aWdhdG9yKSB7XG4gICAgICByZXN1bHQuYnJvd3NlciA9ICdOb3QgYSBicm93c2VyLic7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3guXG4gICAgaWYgKG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEpIHtcbiAgICAgIHJlc3VsdC5icm93c2VyID0gJ2ZpcmVmb3gnO1xuICAgICAgcmVzdWx0LnZlcnNpb24gPSB0aGlzLmV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgICAgL0ZpcmVmb3hcXC8oWzAtOV0rKVxcLi8sIDEpO1xuXG4gICAgLy8gYWxsIHdlYmtpdC1iYXNlZCBicm93c2Vyc1xuICAgIH0gZWxzZSBpZiAobmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSkge1xuICAgICAgLy8gQ2hyb21lLCBDaHJvbWl1bSwgV2VidmlldywgT3BlcmEsIGFsbCB1c2UgdGhlIGNocm9tZSBzaGltIGZvciBub3dcbiAgICAgIGlmICh3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0LmJyb3dzZXIgPSAnY2hyb21lJztcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB0aGlzLmV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAgICAgL0Nocm9tKGV8aXVtKVxcLyhbMC05XSspXFwuLywgMik7XG5cbiAgICAgIC8vIFNhZmFyaSBvciB1bmtub3duIHdlYmtpdC1iYXNlZFxuICAgICAgLy8gZm9yIHRoZSB0aW1lIGJlaW5nIFNhZmFyaSBoYXMgc3VwcG9ydCBmb3IgTWVkaWFTdHJlYW1zIGJ1dCBub3Qgd2ViUlRDXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTYWZhcmkgVUEgc3Vic3RyaW5ncyBvZiBpbnRlcmVzdCBmb3IgcmVmZXJlbmNlOlxuICAgICAgICAvLyAtIHdlYmtpdCB2ZXJzaW9uOiAgICAgICAgICAgQXBwbGVXZWJLaXQvNjAyLjEuMjUgKGFsc28gdXNlZCBpbiBPcCxDcilcbiAgICAgICAgLy8gLSBzYWZhcmkgVUkgdmVyc2lvbjogICAgICAgIFZlcnNpb24vOS4wLjMgKHVuaXF1ZSB0byBTYWZhcmkpXG4gICAgICAgIC8vIC0gc2FmYXJpIFVJIHdlYmtpdCB2ZXJzaW9uOiBTYWZhcmkvNjAxLjQuNCAoYWxzbyB1c2VkIGluIE9wLENyKVxuICAgICAgICAvL1xuICAgICAgICAvLyBpZiB0aGUgd2Via2l0IHZlcnNpb24gYW5kIHNhZmFyaSBVSSB3ZWJraXQgdmVyc2lvbnMgYXJlIGVxdWFscyxcbiAgICAgICAgLy8gLi4uIHRoaXMgaXMgYSBzdGFibGUgdmVyc2lvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gb25seSB0aGUgaW50ZXJuYWwgd2Via2l0IHZlcnNpb24gaXMgaW1wb3J0YW50IHRvZGF5IHRvIGtub3cgaWZcbiAgICAgICAgLy8gbWVkaWEgc3RyZWFtcyBhcmUgc3VwcG9ydGVkXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFxcZCspLihcXGQrKS8pKSB7XG4gICAgICAgICAgcmVzdWx0LmJyb3dzZXIgPSAnc2FmYXJpJztcbiAgICAgICAgICByZXN1bHQudmVyc2lvbiA9IHRoaXMuZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICAgIC9BcHBsZVdlYktpdFxcLyhbMC05XSspXFwuLywgMSk7XG5cbiAgICAgICAgLy8gdW5rbm93biB3ZWJraXQtYmFzZWQgYnJvd3NlclxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5icm93c2VyID0gJ1Vuc3VwcG9ydGVkIHdlYmtpdC1iYXNlZCBicm93c2VyICcgK1xuICAgICAgICAgICAgICAnd2l0aCBHVU0gc3VwcG9ydCBidXQgbm8gV2ViUlRDIHN1cHBvcnQuJztcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAvLyBFZGdlLlxuICAgIH0gZWxzZSBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJlxuICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLihcXGQrKSQvKSkge1xuICAgICAgcmVzdWx0LmJyb3dzZXIgPSAnZWRnZSc7XG4gICAgICByZXN1bHQudmVyc2lvbiA9IHRoaXMuZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgICAvRWRnZVxcLyhcXGQrKS4oXFxkKykkLywgMik7XG5cbiAgICAvLyBEZWZhdWx0IGZhbGx0aHJvdWdoOiBub3Qgc3VwcG9ydGVkLlxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuYnJvd3NlciA9ICdOb3QgYSBzdXBwb3J0ZWQgYnJvd3Nlci4nO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vLyBFeHBvcnQuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbG9nOiB1dGlscy5sb2csXG4gIGRpc2FibGVMb2c6IHV0aWxzLmRpc2FibGVMb2csXG4gIGJyb3dzZXJEZXRhaWxzOiB1dGlscy5kZXRlY3RCcm93c2VyKCksXG4gIGV4dHJhY3RWZXJzaW9uOiB1dGlscy5leHRyYWN0VmVyc2lvblxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iLCJ2YXIgYnVzID0gcmVxdWlyZSgncGFnZS1idXMnKVxudmFyIHNob3J0ID0gcmVxdWlyZSgnc2hvcnQtdXVpZCcpXG52YXIgaWQgPSBzaG9ydCgpLmdlbmVyYXRlKClcbnZhciBlbWl0dGVycyA9IHt9XG52YXIgbmFtZXMgPSBbXVxudmFyIG1ldGEgPSBidXMoe2tleTogJ19tZXRhXyd9KVxudmFyIGpvaW4gPSBidXMoe2tleTogJ19qb2luXyd9KVxudmFyIHNlbGYgPSBidXMoe2tleTogaWR9KVxudmFyIHN3YXJtID0ge30gLy8gaWRzXG52YXIgY291bnQgPSAwXG5cbmpvaW4uZW1pdCgnZGF0YScsIHtpZDogaWR9KVxuXG5qb2luLm9uKCdkYXRhJywgZSA9PiB7XG4gIGlmKGUuaWQgPT0gaWQpIHJldHVyblxuICBsZXQgZW0gPSBzd2FybVtlLmlkXSA9IGJ1cyh7a2V5OiBlLmlkfSlcbiAgY291bnQrK1xuICBpZihNYXRoLnJhbmRvbSgpIDw9IDEgLyBNYXRoLnBvdyhjb3VudCwgMikpIHJldHVyblxuICBlbHNlIGVtLmVtaXQoJ2RhdGEnLCB7ZXZlbnRzOiBuYW1lcywgc3dhbXJtOiBPYmplY3Qua2V5cyhzd2FybSl9KVxufSlcblxuc2VsZi5vbignZGF0YScsIGUgPT4ge1xuICBlLmV2ZW50cy5mb3JFYWNoKGV2ID0+IHtcbiAgICBpZighZW1pdHRlcnNbZS5uYW1lXSkge1xuICAgICAgdmFyIGVtaXR0ZXIgPSBlbWl0dGVyc1tlLm5hbWVdID0gYnVzKHtrZXk6ZS5uYW1lfSlcbiAgICB9XG4gIH0pXG4gIGUuc3dhcm0uZm9yRWFjaChzID0+IHtcbiAgICBpZighc3dhcm1bc10pIHN3YXJtW3NdID0gYnVzKHtrZXk6IHN9KVxuICB9KVxuIGNvdW50ID0gc3dhcm0ubGVuZ3RoXG59KVxuXG5tZXRhLm9uKCdkYXRhJywgZSA9PiB7XG4gIGlmKCFlbWl0dGVyc1tlLm5hbWVdKSBlbWl0dGVyc1tlLm5hbWVdID0gYnVzKHtrZXk6ZS5uYW1lfSlcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0ge29uLCBvbmNlLCBlbWl0fVxuXG5mdW5jdGlvbiBvbihuYW1lLCBmbil7XG4gIGlmKCFlbWl0dGVyc1tuYW1lXSkge1xuICAgIG5hbWVzLnB1c2gobmFtZSlcbiAgICBtZXRhLmVtaXQoJ2RhdGEnLCB7bmFtZTogbmFtZX0pXG4gICAgc2V0VGltZW91dChlID0+IG9uKG5hbWUsIGZuKSwgMClcbiAgfSAgXG4gIGVsc2Uge1xuICAgIGVtaXR0ZXJzW25hbWVdLm9uKG5hbWUsIGZuKVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uY2UobmFtZSwgZm4pe1xuICBpZighZW1pdHRlcnNbbmFtZV0pIHtcbiAgICBtZXRhLmVtaXQoJ2RhdGEnLCB7bmFtZTogbmFtZX0pXG4gICAgc2V0VGltZW91dChlID0+IG9uKG5hbWUsIGZuKSwgMClcbiAgfSAgXG4gIGVsc2UgZW1pdHRlcnNbbmFtZV0ub25jZShuYW1lLCBmbilcbn1cblxuZnVuY3Rpb24gZW1pdChuYW1lLCBkYXRhKXtcbiAgaWYoIWVtaXR0ZXJzW25hbWVdKSB7XG4gICAgbWV0YS5lbWl0KCdkYXRhJywge25hbWU6IG5hbWV9KVxuICAgIHNldFRpbWVvdXQoZSA9PiBlbWl0KG5hbWUsIGRhdGEsIDApKVxuICB9ICBcbiAgZWxzZSBlbWl0dGVyc1tuYW1lXS5lbWl0KG5hbWUsIGRhdGEpXG59XG4iLCJ2YXIgbXMycyA9IDEuMCAvIDEwMDAuMDtcbnZhciBuczJtcyA9IDEuMCAvIDEwMDAwMDAuMFxudmFyIG5zMnMgPSAxZS05XG5cbm1vZHVsZS5leHBvcnRzID0gVFxuXG5mdW5jdGlvbiBUKCl7XG5cdGlmKCFwcm9jZXNzLmhydGltZSl7IC8vIGJyb3dzZXIgZmlsbFxuXG5cdFx0cHJvY2Vzcy5ocnRpbWUgPSBmdW5jdGlvbigpe1xuXG5cdFx0XHRpZihhcmd1bWVudHMubGVuZ3RoKXtcblx0XHRcdFx0YXJndW1lbnRzWzFdID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XHRcdGFyZ3VtZW50c1swXSA9ICBhcmd1bWVudHNbMV0gLSBtaWxsaWVzKGFyZ3VtZW50c1swXSlcblx0XHRcdH1cblxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGFyZ3VtZW50c1swXSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gW3BhcnNlSW50KGFyZ3VtZW50c1swXSAqIG1zMnMpLCBwYXJzZUludCgoKGFyZ3VtZW50c1swXSAqIG1zMnMpICUgMSkgLyBuczJzKV07XG5cdFx0XHRcblx0XHR9XG5cdH1cbiAgaWYoISh0aGlzIGluc3RhbmNlb2YgVCkpIHJldHVybiBuZXcgVCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuc3RhcnQgPSBzZWxmLmxhc3QgPSBzZWxmLmJlYXQgPSBwcm9jZXNzLmhydGltZSgpO1xuICBzZWxmLnggPSBbXVxuICBzZWxmLmVuZCA9IFtdXG4gIHNlbGYuYmVhdHMgPSAgW11cbiAgc2VsZi5hdmVyYWdlU2V0U2l6ZSA9IDMzM1xuICBzZWxmLnRocmVzaG9sZCA9IDFlNiAvLyAxMCwwMDAsMDAwIG5zICggMTAgbXMgKVxuICBzZWxmLnNraXAgPSBmYWxzZVxufTtcblxuVC5wcm90b3R5cGUuc2luY2VCZWdpbiA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBwcm9jZXNzLmhydGltZSh0aGlzLnN0YXJ0KVxufTtcblxuVC5wcm90b3R5cGUuc2luY2VMYXN0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy54ID0gcHJvY2Vzcy5ocnRpbWUodGhpcy5sYXN0KVxuICB0aGlzLmxhc3QgPSBwcm9jZXNzLmhydGltZSgpXG4gIHJldHVybiB0aGlzLnhcbn1cblxuVC5wcm90b3R5cGUuc2luY2VMYXN0TlMgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gbmFub3ModGhpcy5zaW5jZUxhc3QoKSlcbn07XG5cblQucHJvdG90eXBlLnNpbmNlQmVnaW5OUyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBuYW5vcyh0aGlzLnNpbmNlQmVnaW4oKSlcbn07XG5cblQucHJvdG90eXBlLmF2ZyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBucyA9IG5hbm9zKHRoaXMuc2luY2VMYXN0KCkpXG4gIHRoaXMuYmVhdHMucHVzaChucyk7XG4gIHRoaXMuYmVhdHMgPSB0aGlzLmJlYXRzLnNwbGljZSgtdGhpcy5hdmVyYWdlU2V0U2l6ZSlcbiAgcmV0dXJuIGF2Zyh0aGlzLmJlYXRzKTtcbn07XG5cblQucHJvdG90eXBlLmV2ZXJ5UyA9IGZ1bmN0aW9uKHMsIGZuLCBnbyl7XG5cdHRoaXMuZXZlcnkocyAqIDFlOSwgZm4sIGdvKVxufVxuXG5ULnByb3RvdHlwZS5ldmVyeSA9IGZ1bmN0aW9uKG5zLCBmbiwgZ28pe1xuXG4gIHZhciBzZWxmID0gbmV3IFQoKTtcbiAgdmFyIHRpbWVyID0gbmV3IFQoKTtcblxuICB2YXIgaW50ZXIgPSBucyB8fCAwXG4gICAgLCBmbiA9IGZuIHx8IGZ1bmN0aW9uKHQsYyl7YygpfVxuICAgIDsgICBcbiAgICAgIFxuICBmdW5jdGlvbiB0aWNrKCl7XG5cbiAgICB2YXIgbnMgPSBuYW5vcyhzZWxmLnNpbmNlTGFzdCgpKTtcbi8vICB1bm5lY2Vzc2FyeSBjdXogbm8gbG9uZ2VyIHRyeWluZyB0byBvcHRpbWl6ZSBpbiBsb29wKClcbi8vICAgIHNlbGYuYmVhdHMucHVzaChucyk7XG4gICAgbG9vcCgpXG5cbiAgfTtcblxuICBmdW5jdGlvbiBsb29wKCl7XG4gICAgdmFyIGQgPSBpbnRlciAtIChuYW5vcyhwcm9jZXNzLmhydGltZSgpKSAtIG5hbm9zKHNlbGYuYmVhdCkpO1xuXG4gICAgaWYoZCA8IDEwMDAwKSB7XG4gICAgICB0b2NrKClcbiAgICB9XG5cbiAgICBlbHNlIGlmKHNlbGYuc2tpcCkge1xuICAgICBzZXRJbW1lZGlhdGUobG9vcClcbiAgICB9XG5cbiAgICBlbHNlIGlmKGQgPCBzZWxmLnRocmVzaG9sZCkge1xuICAgICAgLy8gdW5kZXIgdGhlIHRocmVzaG9sZCwgaXRzIG5leHRUaWNrcyB1bnRpbCB0aGUgaW50ZXJ2YWwgaXMgdXBcbiAgICAgIHNlbGYuc2tpcCA9IHRydWU7IHNldEltbWVkaWF0ZShsb29wKSBcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIGlmKGZhbHNlICYmIHNlbGYuYmVhdHMubGVuZ3RoID4gOSkge1xuICAgICAgICB2YXIgciA9IHNlbGYuYmVhdHMubGVuZ3RoIC8gc2VsZi5hdmVyYWdlU2V0U2l6ZTtcbiAgICAgICAgc2VsZi50aHJlc2hvbGQgPSBhdmcoc2VsZi5iZWF0cykgKiAuNDUgKiByICogMlxuICAgICAgfVxuXG4gICAgICAvLyBmb3IgZnV0dXJlIHJlZmVyZW5jZTpcbiAgICAgIC8vIGNvbnNvbGUubG9nKGF2ZyhzZWxmLmJlYXRzKSwgc2VsZi5iZWF0cy5sZW5ndGgsICd0aHJlc2hvbGQgPSAnICsgc2VsZi50aHJlc2hvbGQpXG5cbiAgICAgIHNlbGYuc2tpcCA9IGZhbHNlOyBcbiAgICAgIHNldFRpbWVvdXQobG9vcCwgc2VsZi50aHJlc2hvbGQgLyAxZTYpXG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHRvY2soKXtcbiAgICBzZWxmLmJlYXQgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgIHNlbGYuc2tpcCA9IGZhbHNlO1xuICAgIGZuKHRpY2ssIG5hbm9zKHRpbWVyLnNpbmNlTGFzdCgpKSlcbiAgfTtcbiAgXG4gIGlmKGdvKSB0b2NrKClcblxuICBlbHNlIGxvb3AoKVxuXG59XG5cbmZ1bmN0aW9uIG1pbGxpZXMoYXJyKXtcblx0cmV0dXJuIChhcnJbMF0gKiAxZTMpICsgKGFyclsxXSAqIG5zMm1zKVxufVxuXG5mdW5jdGlvbiBuYW5vcyhhcnIpe1xuICByZXR1cm4gYXJyWzBdICogMWU5ICsgYXJyWzFdXG59XG5cbmZ1bmN0aW9uIGFkZChhLCBiKXtcbiAgdmFyIG5zID0gYVsxXSArIGJbMV07XG4gIGJbMF0gKz0gYVswXTtcbiAgYlsxXSA9IG5zICUgMWU5O1xuICBpZihucyAhPT0gYlsxXSkgYlswXSsrO1xuICByZXR1cm4gYlxufTtcblxuZnVuY3Rpb24gYXZnKCl7XG5cbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50c1swXSkucmVkdWNlKGZ1bmN0aW9uKGEsaSl7cmV0dXJuIGEgKz0gaSB9LDApIC8gYXJndW1lbnRzWzBdLmxlbmd0aFxuXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwb3NzaWJsZU5hbWVzID0gW1xuXHQnQmlnSW50NjRBcnJheScsXG5cdCdCaWdVaW50NjRBcnJheScsXG5cdCdGbG9hdDMyQXJyYXknLFxuXHQnRmxvYXQ2NEFycmF5Jyxcblx0J0ludDE2QXJyYXknLFxuXHQnSW50MzJBcnJheScsXG5cdCdJbnQ4QXJyYXknLFxuXHQnVWludDE2QXJyYXknLFxuXHQnVWludDMyQXJyYXknLFxuXHQnVWludDhBcnJheScsXG5cdCdVaW50OENsYW1wZWRBcnJheSdcbl07XG5cbnZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogZ2xvYmFsVGhpcztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5cygpIHtcblx0dmFyIG91dCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHBvc3NpYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodHlwZW9mIGdbcG9zc2libGVOYW1lc1tpXV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG91dFtvdXQubGVuZ3RoXSA9IHBvc3NpYmxlTmFtZXNbaV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmQgPSByZXF1aXJlKCcuLycpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoXG5cdFx0XHRcdGZ1bmMsXG5cdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScpO1xuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCJcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoIChvYmosIGZuLCBjdHgpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiBFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiBFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcblx0dmFyIHZhbHVlO1xuXHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuXHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRpZiAoZ2VuKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgTEVHQUNZX0FMSUFTRVMgPSB7XG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbDtcbnZhciBoYXNTeW1ib2xTaGFtID0gcmVxdWlyZSgnLi9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgY29tcGxleGl0eTogWzIsIDE4XSwgbWF4LXN0YXRlbWVudHM6IFsyLCAzM10gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdHZhciBvYmogPSB7fTtcblx0dmFyIHN5bSA9IFN5bWJvbCgndGVzdCcpO1xuXHR2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG5cdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bU9iaikgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvb2JqZWN0LmFzc2lnbi9pc3N1ZXMvMTdcblx0Ly8gaWYgKHN5bSBpbnN0YW5jZW9mIFN5bWJvbCkgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XG5cdC8vIGlmICghKHN5bU9iaiBpbnN0YW5jZW9mIFN5bWJvbCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gaWYgKHR5cGVvZiBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyBpZiAoU3RyaW5nKHN5bSkgIT09IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1WYWwgPSA0Mjtcblx0b2JqW3N5bV0gPSBzeW1WYWw7XG5cdGZvciAoc3ltIGluIG9iaikgeyByZXR1cm4gZmFsc2U7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tdW5yZWFjaGFibGUtbG9vcFxuXHRpZiAodHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG5cdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSk7XG5cdFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMvc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNUb1N0cmluZ1RhZ1NoYW1zKCkge1xuXHRyZXR1cm4gaGFzU3ltYm9scygpICYmICEhU3ltYm9sLnRvU3RyaW5nVGFnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cyk7XG59KCkpO1xuXG5pc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHM7IC8vIGZvciB0ZXN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmblRvU3RyID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRm5SZWdleCA9IC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBHZW5lcmF0b3JGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdGlmICghZ2V0UHJvdG8pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgZ2VuZXJhdG9yRnVuYyA9IGdldEdlbmVyYXRvckZ1bmMoKTtcblx0XHRHZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90byhnZW5lcmF0b3JGdW5jKSA6IGZhbHNlO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG52YXIgYXZhaWxhYmxlVHlwZWRBcnJheXMgPSByZXF1aXJlKCdhdmFpbGFibGUtdHlwZWQtYXJyYXlzJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IGdsb2JhbFRoaXM7XG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQm91bmQoJ0FycmF5LnByb3RvdHlwZS5pbmRleE9mJywgdHJ1ZSkgfHwgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikge1xuXHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdH1cblx0XHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHRcdH1cblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBhbnlUcnVlID0gZmFsc2U7XG5cdGZvckVhY2godG9TdHJUYWdzLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFhbnlUcnVlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhbnlUcnVlID0gZ2V0dGVyLmNhbGwodmFsdWUpID09PSB0eXBlZEFycmF5O1xuXHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gYW55VHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZyB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkpIHtcblx0XHR2YXIgdGFnID0gJHNsaWNlKCR0b1N0cmluZyh2YWx1ZSksIDgsIC0xKTtcblx0XHRyZXR1cm4gJGluZGV4T2YodHlwZWRBcnJheXMsIHRhZykgPiAtMTtcblx0fVxuXHRpZiAoIWdPUEQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuU3RyZWFtLmZpbmlzaGVkID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMnKVxuU3RyZWFtLnBpcGVsaW5lID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzJylcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuJ3VzZSBzdHJpY3QnO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xuXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5cbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgfVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gSWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47IC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgZGVidWc7XG5cbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0Jyk7XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7IC8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG5cblxudmFyIFN0cmluZ0RlY29kZXI7XG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yO1xudmFyIGZyb207XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7IC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7IC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcblxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuXG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7IC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFJlYWRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5XG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IC8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTsgLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgZGVidWcoJ3JlYWRhYmxlQWRkQ2h1bmsnLCBjaHVuayk7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcblxuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQoKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSAvLyBXZSBjYW4gcHVzaCBtb3JlIGRhdGEgaWYgd2UgYXJlIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLlxuICAvLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZSBtb3JlIGJ5dGVzLlxuICAvLyBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLCBzdWNoIGFzIHRoZSByZXBsLlxuXG5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG5cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG5cbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInLCAnVWludDhBcnJheSddLCBjaHVuayk7XG4gIH1cblxuICByZXR1cm4gZXI7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHZhciBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gZGVjb2RlcjsgLy8gSWYgc2V0RW5jb2RpbmcobnVsbCksIGRlY29kZXIuZW5jb2RpbmcgZXF1YWxzIHV0ZjhcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nOyAvLyBJdGVyYXRlIG92ZXIgY3VycmVudCBidWZmZXIgdG8gY29udmVydCBhbHJlYWR5IHN0b3JlZCBCdWZmZXJzOlxuXG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICB3aGlsZSAocCAhPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShwLmRhdGEpO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuXG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG5cblxudmFyIE1BWF9IV00gPSAweDQwMDAwMDAwO1xuXG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG5cbiAgcmV0dXJuIG47XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG5cbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH0gLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG5cblxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjsgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcblxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59IC8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7IC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7IC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cblxuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfSAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG5cblxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlOyAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcblxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpO1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcblxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG5cbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAgIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH1cbiAgfVxufSAvLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuXG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcblxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9IC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZlxuICAvLyAxLiBJdCBpcyBub3QgZmxvd2luZywgYXMgdGhlIGZsb3cgbWVjaGFuaXNtIHdpbGwgdGFrZVxuICAvLyAgICBjYXJlIG9mIGl0LlxuICAvLyAyLiBJdCBpcyBub3QgZW5kZWQuXG4gIC8vIDMuIEl0IGlzIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLCBzbyB3ZSBjYW4gc2NoZWR1bGVcbiAgLy8gICAgYW5vdGhlciByZWFkYWJsZSBsYXRlci5cblxuXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgZmxvdyhzdHJlYW0pO1xufSAvLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cblxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIEF0dGVtcHQgdG8gcmVhZCBtb3JlIGRhdGEgaWYgd2Ugc2hvdWxkLlxuICAvL1xuICAvLyBUaGUgY29uZGl0aW9ucyBmb3IgcmVhZGluZyBtb3JlIGRhdGEgYXJlIChvbmUgb2YpOlxuICAvLyAtIE5vdCBlbm91Z2ggZGF0YSBidWZmZXJlZCAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykuIFRoZSBsb29wXG4gIC8vICAgaXMgcmVzcG9uc2libGUgZm9yIGZpbGxpbmcgdGhlIGJ1ZmZlciB3aXRoIGVub3VnaCBkYXRhIGlmIHN1Y2ggZGF0YVxuICAvLyAgIGlzIGF2YWlsYWJsZS4gSWYgaGlnaFdhdGVyTWFyayBpcyAwIGFuZCB3ZSBhcmUgbm90IGluIHRoZSBmbG93aW5nIG1vZGVcbiAgLy8gICB3ZSBzaG91bGQgX25vdF8gYXR0ZW1wdCB0byBidWZmZXIgYW55IGV4dHJhIGRhdGEuIFdlJ2xsIGdldCBtb3JlIGRhdGFcbiAgLy8gICB3aGVuIHRoZSBzdHJlYW0gY29uc3VtZXIgY2FsbHMgcmVhZCgpIGluc3RlYWQuXG4gIC8vIC0gTm8gZGF0YSBpbiB0aGUgYnVmZmVyLCBhbmQgdGhlIHN0cmVhbSBpcyBpbiBmbG93aW5nIG1vZGUuIEluIHRoaXMgbW9kZVxuICAvLyAgIHRoZSBsb29wIGJlbG93IGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyByZWFkKCkgaXMgY2FsbGVkLiBGYWlsaW5nIHRvXG4gIC8vICAgY2FsbCByZWFkIGhlcmUgd291bGQgYWJvcnQgdGhlIGZsb3cgYW5kIHRoZXJlJ3Mgbm8gb3RoZXIgbWVjaGFuaXNtIGZvclxuICAvLyAgIGNvbnRpbnVpbmcgdGhlIGZsb3cgaWYgdGhlIHN0cmVhbSBjb25zdW1lciBoYXMganVzdCBzdWJzY3JpYmVkIHRvIHRoZVxuICAvLyAgICdkYXRhJyBldmVudC5cbiAgLy9cbiAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGFib3ZlIGNvbmRpdGlvbnMgdG8ga2VlcCByZWFkaW5nIGRhdGEsIHRoZSBmb2xsb3dpbmdcbiAgLy8gY29uZGl0aW9ucyBwcmV2ZW50IHRoZSBkYXRhIGZyb20gYmVpbmcgcmVhZDpcbiAgLy8gLSBUaGUgc3RyZWFtIGhhcyBlbmRlZCAoc3RhdGUuZW5kZWQpLlxuICAvLyAtIFRoZXJlIGlzIGFscmVhZHkgYSBwZW5kaW5nICdyZWFkJyBvcGVyYXRpb24gKHN0YXRlLnJlYWRpbmcpLiBUaGlzIGlzIGFcbiAgLy8gICBjYXNlIHdoZXJlIHRoZSB0aGUgc3RyZWFtIGhhcyBjYWxsZWQgdGhlIGltcGxlbWVudGF0aW9uIGRlZmluZWQgX3JlYWQoKVxuICAvLyAgIG1ldGhvZCwgYnV0IHRoZXkgYXJlIHByb2Nlc3NpbmcgdGhlIGNhbGwgYXN5bmNocm9ub3VzbHkgYW5kIGhhdmUgX25vdF9cbiAgLy8gICBjYWxsZWQgcHVzaCgpIHdpdGggbmV3IGRhdGEuIEluIHRoaXMgY2FzZSB3ZSBza2lwIHBlcmZvcm1pbmcgbW9yZVxuICAvLyAgIHJlYWQoKXMuIFRoZSBleGVjdXRpb24gZW5kcyBpbiB0aGlzIG1ldGhvZCBhZ2FpbiBhZnRlciB0aGUgX3JlYWQoKSBlbmRzXG4gIC8vICAgdXAgY2FsbGluZyBwdXNoKCkgd2l0aCBtb3JlIGRhdGEuXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDApKSB7XG4gICAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59IC8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG5cbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcblxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9IC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuXG5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpOyAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7IC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgZGVidWcoJ2Rlc3Qud3JpdGUnLCByZXQpO1xuXG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICB9XG5cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfSAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuXG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpO1xuICB9IC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cblxuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTsgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcblxuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9IC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG5cblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpOyAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHtcbiAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICB9OyAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzOyAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7IC8vIGdvdCBhIG1hdGNoLlxuXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cblxuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gdXBkYXRlIHJlYWRhYmxlTGlzdGVuaW5nIHNvIHRoYXQgcmVzdW1lKCkgbWF5IGJlIGEgbm8tb3BcbiAgICAvLyBhIGZldyBsaW5lcyBkb3duLiBUaGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJykuXG4gICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwOyAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG5cbiAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGRlYnVnKCdvbiByZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUucmVhZGluZyk7XG5cbiAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2KSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYpIHtcbiAgdmFyIHN0YXRlID0gc2VsZi5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwO1xuXG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7IC8vIGNydWRlIHdheSB0byBjaGVjayBpZiB3ZSBzaG91bGQgcmVzdW1lXG4gIH0gZWxzZSBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKSB7XG4gICAgc2VsZi5yZXN1bWUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59IC8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTsgLy8gd2UgZmxvdyBvbmx5IGlmIHRoZXJlIGlzIG5vIG9uZSBsaXN0ZW5pbmdcbiAgICAvLyBmb3IgcmVhZGFibGUsIGJ1dCB3ZSBzdGlsbCBoYXZlIHRvIGNhbGxcbiAgICAvLyByZXN1bWUoKVxuXG4gICAgc3RhdGUuZmxvd2luZyA9ICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZztcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG5cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdyZXN1bWUnLCBzdGF0ZS5yZWFkaW5nKTtcblxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcblxuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7XG4gICAgO1xuICB9XG59IC8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG5cbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7IC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiBtZXRob2RXcmFwKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfSAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG5cblxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9IC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG5cblxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuXG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcyk7XG4gIH07XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pOyAvLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmZpcnN0KCk7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlTlQnLCBzdGF0ZS5lbmRFbWl0dGVkLCBzdGF0ZS5sZW5ndGgpOyAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblxuICAgICAgaWYgKCF3U3RhdGUgfHwgd1N0YXRlLmF1dG9EZXN0cm95ICYmIHdTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5mcm9tID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBvcHRzKSB7XG4gICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9mcm9tJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cblxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn0gLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cblxuXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgICBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICAgIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsgLy8gZHJhaW4gZXZlbnQgZmxhZy5cblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOyAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7IC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcblxuICB0aGlzLmVuZGVkID0gZmFsc2U7IC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cblxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcblxuICB0aGlzLmNvcmtlZCA9IDA7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7IC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcblxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9OyAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcblxuXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7IC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cblxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOyAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcblxuICB0aGlzLnBlbmRpbmdjYiA9IDA7IC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcblxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG5cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpOyAvLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cblxuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTsgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5LlxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn0gLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuXG5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKTsgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcblxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufSAvLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5cblxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIGVyO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuXG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7IC8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG5cbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59IC8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuXG5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn0gLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcblxuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG5cbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcblxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cblxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTsgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9IC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cblxuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuXG4gICAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuXG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9IC8vIHJldXNlIHRoZSBmcmVlIGNvcmtSZXEuXG5cblxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU87XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBmaW5pc2hlZCA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuXG52YXIga0xhc3RSZXNvbHZlID0gU3ltYm9sKCdsYXN0UmVzb2x2ZScpO1xudmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCdsYXN0UmVqZWN0Jyk7XG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xudmFyIGtFbmRlZCA9IFN5bWJvbCgnZW5kZWQnKTtcbnZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woJ2xhc3RQcm9taXNlJyk7XG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcbnZhciBrU3RyZWFtID0gU3ltYm9sKCdzdHJlYW0nKTtcblxuZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiBkb25lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGl0ZXIpIHtcbiAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG5cbiAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpOyAvLyB3ZSBkZWZlciBpZiBkYXRhIGlzIG51bGxcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxuICAgIC8vICdlcnJvcidcblxuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcbiAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgdGljaywgYmVjYXVzZSBpdCBtaWdodFxuICAvLyBlbWl0IGFuIGVycm9yIHdpdGggcHJvY2Vzcy5uZXh0VGlja1xuICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTtcbn1cblxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfTtcbn1cblxudmFyIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24gKCkge30pO1xudmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZigoX09iamVjdCRzZXRQcm90b3R5cGVPID0ge1xuICBnZXQgc3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzW2tTdHJlYW1dO1xuICB9LFxuXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIGlmIHdlIGhhdmUgZGV0ZWN0ZWQgYW4gZXJyb3IgaW4gdGhlIG1lYW53aGlsZVxuICAgIC8vIHJlamVjdCBzdHJhaWdodCBhd2F5XG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdmlhIG5leHRUaWNrIGJlY2F1c2UgaWYgLmRlc3Ryb3koZXJyKSBpc1xuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXG4gICAgICAvLyB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgbm8gZXJyb3IgbGluZ2VyaW5nIGFyb3VuZFxuICAgICAgLy8gd2FpdGluZyB0byBiZSBlbWl0dGVkLlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHtcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIGlmIHdlIGhhdmUgbXVsdGlwbGUgbmV4dCgpIGNhbGxzXG4gICAgLy8gd2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgUHJvbWlzZSB0byBmaW5pc2hcbiAgICAvLyB0aGlzIGxvZ2ljIGlzIG9wdGltaXplZCB0byBzdXBwb3J0IGZvciBhd2FpdCBsb29wcyxcbiAgICAvLyB3aGVyZSBuZXh0KCkgaXMgb25seSBjYWxsZWQgb25jZSBhdCBhIHRpbWVcblxuXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xuICAgIHZhciBwcm9taXNlO1xuXG4gICAgaWYgKGxhc3RQcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFzdCBwYXRoIG5lZWRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHRoaXMucHVzaCgpXG4gICAgICAvLyB3aXRob3V0IHRyaWdnZXJpbmcgdGhlIG5leHQoKSBxdWV1ZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzW2tIYW5kbGVQcm9taXNlXSk7XG4gICAgfVxuXG4gICAgdGhpc1trTGFzdFByb21pc2VdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgXCJyZXR1cm5cIiwgZnVuY3Rpb24gX3JldHVybigpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgLy8gZGVzdHJveShlcnIsIGNiKSBpcyBhIHByaXZhdGUgQVBJXG4gIC8vIHdlIGNhbiBndWFyYW50ZWUgd2UgaGF2ZSB0aGF0IGhlcmUsIGJlY2F1c2Ugd2UgY29udHJvbCB0aGVcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcbn0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcblxudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0pIHtcbiAgdmFyIF9PYmplY3QkY3JlYXRlO1xuXG4gIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgdmFsdWU6IHN0cmVhbSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfT2JqZWN0JGNyZWF0ZSkpO1xuICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTsgLy8gcmVqZWN0IGlmIHdlIGFyZSB3YWl0aW5nIGZvciBkYXRhIGluIHRoZSBQcm9taXNlXG4gICAgICAvLyByZXR1cm5lZCBieSBuZXh0KCkgYW5kIHN0b3JlIHRoZSBlcnJvclxuXG4gICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmUgPSBpdGVyYXRvcltrTGFzdFJlc29sdmVdO1xuXG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICByZXR1cm4gaXRlcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjsiLCIndXNlIHN0cmljdCc7IC8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcblxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9IC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcblxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGVtaXRDbG9zZU5UKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUgJiYgIXNlbGYuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIGlmIChzZWxmLl9yZWFkYWJsZVN0YXRlICYmICFzZWxmLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cbiAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHJTdGF0ZSAmJiByU3RhdGUuYXV0b0Rlc3Ryb3kgfHwgd1N0YXRlICYmIHdTdGF0ZS5hdXRvRGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koZXJyKTtlbHNlIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3k6IGVycm9yT3JEZXN0cm95XG59OyIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc0FyZ3VtZW50c09iamVjdCA9IHJlcXVpcmUoJ2lzLWFyZ3VtZW50cycpO1xudmFyIGlzR2VuZXJhdG9yRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1nZW5lcmF0b3ItZnVuY3Rpb24nKTtcbnZhciB3aGljaFR5cGVkQXJyYXkgPSByZXF1aXJlKCd3aGljaC10eXBlZC1hcnJheScpO1xudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgQmlnSW50U3VwcG9ydGVkID0gdHlwZW9mIEJpZ0ludCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgU3ltYm9sU3VwcG9ydGVkID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBPYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgbnVtYmVyVmFsdWUgPSB1bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIHN0cmluZ1ZhbHVlID0gdW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBib29sZWFuVmFsdWUgPSB1bmN1cnJ5VGhpcyhCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mKTtcblxuaWYgKEJpZ0ludFN1cHBvcnRlZCkge1xuICB2YXIgYmlnSW50VmFsdWUgPSB1bmN1cnJ5VGhpcyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5pZiAoU3ltYm9sU3VwcG9ydGVkKSB7XG4gIHZhciBzeW1ib2xWYWx1ZSA9IHVuY3VycnlUaGlzKFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHByb3RvdHlwZVZhbHVlT2YpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBwcm90b3R5cGVWYWx1ZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydHMuaXNBcmd1bWVudHNPYmplY3QgPSBpc0FyZ3VtZW50c09iamVjdDtcbmV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGlzR2VuZXJhdG9yRnVuY3Rpb247XG5leHBvcnRzLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcblxuLy8gVGFrZW4gZnJvbSBoZXJlIGFuZCBtb2RpZmllZCBmb3IgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9wLWlzLXByb21pc2UvYmxvYi9jZGEzNWE1MTNiZGEwM2Y5NzdhZDVjZGUzYTA3OWQyMzdlODJkN2VmL2luZGV4LmpzXG5mdW5jdGlvbiBpc1Byb21pc2UoaW5wdXQpIHtcblx0cmV0dXJuIChcblx0XHQoXG5cdFx0XHR0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZVxuXHRcdCkgfHxcblx0XHQoXG5cdFx0XHRpbnB1dCAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LnRoZW4gPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdClcblx0KTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgaXNUeXBlZEFycmF5KHZhbHVlKSB8fFxuICAgIGlzRGF0YVZpZXcodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXJWaWV3ID0gaXNBcnJheUJ1ZmZlclZpZXc7XG5cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhBcnJheSA9IGlzVWludDhBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4Q2xhbXBlZEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OENsYW1wZWRBcnJheSA9IGlzVWludDhDbGFtcGVkQXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDE2QXJyYXkgPSBpc1VpbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQzMkFycmF5ID0gaXNVaW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDhBcnJheSA9IGlzSW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQxNkFycmF5ID0gaXNJbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQzMkFycmF5ID0gaXNJbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0MzJBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQzMkFycmF5ID0gaXNGbG9hdDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDY0QXJyYXkgPSBpc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnSW50NjRBcnJheSA9IGlzQmlnSW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ1VpbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdVaW50NjRBcnJheSA9IGlzQmlnVWludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwXSc7XG59XG5pc01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzTWFwVG9TdHJpbmcobmV3IE1hcCgpKVxuKTtcblxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgTWFwO1xufVxuZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xuXG5mdW5jdGlvbiBpc1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldF0nO1xufVxuaXNTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1NldFRvU3RyaW5nKG5ldyBTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NldFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTZXQ7XG59XG5leHBvcnRzLmlzU2V0ID0gaXNTZXQ7XG5cbmZ1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtNYXBdJztcbn1cbmlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBXZWFrTWFwO1xufVxuZXhwb3J0cy5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG5cbmZ1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtTZXRdJztcbn1cbmlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpO1xufVxuZXhwb3J0cy5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBBcnJheUJ1ZmZlcigpKVxuKTtcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0YVZpZXddJztcbn1cbmlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksIDAsIDEpKVxuKTtcbmZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXc7XG59XG5leHBvcnRzLmlzRGF0YVZpZXcgPSBpc0RhdGFWaWV3O1xuXG4vLyBTdG9yZSBhIGNvcHkgb2YgU2hhcmVkQXJyYXlCdWZmZXIgaW4gY2FzZSBpdCdzIGRlbGV0ZWQgZWxzZXdoZXJlXG52YXIgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IFNoYXJlZEFycmF5QnVmZmVyIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSc7XG59XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcobmV3IFNoYXJlZEFycmF5QnVmZmVyQ29weSgpKTtcbiAgfVxuXG4gIHJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHk7XG59XG5leHBvcnRzLmlzU2hhcmVkQXJyYXlCdWZmZXIgPSBpc1NoYXJlZEFycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nO1xufVxuZXhwb3J0cy5pc0FzeW5jRnVuY3Rpb24gPSBpc0FzeW5jRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzTWFwSXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzTWFwSXRlcmF0b3IgPSBpc01hcEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc1NldEl0ZXJhdG9yID0gaXNTZXRJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzR2VuZXJhdG9yT2JqZWN0ID0gaXNHZW5lcmF0b3JPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdJztcbn1cbmV4cG9ydHMuaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlID0gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlO1xuXG5mdW5jdGlvbiBpc051bWJlck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgbnVtYmVyVmFsdWUpO1xufVxuZXhwb3J0cy5pc051bWJlck9iamVjdCA9IGlzTnVtYmVyT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3RyaW5nVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N0cmluZ09iamVjdCA9IGlzU3RyaW5nT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJvb2xlYW5WYWx1ZSk7XG59XG5leHBvcnRzLmlzQm9vbGVhbk9iamVjdCA9IGlzQm9vbGVhbk9iamVjdDtcblxuZnVuY3Rpb24gaXNCaWdJbnRPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ0ludFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBiaWdJbnRWYWx1ZSk7XG59XG5leHBvcnRzLmlzQmlnSW50T2JqZWN0ID0gaXNCaWdJbnRPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBTeW1ib2xTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3ltYm9sVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N5bWJvbE9iamVjdCA9IGlzU3ltYm9sT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgaXNOdW1iZXJPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTdHJpbmdPYmplY3QodmFsdWUpIHx8XG4gICAgaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3ltYm9sT2JqZWN0KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0JveGVkUHJpbWl0aXZlID0gaXNCb3hlZFByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc0FycmF5QnVmZmVyKHZhbHVlKSB8fFxuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQW55QXJyYXlCdWZmZXIgPSBpc0FueUFycmF5QnVmZmVyO1xuXG5bJ2lzUHJveHknLCAnaXNFeHRlcm5hbCcsICdpc01vZHVsZU5hbWVzcGFjZU9iamVjdCddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBtZXRob2QsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIHVzZXJsYW5kJyk7XG4gICAgfVxuICB9KTtcbn0pO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0VudlJlZ2V4ID0gL14kLztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpIHtcbiAgdmFyIGRlYnVnRW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRztcbiAgZGVidWdFbnYgPSBkZWJ1Z0Vudi5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLCAnXFxcXCQmJylcbiAgICAucmVwbGFjZSgvXFwqL2csICcuKicpXG4gICAgLnJlcGxhY2UoLywvZywgJyR8XicpXG4gICAgLnRvVXBwZXJDYXNlKCk7XG4gIGRlYnVnRW52UmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGRlYnVnRW52ICsgJyQnLCAnaScpO1xufVxuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChkZWJ1Z0VudlJlZ2V4LnRlc3Qoc2V0KSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5leHBvcnRzLnR5cGVzID0gcmVxdWlyZSgnLi9zdXBwb3J0L3R5cGVzJyk7XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5leHBvcnRzLnR5cGVzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZXhwb3J0cy50eXBlcy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmV4cG9ydHMudHlwZXMuaXNOYXRpdmVFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsIG51bGwsIHJldCkpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLCByZWosIGNiKSkgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gcmVxdWlyZSgnYXZhaWxhYmxlLXR5cGVkLWFycmF5cycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gcmVxdWlyZSgnaGFzLXRvc3RyaW5ndGFnL3NoYW1zJykoKTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiBnbG9iYWxUaGlzO1xudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRzbGljZSA9IGNhbGxCb3VuZCgnU3RyaW5nLnByb3RvdHlwZS5zbGljZScpO1xudmFyIHRvU3RyVGFncyA9IHt9O1xudmFyIGdPUEQgPSByZXF1aXJlKCdlcy1hYnN0cmFjdC9oZWxwZXJzL2dldE93blByb3BlcnR5RGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mOyAvLyByZXF1aXJlKCdnZXRwcm90b3R5cGVvZicpO1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHRpZiAodHlwZW9mIGdbdHlwZWRBcnJheV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdFx0aWYgKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBhcnIpIHtcblx0XHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRvU3RyVGFnc1t0eXBlZEFycmF5XSA9IGRlc2NyaXB0b3IuZ2V0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZE5hbWUgPSBmYWxzZTtcblx0Zm9yRWFjaCh0b1N0clRhZ3MsIGZ1bmN0aW9uIChnZXR0ZXIsIHR5cGVkQXJyYXkpIHtcblx0XHRpZiAoIWZvdW5kTmFtZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIG5hbWUgPSBnZXR0ZXIuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmIChuYW1lID09PSB0eXBlZEFycmF5KSB7XG5cdFx0XHRcdFx0Zm91bmROYW1lID0gbmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmROYW1lO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkLWFycmF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghaXNUeXBlZEFycmF5KHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZyB8fCAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkpIHsgcmV0dXJuICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7IH1cblx0cmV0dXJuIHRyeVR5cGVkQXJyYXlzKHZhbHVlKTtcbn07XG4iXX0=
